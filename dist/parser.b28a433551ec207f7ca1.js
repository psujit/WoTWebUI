webpackJsonp([2],{16:function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},17:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (f) {\n    if (( false ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f();\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        var g;if (typeof window !== \"undefined\") {\n            g = window;\n        } else if (typeof global !== \"undefined\") {\n            g = global;\n        } else if (typeof self !== \"undefined\") {\n            g = self;\n        } else {\n            g = this;\n        }g.parser = f();\n    }\n})(function () {\n    var define, module, exports;return function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }({ 1: [function (require, module, exports) {\n            (function (global) {\n                /*! https://mths.be/punycode v1.4.1 by @mathias */\n                ;(function (root) {\n\n                    /** Detect free variables */\n                    var freeExports = (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n                    var freeModule = (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) == 'object' && module && !module.nodeType && module;\n                    var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global;\n                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n                        root = freeGlobal;\n                    }\n\n                    /**\n                     * The `punycode` object.\n                     * @name punycode\n                     * @type Object\n                     */\n                    var punycode,\n\n\n                    /** Highest positive signed 32-bit float value */\n                    maxInt = 2147483647,\n                        // aka. 0x7FFFFFFF or 2^31-1\n\n                    /** Bootstring parameters */\n                    base = 36,\n                        tMin = 1,\n                        tMax = 26,\n                        skew = 38,\n                        damp = 700,\n                        initialBias = 72,\n                        initialN = 128,\n                        // 0x80\n                    delimiter = '-',\n                        // '\\x2D'\n\n                    /** Regular expressions */\n                    regexPunycode = /^xn--/,\n                        regexNonASCII = /[^\\x20-\\x7E]/,\n                        // unprintable ASCII chars + non-ASCII chars\n                    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                        // RFC 3490 separators\n\n                    /** Error messages */\n                    errors = {\n                        'overflow': 'Overflow: input needs wider integers to process',\n                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n                        'invalid-input': 'Invalid input'\n                    },\n\n\n                    /** Convenience shortcuts */\n                    baseMinusTMin = base - tMin,\n                        floor = Math.floor,\n                        stringFromCharCode = String.fromCharCode,\n\n\n                    /** Temporary variable */\n                    key;\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /**\n                     * A generic error utility function.\n                     * @private\n                     * @param {String} type The error type.\n                     * @returns {Error} Throws a `RangeError` with the applicable error message.\n                     */\n                    function error(type) {\n                        throw new RangeError(errors[type]);\n                    }\n\n                    /**\n                     * A generic `Array#map` utility function.\n                     * @private\n                     * @param {Array} array The array to iterate over.\n                     * @param {Function} callback The function that gets called for every array\n                     * item.\n                     * @returns {Array} A new array of values returned by the callback function.\n                     */\n                    function map(array, fn) {\n                        var length = array.length;\n                        var result = [];\n                        while (length--) {\n                            result[length] = fn(array[length]);\n                        }\n                        return result;\n                    }\n\n                    /**\n                     * A simple `Array#map`-like wrapper to work with domain name strings or email\n                     * addresses.\n                     * @private\n                     * @param {String} domain The domain name or email address.\n                     * @param {Function} callback The function that gets called for every\n                     * character.\n                     * @returns {Array} A new string of characters returned by the callback\n                     * function.\n                     */\n                    function mapDomain(string, fn) {\n                        var parts = string.split('@');\n                        var result = '';\n                        if (parts.length > 1) {\n                            // In email addresses, only the domain name should be punycoded. Leave\n                            // the local part (i.e. everything up to `@`) intact.\n                            result = parts[0] + '@';\n                            string = parts[1];\n                        }\n                        // Avoid `split(regex)` for IE8 compatibility. See #17.\n                        string = string.replace(regexSeparators, '\\x2E');\n                        var labels = string.split('.');\n                        var encoded = map(labels, fn).join('.');\n                        return result + encoded;\n                    }\n\n                    /**\n                     * Creates an array containing the numeric code points of each Unicode\n                     * character in the string. While JavaScript uses UCS-2 internally,\n                     * this function will convert a pair of surrogate halves (each of which\n                     * UCS-2 exposes as separate characters) into a single code point,\n                     * matching UTF-16.\n                     * @see `punycode.ucs2.encode`\n                     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                     * @memberOf punycode.ucs2\n                     * @name decode\n                     * @param {String} string The Unicode input string (UCS-2).\n                     * @returns {Array} The new array of code points.\n                     */\n                    function ucs2decode(string) {\n                        var output = [],\n                            counter = 0,\n                            length = string.length,\n                            value,\n                            extra;\n                        while (counter < length) {\n                            value = string.charCodeAt(counter++);\n                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                                // high surrogate, and there is a next character\n                                extra = string.charCodeAt(counter++);\n                                if ((extra & 0xFC00) == 0xDC00) {\n                                    // low surrogate\n                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                                } else {\n                                    // unmatched surrogate; only append this code unit, in case the next\n                                    // code unit is the high surrogate of a surrogate pair\n                                    output.push(value);\n                                    counter--;\n                                }\n                            } else {\n                                output.push(value);\n                            }\n                        }\n                        return output;\n                    }\n\n                    /**\n                     * Creates a string based on an array of numeric code points.\n                     * @see `punycode.ucs2.decode`\n                     * @memberOf punycode.ucs2\n                     * @name encode\n                     * @param {Array} codePoints The array of numeric code points.\n                     * @returns {String} The new Unicode string (UCS-2).\n                     */\n                    function ucs2encode(array) {\n                        return map(array, function (value) {\n                            var output = '';\n                            if (value > 0xFFFF) {\n                                value -= 0x10000;\n                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                                value = 0xDC00 | value & 0x3FF;\n                            }\n                            output += stringFromCharCode(value);\n                            return output;\n                        }).join('');\n                    }\n\n                    /**\n                     * Converts a basic code point into a digit/integer.\n                     * @see `digitToBasic()`\n                     * @private\n                     * @param {Number} codePoint The basic numeric code point value.\n                     * @returns {Number} The numeric value of a basic code point (for use in\n                     * representing integers) in the range `0` to `base - 1`, or `base` if\n                     * the code point does not represent a value.\n                     */\n                    function basicToDigit(codePoint) {\n                        if (codePoint - 48 < 10) {\n                            return codePoint - 22;\n                        }\n                        if (codePoint - 65 < 26) {\n                            return codePoint - 65;\n                        }\n                        if (codePoint - 97 < 26) {\n                            return codePoint - 97;\n                        }\n                        return base;\n                    }\n\n                    /**\n                     * Converts a digit/integer into a basic code point.\n                     * @see `basicToDigit()`\n                     * @private\n                     * @param {Number} digit The numeric value of a basic code point.\n                     * @returns {Number} The basic code point whose value (when used for\n                     * representing integers) is `digit`, which needs to be in the range\n                     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n                     * used; else, the lowercase form is used. The behavior is undefined\n                     * if `flag` is non-zero and `digit` has no uppercase form.\n                     */\n                    function digitToBasic(digit, flag) {\n                        //  0..25 map to ASCII a..z or A..Z\n                        // 26..35 map to ASCII 0..9\n                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n                    }\n\n                    /**\n                     * Bias adaptation function as per section 3.4 of RFC 3492.\n                     * https://tools.ietf.org/html/rfc3492#section-3.4\n                     * @private\n                     */\n                    function adapt(delta, numPoints, firstTime) {\n                        var k = 0;\n                        delta = firstTime ? floor(delta / damp) : delta >> 1;\n                        delta += floor(delta / numPoints);\n                        for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n                            delta = floor(delta / baseMinusTMin);\n                        }\n                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n                    }\n\n                    /**\n                     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n                     * symbols.\n                     * @memberOf punycode\n                     * @param {String} input The Punycode string of ASCII-only symbols.\n                     * @returns {String} The resulting string of Unicode symbols.\n                     */\n                    function decode(input) {\n                        // Don't use UCS-2\n                        var output = [],\n                            inputLength = input.length,\n                            out,\n                            i = 0,\n                            n = initialN,\n                            bias = initialBias,\n                            basic,\n                            j,\n                            index,\n                            oldi,\n                            w,\n                            k,\n                            digit,\n                            t,\n\n                        /** Cached calculation results */\n                        baseMinusT;\n\n                        // Handle the basic code points: let `basic` be the number of input code\n                        // points before the last delimiter, or `0` if there is none, then copy\n                        // the first basic code points to the output.\n\n                        basic = input.lastIndexOf(delimiter);\n                        if (basic < 0) {\n                            basic = 0;\n                        }\n\n                        for (j = 0; j < basic; ++j) {\n                            // if it's not a basic code point\n                            if (input.charCodeAt(j) >= 0x80) {\n                                error('not-basic');\n                            }\n                            output.push(input.charCodeAt(j));\n                        }\n\n                        // Main decoding loop: start just after the last delimiter if any basic code\n                        // points were copied; start at the beginning otherwise.\n\n                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n                            // `index` is the index of the next character to be consumed.\n                            // Decode a generalized variable-length integer into `delta`,\n                            // which gets added to `i`. The overflow checking is easier\n                            // if we increase `i` as we go, then subtract off its starting\n                            // value at the end to obtain `delta`.\n                            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\n                                if (index >= inputLength) {\n                                    error('invalid-input');\n                                }\n\n                                digit = basicToDigit(input.charCodeAt(index++));\n\n                                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                                    error('overflow');\n                                }\n\n                                i += digit * w;\n                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                                if (digit < t) {\n                                    break;\n                                }\n\n                                baseMinusT = base - t;\n                                if (w > floor(maxInt / baseMinusT)) {\n                                    error('overflow');\n                                }\n\n                                w *= baseMinusT;\n                            }\n\n                            out = output.length + 1;\n                            bias = adapt(i - oldi, out, oldi == 0);\n\n                            // `i` was supposed to wrap around from `out` to `0`,\n                            // incrementing `n` each time, so we'll fix that now:\n                            if (floor(i / out) > maxInt - n) {\n                                error('overflow');\n                            }\n\n                            n += floor(i / out);\n                            i %= out;\n\n                            // Insert `n` at position `i` of the output\n                            output.splice(i++, 0, n);\n                        }\n\n                        return ucs2encode(output);\n                    }\n\n                    /**\n                     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n                     * Punycode string of ASCII-only symbols.\n                     * @memberOf punycode\n                     * @param {String} input The string of Unicode symbols.\n                     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n                     */\n                    function encode(input) {\n                        var n,\n                            delta,\n                            handledCPCount,\n                            basicLength,\n                            bias,\n                            j,\n                            m,\n                            q,\n                            k,\n                            t,\n                            currentValue,\n                            output = [],\n\n                        /** `inputLength` will hold the number of code points in `input`. */\n                        inputLength,\n\n                        /** Cached calculation results */\n                        handledCPCountPlusOne,\n                            baseMinusT,\n                            qMinusT;\n\n                        // Convert the input in UCS-2 to Unicode\n                        input = ucs2decode(input);\n\n                        // Cache the length\n                        inputLength = input.length;\n\n                        // Initialize the state\n                        n = initialN;\n                        delta = 0;\n                        bias = initialBias;\n\n                        // Handle the basic code points\n                        for (j = 0; j < inputLength; ++j) {\n                            currentValue = input[j];\n                            if (currentValue < 0x80) {\n                                output.push(stringFromCharCode(currentValue));\n                            }\n                        }\n\n                        handledCPCount = basicLength = output.length;\n\n                        // `handledCPCount` is the number of code points that have been handled;\n                        // `basicLength` is the number of basic code points.\n\n                        // Finish the basic string - if it is not empty - with a delimiter\n                        if (basicLength) {\n                            output.push(delimiter);\n                        }\n\n                        // Main encoding loop:\n                        while (handledCPCount < inputLength) {\n\n                            // All non-basic code points < n have been handled already. Find the next\n                            // larger one:\n                            for (m = maxInt, j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n                                if (currentValue >= n && currentValue < m) {\n                                    m = currentValue;\n                                }\n                            }\n\n                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                            // but guard against overflow\n                            handledCPCountPlusOne = handledCPCount + 1;\n                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                                error('overflow');\n                            }\n\n                            delta += (m - n) * handledCPCountPlusOne;\n                            n = m;\n\n                            for (j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n\n                                if (currentValue < n && ++delta > maxInt) {\n                                    error('overflow');\n                                }\n\n                                if (currentValue == n) {\n                                    // Represent delta as a generalized variable-length integer\n                                    for (q = delta, k = base;; /* no condition */k += base) {\n                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                                        if (q < t) {\n                                            break;\n                                        }\n                                        qMinusT = q - t;\n                                        baseMinusT = base - t;\n                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                                        q = floor(qMinusT / baseMinusT);\n                                    }\n\n                                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                                    delta = 0;\n                                    ++handledCPCount;\n                                }\n                            }\n\n                            ++delta;\n                            ++n;\n                        }\n                        return output.join('');\n                    }\n\n                    /**\n                     * Converts a Punycode string representing a domain name or an email address\n                     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n                     * it doesn't matter if you call it on a string that has already been\n                     * converted to Unicode.\n                     * @memberOf punycode\n                     * @param {String} input The Punycoded domain name or email address to\n                     * convert to Unicode.\n                     * @returns {String} The Unicode representation of the given Punycode\n                     * string.\n                     */\n                    function toUnicode(input) {\n                        return mapDomain(input, function (string) {\n                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n                        });\n                    }\n\n                    /**\n                     * Converts a Unicode string representing a domain name or an email address to\n                     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n                     * i.e. it doesn't matter if you call it with a domain that's already in\n                     * ASCII.\n                     * @memberOf punycode\n                     * @param {String} input The domain name or email address to convert, as a\n                     * Unicode string.\n                     * @returns {String} The Punycode representation of the given domain name or\n                     * email address.\n                     */\n                    function toASCII(input) {\n                        return mapDomain(input, function (string) {\n                            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n                        });\n                    }\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /** Define the public API */\n                    punycode = {\n                        /**\n                         * A string representing the current Punycode.js version number.\n                         * @memberOf punycode\n                         * @type String\n                         */\n                        'version': '1.4.1',\n                        /**\n                         * An object of methods to convert from JavaScript's internal character\n                         * representation (UCS-2) to Unicode code points, and back.\n                         * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                         * @memberOf punycode\n                         * @type Object\n                         */\n                        'ucs2': {\n                            'decode': ucs2decode,\n                            'encode': ucs2encode\n                        },\n                        'decode': decode,\n                        'encode': encode,\n                        'toASCII': toASCII,\n                        'toUnicode': toUnicode\n                    };\n\n                    /** Expose `punycode` */\n                    // Some AMD build optimizers, like r.js, check for specific condition patterns\n                    // like the following:\n                    if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n                        define('punycode', function () {\n                            return punycode;\n                        });\n                    } else if (freeExports && freeModule) {\n                        if (module.exports == freeExports) {\n                            // in Node.js, io.js, or RingoJS v0.8.0+\n                            freeModule.exports = punycode;\n                        } else {\n                            // in Narwhal or RingoJS v0.7.0-\n                            for (key in punycode) {\n                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n                            }\n                        }\n                    } else {\n                        // in Rhino or a web browser\n                        root.punycode = punycode;\n                    }\n                })(this);\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 2: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            // If obj.hasOwnProperty has been overridden, then calling\n            // obj.hasOwnProperty(prop) will break.\n            // See: https://github.com/joyent/node/issues/1707\n\n            function hasOwnProperty(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            }\n\n            module.exports = function (qs, sep, eq, options) {\n                sep = sep || '&';\n                eq = eq || '=';\n                var obj = {};\n\n                if (typeof qs !== 'string' || qs.length === 0) {\n                    return obj;\n                }\n\n                var regexp = /\\+/g;\n                qs = qs.split(sep);\n\n                var maxKeys = 1000;\n                if (options && typeof options.maxKeys === 'number') {\n                    maxKeys = options.maxKeys;\n                }\n\n                var len = qs.length;\n                // maxKeys <= 0 means that we should not limit keys count\n                if (maxKeys > 0 && len > maxKeys) {\n                    len = maxKeys;\n                }\n\n                for (var i = 0; i < len; ++i) {\n                    var x = qs[i].replace(regexp, '%20'),\n                        idx = x.indexOf(eq),\n                        kstr,\n                        vstr,\n                        k,\n                        v;\n\n                    if (idx >= 0) {\n                        kstr = x.substr(0, idx);\n                        vstr = x.substr(idx + 1);\n                    } else {\n                        kstr = x;\n                        vstr = '';\n                    }\n\n                    k = decodeURIComponent(kstr);\n                    v = decodeURIComponent(vstr);\n\n                    if (!hasOwnProperty(obj, k)) {\n                        obj[k] = v;\n                    } else if (isArray(obj[k])) {\n                        obj[k].push(v);\n                    } else {\n                        obj[k] = [obj[k], v];\n                    }\n                }\n\n                return obj;\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n        }, {}], 3: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var stringifyPrimitive = function stringifyPrimitive(v) {\n                switch (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) {\n                    case 'string':\n                        return v;\n\n                    case 'boolean':\n                        return v ? 'true' : 'false';\n\n                    case 'number':\n                        return isFinite(v) ? v : '';\n\n                    default:\n                        return '';\n                }\n            };\n\n            module.exports = function (obj, sep, eq, name) {\n                sep = sep || '&';\n                eq = eq || '=';\n                if (obj === null) {\n                    obj = undefined;\n                }\n\n                if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n                    return map(objectKeys(obj), function (k) {\n                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n                        if (isArray(obj[k])) {\n                            return map(obj[k], function (v) {\n                                return ks + encodeURIComponent(stringifyPrimitive(v));\n                            }).join(sep);\n                        } else {\n                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n                        }\n                    }).join(sep);\n                }\n\n                if (!name) return '';\n                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n\n            function map(xs, f) {\n                if (xs.map) return xs.map(f);\n                var res = [];\n                for (var i = 0; i < xs.length; i++) {\n                    res.push(f(xs[i], i));\n                }\n                return res;\n            }\n\n            var objectKeys = Object.keys || function (obj) {\n                var res = [];\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n                }\n                return res;\n            };\n        }, {}], 4: [function (require, module, exports) {\n            'use strict';\n\n            exports.decode = exports.parse = require('./decode');\n            exports.encode = exports.stringify = require('./encode');\n        }, { \"./decode\": 2, \"./encode\": 3 }], 5: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var punycode = require('punycode');\n            var util = require('./util');\n\n            exports.parse = urlParse;\n            exports.resolve = urlResolve;\n            exports.resolveObject = urlResolveObject;\n            exports.format = urlFormat;\n\n            exports.Url = Url;\n\n            function Url() {\n                this.protocol = null;\n                this.slashes = null;\n                this.auth = null;\n                this.host = null;\n                this.port = null;\n                this.hostname = null;\n                this.hash = null;\n                this.search = null;\n                this.query = null;\n                this.pathname = null;\n                this.path = null;\n                this.href = null;\n            }\n\n            // Reference: RFC 3986, RFC 1808, RFC 2396\n\n            // define these here so at least they only have to be\n            // compiled once on the first module load.\n            var protocolPattern = /^([a-z0-9.+-]+:)/i,\n                portPattern = /:[0-9]*$/,\n\n\n            // Special case for a simple path URL\n            simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n\n            // RFC 2396: characters reserved for delimiting URLs.\n            // We actually just auto-escape these.\n            delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n\n            // RFC 2396: characters not allowed for various reasons.\n            unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n\n            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n            autoEscape = ['\\''].concat(unwise),\n\n            // Characters that are never ever allowed in a hostname.\n            // Note that any invalid chars are also handled, but these\n            // are the ones that are *expected* to be seen, so we fast-path\n            // them.\n            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n                hostEndingChars = ['/', '?', '#'],\n                hostnameMaxLen = 255,\n                hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n\n            // protocols that can allow \"unsafe\" and \"unwise\" chars.\n            unsafeProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that never have a hostname.\n            hostlessProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that always contain a // bit.\n            slashedProtocol = {\n                'http': true,\n                'https': true,\n                'ftp': true,\n                'gopher': true,\n                'file': true,\n                'http:': true,\n                'https:': true,\n                'ftp:': true,\n                'gopher:': true,\n                'file:': true\n            },\n                querystring = require('querystring');\n\n            function urlParse(url, parseQueryString, slashesDenoteHost) {\n                if (url && util.isObject(url) && url instanceof Url) return url;\n\n                var u = new Url();\n                u.parse(url, parseQueryString, slashesDenoteHost);\n                return u;\n            }\n\n            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n                if (!util.isString(url)) {\n                    throw new TypeError(\"Parameter 'url' must be a string, not \" + (typeof url === \"undefined\" ? \"undefined\" : _typeof(url)));\n                }\n\n                // Copy chrome, IE, opera backslash-handling behavior.\n                // Back slashes before the query string get converted to forward slashes\n                // See: https://code.google.com/p/chromium/issues/detail?id=25916\n                var queryIndex = url.indexOf('?'),\n                    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n                    uSplit = url.split(splitter),\n                    slashRegex = /\\\\/g;\n                uSplit[0] = uSplit[0].replace(slashRegex, '/');\n                url = uSplit.join(splitter);\n\n                var rest = url;\n\n                // trim before proceeding.\n                // This is to support parse stuff like \"  http://foo.com  \\n\"\n                rest = rest.trim();\n\n                if (!slashesDenoteHost && url.split('#').length === 1) {\n                    // Try fast path regexp\n                    var simplePath = simplePathPattern.exec(rest);\n                    if (simplePath) {\n                        this.path = rest;\n                        this.href = rest;\n                        this.pathname = simplePath[1];\n                        if (simplePath[2]) {\n                            this.search = simplePath[2];\n                            if (parseQueryString) {\n                                this.query = querystring.parse(this.search.substr(1));\n                            } else {\n                                this.query = this.search.substr(1);\n                            }\n                        } else if (parseQueryString) {\n                            this.search = '';\n                            this.query = {};\n                        }\n                        return this;\n                    }\n                }\n\n                var proto = protocolPattern.exec(rest);\n                if (proto) {\n                    proto = proto[0];\n                    var lowerProto = proto.toLowerCase();\n                    this.protocol = lowerProto;\n                    rest = rest.substr(proto.length);\n                }\n\n                // figure out if it's got a host\n                // user@server is *always* interpreted as a hostname, and url\n                // resolution will treat //foo/bar as host=foo,path=bar because that's\n                // how the browser resolves relative URLs.\n                if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n                    var slashes = rest.substr(0, 2) === '//';\n                    if (slashes && !(proto && hostlessProtocol[proto])) {\n                        rest = rest.substr(2);\n                        this.slashes = true;\n                    }\n                }\n\n                if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n\n                    // there's a hostname.\n                    // the first instance of /, ?, ;, or # ends the host.\n                    //\n                    // If there is an @ in the hostname, then non-host chars *are* allowed\n                    // to the left of the last @ sign, unless some host-ending character\n                    // comes *before* the @-sign.\n                    // URLs are obnoxious.\n                    //\n                    // ex:\n                    // http://a@b@c/ => user:a@b host:c\n                    // http://a@b?@c => user:a host:c path:/?@c\n\n                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n                    // Review our test case against browsers more comprehensively.\n\n                    // find the first instance of any hostEndingChars\n                    var hostEnd = -1;\n                    for (var i = 0; i < hostEndingChars.length; i++) {\n                        var hec = rest.indexOf(hostEndingChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n\n                    // at this point, either we have an explicit point where the\n                    // auth portion cannot go past, or the last @ char is the decider.\n                    var auth, atSign;\n                    if (hostEnd === -1) {\n                        // atSign can be anywhere.\n                        atSign = rest.lastIndexOf('@');\n                    } else {\n                        // atSign must be in auth portion.\n                        // http://a@b/c@d => host:b auth:a path:/c@d\n                        atSign = rest.lastIndexOf('@', hostEnd);\n                    }\n\n                    // Now we have a portion which is definitely the auth.\n                    // Pull that off.\n                    if (atSign !== -1) {\n                        auth = rest.slice(0, atSign);\n                        rest = rest.slice(atSign + 1);\n                        this.auth = decodeURIComponent(auth);\n                    }\n\n                    // the host is the remaining to the left of the first non-host char\n                    hostEnd = -1;\n                    for (var i = 0; i < nonHostChars.length; i++) {\n                        var hec = rest.indexOf(nonHostChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n                    // if we still have not hit it, then the entire thing is a host.\n                    if (hostEnd === -1) hostEnd = rest.length;\n\n                    this.host = rest.slice(0, hostEnd);\n                    rest = rest.slice(hostEnd);\n\n                    // pull out port.\n                    this.parseHost();\n\n                    // we've indicated that there is a hostname,\n                    // so even if it's empty, it has to be present.\n                    this.hostname = this.hostname || '';\n\n                    // if hostname begins with [ and ends with ]\n                    // assume that it's an IPv6 address.\n                    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n                    // validate a little.\n                    if (!ipv6Hostname) {\n                        var hostparts = this.hostname.split(/\\./);\n                        for (var i = 0, l = hostparts.length; i < l; i++) {\n                            var part = hostparts[i];\n                            if (!part) continue;\n                            if (!part.match(hostnamePartPattern)) {\n                                var newpart = '';\n                                for (var j = 0, k = part.length; j < k; j++) {\n                                    if (part.charCodeAt(j) > 127) {\n                                        // we replace non-ASCII char with a temporary placeholder\n                                        // we need this to make sure size of hostname is not\n                                        // broken by replacing non-ASCII by nothing\n                                        newpart += 'x';\n                                    } else {\n                                        newpart += part[j];\n                                    }\n                                }\n                                // we test again with ASCII char only\n                                if (!newpart.match(hostnamePartPattern)) {\n                                    var validParts = hostparts.slice(0, i);\n                                    var notHost = hostparts.slice(i + 1);\n                                    var bit = part.match(hostnamePartStart);\n                                    if (bit) {\n                                        validParts.push(bit[1]);\n                                        notHost.unshift(bit[2]);\n                                    }\n                                    if (notHost.length) {\n                                        rest = '/' + notHost.join('.') + rest;\n                                    }\n                                    this.hostname = validParts.join('.');\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (this.hostname.length > hostnameMaxLen) {\n                        this.hostname = '';\n                    } else {\n                        // hostnames are always lower case.\n                        this.hostname = this.hostname.toLowerCase();\n                    }\n\n                    if (!ipv6Hostname) {\n                        // IDNA Support: Returns a punycoded representation of \"domain\".\n                        // It only converts parts of the domain name that\n                        // have non-ASCII characters, i.e. it doesn't matter if\n                        // you call it with a domain that already is ASCII-only.\n                        this.hostname = punycode.toASCII(this.hostname);\n                    }\n\n                    var p = this.port ? ':' + this.port : '';\n                    var h = this.hostname || '';\n                    this.host = h + p;\n                    this.href += this.host;\n\n                    // strip [ and ] from the hostname\n                    // the host field still retains them, though\n                    if (ipv6Hostname) {\n                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n                        if (rest[0] !== '/') {\n                            rest = '/' + rest;\n                        }\n                    }\n                }\n\n                // now rest is set to the post-host stuff.\n                // chop off any delim chars.\n                if (!unsafeProtocol[lowerProto]) {\n\n                    // First, make 100% sure that any \"autoEscape\" chars get\n                    // escaped, even if encodeURIComponent doesn't think they\n                    // need to be.\n                    for (var i = 0, l = autoEscape.length; i < l; i++) {\n                        var ae = autoEscape[i];\n                        if (rest.indexOf(ae) === -1) continue;\n                        var esc = encodeURIComponent(ae);\n                        if (esc === ae) {\n                            esc = escape(ae);\n                        }\n                        rest = rest.split(ae).join(esc);\n                    }\n                }\n\n                // chop off from the tail first.\n                var hash = rest.indexOf('#');\n                if (hash !== -1) {\n                    // got a fragment string.\n                    this.hash = rest.substr(hash);\n                    rest = rest.slice(0, hash);\n                }\n                var qm = rest.indexOf('?');\n                if (qm !== -1) {\n                    this.search = rest.substr(qm);\n                    this.query = rest.substr(qm + 1);\n                    if (parseQueryString) {\n                        this.query = querystring.parse(this.query);\n                    }\n                    rest = rest.slice(0, qm);\n                } else if (parseQueryString) {\n                    // no query string, but parseQueryString still requested\n                    this.search = '';\n                    this.query = {};\n                }\n                if (rest) this.pathname = rest;\n                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n                    this.pathname = '/';\n                }\n\n                //to support http.request\n                if (this.pathname || this.search) {\n                    var p = this.pathname || '';\n                    var s = this.search || '';\n                    this.path = p + s;\n                }\n\n                // finally, reconstruct the href based on what has been validated.\n                this.href = this.format();\n                return this;\n            };\n\n            // format a parsed object into a url string\n            function urlFormat(obj) {\n                // ensure it's an object, and not a string url.\n                // If it's an obj, this is a no-op.\n                // this way, you can call url_format() on strings\n                // to clean up potentially wonky urls.\n                if (util.isString(obj)) obj = urlParse(obj);\n                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n                return obj.format();\n            }\n\n            Url.prototype.format = function () {\n                var auth = this.auth || '';\n                if (auth) {\n                    auth = encodeURIComponent(auth);\n                    auth = auth.replace(/%3A/i, ':');\n                    auth += '@';\n                }\n\n                var protocol = this.protocol || '',\n                    pathname = this.pathname || '',\n                    hash = this.hash || '',\n                    host = false,\n                    query = '';\n\n                if (this.host) {\n                    host = auth + this.host;\n                } else if (this.hostname) {\n                    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n                    if (this.port) {\n                        host += ':' + this.port;\n                    }\n                }\n\n                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n                    query = querystring.stringify(this.query);\n                }\n\n                var search = this.search || query && '?' + query || '';\n\n                if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n                // unless they had them to begin with.\n                if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n                    host = '//' + (host || '');\n                    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n                } else if (!host) {\n                    host = '';\n                }\n\n                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n                if (search && search.charAt(0) !== '?') search = '?' + search;\n\n                pathname = pathname.replace(/[?#]/g, function (match) {\n                    return encodeURIComponent(match);\n                });\n                search = search.replace('#', '%23');\n\n                return protocol + host + pathname + search + hash;\n            };\n\n            function urlResolve(source, relative) {\n                return urlParse(source, false, true).resolve(relative);\n            }\n\n            Url.prototype.resolve = function (relative) {\n                return this.resolveObject(urlParse(relative, false, true)).format();\n            };\n\n            function urlResolveObject(source, relative) {\n                if (!source) return relative;\n                return urlParse(source, false, true).resolveObject(relative);\n            }\n\n            Url.prototype.resolveObject = function (relative) {\n                if (util.isString(relative)) {\n                    var rel = new Url();\n                    rel.parse(relative, false, true);\n                    relative = rel;\n                }\n\n                var result = new Url();\n                var tkeys = Object.keys(this);\n                for (var tk = 0; tk < tkeys.length; tk++) {\n                    var tkey = tkeys[tk];\n                    result[tkey] = this[tkey];\n                }\n\n                // hash is always overridden, no matter what.\n                // even href=\"\" will remove it.\n                result.hash = relative.hash;\n\n                // if the relative url is empty, then there's nothing left to do here.\n                if (relative.href === '') {\n                    result.href = result.format();\n                    return result;\n                }\n\n                // hrefs like //foo/bar always cut to the protocol.\n                if (relative.slashes && !relative.protocol) {\n                    // take everything except the protocol from relative\n                    var rkeys = Object.keys(relative);\n                    for (var rk = 0; rk < rkeys.length; rk++) {\n                        var rkey = rkeys[rk];\n                        if (rkey !== 'protocol') result[rkey] = relative[rkey];\n                    }\n\n                    //urlParse appends trailing / to urls like http://www.example.com\n                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n                        result.path = result.pathname = '/';\n                    }\n\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (relative.protocol && relative.protocol !== result.protocol) {\n                    // if it's a known url protocol, then changing\n                    // the protocol does weird things\n                    // first, if it's not file:, then we MUST have a host,\n                    // and if there was a path\n                    // to begin with, then we MUST have a path.\n                    // if it is file:, then the host is dropped,\n                    // because that's known to be hostless.\n                    // anything else is assumed to be absolute.\n                    if (!slashedProtocol[relative.protocol]) {\n                        var keys = Object.keys(relative);\n                        for (var v = 0; v < keys.length; v++) {\n                            var k = keys[v];\n                            result[k] = relative[k];\n                        }\n                        result.href = result.format();\n                        return result;\n                    }\n\n                    result.protocol = relative.protocol;\n                    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n                        var relPath = (relative.pathname || '').split('/');\n                        while (relPath.length && !(relative.host = relPath.shift())) {}\n                        if (!relative.host) relative.host = '';\n                        if (!relative.hostname) relative.hostname = '';\n                        if (relPath[0] !== '') relPath.unshift('');\n                        if (relPath.length < 2) relPath.unshift('');\n                        result.pathname = relPath.join('/');\n                    } else {\n                        result.pathname = relative.pathname;\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    result.host = relative.host || '';\n                    result.auth = relative.auth;\n                    result.hostname = relative.hostname || relative.host;\n                    result.port = relative.port;\n                    // to support http.request\n                    if (result.pathname || result.search) {\n                        var p = result.pathname || '';\n                        var s = result.search || '';\n                        result.path = p + s;\n                    }\n                    result.slashes = result.slashes || relative.slashes;\n                    result.href = result.format();\n                    return result;\n                }\n\n                var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n                    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n                    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n                    removeAllDots = mustEndAbs,\n                    srcPath = result.pathname && result.pathname.split('/') || [],\n                    relPath = relative.pathname && relative.pathname.split('/') || [],\n                    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n                // if the url is a non-slashed url, then relative\n                // links like ../.. should be able\n                // to crawl up to the hostname, as well.  This is strange.\n                // result.protocol has already been set by now.\n                // Later on, put the first path part into the host field.\n                if (psychotic) {\n                    result.hostname = '';\n                    result.port = null;\n                    if (result.host) {\n                        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n                    }\n                    result.host = '';\n                    if (relative.protocol) {\n                        relative.hostname = null;\n                        relative.port = null;\n                        if (relative.host) {\n                            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n                        }\n                        relative.host = null;\n                    }\n                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n                }\n\n                if (isRelAbs) {\n                    // it's absolute.\n                    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n                    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    srcPath = relPath;\n                    // fall through to the dot-handling below.\n                } else if (relPath.length) {\n                    // it's relative\n                    // throw away the existing file, and take the new path instead.\n                    if (!srcPath) srcPath = [];\n                    srcPath.pop();\n                    srcPath = srcPath.concat(relPath);\n                    result.search = relative.search;\n                    result.query = relative.query;\n                } else if (!util.isNullOrUndefined(relative.search)) {\n                    // just pull out the search.\n                    // like href='?foo'.\n                    // Put this after the other two cases because it simplifies the booleans\n                    if (psychotic) {\n                        result.hostname = result.host = srcPath.shift();\n                        //occationaly the auth can get stuck only in host\n                        //this especially happens in cases like\n                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                        if (authInHost) {\n                            result.auth = authInHost.shift();\n                            result.host = result.hostname = authInHost.shift();\n                        }\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    //to support http.request\n                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (!srcPath.length) {\n                    // no path at all.  easy.\n                    // we've already handled the other stuff above.\n                    result.pathname = null;\n                    //to support http.request\n                    if (result.search) {\n                        result.path = '/' + result.search;\n                    } else {\n                        result.path = null;\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                // if a url ENDs in . or .., then it must get a trailing slash.\n                // however, if it ends in anything else non-slashy,\n                // then it must NOT get a trailing slash.\n                var last = srcPath.slice(-1)[0];\n                var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n                // strip single dots, resolve double dots to parent dir\n                // if the path tries to go above the root, `up` ends up > 0\n                var up = 0;\n                for (var i = srcPath.length; i >= 0; i--) {\n                    last = srcPath[i];\n                    if (last === '.') {\n                        srcPath.splice(i, 1);\n                    } else if (last === '..') {\n                        srcPath.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        srcPath.splice(i, 1);\n                        up--;\n                    }\n                }\n\n                // if the path is allowed to go above the root, restore leading ..s\n                if (!mustEndAbs && !removeAllDots) {\n                    for (; up--; up) {\n                        srcPath.unshift('..');\n                    }\n                }\n\n                if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n                    srcPath.unshift('');\n                }\n\n                if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n                    srcPath.push('');\n                }\n\n                var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n                // put the host back\n                if (psychotic) {\n                    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n                    //occationaly the auth can get stuck only in host\n                    //this especially happens in cases like\n                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                    if (authInHost) {\n                        result.auth = authInHost.shift();\n                        result.host = result.hostname = authInHost.shift();\n                    }\n                }\n\n                mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n                if (mustEndAbs && !isAbsolute) {\n                    srcPath.unshift('');\n                }\n\n                if (!srcPath.length) {\n                    result.pathname = null;\n                    result.path = null;\n                } else {\n                    result.pathname = srcPath.join('/');\n                }\n\n                //to support request.http\n                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                }\n                result.auth = relative.auth || result.auth;\n                result.slashes = result.slashes || relative.slashes;\n                result.href = result.format();\n                return result;\n            };\n\n            Url.prototype.parseHost = function () {\n                var host = this.host;\n                var port = portPattern.exec(host);\n                if (port) {\n                    port = port[0];\n                    if (port !== ':') {\n                        this.port = port.substr(1);\n                    }\n                    host = host.substr(0, host.length - port.length);\n                }\n                if (host) this.hostname = host;\n            };\n        }, { \"./util\": 6, \"punycode\": 1, \"querystring\": 4 }], 6: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = {\n                isString: function isString(arg) {\n                    return typeof arg === 'string';\n                },\n                isObject: function isObject(arg) {\n                    return (typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg)) === 'object' && arg !== null;\n                },\n                isNull: function isNull(arg) {\n                    return arg === null;\n                },\n                isNullOrUndefined: function isNullOrUndefined(arg) {\n                    return arg == null;\n                }\n            };\n        }, {}], 7: [function (require, module, exports) {\n            \"use strict\";\n\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var thing_description_1 = require(\"./thing-description\");\n            var TD = require(\"./thing-description\");\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            function parseTDObject(td) {\n                return parseTDString(typedjson_npm_1.TypedJSON.stringify(td, { enableTypeHints: false }));\n            }\n            exports.parseTDObject = parseTDObject;\n            function parseTDString(json) {\n                console.log(\"parseTDString() parsing\\n```\\n\" + json + \"\\n```\");\n                var td = typedjson_npm_1.TypedJSON.parse(json, thing_description_1.default);\n                console.log(\"parseTDString() found \" + td.interaction.length + \" Interaction\" + (td.interaction.length === 1 ? '' : 's'));\n                for (var _i = 0, _a = td.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Property.toString()) !== -1) {\n                        console.log(\" * Property '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Property;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Action.toString()) !== -1) {\n                        console.log(\" * Action '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Action;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Event.toString()) !== -1) {\n                        console.log(\" * Event '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Event;\n                    } else {\n                        console.error(\"parseTDString() found unknown Interaction pattern '\" + interaction.semanticTypes + \"'\");\n                    }\n                    if (td.base !== undefined) {\n                        console.log(\"parseTDString() applying base '\" + td.base + \"' to href '\" + interaction.link[0].href + \"'\");\n                        var href = interaction.link[0].href;\n                        var url = require('url');\n                        var n = td.base.indexOf(':');\n                        var pr = td.base.substr(0, n + 1);\n                        var uriTemp = td.base.replace(pr, 'http:');\n                        uriTemp = url.resolve(uriTemp, href);\n                        uriTemp = uriTemp.replace('http:', pr);\n                        interaction.link[0].href = uriTemp;\n                    }\n                }\n                return td;\n            }\n            exports.parseTDString = parseTDString;\n            function serializeTD(td) {\n                typedjson_npm_1.TypedJSON.config({ \"enableTypeHints\": false });\n                var json = typedjson_npm_1.TypedJSON.stringify(td);\n                var raw = JSON.parse(json);\n                if (td.base === null || td.base === undefined) {\n                    delete raw.base;\n                }\n                for (var _i = 0, _a = raw.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.inputData === null) {\n                        delete interaction.inputData;\n                    }\n                    if (interaction.outputData === null) {\n                        delete interaction.outputData;\n                    }\n                    if (interaction.writable === null) {\n                        delete interaction.writable;\n                    }\n                    if (interaction.outputData && interaction.outputData.required !== undefined) {\n                        console.log(\"### HOTFIX for TypedJSON ###\");\n                        var reqs = [];\n                        for (var req in interaction.outputData.required) {\n                            reqs.push(interaction.outputData.required[req]);\n                        }interaction.outputData.required = reqs;\n                    }\n                }\n                json = JSON.stringify(raw);\n                console.log(\"serializeTD() produced\\n```\\n\" + json + \"\\n```\");\n                return json;\n            }\n            exports.serializeTD = serializeTD;\n        }, { \"./thing-description\": 8, \"typedjson-npm\": 9, \"url\": 5 }], 8: [function (require, module, exports) {\n            \"use strict\";\n\n            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n                var c = arguments.length,\n                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n                    d;\n                if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                }return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            var InteractionPattern;\n            (function (InteractionPattern) {\n                InteractionPattern[InteractionPattern[\"Property\"] = 'Property'] = \"Property\";\n                InteractionPattern[InteractionPattern[\"Action\"] = 'Action'] = \"Action\";\n                InteractionPattern[InteractionPattern[\"Event\"] = 'Event'] = \"Event\";\n            })(InteractionPattern = exports.InteractionPattern || (exports.InteractionPattern = {}));\n            var InteractionLink = function () {\n                function InteractionLink() {}\n                return InteractionLink;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"href\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"mediaType\", void 0);\n            InteractionLink = __decorate([typedjson_npm_1.JsonObject()], InteractionLink);\n            exports.InteractionLink = InteractionLink;\n            var Interaction = function () {\n                function Interaction() {\n                    this.semanticTypes = [];\n                    this.link = [];\n                }\n                return Interaction;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', isRequired: true, elements: String })], Interaction.prototype, \"semanticTypes\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], Interaction.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: InteractionLink })], Interaction.prototype, \"link\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Boolean })], Interaction.prototype, \"writable\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"inputData\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"outputData\", void 0);\n            Interaction = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [InteractionLink] })], Interaction);\n            exports.Interaction = Interaction;\n            var ThingDescription = function () {\n                function ThingDescription() {\n                    this.context = ['http://w3c.github.io/wot/w3c-wot-td-context.jsonld'];\n                    this.semanticType = ['Thing'];\n                    this.interaction = [];\n                }\n                return ThingDescription;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', elements: String })], ThingDescription.prototype, \"semanticType\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], ThingDescription.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: String })], ThingDescription.prototype, \"base\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: Interaction })], ThingDescription.prototype, \"interaction\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ name: '@context', elements: String })], ThingDescription.prototype, \"context\", void 0);\n            ThingDescription = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [Interaction] })], ThingDescription);\n            exports.default = ThingDescription;\n        }, { \"typedjson-npm\": 9 }], 9: [function (require, module, exports) {\n            /*!\n            TypedJSON v0.2.0 - https://github.com/JohnWhiteTB/TypedJSON\n            \n            Typed JSON parsing and serializing that preserves type information. Parse JSON into actual class instances. Recommended (but not required)\n            to be used with reflect-metadata (global installation): https://github.com/rbuckton/ReflectDecorators.\n            \n            \n            The MIT License (MIT)\n            Copyright (c) 2016 John White\n            \n            Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the\n            \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish,\n            distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to\n            the following conditions:\n            \n            The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n            \n            THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n            CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n            SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n            */\n            (function (factory) {\n                if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n                    var v = factory(require, exports);if (v !== undefined) module.exports = v;\n                } else if (typeof define === 'function' && define.amd) {\n                    define([\"require\", \"exports\"], factory);\n                }\n            })(function (require, exports) {\n                \"use strict\";\n\n                var METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n                var JSON;\n                if (!JSON) {\n                    JSON = {\n                        parse: function parse(sJSON) {\n                            var returnval = sJSON;\n                            if ((typeof returnval === \"undefined\" ? \"undefined\" : _typeof(returnval)) === 'object') {\n                                return returnval;\n                            } else {\n                                return eval('(' + sJSON + ')');\n                            }\n                        },\n                        stringify: function () {\n                            var toString = Object.prototype.toString;\n                            var isArray = Array.isArray || function (a) {\n                                return toString.call(a) === '[object Array]';\n                            };\n                            var escMap = { '\"': '\\\\\"', '\\\\': '\\\\\\\\', '\\b': '\\\\b', '\\f': '\\\\f', '\\n': '\\\\n', '\\r': '\\\\r', '\\t': '\\\\t' };\n                            var escFunc = function escFunc(m) {\n                                return escMap[m] || \"\\\\u\" + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);\n                            };\n                            var escRE = /[\\\\\"\\u0000-\\u001F\\u2028\\u2029]/g;\n                            return function stringify(value) {\n                                if (value == null) {\n                                    return 'null';\n                                } else if (typeof value === 'number') {\n                                    return isFinite(value) ? value.toString() : 'null';\n                                } else if (typeof value === 'boolean') {\n                                    return value.toString();\n                                } else if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n                                    if (typeof value.toJSON === 'function') {\n                                        return stringify(value.toJSON());\n                                    } else if (isArray(value)) {\n                                        var res = '[';\n                                        for (var i = 0; i < value.length; i++) {\n                                            res += (i ? ', ' : '') + stringify(value[i]);\n                                        }return res + ']';\n                                    } else if (toString.call(value) === '[object Object]') {\n                                        var tmp = [];\n                                        for (var k in value) {\n                                            if (value.hasOwnProperty(k)) tmp.push(stringify(k) + ': ' + stringify(value[k]));\n                                        }\n                                        return '{' + tmp.join(', ') + '}';\n                                    }\n                                }\n                                return '\"' + value.toString().replace(escRE, escFunc) + '\"';\n                            };\n                        }()\n                    };\n                }\n                var Helpers;\n                (function (Helpers) {\n                    function assign(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = Object(target);\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.assign = assign;\n                    function error(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.error === \"function\") {\n                            console.error.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"ERROR: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.error = error;\n                    function getClassName(target) {\n                        var targetType;\n                        if (typeof target === \"function\") {\n                            targetType = target;\n                        } else if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\") {\n                            targetType = target.constructor;\n                        }\n                        if (!targetType) {\n                            return \"undefined\";\n                        }\n                        if (\"name\" in targetType && typeof targetType.name === \"string\") {\n                            return targetType.name;\n                        } else {\n                            return targetType.toString().match(/function (\\w*)/)[1];\n                        }\n                    }\n                    Helpers.getClassName = getClassName;\n                    function getDefaultValue(type) {\n                        switch (type) {\n                            case Number:\n                                return 0;\n                            case String:\n                                return \"\";\n                            case Boolean:\n                                return false;\n                            case Array:\n                                return [];\n                            default:\n                                return null;\n                        }\n                    }\n                    Helpers.getDefaultValue = getDefaultValue;\n                    function getPropertyDisplayName(target, propertyKey) {\n                        return getClassName(target) + \".\" + propertyKey.toString();\n                    }\n                    Helpers.getPropertyDisplayName = getPropertyDisplayName;\n                    function isArray(object) {\n                        if (typeof Array.isArray === \"function\") {\n                            return Array.isArray(object);\n                        } else {\n                            if (object instanceof Array) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        }\n                    }\n                    Helpers.isArray = isArray;\n                    function isPrimitive(obj) {\n                        switch (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) {\n                            case \"string\":\n                            case \"number\":\n                            case \"boolean\":\n                                return true;\n                        }\n                        if (obj instanceof String || obj === String || obj instanceof Number || obj === Number || obj instanceof Boolean || obj === Boolean) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    Helpers.isPrimitive = isPrimitive;\n                    function isReservedMemberName(name) {\n                        return name === METADATA_FIELD_KEY;\n                    }\n                    Helpers.isReservedMemberName = isReservedMemberName;\n                    function isSubtypeOf(A, B) {\n                        var aPrototype = A.prototype;\n                        if (A === B) {\n                            return true;\n                        }\n                        while (aPrototype) {\n                            if (aPrototype instanceof B) {\n                                return true;\n                            }\n                            aPrototype = aPrototype.prototype;\n                        }\n                        return false;\n                    }\n                    Helpers.isSubtypeOf = isSubtypeOf;\n                    function log(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.log = log;\n                    function merge(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = {};\n                        Object.keys(target).forEach(function (nextKey) {\n                            output[nextKey] = target[nextKey];\n                        });\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.merge = merge;\n                    function valueIsDefined(value) {\n                        if (typeof value === \"undefined\" || value === null) {\n                            return false;\n                        } else {\n                            return true;\n                        }\n                    }\n                    Helpers.valueIsDefined = valueIsDefined;\n                    function warn(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.warn === \"function\") {\n                            console.warn.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"WARNING: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.warn = warn;\n                })(Helpers || (Helpers = {}));\n                var JsonMemberMetadata = function () {\n                    function JsonMemberMetadata() {}\n                    return JsonMemberMetadata;\n                }();\n                var JsonObjectMetadata = function () {\n                    function JsonObjectMetadata() {\n                        this._dataMembers = {};\n                        this._knownTypes = [];\n                        this._knownTypeCache = null;\n                        this.isExplicitlyMarked = false;\n                    }\n                    JsonObjectMetadata.getJsonObjectName = function (type, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var metadata = this.getFromType(type, inherited);\n                        if (metadata !== null) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(type);\n                        }\n                    };\n                    JsonObjectMetadata.getFromType = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var targetPrototype;\n                        var metadata;\n                        if (typeof target === \"function\") {\n                            targetPrototype = target.prototype;\n                        } else {\n                            targetPrototype = target;\n                        }\n                        if (!targetPrototype) {\n                            return null;\n                        }\n                        if (targetPrototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        } else if (inherited && targetPrototype[METADATA_FIELD_KEY]) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        }\n                        if (metadata && metadata.isExplicitlyMarked) {\n                            return metadata;\n                        } else {\n                            return null;\n                        }\n                    };\n                    JsonObjectMetadata.getFromInstance = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        return this.getFromType(Object.getPrototypeOf(target), inherited);\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromType = function (target) {\n                        var metadata = this.getFromType(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target);\n                        }\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromInstance = function (target) {\n                        var metadata = this.getFromInstance(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target.constructor);\n                        }\n                    };\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"dataMembers\", {\n                        get: function get() {\n                            return this._dataMembers;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"className\", {\n                        get: function get() {\n                            if (typeof this._className === \"string\") {\n                                return this._className;\n                            } else {\n                                return Helpers.getClassName(this.classType);\n                            }\n                        },\n                        set: function set(value) {\n                            this._className = value;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"knownTypes\", {\n                        get: function get() {\n                            var knownTypes;\n                            var knownTypeName;\n                            knownTypes = {};\n                            this._knownTypes.forEach(function (knownType) {\n                                knownTypeName = JsonObjectMetadata.getKnownTypeNameFromType(knownType);\n                                knownTypes[knownTypeName] = knownType;\n                            });\n                            this._knownTypeCache = knownTypes;\n                            return knownTypes;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    JsonObjectMetadata.prototype.setKnownType = function (type) {\n                        if (this._knownTypes.indexOf(type) === -1) {\n                            this._knownTypes.push(type);\n                            this._knownTypeCache = null;\n                        }\n                    };\n                    JsonObjectMetadata.prototype.addMember = function (member) {\n                        var _this = this;\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            if (_this._dataMembers[propertyKey].name === member.name) {\n                                throw new Error(\"A member with the name '\" + member.name + \"' already exists.\");\n                            }\n                        });\n                        this._dataMembers[member.key] = member;\n                    };\n                    JsonObjectMetadata.prototype.sortMembers = function () {\n                        var _this = this;\n                        var memberArray = [];\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            memberArray.push(_this._dataMembers[propertyKey]);\n                        });\n                        memberArray = memberArray.sort(this.sortMembersCompare);\n                        this._dataMembers = {};\n                        memberArray.forEach(function (dataMember) {\n                            _this._dataMembers[dataMember.key] = dataMember;\n                        });\n                    };\n                    JsonObjectMetadata.prototype.sortMembersCompare = function (a, b) {\n                        if (typeof a.order !== \"number\" && typeof b.order !== \"number\") {\n                            if (a.name < b.name) {\n                                return -1;\n                            } else if (a.name > b.name) {\n                                return 1;\n                            }\n                        } else if (typeof a.order !== \"number\") {\n                            return 1;\n                        } else if (typeof b.order !== \"number\") {\n                            return -1;\n                        } else {\n                            if (a.order < b.order) {\n                                return -1;\n                            } else if (a.order > b.order) {\n                                return 1;\n                            } else {\n                                if (a.name < b.name) {\n                                    return -1;\n                                } else if (a.name > b.name) {\n                                    return 1;\n                                }\n                            }\n                        }\n                        return 0;\n                    };\n                    return JsonObjectMetadata;\n                }();\n                function JsonObject(optionsOrTarget) {\n                    var options;\n                    if (typeof optionsOrTarget === \"function\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    var initializer = options.initializer;\n                    var serializer = options.serializer;\n                    var decorator = function decorator(target) {\n                        var objectMetadata;\n                        var parentMetadata;\n                        var i;\n                        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target.prototype[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                                Object.keys(parentMetadata.knownTypes).forEach(function (key) {\n                                    objectMetadata.setKnownType(parentMetadata.knownTypes[key]);\n                                });\n                            }\n                            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n                        }\n                        objectMetadata.classType = target;\n                        objectMetadata.isExplicitlyMarked = true;\n                        if (options.name) {\n                            objectMetadata.className = options.name;\n                        }\n                        if (options.knownTypes) {\n                            i = 0;\n                            try {\n                                options.knownTypes.forEach(function (knownType) {\n                                    if (typeof knownType === \"undefined\") {\n                                        throw new TypeError(\"Known type #\" + i++ + \" is undefined.\");\n                                    }\n                                    objectMetadata.setKnownType(knownType);\n                                });\n                            } catch (e) {\n                                Helpers.error(new TypeError(\"@JsonObject: \" + e.message + \" (on '\" + Helpers.getClassName(target) + \"')\"));\n                            }\n                        }\n                        if (typeof initializer === \"function\") {\n                            objectMetadata.initializer = initializer;\n                        }\n\n                        if (typeof serializer === \"function\") {\n                            objectMetadata.serializer = serializer;\n                        }\n                    };\n                    if (typeof optionsOrTarget === \"function\") {\n                        return decorator(optionsOrTarget);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonObject = JsonObject;\n                function jsonMemberTypeInit(metadata, propertyName, warnArray) {\n                    if (warnArray === void 0) {\n                        warnArray = false;\n                    }\n                    if (metadata.elements) {\n                        if (typeof metadata.elements === \"function\") {\n                            metadata.elements = {\n                                type: metadata.elements\n                            };\n                        }\n                        if (!metadata.type) {\n                            metadata.type = Array;\n                        }\n                    }\n                    if (metadata.type === Array) {\n                        if (!metadata.elements) {\n                            if (warnArray) {\n                                Helpers.warn(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            } else {\n                                throw new Error(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            }\n                        } else {\n                            jsonMemberTypeInit(metadata.elements, propertyName + '[]', true);\n                        }\n                    }\n                    if (typeof metadata.type !== \"function\") {\n                        throw new Error(\"No valid 'type' option was specified for '\" + propertyName + \"'.\");\n                    }\n                }\n                function jsonMemberKnownTypes(metadata) {\n                    var knownTypes = new Array();\n                    knownTypes.push(metadata.type);\n                    if (metadata.elements) {\n                        knownTypes = knownTypes.concat(jsonMemberKnownTypes(metadata.elements));\n                    }\n                    return knownTypes;\n                }\n                function JsonMember(optionsOrTarget, propertyKey) {\n                    var memberMetadata = new JsonMemberMetadata();\n                    var options;\n                    var decorator;\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    decorator = function decorator(target, propertyKey) {\n                        var descriptor = Object.getOwnPropertyDescriptor(target, propertyKey.toString());\n                        ;\n                        var objectMetadata;\n                        var parentMetadata;\n                        var reflectType;\n                        var propertyName = Helpers.getPropertyDisplayName(target, propertyKey);\n                        if (typeof target === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a static property ('\" + propertyName + \"').\");\n                        }\n                        if (typeof target[propertyKey] === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a method property ('\" + propertyName + \"').\");\n                        }\n                        if (options.hasOwnProperty(\"elementType\")) {\n                            Helpers.warn(propertyName + \": the 'elementType' option is deprecated, use 'elements' instead.\");\n                            options.elements = options.elementType;\n                            if (options.elementType === Array) {\n                                memberMetadata.forceEnableTypeHinting = true;\n                            }\n                        }\n                        memberMetadata = Helpers.assign(memberMetadata, options);\n                        memberMetadata.key = propertyKey.toString();\n                        memberMetadata.name = options.name || propertyKey.toString();\n                        if (Helpers.isReservedMemberName(memberMetadata.name)) {\n                            throw new Error(\"@JsonMember: '\" + memberMetadata.name + \"' is a reserved name.\");\n                        }\n                        if (options.hasOwnProperty(\"type\") && typeof options.type === \"undefined\") {\n                            throw new TypeError(\"@JsonMember: 'type' of '\" + propertyName + \"' is undefined.\");\n                        }\n                        if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.getMetadata === \"function\") {\n                            reflectType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n                            if (typeof reflectType === \"undefined\") {\n                                throw new TypeError(\"@JsonMember: type detected for '\" + propertyName + \"' is undefined.\");\n                            }\n                            if (!memberMetadata.type || typeof memberMetadata.type !== \"function\") {\n                                memberMetadata.type = reflectType;\n                            } else if (memberMetadata.type !== reflectType) {\n                                Helpers.warn(\"@JsonMember: 'type' specified for '\" + propertyName + \"' does not match detected type.\");\n                            }\n                        }\n                        jsonMemberTypeInit(memberMetadata, propertyName);\n                        if (!target.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                            }\n                            Object.defineProperty(target, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target[METADATA_FIELD_KEY];\n                        }\n                        jsonMemberKnownTypes(memberMetadata).forEach(function (knownType) {\n                            objectMetadata.setKnownType(knownType);\n                        });\n                        try {\n                            objectMetadata.addMember(memberMetadata);\n                        } catch (e) {\n                            throw new Error(\"Member '\" + memberMetadata.name + \"' already exists on '\" + Helpers.getClassName(objectMetadata.classType) + \"'.\");\n                        }\n                    };\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        return decorator(optionsOrTarget, propertyKey);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonMember = JsonMember;\n                var Serializer = function () {\n                    function Serializer() {}\n                    Serializer.writeObject = function (object, settings) {\n                        var objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                        var ObjectType;\n                        if (objectMetadata) {\n                            ObjectType = objectMetadata.classType;\n                        } else {\n                            ObjectType = object.constructor;\n                        }\n                        return JSON.stringify(this.writeToJsonObject(object, {\n                            objectType: ObjectType,\n                            enableTypeHints: settings.enableTypeHints,\n                            typeHintPropertyKey: settings.typeHintPropertyKey\n                        }), settings.replacer);\n                    };\n                    Serializer.writeToJsonObject = function (object, settings) {\n                        var _this = this;\n                        var json;\n                        var objectMetadata;\n                        if (object === null || typeof object === \"undefined\") {\n                            if (settings.emitDefault) {\n                                json = Helpers.getDefaultValue(settings.objectType);\n                            } else {\n                                json = object;\n                            }\n                        } else if (Helpers.isPrimitive(object) || object instanceof Date) {\n                            json = object;\n                        } else if (object instanceof Array) {\n                            json = [];\n                            for (var i = 0, n = object.length; i < n; i++) {\n                                json.push(this.writeToJsonObject(object[i], {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    objectType: settings.elements ? settings.elements.type : Object,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            }\n                        } else {\n                            objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                            if (objectMetadata && typeof objectMetadata.serializer === \"function\") {\n                                json = objectMetadata.serializer(object);\n                            } else {\n                                json = {};\n                                if (settings.enableTypeHints && (settings.requireTypeHints || object.constructor !== settings.objectType)) {\n                                    json[settings.typeHintPropertyKey] = JsonObjectMetadata.getKnownTypeNameFromInstance(object);\n                                }\n                                if (objectMetadata) {\n                                    objectMetadata.sortMembers();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        json[propertyMetadata.name] = _this.writeToJsonObject(object[propertyKey], {\n                                            elements: propertyMetadata.elements,\n                                            emitDefault: propertyMetadata.emitDefaultValue,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            name: propertyMetadata.name,\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                } else {\n                                    Object.keys(object).forEach(function (propertyKey) {\n                                        json[propertyKey] = _this.writeToJsonObject(object[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            objectType: Object,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                }\n                            }\n                        }\n                        return json;\n                    };\n                    return Serializer;\n                }();\n                var Deserializer = function () {\n                    function Deserializer() {}\n                    Deserializer.readObject = function (json, type, settings) {\n                        var value;\n                        var instance;\n                        var metadata = JsonObjectMetadata.getFromType(type);\n                        if (typeof json === 'Object') {\n                            value = json;\n                        } else {\n                            value = JSON.parse(json, settings.reviver);\n                        }\n                        if (typeof settings.maxObjects === \"number\") {\n                            if (this.countObjects(value) > settings.maxObjects) {\n                                throw new Error(\"JSON exceeds object count limit (\" + settings.maxObjects + \").\");\n                            }\n                        }\n                        instance = this.readJsonToInstance(value, {\n                            objectType: type,\n                            typeHintPropertyKey: settings.typeHintPropertyKey,\n                            enableTypeHints: settings.enableTypeHints,\n                            strictTypeHintMode: true,\n                            knownTypes: metadata ? metadata.knownTypes : {}\n                        });\n                        return instance;\n                    };\n                    Deserializer.countObjects = function (value) {\n                        var _this = this;\n                        switch (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) {\n                            case \"object\":\n                                if (value === null) {\n                                    return 0;\n                                } else if (Helpers.isArray(value)) {\n                                    var count_1 = 0;\n                                    value.forEach(function (item) {\n                                        count_1 += _this.countObjects(item);\n                                    });\n                                    return count_1;\n                                } else {\n                                    var count_2 = 0;\n                                    Object.keys(value).forEach(function (propertyKey) {\n                                        count_2 += _this.countObjects(value[propertyKey]);\n                                    });\n                                    return count_2;\n                                }\n                            case \"undefined\":\n                                return 0;\n                            default:\n                                return 1;\n                        }\n                    };\n                    Deserializer.readJsonToInstance = function (json, settings) {\n                        var _this = this;\n                        var object;\n                        var objectMetadata;\n                        var ObjectType;\n                        var typeHint;\n                        var temp;\n                        var knownTypes;\n                        if (typeof json === \"undefined\" || json === null) {\n                            if (settings.isRequired) {\n                                throw new Error(\"Missing required member.\");\n                            }\n                        } else if (Helpers.isPrimitive(settings.objectType)) {\n                            if (json.constructor !== settings.objectType) {\n                                var expectedTypeName = Helpers.getClassName(settings.objectType).toLowerCase();\n                                var foundTypeName = Helpers.getClassName(json.constructor).toLowerCase();\n                                throw new TypeError(\"Expected value to be of type '\" + expectedTypeName + \"', got '\" + foundTypeName + \"'.\");\n                            }\n                            object = json;\n                        } else if (settings.objectType === Array) {\n                            if (!Helpers.isArray(json)) {\n                                throw new TypeError(\"Expected value to be of type 'Array', got '\" + Helpers.getClassName(json.constructor) + \"'.\");\n                            }\n                            object = [];\n                            json.forEach(function (element) {\n                                object.push(_this.readJsonToInstance(element, {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    knownTypes: settings.knownTypes,\n                                    objectType: settings.elements ? settings.elements.type : element.constructor,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    strictTypeHintMode: settings.strictTypeHintMode,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            });\n                        } else if (settings.objectType === Date) {\n                            if (typeof json === \"string\") {\n                                object = new Date(json);\n                            } else if (json instanceof Date) {\n                                object = json;\n                            } else {\n                                throw new TypeError(\"Expected value to be of type 'string', got '\" + (typeof json === \"undefined\" ? \"undefined\" : _typeof(json)) + \"'.\");\n                            }\n                        } else {\n                            typeHint = json[settings.typeHintPropertyKey];\n                            if (typeHint && settings.enableTypeHints) {\n                                if (typeof typeHint !== \"string\") {\n                                    throw new TypeError(\"Type-hint (\" + settings.typeHintPropertyKey + \") must be a string.\");\n                                }\n                                if (!settings.knownTypes[typeHint]) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a known type.\");\n                                }\n                                if (settings.strictTypeHintMode && !Helpers.isSubtypeOf(settings.knownTypes[typeHint], settings.objectType)) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a subtype of '\" + Helpers.getClassName(settings.objectType) + \"'.\");\n                                }\n                                ObjectType = settings.knownTypes[typeHint];\n                                objectMetadata = JsonObjectMetadata.getFromType(ObjectType);\n                            } else {\n                                if (settings.enableTypeHints && settings.requireTypeHints) {\n                                    throw new Error(\"Missing required type-hint.\");\n                                }\n                                ObjectType = settings.objectType;\n                                objectMetadata = JsonObjectMetadata.getFromType(settings.objectType);\n                            }\n                            if (objectMetadata) {\n                                if (typeof objectMetadata.initializer === \"function\") {\n                                    object = objectMetadata.initializer(json) || null;\n                                } else {\n                                    objectMetadata.sortMembers();\n                                    object = new ObjectType();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        temp = _this.readJsonToInstance(json[propertyMetadata.name], {\n                                            elements: propertyMetadata.elements,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            isRequired: propertyMetadata.isRequired,\n                                            knownTypes: Helpers.merge(settings.knownTypes, objectMetadata.knownTypes || {}),\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            strictTypeHintMode: settings.strictTypeHintMode,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                        if (Helpers.valueIsDefined(temp)) {\n                                            object[propertyKey] = temp;\n                                        }\n                                    });\n                                }\n                            } else {\n                                object = {};\n                                Object.keys(json).forEach(function (propertyKey) {\n                                    if (json[propertyKey] && propertyKey !== settings.typeHintPropertyKey) {\n                                        object[propertyKey] = _this.readJsonToInstance(json[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            knownTypes: settings.knownTypes,\n                                            objectType: json[propertyKey].constructor,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                        return object;\n                    };\n                    return Deserializer;\n                }();\n                var configSettings = {\n                    enableTypeHints: true,\n                    typeHintPropertyKey: \"__type\"\n                };\n                var TypedJSON = {\n                    config: function config(settings) {\n                        configSettings = Helpers.merge(configSettings, settings);\n                    },\n                    stringify: function stringify(value, settings) {\n                        return Serializer.writeObject(value, Helpers.merge(configSettings, settings || {}));\n                    },\n                    parse: function parse(json, type, settings) {\n                        if (JsonObjectMetadata.getFromType(type)) {\n                            return Deserializer.readObject(json, type, Helpers.merge(configSettings, settings || {}));\n                        } else {\n                            return JSON.parse.apply(JSON, arguments);\n                        }\n                    }\n                };\n                exports.TypedJSON = TypedJSON;\n            });\n        }, {}] }, {}, [7])(7);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYXJzZXIvYnVuZGxlLXBhcnNlci5qcz84YzM1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuKGZ1bmN0aW9uIChmKSB7XG4gICAgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZztpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZyA9IHdpbmRvdztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBnID0gZ2xvYmFsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBnID0gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGcgPSB0aGlzO1xuICAgICAgICB9Zy5wYXJzZXIgPSBmKCk7XG4gICAgfVxufSkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cztyZXR1cm4gZnVuY3Rpb24gZSh0LCBuLCByKSB7XG4gICAgICAgIGZ1bmN0aW9uIHMobywgdSkge1xuICAgICAgICAgICAgaWYgKCFuW29dKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0W29dKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiICYmIHJlcXVpcmU7aWYgKCF1ICYmIGEpIHJldHVybiBhKG8sICEwKTtpZiAoaSkgcmV0dXJuIGkobywgITApO3ZhciBmID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG8gKyBcIidcIik7dGhyb3cgZi5jb2RlID0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGY7XG4gICAgICAgICAgICAgICAgfXZhciBsID0gbltvXSA9IHsgZXhwb3J0czoge30gfTt0W29dWzBdLmNhbGwobC5leHBvcnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRbb11bMV1bZV07cmV0dXJuIHMobiA/IG4gOiBlKTtcbiAgICAgICAgICAgICAgICB9LCBsLCBsLmV4cG9ydHMsIGUsIHQsIG4sIHIpO1xuICAgICAgICAgICAgfXJldHVybiBuW29dLmV4cG9ydHM7XG4gICAgICAgIH12YXIgaSA9IHR5cGVvZiByZXF1aXJlID09IFwiZnVuY3Rpb25cIiAmJiByZXF1aXJlO2ZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgcyhyW29dKTtcbiAgICAgICAgfXJldHVybiBzO1xuICAgIH0oeyAxOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuICAgICAgICAgICAgICAgIDsoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAgICAgICAgICAgICAgICAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlRXhwb3J0cyA9ICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtb2R1bGUpKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlR2xvYmFsID0gKHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihnbG9iYWwpKSA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgcHVueWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHVueWNvZGUsXG5cblxuICAgICAgICAgICAgICAgICAgICAvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG4gICAgICAgICAgICAgICAgICAgIG1heEludCA9IDIxNDc0ODM2NDcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gMzYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0TWluID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRNYXggPSAyNixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZXcgPSAzOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXAgPSA3MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQmlhcyA9IDcyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbE4gPSAxMjgsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAweDgwXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICctJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHgyRCdcblxuICAgICAgICAgICAgICAgICAgICAvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuICAgICAgICAgICAgICAgICAgICByZWdleFB1bnljb2RlID0gL154bi0tLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuICAgICAgICAgICAgICAgICAgICAvKiogRXJyb3IgbWVzc2FnZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuICAgICAgICAgICAgICAgICAgICBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAqIGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAgICAgICAgICAgICAgICAgICAgICogYWRkcmVzc2VzLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICAgICAgICAgICAgICAgICAgICogY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgICAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgKiBtYXRjaGluZyBVVEYtMTYuXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlciA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgZW5jb2RlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gICAgICAgICAgICAgICAgICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAyMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gOTc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICAgICAgICAgICAgICAgICAgICAgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAgICAgICAgICAgICAgICAgICAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICAgICAgICAgICAgICAgICAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IC8qIG5vIGluaXRpYWxpemF0aW9uICovZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAgKiBzeW1ib2xzLlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHVzZSBVQ1MtMlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gaW5pdGlhbE4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2ljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWludXNUO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2ljIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2ljID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdub3QtYmFzaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IGRpZ2l0ICogdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgKj0gYmFzZU1pbnVzVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAlPSBvdXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gICAgICAgICAgICAgICAgICAgICAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzaWNMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRMZW5ndGgsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNaW51c1QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcU1pbnVzVDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gaW5pdGlhbE47XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gaW5pdGlhbEJpYXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNpY0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGFyZ2VyIG9uZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAgICAgICAgICAgICAgICAgICAgICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICAgICAgICAgICAgICAgICAgICAgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICAgICAgICAgICAgICAgICAgICAgKiBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gICAgICAgICAgICAgICAgICAgICAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICAgICAgICAgICAgICAgICAgICAgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAgICAgICAgICAgICAgICAgICAgICogQVNDSUkuXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICAgICAgICAgICAgICAgICAgICAgKiBVbmljb2RlIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICAgICAgICAgICAgICAgICAgICAgKiBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgICAgICAvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG4gICAgICAgICAgICAgICAgICAgIHB1bnljb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAndmVyc2lvbic6ICcxLjQuMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAndWNzMic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb2RlJzogdWNzMmRlY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW5jb2RlJzogdWNzMmVuY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZWNvZGUnOiBkZWNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZW5jb2RlJzogZW5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvQVNDSUknOiB0b0FTQ0lJLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvVW5pY29kZSc6IHRvVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlrZSB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIF90eXBlb2YoZGVmaW5lLmFtZCkgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVueWNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcHVueWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKHRoaXMpO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbiAgICAgICAgfSwge31dLCAyOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAgIC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAgICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICAgICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgICAgLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICAgICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAgIC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAgICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuICAgICAgICAgICAgLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICAgICAgICAgICAgICBlcSA9IGVxIHx8ICc9JztcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICAgICAgICAgICAgICAgIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gICAgICAgICAgICAgICAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbWF4S2V5cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgICAgICAgICAgICAgICAgICBrc3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdnN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgICAgICAgICB2O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrc3RyID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzdHIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fV0sIDM6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICAgICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgICAgLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICAgICAgICAgICAvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gICAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgICAvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gICAgICAgICAgICAvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gICAgICAgICAgICAvLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgICAvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAgICAgICAgICAgIC8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICAgICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgICAgLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICB2YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHYpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzZXAgfHwgJyYnO1xuICAgICAgICAgICAgICAgIGVxID0gZXEgfHwgJz0nO1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcCh4cywgZikge1xuICAgICAgICAgICAgICAgIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9XSwgNDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuICAgICAgICB9LCB7IFwiLi9kZWNvZGVcIjogMiwgXCIuL2VuY29kZVwiOiAzIH1dLCA1OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAgIC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAgICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICAgICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgICAgLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICAgICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAgIC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAgICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgdmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbiAgICAgICAgICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgICAgICAgICAgIGV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbiAgICAgICAgICAgIGV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG4gICAgICAgICAgICBleHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuICAgICAgICAgICAgZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbiAgICAgICAgICAgIGV4cG9ydHMuVXJsID0gVXJsO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBVcmwoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4gICAgICAgICAgICAvLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuICAgICAgICAgICAgLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG4gICAgICAgICAgICB2YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICAgICAgICAgICAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgICAgICAgICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG5cbiAgICAgICAgICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgICAgICAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgICAgICAgICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cblxuICAgICAgICAgICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICAgICAgICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuXG4gICAgICAgICAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgICAgICAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcblxuICAgICAgICAgICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAgICAgICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgICAgICAgICAgLy8gdGhlbS5cbiAgICAgICAgICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgICAgICAgICAgICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICAgICAgICAgICAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICAgICAgICAgICAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuXG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAgICAgICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgICAgICAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgICAgICAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgICAgICAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICAgICAgICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICAgICAgICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZnRwOic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmaWxlOic6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gICAgICAgICAgICAgICAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyAodHlwZW9mIHVybCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHVybCkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgICAgICAgICAgICAgICAgc3BsaXR0ZXIgPSBxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSA/ICc/JyA6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgICAgICAgICAgICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gICAgICAgICAgICAgICAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgICAgICAgICAgICAgICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdCA9IHVybDtcblxuICAgICAgICAgICAgICAgIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgICAgICAgICAgICAgICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAgICAgICAgICAgICAgIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAgICAgICAgICAgICAgIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYgKHNsYXNoZXMgfHwgcHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZXg6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgICAgICAgICAgICAgICAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSBob3N0RW5kID0gaGVjO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkgaG9zdEVuZCA9IGhlYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAgICAgICAgICAgICAgIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgICAgICAgICAgICAgICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgICAgICBpZiAocW0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICAgICAgICAgICAgICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiYgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG4gICAgICAgICAgICBmdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBVcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgICAgICAgICAgICAgICAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aCArPSAnQCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBob3N0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgPyB0aGlzLmhvc3RuYW1lIDogJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkgJiYgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IHF1ZXJ5ICYmICc/JyArIHF1ZXJ5IHx8ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3QgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZSA9IHJlbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICAgICAgICAgICAgICAgIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgICAgICAgICAgICAgICAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpc1NvdXJjZUFicyA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgICAgICAgICAgICAgICAgIGlzUmVsQWJzID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICAgICAgICAgICAgICAgICAgbXVzdEVuZEFicyA9IGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8IHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgICAgICAgICAgICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gICAgICAgICAgICAgICAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgICAgIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgICAgICAgICAgICAgICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAgICAgICAgICAgICAgIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICAgICAgICAgICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJyA/IHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnID8gcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgICAgICAgICAgICAgICAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJztcblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgICAgICAgICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gICAgICAgICAgICAgICAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiYgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLyc7XG5cbiAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgICAgICAgICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOiBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgICAgICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgcmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgICAgICAgICAgICAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICAgICAgICAgICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL3V0aWxcIjogNiwgXCJwdW55Y29kZVwiOiAxLCBcInF1ZXJ5c3RyaW5nXCI6IDQgfV0sIDY6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgICAgIGlzU3RyaW5nOiBmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhcmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihhcmcpKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNOdWxsOiBmdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fV0sIDc6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdmFyIHRoaW5nX2Rlc2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi90aGluZy1kZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBURCA9IHJlcXVpcmUoXCIuL3RoaW5nLWRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgdmFyIHR5cGVkanNvbl9ucG1fMSA9IHJlcXVpcmUoXCJ0eXBlZGpzb24tbnBtXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VURE9iamVjdCh0ZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVREU3RyaW5nKHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04uc3RyaW5naWZ5KHRkLCB7IGVuYWJsZVR5cGVIaW50czogZmFsc2UgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZVRET2JqZWN0ID0gcGFyc2VURE9iamVjdDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVERTdHJpbmcoanNvbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGFyc2VURFN0cmluZygpIHBhcnNpbmdcXG5gYGBcXG5cIiArIGpzb24gKyBcIlxcbmBgYFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdGQgPSB0eXBlZGpzb25fbnBtXzEuVHlwZWRKU09OLnBhcnNlKGpzb24sIHRoaW5nX2Rlc2NyaXB0aW9uXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXJzZVREU3RyaW5nKCkgZm91bmQgXCIgKyB0ZC5pbnRlcmFjdGlvbi5sZW5ndGggKyBcIiBJbnRlcmFjdGlvblwiICsgKHRkLmludGVyYWN0aW9uLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRkLmludGVyYWN0aW9uOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbi5zZW1hbnRpY1R5cGVzLmluZGV4T2YoVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLlByb3BlcnR5LnRvU3RyaW5nKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgKiBQcm9wZXJ0eSAnXCIgKyBpbnRlcmFjdGlvbi5uYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ucGF0dGVybiA9IFRELkludGVyYWN0aW9uUGF0dGVybi5Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbi5zZW1hbnRpY1R5cGVzLmluZGV4T2YoVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkFjdGlvbi50b1N0cmluZygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiICogQWN0aW9uICdcIiArIGludGVyYWN0aW9uLm5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5wYXR0ZXJuID0gVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbi5zZW1hbnRpY1R5cGVzLmluZGV4T2YoVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkV2ZW50LnRvU3RyaW5nKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgKiBFdmVudCAnXCIgKyBpbnRlcmFjdGlvbi5uYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ucGF0dGVybiA9IFRELkludGVyYWN0aW9uUGF0dGVybi5FdmVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJwYXJzZVREU3RyaW5nKCkgZm91bmQgdW5rbm93biBJbnRlcmFjdGlvbiBwYXR0ZXJuICdcIiArIGludGVyYWN0aW9uLnNlbWFudGljVHlwZXMgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRkLmJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXJzZVREU3RyaW5nKCkgYXBwbHlpbmcgYmFzZSAnXCIgKyB0ZC5iYXNlICsgXCInIHRvIGhyZWYgJ1wiICsgaW50ZXJhY3Rpb24ubGlua1swXS5ocmVmICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBpbnRlcmFjdGlvbi5saW5rWzBdLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRkLmJhc2UuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByID0gdGQuYmFzZS5zdWJzdHIoMCwgbiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVyaVRlbXAgPSB0ZC5iYXNlLnJlcGxhY2UocHIsICdodHRwOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpVGVtcCA9IHVybC5yZXNvbHZlKHVyaVRlbXAsIGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpVGVtcCA9IHVyaVRlbXAucmVwbGFjZSgnaHR0cDonLCBwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5saW5rWzBdLmhyZWYgPSB1cmlUZW1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMucGFyc2VURFN0cmluZyA9IHBhcnNlVERTdHJpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVURCh0ZCkge1xuICAgICAgICAgICAgICAgIHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04uY29uZmlnKHsgXCJlbmFibGVUeXBlSGludHNcIjogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSB0eXBlZGpzb25fbnBtXzEuVHlwZWRKU09OLnN0cmluZ2lmeSh0ZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhdyA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRkLmJhc2UgPT09IG51bGwgfHwgdGQuYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByYXcuYmFzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHJhdy5pbnRlcmFjdGlvbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24uaW5wdXREYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb24uaW5wdXREYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbi5vdXRwdXREYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb24ub3V0cHV0RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24ud3JpdGFibGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvbi53cml0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24ub3V0cHV0RGF0YSAmJiBpbnRlcmFjdGlvbi5vdXRwdXREYXRhLnJlcXVpcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIEhPVEZJWCBmb3IgVHlwZWRKU09OICMjI1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByZXEgaW4gaW50ZXJhY3Rpb24ub3V0cHV0RGF0YS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChpbnRlcmFjdGlvbi5vdXRwdXREYXRhLnJlcXVpcmVkW3JlcV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfWludGVyYWN0aW9uLm91dHB1dERhdGEucmVxdWlyZWQgPSByZXFzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShyYXcpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2VyaWFsaXplVEQoKSBwcm9kdWNlZFxcbmBgYFxcblwiICsganNvbiArIFwiXFxuYGBgXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5zZXJpYWxpemVURCA9IHNlcmlhbGl6ZVREO1xuICAgICAgICB9LCB7IFwiLi90aGluZy1kZXNjcmlwdGlvblwiOiA4LCBcInR5cGVkanNvbi1ucG1cIjogOSwgXCJ1cmxcIjogNSB9XSwgODogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICB2YXIgX19kZWNvcmF0ZSA9IHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsXG4gICAgICAgICAgICAgICAgICAgIGQ7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICAgICAgICAgIH1yZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHZhciB0eXBlZGpzb25fbnBtXzEgPSByZXF1aXJlKFwidHlwZWRqc29uLW5wbVwiKTtcbiAgICAgICAgICAgIHZhciBJbnRlcmFjdGlvblBhdHRlcm47XG4gICAgICAgICAgICAoZnVuY3Rpb24gKEludGVyYWN0aW9uUGF0dGVybikge1xuICAgICAgICAgICAgICAgIEludGVyYWN0aW9uUGF0dGVybltJbnRlcmFjdGlvblBhdHRlcm5bXCJQcm9wZXJ0eVwiXSA9ICdQcm9wZXJ0eSddID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICAgIEludGVyYWN0aW9uUGF0dGVybltJbnRlcmFjdGlvblBhdHRlcm5bXCJBY3Rpb25cIl0gPSAnQWN0aW9uJ10gPSBcIkFjdGlvblwiO1xuICAgICAgICAgICAgICAgIEludGVyYWN0aW9uUGF0dGVybltJbnRlcmFjdGlvblBhdHRlcm5bXCJFdmVudFwiXSA9ICdFdmVudCddID0gXCJFdmVudFwiO1xuICAgICAgICAgICAgfSkoSW50ZXJhY3Rpb25QYXR0ZXJuID0gZXhwb3J0cy5JbnRlcmFjdGlvblBhdHRlcm4gfHwgKGV4cG9ydHMuSW50ZXJhY3Rpb25QYXR0ZXJuID0ge30pKTtcbiAgICAgICAgICAgIHZhciBJbnRlcmFjdGlvbkxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSW50ZXJhY3Rpb25MaW5rKCkge31cbiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZXJhY3Rpb25MaW5rO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBpc1JlcXVpcmVkOiB0cnVlLCB0eXBlOiBTdHJpbmcgfSldLCBJbnRlcmFjdGlvbkxpbmsucHJvdG90eXBlLCBcImhyZWZcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXSwgSW50ZXJhY3Rpb25MaW5rLnByb3RvdHlwZSwgXCJtZWRpYVR5cGVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIEludGVyYWN0aW9uTGluayA9IF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uT2JqZWN0KCldLCBJbnRlcmFjdGlvbkxpbmspO1xuICAgICAgICAgICAgZXhwb3J0cy5JbnRlcmFjdGlvbkxpbmsgPSBJbnRlcmFjdGlvbkxpbms7XG4gICAgICAgICAgICB2YXIgSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtYW50aWNUeXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludGVyYWN0aW9uO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBuYW1lOiAnQHR5cGUnLCBpc1JlcXVpcmVkOiB0cnVlLCBlbGVtZW50czogU3RyaW5nIH0pXSwgSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcInNlbWFudGljVHlwZXNcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXSwgSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgZWxlbWVudHM6IEludGVyYWN0aW9uTGluayB9KV0sIEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJsaW5rXCIsIHZvaWQgMCk7XG4gICAgICAgICAgICBfX2RlY29yYXRlKFt0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IHR5cGU6IEJvb2xlYW4gfSldLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwid3JpdGFibGVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgdHlwZTogT2JqZWN0IH0pXSwgSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcImlucHV0RGF0YVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyB0eXBlOiBPYmplY3QgfSldLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwib3V0cHV0RGF0YVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgSW50ZXJhY3Rpb24gPSBfX2RlY29yYXRlKFt0eXBlZGpzb25fbnBtXzEuSnNvbk9iamVjdCh7IGtub3duVHlwZXM6IFtJbnRlcmFjdGlvbkxpbmtdIH0pXSwgSW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgZXhwb3J0cy5JbnRlcmFjdGlvbiA9IEludGVyYWN0aW9uO1xuICAgICAgICAgICAgdmFyIFRoaW5nRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVGhpbmdEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gWydodHRwOi8vdzNjLmdpdGh1Yi5pby93b3QvdzNjLXdvdC10ZC1jb250ZXh0Lmpzb25sZCddO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWFudGljVHlwZSA9IFsnVGhpbmcnXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gVGhpbmdEZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgbmFtZTogJ0B0eXBlJywgZWxlbWVudHM6IFN0cmluZyB9KV0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcInNlbWFudGljVHlwZVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBpc1JlcXVpcmVkOiB0cnVlLCB0eXBlOiBTdHJpbmcgfSldLCBUaGluZ0Rlc2NyaXB0aW9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgICAgICBfX2RlY29yYXRlKFt0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IHR5cGU6IFN0cmluZyB9KV0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcImJhc2VcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgZWxlbWVudHM6IEludGVyYWN0aW9uIH0pXSwgVGhpbmdEZXNjcmlwdGlvbi5wcm90b3R5cGUsIFwiaW50ZXJhY3Rpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW3R5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgbmFtZTogJ0Bjb250ZXh0JywgZWxlbWVudHM6IFN0cmluZyB9KV0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIFRoaW5nRGVzY3JpcHRpb24gPSBfX2RlY29yYXRlKFt0eXBlZGpzb25fbnBtXzEuSnNvbk9iamVjdCh7IGtub3duVHlwZXM6IFtJbnRlcmFjdGlvbl0gfSldLCBUaGluZ0Rlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IFRoaW5nRGVzY3JpcHRpb247XG4gICAgICAgIH0sIHsgXCJ0eXBlZGpzb24tbnBtXCI6IDkgfV0sIDk6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICAvKiFcbiAgICAgICAgICAgIFR5cGVkSlNPTiB2MC4yLjAgLSBodHRwczovL2dpdGh1Yi5jb20vSm9obldoaXRlVEIvVHlwZWRKU09OXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFR5cGVkIEpTT04gcGFyc2luZyBhbmQgc2VyaWFsaXppbmcgdGhhdCBwcmVzZXJ2ZXMgdHlwZSBpbmZvcm1hdGlvbi4gUGFyc2UgSlNPTiBpbnRvIGFjdHVhbCBjbGFzcyBpbnN0YW5jZXMuIFJlY29tbWVuZGVkIChidXQgbm90IHJlcXVpcmVkKVxuICAgICAgICAgICAgdG8gYmUgdXNlZCB3aXRoIHJlZmxlY3QtbWV0YWRhdGEgKGdsb2JhbCBpbnN0YWxsYXRpb24pOiBodHRwczovL2dpdGh1Yi5jb20vcmJ1Y2t0b24vUmVmbGVjdERlY29yYXRvcnMuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gICAgICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTYgSm9obiBXaGl0ZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gICAgICAgICAgICBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgICAgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICAgICAgICAgICAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgICAgICAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gICAgICAgICAgICBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICAgICAgICAgICAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgbW9kdWxlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobW9kdWxlKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YobW9kdWxlLmV4cG9ydHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7aWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgICAgIHZhciBNRVRBREFUQV9GSUVMRF9LRVkgPSBcIl9fdHlwZWRKc29uSnNvbk9iamVjdE1ldGFkYXRhSW5mb3JtYXRpb25fX1wiO1xuICAgICAgICAgICAgICAgIHZhciBKU09OO1xuICAgICAgICAgICAgICAgIGlmICghSlNPTikge1xuICAgICAgICAgICAgICAgICAgICBKU09OID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHNKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybnZhbCA9IHNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHJldHVybnZhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHJldHVybnZhbCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmFsKCcoJyArIHNKU09OICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjTWFwID0geyAnXCInOiAnXFxcXFwiJywgJ1xcXFwnOiAnXFxcXFxcXFwnLCAnXFxiJzogJ1xcXFxiJywgJ1xcZic6ICdcXFxcZicsICdcXG4nOiAnXFxcXG4nLCAnXFxyJzogJ1xcXFxyJywgJ1xcdCc6ICdcXFxcdCcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjRnVuYyA9IGZ1bmN0aW9uIGVzY0Z1bmMobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjTWFwW21dIHx8IFwiXFxcXHVcIiArIChtLmNoYXJDb2RlQXQoMCkgKyAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVzY1JFID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMUZcXHUyMDI4XFx1MjAyOV0vZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9ICdbJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAoaSA/ICcsICcgOiAnJykgKyBzdHJpbmdpZnkodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1yZXR1cm4gcmVzICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpIHRtcC5wdXNoKHN0cmluZ2lmeShrKSArICc6ICcgKyBzdHJpbmdpZnkodmFsdWVba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd7JyArIHRtcC5qb2luKCcsICcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXCInICsgdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKGVzY1JFLCBlc2NGdW5jKSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgSGVscGVycztcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKEhlbHBlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMuYXNzaWduID0gYXNzaWduO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIFttZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgW1wiRVJST1I6IFwiICsgbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc05hbWUodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIHRhcmdldCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHRhcmdldCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwibmFtZVwiIGluIHRhcmdldFR5cGUgJiYgdHlwZW9mIHRhcmdldFR5cGUubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRUeXBlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRUeXBlLnRvU3RyaW5nKCkubWF0Y2goL2Z1bmN0aW9uIChcXHcqKS8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy5nZXREZWZhdWx0VmFsdWUgPSBnZXREZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGlzcGxheU5hbWUodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENsYXNzTmFtZSh0YXJnZXQpICsgXCIuXCIgKyBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMuZ2V0UHJvcGVydHlEaXNwbGF5TmFtZSA9IGdldFByb3BlcnR5RGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMuaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9iaiA9PT0gU3RyaW5nIHx8IG9iaiBpbnN0YW5jZW9mIE51bWJlciB8fCBvYmogPT09IE51bWJlciB8fCBvYmogaW5zdGFuY2VvZiBCb29sZWFuIHx8IG9iaiA9PT0gQm9vbGVhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNSZXNlcnZlZE1lbWJlck5hbWUobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IE1FVEFEQVRBX0ZJRUxEX0tFWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBIZWxwZXJzLmlzUmVzZXJ2ZWRNZW1iZXJOYW1lID0gaXNSZXNlcnZlZE1lbWJlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzU3VidHlwZU9mKEEsIEIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhUHJvdG90eXBlID0gQS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQSA9PT0gQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVByb3RvdHlwZSBpbnN0YW5jZW9mIEIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFQcm90b3R5cGUgPSBhUHJvdG90eXBlLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBIZWxwZXJzLmlzU3VidHlwZU9mID0gaXNTdWJ0eXBlT2Y7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgW21lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMubG9nID0gbG9nO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKG5leHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSB0YXJnZXRbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMubWVyZ2UgPSBtZXJnZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdmFsdWVJc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMudmFsdWVJc0RlZmluZWQgPSB2YWx1ZUlzRGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgY29uc29sZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnNvbGUpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFtcIldBUk5JTkc6IFwiICsgbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy53YXJuID0gd2FybjtcbiAgICAgICAgICAgICAgICB9KShIZWxwZXJzIHx8IChIZWxwZXJzID0ge30pKTtcbiAgICAgICAgICAgICAgICB2YXIgSnNvbk1lbWJlck1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBKc29uTWVtYmVyTWV0YWRhdGEoKSB7fVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSnNvbk1lbWJlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB2YXIgSnNvbk9iamVjdE1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBKc29uT2JqZWN0TWV0YWRhdGEoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTWVtYmVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0bHlNYXJrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0SnNvbk9iamVjdE5hbWUgPSBmdW5jdGlvbiAodHlwZSwgaW5oZXJpdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdGVkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRGcm9tVHlwZSh0eXBlLCBpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBpbmhlcml0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvdG90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UHJvdG90eXBlLmhhc093blByb3BlcnR5KE1FVEFEQVRBX0ZJRUxEX0tFWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRhcmdldFByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmhlcml0ZWQgJiYgdGFyZ2V0UHJvdG90eXBlW01FVEFEQVRBX0ZJRUxEX0tFWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRhcmdldFByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmlzRXhwbGljaXRseU1hcmtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5nZXRGcm9tSW5zdGFuY2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBpbmhlcml0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tVHlwZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSwgaW5oZXJpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLmdldEtub3duVHlwZU5hbWVGcm9tVHlwZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuZ2V0RnJvbVR5cGUodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSGVscGVycy5nZXRDbGFzc05hbWUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLmdldEtub3duVHlwZU5hbWVGcm9tSW5zdGFuY2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLmdldEZyb21JbnN0YW5jZSh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXJzLmdldENsYXNzTmFtZSh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZSwgXCJkYXRhTWVtYmVyc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YU1lbWJlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHRoaXMuY2xhc3NUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZSwgXCJrbm93blR5cGVzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrbm93blR5cGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrbm93blR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtub3duVHlwZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rbm93blR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGtub3duVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVOYW1lID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEtub3duVHlwZU5hbWVGcm9tVHlwZShrbm93blR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVzW2tub3duVHlwZU5hbWVdID0ga25vd25UeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tub3duVHlwZUNhY2hlID0ga25vd25UeXBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga25vd25UeXBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLnNldEtub3duVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa25vd25UeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tub3duVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rbm93blR5cGVDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUuYWRkTWVtYmVyID0gZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2RhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZGF0YU1lbWJlcnNbcHJvcGVydHlLZXldLm5hbWUgPT09IG1lbWJlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbWVtYmVyIHdpdGggdGhlIG5hbWUgJ1wiICsgbWVtYmVyLm5hbWUgKyBcIicgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YU1lbWJlcnNbbWVtYmVyLmtleV0gPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUuc29ydE1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lbWJlckFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9kYXRhTWVtYmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXJBcnJheS5wdXNoKF90aGlzLl9kYXRhTWVtYmVyc1twcm9wZXJ0eUtleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXJBcnJheSA9IG1lbWJlckFycmF5LnNvcnQodGhpcy5zb3J0TWVtYmVyc0NvbXBhcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YU1lbWJlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGRhdGFNZW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YU1lbWJlcnNbZGF0YU1lbWJlci5rZXldID0gZGF0YU1lbWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLnNvcnRNZW1iZXJzQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGEub3JkZXIgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIub3JkZXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5uYW1lIDwgYi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGEubmFtZSA+IGIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhLm9yZGVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBiLm9yZGVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5vcmRlciA8IGIub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5vcmRlciA+IGIub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEubmFtZSA8IGIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGEubmFtZSA+IGIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpzb25PYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSnNvbk9iamVjdChvcHRpb25zT3JUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yVGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JUYXJnZXQgfHwge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxpemVyID0gb3B0aW9ucy5pbml0aWFsaXplcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBvcHRpb25zLnNlcmlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50TWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShNRVRBREFUQV9GSUVMRF9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBuZXcgSnNvbk9iamVjdE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE1ldGFkYXRhID0gdGFyZ2V0LnByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGFkYXRhLmRhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJQcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldID0gcGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0YWRhdGEua25vd25UeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5zZXRLbm93blR5cGUocGFyZW50TWV0YWRhdGEua25vd25UeXBlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQucHJvdG90eXBlLCBNRVRBREFUQV9GSUVMRF9LRVksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iamVjdE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gdGFyZ2V0LnByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuY2xhc3NUeXBlID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuaXNFeHBsaWNpdGx5TWFya2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5jbGFzc05hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rbm93blR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rbm93blR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGtub3duVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrbm93blR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiS25vd24gdHlwZSAjXCIgKyBpKysgKyBcIiBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc2V0S25vd25UeXBlKGtub3duVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGVscGVycy5lcnJvcihuZXcgVHlwZUVycm9yKFwiQEpzb25PYmplY3Q6IFwiICsgZS5tZXNzYWdlICsgXCIgKG9uICdcIiArIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHRhcmdldCkgKyBcIicpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxpemVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplciA9IGluaXRpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPclRhcmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yKG9wdGlvbnNPclRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cG9ydHMuSnNvbk9iamVjdCA9IEpzb25PYmplY3Q7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ganNvbk1lbWJlclR5cGVJbml0KG1ldGFkYXRhLCBwcm9wZXJ0eU5hbWUsIHdhcm5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2FybkFycmF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5BcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5lbGVtZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuZWxlbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGFkYXRhLmVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnR5cGUgPSBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEudHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FybkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBlcnMud2FybihcIk5vIHZhbGlkICdlbGVtZW50cycgb3B0aW9uIHdhcyBzcGVjaWZpZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgJ2VsZW1lbnRzJyBvcHRpb24gd2FzIHNwZWNpZmllZCBmb3IgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25NZW1iZXJUeXBlSW5pdChtZXRhZGF0YS5lbGVtZW50cywgcHJvcGVydHlOYW1lICsgJ1tdJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YS50eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkICd0eXBlJyBvcHRpb24gd2FzIHNwZWNpZmllZCBmb3IgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBqc29uTWVtYmVyS25vd25UeXBlcyhtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga25vd25UeXBlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVzLnB1c2gobWV0YWRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlcyA9IGtub3duVHlwZXMuY29uY2F0KGpzb25NZW1iZXJLbm93blR5cGVzKG1ldGFkYXRhLmVsZW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtub3duVHlwZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEpzb25NZW1iZXIob3B0aW9uc09yVGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVtYmVyTWV0YWRhdGEgPSBuZXcgSnNvbk1lbWJlck1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5S2V5ID09PSBcInN0cmluZ1wiIHx8ICh0eXBlb2YgcHJvcGVydHlLZXkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihwcm9wZXJ0eUtleSkpID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yVGFyZ2V0IHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvciA9IGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZsZWN0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBIZWxwZXJzLmdldFByb3BlcnR5RGlzcGxheU5hbWUodGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBKc29uTWVtYmVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgc3RhdGljIHByb3BlcnR5ICgnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W3Byb3BlcnR5S2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBKc29uTWVtYmVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbWV0aG9kIHByb3BlcnR5ICgnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiZWxlbWVudFR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWxwZXJzLndhcm4ocHJvcGVydHlOYW1lICsgXCI6IHRoZSAnZWxlbWVudFR5cGUnIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgJ2VsZW1lbnRzJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVsZW1lbnRzID0gb3B0aW9ucy5lbGVtZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbGVtZW50VHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEuZm9yY2VFbmFibGVUeXBlSGludGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEgPSBIZWxwZXJzLmFzc2lnbihtZW1iZXJNZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXJNZXRhZGF0YS5rZXkgPSBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhlbHBlcnMuaXNSZXNlcnZlZE1lbWJlck5hbWUobWVtYmVyTWV0YWRhdGEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASnNvbk1lbWJlcjogJ1wiICsgbWVtYmVyTWV0YWRhdGEubmFtZSArIFwiJyBpcyBhIHJlc2VydmVkIG5hbWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpICYmIHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEpzb25NZW1iZXI6ICd0eXBlJyBvZiAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihSZWZsZWN0KSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZ2V0TWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3RUeXBlID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmbGVjdFR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBKc29uTWVtYmVyOiB0eXBlIGRldGVjdGVkIGZvciAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1iZXJNZXRhZGF0YS50eXBlIHx8IHR5cGVvZiBtZW1iZXJNZXRhZGF0YS50eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEudHlwZSA9IHJlZmxlY3RUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVtYmVyTWV0YWRhdGEudHlwZSAhPT0gcmVmbGVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGVscGVycy53YXJuKFwiQEpzb25NZW1iZXI6ICd0eXBlJyBzcGVjaWZpZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZXRlY3RlZCB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uTWVtYmVyVHlwZUluaXQobWVtYmVyTWV0YWRhdGEsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBREFUQV9GSUVMRF9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBuZXcgSnNvbk9iamVjdE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE1ldGFkYXRhID0gdGFyZ2V0W01FVEFEQVRBX0ZJRUxEX0tFWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlclByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV0gPSBwYXJlbnRNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBREFUQV9GSUVMRF9LRVksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iamVjdE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gdGFyZ2V0W01FVEFEQVRBX0ZJRUxEX0tFWV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uTWVtYmVyS25vd25UeXBlcyhtZW1iZXJNZXRhZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa25vd25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc2V0S25vd25UeXBlKGtub3duVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuYWRkTWVtYmVyKG1lbWJlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZW1iZXIgJ1wiICsgbWVtYmVyTWV0YWRhdGEubmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0cyBvbiAnXCIgKyBIZWxwZXJzLmdldENsYXNzTmFtZShvYmplY3RNZXRhZGF0YS5jbGFzc1R5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUtleSA9PT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHByb3BlcnR5S2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocHJvcGVydHlLZXkpKSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcihvcHRpb25zT3JUYXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5Kc29uTWVtYmVyID0gSnNvbk1lbWJlcjtcbiAgICAgICAgICAgICAgICB2YXIgU2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gU2VyaWFsaXplcigpIHt9XG4gICAgICAgICAgICAgICAgICAgIFNlcmlhbGl6ZXIud3JpdGVPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21JbnN0YW5jZShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE9iamVjdFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gb2JqZWN0TWV0YWRhdGEuY2xhc3NUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMud3JpdGVUb0pzb25PYmplY3Qob2JqZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogT2JqZWN0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgc2V0dGluZ3MucmVwbGFjZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBTZXJpYWxpemVyLndyaXRlVG9Kc29uT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbWl0RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gSGVscGVycy5nZXREZWZhdWx0VmFsdWUoc2V0dGluZ3Mub2JqZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEhlbHBlcnMuaXNQcmltaXRpdmUob2JqZWN0KSB8fCBvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmplY3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ucHVzaCh0aGlzLndyaXRlVG9Kc29uT2JqZWN0KG9iamVjdFtpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHNldHRpbmdzLmVsZW1lbnRzID8gc2V0dGluZ3MuZWxlbWVudHMuZWxlbWVudHMgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBzZXR0aW5ncy5lbGVtZW50cyA/IHNldHRpbmdzLmVsZW1lbnRzLnR5cGUgOiBPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YSA9IEpzb25PYmplY3RNZXRhZGF0YS5nZXRGcm9tSW5zdGFuY2Uob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEgJiYgdHlwZW9mIG9iamVjdE1ldGFkYXRhLnNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gb2JqZWN0TWV0YWRhdGEuc2VyaWFsaXplcihvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyAmJiAoc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyB8fCBvYmplY3QuY29uc3RydWN0b3IgIT09IHNldHRpbmdzLm9iamVjdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW3NldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXldID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEtub3duVHlwZU5hbWVGcm9tSW5zdGFuY2Uob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNvcnRNZW1iZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNZXRhZGF0YSA9IG9iamVjdE1ldGFkYXRhLmRhdGFNZW1iZXJzW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW3Byb3BlcnR5TWV0YWRhdGEubmFtZV0gPSBfdGhpcy53cml0ZVRvSnNvbk9iamVjdChvYmplY3RbcHJvcGVydHlLZXldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBwcm9wZXJ0eU1ldGFkYXRhLmVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0RGVmYXVsdDogcHJvcGVydHlNZXRhZGF0YS5lbWl0RGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcGVydHlNZXRhZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBwcm9wZXJ0eU1ldGFkYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVIaW50UHJvcGVydHlLZXk6IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bcHJvcGVydHlLZXldID0gX3RoaXMud3JpdGVUb0pzb25PYmplY3Qob2JqZWN0W3Byb3BlcnR5S2V5XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXplcjtcbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgdmFyIERlc2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRGVzZXJpYWxpemVyKCkge31cbiAgICAgICAgICAgICAgICAgICAgRGVzZXJpYWxpemVyLnJlYWRPYmplY3QgPSBmdW5jdGlvbiAoanNvbiwgdHlwZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IEpzb25PYmplY3RNZXRhZGF0YS5nZXRGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZShqc29uLCBzZXR0aW5ncy5yZXZpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubWF4T2JqZWN0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50T2JqZWN0cyh2YWx1ZSkgPiBzZXR0aW5ncy5tYXhPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04gZXhjZWVkcyBvYmplY3QgY291bnQgbGltaXQgKFwiICsgc2V0dGluZ3MubWF4T2JqZWN0cyArIFwiKS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLnJlYWRKc29uVG9JbnN0YW5jZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RUeXBlSGludE1vZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlczogbWV0YWRhdGEgPyBtZXRhZGF0YS5rbm93blR5cGVzIDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBEZXNlcmlhbGl6ZXIuY291bnRPYmplY3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoSGVscGVycy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50XzEgKz0gX3RoaXMuY291bnRPYmplY3RzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudF8yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50XzIgKz0gX3RoaXMuY291bnRPYmplY3RzKHZhbHVlW3Byb3BlcnR5S2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgRGVzZXJpYWxpemVyLnJlYWRKc29uVG9JbnN0YW5jZSA9IGZ1bmN0aW9uIChqc29uLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgT2JqZWN0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlSGludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtub3duVHlwZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09IFwidW5kZWZpbmVkXCIgfHwganNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pc1JlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgbWVtYmVyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEhlbHBlcnMuaXNQcmltaXRpdmUoc2V0dGluZ3Mub2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5jb25zdHJ1Y3RvciAhPT0gc2V0dGluZ3Mub2JqZWN0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlTmFtZSA9IEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHNldHRpbmdzLm9iamVjdFR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFR5cGVOYW1lID0gSGVscGVycy5nZXRDbGFzc05hbWUoanNvbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJ1wiICsgZXhwZWN0ZWRUeXBlTmFtZSArIFwiJywgZ290ICdcIiArIGZvdW5kVHlwZU5hbWUgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vYmplY3RUeXBlID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghSGVscGVycy5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlICdBcnJheScsIGdvdCAnXCIgKyBIZWxwZXJzLmdldENsYXNzTmFtZShqc29uLmNvbnN0cnVjdG9yKSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucHVzaChfdGhpcy5yZWFkSnNvblRvSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHNldHRpbmdzLmVsZW1lbnRzID8gc2V0dGluZ3MuZWxlbWVudHMuZWxlbWVudHMgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVzOiBzZXR0aW5ncy5rbm93blR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogc2V0dGluZ3MuZWxlbWVudHMgPyBzZXR0aW5ncy5lbGVtZW50cy50eXBlIDogZWxlbWVudC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RUeXBlSGludE1vZGU6IHNldHRpbmdzLnN0cmljdFR5cGVIaW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVIaW50UHJvcGVydHlLZXk6IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vYmplY3RUeXBlID09PSBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBEYXRlKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0ganNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICdcIiArICh0eXBlb2YganNvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGpzb24pKSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludCA9IGpzb25bc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVIaW50ICYmIHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVIaW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZS1oaW50IChcIiArIHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXkgKyBcIikgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgdHlwZUhpbnQgKyBcIicgaXMgbm90IGEga25vd24gdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0cmljdFR5cGVIaW50TW9kZSAmJiAhSGVscGVycy5pc1N1YnR5cGVPZihzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XSwgc2V0dGluZ3Mub2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIHR5cGVIaW50ICsgXCInIGlzIG5vdCBhIHN1YnR5cGUgb2YgJ1wiICsgSGVscGVycy5nZXRDbGFzc05hbWUoc2V0dGluZ3Mub2JqZWN0VHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGUgPSBzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUoT2JqZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyAmJiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHR5cGUtaGludC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZSA9IHNldHRpbmdzLm9iamVjdFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlKHNldHRpbmdzLm9iamVjdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplcihqc29uKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc29ydE1lbWJlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBPYmplY3RUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNZXRhZGF0YSA9IG9iamVjdE1ldGFkYXRhLmRhdGFNZW1iZXJzW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gX3RoaXMucmVhZEpzb25Ub0luc3RhbmNlKGpzb25bcHJvcGVydHlNZXRhZGF0YS5uYW1lXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogcHJvcGVydHlNZXRhZGF0YS5lbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQ6IHByb3BlcnR5TWV0YWRhdGEuaXNSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlczogSGVscGVycy5tZXJnZShzZXR0aW5ncy5rbm93blR5cGVzLCBvYmplY3RNZXRhZGF0YS5rbm93blR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogcHJvcGVydHlNZXRhZGF0YS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RUeXBlSGludE1vZGU6IHNldHRpbmdzLnN0cmljdFR5cGVIaW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXJzLnZhbHVlSXNEZWZpbmVkKHRlbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbltwcm9wZXJ0eUtleV0gJiYgcHJvcGVydHlLZXkgIT09IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHlLZXldID0gX3RoaXMucmVhZEpzb25Ub0luc3RhbmNlKGpzb25bcHJvcGVydHlLZXldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVzOiBzZXR0aW5ncy5rbm93blR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBqc29uW3Byb3BlcnR5S2V5XS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVR5cGVIaW50czogc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVzZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnU2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogXCJfX3R5cGVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIFR5cGVkSlNPTiA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1NldHRpbmdzID0gSGVscGVycy5tZXJnZShjb25maWdTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemVyLndyaXRlT2JqZWN0KHZhbHVlLCBIZWxwZXJzLm1lcmdlKGNvbmZpZ1NldHRpbmdzLCBzZXR0aW5ncyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoanNvbiwgdHlwZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVzZXJpYWxpemVyLnJlYWRPYmplY3QoanNvbiwgdHlwZSwgSGVscGVycy5tZXJnZShjb25maWdTZXR0aW5ncywgc2V0dGluZ3MgfHwge30pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UuYXBwbHkoSlNPTiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5UeXBlZEpTT04gPSBUeXBlZEpTT047XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwge31dIH0sIHt9LCBbN10pKDcpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYXJzZXIvYnVuZGxlLXBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n")}},[17]);