webpackJsonp([2],{16:function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},17:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (f) {\n    if (( false ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f();\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        var g;if (typeof window !== \"undefined\") {\n            g = window;\n        } else if (typeof global !== \"undefined\") {\n            g = global;\n        } else if (typeof self !== \"undefined\") {\n            g = self;\n        } else {\n            g = this;\n        }g.parser = f();\n    }\n})(function () {\n    var define, module, exports;return function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }({ 1: [function (require, module, exports) {\n            (function (global) {\n                /*! https://mths.be/punycode v1.4.1 by @mathias */\n                ;(function (root) {\n\n                    /** Detect free variables */\n                    var freeExports = (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n                    var freeModule = (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) == 'object' && module && !module.nodeType && module;\n                    var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global;\n                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n                        root = freeGlobal;\n                    }\n\n                    /**\n                     * The `punycode` object.\n                     * @name punycode\n                     * @type Object\n                     */\n                    var punycode,\n\n\n                    /** Highest positive signed 32-bit float value */\n                    maxInt = 2147483647,\n                        // aka. 0x7FFFFFFF or 2^31-1\n\n                    /** Bootstring parameters */\n                    base = 36,\n                        tMin = 1,\n                        tMax = 26,\n                        skew = 38,\n                        damp = 700,\n                        initialBias = 72,\n                        initialN = 128,\n                        // 0x80\n                    delimiter = '-',\n                        // '\\x2D'\n\n                    /** Regular expressions */\n                    regexPunycode = /^xn--/,\n                        regexNonASCII = /[^\\x20-\\x7E]/,\n                        // unprintable ASCII chars + non-ASCII chars\n                    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                        // RFC 3490 separators\n\n                    /** Error messages */\n                    errors = {\n                        'overflow': 'Overflow: input needs wider integers to process',\n                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n                        'invalid-input': 'Invalid input'\n                    },\n\n\n                    /** Convenience shortcuts */\n                    baseMinusTMin = base - tMin,\n                        floor = Math.floor,\n                        stringFromCharCode = String.fromCharCode,\n\n\n                    /** Temporary variable */\n                    key;\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /**\n                     * A generic error utility function.\n                     * @private\n                     * @param {String} type The error type.\n                     * @returns {Error} Throws a `RangeError` with the applicable error message.\n                     */\n                    function error(type) {\n                        throw new RangeError(errors[type]);\n                    }\n\n                    /**\n                     * A generic `Array#map` utility function.\n                     * @private\n                     * @param {Array} array The array to iterate over.\n                     * @param {Function} callback The function that gets called for every array\n                     * item.\n                     * @returns {Array} A new array of values returned by the callback function.\n                     */\n                    function map(array, fn) {\n                        var length = array.length;\n                        var result = [];\n                        while (length--) {\n                            result[length] = fn(array[length]);\n                        }\n                        return result;\n                    }\n\n                    /**\n                     * A simple `Array#map`-like wrapper to work with domain name strings or email\n                     * addresses.\n                     * @private\n                     * @param {String} domain The domain name or email address.\n                     * @param {Function} callback The function that gets called for every\n                     * character.\n                     * @returns {Array} A new string of characters returned by the callback\n                     * function.\n                     */\n                    function mapDomain(string, fn) {\n                        var parts = string.split('@');\n                        var result = '';\n                        if (parts.length > 1) {\n                            // In email addresses, only the domain name should be punycoded. Leave\n                            // the local part (i.e. everything up to `@`) intact.\n                            result = parts[0] + '@';\n                            string = parts[1];\n                        }\n                        // Avoid `split(regex)` for IE8 compatibility. See #17.\n                        string = string.replace(regexSeparators, '\\x2E');\n                        var labels = string.split('.');\n                        var encoded = map(labels, fn).join('.');\n                        return result + encoded;\n                    }\n\n                    /**\n                     * Creates an array containing the numeric code points of each Unicode\n                     * character in the string. While JavaScript uses UCS-2 internally,\n                     * this function will convert a pair of surrogate halves (each of which\n                     * UCS-2 exposes as separate characters) into a single code point,\n                     * matching UTF-16.\n                     * @see `punycode.ucs2.encode`\n                     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                     * @memberOf punycode.ucs2\n                     * @name decode\n                     * @param {String} string The Unicode input string (UCS-2).\n                     * @returns {Array} The new array of code points.\n                     */\n                    function ucs2decode(string) {\n                        var output = [],\n                            counter = 0,\n                            length = string.length,\n                            value,\n                            extra;\n                        while (counter < length) {\n                            value = string.charCodeAt(counter++);\n                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                                // high surrogate, and there is a next character\n                                extra = string.charCodeAt(counter++);\n                                if ((extra & 0xFC00) == 0xDC00) {\n                                    // low surrogate\n                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                                } else {\n                                    // unmatched surrogate; only append this code unit, in case the next\n                                    // code unit is the high surrogate of a surrogate pair\n                                    output.push(value);\n                                    counter--;\n                                }\n                            } else {\n                                output.push(value);\n                            }\n                        }\n                        return output;\n                    }\n\n                    /**\n                     * Creates a string based on an array of numeric code points.\n                     * @see `punycode.ucs2.decode`\n                     * @memberOf punycode.ucs2\n                     * @name encode\n                     * @param {Array} codePoints The array of numeric code points.\n                     * @returns {String} The new Unicode string (UCS-2).\n                     */\n                    function ucs2encode(array) {\n                        return map(array, function (value) {\n                            var output = '';\n                            if (value > 0xFFFF) {\n                                value -= 0x10000;\n                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                                value = 0xDC00 | value & 0x3FF;\n                            }\n                            output += stringFromCharCode(value);\n                            return output;\n                        }).join('');\n                    }\n\n                    /**\n                     * Converts a basic code point into a digit/integer.\n                     * @see `digitToBasic()`\n                     * @private\n                     * @param {Number} codePoint The basic numeric code point value.\n                     * @returns {Number} The numeric value of a basic code point (for use in\n                     * representing integers) in the range `0` to `base - 1`, or `base` if\n                     * the code point does not represent a value.\n                     */\n                    function basicToDigit(codePoint) {\n                        if (codePoint - 48 < 10) {\n                            return codePoint - 22;\n                        }\n                        if (codePoint - 65 < 26) {\n                            return codePoint - 65;\n                        }\n                        if (codePoint - 97 < 26) {\n                            return codePoint - 97;\n                        }\n                        return base;\n                    }\n\n                    /**\n                     * Converts a digit/integer into a basic code point.\n                     * @see `basicToDigit()`\n                     * @private\n                     * @param {Number} digit The numeric value of a basic code point.\n                     * @returns {Number} The basic code point whose value (when used for\n                     * representing integers) is `digit`, which needs to be in the range\n                     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n                     * used; else, the lowercase form is used. The behavior is undefined\n                     * if `flag` is non-zero and `digit` has no uppercase form.\n                     */\n                    function digitToBasic(digit, flag) {\n                        //  0..25 map to ASCII a..z or A..Z\n                        // 26..35 map to ASCII 0..9\n                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n                    }\n\n                    /**\n                     * Bias adaptation function as per section 3.4 of RFC 3492.\n                     * https://tools.ietf.org/html/rfc3492#section-3.4\n                     * @private\n                     */\n                    function adapt(delta, numPoints, firstTime) {\n                        var k = 0;\n                        delta = firstTime ? floor(delta / damp) : delta >> 1;\n                        delta += floor(delta / numPoints);\n                        for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n                            delta = floor(delta / baseMinusTMin);\n                        }\n                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n                    }\n\n                    /**\n                     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n                     * symbols.\n                     * @memberOf punycode\n                     * @param {String} input The Punycode string of ASCII-only symbols.\n                     * @returns {String} The resulting string of Unicode symbols.\n                     */\n                    function decode(input) {\n                        // Don't use UCS-2\n                        var output = [],\n                            inputLength = input.length,\n                            out,\n                            i = 0,\n                            n = initialN,\n                            bias = initialBias,\n                            basic,\n                            j,\n                            index,\n                            oldi,\n                            w,\n                            k,\n                            digit,\n                            t,\n\n                        /** Cached calculation results */\n                        baseMinusT;\n\n                        // Handle the basic code points: let `basic` be the number of input code\n                        // points before the last delimiter, or `0` if there is none, then copy\n                        // the first basic code points to the output.\n\n                        basic = input.lastIndexOf(delimiter);\n                        if (basic < 0) {\n                            basic = 0;\n                        }\n\n                        for (j = 0; j < basic; ++j) {\n                            // if it's not a basic code point\n                            if (input.charCodeAt(j) >= 0x80) {\n                                error('not-basic');\n                            }\n                            output.push(input.charCodeAt(j));\n                        }\n\n                        // Main decoding loop: start just after the last delimiter if any basic code\n                        // points were copied; start at the beginning otherwise.\n\n                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n                            // `index` is the index of the next character to be consumed.\n                            // Decode a generalized variable-length integer into `delta`,\n                            // which gets added to `i`. The overflow checking is easier\n                            // if we increase `i` as we go, then subtract off its starting\n                            // value at the end to obtain `delta`.\n                            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\n                                if (index >= inputLength) {\n                                    error('invalid-input');\n                                }\n\n                                digit = basicToDigit(input.charCodeAt(index++));\n\n                                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                                    error('overflow');\n                                }\n\n                                i += digit * w;\n                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                                if (digit < t) {\n                                    break;\n                                }\n\n                                baseMinusT = base - t;\n                                if (w > floor(maxInt / baseMinusT)) {\n                                    error('overflow');\n                                }\n\n                                w *= baseMinusT;\n                            }\n\n                            out = output.length + 1;\n                            bias = adapt(i - oldi, out, oldi == 0);\n\n                            // `i` was supposed to wrap around from `out` to `0`,\n                            // incrementing `n` each time, so we'll fix that now:\n                            if (floor(i / out) > maxInt - n) {\n                                error('overflow');\n                            }\n\n                            n += floor(i / out);\n                            i %= out;\n\n                            // Insert `n` at position `i` of the output\n                            output.splice(i++, 0, n);\n                        }\n\n                        return ucs2encode(output);\n                    }\n\n                    /**\n                     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n                     * Punycode string of ASCII-only symbols.\n                     * @memberOf punycode\n                     * @param {String} input The string of Unicode symbols.\n                     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n                     */\n                    function encode(input) {\n                        var n,\n                            delta,\n                            handledCPCount,\n                            basicLength,\n                            bias,\n                            j,\n                            m,\n                            q,\n                            k,\n                            t,\n                            currentValue,\n                            output = [],\n\n                        /** `inputLength` will hold the number of code points in `input`. */\n                        inputLength,\n\n                        /** Cached calculation results */\n                        handledCPCountPlusOne,\n                            baseMinusT,\n                            qMinusT;\n\n                        // Convert the input in UCS-2 to Unicode\n                        input = ucs2decode(input);\n\n                        // Cache the length\n                        inputLength = input.length;\n\n                        // Initialize the state\n                        n = initialN;\n                        delta = 0;\n                        bias = initialBias;\n\n                        // Handle the basic code points\n                        for (j = 0; j < inputLength; ++j) {\n                            currentValue = input[j];\n                            if (currentValue < 0x80) {\n                                output.push(stringFromCharCode(currentValue));\n                            }\n                        }\n\n                        handledCPCount = basicLength = output.length;\n\n                        // `handledCPCount` is the number of code points that have been handled;\n                        // `basicLength` is the number of basic code points.\n\n                        // Finish the basic string - if it is not empty - with a delimiter\n                        if (basicLength) {\n                            output.push(delimiter);\n                        }\n\n                        // Main encoding loop:\n                        while (handledCPCount < inputLength) {\n\n                            // All non-basic code points < n have been handled already. Find the next\n                            // larger one:\n                            for (m = maxInt, j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n                                if (currentValue >= n && currentValue < m) {\n                                    m = currentValue;\n                                }\n                            }\n\n                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                            // but guard against overflow\n                            handledCPCountPlusOne = handledCPCount + 1;\n                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                                error('overflow');\n                            }\n\n                            delta += (m - n) * handledCPCountPlusOne;\n                            n = m;\n\n                            for (j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n\n                                if (currentValue < n && ++delta > maxInt) {\n                                    error('overflow');\n                                }\n\n                                if (currentValue == n) {\n                                    // Represent delta as a generalized variable-length integer\n                                    for (q = delta, k = base;; /* no condition */k += base) {\n                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                                        if (q < t) {\n                                            break;\n                                        }\n                                        qMinusT = q - t;\n                                        baseMinusT = base - t;\n                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                                        q = floor(qMinusT / baseMinusT);\n                                    }\n\n                                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                                    delta = 0;\n                                    ++handledCPCount;\n                                }\n                            }\n\n                            ++delta;\n                            ++n;\n                        }\n                        return output.join('');\n                    }\n\n                    /**\n                     * Converts a Punycode string representing a domain name or an email address\n                     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n                     * it doesn't matter if you call it on a string that has already been\n                     * converted to Unicode.\n                     * @memberOf punycode\n                     * @param {String} input The Punycoded domain name or email address to\n                     * convert to Unicode.\n                     * @returns {String} The Unicode representation of the given Punycode\n                     * string.\n                     */\n                    function toUnicode(input) {\n                        return mapDomain(input, function (string) {\n                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n                        });\n                    }\n\n                    /**\n                     * Converts a Unicode string representing a domain name or an email address to\n                     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n                     * i.e. it doesn't matter if you call it with a domain that's already in\n                     * ASCII.\n                     * @memberOf punycode\n                     * @param {String} input The domain name or email address to convert, as a\n                     * Unicode string.\n                     * @returns {String} The Punycode representation of the given domain name or\n                     * email address.\n                     */\n                    function toASCII(input) {\n                        return mapDomain(input, function (string) {\n                            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n                        });\n                    }\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /** Define the public API */\n                    punycode = {\n                        /**\n                         * A string representing the current Punycode.js version number.\n                         * @memberOf punycode\n                         * @type String\n                         */\n                        'version': '1.4.1',\n                        /**\n                         * An object of methods to convert from JavaScript's internal character\n                         * representation (UCS-2) to Unicode code points, and back.\n                         * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                         * @memberOf punycode\n                         * @type Object\n                         */\n                        'ucs2': {\n                            'decode': ucs2decode,\n                            'encode': ucs2encode\n                        },\n                        'decode': decode,\n                        'encode': encode,\n                        'toASCII': toASCII,\n                        'toUnicode': toUnicode\n                    };\n\n                    /** Expose `punycode` */\n                    // Some AMD build optimizers, like r.js, check for specific condition patterns\n                    // like the following:\n                    if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n                        define('punycode', function () {\n                            return punycode;\n                        });\n                    } else if (freeExports && freeModule) {\n                        if (module.exports == freeExports) {\n                            // in Node.js, io.js, or RingoJS v0.8.0+\n                            freeModule.exports = punycode;\n                        } else {\n                            // in Narwhal or RingoJS v0.7.0-\n                            for (key in punycode) {\n                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n                            }\n                        }\n                    } else {\n                        // in Rhino or a web browser\n                        root.punycode = punycode;\n                    }\n                })(this);\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 2: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            // If obj.hasOwnProperty has been overridden, then calling\n            // obj.hasOwnProperty(prop) will break.\n            // See: https://github.com/joyent/node/issues/1707\n\n            function hasOwnProperty(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            }\n\n            module.exports = function (qs, sep, eq, options) {\n                sep = sep || '&';\n                eq = eq || '=';\n                var obj = {};\n\n                if (typeof qs !== 'string' || qs.length === 0) {\n                    return obj;\n                }\n\n                var regexp = /\\+/g;\n                qs = qs.split(sep);\n\n                var maxKeys = 1000;\n                if (options && typeof options.maxKeys === 'number') {\n                    maxKeys = options.maxKeys;\n                }\n\n                var len = qs.length;\n                // maxKeys <= 0 means that we should not limit keys count\n                if (maxKeys > 0 && len > maxKeys) {\n                    len = maxKeys;\n                }\n\n                for (var i = 0; i < len; ++i) {\n                    var x = qs[i].replace(regexp, '%20'),\n                        idx = x.indexOf(eq),\n                        kstr,\n                        vstr,\n                        k,\n                        v;\n\n                    if (idx >= 0) {\n                        kstr = x.substr(0, idx);\n                        vstr = x.substr(idx + 1);\n                    } else {\n                        kstr = x;\n                        vstr = '';\n                    }\n\n                    k = decodeURIComponent(kstr);\n                    v = decodeURIComponent(vstr);\n\n                    if (!hasOwnProperty(obj, k)) {\n                        obj[k] = v;\n                    } else if (isArray(obj[k])) {\n                        obj[k].push(v);\n                    } else {\n                        obj[k] = [obj[k], v];\n                    }\n                }\n\n                return obj;\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n        }, {}], 3: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var stringifyPrimitive = function stringifyPrimitive(v) {\n                switch (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) {\n                    case 'string':\n                        return v;\n\n                    case 'boolean':\n                        return v ? 'true' : 'false';\n\n                    case 'number':\n                        return isFinite(v) ? v : '';\n\n                    default:\n                        return '';\n                }\n            };\n\n            module.exports = function (obj, sep, eq, name) {\n                sep = sep || '&';\n                eq = eq || '=';\n                if (obj === null) {\n                    obj = undefined;\n                }\n\n                if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n                    return map(objectKeys(obj), function (k) {\n                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n                        if (isArray(obj[k])) {\n                            return map(obj[k], function (v) {\n                                return ks + encodeURIComponent(stringifyPrimitive(v));\n                            }).join(sep);\n                        } else {\n                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n                        }\n                    }).join(sep);\n                }\n\n                if (!name) return '';\n                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n\n            function map(xs, f) {\n                if (xs.map) return xs.map(f);\n                var res = [];\n                for (var i = 0; i < xs.length; i++) {\n                    res.push(f(xs[i], i));\n                }\n                return res;\n            }\n\n            var objectKeys = Object.keys || function (obj) {\n                var res = [];\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n                }\n                return res;\n            };\n        }, {}], 4: [function (require, module, exports) {\n            'use strict';\n\n            exports.decode = exports.parse = require('./decode');\n            exports.encode = exports.stringify = require('./encode');\n        }, { \"./decode\": 2, \"./encode\": 3 }], 5: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var punycode = require('punycode');\n            var util = require('./util');\n\n            exports.parse = urlParse;\n            exports.resolve = urlResolve;\n            exports.resolveObject = urlResolveObject;\n            exports.format = urlFormat;\n\n            exports.Url = Url;\n\n            function Url() {\n                this.protocol = null;\n                this.slashes = null;\n                this.auth = null;\n                this.host = null;\n                this.port = null;\n                this.hostname = null;\n                this.hash = null;\n                this.search = null;\n                this.query = null;\n                this.pathname = null;\n                this.path = null;\n                this.href = null;\n            }\n\n            // Reference: RFC 3986, RFC 1808, RFC 2396\n\n            // define these here so at least they only have to be\n            // compiled once on the first module load.\n            var protocolPattern = /^([a-z0-9.+-]+:)/i,\n                portPattern = /:[0-9]*$/,\n\n\n            // Special case for a simple path URL\n            simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n\n            // RFC 2396: characters reserved for delimiting URLs.\n            // We actually just auto-escape these.\n            delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n\n            // RFC 2396: characters not allowed for various reasons.\n            unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n\n            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n            autoEscape = ['\\''].concat(unwise),\n\n            // Characters that are never ever allowed in a hostname.\n            // Note that any invalid chars are also handled, but these\n            // are the ones that are *expected* to be seen, so we fast-path\n            // them.\n            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n                hostEndingChars = ['/', '?', '#'],\n                hostnameMaxLen = 255,\n                hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n\n            // protocols that can allow \"unsafe\" and \"unwise\" chars.\n            unsafeProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that never have a hostname.\n            hostlessProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that always contain a // bit.\n            slashedProtocol = {\n                'http': true,\n                'https': true,\n                'ftp': true,\n                'gopher': true,\n                'file': true,\n                'http:': true,\n                'https:': true,\n                'ftp:': true,\n                'gopher:': true,\n                'file:': true\n            },\n                querystring = require('querystring');\n\n            function urlParse(url, parseQueryString, slashesDenoteHost) {\n                if (url && util.isObject(url) && url instanceof Url) return url;\n\n                var u = new Url();\n                u.parse(url, parseQueryString, slashesDenoteHost);\n                return u;\n            }\n\n            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n                if (!util.isString(url)) {\n                    throw new TypeError(\"Parameter 'url' must be a string, not \" + (typeof url === \"undefined\" ? \"undefined\" : _typeof(url)));\n                }\n\n                // Copy chrome, IE, opera backslash-handling behavior.\n                // Back slashes before the query string get converted to forward slashes\n                // See: https://code.google.com/p/chromium/issues/detail?id=25916\n                var queryIndex = url.indexOf('?'),\n                    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n                    uSplit = url.split(splitter),\n                    slashRegex = /\\\\/g;\n                uSplit[0] = uSplit[0].replace(slashRegex, '/');\n                url = uSplit.join(splitter);\n\n                var rest = url;\n\n                // trim before proceeding.\n                // This is to support parse stuff like \"  http://foo.com  \\n\"\n                rest = rest.trim();\n\n                if (!slashesDenoteHost && url.split('#').length === 1) {\n                    // Try fast path regexp\n                    var simplePath = simplePathPattern.exec(rest);\n                    if (simplePath) {\n                        this.path = rest;\n                        this.href = rest;\n                        this.pathname = simplePath[1];\n                        if (simplePath[2]) {\n                            this.search = simplePath[2];\n                            if (parseQueryString) {\n                                this.query = querystring.parse(this.search.substr(1));\n                            } else {\n                                this.query = this.search.substr(1);\n                            }\n                        } else if (parseQueryString) {\n                            this.search = '';\n                            this.query = {};\n                        }\n                        return this;\n                    }\n                }\n\n                var proto = protocolPattern.exec(rest);\n                if (proto) {\n                    proto = proto[0];\n                    var lowerProto = proto.toLowerCase();\n                    this.protocol = lowerProto;\n                    rest = rest.substr(proto.length);\n                }\n\n                // figure out if it's got a host\n                // user@server is *always* interpreted as a hostname, and url\n                // resolution will treat //foo/bar as host=foo,path=bar because that's\n                // how the browser resolves relative URLs.\n                if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n                    var slashes = rest.substr(0, 2) === '//';\n                    if (slashes && !(proto && hostlessProtocol[proto])) {\n                        rest = rest.substr(2);\n                        this.slashes = true;\n                    }\n                }\n\n                if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n\n                    // there's a hostname.\n                    // the first instance of /, ?, ;, or # ends the host.\n                    //\n                    // If there is an @ in the hostname, then non-host chars *are* allowed\n                    // to the left of the last @ sign, unless some host-ending character\n                    // comes *before* the @-sign.\n                    // URLs are obnoxious.\n                    //\n                    // ex:\n                    // http://a@b@c/ => user:a@b host:c\n                    // http://a@b?@c => user:a host:c path:/?@c\n\n                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n                    // Review our test case against browsers more comprehensively.\n\n                    // find the first instance of any hostEndingChars\n                    var hostEnd = -1;\n                    for (var i = 0; i < hostEndingChars.length; i++) {\n                        var hec = rest.indexOf(hostEndingChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n\n                    // at this point, either we have an explicit point where the\n                    // auth portion cannot go past, or the last @ char is the decider.\n                    var auth, atSign;\n                    if (hostEnd === -1) {\n                        // atSign can be anywhere.\n                        atSign = rest.lastIndexOf('@');\n                    } else {\n                        // atSign must be in auth portion.\n                        // http://a@b/c@d => host:b auth:a path:/c@d\n                        atSign = rest.lastIndexOf('@', hostEnd);\n                    }\n\n                    // Now we have a portion which is definitely the auth.\n                    // Pull that off.\n                    if (atSign !== -1) {\n                        auth = rest.slice(0, atSign);\n                        rest = rest.slice(atSign + 1);\n                        this.auth = decodeURIComponent(auth);\n                    }\n\n                    // the host is the remaining to the left of the first non-host char\n                    hostEnd = -1;\n                    for (var i = 0; i < nonHostChars.length; i++) {\n                        var hec = rest.indexOf(nonHostChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n                    // if we still have not hit it, then the entire thing is a host.\n                    if (hostEnd === -1) hostEnd = rest.length;\n\n                    this.host = rest.slice(0, hostEnd);\n                    rest = rest.slice(hostEnd);\n\n                    // pull out port.\n                    this.parseHost();\n\n                    // we've indicated that there is a hostname,\n                    // so even if it's empty, it has to be present.\n                    this.hostname = this.hostname || '';\n\n                    // if hostname begins with [ and ends with ]\n                    // assume that it's an IPv6 address.\n                    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n                    // validate a little.\n                    if (!ipv6Hostname) {\n                        var hostparts = this.hostname.split(/\\./);\n                        for (var i = 0, l = hostparts.length; i < l; i++) {\n                            var part = hostparts[i];\n                            if (!part) continue;\n                            if (!part.match(hostnamePartPattern)) {\n                                var newpart = '';\n                                for (var j = 0, k = part.length; j < k; j++) {\n                                    if (part.charCodeAt(j) > 127) {\n                                        // we replace non-ASCII char with a temporary placeholder\n                                        // we need this to make sure size of hostname is not\n                                        // broken by replacing non-ASCII by nothing\n                                        newpart += 'x';\n                                    } else {\n                                        newpart += part[j];\n                                    }\n                                }\n                                // we test again with ASCII char only\n                                if (!newpart.match(hostnamePartPattern)) {\n                                    var validParts = hostparts.slice(0, i);\n                                    var notHost = hostparts.slice(i + 1);\n                                    var bit = part.match(hostnamePartStart);\n                                    if (bit) {\n                                        validParts.push(bit[1]);\n                                        notHost.unshift(bit[2]);\n                                    }\n                                    if (notHost.length) {\n                                        rest = '/' + notHost.join('.') + rest;\n                                    }\n                                    this.hostname = validParts.join('.');\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (this.hostname.length > hostnameMaxLen) {\n                        this.hostname = '';\n                    } else {\n                        // hostnames are always lower case.\n                        this.hostname = this.hostname.toLowerCase();\n                    }\n\n                    if (!ipv6Hostname) {\n                        // IDNA Support: Returns a punycoded representation of \"domain\".\n                        // It only converts parts of the domain name that\n                        // have non-ASCII characters, i.e. it doesn't matter if\n                        // you call it with a domain that already is ASCII-only.\n                        this.hostname = punycode.toASCII(this.hostname);\n                    }\n\n                    var p = this.port ? ':' + this.port : '';\n                    var h = this.hostname || '';\n                    this.host = h + p;\n                    this.href += this.host;\n\n                    // strip [ and ] from the hostname\n                    // the host field still retains them, though\n                    if (ipv6Hostname) {\n                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n                        if (rest[0] !== '/') {\n                            rest = '/' + rest;\n                        }\n                    }\n                }\n\n                // now rest is set to the post-host stuff.\n                // chop off any delim chars.\n                if (!unsafeProtocol[lowerProto]) {\n\n                    // First, make 100% sure that any \"autoEscape\" chars get\n                    // escaped, even if encodeURIComponent doesn't think they\n                    // need to be.\n                    for (var i = 0, l = autoEscape.length; i < l; i++) {\n                        var ae = autoEscape[i];\n                        if (rest.indexOf(ae) === -1) continue;\n                        var esc = encodeURIComponent(ae);\n                        if (esc === ae) {\n                            esc = escape(ae);\n                        }\n                        rest = rest.split(ae).join(esc);\n                    }\n                }\n\n                // chop off from the tail first.\n                var hash = rest.indexOf('#');\n                if (hash !== -1) {\n                    // got a fragment string.\n                    this.hash = rest.substr(hash);\n                    rest = rest.slice(0, hash);\n                }\n                var qm = rest.indexOf('?');\n                if (qm !== -1) {\n                    this.search = rest.substr(qm);\n                    this.query = rest.substr(qm + 1);\n                    if (parseQueryString) {\n                        this.query = querystring.parse(this.query);\n                    }\n                    rest = rest.slice(0, qm);\n                } else if (parseQueryString) {\n                    // no query string, but parseQueryString still requested\n                    this.search = '';\n                    this.query = {};\n                }\n                if (rest) this.pathname = rest;\n                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n                    this.pathname = '/';\n                }\n\n                //to support http.request\n                if (this.pathname || this.search) {\n                    var p = this.pathname || '';\n                    var s = this.search || '';\n                    this.path = p + s;\n                }\n\n                // finally, reconstruct the href based on what has been validated.\n                this.href = this.format();\n                return this;\n            };\n\n            // format a parsed object into a url string\n            function urlFormat(obj) {\n                // ensure it's an object, and not a string url.\n                // If it's an obj, this is a no-op.\n                // this way, you can call url_format() on strings\n                // to clean up potentially wonky urls.\n                if (util.isString(obj)) obj = urlParse(obj);\n                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n                return obj.format();\n            }\n\n            Url.prototype.format = function () {\n                var auth = this.auth || '';\n                if (auth) {\n                    auth = encodeURIComponent(auth);\n                    auth = auth.replace(/%3A/i, ':');\n                    auth += '@';\n                }\n\n                var protocol = this.protocol || '',\n                    pathname = this.pathname || '',\n                    hash = this.hash || '',\n                    host = false,\n                    query = '';\n\n                if (this.host) {\n                    host = auth + this.host;\n                } else if (this.hostname) {\n                    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n                    if (this.port) {\n                        host += ':' + this.port;\n                    }\n                }\n\n                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n                    query = querystring.stringify(this.query);\n                }\n\n                var search = this.search || query && '?' + query || '';\n\n                if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n                // unless they had them to begin with.\n                if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n                    host = '//' + (host || '');\n                    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n                } else if (!host) {\n                    host = '';\n                }\n\n                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n                if (search && search.charAt(0) !== '?') search = '?' + search;\n\n                pathname = pathname.replace(/[?#]/g, function (match) {\n                    return encodeURIComponent(match);\n                });\n                search = search.replace('#', '%23');\n\n                return protocol + host + pathname + search + hash;\n            };\n\n            function urlResolve(source, relative) {\n                return urlParse(source, false, true).resolve(relative);\n            }\n\n            Url.prototype.resolve = function (relative) {\n                return this.resolveObject(urlParse(relative, false, true)).format();\n            };\n\n            function urlResolveObject(source, relative) {\n                if (!source) return relative;\n                return urlParse(source, false, true).resolveObject(relative);\n            }\n\n            Url.prototype.resolveObject = function (relative) {\n                if (util.isString(relative)) {\n                    var rel = new Url();\n                    rel.parse(relative, false, true);\n                    relative = rel;\n                }\n\n                var result = new Url();\n                var tkeys = Object.keys(this);\n                for (var tk = 0; tk < tkeys.length; tk++) {\n                    var tkey = tkeys[tk];\n                    result[tkey] = this[tkey];\n                }\n\n                // hash is always overridden, no matter what.\n                // even href=\"\" will remove it.\n                result.hash = relative.hash;\n\n                // if the relative url is empty, then there's nothing left to do here.\n                if (relative.href === '') {\n                    result.href = result.format();\n                    return result;\n                }\n\n                // hrefs like //foo/bar always cut to the protocol.\n                if (relative.slashes && !relative.protocol) {\n                    // take everything except the protocol from relative\n                    var rkeys = Object.keys(relative);\n                    for (var rk = 0; rk < rkeys.length; rk++) {\n                        var rkey = rkeys[rk];\n                        if (rkey !== 'protocol') result[rkey] = relative[rkey];\n                    }\n\n                    //urlParse appends trailing / to urls like http://www.example.com\n                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n                        result.path = result.pathname = '/';\n                    }\n\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (relative.protocol && relative.protocol !== result.protocol) {\n                    // if it's a known url protocol, then changing\n                    // the protocol does weird things\n                    // first, if it's not file:, then we MUST have a host,\n                    // and if there was a path\n                    // to begin with, then we MUST have a path.\n                    // if it is file:, then the host is dropped,\n                    // because that's known to be hostless.\n                    // anything else is assumed to be absolute.\n                    if (!slashedProtocol[relative.protocol]) {\n                        var keys = Object.keys(relative);\n                        for (var v = 0; v < keys.length; v++) {\n                            var k = keys[v];\n                            result[k] = relative[k];\n                        }\n                        result.href = result.format();\n                        return result;\n                    }\n\n                    result.protocol = relative.protocol;\n                    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n                        var relPath = (relative.pathname || '').split('/');\n                        while (relPath.length && !(relative.host = relPath.shift())) {}\n                        if (!relative.host) relative.host = '';\n                        if (!relative.hostname) relative.hostname = '';\n                        if (relPath[0] !== '') relPath.unshift('');\n                        if (relPath.length < 2) relPath.unshift('');\n                        result.pathname = relPath.join('/');\n                    } else {\n                        result.pathname = relative.pathname;\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    result.host = relative.host || '';\n                    result.auth = relative.auth;\n                    result.hostname = relative.hostname || relative.host;\n                    result.port = relative.port;\n                    // to support http.request\n                    if (result.pathname || result.search) {\n                        var p = result.pathname || '';\n                        var s = result.search || '';\n                        result.path = p + s;\n                    }\n                    result.slashes = result.slashes || relative.slashes;\n                    result.href = result.format();\n                    return result;\n                }\n\n                var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n                    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n                    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n                    removeAllDots = mustEndAbs,\n                    srcPath = result.pathname && result.pathname.split('/') || [],\n                    relPath = relative.pathname && relative.pathname.split('/') || [],\n                    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n                // if the url is a non-slashed url, then relative\n                // links like ../.. should be able\n                // to crawl up to the hostname, as well.  This is strange.\n                // result.protocol has already been set by now.\n                // Later on, put the first path part into the host field.\n                if (psychotic) {\n                    result.hostname = '';\n                    result.port = null;\n                    if (result.host) {\n                        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n                    }\n                    result.host = '';\n                    if (relative.protocol) {\n                        relative.hostname = null;\n                        relative.port = null;\n                        if (relative.host) {\n                            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n                        }\n                        relative.host = null;\n                    }\n                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n                }\n\n                if (isRelAbs) {\n                    // it's absolute.\n                    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n                    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    srcPath = relPath;\n                    // fall through to the dot-handling below.\n                } else if (relPath.length) {\n                    // it's relative\n                    // throw away the existing file, and take the new path instead.\n                    if (!srcPath) srcPath = [];\n                    srcPath.pop();\n                    srcPath = srcPath.concat(relPath);\n                    result.search = relative.search;\n                    result.query = relative.query;\n                } else if (!util.isNullOrUndefined(relative.search)) {\n                    // just pull out the search.\n                    // like href='?foo'.\n                    // Put this after the other two cases because it simplifies the booleans\n                    if (psychotic) {\n                        result.hostname = result.host = srcPath.shift();\n                        //occationaly the auth can get stuck only in host\n                        //this especially happens in cases like\n                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                        if (authInHost) {\n                            result.auth = authInHost.shift();\n                            result.host = result.hostname = authInHost.shift();\n                        }\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    //to support http.request\n                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (!srcPath.length) {\n                    // no path at all.  easy.\n                    // we've already handled the other stuff above.\n                    result.pathname = null;\n                    //to support http.request\n                    if (result.search) {\n                        result.path = '/' + result.search;\n                    } else {\n                        result.path = null;\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                // if a url ENDs in . or .., then it must get a trailing slash.\n                // however, if it ends in anything else non-slashy,\n                // then it must NOT get a trailing slash.\n                var last = srcPath.slice(-1)[0];\n                var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n                // strip single dots, resolve double dots to parent dir\n                // if the path tries to go above the root, `up` ends up > 0\n                var up = 0;\n                for (var i = srcPath.length; i >= 0; i--) {\n                    last = srcPath[i];\n                    if (last === '.') {\n                        srcPath.splice(i, 1);\n                    } else if (last === '..') {\n                        srcPath.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        srcPath.splice(i, 1);\n                        up--;\n                    }\n                }\n\n                // if the path is allowed to go above the root, restore leading ..s\n                if (!mustEndAbs && !removeAllDots) {\n                    for (; up--; up) {\n                        srcPath.unshift('..');\n                    }\n                }\n\n                if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n                    srcPath.unshift('');\n                }\n\n                if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n                    srcPath.push('');\n                }\n\n                var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n                // put the host back\n                if (psychotic) {\n                    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n                    //occationaly the auth can get stuck only in host\n                    //this especially happens in cases like\n                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                    if (authInHost) {\n                        result.auth = authInHost.shift();\n                        result.host = result.hostname = authInHost.shift();\n                    }\n                }\n\n                mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n                if (mustEndAbs && !isAbsolute) {\n                    srcPath.unshift('');\n                }\n\n                if (!srcPath.length) {\n                    result.pathname = null;\n                    result.path = null;\n                } else {\n                    result.pathname = srcPath.join('/');\n                }\n\n                //to support request.http\n                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                }\n                result.auth = relative.auth || result.auth;\n                result.slashes = result.slashes || relative.slashes;\n                result.href = result.format();\n                return result;\n            };\n\n            Url.prototype.parseHost = function () {\n                var host = this.host;\n                var port = portPattern.exec(host);\n                if (port) {\n                    port = port[0];\n                    if (port !== ':') {\n                        this.port = port.substr(1);\n                    }\n                    host = host.substr(0, host.length - port.length);\n                }\n                if (host) this.hostname = host;\n            };\n        }, { \"./util\": 6, \"punycode\": 1, \"querystring\": 4 }], 6: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = {\n                isString: function isString(arg) {\n                    return typeof arg === 'string';\n                },\n                isObject: function isObject(arg) {\n                    return (typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg)) === 'object' && arg !== null;\n                },\n                isNull: function isNull(arg) {\n                    return arg === null;\n                },\n                isNullOrUndefined: function isNullOrUndefined(arg) {\n                    return arg == null;\n                }\n            };\n        }, {}], 7: [function (require, module, exports) {\n            \"use strict\";\n\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var thing_description_1 = require(\"./thing-description\");\n            var TD = require(\"./thing-description\");\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            function parseTDObject(td) {\n                return parseTDString(typedjson_npm_1.TypedJSON.stringify(td, { enableTypeHints: false }));\n            }\n            exports.parseTDObject = parseTDObject;\n            function parseTDString(json) {\n                console.log(\"parseTDString() parsing\\n```\\n\" + json + \"\\n```\");\n                var td = typedjson_npm_1.TypedJSON.parse(json, thing_description_1.default);\n                console.log(\"parseTDString() found \" + td.interaction.length + \" Interaction\" + (td.interaction.length === 1 ? '' : 's'));\n                for (var _i = 0, _a = td.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Property.toString()) !== -1) {\n                        console.log(\" * Property '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Property;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Action.toString()) !== -1) {\n                        console.log(\" * Action '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Action;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Event.toString()) !== -1) {\n                        console.log(\" * Event '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Event;\n                    } else {\n                        console.error(\"parseTDString() found unknown Interaction pattern '\" + interaction.semanticTypes + \"'\");\n                    }\n                    if (td.base !== undefined) {\n                        console.log(\"parseTDString() applying base '\" + td.base + \"' to href '\" + interaction.link[0].href + \"'\");\n                        var href = interaction.link[0].href;\n                        var url = require('url');\n                        var n = td.base.indexOf(':');\n                        var pr = td.base.substr(0, n + 1);\n                        var uriTemp = td.base.replace(pr, 'http:');\n                        uriTemp = url.resolve(uriTemp, href);\n                        uriTemp = uriTemp.replace('http:', pr);\n                        interaction.link[0].href = uriTemp;\n                    }\n                }\n                return td;\n            }\n            exports.parseTDString = parseTDString;\n            function serializeTD(td) {\n                typedjson_npm_1.TypedJSON.config({ \"enableTypeHints\": false });\n                var json = typedjson_npm_1.TypedJSON.stringify(td);\n                var raw = JSON.parse(json);\n                if (td.base === null || td.base === undefined) {\n                    delete raw.base;\n                }\n                for (var _i = 0, _a = raw.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.inputData === null) {\n                        delete interaction.inputData;\n                    }\n                    if (interaction.outputData === null) {\n                        delete interaction.outputData;\n                    }\n                    if (interaction.writable === null) {\n                        delete interaction.writable;\n                    }\n                    if (interaction.outputData && interaction.outputData.required !== undefined) {\n                        console.log(\"### HOTFIX for TypedJSON ###\");\n                        var reqs = [];\n                        for (var req in interaction.outputData.required) {\n                            reqs.push(interaction.outputData.required[req]);\n                        }interaction.outputData.required = reqs;\n                    }\n                }\n                json = JSON.stringify(raw);\n                console.log(\"serializeTD() produced\\n```\\n\" + json + \"\\n```\");\n                return json;\n            }\n            exports.serializeTD = serializeTD;\n        }, { \"./thing-description\": 8, \"typedjson-npm\": 9, \"url\": 5 }], 8: [function (require, module, exports) {\n            \"use strict\";\n\n            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n                var c = arguments.length,\n                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n                    d;\n                if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                }return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            var InteractionPattern;\n            (function (InteractionPattern) {\n                InteractionPattern[InteractionPattern[\"Property\"] = 'Property'] = \"Property\";\n                InteractionPattern[InteractionPattern[\"Action\"] = 'Action'] = \"Action\";\n                InteractionPattern[InteractionPattern[\"Event\"] = 'Event'] = \"Event\";\n            })(InteractionPattern = exports.InteractionPattern || (exports.InteractionPattern = {}));\n            var InteractionLink = function () {\n                function InteractionLink() {}\n                return InteractionLink;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"href\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"mediaType\", void 0);\n            InteractionLink = __decorate([typedjson_npm_1.JsonObject()], InteractionLink);\n            exports.InteractionLink = InteractionLink;\n            var Interaction = function () {\n                function Interaction() {\n                    this.semanticTypes = [];\n                    this.link = [];\n                }\n                return Interaction;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', isRequired: true, elements: String })], Interaction.prototype, \"semanticTypes\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], Interaction.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: InteractionLink })], Interaction.prototype, \"link\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Boolean })], Interaction.prototype, \"writable\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"inputData\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"outputData\", void 0);\n            Interaction = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [InteractionLink] })], Interaction);\n            exports.Interaction = Interaction;\n            var ThingDescription = function () {\n                function ThingDescription() {\n                    this.context = ['http://w3c.github.io/wot/w3c-wot-td-context.jsonld'];\n                    this.semanticType = ['Thing'];\n                    this.interaction = [];\n                }\n                return ThingDescription;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', elements: String })], ThingDescription.prototype, \"semanticType\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], ThingDescription.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: String })], ThingDescription.prototype, \"base\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: Interaction })], ThingDescription.prototype, \"interaction\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ name: '@context', elements: String })], ThingDescription.prototype, \"context\", void 0);\n            ThingDescription = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [Interaction] })], ThingDescription);\n            exports.default = ThingDescription;\n        }, { \"typedjson-npm\": 9 }], 9: [function (require, module, exports) {\n            /*!\n            TypedJSON v0.2.0 - https://github.com/JohnWhiteTB/TypedJSON\n            \n            Typed JSON parsing and serializing that preserves type information. Parse JSON into actual class instances. Recommended (but not required)\n            to be used with reflect-metadata (global installation): https://github.com/rbuckton/ReflectDecorators.\n            \n            \n            The MIT License (MIT)\n            Copyright (c) 2016 John White\n            \n            Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the\n            \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish,\n            distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to\n            the following conditions:\n            \n            The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n            \n            THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n            CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n            SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n            */\n            (function (factory) {\n                if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n                    var v = factory(require, exports);if (v !== undefined) module.exports = v;\n                } else if (typeof define === 'function' && define.amd) {\n                    define([\"require\", \"exports\"], factory);\n                }\n            })(function (require, exports) {\n                \"use strict\";\n\n                var METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n                var JSON;\n                if (!JSON) {\n                    JSON = {\n                        parse: function parse(sJSON) {\n                            var returnval = sJSON;\n                            if ((typeof returnval === \"undefined\" ? \"undefined\" : _typeof(returnval)) === 'object') {\n                                return returnval;\n                            } else {\n                                return eval('(' + sJSON + ')');\n                            }\n                        },\n                        stringify: function () {\n                            var toString = Object.prototype.toString;\n                            var isArray = Array.isArray || function (a) {\n                                return toString.call(a) === '[object Array]';\n                            };\n                            var escMap = { '\"': '\\\\\"', '\\\\': '\\\\\\\\', '\\b': '\\\\b', '\\f': '\\\\f', '\\n': '\\\\n', '\\r': '\\\\r', '\\t': '\\\\t' };\n                            var escFunc = function escFunc(m) {\n                                return escMap[m] || \"\\\\u\" + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);\n                            };\n                            var escRE = /[\\\\\"\\u0000-\\u001F\\u2028\\u2029]/g;\n                            return function stringify(value) {\n                                if (value == null) {\n                                    return 'null';\n                                } else if (typeof value === 'number') {\n                                    return isFinite(value) ? value.toString() : 'null';\n                                } else if (typeof value === 'boolean') {\n                                    return value.toString();\n                                } else if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n                                    if (typeof value.toJSON === 'function') {\n                                        return stringify(value.toJSON());\n                                    } else if (isArray(value)) {\n                                        var res = '[';\n                                        for (var i = 0; i < value.length; i++) {\n                                            res += (i ? ', ' : '') + stringify(value[i]);\n                                        }return res + ']';\n                                    } else if (toString.call(value) === '[object Object]') {\n                                        var tmp = [];\n                                        for (var k in value) {\n                                            if (value.hasOwnProperty(k)) tmp.push(stringify(k) + ': ' + stringify(value[k]));\n                                        }\n                                        return '{' + tmp.join(', ') + '}';\n                                    }\n                                }\n                                return '\"' + value.toString().replace(escRE, escFunc) + '\"';\n                            };\n                        }()\n                    };\n                }\n                var Helpers;\n                (function (Helpers) {\n                    function assign(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = Object(target);\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.assign = assign;\n                    function error(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.error === \"function\") {\n                            console.error.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"ERROR: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.error = error;\n                    function getClassName(target) {\n                        var targetType;\n                        if (typeof target === \"function\") {\n                            targetType = target;\n                        } else if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\") {\n                            targetType = target.constructor;\n                        }\n                        if (!targetType) {\n                            return \"undefined\";\n                        }\n                        if (\"name\" in targetType && typeof targetType.name === \"string\") {\n                            return targetType.name;\n                        } else {\n                            return targetType.toString().match(/function (\\w*)/)[1];\n                        }\n                    }\n                    Helpers.getClassName = getClassName;\n                    function getDefaultValue(type) {\n                        switch (type) {\n                            case Number:\n                                return 0;\n                            case String:\n                                return \"\";\n                            case Boolean:\n                                return false;\n                            case Array:\n                                return [];\n                            default:\n                                return null;\n                        }\n                    }\n                    Helpers.getDefaultValue = getDefaultValue;\n                    function getPropertyDisplayName(target, propertyKey) {\n                        return getClassName(target) + \".\" + propertyKey.toString();\n                    }\n                    Helpers.getPropertyDisplayName = getPropertyDisplayName;\n                    function isArray(object) {\n                        if (typeof Array.isArray === \"function\") {\n                            return Array.isArray(object);\n                        } else {\n                            if (object instanceof Array) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        }\n                    }\n                    Helpers.isArray = isArray;\n                    function isPrimitive(obj) {\n                        switch (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) {\n                            case \"string\":\n                            case \"number\":\n                            case \"boolean\":\n                                return true;\n                        }\n                        if (obj instanceof String || obj === String || obj instanceof Number || obj === Number || obj instanceof Boolean || obj === Boolean) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    Helpers.isPrimitive = isPrimitive;\n                    function isReservedMemberName(name) {\n                        return name === METADATA_FIELD_KEY;\n                    }\n                    Helpers.isReservedMemberName = isReservedMemberName;\n                    function isSubtypeOf(A, B) {\n                        var aPrototype = A.prototype;\n                        if (A === B) {\n                            return true;\n                        }\n                        while (aPrototype) {\n                            if (aPrototype instanceof B) {\n                                return true;\n                            }\n                            aPrototype = aPrototype.prototype;\n                        }\n                        return false;\n                    }\n                    Helpers.isSubtypeOf = isSubtypeOf;\n                    function log(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.log = log;\n                    function merge(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = {};\n                        Object.keys(target).forEach(function (nextKey) {\n                            output[nextKey] = target[nextKey];\n                        });\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.merge = merge;\n                    function valueIsDefined(value) {\n                        if (typeof value === \"undefined\" || value === null) {\n                            return false;\n                        } else {\n                            return true;\n                        }\n                    }\n                    Helpers.valueIsDefined = valueIsDefined;\n                    function warn(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.warn === \"function\") {\n                            console.warn.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"WARNING: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.warn = warn;\n                })(Helpers || (Helpers = {}));\n                var JsonMemberMetadata = function () {\n                    function JsonMemberMetadata() {}\n                    return JsonMemberMetadata;\n                }();\n                var JsonObjectMetadata = function () {\n                    function JsonObjectMetadata() {\n                        this._dataMembers = {};\n                        this._knownTypes = [];\n                        this._knownTypeCache = null;\n                        this.isExplicitlyMarked = false;\n                    }\n                    JsonObjectMetadata.getJsonObjectName = function (type, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var metadata = this.getFromType(type, inherited);\n                        if (metadata !== null) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(type);\n                        }\n                    };\n                    JsonObjectMetadata.getFromType = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var targetPrototype;\n                        var metadata;\n                        if (typeof target === \"function\") {\n                            targetPrototype = target.prototype;\n                        } else {\n                            targetPrototype = target;\n                        }\n                        if (!targetPrototype) {\n                            return null;\n                        }\n                        if (targetPrototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        } else if (inherited && targetPrototype[METADATA_FIELD_KEY]) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        }\n                        if (metadata && metadata.isExplicitlyMarked) {\n                            return metadata;\n                        } else {\n                            return null;\n                        }\n                    };\n                    JsonObjectMetadata.getFromInstance = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        return this.getFromType(Object.getPrototypeOf(target), inherited);\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromType = function (target) {\n                        var metadata = this.getFromType(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target);\n                        }\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromInstance = function (target) {\n                        var metadata = this.getFromInstance(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target.constructor);\n                        }\n                    };\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"dataMembers\", {\n                        get: function get() {\n                            return this._dataMembers;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"className\", {\n                        get: function get() {\n                            if (typeof this._className === \"string\") {\n                                return this._className;\n                            } else {\n                                return Helpers.getClassName(this.classType);\n                            }\n                        },\n                        set: function set(value) {\n                            this._className = value;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"knownTypes\", {\n                        get: function get() {\n                            var knownTypes;\n                            var knownTypeName;\n                            knownTypes = {};\n                            this._knownTypes.forEach(function (knownType) {\n                                knownTypeName = JsonObjectMetadata.getKnownTypeNameFromType(knownType);\n                                knownTypes[knownTypeName] = knownType;\n                            });\n                            this._knownTypeCache = knownTypes;\n                            return knownTypes;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    JsonObjectMetadata.prototype.setKnownType = function (type) {\n                        if (this._knownTypes.indexOf(type) === -1) {\n                            this._knownTypes.push(type);\n                            this._knownTypeCache = null;\n                        }\n                    };\n                    JsonObjectMetadata.prototype.addMember = function (member) {\n                        var _this = this;\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            if (_this._dataMembers[propertyKey].name === member.name) {\n                                throw new Error(\"A member with the name '\" + member.name + \"' already exists.\");\n                            }\n                        });\n                        this._dataMembers[member.key] = member;\n                    };\n                    JsonObjectMetadata.prototype.sortMembers = function () {\n                        var _this = this;\n                        var memberArray = [];\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            memberArray.push(_this._dataMembers[propertyKey]);\n                        });\n                        memberArray = memberArray.sort(this.sortMembersCompare);\n                        this._dataMembers = {};\n                        memberArray.forEach(function (dataMember) {\n                            _this._dataMembers[dataMember.key] = dataMember;\n                        });\n                    };\n                    JsonObjectMetadata.prototype.sortMembersCompare = function (a, b) {\n                        if (typeof a.order !== \"number\" && typeof b.order !== \"number\") {\n                            if (a.name < b.name) {\n                                return -1;\n                            } else if (a.name > b.name) {\n                                return 1;\n                            }\n                        } else if (typeof a.order !== \"number\") {\n                            return 1;\n                        } else if (typeof b.order !== \"number\") {\n                            return -1;\n                        } else {\n                            if (a.order < b.order) {\n                                return -1;\n                            } else if (a.order > b.order) {\n                                return 1;\n                            } else {\n                                if (a.name < b.name) {\n                                    return -1;\n                                } else if (a.name > b.name) {\n                                    return 1;\n                                }\n                            }\n                        }\n                        return 0;\n                    };\n                    return JsonObjectMetadata;\n                }();\n                function JsonObject(optionsOrTarget) {\n                    var options;\n                    if (typeof optionsOrTarget === \"function\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    var initializer = options.initializer;\n                    var serializer = options.serializer;\n                    var decorator = function decorator(target) {\n                        var objectMetadata;\n                        var parentMetadata;\n                        var i;\n                        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target.prototype[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                                Object.keys(parentMetadata.knownTypes).forEach(function (key) {\n                                    objectMetadata.setKnownType(parentMetadata.knownTypes[key]);\n                                });\n                            }\n                            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n                        }\n                        objectMetadata.classType = target;\n                        objectMetadata.isExplicitlyMarked = true;\n                        if (options.name) {\n                            objectMetadata.className = options.name;\n                        }\n                        if (options.knownTypes) {\n                            i = 0;\n                            try {\n                                options.knownTypes.forEach(function (knownType) {\n                                    if (typeof knownType === \"undefined\") {\n                                        throw new TypeError(\"Known type #\" + i++ + \" is undefined.\");\n                                    }\n                                    objectMetadata.setKnownType(knownType);\n                                });\n                            } catch (e) {\n                                Helpers.error(new TypeError(\"@JsonObject: \" + e.message + \" (on '\" + Helpers.getClassName(target) + \"')\"));\n                            }\n                        }\n                        if (typeof initializer === \"function\") {\n                            objectMetadata.initializer = initializer;\n                        }\n\n                        if (typeof serializer === \"function\") {\n                            objectMetadata.serializer = serializer;\n                        }\n                    };\n                    if (typeof optionsOrTarget === \"function\") {\n                        return decorator(optionsOrTarget);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonObject = JsonObject;\n                function jsonMemberTypeInit(metadata, propertyName, warnArray) {\n                    if (warnArray === void 0) {\n                        warnArray = false;\n                    }\n                    if (metadata.elements) {\n                        if (typeof metadata.elements === \"function\") {\n                            metadata.elements = {\n                                type: metadata.elements\n                            };\n                        }\n                        if (!metadata.type) {\n                            metadata.type = Array;\n                        }\n                    }\n                    if (metadata.type === Array) {\n                        if (!metadata.elements) {\n                            if (warnArray) {\n                                Helpers.warn(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            } else {\n                                throw new Error(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            }\n                        } else {\n                            jsonMemberTypeInit(metadata.elements, propertyName + '[]', true);\n                        }\n                    }\n                    if (typeof metadata.type !== \"function\") {\n                        throw new Error(\"No valid 'type' option was specified for '\" + propertyName + \"'.\");\n                    }\n                }\n                function jsonMemberKnownTypes(metadata) {\n                    var knownTypes = new Array();\n                    knownTypes.push(metadata.type);\n                    if (metadata.elements) {\n                        knownTypes = knownTypes.concat(jsonMemberKnownTypes(metadata.elements));\n                    }\n                    return knownTypes;\n                }\n                function JsonMember(optionsOrTarget, propertyKey) {\n                    var memberMetadata = new JsonMemberMetadata();\n                    var options;\n                    var decorator;\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    decorator = function decorator(target, propertyKey) {\n                        var descriptor = Object.getOwnPropertyDescriptor(target, propertyKey.toString());\n                        ;\n                        var objectMetadata;\n                        var parentMetadata;\n                        var reflectType;\n                        var propertyName = Helpers.getPropertyDisplayName(target, propertyKey);\n                        if (typeof target === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a static property ('\" + propertyName + \"').\");\n                        }\n                        if (typeof target[propertyKey] === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a method property ('\" + propertyName + \"').\");\n                        }\n                        if (options.hasOwnProperty(\"elementType\")) {\n                            Helpers.warn(propertyName + \": the 'elementType' option is deprecated, use 'elements' instead.\");\n                            options.elements = options.elementType;\n                            if (options.elementType === Array) {\n                                memberMetadata.forceEnableTypeHinting = true;\n                            }\n                        }\n                        memberMetadata = Helpers.assign(memberMetadata, options);\n                        memberMetadata.key = propertyKey.toString();\n                        memberMetadata.name = options.name || propertyKey.toString();\n                        if (Helpers.isReservedMemberName(memberMetadata.name)) {\n                            throw new Error(\"@JsonMember: '\" + memberMetadata.name + \"' is a reserved name.\");\n                        }\n                        if (options.hasOwnProperty(\"type\") && typeof options.type === \"undefined\") {\n                            throw new TypeError(\"@JsonMember: 'type' of '\" + propertyName + \"' is undefined.\");\n                        }\n                        if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.getMetadata === \"function\") {\n                            reflectType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n                            if (typeof reflectType === \"undefined\") {\n                                throw new TypeError(\"@JsonMember: type detected for '\" + propertyName + \"' is undefined.\");\n                            }\n                            if (!memberMetadata.type || typeof memberMetadata.type !== \"function\") {\n                                memberMetadata.type = reflectType;\n                            } else if (memberMetadata.type !== reflectType) {\n                                Helpers.warn(\"@JsonMember: 'type' specified for '\" + propertyName + \"' does not match detected type.\");\n                            }\n                        }\n                        jsonMemberTypeInit(memberMetadata, propertyName);\n                        if (!target.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                            }\n                            Object.defineProperty(target, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target[METADATA_FIELD_KEY];\n                        }\n                        jsonMemberKnownTypes(memberMetadata).forEach(function (knownType) {\n                            objectMetadata.setKnownType(knownType);\n                        });\n                        try {\n                            objectMetadata.addMember(memberMetadata);\n                        } catch (e) {\n                            throw new Error(\"Member '\" + memberMetadata.name + \"' already exists on '\" + Helpers.getClassName(objectMetadata.classType) + \"'.\");\n                        }\n                    };\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        return decorator(optionsOrTarget, propertyKey);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonMember = JsonMember;\n                var Serializer = function () {\n                    function Serializer() {}\n                    Serializer.writeObject = function (object, settings) {\n                        var objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                        var ObjectType;\n                        if (objectMetadata) {\n                            ObjectType = objectMetadata.classType;\n                        } else {\n                            ObjectType = object.constructor;\n                        }\n                        return JSON.stringify(this.writeToJsonObject(object, {\n                            objectType: ObjectType,\n                            enableTypeHints: settings.enableTypeHints,\n                            typeHintPropertyKey: settings.typeHintPropertyKey\n                        }), settings.replacer);\n                    };\n                    Serializer.writeToJsonObject = function (object, settings) {\n                        var _this = this;\n                        var json;\n                        var objectMetadata;\n                        if (object === null || typeof object === \"undefined\") {\n                            if (settings.emitDefault) {\n                                json = Helpers.getDefaultValue(settings.objectType);\n                            } else {\n                                json = object;\n                            }\n                        } else if (Helpers.isPrimitive(object) || object instanceof Date) {\n                            json = object;\n                        } else if (object instanceof Array) {\n                            json = [];\n                            for (var i = 0, n = object.length; i < n; i++) {\n                                json.push(this.writeToJsonObject(object[i], {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    objectType: settings.elements ? settings.elements.type : Object,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            }\n                        } else {\n                            objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                            if (objectMetadata && typeof objectMetadata.serializer === \"function\") {\n                                json = objectMetadata.serializer(object);\n                            } else {\n                                json = {};\n                                if (settings.enableTypeHints && (settings.requireTypeHints || object.constructor !== settings.objectType)) {\n                                    json[settings.typeHintPropertyKey] = JsonObjectMetadata.getKnownTypeNameFromInstance(object);\n                                }\n                                if (objectMetadata) {\n                                    objectMetadata.sortMembers();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        json[propertyMetadata.name] = _this.writeToJsonObject(object[propertyKey], {\n                                            elements: propertyMetadata.elements,\n                                            emitDefault: propertyMetadata.emitDefaultValue,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            name: propertyMetadata.name,\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                } else {\n                                    Object.keys(object).forEach(function (propertyKey) {\n                                        json[propertyKey] = _this.writeToJsonObject(object[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            objectType: Object,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                }\n                            }\n                        }\n                        return json;\n                    };\n                    return Serializer;\n                }();\n                var Deserializer = function () {\n                    function Deserializer() {}\n                    Deserializer.readObject = function (json, type, settings) {\n                        var value;\n                        var instance;\n                        var metadata = JsonObjectMetadata.getFromType(type);\n                        if (typeof json === 'Object') {\n                            value = json;\n                        } else {\n                            value = JSON.parse(json, settings.reviver);\n                        }\n                        if (typeof settings.maxObjects === \"number\") {\n                            if (this.countObjects(value) > settings.maxObjects) {\n                                throw new Error(\"JSON exceeds object count limit (\" + settings.maxObjects + \").\");\n                            }\n                        }\n                        instance = this.readJsonToInstance(value, {\n                            objectType: type,\n                            typeHintPropertyKey: settings.typeHintPropertyKey,\n                            enableTypeHints: settings.enableTypeHints,\n                            strictTypeHintMode: true,\n                            knownTypes: metadata ? metadata.knownTypes : {}\n                        });\n                        return instance;\n                    };\n                    Deserializer.countObjects = function (value) {\n                        var _this = this;\n                        switch (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) {\n                            case \"object\":\n                                if (value === null) {\n                                    return 0;\n                                } else if (Helpers.isArray(value)) {\n                                    var count_1 = 0;\n                                    value.forEach(function (item) {\n                                        count_1 += _this.countObjects(item);\n                                    });\n                                    return count_1;\n                                } else {\n                                    var count_2 = 0;\n                                    Object.keys(value).forEach(function (propertyKey) {\n                                        count_2 += _this.countObjects(value[propertyKey]);\n                                    });\n                                    return count_2;\n                                }\n                            case \"undefined\":\n                                return 0;\n                            default:\n                                return 1;\n                        }\n                    };\n                    Deserializer.readJsonToInstance = function (json, settings) {\n                        var _this = this;\n                        var object;\n                        var objectMetadata;\n                        var ObjectType;\n                        var typeHint;\n                        var temp;\n                        var knownTypes;\n                        if (typeof json === \"undefined\" || json === null) {\n                            if (settings.isRequired) {\n                                throw new Error(\"Missing required member.\");\n                            }\n                        } else if (Helpers.isPrimitive(settings.objectType)) {\n                            if (json.constructor !== settings.objectType) {\n                                var expectedTypeName = Helpers.getClassName(settings.objectType).toLowerCase();\n                                var foundTypeName = Helpers.getClassName(json.constructor).toLowerCase();\n                                throw new TypeError(\"Expected value to be of type '\" + expectedTypeName + \"', got '\" + foundTypeName + \"'.\");\n                            }\n                            object = json;\n                        } else if (settings.objectType === Array) {\n                            if (!Helpers.isArray(json)) {\n                                throw new TypeError(\"Expected value to be of type 'Array', got '\" + Helpers.getClassName(json.constructor) + \"'.\");\n                            }\n                            object = [];\n                            json.forEach(function (element) {\n                                object.push(_this.readJsonToInstance(element, {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    knownTypes: settings.knownTypes,\n                                    objectType: settings.elements ? settings.elements.type : element.constructor,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    strictTypeHintMode: settings.strictTypeHintMode,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            });\n                        } else if (settings.objectType === Date) {\n                            if (typeof json === \"string\") {\n                                object = new Date(json);\n                            } else if (json instanceof Date) {\n                                object = json;\n                            } else {\n                                throw new TypeError(\"Expected value to be of type 'string', got '\" + (typeof json === \"undefined\" ? \"undefined\" : _typeof(json)) + \"'.\");\n                            }\n                        } else {\n                            typeHint = json[settings.typeHintPropertyKey];\n                            if (typeHint && settings.enableTypeHints) {\n                                if (typeof typeHint !== \"string\") {\n                                    throw new TypeError(\"Type-hint (\" + settings.typeHintPropertyKey + \") must be a string.\");\n                                }\n                                if (!settings.knownTypes[typeHint]) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a known type.\");\n                                }\n                                if (settings.strictTypeHintMode && !Helpers.isSubtypeOf(settings.knownTypes[typeHint], settings.objectType)) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a subtype of '\" + Helpers.getClassName(settings.objectType) + \"'.\");\n                                }\n                                ObjectType = settings.knownTypes[typeHint];\n                                objectMetadata = JsonObjectMetadata.getFromType(ObjectType);\n                            } else {\n                                if (settings.enableTypeHints && settings.requireTypeHints) {\n                                    throw new Error(\"Missing required type-hint.\");\n                                }\n                                ObjectType = settings.objectType;\n                                objectMetadata = JsonObjectMetadata.getFromType(settings.objectType);\n                            }\n                            if (objectMetadata) {\n                                if (typeof objectMetadata.initializer === \"function\") {\n                                    object = objectMetadata.initializer(json) || null;\n                                } else {\n                                    objectMetadata.sortMembers();\n                                    object = new ObjectType();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        temp = _this.readJsonToInstance(json[propertyMetadata.name], {\n                                            elements: propertyMetadata.elements,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            isRequired: propertyMetadata.isRequired,\n                                            knownTypes: Helpers.merge(settings.knownTypes, objectMetadata.knownTypes || {}),\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            strictTypeHintMode: settings.strictTypeHintMode,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                        if (Helpers.valueIsDefined(temp)) {\n                                            object[propertyKey] = temp;\n                                        }\n                                    });\n                                }\n                            } else {\n                                object = {};\n                                Object.keys(json).forEach(function (propertyKey) {\n                                    if (json[propertyKey] && propertyKey !== settings.typeHintPropertyKey) {\n                                        object[propertyKey] = _this.readJsonToInstance(json[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            knownTypes: settings.knownTypes,\n                                            objectType: json[propertyKey].constructor,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                        return object;\n                    };\n                    return Deserializer;\n                }();\n                var configSettings = {\n                    enableTypeHints: true,\n                    typeHintPropertyKey: \"__type\"\n                };\n                var TypedJSON = {\n                    config: function config(settings) {\n                        configSettings = Helpers.merge(configSettings, settings);\n                    },\n                    stringify: function stringify(value, settings) {\n                        return Serializer.writeObject(value, Helpers.merge(configSettings, settings || {}));\n                    },\n                    parse: function parse(json, type, settings) {\n                        if (JsonObjectMetadata.getFromType(type)) {\n                            return Deserializer.readObject(json, type, Helpers.merge(configSettings, settings || {}));\n                        } else {\n                            return JSON.parse.apply(JSON, arguments);\n                        }\n                    }\n                };\n                exports.TypedJSON = TypedJSON;\n            });\n        }, {}] }, {}, [7])(7);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYXJzZXIvYnVuZGxlLXBhcnNlci5qcz8zYzFkIl0sIm5hbWVzIjpbImYiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiZyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJwYXJzZXIiLCJlIiwidCIsIm4iLCJyIiwicyIsIm8iLCJ1IiwiYSIsInJlcXVpcmUiLCJpIiwiRXJyb3IiLCJjb2RlIiwibCIsImNhbGwiLCJsZW5ndGgiLCJyb290IiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwicHVueWNvZGUiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJrZXkiLCJlcnJvciIsInR5cGUiLCJSYW5nZUVycm9yIiwibWFwIiwiYXJyYXkiLCJmbiIsInJlc3VsdCIsIm1hcERvbWFpbiIsInN0cmluZyIsInBhcnRzIiwic3BsaXQiLCJyZXBsYWNlIiwibGFiZWxzIiwiZW5jb2RlZCIsImpvaW4iLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsInZhbHVlIiwiZXh0cmEiLCJjaGFyQ29kZUF0IiwicHVzaCIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiayIsImRlY29kZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJvdXQiLCJiaWFzIiwiYmFzaWMiLCJqIiwiaW5kZXgiLCJvbGRpIiwidyIsImJhc2VNaW51c1QiLCJsYXN0SW5kZXhPZiIsInNwbGljZSIsImVuY29kZSIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJtIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0ZXN0Iiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInRvQVNDSUkiLCJhbWQiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJxcyIsInNlcCIsImVxIiwib3B0aW9ucyIsInJlZ2V4cCIsIm1heEtleXMiLCJsZW4iLCJ4IiwiaWR4IiwiaW5kZXhPZiIsImtzdHIiLCJ2c3RyIiwidiIsInN1YnN0ciIsImRlY29kZVVSSUNvbXBvbmVudCIsImlzQXJyYXkiLCJBcnJheSIsInhzIiwidG9TdHJpbmciLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJpc0Zpbml0ZSIsIm5hbWUiLCJ1bmRlZmluZWQiLCJvYmplY3RLZXlzIiwia3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXMiLCJrZXlzIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ1dGlsIiwidXJsUGFyc2UiLCJyZXNvbHZlIiwidXJsUmVzb2x2ZSIsInJlc29sdmVPYmplY3QiLCJ1cmxSZXNvbHZlT2JqZWN0IiwiZm9ybWF0IiwidXJsRm9ybWF0IiwiVXJsIiwicHJvdG9jb2wiLCJzbGFzaGVzIiwiYXV0aCIsImhvc3QiLCJwb3J0IiwiaG9zdG5hbWUiLCJoYXNoIiwic2VhcmNoIiwicXVlcnkiLCJwYXRobmFtZSIsInBhdGgiLCJocmVmIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImNvbmNhdCIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInF1ZXJ5c3RyaW5nIiwidXJsIiwicGFyc2VRdWVyeVN0cmluZyIsInNsYXNoZXNEZW5vdGVIb3N0IiwiaXNPYmplY3QiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInF1ZXJ5SW5kZXgiLCJzcGxpdHRlciIsInVTcGxpdCIsInNsYXNoUmVnZXgiLCJyZXN0IiwidHJpbSIsInNpbXBsZVBhdGgiLCJleGVjIiwicHJvdG8iLCJsb3dlclByb3RvIiwibWF0Y2giLCJob3N0RW5kIiwiaGVjIiwiYXRTaWduIiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJwIiwiaCIsImFlIiwiZXNjIiwiZXNjYXBlIiwicW0iLCJjaGFyQXQiLCJzb3VyY2UiLCJyZWxhdGl2ZSIsInJlbCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwic2hpZnQiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwicG9wIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJhdXRoSW5Ib3N0IiwiaXNOdWxsIiwibGFzdCIsImhhc1RyYWlsaW5nU2xhc2giLCJ1cCIsImlzQWJzb2x1dGUiLCJhcmciLCJkZWZpbmVQcm9wZXJ0eSIsInRoaW5nX2Rlc2NyaXB0aW9uXzEiLCJURCIsInR5cGVkanNvbl9ucG1fMSIsInBhcnNlVERPYmplY3QiLCJ0ZCIsInBhcnNlVERTdHJpbmciLCJUeXBlZEpTT04iLCJlbmFibGVUeXBlSGludHMiLCJqc29uIiwiY29uc29sZSIsImxvZyIsImRlZmF1bHQiLCJpbnRlcmFjdGlvbiIsIl9pIiwiX2EiLCJzZW1hbnRpY1R5cGVzIiwiSW50ZXJhY3Rpb25QYXR0ZXJuIiwiUHJvcGVydHkiLCJwYXR0ZXJuIiwiQWN0aW9uIiwiRXZlbnQiLCJsaW5rIiwicHIiLCJ1cmlUZW1wIiwic2VyaWFsaXplVEQiLCJjb25maWciLCJyYXciLCJKU09OIiwiaW5wdXREYXRhIiwib3V0cHV0RGF0YSIsIndyaXRhYmxlIiwicmVxdWlyZWQiLCJyZXFzIiwicmVxIiwiX19kZWNvcmF0ZSIsImRlY29yYXRvcnMiLCJ0YXJnZXQiLCJkZXNjIiwiYyIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImQiLCJSZWZsZWN0IiwiZGVjb3JhdGUiLCJJbnRlcmFjdGlvbkxpbmsiLCJKc29uTWVtYmVyIiwiaXNSZXF1aXJlZCIsIkpzb25PYmplY3QiLCJJbnRlcmFjdGlvbiIsImVsZW1lbnRzIiwiQm9vbGVhbiIsImtub3duVHlwZXMiLCJUaGluZ0Rlc2NyaXB0aW9uIiwiY29udGV4dCIsInNlbWFudGljVHlwZSIsImZhY3RvcnkiLCJNRVRBREFUQV9GSUVMRF9LRVkiLCJzSlNPTiIsInJldHVybnZhbCIsImV2YWwiLCJlc2NNYXAiLCJlc2NGdW5jIiwiZXNjUkUiLCJ0b0pTT04iLCJ0bXAiLCJIZWxwZXJzIiwiYXNzaWduIiwic291cmNlcyIsIm5leHRLZXkiLCJtZXNzYWdlIiwib3B0aW9uYWxQYXJhbXMiLCJhcHBseSIsImdldENsYXNzTmFtZSIsInRhcmdldFR5cGUiLCJjb25zdHJ1Y3RvciIsImdldERlZmF1bHRWYWx1ZSIsIk51bWJlciIsImdldFByb3BlcnR5RGlzcGxheU5hbWUiLCJwcm9wZXJ0eUtleSIsIm9iamVjdCIsImlzUHJpbWl0aXZlIiwiaXNSZXNlcnZlZE1lbWJlck5hbWUiLCJpc1N1YnR5cGVPZiIsIkEiLCJCIiwiYVByb3RvdHlwZSIsIm1lcmdlIiwiZm9yRWFjaCIsInZhbHVlSXNEZWZpbmVkIiwid2FybiIsIkpzb25NZW1iZXJNZXRhZGF0YSIsIkpzb25PYmplY3RNZXRhZGF0YSIsIl9kYXRhTWVtYmVycyIsIl9rbm93blR5cGVzIiwiX2tub3duVHlwZUNhY2hlIiwiaXNFeHBsaWNpdGx5TWFya2VkIiwiZ2V0SnNvbk9iamVjdE5hbWUiLCJpbmhlcml0ZWQiLCJtZXRhZGF0YSIsImdldEZyb21UeXBlIiwiY2xhc3NOYW1lIiwidGFyZ2V0UHJvdG90eXBlIiwiZ2V0RnJvbUluc3RhbmNlIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRLbm93blR5cGVOYW1lRnJvbVR5cGUiLCJnZXRLbm93blR5cGVOYW1lRnJvbUluc3RhbmNlIiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIl9jbGFzc05hbWUiLCJjbGFzc1R5cGUiLCJzZXQiLCJrbm93blR5cGVOYW1lIiwia25vd25UeXBlIiwic2V0S25vd25UeXBlIiwiYWRkTWVtYmVyIiwibWVtYmVyIiwiX3RoaXMiLCJzb3J0TWVtYmVycyIsIm1lbWJlckFycmF5Iiwic29ydCIsInNvcnRNZW1iZXJzQ29tcGFyZSIsImRhdGFNZW1iZXIiLCJiIiwib3JkZXIiLCJvcHRpb25zT3JUYXJnZXQiLCJpbml0aWFsaXplciIsInNlcmlhbGl6ZXIiLCJkZWNvcmF0b3IiLCJvYmplY3RNZXRhZGF0YSIsInBhcmVudE1ldGFkYXRhIiwiZGF0YU1lbWJlcnMiLCJtZW1iZXJQcm9wZXJ0eUtleSIsImpzb25NZW1iZXJUeXBlSW5pdCIsInByb3BlcnR5TmFtZSIsIndhcm5BcnJheSIsImpzb25NZW1iZXJLbm93blR5cGVzIiwibWVtYmVyTWV0YWRhdGEiLCJkZXNjcmlwdG9yIiwicmVmbGVjdFR5cGUiLCJlbGVtZW50VHlwZSIsImZvcmNlRW5hYmxlVHlwZUhpbnRpbmciLCJnZXRNZXRhZGF0YSIsIlNlcmlhbGl6ZXIiLCJ3cml0ZU9iamVjdCIsInNldHRpbmdzIiwiT2JqZWN0VHlwZSIsIndyaXRlVG9Kc29uT2JqZWN0Iiwib2JqZWN0VHlwZSIsInR5cGVIaW50UHJvcGVydHlLZXkiLCJyZXBsYWNlciIsImVtaXREZWZhdWx0IiwiRGF0ZSIsInJlcXVpcmVUeXBlSGludHMiLCJwcm9wZXJ0eU1ldGFkYXRhIiwiZW1pdERlZmF1bHRWYWx1ZSIsIkRlc2VyaWFsaXplciIsInJlYWRPYmplY3QiLCJpbnN0YW5jZSIsInJldml2ZXIiLCJtYXhPYmplY3RzIiwiY291bnRPYmplY3RzIiwicmVhZEpzb25Ub0luc3RhbmNlIiwic3RyaWN0VHlwZUhpbnRNb2RlIiwiY291bnRfMSIsIml0ZW0iLCJjb3VudF8yIiwidHlwZUhpbnQiLCJ0ZW1wIiwiZXhwZWN0ZWRUeXBlTmFtZSIsImZvdW5kVHlwZU5hbWUiLCJlbGVtZW50IiwiY29uZmlnU2V0dGluZ3MiXSwibWFwcGluZ3MiOiI7O0FBQUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFBQyxRQUFHLGdDQUFPQyxPQUFQLE9BQWlCLFFBQWpCLElBQTJCLE9BQU9DLE1BQVAsS0FBZ0IsV0FBOUMsRUFBMEQ7QUFBQ0EsZUFBT0QsT0FBUCxHQUFlRCxHQUFmO0FBQW1CLEtBQTlFLE1BQW1GLElBQUcsSUFBSCxFQUEwQztBQUFDRyxRQUFBLGlDQUFPLEVBQVAsb0NBQVVILENBQVY7QUFBQTtBQUFBO0FBQUE7QUFBYSxLQUF4RCxNQUE0RDtBQUFDLFlBQUlJLENBQUosQ0FBTSxJQUFHLE9BQU9DLE1BQVAsS0FBZ0IsV0FBbkIsRUFBK0I7QUFBQ0QsZ0JBQUVDLE1BQUY7QUFBUyxTQUF6QyxNQUE4QyxJQUFHLE9BQU9DLE1BQVAsS0FBZ0IsV0FBbkIsRUFBK0I7QUFBQ0YsZ0JBQUVFLE1BQUY7QUFBUyxTQUF6QyxNQUE4QyxJQUFHLE9BQU9DLElBQVAsS0FBYyxXQUFqQixFQUE2QjtBQUFDSCxnQkFBRUcsSUFBRjtBQUFPLFNBQXJDLE1BQXlDO0FBQUNILGdCQUFFLElBQUY7QUFBTyxXQUFFSSxNQUFGLEdBQVdSLEdBQVg7QUFBZTtBQUFDLENBQWhVLEVBQWtVLFlBQVU7QUFBQyxRQUFJRyxNQUFKLEVBQVdELE1BQVgsRUFBa0JELE9BQWxCLENBQTBCLE9BQVEsU0FBU1EsQ0FBVCxDQUFXQyxDQUFYLEVBQWFDLENBQWIsRUFBZUMsQ0FBZixFQUFpQjtBQUFDLGlCQUFT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LGVBQVU4RyxJQUFWLEVBQWdCMU0sSUFBaEIsRUFBc0JtVixRQUF0QixFQUFnQztBQUNuQyw0QkFBSXRELG1CQUFtQlEsV0FBbkIsQ0FBK0JyUyxJQUEvQixDQUFKLEVBQTBDO0FBQ3RDLG1DQUFPOFYsYUFBYUMsVUFBYixDQUF3QnJKLElBQXhCLEVBQThCMU0sSUFBOUIsRUFBb0NtUSxRQUFRcUIsS0FBUixDQUFjc0YsY0FBZCxFQUE4QjNCLFlBQVksRUFBMUMsQ0FBcEMsQ0FBUDtBQUNILHlCQUZELE1BR0s7QUFDRCxtQ0FBT3RILEtBQUtqSSxLQUFMLENBQVc2SyxLQUFYLENBQWlCNUMsSUFBakIsRUFBdUJZLFNBQXZCLENBQVA7QUFDSDtBQUNKO0FBZFcsaUJBQWhCO0FBZ0JBM1Isd0JBQVEwUCxTQUFSLEdBQW9CQSxTQUFwQjtBQUNILGFBcDNCRDtBQXMzQkMsU0E3NEJ3QixFQTY0QnZCLEVBNzRCdUIsQ0FsbURneEIsRUFBM2IsRUErK0V2VyxFQS8rRXVXLEVBKytFcFcsQ0FBQyxDQUFELENBLytFb1csRUErK0UvVixDQS8rRStWLENBQVA7QUFnL0V0VyxDQWgvRUQsRSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLnBhcnNlciA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG59LHtcIi4vZGVjb2RlXCI6MixcIi4vZW5jb2RlXCI6M31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbn0se1wiLi91dGlsXCI6NixcInB1bnljb2RlXCI6MSxcInF1ZXJ5c3RyaW5nXCI6NH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG59LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0aGluZ19kZXNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vdGhpbmctZGVzY3JpcHRpb25cIik7XHJcbnZhciBURCA9IHJlcXVpcmUoXCIuL3RoaW5nLWRlc2NyaXB0aW9uXCIpO1xyXG52YXIgdHlwZWRqc29uX25wbV8xID0gcmVxdWlyZShcInR5cGVkanNvbi1ucG1cIik7XHJcbmZ1bmN0aW9uIHBhcnNlVERPYmplY3QodGQpIHtcclxuICAgIHJldHVybiBwYXJzZVREU3RyaW5nKHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04uc3RyaW5naWZ5KHRkLCB7IGVuYWJsZVR5cGVIaW50czogZmFsc2UgfSkpO1xyXG59XHJcbmV4cG9ydHMucGFyc2VURE9iamVjdCA9IHBhcnNlVERPYmplY3Q7XHJcbmZ1bmN0aW9uIHBhcnNlVERTdHJpbmcoanNvbikge1xyXG4gICAgY29uc29sZS5sb2coXCJwYXJzZVREU3RyaW5nKCkgcGFyc2luZ1xcbmBgYFxcblwiICsganNvbiArIFwiXFxuYGBgXCIpO1xyXG4gICAgdmFyIHRkID0gdHlwZWRqc29uX25wbV8xLlR5cGVkSlNPTi5wYXJzZShqc29uLCB0aGluZ19kZXNjcmlwdGlvbl8xLmRlZmF1bHQpO1xyXG4gICAgY29uc29sZS5sb2coXCJwYXJzZVREU3RyaW5nKCkgZm91bmQgXCIgKyB0ZC5pbnRlcmFjdGlvbi5sZW5ndGggKyBcIiBJbnRlcmFjdGlvblwiICsgKHRkLmludGVyYWN0aW9uLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnKSk7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGQuaW50ZXJhY3Rpb247IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xyXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5zZW1hbnRpY1R5cGVzLmluZGV4T2YoVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLlByb3BlcnR5LnRvU3RyaW5nKCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAqIFByb3BlcnR5ICdcIiArIGludGVyYWN0aW9uLm5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uLnBhdHRlcm4gPSBURC5JbnRlcmFjdGlvblBhdHRlcm4uUHJvcGVydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGludGVyYWN0aW9uLnNlbWFudGljVHlwZXMuaW5kZXhPZihURC5JbnRlcmFjdGlvblBhdHRlcm4uQWN0aW9uLnRvU3RyaW5nKCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAqIEFjdGlvbiAnXCIgKyBpbnRlcmFjdGlvbi5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5wYXR0ZXJuID0gVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkFjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW50ZXJhY3Rpb24uc2VtYW50aWNUeXBlcy5pbmRleE9mKFRELkludGVyYWN0aW9uUGF0dGVybi5FdmVudC50b1N0cmluZygpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgKiBFdmVudCAnXCIgKyBpbnRlcmFjdGlvbi5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5wYXR0ZXJuID0gVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInBhcnNlVERTdHJpbmcoKSBmb3VuZCB1bmtub3duIEludGVyYWN0aW9uIHBhdHRlcm4gJ1wiICsgaW50ZXJhY3Rpb24uc2VtYW50aWNUeXBlcyArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRkLmJhc2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBhcnNlVERTdHJpbmcoKSBhcHBseWluZyBiYXNlICdcIiArIHRkLmJhc2UgKyBcIicgdG8gaHJlZiAnXCIgKyBpbnRlcmFjdGlvbi5saW5rWzBdLmhyZWYgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHZhciBocmVmID0gaW50ZXJhY3Rpb24ubGlua1swXS5ocmVmO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGQuYmFzZS5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgICAgIHZhciBwciA9IHRkLmJhc2Uuc3Vic3RyKDAsIG4gKyAxKTtcclxuICAgICAgICAgICAgdmFyIHVyaVRlbXAgPSB0ZC5iYXNlLnJlcGxhY2UocHIsICdodHRwOicpO1xyXG4gICAgICAgICAgICB1cmlUZW1wID0gdXJsLnJlc29sdmUodXJpVGVtcCwgaHJlZik7XHJcbiAgICAgICAgICAgIHVyaVRlbXAgPSB1cmlUZW1wLnJlcGxhY2UoJ2h0dHA6JywgcHIpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5saW5rWzBdLmhyZWYgPSB1cmlUZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZDtcclxufVxyXG5leHBvcnRzLnBhcnNlVERTdHJpbmcgPSBwYXJzZVREU3RyaW5nO1xyXG5mdW5jdGlvbiBzZXJpYWxpemVURCh0ZCkge1xyXG4gICAgdHlwZWRqc29uX25wbV8xLlR5cGVkSlNPTi5jb25maWcoeyBcImVuYWJsZVR5cGVIaW50c1wiOiBmYWxzZSB9KTtcclxuICAgIHZhciBqc29uID0gdHlwZWRqc29uX25wbV8xLlR5cGVkSlNPTi5zdHJpbmdpZnkodGQpO1xyXG4gICAgdmFyIHJhdyA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICBpZiAodGQuYmFzZSA9PT0gbnVsbCB8fCB0ZC5iYXNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBkZWxldGUgcmF3LmJhc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcmF3LmludGVyYWN0aW9uOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9hW19pXTtcclxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24uaW5wdXREYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvbi5pbnB1dERhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5vdXRwdXREYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvbi5vdXRwdXREYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24ud3JpdGFibGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uLndyaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24ub3V0cHV0RGF0YSAmJiBpbnRlcmFjdGlvbi5vdXRwdXREYXRhLnJlcXVpcmVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgSE9URklYIGZvciBUeXBlZEpTT04gIyMjXCIpO1xyXG4gICAgICAgICAgICB2YXIgcmVxcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciByZXEgaW4gaW50ZXJhY3Rpb24ub3V0cHV0RGF0YS5yZXF1aXJlZClcclxuICAgICAgICAgICAgICAgIHJlcXMucHVzaChpbnRlcmFjdGlvbi5vdXRwdXREYXRhLnJlcXVpcmVkW3JlcV0pO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5vdXRwdXREYXRhLnJlcXVpcmVkID0gcmVxcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkocmF3KTtcclxuICAgIGNvbnNvbGUubG9nKFwic2VyaWFsaXplVEQoKSBwcm9kdWNlZFxcbmBgYFxcblwiICsganNvbiArIFwiXFxuYGBgXCIpO1xyXG4gICAgcmV0dXJuIGpzb247XHJcbn1cclxuZXhwb3J0cy5zZXJpYWxpemVURCA9IHNlcmlhbGl6ZVREO1xyXG5cbn0se1wiLi90aGluZy1kZXNjcmlwdGlvblwiOjgsXCJ0eXBlZGpzb24tbnBtXCI6OSxcInVybFwiOjV9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0eXBlZGpzb25fbnBtXzEgPSByZXF1aXJlKFwidHlwZWRqc29uLW5wbVwiKTtcclxudmFyIEludGVyYWN0aW9uUGF0dGVybjtcclxuKGZ1bmN0aW9uIChJbnRlcmFjdGlvblBhdHRlcm4pIHtcclxuICAgIEludGVyYWN0aW9uUGF0dGVybltJbnRlcmFjdGlvblBhdHRlcm5bXCJQcm9wZXJ0eVwiXSA9ICdQcm9wZXJ0eSddID0gXCJQcm9wZXJ0eVwiO1xyXG4gICAgSW50ZXJhY3Rpb25QYXR0ZXJuW0ludGVyYWN0aW9uUGF0dGVybltcIkFjdGlvblwiXSA9ICdBY3Rpb24nXSA9IFwiQWN0aW9uXCI7XHJcbiAgICBJbnRlcmFjdGlvblBhdHRlcm5bSW50ZXJhY3Rpb25QYXR0ZXJuW1wiRXZlbnRcIl0gPSAnRXZlbnQnXSA9IFwiRXZlbnRcIjtcclxufSkoSW50ZXJhY3Rpb25QYXR0ZXJuID0gZXhwb3J0cy5JbnRlcmFjdGlvblBhdHRlcm4gfHwgKGV4cG9ydHMuSW50ZXJhY3Rpb25QYXR0ZXJuID0ge30pKTtcclxudmFyIEludGVyYWN0aW9uTGluayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbkxpbmsoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW50ZXJhY3Rpb25MaW5rO1xyXG59KCkpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXHJcbl0sIEludGVyYWN0aW9uTGluay5wcm90b3R5cGUsIFwiaHJlZlwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXHJcbl0sIEludGVyYWN0aW9uTGluay5wcm90b3R5cGUsIFwibWVkaWFUeXBlXCIsIHZvaWQgMCk7XHJcbkludGVyYWN0aW9uTGluayA9IF9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25PYmplY3QoKVxyXG5dLCBJbnRlcmFjdGlvbkxpbmspO1xyXG5leHBvcnRzLkludGVyYWN0aW9uTGluayA9IEludGVyYWN0aW9uTGluaztcclxudmFyIEludGVyYWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2VtYW50aWNUeXBlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGluayA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEludGVyYWN0aW9uO1xyXG59KCkpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgbmFtZTogJ0B0eXBlJywgaXNSZXF1aXJlZDogdHJ1ZSwgZWxlbWVudHM6IFN0cmluZyB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwic2VtYW50aWNUeXBlc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXHJcbl0sIEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBpc1JlcXVpcmVkOiB0cnVlLCBlbGVtZW50czogSW50ZXJhY3Rpb25MaW5rIH0pXHJcbl0sIEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJsaW5rXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyB0eXBlOiBCb29sZWFuIH0pXHJcbl0sIEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJ3cml0YWJsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgdHlwZTogT2JqZWN0IH0pXHJcbl0sIEludGVyYWN0aW9uLnByb3RvdHlwZSwgXCJpbnB1dERhdGFcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IHR5cGU6IE9iamVjdCB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwib3V0cHV0RGF0YVwiLCB2b2lkIDApO1xyXG5JbnRlcmFjdGlvbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25PYmplY3QoeyBrbm93blR5cGVzOiBbSW50ZXJhY3Rpb25MaW5rXSB9KVxyXG5dLCBJbnRlcmFjdGlvbik7XHJcbmV4cG9ydHMuSW50ZXJhY3Rpb24gPSBJbnRlcmFjdGlvbjtcclxudmFyIFRoaW5nRGVzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGhpbmdEZXNjcmlwdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBbJ2h0dHA6Ly93M2MuZ2l0aHViLmlvL3dvdC93M2Mtd290LXRkLWNvbnRleHQuanNvbmxkJ107XHJcbiAgICAgICAgdGhpcy5zZW1hbnRpY1R5cGUgPSBbJ1RoaW5nJ107XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRoaW5nRGVzY3JpcHRpb247XHJcbn0oKSk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBuYW1lOiAnQHR5cGUnLCBlbGVtZW50czogU3RyaW5nIH0pXHJcbl0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcInNlbWFudGljVHlwZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgdHlwZTogU3RyaW5nIH0pXHJcbl0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IHR5cGU6IFN0cmluZyB9KVxyXG5dLCBUaGluZ0Rlc2NyaXB0aW9uLnByb3RvdHlwZSwgXCJiYXNlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBpc1JlcXVpcmVkOiB0cnVlLCBlbGVtZW50czogSW50ZXJhY3Rpb24gfSlcclxuXSwgVGhpbmdEZXNjcmlwdGlvbi5wcm90b3R5cGUsIFwiaW50ZXJhY3Rpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IG5hbWU6ICdAY29udGV4dCcsIGVsZW1lbnRzOiBTdHJpbmcgfSlcclxuXSwgVGhpbmdEZXNjcmlwdGlvbi5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xyXG5UaGluZ0Rlc2NyaXB0aW9uID0gX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk9iamVjdCh7IGtub3duVHlwZXM6IFtJbnRlcmFjdGlvbl0gfSlcclxuXSwgVGhpbmdEZXNjcmlwdGlvbik7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRoaW5nRGVzY3JpcHRpb247XHJcblxufSx7XCJ0eXBlZGpzb24tbnBtXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyohXG5UeXBlZEpTT04gdjAuMi4wIC0gaHR0cHM6Ly9naXRodWIuY29tL0pvaG5XaGl0ZVRCL1R5cGVkSlNPTlxuXG5UeXBlZCBKU09OIHBhcnNpbmcgYW5kIHNlcmlhbGl6aW5nIHRoYXQgcHJlc2VydmVzIHR5cGUgaW5mb3JtYXRpb24uIFBhcnNlIEpTT04gaW50byBhY3R1YWwgY2xhc3MgaW5zdGFuY2VzLiBSZWNvbW1lbmRlZCAoYnV0IG5vdCByZXF1aXJlZClcbnRvIGJlIHVzZWQgd2l0aCByZWZsZWN0LW1ldGFkYXRhIChnbG9iYWwgaW5zdGFsbGF0aW9uKTogaHR0cHM6Ly9naXRodWIuY29tL3JidWNrdG9uL1JlZmxlY3REZWNvcmF0b3JzLlxuXG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuQ29weXJpZ2h0IChjKSAyMDE2IEpvaG4gV2hpdGVcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTsgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBNRVRBREFUQV9GSUVMRF9LRVkgPSBcIl9fdHlwZWRKc29uSnNvbk9iamVjdE1ldGFkYXRhSW5mb3JtYXRpb25fX1wiO1xuICAgIHZhciBKU09OO1xuICAgIGlmICghSlNPTikge1xuICAgICAgICBKU09OID0ge1xuICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChzSlNPTikge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm52YWwgPSBzSlNPTjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldHVybnZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmFsKCcoJyArIHNKU09OICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyaW5naWZ5OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0b1N0cmluZy5jYWxsKGEpID09PSAnW29iamVjdCBBcnJheV0nOyB9O1xuICAgICAgICAgICAgICAgIHZhciBlc2NNYXAgPSB7ICdcIic6ICdcXFxcXCInLCAnXFxcXCc6ICdcXFxcXFxcXCcsICdcXGInOiAnXFxcXGInLCAnXFxmJzogJ1xcXFxmJywgJ1xcbic6ICdcXFxcbicsICdcXHInOiAnXFxcXHInLCAnXFx0JzogJ1xcXFx0JyB9O1xuICAgICAgICAgICAgICAgIHZhciBlc2NGdW5jID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGVzY01hcFttXSB8fCAnXFxcXHUnICsgKG0uY2hhckNvZGVBdCgwKSArIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7IH07XG4gICAgICAgICAgICAgICAgdmFyIGVzY1JFID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMUZcXHUyMDI4XFx1MjAyOV0vZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gJ1snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAoaSA/ICcsICcgOiAnJykgKyBzdHJpbmdpZnkodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChzdHJpbmdpZnkoaykgKyAnOiAnICsgc3RyaW5naWZ5KHZhbHVlW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneycgKyB0bXAuam9pbignLCAnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZShlc2NSRSwgZXNjRnVuYykgKyAnXCInO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBIZWxwZXJzO1xuICAgIChmdW5jdGlvbiAoSGVscGVycykge1xuICAgICAgICBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgSGVscGVycy5hc3NpZ24gPSBhc3NpZ247XG4gICAgICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFtcIkVSUk9SOiBcIiArIG1lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRUeXBlID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJuYW1lXCIgaW4gdGFyZ2V0VHlwZSAmJiB0eXBlb2YgdGFyZ2V0VHlwZS5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRUeXBlLnRvU3RyaW5nKCkubWF0Y2goL2Z1bmN0aW9uIChcXHcqKS8pWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lO1xuICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUodHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSGVscGVycy5nZXREZWZhdWx0VmFsdWUgPSBnZXREZWZhdWx0VmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGlzcGxheU5hbWUodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENsYXNzTmFtZSh0YXJnZXQpICsgXCIuXCIgKyBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuZ2V0UHJvcGVydHlEaXNwbGF5TmFtZSA9IGdldFByb3BlcnR5RGlzcGxheU5hbWU7XG4gICAgICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBTdHJpbmcgfHwgb2JqID09PSBTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBOdW1iZXIgfHwgb2JqID09PSBOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBCb29sZWFuIHx8IG9iaiA9PT0gQm9vbGVhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbiAgICAgICAgZnVuY3Rpb24gaXNSZXNlcnZlZE1lbWJlck5hbWUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIChuYW1lID09PSBNRVRBREFUQV9GSUVMRF9LRVkpO1xuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuaXNSZXNlcnZlZE1lbWJlck5hbWUgPSBpc1Jlc2VydmVkTWVtYmVyTmFtZTtcbiAgICAgICAgZnVuY3Rpb24gaXNTdWJ0eXBlT2YoQSwgQikge1xuICAgICAgICAgICAgdmFyIGFQcm90b3R5cGUgPSBBLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmIChBID09PSBCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYVByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChhUHJvdG90eXBlIGluc3RhbmNlb2YgQikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYVByb3RvdHlwZSA9IGFQcm90b3R5cGUucHJvdG90eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuaXNTdWJ0eXBlT2YgPSBpc1N1YnR5cGVPZjtcbiAgICAgICAgZnVuY3Rpb24gbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFttZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmxvZyA9IGxvZztcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0S2V5KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gdGFyZ2V0W25leHRLZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLm1lcmdlID0gbWVyZ2U7XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlSXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSGVscGVycy52YWx1ZUlzRGVmaW5lZCA9IHZhbHVlSXNEZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgW21lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbXCJXQVJOSU5HOiBcIiArIG1lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMud2FybiA9IHdhcm47XG4gICAgfSkoSGVscGVycyB8fCAoSGVscGVycyA9IHt9KSk7XG4gICAgdmFyIEpzb25NZW1iZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEpzb25NZW1iZXJNZXRhZGF0YSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSnNvbk1lbWJlck1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgdmFyIEpzb25PYmplY3RNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEpzb25PYmplY3RNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFNZW1iZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9rbm93blR5cGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9rbm93blR5cGVDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzRXhwbGljaXRseU1hcmtlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5nZXRKc29uT2JqZWN0TmFtZSA9IGZ1bmN0aW9uICh0eXBlLCBpbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgPT09IHZvaWQgMCkgeyBpbmhlcml0ZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLmdldEZyb21UeXBlKHR5cGUsIGluaGVyaXRlZCk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBpbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgPT09IHZvaWQgMCkgeyBpbmhlcml0ZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShNRVRBREFUQV9GSUVMRF9LRVkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB0YXJnZXRQcm90b3R5cGVbTUVUQURBVEFfRklFTERfS0VZXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluaGVyaXRlZCAmJiB0YXJnZXRQcm90b3R5cGVbTUVUQURBVEFfRklFTERfS0VZXSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gdGFyZ2V0UHJvdG90eXBlW01FVEFEQVRBX0ZJRUxEX0tFWV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuaXNFeHBsaWNpdGx5TWFya2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5nZXRGcm9tSW5zdGFuY2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBpbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgPT09IHZvaWQgMCkgeyBpbmhlcml0ZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tVHlwZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSwgaW5oZXJpdGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLmdldEtub3duVHlwZU5hbWVGcm9tVHlwZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuZ2V0RnJvbVR5cGUodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5nZXRLbm93blR5cGVOYW1lRnJvbUluc3RhbmNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRGcm9tSW5zdGFuY2UodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLCBcImRhdGFNZW1iZXJzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhTWVtYmVycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZSwgXCJjbGFzc05hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXJzLmdldENsYXNzTmFtZSh0aGlzLmNsYXNzVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUsIFwia25vd25UeXBlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIga25vd25UeXBlcztcbiAgICAgICAgICAgICAgICB2YXIga25vd25UeXBlTmFtZTtcbiAgICAgICAgICAgICAgICBrbm93blR5cGVzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChrbm93blR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAga25vd25UeXBlTmFtZSA9IEpzb25PYmplY3RNZXRhZGF0YS5nZXRLbm93blR5cGVOYW1lRnJvbVR5cGUoa25vd25UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAga25vd25UeXBlc1trbm93blR5cGVOYW1lXSA9IGtub3duVHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9rbm93blR5cGVDYWNoZSA9IGtub3duVHlwZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtub3duVHlwZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRLbm93blR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tub3duVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9rbm93blR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLmFkZE1lbWJlciA9IGZ1bmN0aW9uIChtZW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9kYXRhTWVtYmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2RhdGFNZW1iZXJzW3Byb3BlcnR5S2V5XS5uYW1lID09PSBtZW1iZXIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIG1lbWJlciB3aXRoIHRoZSBuYW1lICdcIiArIG1lbWJlci5uYW1lICsgXCInIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFNZW1iZXJzW21lbWJlci5rZXldID0gbWVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLnNvcnRNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtZW1iZXJBcnJheSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgbWVtYmVyQXJyYXkucHVzaChfdGhpcy5fZGF0YU1lbWJlcnNbcHJvcGVydHlLZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVtYmVyQXJyYXkgPSBtZW1iZXJBcnJheS5zb3J0KHRoaXMuc29ydE1lbWJlcnNDb21wYXJlKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFNZW1iZXJzID0ge307XG4gICAgICAgICAgICBtZW1iZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhTWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RhdGFNZW1iZXJzW2RhdGFNZW1iZXIua2V5XSA9IGRhdGFNZW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZS5zb3J0TWVtYmVyc0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhLm9yZGVyICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBiLm9yZGVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEubmFtZSA8IGIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEubmFtZSA+IGIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYS5vcmRlciAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGIub3JkZXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5vcmRlciA8IGIub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLm9yZGVyID4gYi5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhLm5hbWUgPiBiLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKc29uT2JqZWN0TWV0YWRhdGE7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBKc29uT2JqZWN0KG9wdGlvbnNPclRhcmdldCkge1xuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JUYXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPclRhcmdldCB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBvcHRpb25zLmluaXRpYWxpemVyO1xuICAgICAgICB2YXIgc2VyaWFsaXplciA9IG9wdGlvbnMuc2VyaWFsaXplcjtcbiAgICAgICAgdmFyIGRlY29yYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRNZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQucHJvdG90eXBlLmhhc093blByb3BlcnR5KE1FVEFEQVRBX0ZJRUxEX0tFWSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YSA9IG5ldyBKc29uT2JqZWN0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50TWV0YWRhdGEgPSB0YXJnZXQucHJvdG90eXBlW01FVEFEQVRBX0ZJRUxEX0tFWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlclByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV0gPSBwYXJlbnRNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRNZXRhZGF0YS5rbm93blR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNldEtub3duVHlwZShwYXJlbnRNZXRhZGF0YS5rbm93blR5cGVzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldC5wcm90b3R5cGUsIE1FVEFEQVRBX0ZJRUxEX0tFWSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2JqZWN0TWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gdGFyZ2V0LnByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuY2xhc3NUeXBlID0gdGFyZ2V0O1xuICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuaXNFeHBsaWNpdGx5TWFya2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5jbGFzc05hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rbm93blR5cGVzKSB7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rbm93blR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGtub3duVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrbm93blR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiS25vd24gdHlwZSAjXCIgKyBpKysgKyBcIiBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc2V0S25vd25UeXBlKGtub3duVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBIZWxwZXJzLmVycm9yKG5ldyBUeXBlRXJyb3IoXCJASnNvbk9iamVjdDogXCIgKyBlLm1lc3NhZ2UgKyBcIiAob24gJ1wiICsgSGVscGVycy5nZXRDbGFzc05hbWUodGFyZ2V0KSArIFwiJylcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yVGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3Iob3B0aW9uc09yVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5Kc29uT2JqZWN0ID0gSnNvbk9iamVjdDtcbiAgICBmdW5jdGlvbiBqc29uTWVtYmVyVHlwZUluaXQobWV0YWRhdGEsIHByb3BlcnR5TmFtZSwgd2FybkFycmF5KSB7XG4gICAgICAgIGlmICh3YXJuQXJyYXkgPT09IHZvaWQgMCkgeyB3YXJuQXJyYXkgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobWV0YWRhdGEuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuZWxlbWVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmVsZW1lbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZXRhZGF0YS5lbGVtZW50c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS50eXBlID0gQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLnR5cGUgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhcm5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBIZWxwZXJzLndhcm4oXCJObyB2YWxpZCAnZWxlbWVudHMnIG9wdGlvbiB3YXMgc3BlY2lmaWVkIGZvciAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgJ2VsZW1lbnRzJyBvcHRpb24gd2FzIHNwZWNpZmllZCBmb3IgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqc29uTWVtYmVyVHlwZUluaXQobWV0YWRhdGEuZWxlbWVudHMsIHByb3BlcnR5TmFtZSArICdbXScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCAndHlwZScgb3B0aW9uIHdhcyBzcGVjaWZpZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24ganNvbk1lbWJlcktub3duVHlwZXMobWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIGtub3duVHlwZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAga25vd25UeXBlcy5wdXNoKG1ldGFkYXRhLnR5cGUpO1xuICAgICAgICBpZiAobWV0YWRhdGEuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGtub3duVHlwZXMgPSBrbm93blR5cGVzLmNvbmNhdChqc29uTWVtYmVyS25vd25UeXBlcyhtZXRhZGF0YS5lbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbm93blR5cGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBKc29uTWVtYmVyKG9wdGlvbnNPclRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgdmFyIG1lbWJlck1ldGFkYXRhID0gbmV3IEpzb25NZW1iZXJNZXRhZGF0YSgpO1xuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgdmFyIGRlY29yYXRvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcHJvcGVydHlLZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JUYXJnZXQgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgZGVjb3JhdG9yID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIG9iamVjdE1ldGFkYXRhO1xuICAgICAgICAgICAgdmFyIHBhcmVudE1ldGFkYXRhO1xuICAgICAgICAgICAgdmFyIHJlZmxlY3RUeXBlO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IEhlbHBlcnMuZ2V0UHJvcGVydHlEaXNwbGF5TmFtZSh0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEpzb25NZW1iZXIgY2Fubm90IGJlIHVzZWQgb24gYSBzdGF0aWMgcHJvcGVydHkgKCdcIiArIHByb3BlcnR5TmFtZSArIFwiJykuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcGVydHlLZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEpzb25NZW1iZXIgY2Fubm90IGJlIHVzZWQgb24gYSBtZXRob2QgcHJvcGVydHkgKCdcIiArIHByb3BlcnR5TmFtZSArIFwiJykuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJlbGVtZW50VHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIEhlbHBlcnMud2Fybihwcm9wZXJ0eU5hbWUgKyBcIjogdGhlICdlbGVtZW50VHlwZScgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSAnZWxlbWVudHMnIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZWxlbWVudHMgPSBvcHRpb25zLmVsZW1lbnRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVsZW1lbnRUeXBlID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJNZXRhZGF0YS5mb3JjZUVuYWJsZVR5cGVIaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1iZXJNZXRhZGF0YSA9IEhlbHBlcnMuYXNzaWduKG1lbWJlck1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1lbWJlck1ldGFkYXRhLmtleSA9IHByb3BlcnR5S2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBtZW1iZXJNZXRhZGF0YS5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IHByb3BlcnR5S2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoSGVscGVycy5pc1Jlc2VydmVkTWVtYmVyTmFtZShtZW1iZXJNZXRhZGF0YS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBKc29uTWVtYmVyOiAnXCIgKyBtZW1iZXJNZXRhZGF0YS5uYW1lICsgXCInIGlzIGEgcmVzZXJ2ZWQgbmFtZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikgJiYgdHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJASnNvbk1lbWJlcjogJ3R5cGUnIG9mICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmdldE1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZWZsZWN0VHlwZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmxlY3RUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJASnNvbk1lbWJlcjogdHlwZSBkZXRlY3RlZCBmb3IgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInIGlzIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWVtYmVyTWV0YWRhdGEudHlwZSB8fCB0eXBlb2YgbWVtYmVyTWV0YWRhdGEudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck1ldGFkYXRhLnR5cGUgPSByZWZsZWN0VHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyTWV0YWRhdGEudHlwZSAhPT0gcmVmbGVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy53YXJuKFwiQEpzb25NZW1iZXI6ICd0eXBlJyBzcGVjaWZpZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZXRlY3RlZCB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc29uTWVtYmVyVHlwZUluaXQobWVtYmVyTWV0YWRhdGEsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBREFUQV9GSUVMRF9LRVkpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBuZXcgSnNvbk9iamVjdE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE1ldGFkYXRhID0gdGFyZ2V0W01FVEFEQVRBX0ZJRUxEX0tFWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlclByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV0gPSBwYXJlbnRNZXRhZGF0YS5kYXRhTWVtYmVyc1ttZW1iZXJQcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBREFUQV9GSUVMRF9LRVksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iamVjdE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YSA9IHRhcmdldFtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAganNvbk1lbWJlcktub3duVHlwZXMobWVtYmVyTWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtub3duVHlwZSkge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNldEtub3duVHlwZShrbm93blR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLmFkZE1lbWJlcihtZW1iZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lbWJlciAnXCIgKyBtZW1iZXJNZXRhZGF0YS5uYW1lICsgXCInIGFscmVhZHkgZXhpc3RzIG9uICdcIiArIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKG9iamVjdE1ldGFkYXRhLmNsYXNzVHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5S2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwcm9wZXJ0eUtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcihvcHRpb25zT3JUYXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5Kc29uTWVtYmVyID0gSnNvbk1lbWJlcjtcbiAgICB2YXIgU2VyaWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2VyaWFsaXplci53cml0ZU9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGEgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbUluc3RhbmNlKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgT2JqZWN0VHlwZTtcbiAgICAgICAgICAgIGlmIChvYmplY3RNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIE9iamVjdFR5cGUgPSBvYmplY3RNZXRhZGF0YS5jbGFzc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMud3JpdGVUb0pzb25PYmplY3Qob2JqZWN0LCB7XG4gICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogT2JqZWN0VHlwZSxcbiAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICB9KSwgc2V0dGluZ3MucmVwbGFjZXIpO1xuICAgICAgICB9O1xuICAgICAgICBTZXJpYWxpemVyLndyaXRlVG9Kc29uT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIganNvbjtcbiAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbWl0RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gSGVscGVycy5nZXREZWZhdWx0VmFsdWUoc2V0dGluZ3Mub2JqZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEhlbHBlcnMuaXNQcmltaXRpdmUob2JqZWN0KSB8fCBvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAganNvbiA9IG9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAganNvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBqc29uLnB1c2godGhpcy53cml0ZVRvSnNvbk9iamVjdChvYmplY3RbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBzZXR0aW5ncy5lbGVtZW50cyA/IHNldHRpbmdzLmVsZW1lbnRzLmVsZW1lbnRzIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogc2V0dGluZ3MuZWxlbWVudHMgPyBzZXR0aW5ncy5lbGVtZW50cy50eXBlIDogT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVR5cGVIaW50czogc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVIaW50UHJvcGVydHlLZXk6IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXlcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21JbnN0YW5jZShvYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RNZXRhZGF0YSAmJiB0eXBlb2Ygb2JqZWN0TWV0YWRhdGEuc2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb24gPSBvYmplY3RNZXRhZGF0YS5zZXJpYWxpemVyKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVUeXBlSGludHMgJiYgKHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMgfHwgb2JqZWN0LmNvbnN0cnVjdG9yICE9PSBzZXR0aW5ncy5vYmplY3RUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbltzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XSA9IEpzb25PYmplY3RNZXRhZGF0YS5nZXRLbm93blR5cGVOYW1lRnJvbUluc3RhbmNlKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5zb3J0TWVtYmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TWV0YWRhdGEgPSBvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVyc1twcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltwcm9wZXJ0eU1ldGFkYXRhLm5hbWVdID0gX3RoaXMud3JpdGVUb0pzb25PYmplY3Qob2JqZWN0W3Byb3BlcnR5S2V5XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogcHJvcGVydHlNZXRhZGF0YS5lbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdERlZmF1bHQ6IHByb3BlcnR5TWV0YWRhdGEuZW1pdERlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5TWV0YWRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogcHJvcGVydHlNZXRhZGF0YS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW3Byb3BlcnR5S2V5XSA9IF90aGlzLndyaXRlVG9Kc29uT2JqZWN0KG9iamVjdFtwcm9wZXJ0eUtleV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVR5cGVIaW50czogc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVzZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVzZXJpYWxpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIERlc2VyaWFsaXplci5yZWFkT2JqZWN0ID0gZnVuY3Rpb24gKGpzb24sIHR5cGUsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKGpzb24sIHNldHRpbmdzLnJldml2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5tYXhPYmplY3RzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRPYmplY3RzKHZhbHVlKSA+IHNldHRpbmdzLm1heE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTiBleGNlZWRzIG9iamVjdCBjb3VudCBsaW1pdCAoXCIgKyBzZXR0aW5ncy5tYXhPYmplY3RzICsgXCIpLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMucmVhZEpzb25Ub0luc3RhbmNlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5LFxuICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgIHN0cmljdFR5cGVIaW50TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrbm93blR5cGVzOiBtZXRhZGF0YSA/IG1ldGFkYXRhLmtub3duVHlwZXMgOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIERlc2VyaWFsaXplci5jb3VudE9iamVjdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChIZWxwZXJzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRfMSArPSBfdGhpcy5jb3VudE9iamVjdHMoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF8xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRfMiArPSBfdGhpcy5jb3VudE9iamVjdHModmFsdWVbcHJvcGVydHlLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50XzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZXNlcmlhbGl6ZXIucmVhZEpzb25Ub0luc3RhbmNlID0gZnVuY3Rpb24gKGpzb24sIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBPYmplY3RUeXBlO1xuICAgICAgICAgICAgdmFyIHR5cGVIaW50O1xuICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICB2YXIga25vd25UeXBlcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBqc29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmlzUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBtZW1iZXIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEhlbHBlcnMuaXNQcmltaXRpdmUoc2V0dGluZ3Mub2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5jb25zdHJ1Y3RvciAhPT0gc2V0dGluZ3Mub2JqZWN0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlTmFtZSA9IEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHNldHRpbmdzLm9iamVjdFR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFR5cGVOYW1lID0gSGVscGVycy5nZXRDbGFzc05hbWUoanNvbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJ1wiICsgZXhwZWN0ZWRUeXBlTmFtZSArIFwiJywgZ290ICdcIiArIGZvdW5kVHlwZU5hbWUgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QgPSBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Mub2JqZWN0VHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUhlbHBlcnMuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAnQXJyYXknLCBnb3QgJ1wiICsgSGVscGVycy5nZXRDbGFzc05hbWUoanNvbi5jb25zdHJ1Y3RvcikgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgICAgICBqc29uLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnB1c2goX3RoaXMucmVhZEpzb25Ub0luc3RhbmNlKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBzZXR0aW5ncy5lbGVtZW50cyA/IHNldHRpbmdzLmVsZW1lbnRzLmVsZW1lbnRzIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlczogc2V0dGluZ3Mua25vd25UeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IHNldHRpbmdzLmVsZW1lbnRzID8gc2V0dGluZ3MuZWxlbWVudHMudHlwZSA6IGVsZW1lbnQuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0VHlwZUhpbnRNb2RlOiBzZXR0aW5ncy5zdHJpY3RUeXBlSGludE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLm9iamVjdFR5cGUgPT09IERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IERhdGUoanNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpzb24gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IGpzb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICdcIiArIHR5cGVvZiBqc29uICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlSGludCA9IGpzb25bc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVIaW50ICYmIHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVIaW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZS1oaW50IChcIiArIHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXkgKyBcIikgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgdHlwZUhpbnQgKyBcIicgaXMgbm90IGEga25vd24gdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0cmljdFR5cGVIaW50TW9kZSAmJiAhSGVscGVycy5pc1N1YnR5cGVPZihzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XSwgc2V0dGluZ3Mub2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIHR5cGVIaW50ICsgXCInIGlzIG5vdCBhIHN1YnR5cGUgb2YgJ1wiICsgSGVscGVycy5nZXRDbGFzc05hbWUoc2V0dGluZ3Mub2JqZWN0VHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGUgPSBzZXR0aW5ncy5rbm93blR5cGVzW3R5cGVIaW50XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUoT2JqZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzICYmIHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgdHlwZS1oaW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gc2V0dGluZ3Mub2JqZWN0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUoc2V0dGluZ3Mub2JqZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdE1ldGFkYXRhLmluaXRpYWxpemVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdE1ldGFkYXRhLmluaXRpYWxpemVyKGpzb24pIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5zb3J0TWVtYmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IE9iamVjdFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdE1ldGFkYXRhLmRhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gb2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnNbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBfdGhpcy5yZWFkSnNvblRvSW5zdGFuY2UoanNvbltwcm9wZXJ0eU1ldGFkYXRhLm5hbWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBwcm9wZXJ0eU1ldGFkYXRhLmVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXF1aXJlZDogcHJvcGVydHlNZXRhZGF0YS5pc1JlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm93blR5cGVzOiBIZWxwZXJzLm1lcmdlKHNldHRpbmdzLmtub3duVHlwZXMsIG9iamVjdE1ldGFkYXRhLmtub3duVHlwZXMgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBwcm9wZXJ0eU1ldGFkYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdFR5cGVIaW50TW9kZTogc2V0dGluZ3Muc3RyaWN0VHlwZUhpbnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhlbHBlcnMudmFsdWVJc0RlZmluZWQodGVtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bcHJvcGVydHlLZXldICYmIHByb3BlcnR5S2V5ICE9PSBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5S2V5XSA9IF90aGlzLnJlYWRKc29uVG9JbnN0YW5jZShqc29uW3Byb3BlcnR5S2V5XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlczogc2V0dGluZ3Mua25vd25UeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZToganNvbltwcm9wZXJ0eUtleV0uY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVIaW50UHJvcGVydHlLZXk6IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlc2VyaWFsaXplcjtcbiAgICB9KCkpO1xuICAgIHZhciBjb25maWdTZXR0aW5ncyA9IHtcbiAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiB0cnVlLFxuICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBcIl9fdHlwZVwiXG4gICAgfTtcbiAgICB2YXIgVHlwZWRKU09OID0ge1xuICAgICAgICBjb25maWc6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgY29uZmlnU2V0dGluZ3MgPSBIZWxwZXJzLm1lcmdlKGNvbmZpZ1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6ZXIud3JpdGVPYmplY3QodmFsdWUsIEhlbHBlcnMubWVyZ2UoY29uZmlnU2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoanNvbiwgdHlwZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbVR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVzZXJpYWxpemVyLnJlYWRPYmplY3QoanNvbiwgdHlwZSwgSGVscGVycy5tZXJnZShjb25maWdTZXR0aW5ncywgc2V0dGluZ3MgfHwge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlLmFwcGx5KEpTT04sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuVHlwZWRKU09OID0gVHlwZWRKU09OO1xufSk7XG5cbn0se31dfSx7fSxbN10pKDcpXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYXJzZXIvYnVuZGxlLXBhcnNlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n")}},[17]);