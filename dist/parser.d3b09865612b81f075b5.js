/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ({

/***/ 18:
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n");

/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (f) {\n    if (( false ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f();\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        var g;if (typeof window !== \"undefined\") {\n            g = window;\n        } else if (typeof global !== \"undefined\") {\n            g = global;\n        } else if (typeof self !== \"undefined\") {\n            g = self;\n        } else {\n            g = this;\n        }g.parser = f();\n    }\n})(function () {\n    var define, module, exports;return function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }({ 1: [function (require, module, exports) {\n            (function (global) {\n                /*! https://mths.be/punycode v1.4.1 by @mathias */\n                ;(function (root) {\n\n                    /** Detect free variables */\n                    var freeExports = (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n                    var freeModule = (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) == 'object' && module && !module.nodeType && module;\n                    var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global;\n                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n                        root = freeGlobal;\n                    }\n\n                    /**\n                     * The `punycode` object.\n                     * @name punycode\n                     * @type Object\n                     */\n                    var punycode,\n\n\n                    /** Highest positive signed 32-bit float value */\n                    maxInt = 2147483647,\n                        // aka. 0x7FFFFFFF or 2^31-1\n\n                    /** Bootstring parameters */\n                    base = 36,\n                        tMin = 1,\n                        tMax = 26,\n                        skew = 38,\n                        damp = 700,\n                        initialBias = 72,\n                        initialN = 128,\n                        // 0x80\n                    delimiter = '-',\n                        // '\\x2D'\n\n                    /** Regular expressions */\n                    regexPunycode = /^xn--/,\n                        regexNonASCII = /[^\\x20-\\x7E]/,\n                        // unprintable ASCII chars + non-ASCII chars\n                    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                        // RFC 3490 separators\n\n                    /** Error messages */\n                    errors = {\n                        'overflow': 'Overflow: input needs wider integers to process',\n                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n                        'invalid-input': 'Invalid input'\n                    },\n\n\n                    /** Convenience shortcuts */\n                    baseMinusTMin = base - tMin,\n                        floor = Math.floor,\n                        stringFromCharCode = String.fromCharCode,\n\n\n                    /** Temporary variable */\n                    key;\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /**\n                     * A generic error utility function.\n                     * @private\n                     * @param {String} type The error type.\n                     * @returns {Error} Throws a `RangeError` with the applicable error message.\n                     */\n                    function error(type) {\n                        throw new RangeError(errors[type]);\n                    }\n\n                    /**\n                     * A generic `Array#map` utility function.\n                     * @private\n                     * @param {Array} array The array to iterate over.\n                     * @param {Function} callback The function that gets called for every array\n                     * item.\n                     * @returns {Array} A new array of values returned by the callback function.\n                     */\n                    function map(array, fn) {\n                        var length = array.length;\n                        var result = [];\n                        while (length--) {\n                            result[length] = fn(array[length]);\n                        }\n                        return result;\n                    }\n\n                    /**\n                     * A simple `Array#map`-like wrapper to work with domain name strings or email\n                     * addresses.\n                     * @private\n                     * @param {String} domain The domain name or email address.\n                     * @param {Function} callback The function that gets called for every\n                     * character.\n                     * @returns {Array} A new string of characters returned by the callback\n                     * function.\n                     */\n                    function mapDomain(string, fn) {\n                        var parts = string.split('@');\n                        var result = '';\n                        if (parts.length > 1) {\n                            // In email addresses, only the domain name should be punycoded. Leave\n                            // the local part (i.e. everything up to `@`) intact.\n                            result = parts[0] + '@';\n                            string = parts[1];\n                        }\n                        // Avoid `split(regex)` for IE8 compatibility. See #17.\n                        string = string.replace(regexSeparators, '\\x2E');\n                        var labels = string.split('.');\n                        var encoded = map(labels, fn).join('.');\n                        return result + encoded;\n                    }\n\n                    /**\n                     * Creates an array containing the numeric code points of each Unicode\n                     * character in the string. While JavaScript uses UCS-2 internally,\n                     * this function will convert a pair of surrogate halves (each of which\n                     * UCS-2 exposes as separate characters) into a single code point,\n                     * matching UTF-16.\n                     * @see `punycode.ucs2.encode`\n                     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                     * @memberOf punycode.ucs2\n                     * @name decode\n                     * @param {String} string The Unicode input string (UCS-2).\n                     * @returns {Array} The new array of code points.\n                     */\n                    function ucs2decode(string) {\n                        var output = [],\n                            counter = 0,\n                            length = string.length,\n                            value,\n                            extra;\n                        while (counter < length) {\n                            value = string.charCodeAt(counter++);\n                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                                // high surrogate, and there is a next character\n                                extra = string.charCodeAt(counter++);\n                                if ((extra & 0xFC00) == 0xDC00) {\n                                    // low surrogate\n                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                                } else {\n                                    // unmatched surrogate; only append this code unit, in case the next\n                                    // code unit is the high surrogate of a surrogate pair\n                                    output.push(value);\n                                    counter--;\n                                }\n                            } else {\n                                output.push(value);\n                            }\n                        }\n                        return output;\n                    }\n\n                    /**\n                     * Creates a string based on an array of numeric code points.\n                     * @see `punycode.ucs2.decode`\n                     * @memberOf punycode.ucs2\n                     * @name encode\n                     * @param {Array} codePoints The array of numeric code points.\n                     * @returns {String} The new Unicode string (UCS-2).\n                     */\n                    function ucs2encode(array) {\n                        return map(array, function (value) {\n                            var output = '';\n                            if (value > 0xFFFF) {\n                                value -= 0x10000;\n                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                                value = 0xDC00 | value & 0x3FF;\n                            }\n                            output += stringFromCharCode(value);\n                            return output;\n                        }).join('');\n                    }\n\n                    /**\n                     * Converts a basic code point into a digit/integer.\n                     * @see `digitToBasic()`\n                     * @private\n                     * @param {Number} codePoint The basic numeric code point value.\n                     * @returns {Number} The numeric value of a basic code point (for use in\n                     * representing integers) in the range `0` to `base - 1`, or `base` if\n                     * the code point does not represent a value.\n                     */\n                    function basicToDigit(codePoint) {\n                        if (codePoint - 48 < 10) {\n                            return codePoint - 22;\n                        }\n                        if (codePoint - 65 < 26) {\n                            return codePoint - 65;\n                        }\n                        if (codePoint - 97 < 26) {\n                            return codePoint - 97;\n                        }\n                        return base;\n                    }\n\n                    /**\n                     * Converts a digit/integer into a basic code point.\n                     * @see `basicToDigit()`\n                     * @private\n                     * @param {Number} digit The numeric value of a basic code point.\n                     * @returns {Number} The basic code point whose value (when used for\n                     * representing integers) is `digit`, which needs to be in the range\n                     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n                     * used; else, the lowercase form is used. The behavior is undefined\n                     * if `flag` is non-zero and `digit` has no uppercase form.\n                     */\n                    function digitToBasic(digit, flag) {\n                        //  0..25 map to ASCII a..z or A..Z\n                        // 26..35 map to ASCII 0..9\n                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n                    }\n\n                    /**\n                     * Bias adaptation function as per section 3.4 of RFC 3492.\n                     * https://tools.ietf.org/html/rfc3492#section-3.4\n                     * @private\n                     */\n                    function adapt(delta, numPoints, firstTime) {\n                        var k = 0;\n                        delta = firstTime ? floor(delta / damp) : delta >> 1;\n                        delta += floor(delta / numPoints);\n                        for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n                            delta = floor(delta / baseMinusTMin);\n                        }\n                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n                    }\n\n                    /**\n                     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n                     * symbols.\n                     * @memberOf punycode\n                     * @param {String} input The Punycode string of ASCII-only symbols.\n                     * @returns {String} The resulting string of Unicode symbols.\n                     */\n                    function decode(input) {\n                        // Don't use UCS-2\n                        var output = [],\n                            inputLength = input.length,\n                            out,\n                            i = 0,\n                            n = initialN,\n                            bias = initialBias,\n                            basic,\n                            j,\n                            index,\n                            oldi,\n                            w,\n                            k,\n                            digit,\n                            t,\n\n                        /** Cached calculation results */\n                        baseMinusT;\n\n                        // Handle the basic code points: let `basic` be the number of input code\n                        // points before the last delimiter, or `0` if there is none, then copy\n                        // the first basic code points to the output.\n\n                        basic = input.lastIndexOf(delimiter);\n                        if (basic < 0) {\n                            basic = 0;\n                        }\n\n                        for (j = 0; j < basic; ++j) {\n                            // if it's not a basic code point\n                            if (input.charCodeAt(j) >= 0x80) {\n                                error('not-basic');\n                            }\n                            output.push(input.charCodeAt(j));\n                        }\n\n                        // Main decoding loop: start just after the last delimiter if any basic code\n                        // points were copied; start at the beginning otherwise.\n\n                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n                            // `index` is the index of the next character to be consumed.\n                            // Decode a generalized variable-length integer into `delta`,\n                            // which gets added to `i`. The overflow checking is easier\n                            // if we increase `i` as we go, then subtract off its starting\n                            // value at the end to obtain `delta`.\n                            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\n                                if (index >= inputLength) {\n                                    error('invalid-input');\n                                }\n\n                                digit = basicToDigit(input.charCodeAt(index++));\n\n                                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                                    error('overflow');\n                                }\n\n                                i += digit * w;\n                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                                if (digit < t) {\n                                    break;\n                                }\n\n                                baseMinusT = base - t;\n                                if (w > floor(maxInt / baseMinusT)) {\n                                    error('overflow');\n                                }\n\n                                w *= baseMinusT;\n                            }\n\n                            out = output.length + 1;\n                            bias = adapt(i - oldi, out, oldi == 0);\n\n                            // `i` was supposed to wrap around from `out` to `0`,\n                            // incrementing `n` each time, so we'll fix that now:\n                            if (floor(i / out) > maxInt - n) {\n                                error('overflow');\n                            }\n\n                            n += floor(i / out);\n                            i %= out;\n\n                            // Insert `n` at position `i` of the output\n                            output.splice(i++, 0, n);\n                        }\n\n                        return ucs2encode(output);\n                    }\n\n                    /**\n                     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n                     * Punycode string of ASCII-only symbols.\n                     * @memberOf punycode\n                     * @param {String} input The string of Unicode symbols.\n                     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n                     */\n                    function encode(input) {\n                        var n,\n                            delta,\n                            handledCPCount,\n                            basicLength,\n                            bias,\n                            j,\n                            m,\n                            q,\n                            k,\n                            t,\n                            currentValue,\n                            output = [],\n\n                        /** `inputLength` will hold the number of code points in `input`. */\n                        inputLength,\n\n                        /** Cached calculation results */\n                        handledCPCountPlusOne,\n                            baseMinusT,\n                            qMinusT;\n\n                        // Convert the input in UCS-2 to Unicode\n                        input = ucs2decode(input);\n\n                        // Cache the length\n                        inputLength = input.length;\n\n                        // Initialize the state\n                        n = initialN;\n                        delta = 0;\n                        bias = initialBias;\n\n                        // Handle the basic code points\n                        for (j = 0; j < inputLength; ++j) {\n                            currentValue = input[j];\n                            if (currentValue < 0x80) {\n                                output.push(stringFromCharCode(currentValue));\n                            }\n                        }\n\n                        handledCPCount = basicLength = output.length;\n\n                        // `handledCPCount` is the number of code points that have been handled;\n                        // `basicLength` is the number of basic code points.\n\n                        // Finish the basic string - if it is not empty - with a delimiter\n                        if (basicLength) {\n                            output.push(delimiter);\n                        }\n\n                        // Main encoding loop:\n                        while (handledCPCount < inputLength) {\n\n                            // All non-basic code points < n have been handled already. Find the next\n                            // larger one:\n                            for (m = maxInt, j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n                                if (currentValue >= n && currentValue < m) {\n                                    m = currentValue;\n                                }\n                            }\n\n                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                            // but guard against overflow\n                            handledCPCountPlusOne = handledCPCount + 1;\n                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                                error('overflow');\n                            }\n\n                            delta += (m - n) * handledCPCountPlusOne;\n                            n = m;\n\n                            for (j = 0; j < inputLength; ++j) {\n                                currentValue = input[j];\n\n                                if (currentValue < n && ++delta > maxInt) {\n                                    error('overflow');\n                                }\n\n                                if (currentValue == n) {\n                                    // Represent delta as a generalized variable-length integer\n                                    for (q = delta, k = base;; /* no condition */k += base) {\n                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                                        if (q < t) {\n                                            break;\n                                        }\n                                        qMinusT = q - t;\n                                        baseMinusT = base - t;\n                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                                        q = floor(qMinusT / baseMinusT);\n                                    }\n\n                                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                                    delta = 0;\n                                    ++handledCPCount;\n                                }\n                            }\n\n                            ++delta;\n                            ++n;\n                        }\n                        return output.join('');\n                    }\n\n                    /**\n                     * Converts a Punycode string representing a domain name or an email address\n                     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n                     * it doesn't matter if you call it on a string that has already been\n                     * converted to Unicode.\n                     * @memberOf punycode\n                     * @param {String} input The Punycoded domain name or email address to\n                     * convert to Unicode.\n                     * @returns {String} The Unicode representation of the given Punycode\n                     * string.\n                     */\n                    function toUnicode(input) {\n                        return mapDomain(input, function (string) {\n                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n                        });\n                    }\n\n                    /**\n                     * Converts a Unicode string representing a domain name or an email address to\n                     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n                     * i.e. it doesn't matter if you call it with a domain that's already in\n                     * ASCII.\n                     * @memberOf punycode\n                     * @param {String} input The domain name or email address to convert, as a\n                     * Unicode string.\n                     * @returns {String} The Punycode representation of the given domain name or\n                     * email address.\n                     */\n                    function toASCII(input) {\n                        return mapDomain(input, function (string) {\n                            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n                        });\n                    }\n\n                    /*--------------------------------------------------------------------------*/\n\n                    /** Define the public API */\n                    punycode = {\n                        /**\n                         * A string representing the current Punycode.js version number.\n                         * @memberOf punycode\n                         * @type String\n                         */\n                        'version': '1.4.1',\n                        /**\n                         * An object of methods to convert from JavaScript's internal character\n                         * representation (UCS-2) to Unicode code points, and back.\n                         * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                         * @memberOf punycode\n                         * @type Object\n                         */\n                        'ucs2': {\n                            'decode': ucs2decode,\n                            'encode': ucs2encode\n                        },\n                        'decode': decode,\n                        'encode': encode,\n                        'toASCII': toASCII,\n                        'toUnicode': toUnicode\n                    };\n\n                    /** Expose `punycode` */\n                    // Some AMD build optimizers, like r.js, check for specific condition patterns\n                    // like the following:\n                    if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n                        define('punycode', function () {\n                            return punycode;\n                        });\n                    } else if (freeExports && freeModule) {\n                        if (module.exports == freeExports) {\n                            // in Node.js, io.js, or RingoJS v0.8.0+\n                            freeModule.exports = punycode;\n                        } else {\n                            // in Narwhal or RingoJS v0.7.0-\n                            for (key in punycode) {\n                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n                            }\n                        }\n                    } else {\n                        // in Rhino or a web browser\n                        root.punycode = punycode;\n                    }\n                })(this);\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 2: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            // If obj.hasOwnProperty has been overridden, then calling\n            // obj.hasOwnProperty(prop) will break.\n            // See: https://github.com/joyent/node/issues/1707\n\n            function hasOwnProperty(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            }\n\n            module.exports = function (qs, sep, eq, options) {\n                sep = sep || '&';\n                eq = eq || '=';\n                var obj = {};\n\n                if (typeof qs !== 'string' || qs.length === 0) {\n                    return obj;\n                }\n\n                var regexp = /\\+/g;\n                qs = qs.split(sep);\n\n                var maxKeys = 1000;\n                if (options && typeof options.maxKeys === 'number') {\n                    maxKeys = options.maxKeys;\n                }\n\n                var len = qs.length;\n                // maxKeys <= 0 means that we should not limit keys count\n                if (maxKeys > 0 && len > maxKeys) {\n                    len = maxKeys;\n                }\n\n                for (var i = 0; i < len; ++i) {\n                    var x = qs[i].replace(regexp, '%20'),\n                        idx = x.indexOf(eq),\n                        kstr,\n                        vstr,\n                        k,\n                        v;\n\n                    if (idx >= 0) {\n                        kstr = x.substr(0, idx);\n                        vstr = x.substr(idx + 1);\n                    } else {\n                        kstr = x;\n                        vstr = '';\n                    }\n\n                    k = decodeURIComponent(kstr);\n                    v = decodeURIComponent(vstr);\n\n                    if (!hasOwnProperty(obj, k)) {\n                        obj[k] = v;\n                    } else if (isArray(obj[k])) {\n                        obj[k].push(v);\n                    } else {\n                        obj[k] = [obj[k], v];\n                    }\n                }\n\n                return obj;\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n        }, {}], 3: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var stringifyPrimitive = function stringifyPrimitive(v) {\n                switch (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) {\n                    case 'string':\n                        return v;\n\n                    case 'boolean':\n                        return v ? 'true' : 'false';\n\n                    case 'number':\n                        return isFinite(v) ? v : '';\n\n                    default:\n                        return '';\n                }\n            };\n\n            module.exports = function (obj, sep, eq, name) {\n                sep = sep || '&';\n                eq = eq || '=';\n                if (obj === null) {\n                    obj = undefined;\n                }\n\n                if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n                    return map(objectKeys(obj), function (k) {\n                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n                        if (isArray(obj[k])) {\n                            return map(obj[k], function (v) {\n                                return ks + encodeURIComponent(stringifyPrimitive(v));\n                            }).join(sep);\n                        } else {\n                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n                        }\n                    }).join(sep);\n                }\n\n                if (!name) return '';\n                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n            };\n\n            var isArray = Array.isArray || function (xs) {\n                return Object.prototype.toString.call(xs) === '[object Array]';\n            };\n\n            function map(xs, f) {\n                if (xs.map) return xs.map(f);\n                var res = [];\n                for (var i = 0; i < xs.length; i++) {\n                    res.push(f(xs[i], i));\n                }\n                return res;\n            }\n\n            var objectKeys = Object.keys || function (obj) {\n                var res = [];\n                for (var key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n                }\n                return res;\n            };\n        }, {}], 4: [function (require, module, exports) {\n            'use strict';\n\n            exports.decode = exports.parse = require('./decode');\n            exports.encode = exports.stringify = require('./encode');\n        }, { \"./decode\": 2, \"./encode\": 3 }], 5: [function (require, module, exports) {\n            // Copyright Joyent, Inc. and other Node contributors.\n            //\n            // Permission is hereby granted, free of charge, to any person obtaining a\n            // copy of this software and associated documentation files (the\n            // \"Software\"), to deal in the Software without restriction, including\n            // without limitation the rights to use, copy, modify, merge, publish,\n            // distribute, sublicense, and/or sell copies of the Software, and to permit\n            // persons to whom the Software is furnished to do so, subject to the\n            // following conditions:\n            //\n            // The above copyright notice and this permission notice shall be included\n            // in all copies or substantial portions of the Software.\n            //\n            // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n            // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n            'use strict';\n\n            var punycode = require('punycode');\n            var util = require('./util');\n\n            exports.parse = urlParse;\n            exports.resolve = urlResolve;\n            exports.resolveObject = urlResolveObject;\n            exports.format = urlFormat;\n\n            exports.Url = Url;\n\n            function Url() {\n                this.protocol = null;\n                this.slashes = null;\n                this.auth = null;\n                this.host = null;\n                this.port = null;\n                this.hostname = null;\n                this.hash = null;\n                this.search = null;\n                this.query = null;\n                this.pathname = null;\n                this.path = null;\n                this.href = null;\n            }\n\n            // Reference: RFC 3986, RFC 1808, RFC 2396\n\n            // define these here so at least they only have to be\n            // compiled once on the first module load.\n            var protocolPattern = /^([a-z0-9.+-]+:)/i,\n                portPattern = /:[0-9]*$/,\n\n\n            // Special case for a simple path URL\n            simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n\n            // RFC 2396: characters reserved for delimiting URLs.\n            // We actually just auto-escape these.\n            delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n\n            // RFC 2396: characters not allowed for various reasons.\n            unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n\n            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n            autoEscape = ['\\''].concat(unwise),\n\n            // Characters that are never ever allowed in a hostname.\n            // Note that any invalid chars are also handled, but these\n            // are the ones that are *expected* to be seen, so we fast-path\n            // them.\n            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n                hostEndingChars = ['/', '?', '#'],\n                hostnameMaxLen = 255,\n                hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n\n            // protocols that can allow \"unsafe\" and \"unwise\" chars.\n            unsafeProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that never have a hostname.\n            hostlessProtocol = {\n                'javascript': true,\n                'javascript:': true\n            },\n\n            // protocols that always contain a // bit.\n            slashedProtocol = {\n                'http': true,\n                'https': true,\n                'ftp': true,\n                'gopher': true,\n                'file': true,\n                'http:': true,\n                'https:': true,\n                'ftp:': true,\n                'gopher:': true,\n                'file:': true\n            },\n                querystring = require('querystring');\n\n            function urlParse(url, parseQueryString, slashesDenoteHost) {\n                if (url && util.isObject(url) && url instanceof Url) return url;\n\n                var u = new Url();\n                u.parse(url, parseQueryString, slashesDenoteHost);\n                return u;\n            }\n\n            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n                if (!util.isString(url)) {\n                    throw new TypeError(\"Parameter 'url' must be a string, not \" + (typeof url === \"undefined\" ? \"undefined\" : _typeof(url)));\n                }\n\n                // Copy chrome, IE, opera backslash-handling behavior.\n                // Back slashes before the query string get converted to forward slashes\n                // See: https://code.google.com/p/chromium/issues/detail?id=25916\n                var queryIndex = url.indexOf('?'),\n                    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n                    uSplit = url.split(splitter),\n                    slashRegex = /\\\\/g;\n                uSplit[0] = uSplit[0].replace(slashRegex, '/');\n                url = uSplit.join(splitter);\n\n                var rest = url;\n\n                // trim before proceeding.\n                // This is to support parse stuff like \"  http://foo.com  \\n\"\n                rest = rest.trim();\n\n                if (!slashesDenoteHost && url.split('#').length === 1) {\n                    // Try fast path regexp\n                    var simplePath = simplePathPattern.exec(rest);\n                    if (simplePath) {\n                        this.path = rest;\n                        this.href = rest;\n                        this.pathname = simplePath[1];\n                        if (simplePath[2]) {\n                            this.search = simplePath[2];\n                            if (parseQueryString) {\n                                this.query = querystring.parse(this.search.substr(1));\n                            } else {\n                                this.query = this.search.substr(1);\n                            }\n                        } else if (parseQueryString) {\n                            this.search = '';\n                            this.query = {};\n                        }\n                        return this;\n                    }\n                }\n\n                var proto = protocolPattern.exec(rest);\n                if (proto) {\n                    proto = proto[0];\n                    var lowerProto = proto.toLowerCase();\n                    this.protocol = lowerProto;\n                    rest = rest.substr(proto.length);\n                }\n\n                // figure out if it's got a host\n                // user@server is *always* interpreted as a hostname, and url\n                // resolution will treat //foo/bar as host=foo,path=bar because that's\n                // how the browser resolves relative URLs.\n                if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n                    var slashes = rest.substr(0, 2) === '//';\n                    if (slashes && !(proto && hostlessProtocol[proto])) {\n                        rest = rest.substr(2);\n                        this.slashes = true;\n                    }\n                }\n\n                if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n\n                    // there's a hostname.\n                    // the first instance of /, ?, ;, or # ends the host.\n                    //\n                    // If there is an @ in the hostname, then non-host chars *are* allowed\n                    // to the left of the last @ sign, unless some host-ending character\n                    // comes *before* the @-sign.\n                    // URLs are obnoxious.\n                    //\n                    // ex:\n                    // http://a@b@c/ => user:a@b host:c\n                    // http://a@b?@c => user:a host:c path:/?@c\n\n                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n                    // Review our test case against browsers more comprehensively.\n\n                    // find the first instance of any hostEndingChars\n                    var hostEnd = -1;\n                    for (var i = 0; i < hostEndingChars.length; i++) {\n                        var hec = rest.indexOf(hostEndingChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n\n                    // at this point, either we have an explicit point where the\n                    // auth portion cannot go past, or the last @ char is the decider.\n                    var auth, atSign;\n                    if (hostEnd === -1) {\n                        // atSign can be anywhere.\n                        atSign = rest.lastIndexOf('@');\n                    } else {\n                        // atSign must be in auth portion.\n                        // http://a@b/c@d => host:b auth:a path:/c@d\n                        atSign = rest.lastIndexOf('@', hostEnd);\n                    }\n\n                    // Now we have a portion which is definitely the auth.\n                    // Pull that off.\n                    if (atSign !== -1) {\n                        auth = rest.slice(0, atSign);\n                        rest = rest.slice(atSign + 1);\n                        this.auth = decodeURIComponent(auth);\n                    }\n\n                    // the host is the remaining to the left of the first non-host char\n                    hostEnd = -1;\n                    for (var i = 0; i < nonHostChars.length; i++) {\n                        var hec = rest.indexOf(nonHostChars[i]);\n                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n                    }\n                    // if we still have not hit it, then the entire thing is a host.\n                    if (hostEnd === -1) hostEnd = rest.length;\n\n                    this.host = rest.slice(0, hostEnd);\n                    rest = rest.slice(hostEnd);\n\n                    // pull out port.\n                    this.parseHost();\n\n                    // we've indicated that there is a hostname,\n                    // so even if it's empty, it has to be present.\n                    this.hostname = this.hostname || '';\n\n                    // if hostname begins with [ and ends with ]\n                    // assume that it's an IPv6 address.\n                    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n                    // validate a little.\n                    if (!ipv6Hostname) {\n                        var hostparts = this.hostname.split(/\\./);\n                        for (var i = 0, l = hostparts.length; i < l; i++) {\n                            var part = hostparts[i];\n                            if (!part) continue;\n                            if (!part.match(hostnamePartPattern)) {\n                                var newpart = '';\n                                for (var j = 0, k = part.length; j < k; j++) {\n                                    if (part.charCodeAt(j) > 127) {\n                                        // we replace non-ASCII char with a temporary placeholder\n                                        // we need this to make sure size of hostname is not\n                                        // broken by replacing non-ASCII by nothing\n                                        newpart += 'x';\n                                    } else {\n                                        newpart += part[j];\n                                    }\n                                }\n                                // we test again with ASCII char only\n                                if (!newpart.match(hostnamePartPattern)) {\n                                    var validParts = hostparts.slice(0, i);\n                                    var notHost = hostparts.slice(i + 1);\n                                    var bit = part.match(hostnamePartStart);\n                                    if (bit) {\n                                        validParts.push(bit[1]);\n                                        notHost.unshift(bit[2]);\n                                    }\n                                    if (notHost.length) {\n                                        rest = '/' + notHost.join('.') + rest;\n                                    }\n                                    this.hostname = validParts.join('.');\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (this.hostname.length > hostnameMaxLen) {\n                        this.hostname = '';\n                    } else {\n                        // hostnames are always lower case.\n                        this.hostname = this.hostname.toLowerCase();\n                    }\n\n                    if (!ipv6Hostname) {\n                        // IDNA Support: Returns a punycoded representation of \"domain\".\n                        // It only converts parts of the domain name that\n                        // have non-ASCII characters, i.e. it doesn't matter if\n                        // you call it with a domain that already is ASCII-only.\n                        this.hostname = punycode.toASCII(this.hostname);\n                    }\n\n                    var p = this.port ? ':' + this.port : '';\n                    var h = this.hostname || '';\n                    this.host = h + p;\n                    this.href += this.host;\n\n                    // strip [ and ] from the hostname\n                    // the host field still retains them, though\n                    if (ipv6Hostname) {\n                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n                        if (rest[0] !== '/') {\n                            rest = '/' + rest;\n                        }\n                    }\n                }\n\n                // now rest is set to the post-host stuff.\n                // chop off any delim chars.\n                if (!unsafeProtocol[lowerProto]) {\n\n                    // First, make 100% sure that any \"autoEscape\" chars get\n                    // escaped, even if encodeURIComponent doesn't think they\n                    // need to be.\n                    for (var i = 0, l = autoEscape.length; i < l; i++) {\n                        var ae = autoEscape[i];\n                        if (rest.indexOf(ae) === -1) continue;\n                        var esc = encodeURIComponent(ae);\n                        if (esc === ae) {\n                            esc = escape(ae);\n                        }\n                        rest = rest.split(ae).join(esc);\n                    }\n                }\n\n                // chop off from the tail first.\n                var hash = rest.indexOf('#');\n                if (hash !== -1) {\n                    // got a fragment string.\n                    this.hash = rest.substr(hash);\n                    rest = rest.slice(0, hash);\n                }\n                var qm = rest.indexOf('?');\n                if (qm !== -1) {\n                    this.search = rest.substr(qm);\n                    this.query = rest.substr(qm + 1);\n                    if (parseQueryString) {\n                        this.query = querystring.parse(this.query);\n                    }\n                    rest = rest.slice(0, qm);\n                } else if (parseQueryString) {\n                    // no query string, but parseQueryString still requested\n                    this.search = '';\n                    this.query = {};\n                }\n                if (rest) this.pathname = rest;\n                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n                    this.pathname = '/';\n                }\n\n                //to support http.request\n                if (this.pathname || this.search) {\n                    var p = this.pathname || '';\n                    var s = this.search || '';\n                    this.path = p + s;\n                }\n\n                // finally, reconstruct the href based on what has been validated.\n                this.href = this.format();\n                return this;\n            };\n\n            // format a parsed object into a url string\n            function urlFormat(obj) {\n                // ensure it's an object, and not a string url.\n                // If it's an obj, this is a no-op.\n                // this way, you can call url_format() on strings\n                // to clean up potentially wonky urls.\n                if (util.isString(obj)) obj = urlParse(obj);\n                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n                return obj.format();\n            }\n\n            Url.prototype.format = function () {\n                var auth = this.auth || '';\n                if (auth) {\n                    auth = encodeURIComponent(auth);\n                    auth = auth.replace(/%3A/i, ':');\n                    auth += '@';\n                }\n\n                var protocol = this.protocol || '',\n                    pathname = this.pathname || '',\n                    hash = this.hash || '',\n                    host = false,\n                    query = '';\n\n                if (this.host) {\n                    host = auth + this.host;\n                } else if (this.hostname) {\n                    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n                    if (this.port) {\n                        host += ':' + this.port;\n                    }\n                }\n\n                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n                    query = querystring.stringify(this.query);\n                }\n\n                var search = this.search || query && '?' + query || '';\n\n                if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n                // unless they had them to begin with.\n                if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n                    host = '//' + (host || '');\n                    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n                } else if (!host) {\n                    host = '';\n                }\n\n                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n                if (search && search.charAt(0) !== '?') search = '?' + search;\n\n                pathname = pathname.replace(/[?#]/g, function (match) {\n                    return encodeURIComponent(match);\n                });\n                search = search.replace('#', '%23');\n\n                return protocol + host + pathname + search + hash;\n            };\n\n            function urlResolve(source, relative) {\n                return urlParse(source, false, true).resolve(relative);\n            }\n\n            Url.prototype.resolve = function (relative) {\n                return this.resolveObject(urlParse(relative, false, true)).format();\n            };\n\n            function urlResolveObject(source, relative) {\n                if (!source) return relative;\n                return urlParse(source, false, true).resolveObject(relative);\n            }\n\n            Url.prototype.resolveObject = function (relative) {\n                if (util.isString(relative)) {\n                    var rel = new Url();\n                    rel.parse(relative, false, true);\n                    relative = rel;\n                }\n\n                var result = new Url();\n                var tkeys = Object.keys(this);\n                for (var tk = 0; tk < tkeys.length; tk++) {\n                    var tkey = tkeys[tk];\n                    result[tkey] = this[tkey];\n                }\n\n                // hash is always overridden, no matter what.\n                // even href=\"\" will remove it.\n                result.hash = relative.hash;\n\n                // if the relative url is empty, then there's nothing left to do here.\n                if (relative.href === '') {\n                    result.href = result.format();\n                    return result;\n                }\n\n                // hrefs like //foo/bar always cut to the protocol.\n                if (relative.slashes && !relative.protocol) {\n                    // take everything except the protocol from relative\n                    var rkeys = Object.keys(relative);\n                    for (var rk = 0; rk < rkeys.length; rk++) {\n                        var rkey = rkeys[rk];\n                        if (rkey !== 'protocol') result[rkey] = relative[rkey];\n                    }\n\n                    //urlParse appends trailing / to urls like http://www.example.com\n                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n                        result.path = result.pathname = '/';\n                    }\n\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (relative.protocol && relative.protocol !== result.protocol) {\n                    // if it's a known url protocol, then changing\n                    // the protocol does weird things\n                    // first, if it's not file:, then we MUST have a host,\n                    // and if there was a path\n                    // to begin with, then we MUST have a path.\n                    // if it is file:, then the host is dropped,\n                    // because that's known to be hostless.\n                    // anything else is assumed to be absolute.\n                    if (!slashedProtocol[relative.protocol]) {\n                        var keys = Object.keys(relative);\n                        for (var v = 0; v < keys.length; v++) {\n                            var k = keys[v];\n                            result[k] = relative[k];\n                        }\n                        result.href = result.format();\n                        return result;\n                    }\n\n                    result.protocol = relative.protocol;\n                    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n                        var relPath = (relative.pathname || '').split('/');\n                        while (relPath.length && !(relative.host = relPath.shift())) {}\n                        if (!relative.host) relative.host = '';\n                        if (!relative.hostname) relative.hostname = '';\n                        if (relPath[0] !== '') relPath.unshift('');\n                        if (relPath.length < 2) relPath.unshift('');\n                        result.pathname = relPath.join('/');\n                    } else {\n                        result.pathname = relative.pathname;\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    result.host = relative.host || '';\n                    result.auth = relative.auth;\n                    result.hostname = relative.hostname || relative.host;\n                    result.port = relative.port;\n                    // to support http.request\n                    if (result.pathname || result.search) {\n                        var p = result.pathname || '';\n                        var s = result.search || '';\n                        result.path = p + s;\n                    }\n                    result.slashes = result.slashes || relative.slashes;\n                    result.href = result.format();\n                    return result;\n                }\n\n                var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n                    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n                    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n                    removeAllDots = mustEndAbs,\n                    srcPath = result.pathname && result.pathname.split('/') || [],\n                    relPath = relative.pathname && relative.pathname.split('/') || [],\n                    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n                // if the url is a non-slashed url, then relative\n                // links like ../.. should be able\n                // to crawl up to the hostname, as well.  This is strange.\n                // result.protocol has already been set by now.\n                // Later on, put the first path part into the host field.\n                if (psychotic) {\n                    result.hostname = '';\n                    result.port = null;\n                    if (result.host) {\n                        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n                    }\n                    result.host = '';\n                    if (relative.protocol) {\n                        relative.hostname = null;\n                        relative.port = null;\n                        if (relative.host) {\n                            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n                        }\n                        relative.host = null;\n                    }\n                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n                }\n\n                if (isRelAbs) {\n                    // it's absolute.\n                    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n                    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    srcPath = relPath;\n                    // fall through to the dot-handling below.\n                } else if (relPath.length) {\n                    // it's relative\n                    // throw away the existing file, and take the new path instead.\n                    if (!srcPath) srcPath = [];\n                    srcPath.pop();\n                    srcPath = srcPath.concat(relPath);\n                    result.search = relative.search;\n                    result.query = relative.query;\n                } else if (!util.isNullOrUndefined(relative.search)) {\n                    // just pull out the search.\n                    // like href='?foo'.\n                    // Put this after the other two cases because it simplifies the booleans\n                    if (psychotic) {\n                        result.hostname = result.host = srcPath.shift();\n                        //occationaly the auth can get stuck only in host\n                        //this especially happens in cases like\n                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                        if (authInHost) {\n                            result.auth = authInHost.shift();\n                            result.host = result.hostname = authInHost.shift();\n                        }\n                    }\n                    result.search = relative.search;\n                    result.query = relative.query;\n                    //to support http.request\n                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                if (!srcPath.length) {\n                    // no path at all.  easy.\n                    // we've already handled the other stuff above.\n                    result.pathname = null;\n                    //to support http.request\n                    if (result.search) {\n                        result.path = '/' + result.search;\n                    } else {\n                        result.path = null;\n                    }\n                    result.href = result.format();\n                    return result;\n                }\n\n                // if a url ENDs in . or .., then it must get a trailing slash.\n                // however, if it ends in anything else non-slashy,\n                // then it must NOT get a trailing slash.\n                var last = srcPath.slice(-1)[0];\n                var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n                // strip single dots, resolve double dots to parent dir\n                // if the path tries to go above the root, `up` ends up > 0\n                var up = 0;\n                for (var i = srcPath.length; i >= 0; i--) {\n                    last = srcPath[i];\n                    if (last === '.') {\n                        srcPath.splice(i, 1);\n                    } else if (last === '..') {\n                        srcPath.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        srcPath.splice(i, 1);\n                        up--;\n                    }\n                }\n\n                // if the path is allowed to go above the root, restore leading ..s\n                if (!mustEndAbs && !removeAllDots) {\n                    for (; up--; up) {\n                        srcPath.unshift('..');\n                    }\n                }\n\n                if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n                    srcPath.unshift('');\n                }\n\n                if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n                    srcPath.push('');\n                }\n\n                var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n                // put the host back\n                if (psychotic) {\n                    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n                    //occationaly the auth can get stuck only in host\n                    //this especially happens in cases like\n                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n                    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n                    if (authInHost) {\n                        result.auth = authInHost.shift();\n                        result.host = result.hostname = authInHost.shift();\n                    }\n                }\n\n                mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n                if (mustEndAbs && !isAbsolute) {\n                    srcPath.unshift('');\n                }\n\n                if (!srcPath.length) {\n                    result.pathname = null;\n                    result.path = null;\n                } else {\n                    result.pathname = srcPath.join('/');\n                }\n\n                //to support request.http\n                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n                }\n                result.auth = relative.auth || result.auth;\n                result.slashes = result.slashes || relative.slashes;\n                result.href = result.format();\n                return result;\n            };\n\n            Url.prototype.parseHost = function () {\n                var host = this.host;\n                var port = portPattern.exec(host);\n                if (port) {\n                    port = port[0];\n                    if (port !== ':') {\n                        this.port = port.substr(1);\n                    }\n                    host = host.substr(0, host.length - port.length);\n                }\n                if (host) this.hostname = host;\n            };\n        }, { \"./util\": 6, \"punycode\": 1, \"querystring\": 4 }], 6: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = {\n                isString: function isString(arg) {\n                    return typeof arg === 'string';\n                },\n                isObject: function isObject(arg) {\n                    return (typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg)) === 'object' && arg !== null;\n                },\n                isNull: function isNull(arg) {\n                    return arg === null;\n                },\n                isNullOrUndefined: function isNullOrUndefined(arg) {\n                    return arg == null;\n                }\n            };\n        }, {}], 7: [function (require, module, exports) {\n            \"use strict\";\n\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var thing_description_1 = require(\"./thing-description\");\n            var TD = require(\"./thing-description\");\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            function parseTDObject(td) {\n                return parseTDString(typedjson_npm_1.TypedJSON.stringify(td, { enableTypeHints: false }));\n            }\n            exports.parseTDObject = parseTDObject;\n            function parseTDString(json) {\n                console.log(\"parseTDString() parsing\\n```\\n\" + json + \"\\n```\");\n                var td = typedjson_npm_1.TypedJSON.parse(json, thing_description_1.default);\n                console.log(\"parseTDString() found \" + td.interaction.length + \" Interaction\" + (td.interaction.length === 1 ? '' : 's'));\n                for (var _i = 0, _a = td.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Property.toString()) !== -1) {\n                        console.log(\" * Property '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Property;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Action.toString()) !== -1) {\n                        console.log(\" * Action '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Action;\n                    } else if (interaction.semanticTypes.indexOf(TD.InteractionPattern.Event.toString()) !== -1) {\n                        console.log(\" * Event '\" + interaction.name + \"'\");\n                        interaction.pattern = TD.InteractionPattern.Event;\n                    } else {\n                        console.error(\"parseTDString() found unknown Interaction pattern '\" + interaction.semanticTypes + \"'\");\n                    }\n                    if (td.base !== undefined) {\n                        console.log(\"parseTDString() applying base '\" + td.base + \"' to href '\" + interaction.link[0].href + \"'\");\n                        var href = interaction.link[0].href;\n                        var url = require('url');\n                        var n = td.base.indexOf(':');\n                        var pr = td.base.substr(0, n + 1);\n                        var uriTemp = td.base.replace(pr, 'http:');\n                        uriTemp = url.resolve(uriTemp, href);\n                        uriTemp = uriTemp.replace('http:', pr);\n                        interaction.link[0].href = uriTemp;\n                    }\n                }\n                return td;\n            }\n            exports.parseTDString = parseTDString;\n            function serializeTD(td) {\n                typedjson_npm_1.TypedJSON.config({ \"enableTypeHints\": false });\n                var json = typedjson_npm_1.TypedJSON.stringify(td);\n                var raw = JSON.parse(json);\n                if (td.base === null || td.base === undefined) {\n                    delete raw.base;\n                }\n                for (var _i = 0, _a = raw.interaction; _i < _a.length; _i++) {\n                    var interaction = _a[_i];\n                    if (interaction.inputData === null) {\n                        delete interaction.inputData;\n                    }\n                    if (interaction.outputData === null) {\n                        delete interaction.outputData;\n                    }\n                    if (interaction.writable === null) {\n                        delete interaction.writable;\n                    }\n                    if (interaction.outputData && interaction.outputData.required !== undefined) {\n                        console.log(\"### HOTFIX for TypedJSON ###\");\n                        var reqs = [];\n                        for (var req in interaction.outputData.required) {\n                            reqs.push(interaction.outputData.required[req]);\n                        }interaction.outputData.required = reqs;\n                    }\n                }\n                json = JSON.stringify(raw);\n                console.log(\"serializeTD() produced\\n```\\n\" + json + \"\\n```\");\n                return json;\n            }\n            exports.serializeTD = serializeTD;\n        }, { \"./thing-description\": 8, \"typedjson-npm\": 9, \"url\": 5 }], 8: [function (require, module, exports) {\n            \"use strict\";\n\n            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n                var c = arguments.length,\n                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n                    d;\n                if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                }return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var typedjson_npm_1 = require(\"typedjson-npm\");\n            var InteractionPattern;\n            (function (InteractionPattern) {\n                InteractionPattern[InteractionPattern[\"Property\"] = 'Property'] = \"Property\";\n                InteractionPattern[InteractionPattern[\"Action\"] = 'Action'] = \"Action\";\n                InteractionPattern[InteractionPattern[\"Event\"] = 'Event'] = \"Event\";\n            })(InteractionPattern = exports.InteractionPattern || (exports.InteractionPattern = {}));\n            var InteractionLink = function () {\n                function InteractionLink() {}\n                return InteractionLink;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"href\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], InteractionLink.prototype, \"mediaType\", void 0);\n            InteractionLink = __decorate([typedjson_npm_1.JsonObject()], InteractionLink);\n            exports.InteractionLink = InteractionLink;\n            var Interaction = function () {\n                function Interaction() {\n                    this.semanticTypes = [];\n                    this.link = [];\n                }\n                return Interaction;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', isRequired: true, elements: String })], Interaction.prototype, \"semanticTypes\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], Interaction.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: InteractionLink })], Interaction.prototype, \"link\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Boolean })], Interaction.prototype, \"writable\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"inputData\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: Object })], Interaction.prototype, \"outputData\", void 0);\n            Interaction = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [InteractionLink] })], Interaction);\n            exports.Interaction = Interaction;\n            var ThingDescription = function () {\n                function ThingDescription() {\n                    this.context = ['http://w3c.github.io/wot/w3c-wot-td-context.jsonld'];\n                    this.semanticType = ['Thing'];\n                    this.interaction = [];\n                }\n                return ThingDescription;\n            }();\n            __decorate([typedjson_npm_1.JsonMember({ name: '@type', elements: String })], ThingDescription.prototype, \"semanticType\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, type: String })], ThingDescription.prototype, \"name\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ type: String })], ThingDescription.prototype, \"base\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ isRequired: true, elements: Interaction })], ThingDescription.prototype, \"interaction\", void 0);\n            __decorate([typedjson_npm_1.JsonMember({ name: '@context', elements: String })], ThingDescription.prototype, \"context\", void 0);\n            ThingDescription = __decorate([typedjson_npm_1.JsonObject({ knownTypes: [Interaction] })], ThingDescription);\n            exports.default = ThingDescription;\n        }, { \"typedjson-npm\": 9 }], 9: [function (require, module, exports) {\n            /*!\n            TypedJSON v0.2.0 - https://github.com/JohnWhiteTB/TypedJSON\n            \n            Typed JSON parsing and serializing that preserves type information. Parse JSON into actual class instances. Recommended (but not required)\n            to be used with reflect-metadata (global installation): https://github.com/rbuckton/ReflectDecorators.\n            \n            \n            The MIT License (MIT)\n            Copyright (c) 2016 John White\n            \n            Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the\n            \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish,\n            distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to\n            the following conditions:\n            \n            The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n            \n            THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n            MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n            CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n            SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n            */\n            (function (factory) {\n                if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n                    var v = factory(require, exports);if (v !== undefined) module.exports = v;\n                } else if (typeof define === 'function' && define.amd) {\n                    define([\"require\", \"exports\"], factory);\n                }\n            })(function (require, exports) {\n                \"use strict\";\n\n                var METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n                var JSON;\n                if (!JSON) {\n                    JSON = {\n                        parse: function parse(sJSON) {\n                            var returnval = sJSON;\n                            if ((typeof returnval === \"undefined\" ? \"undefined\" : _typeof(returnval)) === 'object') {\n                                return returnval;\n                            } else {\n                                return eval('(' + sJSON + ')');\n                            }\n                        },\n                        stringify: function () {\n                            var toString = Object.prototype.toString;\n                            var isArray = Array.isArray || function (a) {\n                                return toString.call(a) === '[object Array]';\n                            };\n                            var escMap = { '\"': '\\\\\"', '\\\\': '\\\\\\\\', '\\b': '\\\\b', '\\f': '\\\\f', '\\n': '\\\\n', '\\r': '\\\\r', '\\t': '\\\\t' };\n                            var escFunc = function escFunc(m) {\n                                return escMap[m] || \"\\\\u\" + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);\n                            };\n                            var escRE = /[\\\\\"\\u0000-\\u001F\\u2028\\u2029]/g;\n                            return function stringify(value) {\n                                if (value == null) {\n                                    return 'null';\n                                } else if (typeof value === 'number') {\n                                    return isFinite(value) ? value.toString() : 'null';\n                                } else if (typeof value === 'boolean') {\n                                    return value.toString();\n                                } else if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n                                    if (typeof value.toJSON === 'function') {\n                                        return stringify(value.toJSON());\n                                    } else if (isArray(value)) {\n                                        var res = '[';\n                                        for (var i = 0; i < value.length; i++) {\n                                            res += (i ? ', ' : '') + stringify(value[i]);\n                                        }return res + ']';\n                                    } else if (toString.call(value) === '[object Object]') {\n                                        var tmp = [];\n                                        for (var k in value) {\n                                            if (value.hasOwnProperty(k)) tmp.push(stringify(k) + ': ' + stringify(value[k]));\n                                        }\n                                        return '{' + tmp.join(', ') + '}';\n                                    }\n                                }\n                                return '\"' + value.toString().replace(escRE, escFunc) + '\"';\n                            };\n                        }()\n                    };\n                }\n                var Helpers;\n                (function (Helpers) {\n                    function assign(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = Object(target);\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.assign = assign;\n                    function error(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.error === \"function\") {\n                            console.error.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"ERROR: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.error = error;\n                    function getClassName(target) {\n                        var targetType;\n                        if (typeof target === \"function\") {\n                            targetType = target;\n                        } else if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\") {\n                            targetType = target.constructor;\n                        }\n                        if (!targetType) {\n                            return \"undefined\";\n                        }\n                        if (\"name\" in targetType && typeof targetType.name === \"string\") {\n                            return targetType.name;\n                        } else {\n                            return targetType.toString().match(/function (\\w*)/)[1];\n                        }\n                    }\n                    Helpers.getClassName = getClassName;\n                    function getDefaultValue(type) {\n                        switch (type) {\n                            case Number:\n                                return 0;\n                            case String:\n                                return \"\";\n                            case Boolean:\n                                return false;\n                            case Array:\n                                return [];\n                            default:\n                                return null;\n                        }\n                    }\n                    Helpers.getDefaultValue = getDefaultValue;\n                    function getPropertyDisplayName(target, propertyKey) {\n                        return getClassName(target) + \".\" + propertyKey.toString();\n                    }\n                    Helpers.getPropertyDisplayName = getPropertyDisplayName;\n                    function isArray(object) {\n                        if (typeof Array.isArray === \"function\") {\n                            return Array.isArray(object);\n                        } else {\n                            if (object instanceof Array) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        }\n                    }\n                    Helpers.isArray = isArray;\n                    function isPrimitive(obj) {\n                        switch (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) {\n                            case \"string\":\n                            case \"number\":\n                            case \"boolean\":\n                                return true;\n                        }\n                        if (obj instanceof String || obj === String || obj instanceof Number || obj === Number || obj instanceof Boolean || obj === Boolean) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    Helpers.isPrimitive = isPrimitive;\n                    function isReservedMemberName(name) {\n                        return name === METADATA_FIELD_KEY;\n                    }\n                    Helpers.isReservedMemberName = isReservedMemberName;\n                    function isSubtypeOf(A, B) {\n                        var aPrototype = A.prototype;\n                        if (A === B) {\n                            return true;\n                        }\n                        while (aPrototype) {\n                            if (aPrototype instanceof B) {\n                                return true;\n                            }\n                            aPrototype = aPrototype.prototype;\n                        }\n                        return false;\n                    }\n                    Helpers.isSubtypeOf = isSubtypeOf;\n                    function log(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.log = log;\n                    function merge(target) {\n                        var sources = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            sources[_i - 1] = arguments[_i];\n                        }\n                        var output;\n                        var source;\n                        if (target === undefined || target === null) {\n                            throw new TypeError(\"Cannot convert undefined or null to object\");\n                        }\n                        output = {};\n                        Object.keys(target).forEach(function (nextKey) {\n                            output[nextKey] = target[nextKey];\n                        });\n                        for (var i = 1; i < arguments.length; i++) {\n                            source = arguments[i];\n                            if (source !== undefined && source !== null) {\n                                for (var nextKey in source) {\n                                    if (source.hasOwnProperty(nextKey)) {\n                                        output[nextKey] = source[nextKey];\n                                    }\n                                }\n                            }\n                        }\n                        return output;\n                    }\n                    Helpers.merge = merge;\n                    function valueIsDefined(value) {\n                        if (typeof value === \"undefined\" || value === null) {\n                            return false;\n                        } else {\n                            return true;\n                        }\n                    }\n                    Helpers.valueIsDefined = valueIsDefined;\n                    function warn(message) {\n                        var optionalParams = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            optionalParams[_i - 1] = arguments[_i];\n                        }\n                        if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.warn === \"function\") {\n                            console.warn.apply(console, [message].concat(optionalParams));\n                        } else if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === \"object\" && typeof console.log === \"function\") {\n                            console.log.apply(console, [\"WARNING: \" + message].concat(optionalParams));\n                        }\n                    }\n                    Helpers.warn = warn;\n                })(Helpers || (Helpers = {}));\n                var JsonMemberMetadata = function () {\n                    function JsonMemberMetadata() {}\n                    return JsonMemberMetadata;\n                }();\n                var JsonObjectMetadata = function () {\n                    function JsonObjectMetadata() {\n                        this._dataMembers = {};\n                        this._knownTypes = [];\n                        this._knownTypeCache = null;\n                        this.isExplicitlyMarked = false;\n                    }\n                    JsonObjectMetadata.getJsonObjectName = function (type, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var metadata = this.getFromType(type, inherited);\n                        if (metadata !== null) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(type);\n                        }\n                    };\n                    JsonObjectMetadata.getFromType = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        var targetPrototype;\n                        var metadata;\n                        if (typeof target === \"function\") {\n                            targetPrototype = target.prototype;\n                        } else {\n                            targetPrototype = target;\n                        }\n                        if (!targetPrototype) {\n                            return null;\n                        }\n                        if (targetPrototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        } else if (inherited && targetPrototype[METADATA_FIELD_KEY]) {\n                            metadata = targetPrototype[METADATA_FIELD_KEY];\n                        }\n                        if (metadata && metadata.isExplicitlyMarked) {\n                            return metadata;\n                        } else {\n                            return null;\n                        }\n                    };\n                    JsonObjectMetadata.getFromInstance = function (target, inherited) {\n                        if (inherited === void 0) {\n                            inherited = true;\n                        }\n                        return this.getFromType(Object.getPrototypeOf(target), inherited);\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromType = function (target) {\n                        var metadata = this.getFromType(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target);\n                        }\n                    };\n                    JsonObjectMetadata.getKnownTypeNameFromInstance = function (target) {\n                        var metadata = this.getFromInstance(target, false);\n                        if (metadata) {\n                            return metadata.className;\n                        } else {\n                            return Helpers.getClassName(target.constructor);\n                        }\n                    };\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"dataMembers\", {\n                        get: function get() {\n                            return this._dataMembers;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"className\", {\n                        get: function get() {\n                            if (typeof this._className === \"string\") {\n                                return this._className;\n                            } else {\n                                return Helpers.getClassName(this.classType);\n                            }\n                        },\n                        set: function set(value) {\n                            this._className = value;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    Object.defineProperty(JsonObjectMetadata.prototype, \"knownTypes\", {\n                        get: function get() {\n                            var knownTypes;\n                            var knownTypeName;\n                            knownTypes = {};\n                            this._knownTypes.forEach(function (knownType) {\n                                knownTypeName = JsonObjectMetadata.getKnownTypeNameFromType(knownType);\n                                knownTypes[knownTypeName] = knownType;\n                            });\n                            this._knownTypeCache = knownTypes;\n                            return knownTypes;\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                    JsonObjectMetadata.prototype.setKnownType = function (type) {\n                        if (this._knownTypes.indexOf(type) === -1) {\n                            this._knownTypes.push(type);\n                            this._knownTypeCache = null;\n                        }\n                    };\n                    JsonObjectMetadata.prototype.addMember = function (member) {\n                        var _this = this;\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            if (_this._dataMembers[propertyKey].name === member.name) {\n                                throw new Error(\"A member with the name '\" + member.name + \"' already exists.\");\n                            }\n                        });\n                        this._dataMembers[member.key] = member;\n                    };\n                    JsonObjectMetadata.prototype.sortMembers = function () {\n                        var _this = this;\n                        var memberArray = [];\n                        Object.keys(this._dataMembers).forEach(function (propertyKey) {\n                            memberArray.push(_this._dataMembers[propertyKey]);\n                        });\n                        memberArray = memberArray.sort(this.sortMembersCompare);\n                        this._dataMembers = {};\n                        memberArray.forEach(function (dataMember) {\n                            _this._dataMembers[dataMember.key] = dataMember;\n                        });\n                    };\n                    JsonObjectMetadata.prototype.sortMembersCompare = function (a, b) {\n                        if (typeof a.order !== \"number\" && typeof b.order !== \"number\") {\n                            if (a.name < b.name) {\n                                return -1;\n                            } else if (a.name > b.name) {\n                                return 1;\n                            }\n                        } else if (typeof a.order !== \"number\") {\n                            return 1;\n                        } else if (typeof b.order !== \"number\") {\n                            return -1;\n                        } else {\n                            if (a.order < b.order) {\n                                return -1;\n                            } else if (a.order > b.order) {\n                                return 1;\n                            } else {\n                                if (a.name < b.name) {\n                                    return -1;\n                                } else if (a.name > b.name) {\n                                    return 1;\n                                }\n                            }\n                        }\n                        return 0;\n                    };\n                    return JsonObjectMetadata;\n                }();\n                function JsonObject(optionsOrTarget) {\n                    var options;\n                    if (typeof optionsOrTarget === \"function\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    var initializer = options.initializer;\n                    var serializer = options.serializer;\n                    var decorator = function decorator(target) {\n                        var objectMetadata;\n                        var parentMetadata;\n                        var i;\n                        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target.prototype[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                                Object.keys(parentMetadata.knownTypes).forEach(function (key) {\n                                    objectMetadata.setKnownType(parentMetadata.knownTypes[key]);\n                                });\n                            }\n                            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n                        }\n                        objectMetadata.classType = target;\n                        objectMetadata.isExplicitlyMarked = true;\n                        if (options.name) {\n                            objectMetadata.className = options.name;\n                        }\n                        if (options.knownTypes) {\n                            i = 0;\n                            try {\n                                options.knownTypes.forEach(function (knownType) {\n                                    if (typeof knownType === \"undefined\") {\n                                        throw new TypeError(\"Known type #\" + i++ + \" is undefined.\");\n                                    }\n                                    objectMetadata.setKnownType(knownType);\n                                });\n                            } catch (e) {\n                                Helpers.error(new TypeError(\"@JsonObject: \" + e.message + \" (on '\" + Helpers.getClassName(target) + \"')\"));\n                            }\n                        }\n                        if (typeof initializer === \"function\") {\n                            objectMetadata.initializer = initializer;\n                        }\n\n                        if (typeof serializer === \"function\") {\n                            objectMetadata.serializer = serializer;\n                        }\n                    };\n                    if (typeof optionsOrTarget === \"function\") {\n                        return decorator(optionsOrTarget);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonObject = JsonObject;\n                function jsonMemberTypeInit(metadata, propertyName, warnArray) {\n                    if (warnArray === void 0) {\n                        warnArray = false;\n                    }\n                    if (metadata.elements) {\n                        if (typeof metadata.elements === \"function\") {\n                            metadata.elements = {\n                                type: metadata.elements\n                            };\n                        }\n                        if (!metadata.type) {\n                            metadata.type = Array;\n                        }\n                    }\n                    if (metadata.type === Array) {\n                        if (!metadata.elements) {\n                            if (warnArray) {\n                                Helpers.warn(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            } else {\n                                throw new Error(\"No valid 'elements' option was specified for '\" + propertyName + \"'.\");\n                            }\n                        } else {\n                            jsonMemberTypeInit(metadata.elements, propertyName + '[]', true);\n                        }\n                    }\n                    if (typeof metadata.type !== \"function\") {\n                        throw new Error(\"No valid 'type' option was specified for '\" + propertyName + \"'.\");\n                    }\n                }\n                function jsonMemberKnownTypes(metadata) {\n                    var knownTypes = new Array();\n                    knownTypes.push(metadata.type);\n                    if (metadata.elements) {\n                        knownTypes = knownTypes.concat(jsonMemberKnownTypes(metadata.elements));\n                    }\n                    return knownTypes;\n                }\n                function JsonMember(optionsOrTarget, propertyKey) {\n                    var memberMetadata = new JsonMemberMetadata();\n                    var options;\n                    var decorator;\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        options = {};\n                    } else {\n                        options = optionsOrTarget || {};\n                    }\n                    decorator = function decorator(target, propertyKey) {\n                        var descriptor = Object.getOwnPropertyDescriptor(target, propertyKey.toString());\n                        ;\n                        var objectMetadata;\n                        var parentMetadata;\n                        var reflectType;\n                        var propertyName = Helpers.getPropertyDisplayName(target, propertyKey);\n                        if (typeof target === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a static property ('\" + propertyName + \"').\");\n                        }\n                        if (typeof target[propertyKey] === \"function\") {\n                            throw new TypeError(\"@JsonMember cannot be used on a method property ('\" + propertyName + \"').\");\n                        }\n                        if (options.hasOwnProperty(\"elementType\")) {\n                            Helpers.warn(propertyName + \": the 'elementType' option is deprecated, use 'elements' instead.\");\n                            options.elements = options.elementType;\n                            if (options.elementType === Array) {\n                                memberMetadata.forceEnableTypeHinting = true;\n                            }\n                        }\n                        memberMetadata = Helpers.assign(memberMetadata, options);\n                        memberMetadata.key = propertyKey.toString();\n                        memberMetadata.name = options.name || propertyKey.toString();\n                        if (Helpers.isReservedMemberName(memberMetadata.name)) {\n                            throw new Error(\"@JsonMember: '\" + memberMetadata.name + \"' is a reserved name.\");\n                        }\n                        if (options.hasOwnProperty(\"type\") && typeof options.type === \"undefined\") {\n                            throw new TypeError(\"@JsonMember: 'type' of '\" + propertyName + \"' is undefined.\");\n                        }\n                        if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.getMetadata === \"function\") {\n                            reflectType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n                            if (typeof reflectType === \"undefined\") {\n                                throw new TypeError(\"@JsonMember: type detected for '\" + propertyName + \"' is undefined.\");\n                            }\n                            if (!memberMetadata.type || typeof memberMetadata.type !== \"function\") {\n                                memberMetadata.type = reflectType;\n                            } else if (memberMetadata.type !== reflectType) {\n                                Helpers.warn(\"@JsonMember: 'type' specified for '\" + propertyName + \"' does not match detected type.\");\n                            }\n                        }\n                        jsonMemberTypeInit(memberMetadata, propertyName);\n                        if (!target.hasOwnProperty(METADATA_FIELD_KEY)) {\n                            objectMetadata = new JsonObjectMetadata();\n                            if (parentMetadata = target[METADATA_FIELD_KEY]) {\n                                Object.keys(parentMetadata.dataMembers).forEach(function (memberPropertyKey) {\n                                    objectMetadata.dataMembers[memberPropertyKey] = parentMetadata.dataMembers[memberPropertyKey];\n                                });\n                            }\n                            Object.defineProperty(target, METADATA_FIELD_KEY, {\n                                enumerable: false,\n                                configurable: false,\n                                writable: false,\n                                value: objectMetadata\n                            });\n                        } else {\n                            objectMetadata = target[METADATA_FIELD_KEY];\n                        }\n                        jsonMemberKnownTypes(memberMetadata).forEach(function (knownType) {\n                            objectMetadata.setKnownType(knownType);\n                        });\n                        try {\n                            objectMetadata.addMember(memberMetadata);\n                        } catch (e) {\n                            throw new Error(\"Member '\" + memberMetadata.name + \"' already exists on '\" + Helpers.getClassName(objectMetadata.classType) + \"'.\");\n                        }\n                    };\n                    if (typeof propertyKey === \"string\" || (typeof propertyKey === \"undefined\" ? \"undefined\" : _typeof(propertyKey)) === \"symbol\") {\n                        return decorator(optionsOrTarget, propertyKey);\n                    } else {\n                        return decorator;\n                    }\n                }\n                exports.JsonMember = JsonMember;\n                var Serializer = function () {\n                    function Serializer() {}\n                    Serializer.writeObject = function (object, settings) {\n                        var objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                        var ObjectType;\n                        if (objectMetadata) {\n                            ObjectType = objectMetadata.classType;\n                        } else {\n                            ObjectType = object.constructor;\n                        }\n                        return JSON.stringify(this.writeToJsonObject(object, {\n                            objectType: ObjectType,\n                            enableTypeHints: settings.enableTypeHints,\n                            typeHintPropertyKey: settings.typeHintPropertyKey\n                        }), settings.replacer);\n                    };\n                    Serializer.writeToJsonObject = function (object, settings) {\n                        var _this = this;\n                        var json;\n                        var objectMetadata;\n                        if (object === null || typeof object === \"undefined\") {\n                            if (settings.emitDefault) {\n                                json = Helpers.getDefaultValue(settings.objectType);\n                            } else {\n                                json = object;\n                            }\n                        } else if (Helpers.isPrimitive(object) || object instanceof Date) {\n                            json = object;\n                        } else if (object instanceof Array) {\n                            json = [];\n                            for (var i = 0, n = object.length; i < n; i++) {\n                                json.push(this.writeToJsonObject(object[i], {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    objectType: settings.elements ? settings.elements.type : Object,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            }\n                        } else {\n                            objectMetadata = JsonObjectMetadata.getFromInstance(object);\n                            if (objectMetadata && typeof objectMetadata.serializer === \"function\") {\n                                json = objectMetadata.serializer(object);\n                            } else {\n                                json = {};\n                                if (settings.enableTypeHints && (settings.requireTypeHints || object.constructor !== settings.objectType)) {\n                                    json[settings.typeHintPropertyKey] = JsonObjectMetadata.getKnownTypeNameFromInstance(object);\n                                }\n                                if (objectMetadata) {\n                                    objectMetadata.sortMembers();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        json[propertyMetadata.name] = _this.writeToJsonObject(object[propertyKey], {\n                                            elements: propertyMetadata.elements,\n                                            emitDefault: propertyMetadata.emitDefaultValue,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            name: propertyMetadata.name,\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                } else {\n                                    Object.keys(object).forEach(function (propertyKey) {\n                                        json[propertyKey] = _this.writeToJsonObject(object[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            objectType: Object,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    });\n                                }\n                            }\n                        }\n                        return json;\n                    };\n                    return Serializer;\n                }();\n                var Deserializer = function () {\n                    function Deserializer() {}\n                    Deserializer.readObject = function (json, type, settings) {\n                        var value;\n                        var instance;\n                        var metadata = JsonObjectMetadata.getFromType(type);\n                        if (typeof json === 'Object') {\n                            value = json;\n                        } else {\n                            value = JSON.parse(json, settings.reviver);\n                        }\n                        if (typeof settings.maxObjects === \"number\") {\n                            if (this.countObjects(value) > settings.maxObjects) {\n                                throw new Error(\"JSON exceeds object count limit (\" + settings.maxObjects + \").\");\n                            }\n                        }\n                        instance = this.readJsonToInstance(value, {\n                            objectType: type,\n                            typeHintPropertyKey: settings.typeHintPropertyKey,\n                            enableTypeHints: settings.enableTypeHints,\n                            strictTypeHintMode: true,\n                            knownTypes: metadata ? metadata.knownTypes : {}\n                        });\n                        return instance;\n                    };\n                    Deserializer.countObjects = function (value) {\n                        var _this = this;\n                        switch (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) {\n                            case \"object\":\n                                if (value === null) {\n                                    return 0;\n                                } else if (Helpers.isArray(value)) {\n                                    var count_1 = 0;\n                                    value.forEach(function (item) {\n                                        count_1 += _this.countObjects(item);\n                                    });\n                                    return count_1;\n                                } else {\n                                    var count_2 = 0;\n                                    Object.keys(value).forEach(function (propertyKey) {\n                                        count_2 += _this.countObjects(value[propertyKey]);\n                                    });\n                                    return count_2;\n                                }\n                            case \"undefined\":\n                                return 0;\n                            default:\n                                return 1;\n                        }\n                    };\n                    Deserializer.readJsonToInstance = function (json, settings) {\n                        var _this = this;\n                        var object;\n                        var objectMetadata;\n                        var ObjectType;\n                        var typeHint;\n                        var temp;\n                        var knownTypes;\n                        if (typeof json === \"undefined\" || json === null) {\n                            if (settings.isRequired) {\n                                throw new Error(\"Missing required member.\");\n                            }\n                        } else if (Helpers.isPrimitive(settings.objectType)) {\n                            if (json.constructor !== settings.objectType) {\n                                var expectedTypeName = Helpers.getClassName(settings.objectType).toLowerCase();\n                                var foundTypeName = Helpers.getClassName(json.constructor).toLowerCase();\n                                throw new TypeError(\"Expected value to be of type '\" + expectedTypeName + \"', got '\" + foundTypeName + \"'.\");\n                            }\n                            object = json;\n                        } else if (settings.objectType === Array) {\n                            if (!Helpers.isArray(json)) {\n                                throw new TypeError(\"Expected value to be of type 'Array', got '\" + Helpers.getClassName(json.constructor) + \"'.\");\n                            }\n                            object = [];\n                            json.forEach(function (element) {\n                                object.push(_this.readJsonToInstance(element, {\n                                    elements: settings.elements ? settings.elements.elements : null,\n                                    enableTypeHints: settings.enableTypeHints,\n                                    knownTypes: settings.knownTypes,\n                                    objectType: settings.elements ? settings.elements.type : element.constructor,\n                                    requireTypeHints: settings.requireTypeHints,\n                                    strictTypeHintMode: settings.strictTypeHintMode,\n                                    typeHintPropertyKey: settings.typeHintPropertyKey\n                                }));\n                            });\n                        } else if (settings.objectType === Date) {\n                            if (typeof json === \"string\") {\n                                object = new Date(json);\n                            } else if (json instanceof Date) {\n                                object = json;\n                            } else {\n                                throw new TypeError(\"Expected value to be of type 'string', got '\" + (typeof json === \"undefined\" ? \"undefined\" : _typeof(json)) + \"'.\");\n                            }\n                        } else {\n                            typeHint = json[settings.typeHintPropertyKey];\n                            if (typeHint && settings.enableTypeHints) {\n                                if (typeof typeHint !== \"string\") {\n                                    throw new TypeError(\"Type-hint (\" + settings.typeHintPropertyKey + \") must be a string.\");\n                                }\n                                if (!settings.knownTypes[typeHint]) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a known type.\");\n                                }\n                                if (settings.strictTypeHintMode && !Helpers.isSubtypeOf(settings.knownTypes[typeHint], settings.objectType)) {\n                                    throw new Error(\"'\" + typeHint + \"' is not a subtype of '\" + Helpers.getClassName(settings.objectType) + \"'.\");\n                                }\n                                ObjectType = settings.knownTypes[typeHint];\n                                objectMetadata = JsonObjectMetadata.getFromType(ObjectType);\n                            } else {\n                                if (settings.enableTypeHints && settings.requireTypeHints) {\n                                    throw new Error(\"Missing required type-hint.\");\n                                }\n                                ObjectType = settings.objectType;\n                                objectMetadata = JsonObjectMetadata.getFromType(settings.objectType);\n                            }\n                            if (objectMetadata) {\n                                if (typeof objectMetadata.initializer === \"function\") {\n                                    object = objectMetadata.initializer(json) || null;\n                                } else {\n                                    objectMetadata.sortMembers();\n                                    object = new ObjectType();\n                                    Object.keys(objectMetadata.dataMembers).forEach(function (propertyKey) {\n                                        var propertyMetadata = objectMetadata.dataMembers[propertyKey];\n                                        temp = _this.readJsonToInstance(json[propertyMetadata.name], {\n                                            elements: propertyMetadata.elements,\n                                            enableTypeHints: settings.enableTypeHints,\n                                            isRequired: propertyMetadata.isRequired,\n                                            knownTypes: Helpers.merge(settings.knownTypes, objectMetadata.knownTypes || {}),\n                                            objectType: propertyMetadata.type,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            strictTypeHintMode: settings.strictTypeHintMode,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                        if (Helpers.valueIsDefined(temp)) {\n                                            object[propertyKey] = temp;\n                                        }\n                                    });\n                                }\n                            } else {\n                                object = {};\n                                Object.keys(json).forEach(function (propertyKey) {\n                                    if (json[propertyKey] && propertyKey !== settings.typeHintPropertyKey) {\n                                        object[propertyKey] = _this.readJsonToInstance(json[propertyKey], {\n                                            enableTypeHints: settings.enableTypeHints,\n                                            knownTypes: settings.knownTypes,\n                                            objectType: json[propertyKey].constructor,\n                                            requireTypeHints: settings.requireTypeHints,\n                                            typeHintPropertyKey: settings.typeHintPropertyKey\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                        return object;\n                    };\n                    return Deserializer;\n                }();\n                var configSettings = {\n                    enableTypeHints: true,\n                    typeHintPropertyKey: \"__type\"\n                };\n                var TypedJSON = {\n                    config: function config(settings) {\n                        configSettings = Helpers.merge(configSettings, settings);\n                    },\n                    stringify: function stringify(value, settings) {\n                        return Serializer.writeObject(value, Helpers.merge(configSettings, settings || {}));\n                    },\n                    parse: function parse(json, type, settings) {\n                        if (JsonObjectMetadata.getFromType(type)) {\n                            return Deserializer.readObject(json, type, Helpers.merge(configSettings, settings || {}));\n                        } else {\n                            return JSON.parse.apply(JSON, arguments);\n                        }\n                    }\n                };\n                exports.TypedJSON = TypedJSON;\n            });\n        }, {}] }, {}, [7])(7);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGFyc2VyL2J1bmRsZS1wYXJzZXIuanM/N2M1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5wYXJzZXIgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxufSx7XCIuL2RlY29kZVwiOjIsXCIuL2VuY29kZVwiOjN9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG59LHtcIi4vdXRpbFwiOjYsXCJwdW55Y29kZVwiOjEsXCJxdWVyeXN0cmluZ1wiOjR9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdGhpbmdfZGVzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL3RoaW5nLWRlc2NyaXB0aW9uXCIpO1xyXG52YXIgVEQgPSByZXF1aXJlKFwiLi90aGluZy1kZXNjcmlwdGlvblwiKTtcclxudmFyIHR5cGVkanNvbl9ucG1fMSA9IHJlcXVpcmUoXCJ0eXBlZGpzb24tbnBtXCIpO1xyXG5mdW5jdGlvbiBwYXJzZVRET2JqZWN0KHRkKSB7XHJcbiAgICByZXR1cm4gcGFyc2VURFN0cmluZyh0eXBlZGpzb25fbnBtXzEuVHlwZWRKU09OLnN0cmluZ2lmeSh0ZCwgeyBlbmFibGVUeXBlSGludHM6IGZhbHNlIH0pKTtcclxufVxyXG5leHBvcnRzLnBhcnNlVERPYmplY3QgPSBwYXJzZVRET2JqZWN0O1xyXG5mdW5jdGlvbiBwYXJzZVREU3RyaW5nKGpzb24pIHtcclxuICAgIGNvbnNvbGUubG9nKFwicGFyc2VURFN0cmluZygpIHBhcnNpbmdcXG5gYGBcXG5cIiArIGpzb24gKyBcIlxcbmBgYFwiKTtcclxuICAgIHZhciB0ZCA9IHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04ucGFyc2UoanNvbiwgdGhpbmdfZGVzY3JpcHRpb25fMS5kZWZhdWx0KTtcclxuICAgIGNvbnNvbGUubG9nKFwicGFyc2VURFN0cmluZygpIGZvdW5kIFwiICsgdGQuaW50ZXJhY3Rpb24ubGVuZ3RoICsgXCIgSW50ZXJhY3Rpb25cIiArICh0ZC5pbnRlcmFjdGlvbi5sZW5ndGggPT09IDEgPyAnJyA6ICdzJykpO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRkLmludGVyYWN0aW9uOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9hW19pXTtcclxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24uc2VtYW50aWNUeXBlcy5pbmRleE9mKFRELkludGVyYWN0aW9uUGF0dGVybi5Qcm9wZXJ0eS50b1N0cmluZygpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgKiBQcm9wZXJ0eSAnXCIgKyBpbnRlcmFjdGlvbi5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5wYXR0ZXJuID0gVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLlByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnRlcmFjdGlvbi5zZW1hbnRpY1R5cGVzLmluZGV4T2YoVEQuSW50ZXJhY3Rpb25QYXR0ZXJuLkFjdGlvbi50b1N0cmluZygpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgKiBBY3Rpb24gJ1wiICsgaW50ZXJhY3Rpb24ubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24ucGF0dGVybiA9IFRELkludGVyYWN0aW9uUGF0dGVybi5BY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGludGVyYWN0aW9uLnNlbWFudGljVHlwZXMuaW5kZXhPZihURC5JbnRlcmFjdGlvblBhdHRlcm4uRXZlbnQudG9TdHJpbmcoKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiICogRXZlbnQgJ1wiICsgaW50ZXJhY3Rpb24ubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24ucGF0dGVybiA9IFRELkludGVyYWN0aW9uUGF0dGVybi5FdmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJwYXJzZVREU3RyaW5nKCkgZm91bmQgdW5rbm93biBJbnRlcmFjdGlvbiBwYXR0ZXJuICdcIiArIGludGVyYWN0aW9uLnNlbWFudGljVHlwZXMgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZC5iYXNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXJzZVREU3RyaW5nKCkgYXBwbHlpbmcgYmFzZSAnXCIgKyB0ZC5iYXNlICsgXCInIHRvIGhyZWYgJ1wiICsgaW50ZXJhY3Rpb24ubGlua1swXS5ocmVmICsgXCInXCIpO1xyXG4gICAgICAgICAgICB2YXIgaHJlZiA9IGludGVyYWN0aW9uLmxpbmtbMF0uaHJlZjtcclxuICAgICAgICAgICAgdmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRkLmJhc2UuaW5kZXhPZignOicpO1xyXG4gICAgICAgICAgICB2YXIgcHIgPSB0ZC5iYXNlLnN1YnN0cigwLCBuICsgMSk7XHJcbiAgICAgICAgICAgIHZhciB1cmlUZW1wID0gdGQuYmFzZS5yZXBsYWNlKHByLCAnaHR0cDonKTtcclxuICAgICAgICAgICAgdXJpVGVtcCA9IHVybC5yZXNvbHZlKHVyaVRlbXAsIGhyZWYpO1xyXG4gICAgICAgICAgICB1cmlUZW1wID0gdXJpVGVtcC5yZXBsYWNlKCdodHRwOicsIHByKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24ubGlua1swXS5ocmVmID0gdXJpVGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGQ7XHJcbn1cclxuZXhwb3J0cy5wYXJzZVREU3RyaW5nID0gcGFyc2VURFN0cmluZztcclxuZnVuY3Rpb24gc2VyaWFsaXplVEQodGQpIHtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04uY29uZmlnKHsgXCJlbmFibGVUeXBlSGludHNcIjogZmFsc2UgfSk7XHJcbiAgICB2YXIganNvbiA9IHR5cGVkanNvbl9ucG1fMS5UeXBlZEpTT04uc3RyaW5naWZ5KHRkKTtcclxuICAgIHZhciByYXcgPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgaWYgKHRkLmJhc2UgPT09IG51bGwgfHwgdGQuYmFzZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIHJhdy5iYXNlO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHJhdy5pbnRlcmFjdGlvbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLmlucHV0RGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb24uaW5wdXREYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24ub3V0cHV0RGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb24ub3V0cHV0RGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLndyaXRhYmxlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvbi53cml0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLm91dHB1dERhdGEgJiYgaW50ZXJhY3Rpb24ub3V0cHV0RGF0YS5yZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIEhPVEZJWCBmb3IgVHlwZWRKU09OICMjI1wiKTtcclxuICAgICAgICAgICAgdmFyIHJlcXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcmVxIGluIGludGVyYWN0aW9uLm91dHB1dERhdGEucmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICByZXFzLnB1c2goaW50ZXJhY3Rpb24ub3V0cHV0RGF0YS5yZXF1aXJlZFtyZXFdKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb24ub3V0cHV0RGF0YS5yZXF1aXJlZCA9IHJlcXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAganNvbiA9IEpTT04uc3RyaW5naWZ5KHJhdyk7XHJcbiAgICBjb25zb2xlLmxvZyhcInNlcmlhbGl6ZVREKCkgcHJvZHVjZWRcXG5gYGBcXG5cIiArIGpzb24gKyBcIlxcbmBgYFwiKTtcclxuICAgIHJldHVybiBqc29uO1xyXG59XHJcbmV4cG9ydHMuc2VyaWFsaXplVEQgPSBzZXJpYWxpemVURDtcclxuXG59LHtcIi4vdGhpbmctZGVzY3JpcHRpb25cIjo4LFwidHlwZWRqc29uLW5wbVwiOjksXCJ1cmxcIjo1fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHlwZWRqc29uX25wbV8xID0gcmVxdWlyZShcInR5cGVkanNvbi1ucG1cIik7XHJcbnZhciBJbnRlcmFjdGlvblBhdHRlcm47XHJcbihmdW5jdGlvbiAoSW50ZXJhY3Rpb25QYXR0ZXJuKSB7XHJcbiAgICBJbnRlcmFjdGlvblBhdHRlcm5bSW50ZXJhY3Rpb25QYXR0ZXJuW1wiUHJvcGVydHlcIl0gPSAnUHJvcGVydHknXSA9IFwiUHJvcGVydHlcIjtcclxuICAgIEludGVyYWN0aW9uUGF0dGVybltJbnRlcmFjdGlvblBhdHRlcm5bXCJBY3Rpb25cIl0gPSAnQWN0aW9uJ10gPSBcIkFjdGlvblwiO1xyXG4gICAgSW50ZXJhY3Rpb25QYXR0ZXJuW0ludGVyYWN0aW9uUGF0dGVybltcIkV2ZW50XCJdID0gJ0V2ZW50J10gPSBcIkV2ZW50XCI7XHJcbn0pKEludGVyYWN0aW9uUGF0dGVybiA9IGV4cG9ydHMuSW50ZXJhY3Rpb25QYXR0ZXJuIHx8IChleHBvcnRzLkludGVyYWN0aW9uUGF0dGVybiA9IHt9KSk7XHJcbnZhciBJbnRlcmFjdGlvbkxpbmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb25MaW5rKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEludGVyYWN0aW9uTGluaztcclxufSgpKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IGlzUmVxdWlyZWQ6IHRydWUsIHR5cGU6IFN0cmluZyB9KVxyXG5dLCBJbnRlcmFjdGlvbkxpbmsucHJvdG90eXBlLCBcImhyZWZcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IGlzUmVxdWlyZWQ6IHRydWUsIHR5cGU6IFN0cmluZyB9KVxyXG5dLCBJbnRlcmFjdGlvbkxpbmsucHJvdG90eXBlLCBcIm1lZGlhVHlwZVwiLCB2b2lkIDApO1xyXG5JbnRlcmFjdGlvbkxpbmsgPSBfX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uT2JqZWN0KClcclxuXSwgSW50ZXJhY3Rpb25MaW5rKTtcclxuZXhwb3J0cy5JbnRlcmFjdGlvbkxpbmsgPSBJbnRlcmFjdGlvbkxpbms7XHJcbnZhciBJbnRlcmFjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNlbWFudGljVHlwZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmxpbmsgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBJbnRlcmFjdGlvbjtcclxufSgpKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IG5hbWU6ICdAdHlwZScsIGlzUmVxdWlyZWQ6IHRydWUsIGVsZW1lbnRzOiBTdHJpbmcgfSlcclxuXSwgSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcInNlbWFudGljVHlwZXNcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IGlzUmVxdWlyZWQ6IHRydWUsIHR5cGU6IFN0cmluZyB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgZWxlbWVudHM6IEludGVyYWN0aW9uTGluayB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwibGlua1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgdHlwZTogQm9vbGVhbiB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwid3JpdGFibGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IHR5cGU6IE9iamVjdCB9KVxyXG5dLCBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwiaW5wdXREYXRhXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyB0eXBlOiBPYmplY3QgfSlcclxuXSwgSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcIm91dHB1dERhdGFcIiwgdm9pZCAwKTtcclxuSW50ZXJhY3Rpb24gPSBfX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uT2JqZWN0KHsga25vd25UeXBlczogW0ludGVyYWN0aW9uTGlua10gfSlcclxuXSwgSW50ZXJhY3Rpb24pO1xyXG5leHBvcnRzLkludGVyYWN0aW9uID0gSW50ZXJhY3Rpb247XHJcbnZhciBUaGluZ0Rlc2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRoaW5nRGVzY3JpcHRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gWydodHRwOi8vdzNjLmdpdGh1Yi5pby93b3QvdzNjLXdvdC10ZC1jb250ZXh0Lmpzb25sZCddO1xyXG4gICAgICAgIHRoaXMuc2VtYW50aWNUeXBlID0gWydUaGluZyddO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBUaGluZ0Rlc2NyaXB0aW9uO1xyXG59KCkpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgbmFtZTogJ0B0eXBlJywgZWxlbWVudHM6IFN0cmluZyB9KVxyXG5dLCBUaGluZ0Rlc2NyaXB0aW9uLnByb3RvdHlwZSwgXCJzZW1hbnRpY1R5cGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB0eXBlZGpzb25fbnBtXzEuSnNvbk1lbWJlcih7IGlzUmVxdWlyZWQ6IHRydWUsIHR5cGU6IFN0cmluZyB9KVxyXG5dLCBUaGluZ0Rlc2NyaXB0aW9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyB0eXBlOiBTdHJpbmcgfSlcclxuXSwgVGhpbmdEZXNjcmlwdGlvbi5wcm90b3R5cGUsIFwiYmFzZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHR5cGVkanNvbl9ucG1fMS5Kc29uTWVtYmVyKHsgaXNSZXF1aXJlZDogdHJ1ZSwgZWxlbWVudHM6IEludGVyYWN0aW9uIH0pXHJcbl0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcImludGVyYWN0aW9uXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25NZW1iZXIoeyBuYW1lOiAnQGNvbnRleHQnLCBlbGVtZW50czogU3RyaW5nIH0pXHJcbl0sIFRoaW5nRGVzY3JpcHRpb24ucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcclxuVGhpbmdEZXNjcmlwdGlvbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgdHlwZWRqc29uX25wbV8xLkpzb25PYmplY3QoeyBrbm93blR5cGVzOiBbSW50ZXJhY3Rpb25dIH0pXHJcbl0sIFRoaW5nRGVzY3JpcHRpb24pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaGluZ0Rlc2NyaXB0aW9uO1xyXG5cbn0se1widHlwZWRqc29uLW5wbVwiOjl9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuVHlwZWRKU09OIHYwLjIuMCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Kb2huV2hpdGVUQi9UeXBlZEpTT05cblxuVHlwZWQgSlNPTiBwYXJzaW5nIGFuZCBzZXJpYWxpemluZyB0aGF0IHByZXNlcnZlcyB0eXBlIGluZm9ybWF0aW9uLiBQYXJzZSBKU09OIGludG8gYWN0dWFsIGNsYXNzIGluc3RhbmNlcy4gUmVjb21tZW5kZWQgKGJ1dCBub3QgcmVxdWlyZWQpXG50byBiZSB1c2VkIHdpdGggcmVmbGVjdC1tZXRhZGF0YSAoZ2xvYmFsIGluc3RhbGxhdGlvbik6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYnVja3Rvbi9SZWZsZWN0RGVjb3JhdG9ycy5cblxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcbkNvcHlyaWdodCAoYykgMjAxNiBKb2huIFdoaXRlXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7IGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgTUVUQURBVEFfRklFTERfS0VZID0gXCJfX3R5cGVkSnNvbkpzb25PYmplY3RNZXRhZGF0YUluZm9ybWF0aW9uX19cIjtcbiAgICB2YXIgSlNPTjtcbiAgICBpZiAoIUpTT04pIHtcbiAgICAgICAgSlNPTiA9IHtcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoc0pTT04pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJudmFsID0gc0pTT047XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXR1cm52YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZhbCgnKCcgKyBzSlNPTiArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmluZ2lmeTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsgfTtcbiAgICAgICAgICAgICAgICB2YXIgZXNjTWFwID0geyAnXCInOiAnXFxcXFwiJywgJ1xcXFwnOiAnXFxcXFxcXFwnLCAnXFxiJzogJ1xcXFxiJywgJ1xcZic6ICdcXFxcZicsICdcXG4nOiAnXFxcXG4nLCAnXFxyJzogJ1xcXFxyJywgJ1xcdCc6ICdcXFxcdCcgfTtcbiAgICAgICAgICAgICAgICB2YXIgZXNjRnVuYyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBlc2NNYXBbbV0gfHwgJ1xcXFx1JyArIChtLmNoYXJDb2RlQXQoMCkgKyAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpOyB9O1xuICAgICAgICAgICAgICAgIHZhciBlc2NSRSA9IC9bXFxcXFwiXFx1MDAwMC1cXHUwMDFGXFx1MjAyOFxcdTIwMjldL2c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6ICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9ICdbJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gKGkgPyAnLCAnIDogJycpICsgc3RyaW5naWZ5KHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goc3RyaW5naWZ5KGspICsgJzogJyArIHN0cmluZ2lmeSh2YWx1ZVtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3snICsgdG1wLmpvaW4oJywgJykgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoZXNjUkUsIGVzY0Z1bmMpICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgSGVscGVycztcbiAgICAoZnVuY3Rpb24gKEhlbHBlcnMpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuYXNzaWduID0gYXNzaWduO1xuICAgICAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgW21lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbXCJFUlJPUjogXCIgKyBtZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIGZ1bmN0aW9uIGdldENsYXNzTmFtZSh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRhcmdldFR5cGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwibmFtZVwiIGluIHRhcmdldFR5cGUgJiYgdHlwZW9mIHRhcmdldFR5cGUubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRUeXBlLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0VHlwZS50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoXFx3KikvKVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmdldENsYXNzTmFtZSA9IGdldENsYXNzTmFtZTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHR5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMuZ2V0RGVmYXVsdFZhbHVlID0gZ2V0RGVmYXVsdFZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eURpc3BsYXlOYW1lKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDbGFzc05hbWUodGFyZ2V0KSArIFwiLlwiICsgcHJvcGVydHlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmdldFByb3BlcnR5RGlzcGxheU5hbWUgPSBnZXRQcm9wZXJ0eURpc3BsYXlOYW1lO1xuICAgICAgICBmdW5jdGlvbiBpc0FycmF5KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgICAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9iaiA9PT0gU3RyaW5nIHx8XG4gICAgICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTnVtYmVyIHx8IG9iaiA9PT0gTnVtYmVyIHx8XG4gICAgICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgQm9vbGVhbiB8fCBvYmogPT09IEJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRNZW1iZXJOYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gTUVUQURBVEFfRklFTERfS0VZKTtcbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmlzUmVzZXJ2ZWRNZW1iZXJOYW1lID0gaXNSZXNlcnZlZE1lbWJlck5hbWU7XG4gICAgICAgIGZ1bmN0aW9uIGlzU3VidHlwZU9mKEEsIEIpIHtcbiAgICAgICAgICAgIHZhciBhUHJvdG90eXBlID0gQS5wcm90b3R5cGU7XG4gICAgICAgICAgICBpZiAoQSA9PT0gQikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGFQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVByb3RvdHlwZSBpbnN0YW5jZW9mIEIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFQcm90b3R5cGUgPSBhUHJvdG90eXBlLnByb3RvdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLmlzU3VidHlwZU9mID0gaXNTdWJ0eXBlT2Y7XG4gICAgICAgIGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSGVscGVycy5sb2cgPSBsb2c7XG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAobmV4dEtleSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHRhcmdldFtuZXh0S2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgSGVscGVycy5tZXJnZSA9IG1lcmdlO1xuICAgICAgICBmdW5jdGlvbiB2YWx1ZUlzRGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlbHBlcnMudmFsdWVJc0RlZmluZWQgPSB2YWx1ZUlzRGVmaW5lZDtcbiAgICAgICAgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIFttZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgW1wiV0FSTklORzogXCIgKyBtZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWxwZXJzLndhcm4gPSB3YXJuO1xuICAgIH0pKEhlbHBlcnMgfHwgKEhlbHBlcnMgPSB7fSkpO1xuICAgIHZhciBKc29uTWVtYmVyTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKc29uTWVtYmVyTWV0YWRhdGEoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpzb25NZW1iZXJNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIHZhciBKc29uT2JqZWN0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKc29uT2JqZWN0TWV0YWRhdGEoKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTWVtYmVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0bHlNYXJrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0SnNvbk9iamVjdE5hbWUgPSBmdW5jdGlvbiAodHlwZSwgaW5oZXJpdGVkKSB7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkID09PSB2b2lkIDApIHsgaW5oZXJpdGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRGcm9tVHlwZSh0eXBlLCBpbmhlcml0ZWQpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXJzLmdldENsYXNzTmFtZSh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlID0gZnVuY3Rpb24gKHRhcmdldCwgaW5oZXJpdGVkKSB7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkID09PSB2b2lkIDApIHsgaW5oZXJpdGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIHRhcmdldFByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJvdG90eXBlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXRQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRQcm90b3R5cGUuaGFzT3duUHJvcGVydHkoTUVUQURBVEFfRklFTERfS0VZKSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gdGFyZ2V0UHJvdG90eXBlW01FVEFEQVRBX0ZJRUxEX0tFWV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmhlcml0ZWQgJiYgdGFyZ2V0UHJvdG90eXBlW01FVEFEQVRBX0ZJRUxEX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRhcmdldFByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmlzRXhwbGljaXRseU1hcmtlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0RnJvbUluc3RhbmNlID0gZnVuY3Rpb24gKHRhcmdldCwgaW5oZXJpdGVkKSB7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkID09PSB2b2lkIDApIHsgaW5oZXJpdGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVR5cGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCksIGluaGVyaXRlZCk7XG4gICAgICAgIH07XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5nZXRLbm93blR5cGVOYW1lRnJvbVR5cGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLmdldEZyb21UeXBlKHRhcmdldCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXJzLmdldENsYXNzTmFtZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0S25vd25UeXBlTmFtZUZyb21JbnN0YW5jZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuZ2V0RnJvbUluc3RhbmNlKHRhcmdldCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXJzLmdldENsYXNzTmFtZSh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZSwgXCJkYXRhTWVtYmVyc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YU1lbWJlcnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSGVscGVycy5nZXRDbGFzc05hbWUodGhpcy5jbGFzc1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uT2JqZWN0TWV0YWRhdGEucHJvdG90eXBlLCBcImtub3duVHlwZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtub3duVHlwZXM7XG4gICAgICAgICAgICAgICAgdmFyIGtub3duVHlwZU5hbWU7XG4gICAgICAgICAgICAgICAga25vd25UeXBlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2tub3duVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoa25vd25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtub3duVHlwZU5hbWUgPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0S25vd25UeXBlTmFtZUZyb21UeXBlKGtub3duVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGtub3duVHlwZXNba25vd25UeXBlTmFtZV0gPSBrbm93blR5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlQ2FjaGUgPSBrbm93blR5cGVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBrbm93blR5cGVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUuc2V0S25vd25UeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9rbm93blR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa25vd25UeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tub3duVHlwZUNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZS5hZGRNZW1iZXIgPSBmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZGF0YU1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9kYXRhTWVtYmVyc1twcm9wZXJ0eUtleV0ubmFtZSA9PT0gbWVtYmVyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBtZW1iZXIgd2l0aCB0aGUgbmFtZSAnXCIgKyBtZW1iZXIubmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0cy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTWVtYmVyc1ttZW1iZXIua2V5XSA9IG1lbWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgSnNvbk9iamVjdE1ldGFkYXRhLnByb3RvdHlwZS5zb3J0TWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbWVtYmVyQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2RhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgIG1lbWJlckFycmF5LnB1c2goX3RoaXMuX2RhdGFNZW1iZXJzW3Byb3BlcnR5S2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lbWJlckFycmF5ID0gbWVtYmVyQXJyYXkuc29ydCh0aGlzLnNvcnRNZW1iZXJzQ29tcGFyZSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTWVtYmVycyA9IHt9O1xuICAgICAgICAgICAgbWVtYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YU1lbWJlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kYXRhTWVtYmVyc1tkYXRhTWVtYmVyLmtleV0gPSBkYXRhTWVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEpzb25PYmplY3RNZXRhZGF0YS5wcm90b3R5cGUuc29ydE1lbWJlcnNDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYS5vcmRlciAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYi5vcmRlciAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLm5hbWUgPiBiLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGEub3JkZXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiLm9yZGVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGEub3JkZXIgPCBiLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYS5vcmRlciA+IGIub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5uYW1lIDwgYi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYS5uYW1lID4gYi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSnNvbk9iamVjdE1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gSnNvbk9iamVjdChvcHRpb25zT3JUYXJnZXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yVGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JUYXJnZXQgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gb3B0aW9ucy5pbml0aWFsaXplcjtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBvcHRpb25zLnNlcmlhbGl6ZXI7XG4gICAgICAgIHZhciBkZWNvcmF0b3IgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICB2YXIgcGFyZW50TWV0YWRhdGE7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShNRVRBREFUQV9GSUVMRF9LRVkpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSBuZXcgSnNvbk9iamVjdE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE1ldGFkYXRhID0gdGFyZ2V0LnByb3RvdHlwZVtNRVRBREFUQV9GSUVMRF9LRVldKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGFkYXRhLmRhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJQcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldID0gcGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50TWV0YWRhdGEua25vd25UeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5zZXRLbm93blR5cGUocGFyZW50TWV0YWRhdGEua25vd25UeXBlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQucHJvdG90eXBlLCBNRVRBREFUQV9GSUVMRF9LRVksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iamVjdE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YSA9IHRhcmdldC5wcm90b3R5cGVbTUVUQURBVEFfRklFTERfS0VZXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLmNsYXNzVHlwZSA9IHRhcmdldDtcbiAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLmlzRXhwbGljaXRseU1hcmtlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuY2xhc3NOYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMua25vd25UeXBlcykge1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua25vd25UeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChrbm93blR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga25vd25UeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIktub3duIHR5cGUgI1wiICsgaSsrICsgXCIgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNldEtub3duVHlwZShrbm93blR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy5lcnJvcihuZXcgVHlwZUVycm9yKFwiQEpzb25PYmplY3Q6IFwiICsgZS5tZXNzYWdlICsgXCIgKG9uICdcIiArIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHRhcmdldCkgKyBcIicpXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxpemVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplciA9IGluaXRpYWxpemVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPclRhcmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yKG9wdGlvbnNPclRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuSnNvbk9iamVjdCA9IEpzb25PYmplY3Q7XG4gICAgZnVuY3Rpb24ganNvbk1lbWJlclR5cGVJbml0KG1ldGFkYXRhLCBwcm9wZXJ0eU5hbWUsIHdhcm5BcnJheSkge1xuICAgICAgICBpZiAod2FybkFycmF5ID09PSB2b2lkIDApIHsgd2FybkFycmF5ID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhLmVsZW1lbnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5lbGVtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0YWRhdGEuZWxlbWVudHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudHlwZSA9IEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS50eXBlID09PSBBcnJheSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YS5lbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh3YXJuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgSGVscGVycy53YXJuKFwiTm8gdmFsaWQgJ2VsZW1lbnRzJyBvcHRpb24gd2FzIHNwZWNpZmllZCBmb3IgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkICdlbGVtZW50cycgb3B0aW9uIHdhcyBzcGVjaWZpZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAganNvbk1lbWJlclR5cGVJbml0KG1ldGFkYXRhLmVsZW1lbnRzLCBwcm9wZXJ0eU5hbWUgKyAnW10nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgJ3R5cGUnIG9wdGlvbiB3YXMgc3BlY2lmaWVkIGZvciAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzb25NZW1iZXJLbm93blR5cGVzKG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBrbm93blR5cGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGtub3duVHlwZXMucHVzaChtZXRhZGF0YS50eXBlKTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBrbm93blR5cGVzID0ga25vd25UeXBlcy5jb25jYXQoanNvbk1lbWJlcktub3duVHlwZXMobWV0YWRhdGEuZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga25vd25UeXBlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gSnNvbk1lbWJlcihvcHRpb25zT3JUYXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIHZhciBtZW1iZXJNZXRhZGF0YSA9IG5ldyBKc29uTWVtYmVyTWV0YWRhdGEoKTtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIHZhciBkZWNvcmF0b3I7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlLZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHByb3BlcnR5S2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yVGFyZ2V0IHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBvYmplY3RNZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRNZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciByZWZsZWN0VHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBIZWxwZXJzLmdldFByb3BlcnR5RGlzcGxheU5hbWUodGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBKc29uTWVtYmVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgc3RhdGljIHByb3BlcnR5ICgnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W3Byb3BlcnR5S2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBKc29uTWVtYmVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbWV0aG9kIHByb3BlcnR5ICgnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiZWxlbWVudFR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBIZWxwZXJzLndhcm4ocHJvcGVydHlOYW1lICsgXCI6IHRoZSAnZWxlbWVudFR5cGUnIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgJ2VsZW1lbnRzJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVsZW1lbnRzID0gb3B0aW9ucy5lbGVtZW50VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbGVtZW50VHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEuZm9yY2VFbmFibGVUeXBlSGludGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEgPSBIZWxwZXJzLmFzc2lnbihtZW1iZXJNZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBtZW1iZXJNZXRhZGF0YS5rZXkgPSBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgbWVtYmVyTWV0YWRhdGEubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBwcm9wZXJ0eUtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKEhlbHBlcnMuaXNSZXNlcnZlZE1lbWJlck5hbWUobWVtYmVyTWV0YWRhdGEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASnNvbk1lbWJlcjogJ1wiICsgbWVtYmVyTWV0YWRhdGEubmFtZSArIFwiJyBpcyBhIHJlc2VydmVkIG5hbWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpICYmIHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEpzb25NZW1iZXI6ICd0eXBlJyBvZiAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5nZXRNZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdFR5cGUgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWZsZWN0VHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEpzb25NZW1iZXI6IHR5cGUgZGV0ZWN0ZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1lbWJlck1ldGFkYXRhLnR5cGUgfHwgdHlwZW9mIG1lbWJlck1ldGFkYXRhLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJNZXRhZGF0YS50eXBlID0gcmVmbGVjdFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlck1ldGFkYXRhLnR5cGUgIT09IHJlZmxlY3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIEhlbHBlcnMud2FybihcIkBKc29uTWVtYmVyOiAndHlwZScgc3BlY2lmaWVkIGZvciAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgZG9lcyBub3QgbWF0Y2ggZGV0ZWN0ZWQgdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAganNvbk1lbWJlclR5cGVJbml0KG1lbWJlck1ldGFkYXRhLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQURBVEFfRklFTERfS0VZKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gbmV3IEpzb25PYmplY3RNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNZXRhZGF0YSA9IHRhcmdldFtNRVRBREFUQV9GSUVMRF9LRVldKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGFkYXRhLmRhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJQcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldID0gcGFyZW50TWV0YWRhdGEuZGF0YU1lbWJlcnNbbWVtYmVyUHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQURBVEFfRklFTERfS0VZLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmplY3RNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEgPSB0YXJnZXRbTUVUQURBVEFfRklFTERfS0VZXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25NZW1iZXJLbm93blR5cGVzKG1lbWJlck1ldGFkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrbm93blR5cGUpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5zZXRLbm93blR5cGUoa25vd25UeXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YS5hZGRNZW1iZXIobWVtYmVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZW1iZXIgJ1wiICsgbWVtYmVyTWV0YWRhdGEubmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0cyBvbiAnXCIgKyBIZWxwZXJzLmdldENsYXNzTmFtZShvYmplY3RNZXRhZGF0YS5jbGFzc1R5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcHJvcGVydHlLZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3Iob3B0aW9uc09yVGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuSnNvbk1lbWJlciA9IEpzb25NZW1iZXI7XG4gICAgdmFyIFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZXJpYWxpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFNlcmlhbGl6ZXIud3JpdGVPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21JbnN0YW5jZShvYmplY3QpO1xuICAgICAgICAgICAgdmFyIE9iamVjdFR5cGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gb2JqZWN0TWV0YWRhdGEuY2xhc3NUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0VHlwZSA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLndyaXRlVG9Kc29uT2JqZWN0KG9iamVjdCwge1xuICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IE9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgfSksIHNldHRpbmdzLnJlcGxhY2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VyaWFsaXplci53cml0ZVRvSnNvbk9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGpzb247XG4gICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1pdERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IEhlbHBlcnMuZ2V0RGVmYXVsdFZhbHVlKHNldHRpbmdzLm9iamVjdFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChIZWxwZXJzLmlzUHJpbWl0aXZlKG9iamVjdCkgfHwgb2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBvYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAganNvbi5wdXNoKHRoaXMud3JpdGVUb0pzb25PYmplY3Qob2JqZWN0W2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogc2V0dGluZ3MuZWxlbWVudHMgPyBzZXR0aW5ncy5lbGVtZW50cy5lbGVtZW50cyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IHNldHRpbmdzLmVsZW1lbnRzID8gc2V0dGluZ3MuZWxlbWVudHMudHlwZSA6IE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RNZXRhZGF0YSA9IEpzb25PYmplY3RNZXRhZGF0YS5nZXRGcm9tSW5zdGFuY2Uob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEgJiYgdHlwZW9mIG9iamVjdE1ldGFkYXRhLnNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gb2JqZWN0TWV0YWRhdGEuc2VyaWFsaXplcihvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzICYmIChzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzIHx8IG9iamVjdC5jb25zdHJ1Y3RvciAhPT0gc2V0dGluZ3Mub2JqZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleV0gPSBKc29uT2JqZWN0TWV0YWRhdGEuZ2V0S25vd25UeXBlTmFtZUZyb21JbnN0YW5jZShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc29ydE1lbWJlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdE1ldGFkYXRhLmRhdGFNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gb2JqZWN0TWV0YWRhdGEuZGF0YU1lbWJlcnNbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bcHJvcGVydHlNZXRhZGF0YS5uYW1lXSA9IF90aGlzLndyaXRlVG9Kc29uT2JqZWN0KG9iamVjdFtwcm9wZXJ0eUtleV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHByb3BlcnR5TWV0YWRhdGEuZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXREZWZhdWx0OiBwcm9wZXJ0eU1ldGFkYXRhLmVtaXREZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eU1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IHByb3BlcnR5TWV0YWRhdGEudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVR5cGVIaW50czogc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltwcm9wZXJ0eUtleV0gPSBfdGhpcy53cml0ZVRvSnNvbk9iamVjdChvYmplY3RbcHJvcGVydHlLZXldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVR5cGVIaW50czogc2V0dGluZ3MuZW5hYmxlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVUeXBlSGludHM6IHNldHRpbmdzLnJlcXVpcmVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVIaW50UHJvcGVydHlLZXk6IHNldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZXJpYWxpemVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERlc2VyaWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlc2VyaWFsaXplcigpIHtcbiAgICAgICAgfVxuICAgICAgICBEZXNlcmlhbGl6ZXIucmVhZE9iamVjdCA9IGZ1bmN0aW9uIChqc29uLCB0eXBlLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZShqc29uLCBzZXR0aW5ncy5yZXZpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubWF4T2JqZWN0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50T2JqZWN0cyh2YWx1ZSkgPiBzZXR0aW5ncy5tYXhPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04gZXhjZWVkcyBvYmplY3QgY291bnQgbGltaXQgKFwiICsgc2V0dGluZ3MubWF4T2JqZWN0cyArIFwiKS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLnJlYWRKc29uVG9JbnN0YW5jZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleSxcbiAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlSGludE1vZGU6IHRydWUsXG4gICAgICAgICAgICAgICAga25vd25UeXBlczogbWV0YWRhdGEgPyBtZXRhZGF0YS5rbm93blR5cGVzIDoge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICBEZXNlcmlhbGl6ZXIuY291bnRPYmplY3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoSGVscGVycy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50XzEgKz0gX3RoaXMuY291bnRPYmplY3RzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudF8yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50XzIgKz0gX3RoaXMuY291bnRPYmplY3RzKHZhbHVlW3Byb3BlcnR5S2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF8yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVzZXJpYWxpemVyLnJlYWRKc29uVG9JbnN0YW5jZSA9IGZ1bmN0aW9uIChqc29uLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgb2JqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICB2YXIgT2JqZWN0VHlwZTtcbiAgICAgICAgICAgIHZhciB0eXBlSGludDtcbiAgICAgICAgICAgIHZhciB0ZW1wO1xuICAgICAgICAgICAgdmFyIGtub3duVHlwZXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09IFwidW5kZWZpbmVkXCIgfHwganNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pc1JlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgbWVtYmVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChIZWxwZXJzLmlzUHJpbWl0aXZlKHNldHRpbmdzLm9iamVjdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uY29uc3RydWN0b3IgIT09IHNldHRpbmdzLm9iamVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZU5hbWUgPSBIZWxwZXJzLmdldENsYXNzTmFtZShzZXR0aW5ncy5vYmplY3RUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRUeXBlTmFtZSA9IEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKGpzb24uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlICdcIiArIGV4cGVjdGVkVHlwZU5hbWUgKyBcIicsIGdvdCAnXCIgKyBmb3VuZFR5cGVOYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLm9iamVjdFR5cGUgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFIZWxwZXJzLmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJ0FycmF5JywgZ290ICdcIiArIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKGpzb24uY29uc3RydWN0b3IpICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICAgICAganNvbi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wdXNoKF90aGlzLnJlYWRKc29uVG9JbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogc2V0dGluZ3MuZWxlbWVudHMgPyBzZXR0aW5ncy5lbGVtZW50cy5lbGVtZW50cyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVUeXBlSGludHM6IHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtub3duVHlwZXM6IHNldHRpbmdzLmtub3duVHlwZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOiBzZXR0aW5ncy5lbGVtZW50cyA/IHNldHRpbmdzLmVsZW1lbnRzLnR5cGUgOiBlbGVtZW50LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVR5cGVIaW50czogc2V0dGluZ3MucmVxdWlyZVR5cGVIaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdFR5cGVIaW50TW9kZTogc2V0dGluZ3Muc3RyaWN0VHlwZUhpbnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5vYmplY3RUeXBlID09PSBEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBEYXRlKGpzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqc29uIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBqc29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGdvdCAnXCIgKyB0eXBlb2YganNvbiArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZUhpbnQgPSBqc29uW3NldHRpbmdzLnR5cGVIaW50UHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlSGludCAmJiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlSGludCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGUtaGludCAoXCIgKyBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5ICsgXCIpIG11c3QgYmUgYSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mua25vd25UeXBlc1t0eXBlSGludF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIHR5cGVIaW50ICsgXCInIGlzIG5vdCBhIGtub3duIHR5cGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdHJpY3RUeXBlSGludE1vZGUgJiYgIUhlbHBlcnMuaXNTdWJ0eXBlT2Yoc2V0dGluZ3Mua25vd25UeXBlc1t0eXBlSGludF0sIHNldHRpbmdzLm9iamVjdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyB0eXBlSGludCArIFwiJyBpcyBub3QgYSBzdWJ0eXBlIG9mICdcIiArIEhlbHBlcnMuZ2V0Q2xhc3NOYW1lKHNldHRpbmdzLm9iamVjdFR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlID0gc2V0dGluZ3Mua25vd25UeXBlc1t0eXBlSGludF07XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlKE9iamVjdFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZVR5cGVIaW50cyAmJiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHR5cGUtaGludC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZSA9IHNldHRpbmdzLm9iamVjdFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE1ldGFkYXRhID0gSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlKHNldHRpbmdzLm9iamVjdFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3RNZXRhZGF0YS5pbml0aWFsaXplcihqc29uKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TWV0YWRhdGEuc29ydE1lbWJlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBPYmplY3RUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvYmplY3RNZXRhZGF0YS5kYXRhTWVtYmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNZXRhZGF0YSA9IG9iamVjdE1ldGFkYXRhLmRhdGFNZW1iZXJzW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gX3RoaXMucmVhZEpzb25Ub0luc3RhbmNlKGpzb25bcHJvcGVydHlNZXRhZGF0YS5uYW1lXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogcHJvcGVydHlNZXRhZGF0YS5lbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQ6IHByb3BlcnR5TWV0YWRhdGEuaXNSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga25vd25UeXBlczogSGVscGVycy5tZXJnZShzZXR0aW5ncy5rbm93blR5cGVzLCBvYmplY3RNZXRhZGF0YS5rbm93blR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogcHJvcGVydHlNZXRhZGF0YS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RUeXBlSGludE1vZGU6IHNldHRpbmdzLnN0cmljdFR5cGVIaW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXJzLnZhbHVlSXNEZWZpbmVkKHRlbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uW3Byb3BlcnR5S2V5XSAmJiBwcm9wZXJ0eUtleSAhPT0gc2V0dGluZ3MudHlwZUhpbnRQcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eUtleV0gPSBfdGhpcy5yZWFkSnNvblRvSW5zdGFuY2UoanNvbltwcm9wZXJ0eUtleV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlVHlwZUhpbnRzOiBzZXR0aW5ncy5lbmFibGVUeXBlSGludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtub3duVHlwZXM6IHNldHRpbmdzLmtub3duVHlwZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6IGpzb25bcHJvcGVydHlLZXldLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlVHlwZUhpbnRzOiBzZXR0aW5ncy5yZXF1aXJlVHlwZUhpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSGludFByb3BlcnR5S2V5OiBzZXR0aW5ncy50eXBlSGludFByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZXNlcmlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgY29uZmlnU2V0dGluZ3MgPSB7XG4gICAgICAgIGVuYWJsZVR5cGVIaW50czogdHJ1ZSxcbiAgICAgICAgdHlwZUhpbnRQcm9wZXJ0eUtleTogXCJfX3R5cGVcIlxuICAgIH07XG4gICAgdmFyIFR5cGVkSlNPTiA9IHtcbiAgICAgICAgY29uZmlnOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGNvbmZpZ1NldHRpbmdzID0gSGVscGVycy5tZXJnZShjb25maWdTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemVyLndyaXRlT2JqZWN0KHZhbHVlLCBIZWxwZXJzLm1lcmdlKGNvbmZpZ1NldHRpbmdzLCBzZXR0aW5ncyB8fCB7fSkpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGpzb24sIHR5cGUsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoSnNvbk9iamVjdE1ldGFkYXRhLmdldEZyb21UeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlc2VyaWFsaXplci5yZWFkT2JqZWN0KGpzb24sIHR5cGUsIEhlbHBlcnMubWVyZ2UoY29uZmlnU2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZS5hcHBseShKU09OLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLlR5cGVkSlNPTiA9IFR5cGVkSlNPTjtcbn0pO1xuXG59LHt9XX0se30sWzddKSg3KVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBhcnNlci9idW5kbGUtcGFyc2VyLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFIQTtBQUNBO0FBSUE7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFiQTtBQUNBO0FBY0E7QUFDQTtBQWhCQTtBQUFBO0FBa0JBO0FBbEJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUE1QkE7QUFBQTtBQUNBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFmQTtBQUFBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBbkNBO0FBQ0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQ0E7QUFpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFFQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n");

/***/ })

/******/ });