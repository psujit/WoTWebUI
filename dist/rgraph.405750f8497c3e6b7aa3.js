webpackJsonp([1],Array(161).concat([function(module,exports,__webpack_require__){eval("__webpack_require__(162);\n__webpack_require__(163);\n__webpack_require__(164);\n__webpack_require__(165);\n__webpack_require__(166);\n__webpack_require__(167);\n__webpack_require__(168);\n__webpack_require__(169);\n__webpack_require__(170);\n__webpack_require__(171);\n__webpack_require__(172);\n__webpack_require__(173);\n__webpack_require__(174);\n__webpack_require__(175);\n__webpack_require__(176);\n__webpack_require__(177);\n__webpack_require__(178);\n__webpack_require__(179);\n__webpack_require__(180);\n__webpack_require__(181);\n__webpack_require__(182);\n__webpack_require__(183);\n__webpack_require__(184);\n__webpack_require__(185);\n__webpack_require__(186);\n__webpack_require__(187);\n__webpack_require__(188);\n__webpack_require__(189);\n__webpack_require__(190);\n__webpack_require__(191);\n__webpack_require__(192);\n__webpack_require__(193);\n__webpack_require__(194);\n__webpack_require__(195);\n__webpack_require__(196);\n__webpack_require__(197);\n__webpack_require__(198);\n__webpack_require__(199);\n__webpack_require__(200);\n__webpack_require__(201);\n__webpack_require__(202);\n__webpack_require__(203);\n__webpack_require__(204);\n__webpack_require__(205);\n__webpack_require__(206);\n__webpack_require__(207);\n__webpack_require__(208);\n__webpack_require__(209);\n__webpack_require__(210);\n__webpack_require__(211);\n__webpack_require__(212);\n__webpack_require__(213);\n__webpack_require__(214);\n__webpack_require__(215);\n__webpack_require__(216);\n__webpack_require__(217);\n__webpack_require__(218);\n__webpack_require__(219);\n__webpack_require__(220);\n__webpack_require__(221);\nmodule.exports = __webpack_require__(222);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi ./other_components/rgraph/libraries/RGraph.bar.js ./other_components/rgraph/libraries/RGraph.bipolar.js ./other_components/rgraph/libraries/RGraph.common.annotate.js ./other_components/rgraph/libraries/RGraph.common.context.js ./other_components/rgraph/libraries/RGraph.common.core.js ./other_components/rgraph/libraries/RGraph.common.csv.js ./other_components/rgraph/libraries/RGraph.common.deprecated.js ./other_components/rgraph/libraries/RGraph.common.dynamic.js ./other_components/rgraph/libraries/RGraph.common.effects.js ./other_components/rgraph/libraries/RGraph.common.key.js ./other_components/rgraph/libraries/RGraph.common.resizing.js ./other_components/rgraph/libraries/RGraph.common.sheets.js ./other_components/rgraph/libraries/RGraph.common.tooltips.js ./other_components/rgraph/libraries/RGraph.common.zoom.js ./other_components/rgraph/libraries/RGraph.cornergauge.js ./other_components/rgraph/libraries/RGraph.drawing.background.js ./other_components/rgraph/libraries/RGraph.drawing.circle.js ./other_components/rgraph/libraries/RGraph.drawing.image.js ./other_components/rgraph/libraries/RGraph.drawing.marker1.js ./other_components/rgraph/libraries/RGraph.drawing.marker2.js ./other_components/rgraph/libraries/RGraph.drawing.marker3.js ./other_components/rgraph/libraries/RGraph.drawing.poly.js ./other_components/rgraph/libraries/RGraph.drawing.rect.js ./other_components/rgraph/libraries/RGraph.drawing.text.js ./other_components/rgraph/libraries/RGraph.drawing.xaxis.js ./other_components/rgraph/libraries/RGraph.drawing.yaxis.js ./other_components/rgraph/libraries/RGraph.fuel.js ./other_components/rgraph/libraries/RGraph.funnel.js ./other_components/rgraph/libraries/RGraph.gantt.js ./other_components/rgraph/libraries/RGraph.gauge.js ./other_components/rgraph/libraries/RGraph.hbar.js ./other_components/rgraph/libraries/RGraph.hprogress.js ./other_components/rgraph/libraries/RGraph.line.js ./other_components/rgraph/libraries/RGraph.meter.js ./other_components/rgraph/libraries/RGraph.modaldialog.js ./other_components/rgraph/libraries/RGraph.odo.js ./other_components/rgraph/libraries/RGraph.pie.js ./other_components/rgraph/libraries/RGraph.radar.js ./other_components/rgraph/libraries/RGraph.rose.js ./other_components/rgraph/libraries/RGraph.rscatter.js ./other_components/rgraph/libraries/RGraph.scatter.js ./other_components/rgraph/libraries/RGraph.semicircularprogress.js ./other_components/rgraph/libraries/RGraph.svg.bar.js ./other_components/rgraph/libraries/RGraph.svg.common.ajax.js ./other_components/rgraph/libraries/RGraph.svg.common.core.js ./other_components/rgraph/libraries/RGraph.svg.common.csv.js ./other_components/rgraph/libraries/RGraph.svg.common.fx.js ./other_components/rgraph/libraries/RGraph.svg.common.key.js ./other_components/rgraph/libraries/RGraph.svg.common.sheets.js ./other_components/rgraph/libraries/RGraph.svg.common.tooltips.js ./other_components/rgraph/libraries/RGraph.svg.hbar.js ./other_components/rgraph/libraries/RGraph.svg.line.js ./other_components/rgraph/libraries/RGraph.svg.pie.js ./other_components/rgraph/libraries/RGraph.svg.radar.js ./other_components/rgraph/libraries/RGraph.svg.rose.js ./other_components/rgraph/libraries/RGraph.svg.scatter.js ./other_components/rgraph/libraries/RGraph.svg.semicircularprogress.js ./other_components/rgraph/libraries/RGraph.svg.waterfall.js ./other_components/rgraph/libraries/RGraph.thermometer.js ./other_components/rgraph/libraries/RGraph.vprogress.js ./other_components/rgraph/libraries/RGraph.waterfall.js\n// module id = 161\n// module chunks = 1\n\n//# sourceURL=webpack:///multi_./other_components/rgraph/libraries/RGraph.bar.js_./other_components/rgraph/libraries/RGraph.bipolar.js_./other_components/rgraph/libraries/RGraph.common.annotate.js_./other_components/rgraph/libraries/RGraph.common.context.js_./other_components/rgraph/libraries/RGraph.common.core.js_./other_components/rgraph/libraries/RGraph.common.csv.js_./other_components/rgraph/libraries/RGraph.common.deprecated.js_./other_components/rgraph/libraries/RGraph.common.dynamic.js_./other_components/rgraph/libraries/RGraph.common.effects.js_./other_components/rgraph/libraries/RGraph.common.key.js_./other_components/rgraph/libraries/RGraph.common.resizing.js_./other_components/rgraph/libraries/RGraph.common.sheets.js_./other_components/rgraph/libraries/RGraph.common.tooltips.js_./other_components/rgraph/libraries/RGraph.common.zoom.js_./other_components/rgraph/libraries/RGraph.cornergauge.js_./other_components/rgraph/libraries/RGraph.drawing.background.js_./other_components/rgraph/libraries/RGraph.drawing.circle.js_./other_components/rgraph/libraries/RGraph.drawing.image.js_./other_components/rgraph/libraries/RGraph.drawing.marker1.js_./other_components/rgraph/libraries/RGraph.drawing.marker2.js_./other_components/rgraph/libraries/RGraph.drawing.marker3.js_./other_components/rgraph/libraries/RGraph.drawing.poly.js_./other_components/rgraph/libraries/RGraph.drawing.rect.js_./other_components/rgraph/libraries/RGraph.drawing.text.js_./other_components/rgraph/libraries/RGraph.drawing.xaxis.js_./other_components/rgraph/libraries/RGraph.drawing.yaxis.js_./other_components/rgraph/libraries/RGraph.fuel.js_./other_components/rgraph/libraries/RGraph.funnel.js_./other_components/rgraph/libraries/RGraph.gantt.js_./other_components/rgraph/libraries/RGraph.gauge.js_./other_components/rgraph/libraries/RGraph.hbar.js_./other_components/rgraph/libraries/RGraph.hprogress.js_./other_components/rgraph/libraries/RGraph.line.js_./other_components/rgraph/libraries/RGraph.meter.js_./other_components/rgraph/libraries/RGraph.modaldialog.js_./other_components/rgraph/libraries/RGraph.odo.js_./other_components/rgraph/libraries/RGraph.pie.js_./other_components/rgraph/libraries/RGraph.radar.js_./other_components/rgraph/libraries/RGraph.rose.js_./other_components/rgraph/libraries/RGraph.rscatter.js_./other_components/rgraph/libraries/RGraph.scatter.js_./other_components/rgraph/libraries/RGraph.semicircularprogress.js_./other_components/rgraph/libraries/RGraph.svg.bar.js_./other_components/rgraph/libraries/RGraph.svg.common.ajax.js_./other_components/rgraph/libraries/RGraph.svg.common.core.js_./other_components/rgraph/libraries/RGraph.svg.common.csv.js_./other_components/rgraph/libraries/RGraph.svg.common.fx.js_./other_components/rgraph/libraries/RGraph.svg.common.key.js_./other_components/rgraph/libraries/RGraph.svg.common.sheets.js_./other_components/rgraph/libraries/RGraph.svg.common.tooltips.js_./other_components/rgraph/libraries/RGraph.svg.hbar.js_./other_components/rgraph/libraries/RGraph.svg.line.js_./other_components/rgraph/libraries/RGraph.svg.pie.js_./other_components/rgraph/libraries/RGraph.svg.radar.js_./other_components/rgraph/libraries/RGraph.svg.rose.js_./other_components/rgraph/libraries/RGraph.svg.scatter.js_./other_components/rgraph/libraries/RGraph.svg.semicircularprogress.js_./other_components/rgraph/libraries/RGraph.svg.waterfall.js_./other_components/rgraph/libraries/RGraph.thermometer.js_./other_components/rgraph/libraries/RGraph.vprogress.js_./other_components/rgraph/libraries/RGraph.waterfall.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bar';this.max = 0;this.stackedOrGrouped = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.cachedBackgroundCanvas = null;this.firstDraw = true;this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.background.hbars': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.hmargin.grouped': 1, 'chart.strokecolor': 'rgba(0,0,0,0)', 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.size': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'rgba(0,0,0,0)', 'chart.labels.above.angle': null, 'chart.labels.above.offset': 4, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['red', '#0f0', 'blue', 'pink', 'orange', 'cyan', 'black', 'white', 'green', 'magenta'], 'chart.colors.sequential': false, 'chart.colors.reverse': false, 'chart.grouping': 'grouped', 'chart.variant': 'bar', 'chart.variant.sketch.verticals': true, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot.xonly': false, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.halign': 'right', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.text.size': 10, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.linewidth': 1, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.adjustable.only': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.numxticks': null, 'chart.bevel': false, 'chart.errorbars': false, 'chart.errorbars.color': 'black', 'chart.errorbars.capped': true, 'chart.errorbars.capped.width': 14, 'chart.errorbars.linewidth': 1, 'chart.combinedchart.effect': null, 'chart.combinedchart.effect.options': null, 'chart.combinedchart.effect.callback': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[BAR] No canvas support');return;\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (typeof data[i] === 'string') {\n      data[i] = parseFloat(data[i]);\n    } else if (_typeof(data[i]) === 'object' && data[i]) {\n      for (var j = 0; j < data[i].length; ++j) {\n        if (typeof data[i][j] === 'string') {\n          data[i][j] = parseFloat(data[i][j]);\n        }\n      }\n    } else if (typeof data[i] === 'undefined') {\n      data[i] = null;\n    }\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (_typeof(data[i]) === 'object' && !RGraph.is_null(data[i])) {\n      this.stackedOrGrouped = true;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  this.data = data;this.original_data = RGraph.arrayClone(data);this.coords = [];this.coords2 = [];this.coordsText = [];this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.xlabels.offset') {\n      name = 'chart.labels.offsety';\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    if (name == 'chart.strokestyle') {\n      name = 'chart.strokecolor';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n      if (value == 'top') {\n        for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] == 'number' && this.data[i] > 0) {\n            alert('[BAR] The data element with index ' + i + ' should be negative');\n          }\n        }\n      }\n    }\n    if (name.toLowerCase() == 'chart.linewidth' && value == 0) {\n      value = 0.0001;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if ((prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot') && _typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips'] && prop['chart.tooltips'].length > 0) {\n      alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');\n    }\n    this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;RG.background.Draw(this);this.drawbars();this.drawAxes();this.DrawLabels();if (prop['chart.bevel'] || prop['chart.bevelled']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.errorbars']) {\n      this.drawErrorbars();\n    }\n    if (prop['chart.labels.ingraph']) {\n      RG.DrawInGraphLabels(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    var xaxispos = prop['chart.xaxispos'];var yaxispos = prop['chart.yaxispos'];var isSketch = prop['chart.variant'] == 'sketch';co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (RG.ISSAFARI == -1) {\n      co.lineCap = 'square';\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (yaxispos == 'right') {\n        co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      }\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (xaxispos == 'center') {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - (isSketch ? 2 : 0)));\n      } else if (xaxispos == 'top') {\n        co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ma.round(this.getYCoord(0) - (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ma.round(this.getYCoord(0) + (isSketch ? 2 : 0)));\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && !isSketch) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;var xpos = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;if (this.properties['chart.numyticks'] > 0) {\n        for (y = this.gutterTop; xaxispos == 'center' ? y <= ca.height - this.gutterBottom : y < ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0); y += yTickGap) {\n          if (xaxispos == 'center' && y == this.gutterTop + this.grapharea / 2) {\n            continue;\n          }\n          if (xaxispos == 'top' && y == this.gutterTop) {\n            continue;\n          }\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(y));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(y));\n        }\n        if (xaxispos === 'bottom' && prop['chart.ymin'] !== 0) {\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(ca.height - prop['chart.gutter.bottom']));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(ca.height - prop['chart.gutter.bottom']));\n        }\n      }\n      if (prop['chart.noxaxis']) {\n        if (xaxispos == 'center') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));co.lineTo(xpos, Math.round(ca.height / 2));\n        } else if (xaxispos == 'top') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));co.lineTo(xpos, Math.round(this.gutterTop));\n        } else {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    if (prop['chart.noxaxis'] == false && !isSketch) {\n      if (typeof prop['chart.numxticks'] == 'number') {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      } else {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;\n      }\n      if (xaxispos == 'bottom') {\n        yStart = prop['chart.ymin'] < 0 ? this.getYCoord(0) - 3 : this.getYCoord(0);yEnd = this.getYCoord(0) + 3;\n      } else if (xaxispos == 'top') {\n        yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n      } else if (xaxispos == 'center') {\n        yStart = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + 3;yEnd = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - 3;\n      }\n      var noEndXTick = prop['chart.noendxtick'];for (x = this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0), len = ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0); x < len; x += xTickGap) {\n        if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < ca.width - this.gutterRight) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && !noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && x > this.gutterLeft && noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {\n        if (typeof prop['chart.numxticks'] == 'number' && prop['chart.numxticks'] > 0) {\n          co.moveTo(Math.round(this.gutterLeft), yStart);co.lineTo(Math.round(this.gutterLeft), yEnd);\n        }\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {\n      if (xaxispos == 'center') {\n        co.moveTo(ma.round(this.gutterLeft), ca.height / 2 - 3);co.lineTo(ma.round(this.gutterLeft), ca.height / 2 + 3);\n      } else {\n        co.moveTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom + 3);\n      }\n    }\n    co.stroke();\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokecolor'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0,\n        decimals = prop['chart.scale.decimals'];if (prop['chart.ymax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.ymax'], 'strict': prop['chart.scale.round'] ? false : true, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });\n    } else {\n      var errorbars = prop['chart.errorbars'];if (typeof errorbars === 'number') {\n        var value = errorbars;prop['chart.errorbars'] = [];for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] === 'number') {\n            prop['chart.errorbars'].push([value, null]);\n          } else if (_typeof(this.data[i]) === 'object' && !RG.isNull(this.data[i])) {\n            for (var j = 0; j < this.data[i].length; ++j) {\n              prop['chart.errorbars'].push([value, null]);\n            }\n          }\n        }\n        errorbars = prop['chart.errorbars'];\n      }\n      for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = prop['chart.grouping'] === 'grouped' ? Number(RG.arrayMax(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(this.data[i]);\n        }\n        this.max = ma.max(ma.abs(this.max), ma.abs(value) + Number(_typeof(prop['chart.errorbars']) === 'object' && _typeof(prop['chart.errorbars'][i]) === 'object' && !RG.isNull(prop['chart.errorbars'][i]) && typeof prop['chart.errorbars'][i][0] === 'number' ? prop['chart.errorbars'][i][0] : 0));\n      }\n      this.scale2 = RGraph.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.adjustable'] && !prop['chart.ymax']) {\n      this.Set('chart.ymax', this.scale2.max);\n    }\n    if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RGraph.DrawBars(this);\n    }\n    var variant = prop['chart.variant'];if (variant === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var xaxispos = prop['chart.xaxispos'],\n        width = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length,\n        orig_height = height,\n        hmargin = prop['chart.hmargin'],\n        shadow = prop['chart.shadow'],\n        shadowColor = prop['chart.shadow.color'],\n        shadowBlur = prop['chart.shadow.blur'],\n        shadowOffsetX = prop['chart.shadow.offsetx'],\n        shadowOffsetY = prop['chart.shadow.offsety'],\n        strokeStyle = prop['chart.strokecolor'],\n        colors = prop['chart.colors'],\n        sequentialColorIndex = 0;\n    var height;for (i = 0, len = this.data.length; i < len; i += 1) {\n      if (RG.arraySum(this.data[i]) < 0) {\n        var height = (RG.arraySum(this.data[i]) + this.scale2.min) / (this.scale2.max - this.scale2.min);\n      } else {\n        var height = (RG.arraySum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min);\n      }\n      height *= ma.abs(this.getYCoord(this.scale2.max) - this.getYCoord(this.scale2.min));var x = i * width + this.gutterLeft;var y = xaxispos == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - height : ca.height - height - this.gutterBottom;if (xaxispos == 'top') {\n        y = this.gutterTop + ma.abs(height);\n      }\n      if (height < 0) {\n        y += height;height = ma.abs(height);\n      }\n      if (shadow) {\n        co.shadowColor = shadowColor;co.shadowBlur = shadowBlur;co.shadowOffsetX = shadowOffsetX;co.shadowOffsetY = shadowOffsetY;\n      }\n      co.beginPath();if (typeof this.data[i] == 'number') {\n        if (xaxispos === 'bottom' && prop['chart.ymin'] < 0) {\n          if (this.data[i] >= 0) {\n            height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          } else {\n            y = this.getYCoord(0);height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          }\n        }\n        var barWidth = width - 2 * hmargin;if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        co.strokeStyle = strokeStyle;co.fillStyle = colors[0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = colors[i];\n        }\n        if (variant == 'sketch') {\n          co.lineCap = 'round';var sketchOffset = 3;co.beginPath();co.strokeStyle = colors[0];if (prop['chart.colors.sequential']) {\n            co.strokeStyle = colors[i];\n          }\n          co.moveTo(x + hmargin + 2, y + height - 2);co.lineTo(x + hmargin - 1, y - 4);co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));co.bezierCurveTo(x + (hmargin + width) * 0.33, y + 15 + (this.data[i] < 0 ? height - 10 : 0), x + (hmargin + width) * 0.66, y + 5 + (this.data[i] < 0 ? height - 10 : 0), x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0));co.moveTo(x + hmargin + width - 5, y - 5);co.lineTo(x + hmargin + width - 3, y + height - 3);if (prop['chart.variant.sketch.verticals']) {\n            for (var r = 0.2; r <= 0.8; r += 0.2) {\n              co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - r * width, y - 1);co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - r * width, y + height + (r == 0.2 ? 1 : -2));\n            }\n          }\n          co.stroke();\n        } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {\n          if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, barWidth, height]);\n          }\n          if (variant == 'glass') {\n            RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);\n          } else {\n            co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.fill();RG.NoShadow(this);co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.stroke();\n          }\n          if (variant == '3d') {\n            var prevStrokeStyle = co.strokeStyle;var prevFillStyle = co.fillStyle;if (this.data[i] >= 0) {\n              co.beginPath();co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.gutterTop + this.getYCoord(0) ? this.getYCoord(this.data[i]) - prop['chart.variant.threed.offsety'] : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.closePath();co.stroke();co.fill();if (this.data[i] > 0) {\n              co.beginPath();co.fillStyle = 'rgba(255,255,255,0.5)';co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.fillStyle = 'rgba(0,0,0,0.4)';co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.getYCoord(0) ? this.getYCoord(0) : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          } else if (variant == 'glass') {\n            var grad = co.createLinearGradient(x + hmargin, y, x + hmargin + barWidth / 2, y);grad.addColorStop(0, 'rgba(255,255,255,0.9)');grad.addColorStop(1, 'rgba(255,255,255,0.5)');co.beginPath();co.fillStyle = grad;co.fillRect(x + hmargin + 2, y + (this.data[i] > 0 ? 2 : 0), barWidth / 2 - 2, height - 2);co.fill();\n          }\n        } else if (variant == 'dot') {\n          co.beginPath();co.moveTo(x + width / 2, y);co.lineTo(x + width / 2, y + height);co.stroke();co.beginPath();co.fillStyle = this.properties['chart.colors'][i];co.arc(x + width / 2, y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[i];\n          }\n          co.stroke();co.fill();\n        } else {\n          alert('[BAR] Warning! Unknown chart.variant: ' + variant);\n        }\n        this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (this.scale2.min) {\n          alert(\"[ERROR] Stacked Bar charts with a Y min are not supported\");\n        }\n        var barWidth = width - 2 * hmargin;var redrawCoords = [];var startY = 0;var dataset = this.data[i];if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        for (j = 0; j < dataset.length; ++j) {\n          if (xaxispos == 'center') {\n            alert(\"[BAR] It's pointless having the X axis position at the center on a stacked bar chart.\");return;\n          }\n          if (this.data[i][j] < 0) {\n            alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');return;\n          }\n          co.strokeStyle = strokeStyle;\n          co.fillStyle = colors[j];if (prop['chart.colors.reverse']) {\n            co.fillStyle = colors[this.data[i].length - j - 1];\n          }\n          if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var height = dataset[j] / this.scale2.max * (ca.height - this.gutterTop - this.gutterBottom);if (xaxispos == 'center') {\n            height /= 2;\n          }\n          var totalHeight = RGraph.array_sum(dataset) / this.scale2.max * (ca.height - hmargin - this.gutterTop - this.gutterBottom);this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, width - 2 * hmargin, height + 1]);\n          }\n          if (height > 0) {\n            co.strokeRect(x + hmargin, y, width - 2 * hmargin, height);co.fillRect(x + hmargin, y, width - 2 * hmargin, height);\n          }\n          if (j == 0) {\n            var startY = y;var startX = x;\n          }\n          if (shadow) {\n            redrawCoords.push([x + hmargin, y, width - 2 * hmargin, height, co.fillStyle]);\n          }\n          if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;if (j == 0) {\n              co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();if (j == 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          y += height;\n        }\n        if (shadow) {\n          RGraph.NoShadow(this);for (k = 0; k < redrawCoords.length; ++k) {\n            co.strokeStyle = strokeStyle;co.fillStyle = redrawCoords[k][4];co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.stroke();co.fill();\n          }\n          redrawCoords = [];\n        }\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var redrawCoords = [];co.lineWidth = prop['chart.linewidth'];for (j = 0; j < this.data[i].length; ++j) {\n          co.strokeStyle = strokeStyle;co.fillStyle = colors[j];if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var individualBarWidth = (width - 2 * hmargin) / this.data[i].length;var height = (this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : -1 * this.scale2.min)) / (this.scale2.max - this.scale2.min) * (ca.height - this.gutterTop - this.gutterBottom);var groupedMargin = prop['chart.hmargin.grouped'];var startX = x + hmargin + j * individualBarWidth;if (individualBarWidth < 0) {\n            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n          }\n          if (xaxispos == 'center') {\n            height /= 2;\n          }\n          if (xaxispos == 'top') {\n            var startY = this.gutterTop;var height = Math.abs(height);\n          } else if (xaxispos == 'center') {\n            var startY = this.gutterTop + this.grapharea / 2 - height;\n          } else {\n            var startY = this.getYCoord(0);var height = ma.abs(ma.abs(this.getYCoord(this.data[i][j])) - this.getYCoord(0));if (this.data[i][j] >= 0) {\n              startY -= height;\n            }\n          }\n          co.strokeRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);co.fillRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);y += height;if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;var hmarginGrouped = prop['chart.hmargin.grouped'];if (this.data[i][j] >= 0) {\n              co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped - 1, startY);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 && startY + height - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped - 1, startY + height);co.closePath();co.fill();co.stroke();if (this.data[i][j] >= 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped, startY);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 && startY + height - 5 < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (height < 0) {\n            height = Math.abs(height);startY = startY - height;\n          }\n          this.coords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (prop['chart.shadow']) {\n            redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height, co.fillStyle]);\n          }\n        }\n        if (redrawCoords.length) {\n          RGraph.NoShadow(this);co.lineWidth = prop['chart.linewidth'];co.beginPath();for (var j = 0; j < redrawCoords.length; ++j) {\n            co.fillStyle = redrawCoords[j][4];co.strokeStyle = prop['chart.strokecolor'];co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);\n          }\n          co.fill();co.stroke();redrawCoords = [];\n        }\n      } else {\n        this.coords.push([]);\n      }\n      co.closePath();\n    }\n    if (prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right') {\n      RG.draw3DYAxis(this);\n    }\n    RGraph.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co;var text_angle = prop['chart.text.angle'],\n        text_size = prop['chart.text.size'],\n        labels = prop['chart.labels'];\n    if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'top') this.Drawlabels_top();if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();\n    }\n    if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) == 'object' && labels) {\n      var yOffset = Number(prop['chart.labels.offsety']),\n          xOffset = Number(prop['chart.labels.offsetx']),\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.text.angle'] != 0) {\n        var valign = 'center';var halign = 'right';var angle = 0 - prop['chart.text.angle'];\n      } else {\n        var valign = 'top';var halign = 'center';var angle = 0;\n      }\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;\n      var i = 0;var font = prop['chart.text.font'];for (x = this.gutterLeft + xTickGap / 2; x <= ca.width - this.gutterRight; x += xTickGap) {\n        RG.text2(this, _defineProperty({ 'font': font, 'size': text_size, 'x': x + xOffset, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + yOffset - 5 : ca.height - this.gutterBottom + yOffset + 3, 'bold': bold, 'text': String(labels[i++]), 'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign, 'halign': halign, 'tag': 'label', 'marker': false, 'angle': angle }, 'tag', 'labels'));\n      }\n    }\n    this.drawAboveLabels();\n  };this.drawlabels_top = this.Drawlabels_top = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.xaxispos'] == 'top') {\n      var context = co;var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea * (i / labels.length) + grapharea / labels.length;RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      var labels = this.scale2.labels;for (var i = 0; i < labels.length; ++i) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea / labels.length * (i + 1) + offsety, 'text': '-' + labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'text': (this.scale2.min != 0 ? '-' : '') + RGraph.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n    }\n    co.fill();\n  };this.drawlabels_center = this.Drawlabels_center = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];co.fillStyle = prop['chart.text.color'];if (prop['chart.xaxispos'] == 'center') {\n      var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var context = co;var align = '';var xpos = 0;var boxed = false;var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea / 2 / (labels.length - 1) * i;RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        for (var i = labels.length - 1; i >= 1; --i) {\n          var y = this.gutterTop + grapharea * (i / ((labels.length - 1) * 2)) + grapharea / 2;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[labels.length - i - 1]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        var y = this.gutterTop + this.halfgrapharea - this.halfgrapharea / numYLabels * (i + 1);var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      for (var i = this.scale2.labels.length - 1; i >= 0; --i) {\n        var y = this.gutterTop + this.halfgrapharea / numYLabels * (i + 1) + this.halfgrapharea;var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': '-' + text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {\n        var _RG$Text;\n\n        RG.Text2(this, (_RG$Text = { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.halfgrapharea + offsety, 'text': RG.number_format(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center' }, _defineProperty(_RG$Text, 'valign', 'center'), _defineProperty(_RG$Text, 'halign', align), _defineProperty(_RG$Text, 'bordered', boxed), _defineProperty(_RG$Text, 'tag', 'scale'), _RG$Text));\n      }\n    }\n  };this.drawlabels_bottom = this.Drawlabels_bottom = function () {\n    var text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        context = this.context,\n        align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left',\n        font = prop['chart.text.font'],\n        numYLabels = prop['chart.ylabels.count'],\n        ymin = prop['chart.ymin'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n    } else {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n    }\n    if (prop['chart.ylabels.specific'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n        var y = this.gutterTop + grapharea * (i / (labels.length - 1));RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      return;\n    }\n    var gutterTop = this.gutterTop;var halfTextHeight = this.halfTextHeight;var scale = this.scale;for (var i = 0; i < numYLabels; ++i) {\n      var text = this.scale2.labels[i];RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea - this.grapharea / numYLabels * (i + 1) + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n    }\n    if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n      RG.text2(this, { font: font, size: text_size, x: xpos + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), valign: 'center', halign: align, bordered: boxed, tag: 'scale' });\n    }\n    co.fill();\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };this.getShape = this.getBar = function (e) {\n    var obj = arguments[1] ? arguments[1] : this;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        canvas = obj.canvas,\n        context = obj.context,\n        coords = obj.coords;\n    for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var left = coords[i][0],\n          top = coords[i][1],\n          width = coords[i][2],\n          height = coords[i][3],\n          prop = obj.properties;\n      if (prop['chart.tooltips.hotspot.xonly']) {\n        pa2(co, 'b r % % % %', left, this.gutterTop, width, ca.height - this.gutterBottom);\n      } else {\n        pa2(co, 'b r % % % %', left, top, width, height);\n      }\n      if (co.isPointInPath(mouseX, mouseY)) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        var dataset = 0,\n            idx = i;\n        while (idx >= (_typeof(obj.data[dataset]) === 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {\n          if (typeof obj.data[dataset] === 'number') {\n            idx -= 1;\n          } else if (obj.data[dataset]) {\n            idx -= obj.data[dataset].length;\n          } else {\n            idx -= 1;\n          }\n          dataset++;\n        }\n        if (typeof obj.data[dataset] == 'number') {\n          idx = null;\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset };\n      }\n    }\n    return null;\n  };this.getShapeByX = function (e) {\n    var canvas = e.target;var mouseCoords = RGraph.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var left = obj.coords[i][0];var top = obj.coords[i][1];var width = obj.coords[i][2];var height = obj.coords[i][3];var prop = obj.properties;if (mouseX >= left && mouseX <= left + width) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < prop['chart.gutter.top'] || mouseY > ca.height - prop['chart.gutter.bottom'] || mouseX < prop['chart.gutter.left'] || mouseX > ca.width - prop['chart.gutter.right']) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value *= 2;if (value >= 0) {\n        value += this.scale2.min;\n      } else {\n        value -= this.scale2.min;\n      }\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value = this.scale2.max - value;value = ma.abs(value) * -1;\n    } else {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value += this.scale2.min;\n    }\n    return value;\n  };this.getYCoord = function (value) {\n    if (value > this.scale2.max) {\n      return null;\n    }\n    var co = this.context,\n        ca = this.canvas,\n        prop = this.properties;var y,\n        xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      if (value < 0) {\n        value = ma.abs(value);\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * this.grapharea;y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if (value < this.scale2.min) {\n        value = this.scale2.min;\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min);y *= ca.height - this.gutterTop - this.gutterBottom;y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= prop['chart.gutter.left'] && mouseXY[0] <= ca.width - prop['chart.gutter.right'] && mouseXY[1] >= prop['chart.gutter.top'] && mouseXY[1] <= ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');\n      if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.isNull(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.highlight.stroke'] = prop['chart.highlight.stroke'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.strokecolor'] = prop['chart.strokecolor'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.strokecolor'] = this.parseSingleColorForGradient(prop['chart.strokecolor']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RGraph.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    var coords = this.coords;var coords2 = this.coords2;var prop = this.properties;var co = this.context;var ca = this.canvas;if (prop['chart.grouping'] == 'stacked') {\n      for (var i = 0; i < coords2.length; ++i) {\n        if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {\n          var x = coords2[i][0][0];var y = coords2[i][0][1];var w = coords2[i][0][2];var arr = [];for (var j = 0; j < coords2[i].length; ++j) {\n            arr.push(coords2[i][j][3]);\n          }\n          var h = RGraph.array_sum(arr);co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 100);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    } else {\n      for (var i = 0; i < coords.length; ++i) {\n        if (coords[i]) {\n          var x = coords[i][0];var y = coords[i][1];var w = coords[i][2];var h = coords[i][3];var xaxispos = prop['chart.xaxispos'];var xaxis_ycoord = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;if (xaxispos == 'top' || xaxispos == 'center' && y + h > xaxis_ycoord) {\n            y = y - 100;h = h + 100;\n          } else {\n            y = y;h = h + 100;\n          }\n          co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 6);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    this.coords2.forEach(function (value, idx, arr) {\n      if (_typeof(value[index]) == 'object' && value[index]) {\n        var x = value[index][0];\n        var y = value[index][1];\n        var w = value[index][2];\n        var h = value[index][3];\n        co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.strokeRect(x, y, w, h);co.fillRect(x, y, w, h);\n      }\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawAboveLabels = function () {\n    var labels = prop['chart.labels.above'],\n        specific = prop['chart.labels.above.specific'],\n        color = prop['chart.labels.above.color'],\n        background = prop['chart.labels.above.background'],\n        decimals = prop['chart.labels.above.decimals'],\n        size = prop['chart.labels.above.size'],\n        angle = -1 * prop['chart.labels.above.angle'],\n        unitsPre = prop['chart.labels.above.units.pre'],\n        unitsPost = prop['chart.labels.above.units.post'],\n        coords = this.coords,\n        coords2 = this.coords2,\n        data = this.data,\n        ldata = RG.arrayLinearize(this.data),\n        offset = prop['chart.labels.above.offset'],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        grouping = prop['chart.grouping'];\n    RG.noShadow(this);co.fillStyle = typeof color === 'string' ? color : prop['chart.text.color'];if (labels && grouping === 'grouped') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (typeof data[i] === 'number' && data[i] >= 0) {\n          var angle = angle;var halign = angle ? 'left' : 'center';var valign = angle !== 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'marker': false, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'tag': 'labels.above' });sequentialIndex++;\n        } else if (typeof data[i] === 'number' && data[i] < 0) {\n          var angle = angle;var halign = angle ? 'right' : 'center';var valign = angle !== 0 ? 'center' : 'top';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + coords2[i][0][3] + offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        } else if (_typeof(data[i]) === 'object') {\n          for (var j = 0, len2 = data[i].length; j < len2; j += 1) {\n            var angle = angle;var halign = data[i][j] < 0 ? 'right' : 'left';halign = angle === 0 ? 'center' : halign;var valign = data[i][j] < 0 ? 'top' : 'bottom';valign = angle != 0 ? 'center' : valign;RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][j][0] + coords2[i][j][2] / 2, 'y': coords2[i][j][1] + (data[i][j] < 0 ? coords2[i][j][3] + offset : -offset), 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i][j]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n          }\n        }\n      }\n    } else if (labels && grouping === 'stacked') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (_typeof(data[i]) === 'object') {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(RG.arraySum(data[i])).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex += data[i].length;\n        } else {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        }\n      }\n    }\n  };this.firstDrawFunc = function () {};this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        labelsAbove = this.get('labelsAbove');opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(this.original_data);this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('ymax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.colorWave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [], colors = obj.properties['chart.colors'];if (colors.length <= obj.data.length) {\n      obj.set('chart.colors.sequential', true);colors = RG.arrayPad(colors, obj.data.length, colors[colors.length - 1]);\n    }\n    var framesperbar = opt.frames / 2,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        originalColors = RG.arrayClone(obj.properties['chart.colors']);for (var i = 0, len = originalColors.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (originalColors.length - 1) * i;opt.counters[i] = 0;\n    }\n    function iterator() {\n      ++frame;for (var i = 0, len = colors.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i] && colors[i].match(/^rgba?\\(([0-9 ]+),([0-9 ]+),([0-9 ]+)(,([ 0-9.]+)?)\\)/)) {\n          colors[i] = 'rgba({1},{2},{3},{4})'.format(RegExp.$1, RegExp.$2, RegExp.$3, (frame - opt.startFrames[i]) / framesperbar);\n        } else {\n          colors[i] = colors[i].replace(/,[0-9. ]+\\)/, ',0)');\n        }\n      }\n      if (frame >= opt.frames) {\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    if (RG.isArray(opt.data)) {\n      var ymax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            ymax = ma.max(ymax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseInt(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseInt(RegExp.$2);\n          }\n          ymax = ma.max(ymax, opt.data[i]);\n        } else {\n          ymax = ma.max(ymax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    this.set('labelsAbove', false);if (prop['chart.ymax'] == null) {\n      var ymax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          ymax = ma.max(ymax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          ymax = ma.max(ymax, ma.abs(RG.arrayMax(group)));\n        } else {\n          ymax = ma.max(ymax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    if (typeof opt.ymax === 'number') {\n      obj.set('ymax', opt.ymax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.drawErrorbars = function () {\n    var coords = this.coords,\n        color = prop['chart.errorbars.color'] || 'black',\n        default_halfwidth = ma.min(prop['chart.errorbars.capped.width'], coords[0][2]) / 2,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0;halfwidth = 0;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      }\n      var halfwidth = errorbars[i] && typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n        halfwidth = 0;\n      }\n      if (typeof errorbars[i] === 'number') {\n        length = ma.abs(this.getYCoord(errorbars[i]) - this.getYCoord(0));if (length) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - length, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - length), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - length), color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = ma.abs(this.getYCoord(errorbars[i][0]) - this.getYCoord(0));if (typeof errorbars[i][1] === 'string') {\n          color = errorbars[i][1];\n        } else if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n          halfwidth = 0;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - positiveLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] + negativeLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n      if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      }\n    }\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only']) || !RG.isArray(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};RGraph.CombinedChart = function () {\n  this.objects = [];var objects = [];if (RGraph.isArray(arguments[0])) {\n    objects = arguments[0];\n  } else {\n    for (var i = 0; i < arguments.length; i += 1) {\n      objects[i] = arguments[i];\n    }\n  }\n  for (var i = 0; i < objects.length; ++i) {\n    this.objects[i] = objects[i];this.objects[i].set({ gutterLeft: this.objects[0].get('gutter.left'), gutterRight: this.objects[0].get('gutter.right'), gutterTop: this.objects[0].get('gutter.top'), gutterBottom: this.objects[0].get('gutter.bottom') });if (this.objects[i].type == 'line') {\n      var obj = this.objects[i];obj.set('hmargin', (this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length / 2);obj.set('noaxes', true);obj.set('backgroundGrid', false);obj.set('ylabels', false);\n    }\n    if (this.objects[i].get('chart.resizable')) {\n      var resizable_object = obj;\n    }\n  }\n  if (resizable_object) {\n    var myOnresizebeforedraw = function myOnresizebeforedraw(obj) {\n      var gutterLeft = obj.get('gutterLeft');var gutterRight = obj.get('gutterRight');obj.set('hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));\n    };\n\n    RGraph.AddCustomEventListener(resizable_object, 'onresizebeforedraw', myOnresizebeforedraw);\n  }\n};RGraph.CombinedChart.prototype.add = RGraph.CombinedChart.prototype.Add = function (obj) {\n  this.objects.push(obj);\n};RGraph.CombinedChart.prototype.draw = RGraph.CombinedChart.prototype.Draw = function () {\n  for (var i = 0; i < this.objects.length; ++i) {\n    if (this.objects[i].properties['chart.combinedchart.effect']) {\n      var options = this.objects[i].properties['chart.combinedchart.effect.options'] ? eval('(' + this.objects[i].properties['chart.combinedchart.effect.options'] + ')') : null,\n          callback = this.objects[i].properties['chart.combinedchart.effect.callback'],\n          func = this.objects[i].properties['chart.combinedchart.effect'];this.objects[i][func](options, callback);\n    } else {\n      this.objects[i].draw();\n    }\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.bar.js\n// module id = 162\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.bar.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bipolar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.left) === 'object' && _typeof(conf.right) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        left = conf.left,\n        right = conf.right,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        left = arguments[1],\n        right = arguments[2];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bipolar';this.coords = [];this.coordsLeft = [];this.coordsRight = [];this.max = 0;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;for (var i = 0; i < left.length; ++i) {\n    left[i] = parseFloat(left[i]);\n  }for (var i = 0; i < right.length; ++i) {\n    right[i] = parseFloat(right[i]);\n  }this.left = left;this.right = right;this.data = [left, right];this.properties = { 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.linewidth': 1, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.autofit.numhlines': null, 'chart.margin': 2, 'chart.xtickinterval': null, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.above': false, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title.left': '', 'chart.title.right': '', 'chart.gutter.center': 60, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['#0f0'], 'chart.colors.sequential': false, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.units.pre': '', 'chart.units.post': '', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.xmax': null, 'chart.xmin': 0, 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.linewidth': 1, 'chart.noaxes': false, 'chart.xlabels': true, 'chart.numyticks': null, 'chart.numxticks': 5, 'chart.axis.linewidth': 1, 'chart.labels.count': 5, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.angle': 0.1, 'chart.clearto': 'rgba(0,0,0,0)' };\n  while (this.left.length < this.right.length) {\n    this.left.push(null);\n  }while (this.left.length > this.right.length) {\n    this.right.push(null);\n  }this.properties['chart.numyticks'] = this.left.length;var linear_data = RGraph.arrayLinearize(this.left, this.right);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return this.properties[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.gutterCenter = prop['chart.gutter.center'];this.left = this.data[0];this.right = this.data[1];this.coords = [];this.coordsText = [];if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;this.sequentialFullIndex = 0;this.getMax();this.drawBackgroundGrid();this.draw3DAxes();this.drawAxes();this.drawTicks();co.save();co.beginPath();co.rect(this.gutterLeft, this.gutterTop - (prop['chart.variant.threed.offsety'] || 0), ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom + 2 * (prop['chart.variant.threed.offsety'] || 0));co.clip();this.drawLeftBars();this.drawRightBars();this.drawLeftBars({ shadow: false });this.drawRightBars({ shadow: false });co.restore();this.drawAxes();this.drawLabels();this.drawTitles();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.draw3DAxes = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft, ma.round(ca.height - this.gutterBottom), this.gutterLeft + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + offsetx + this.axisWidth, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.axisWidth, ma.round(ca.height - this.gutterBottom));this.draw3DLeftVerticalAxis();pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ma.round(ca.height - this.gutterBottom), this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth, ma.round(ca.height - this.gutterBottom));pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom, this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom - this.axisHeight, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - this.axisHeight - offsety, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety);\n    }\n  };\n  this.draw3DLeftVerticalAxis = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.axisWidth, this.gutterTop, this.gutterLeft + this.axisWidth + offsetx, this.gutterTop - offsety, this.gutterLeft + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety, this.gutterLeft + this.axisWidth, ca.height - this.gutterBottom);\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;if (prop['chart.noaxes']) {\n      return;\n    }\n    co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft + this.axisWidth, Math.round(ca.height - this.gutterBottom));co.moveTo(ma.round(this.gutterLeft + this.axisWidth), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + this.axisWidth), this.gutterTop);co.stroke();co.beginPath();var x = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'];co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), ca.height - this.gutterBottom);co.moveTo(Math.round(x), Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.stroke();\n  };this.drawTicks = this.DrawTicks = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;var numDataPoints = this.left.length;var barHeight = (ca.height - this.gutterTop - this.gutterBottom - this.left.length * (prop['chart.margin'] * 2)) / numDataPoints;this.barHeight = barHeight;if (prop['chart.noaxes']) {\n      return;\n    }\n    if (prop['chart.numyticks'] > 0) {\n      co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth, y);co.lineTo(this.gutterLeft + this.axisWidth + 3, y);\n      }\n      co.stroke();co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'], y);co.lineTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] - 3, y);\n      }\n      co.stroke();\n    }\n    if (prop['chart.numxticks'] > 0) {\n      var xInterval = this.axisWidth / prop['chart.numxticks'];if (typeof prop['chart.xtickinterval'] == 'number') {\n        xInterval = prop['chart.xtickinterval'];\n      }\n      for (i = this.gutterLeft; i < this.gutterLeft + this.axisWidth; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n      var stoppingPoint = ca.width - this.gutterRight;for (i = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] + xInterval; i <= stoppingPoint; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n    }\n  };this.getMax = this.GetMax = function () {\n    var dec = prop['chart.scale.decimals'];if (prop['chart.xmax']) {\n      var max = prop['chart.xmax'];var min = prop['chart.xmin'];this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    } else {\n      var max = Math.max(RG.array_max(this.left), RG.array_max(this.right));this.scale2 = RG.getScale2(this, { 'max': max, 'min': prop['chart.xmin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n  };this.drawLeftBars = this.DrawLeftBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];for (var i = this.left.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.left[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth - width), ma.round(this.gutterTop + i * (this.axisHeight / this.left.length) + prop['chart.margin']), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.drawIEShadow(coords);\n      }\n      if (this.left[i] !== null) {\n        co.strokeRect(coords[0], coords[1], coords[2], coords[3]);co.fillRect(coords[0], coords[1], coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.left[i] !== null) {\n        if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        } else {\n          co.fillStyle = prop['chart.colors'][0];\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.4)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);\n      }\n      this.draw3DLeftVerticalAxis();this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsLeft.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.noShadow(this);co.lineWidth = 1;\n  };this.drawRightBars = this.DrawRightBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (var i = this.right.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.right[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth + prop['chart.gutter.center']), ma.round(prop['chart.margin'] + i * (this.axisHeight / this.right.length) + this.gutterTop), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.DrawIEShadow(coords);\n      }\n      if (this.right[i] !== null) {\n        co.strokeRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);co.fillRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.right[i] !== null) {\n        var color = co.fillStyle;if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1], color);pa2(co, 'b m % % l % % l % % l % % f %', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3], color);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.6)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(0,0,0,0.3)', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3]);\n      }\n      this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsRight.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.NoShadow(this);co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var font = prop['chart.text.font'],\n        color = prop['chart.labels.color'] || prop['chart.text.color'],\n        size = prop['chart.text.size'],\n        labels = prop['chart.labels'],\n        barAreaHeight = ca.height - this.gutterTop - this.gutterBottom;\n    co.fillStyle = color;for (var i = 0, len = labels.length; i < len; i += 1) {\n      RG.Text2(this, { 'color': color, 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] / 2, 'y': this.gutterTop + barAreaHeight / labels.length * i + barAreaHeight / labels.length / 2, 'text': String(labels[i] ? String(labels[i]) : ''), 'halign': 'center', 'valign': 'center', 'marker': false, 'tag': 'labels' });\n    }\n    co.fillStyle = prop['chart.text.color'];if (prop['chart.xlabels']) {\n      var grapharea = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea / this.scale2.labels.length * i, 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[this.scale2.labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea + prop['chart.gutter.center'] + grapharea / this.scale2.labels.length * (i + 1), 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (prop['chart.scale.zerostart']) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + this.gutterCenter, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n    if (prop['chart.labels.above']) {\n      var coordsLeft = RG.arrayReverse(this.coordsLeft);for (var i = 0; i < coordsLeft.length; ++i) {\n        if (typeof this.left[i] !== 'number') {\n          continue;\n        }\n        var coords = coordsLeft[i];RG.text2(this, { font: font, size: size, x: coords[0] - 5, y: coords[1] + coords[3] / 2, text: RG.numberFormat(this, this.left[i], prop['chart.units.pre'], prop['chart.units.post']), valign: 'center', halign: 'right', tag: 'labels.above' });\n      }\n      var coordsRight = RG.arrayReverse(this.coordsRight);for (i = 0; i < coordsRight.length; ++i) {\n        if (typeof this.right[i] != 'number') {\n          continue;\n        }\n        var coords = coordsRight[i];RG.Text2(this, { 'font': font, 'size': size, 'x': coords[0] + coords[2] + 5, 'y': coords[1] + coords[3] / 2, 'text': RG.number_format(this, this.right[i], prop['chart.units.pre'], prop['chart.units.post']), 'valign': 'center', 'halign': 'left', 'tag': 'labels.above' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.gutterLeft + 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.left']), 'halign': 'left', 'valign': 'bottom', 'tag': 'title.left' });RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': ca.width - this.gutterRight - 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.right']), 'halign': 'right', 'valign': 'bottom', 'tag': 'title.right' });RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : null);\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };\n  this.getShape = this.getBar = function (e) {\n    var canvas = this.canvas,\n        context = this.context,\n        mouseCoords = RG.getMouseXY(e);\n    for (var i = 0; i < this.coords.length; i++) {\n      var mouseX = mouseCoords[0],\n          mouseY = mouseCoords[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];\n      pa2(co, 'b r % % % %', left, top, width, height);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getValue = function (e) {\n    var obj = e.target.__object__;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];if (mouseX > this.gutterLeft && mouseX < ca.width / 2 - prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left']) / this.axisWidth;value = this.max - value * this.max;\n    }\n    if (mouseX < ca.width - this.gutterRight && mouseX > ca.width / 2 + prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left'] - this.axisWidth - prop['chart.gutter.center']) / this.axisWidth;value = value * this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (value > this.max || value < 0) {\n      return null;\n    }\n    var ret = [];var offset = value / this.max * this.axisWidth;ret[0] = this.gutterLeft + this.axisWidth - offset;ret[1] = ca.width - this.gutterRight - this.axisWidth + offset;return ret;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    props['chart.highlight.stroke'] = this.parseSingleColorForGradient(props['chart.highlight.stroke']);props['chart.highlight.fill'] = this.parseSingleColorForGradient(props['chart.highlight.fill']);props['chart.axis.color'] = this.parseSingleColorForGradient(props['chart.axis.color']);props['chart.strokestyle'] = this.parseSingleColorForGradient(props['chart.strokestyle']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawBackgroundGrid = function () {\n    if (prop['chart.background.grid']) {\n      var variant = prop['chart.variant'],\n          color = prop['chart.background.grid.color'],\n          numvlines = prop['chart.labels.count'],\n          numhlines = this.left.length,\n          vlines = prop['chart.background.grid.vlines'],\n          hlines = prop['chart.background.grid.hlines'],\n          linewidth = prop['chart.background.grid.linewidth'];if (typeof prop['chart.background.grid.autofit.numhlines'] === 'number') {\n        numhlines = prop['chart.background.grid.autofit.numhlines'];\n      }\n      if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {\n        numvlines = prop['chart.background.grid.autofit.numvlines'];\n      }\n      co.lineWidth = linewidth;if (variant == '3d') {\n        co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth + this.gutterCenter, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth + this.gutterCenter + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (variant == '3d') {\n        co.restore();\n      }\n    }\n  };this.firstDrawFunc = function () {\n    if (prop['chart.tooltips']) {\n      prop['chart.tooltips'] = RG.arrayReverse(prop['chart.tooltips']);\n    }\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  this.grow = function () {\n    var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var obj = this;var originalLeft = RG.arrayClone(this.left);var originalRight = RG.arrayClone(this.right);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < this.left.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.left[i]));\n      }\n      for (var i = 0; i < this.right.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.right[i]));\n      }\n      var scale = RG.getScale2(obj, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var i = 0; i < obj.left.length; i += 1) {\n        obj.left[i] = easingMultiplier * originalLeft[i];\n      }\n      for (var i = 0; i < obj.right.length; i += 1) {\n        obj.right[i] = easingMultiplier * originalRight[i];\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames_left = [];opt.startFrames_right = [];opt.counters_left = [];opt.counters_right = [];var framesperbar = opt.frames / 3,\n        frame_left = -1,\n        frame_right = -1,\n        callback = arguments[1] || function () {},\n        original_left = RG.arrayClone(obj.left),\n        original_right = RG.arrayClone(obj.right);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      opt.startFrames_left[i] = opt.frames / 2 / (obj.left.length - 1) * i;opt.startFrames_right[i] = opt.frames / 2 / (obj.right.length - 1) * i;opt.counters_left[i] = 0;opt.counters_right[i] = 0;\n    }\n    obj.draw();obj.set('xmax', obj.scale2.max);RG.clear(obj.canvas);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      if (typeof obj.left[i] === 'number') obj.left[i] = 0;if (typeof obj.right[i] === 'number') obj.right[i] = 0;\n    }\n    function iteratorLeft() {\n      ++frame_left;for (var i = 0, len = obj.left.length; i < len; i += 1) {\n        if (frame_left > opt.startFrames_left[i]) {\n          var isNull = RG.isNull(obj.left[i]);obj.left[i] = ma.min(ma.abs(original_left[i]), ma.abs(original_left[i] * (opt.counters_left[i]++ / framesperbar)));if (original_left[i] < 0) {\n            obj.left[i] *= -1;\n          }\n          if (isNull) {\n            obj.left[i] = null;\n          }\n        } else {\n          obj.left[i] = _typeof(obj.left[i]) === 'object' && obj.left[i] ? RG.arrayPad([], obj.left[i].length, 0) : RG.isNull(obj.left[i]) ? null : 0;\n        }\n      }\n      if (frame_left < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorLeft);\n      }\n    }\n    function iteratorRight() {\n      ++frame_right;for (var i = 0, len = obj.right.length; i < len; i += 1) {\n        if (frame_right > opt.startFrames_right[i]) {\n          var isNull = RG.isNull(obj.right[i]);obj.right[i] = ma.min(ma.abs(original_right[i]), ma.abs(original_right[i] * (opt.counters_right[i]++ / framesperbar)));if (original_right[i] < 0) {\n            obj.right[i] *= -1;\n          }\n          if (isNull) {\n            obj.right[i] = null;\n          }\n        } else {\n          obj.right[i] = _typeof(obj.right[i]) === 'object' && obj.right[i] ? RG.arrayPad([], obj.right[i].length, 0) : RG.isNull(obj.right[i]) ? null : 0;\n        }\n      }\n      if (frame_right < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorRight);\n      } else {\n        callback(this);\n      }\n    }\n    iteratorLeft();iteratorRight();return this;\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.bipolar.js\n// module id = 163\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.bipolar.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.annotating_canvas_onmousedown = function (e) {\n    if (e.button === 0) {\n      e.target.__object__.Set('chart.mousedown', true);var obj = e.target.__object__,\n          prop = obj.properties;\n      obj.context.beginPath();obj.context.strokeStyle = obj.Get('chart.annotate.color');obj.context.lineWidth = obj.Get('chart.annotate.linewidth');var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      RG.Registry.Set('annotate.actions', [obj.Get('chart.annotate.color')]);obj.context.moveTo(mouseX, mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.Registry.Set('started.annotating', false);RG.Registry.Set('chart.annotating', obj);RG.FireCustomEvent(obj, 'onannotatebegin');\n    }\n    return false;\n  };RG.annotating_window_onmouseup = function (e) {\n    var obj = RG.Registry.Get('chart.annotating');var win = window;if (e.button != 0 || !obj) {\n      return;\n    }\n    var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n      if (tags[i].__object__) {\n        tags[i].__object__.Set('chart.mousedown', false);\n      }\n    }\n    if (RG.Registry.Get('annotate.actions') && RG.Registry.Get('annotate.actions').length > 0 && win.localStorage) {\n      var id = '__rgraph_annotations_' + e.target.id + '__';var annotations = win.localStorage[id] ? win.localStorage[id] + '|' : '';annotations += RG.Registry.Get('annotate.actions');win.localStorage[id] = annotations;\n    }\n    RG.Registry.Set('annotate.actions', []);RG.FireCustomEvent(obj, 'onannotateend');\n  };RGraph.annotating_canvas_onmousemove = function (e) {\n    var obj = e.target.__object__;var prop = obj.properties;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var lastXY = RG.Registry.Get('annotate.last.coordinates');if (obj.Get('chart.mousedown')) {\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      obj.context.beginPath();if (!lastXY) {\n        obj.context.moveTo(mouseX, mouseY);\n      } else {\n        obj.context.strokeStyle = obj.properties['chart.annotate.color'];obj.context.moveTo(lastXY[0], lastXY[1]);obj.context.lineTo(mouseX, mouseY);\n      }\n      RG.Registry.Set('annotate.actions', RG.Registry.Get('annotate.actions') + '|' + mouseX + ',' + mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.FireCustomEvent(obj, 'onannotate');obj.context.stroke();\n    }\n  };RG.ShowPalette = RG.Showpalette = function (e) {\n    var isSafari = navigator.userAgent.indexOf('Safari') ? true : false;e = RG.FixEventObject(e);var canvas = e.target.parentNode.__canvas__,\n        context = canvas.getContext('2d'),\n        obj = canvas.__object__,\n        div = document.createElement('DIV'),\n        coords = RG.getMouseXY(e);\n    div.__object__ = obj;div.className = 'RGraph_palette';div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.left = 0;div.style.top = 0;div.style.padding = '3px';div.style.paddingLeft = '5px';div.style.opacity = 0;div.style.boxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.MozBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';var colors = ['Black', 'Red', 'Yellow', 'Green', 'Orange', 'White', 'Magenta', 'Pink'];for (var i = 0, len = colors.length; i < len; i += 1) {\n      var div2 = doc.createElement('DIV');div2.cssClass = 'RGraph_palette_color';div2.style.fontSize = '12pt';div2.style.cursor = 'pointer';div2.style.padding = '1px';div2.style.paddingRight = '10px';div2.style.textAlign = 'left';var span = document.createElement('SPAN');span.style.display = 'inline-block';span.style.marginRight = '9px';span.style.width = '17px';span.style.height = '17px';span.style.top = '2px';span.style.position = 'relative';span.style.backgroundColor = colors[i];div2.appendChild(span);div2.innerHTML += colors[i];div2.onmouseover = function () {\n        this.style.backgroundColor = '#eee';\n      };\n      div2.onmouseout = function () {\n        this.style.backgroundColor = '';\n      };\n      div2.onclick = function (e) {\n        var color = this.childNodes[0].style.backgroundColor;obj.Set('chart.annotate.color', color);\n      };\n      div.appendChild(div2);\n    }\n    doc.body.appendChild(div);div.style.left = e.pageX + 'px';div.style.top = e.pageY + 'px';if (e.pageX + (div.offsetWidth + 5) > document.body.offsetWidth) {\n      div.style.left = e.pageX - div.offsetWidth + 'px';\n    }\n    RGraph.Registry.Set('chart.palette', div);setTimeout(function () {\n      div.style.opacity = 0.2;\n    }, 50);setTimeout(function () {\n      div.style.opacity = 0.4;\n    }, 100);setTimeout(function () {\n      div.style.opacity = 0.6;\n    }, 150);setTimeout(function () {\n      div.style.opacity = 0.8;\n    }, 200);setTimeout(function () {\n      div.style.opacity = 1;\n    }, 250);RGraph.hideContext();window.onclick = function () {\n      RG.hidePalette();\n    };\n    e.stopPropagation();return false;\n  };RG.clearAnnotations = RG.ClearAnnotations = function (canvas) {\n    if (typeof canvas === 'string') {\n      var id = canvas;canvas = doc.getElementById(id);\n    } else {\n      var id = canvas.id;\n    }\n    var obj = canvas.__object__;if (win.localStorage && win.localStorage['__rgraph_annotations_' + id + '__'] && win.localStorage['__rgraph_annotations_' + id + '__'].length) {\n      win.localStorage['__rgraph_annotations_' + id + '__'] = [];RGraph.FireCustomEvent(obj, 'onannotateclear');\n    }\n  };RG.replayAnnotations = RG.ReplayAnnotations = function (obj) {\n    if (!win.localStorage) {\n      return;\n    }\n    var context = obj.context;var annotations = win.localStorage['__rgraph_annotations_' + obj.id + '__'];var i, len, move, coords;context.beginPath();context.lineWidth = obj.Get('annotate.linewidth');if (annotations && annotations.length) {\n      annotations = annotations.split('|');\n    } else {\n      return;\n    }\n    for (i = 0, len = annotations.length; i < len; ++i) {\n      if (annotations[i].match(/[a-z]+/)) {\n        context.stroke();context.beginPath();context.strokeStyle = annotations[i];move = true;continue;\n      }\n      coords = annotations[i].split(',');coords[0] = Number(coords[0]);coords[1] = Number(coords[1]);if (move) {\n        context.moveTo(coords[0], coords[1]);move = false;\n      } else {\n        context.lineTo(coords[0], coords[1]);\n      }\n    }\n    context.stroke();\n  };window.addEventListener('load', function (e) {\n    setTimeout(function () {\n      var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n        if (tags[i].__object__ && tags[i].__object__.isRGraph && tags[i].__object__.Get('chart.annotatable')) {\n          RG.replayAnnotations(tags[i].__object__);\n        }\n      }\n    }, 100);\n  }, false);\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.annotate.js\n// module id = 164\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.annotate.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.contextmenu = RG.Contextmenu = function (obj, menuitems, e) {\n    var canvas = obj.canvas;e = RG.FixEventObject(e);RG.FireCustomEvent(obj, 'onbeforecontextmenu');if (RG.Registry.Get('chart.contextmenu')) {\n      RG.HideContext();\n    }\n    RG.HideZoomedCanvas();RG.HidePalette();obj.Set('chart.mousedown', false);var x = e.pageX;var y = e.pageY;var div = document.createElement('div');var bg = document.createElement('div');div.className = 'RGraph_contextmenu';div.__canvas__ = canvas;div.style.position = 'absolute';div.style.left = 0;div.style.top = 0;div.style.border = '1px solid #666';div.style.backgroundColor = 'white';div.style.boxShadow = '1px 1px 3px #ddd';div.style.MozBoxShadow = '1px 1px 3px #ddd';div.style.WebkitBoxShadow = '1px 1px 3px #ddd';div.style.opacity = 0;bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg.style.opacity = 0;div = document.body.appendChild(div);bg = div.appendChild(bg);for (i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('div');menuitem.__object__ = obj;menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = div;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.textAlign = 'left';menuitem.style.fontWeight = 'normal';menuitem.innerHTML = menuitems[i][0];if (RG.is_array(menuitems[i][1])) {\n          menuitem.style.backgroundImage = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAQUlEQVQImY3NoQ2AMABE0ZewABMyGQ6mqWODzlAclBSFO8HZl8uf0FFxCHtwYkt4Y6ChYE44cGH9/fyae2p2LAleW9oVTQuVf6gAAAAASUVORK5CYII=)';menuitem.style.backgroundRepeat = 'no-repeat';menuitem.style.backgroundPosition = '97% center';\n        }\n        if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              RG.HideContextSubmenu();e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              RG.HideContextSubmenu();event.srcElement.style.backgroundColor = '#eee';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      div.appendChild(menuitem);if (menuitems[i] && menuitems[i][1] && typeof menuitems[i][1] == 'function') {\n        menuitem.addEventListener('click', menuitems[i][1], false);\n      } else if (menuitems[i] && menuitems[i][1] && RG.is_array(menuitems[i][1])) {\n        (function () {\n          var tmp = menuitems[i][1];menuitem.addEventListener('mouseover', function (e) {\n            RG.Contextmenu_submenu(obj, tmp, e.target);\n          }, false);\n        })();\n      }\n    }\n    div.style.width = div.offsetWidth + 10 + 'px';div.style.height = div.offsetHeight - 2 + 'px';if (x + div.offsetWidth > document.body.offsetWidth) {\n      x -= div.offsetWidth;\n    }\n    div.style.left = x + 'px';div.style.top = y + 'px';setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 1\", 250);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 1\", 250);RG.Registry.Set('chart.contextmenu', div);RG.Registry.Set('chart.contextmenu.bg', bg);RG.Registry.Get('chart.contextmenu').oncontextmenu = function () {\n      return false;\n    };RG.Registry.Get('chart.contextmenu.bg').oncontextmenu = function () {\n      return false;\n    };canvas.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('resize', function () {\n      RG.HideContext();\n    }, false);if (typeof obj.getShape == 'function') {\n      RG.Registry.Get('chart.contextmenu').__shape__ = obj.getShape(e);\n    }\n    e.stopPropagation();RG.FireCustomEvent(obj, 'oncontextmenu');return false;\n  };RG.hideContext = RG.HideContext = function () {\n    var cm = RG.Registry.Get('chart.contextmenu');var cmbg = RG.Registry.Get('chart.contextmenu.bg');RG.HideContextSubmenu();if (cm) {\n      cm.parentNode.removeChild(cm);cmbg.parentNode.removeChild(cmbg);cm.style.visibility = 'hidden';cm.style.display = 'none';RG.Registry.Set('chart.contextmenu', null);cmbg.style.visibility = 'hidden';cmbg.style.display = 'none';RG.Registry.Set('chart.contextmenu.bg', null);\n    }\n  };RG.hideContextSubmenu = RG.HideContextSubmenu = function () {\n    var sub = RG.Registry.Get('chart.contextmenu.submenu');if (sub) {\n      sub.style.visibility = 'none';sub.style.display = 'none';RG.Registry.Set('chart.contextmenu.submenu', null);\n    }\n  };RG.showContext = RG.ShowContext = function (obj) {\n    RG.HidePalette();if (obj.Get('chart.contextmenu') && obj.Get('chart.contextmenu').length) {\n      var isOpera = navigator.userAgent.indexOf('Opera') >= 0;var isSafari = navigator.userAgent.indexOf('Safari') >= 0;var isChrome = navigator.userAgent.indexOf('Chrome') >= 0;var isMacFirefox = navigator.userAgent.indexOf('Firefox') > 0 && navigator.userAgent.indexOf('Mac') > 0;var isIE9 = navigator.userAgent.indexOf('MSIE 9') >= 0;if ((!isOpera && !isSafari || isChrome) && !isMacFirefox) {\n        obj.canvas.oncontextmenu = function (e) {\n          e = RG.FixEventObject(e);if (e.ctrlKey) return true;RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);return false;\n        };\n      } else {\n        obj.canvas.addEventListener('dblclick', function (e) {\n          if (e.ctrlKey) return true;if (!RG.Registry.Get('chart.contextmenu')) {\n            RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);\n          }\n        }, false);\n      }\n    }\n  };RG.contextmenu_submenu = RG.Contextmenu_submenu = function (obj, menuitems, parentMenuItem) {\n    RG.HideContextSubmenu();var canvas = obj.canvas;var context = obj.context;var menu = parentMenuItem.parentNode;var subMenu = document.createElement('DIV');subMenu.style.position = 'absolute';subMenu.style.width = '100px';subMenu.style.top = menu.offsetTop + parentMenuItem.offsetTop + 'px';subMenu.style.left = menu.offsetLeft + menu.offsetWidth - (RG.ISOLD ? 9 : 0) + 'px';subMenu.style.backgroundColor = 'white';subMenu.style.border = '1px solid black';subMenu.className = 'RGraph_contextmenu';subMenu.__contextmenu__ = menu;subMenu.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.WebkitBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.filter = 'progid:DXImageTransform.Microsoft.Shadow(color=#aaaaaa,direction=135)';document.body.appendChild(subMenu);for (var i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('DIV');menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = menu;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.fontWeight = 'normal';menuitem.style.textAlign = 'left';menuitem.innerHTML = menuitems[i][0];if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.backgroundColor = 'rgba(0,0,0,0.2)';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      subMenu.appendChild(menuitem);if (menuitems[i] && menuitems[i][1]) {\n        if (document.all) {\n          menuitem.attachEvent('onclick', menuitems[i][1]);\n        } else {\n          menuitem.addEventListener('click', menuitems[i][1], false);\n        }\n      }\n    }\n    var bg = document.createElement('DIV');bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg = subMenu.appendChild(bg);RG.Registry.Set('chart.contextmenu.submenu', subMenu);\n  };RG.showPNG = function () {\n    if (RG.ISIE8) {\n      alert('[RGRAPH PNG] Sorry, showing a PNG is not supported on MSIE8.');return;\n    }\n    if (arguments[0] && arguments[0].id) {\n      var canvas = arguments[0];var event = arguments[1];\n    } else if (RG.Registry.Get('chart.contextmenu')) {\n      var canvas = RG.Registry.Get('chart.contextmenu').__canvas__;\n    } else {\n      alert('[RGRAPH SHOWPNG] Could not find canvas!');\n    }\n    var obj = canvas.__object__;var bg = document.createElement('DIV');bg.id = '__rgraph_image_bg__';bg.style.position = 'fixed';bg.style.top = '-10px';bg.style.left = '-10px';bg.style.width = '5000px';bg.style.height = '5000px';bg.style.backgroundColor = 'rgb(204,204,204)';bg.style.opacity = 0;document.body.appendChild(bg);var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.border = '1px solid black';div.style.position = 'fixed';div.style.top = '20%';div.style.width = canvas.width + 'px';div.style.height = canvas.height + 35 + 'px';div.style.left = document.body.clientWidth / 2 - canvas.width / 2 + 'px';div.style.padding = '5px';div.style.borderRadius = '10px';div.style.MozBorderRadius = '10px';div.style.WebkitBorderRadius = '10px';div.style.boxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.MozBoxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 0 0 15px';div.__canvas__ = canvas;div.__object__ = obj;div.id = '__rgraph_image_div__';document.body.appendChild(div);div.innerHTML += '<div style=\"position: absolute; margin-left: 10px; top: ' + canvas.height + 'px; width: ' + (canvas.width - 50) + 'px; height: 25px\"><span style=\"font-size: 12pt;display: inline; display: inline-block; width: 65px; text-align: right\">URL:</span><textarea style=\"float: right; overflow: hidden; height: 20px; width: ' + (canvas.width - obj.gutterLeft - obj.gutterRight - 80) + 'px\" onclick=\"this.select()\" readonly=\"readonly\" id=\"__rgraph_dataurl__\">' + canvas.toDataURL() + '</textarea></div>';div.innerHTML += '<div style=\"position: absolute; top: ' + (canvas.height + 25) + 'px; left: ' + (obj.gutterLeft - 65 + canvas.width / 2) + 'px; width: ' + (canvas.width - obj.gutterRight) + 'px; font-size: 65%\">A link using the URL: <a href=\"' + canvas.toDataURL() + '\">View</a></div>';\n    var img = document.createElement('IMG');RG.Registry.Set('chart.png', img);img.__canvas__ = canvas;img.__object__ = obj;img.id = '__rgraph_image_img__';img.className = 'RGraph_png';img.src = canvas.toDataURL();div.appendChild(img);setTimeout(function () {\n      document.getElementById(\"__rgraph_dataurl__\").select();\n    }, 50);window.addEventListener('resize', function (e) {\n      var img = RG.Registry.Get('chart.png');img.style.left = document.body.clientWidth / 2 - img.width / 2 + 'px';\n    }, false);bg.onclick = function (e) {\n      var div = document.getElementById(\"__rgraph_image_div__\");var bg = document.getElementById(\"__rgraph_image_bg__\");if (div) {\n        div.style.opacity = 0;div.parentNode.removeChild(div);div.id = '';div.style.display = 'none';div = null;\n      }\n      if (bg) {\n        bg.style.opacity = 0;bg.id = '';bg.style.display = 'none';bg = null;\n      }\n    };\n    window.addEventListener('resize', function (e) {\n      bg.onclick(e);\n    }, false);\n    RG.showpng_image_bg = bg;RG.showpng_image_div = div;setTimeout('RGraph.showpng_image_div.style.opacity = 0.2', 50);setTimeout('RGraph.showpng_image_div.style.opacity = 0.4', 100);setTimeout('RGraph.showpng_image_div.style.opacity = 0.6', 150);setTimeout('RGraph.showpng_image_div.style.opacity = 0.8', 200);setTimeout('RGraph.showpng_image_div.style.opacity = 1', 250);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.1', 50);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.2', 100);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.3', 150);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.4', 200);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.5', 250);img.onclick = function (e) {\n      if (e.stopPropagation) e.stopPropagation();else event.cancelBubble = true;\n    };\n    if (event && event.stopPropagation) {\n      event.stopPropagation();\n    }\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.context.js\n// module id = 165\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.context.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Highlight = {};RG.Registry = {};RG.Registry.store = [];RG.Registry.store['chart.event.handlers'] = [];RG.Registry.store['__rgraph_event_listeners__'] = [];RG.Background = {};RG.background = {};RG.objects = [];RG.Resizing = {};RG.events = [];RG.cursor = [];RG.Effects = RG.Effects || {};RG.cache = [];RG.ObjectRegistry = {};RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];RG.OR = RG.ObjectRegistry;RG.PI = ma.PI;RG.HALFPI = RG.PI / 2;RG.TWOPI = RG.PI * 2;RG.ISFF = ua.indexOf('Firefox') != -1;RG.ISOPERA = ua.indexOf('Opera') != -1;RG.ISCHROME = ua.indexOf('Chrome') != -1;RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.ISOLD = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8;RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;RG.ISIE9UP = RG.ISIE9 || RG.ISIE10UP;RG.getScale = function (max, obj) {\n    if (max == 0) {\n      return ['0.2', '0.4', '0.6', '0.8', '1.0'];\n    }\n    var original_max = max;if (max <= 1) {\n      if (max > 0.5) {\n        return [0.2, 0.4, 0.6, 0.8, Number(1).toFixed(1)];\n      } else if (max >= 0.1) {\n        return obj.Get('chart.scale.round') ? [0.2, 0.4, 0.6, 0.8, 1] : [0.1, 0.2, 0.3, 0.4, 0.5];\n      } else {\n        var tmp = max;var exp = 0;while (tmp < 1.01) {\n          exp += 1;tmp *= 10;\n        }\n        var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];if (max <= '5e-' + exp) {\n          ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\n        }\n        return ret;\n      }\n    }\n    if (String(max).indexOf('.') > 0) {\n      max = String(max).replace(/\\.\\d+$/, '');\n    }\n    var interval = ma.pow(10, Number(String(Number(max)).length - 1));var topValue = interval;while (topValue < max) {\n      topValue += interval / 2;\n    }\n    if (Number(original_max) > Number(topValue)) {\n      topValue += interval / 2;\n    }\n    if (max < 10) {\n      topValue = Number(original_max) <= 5 ? 5 : 10;\n    }\n    if (obj && typeof obj.Get('chart.scale.round') == 'boolean' && obj.Get('chart.scale.round')) {\n      topValue = 10 * interval;\n    }\n    return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\n  };RG.getScale2 = function (obj, opt) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        numlabels = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,\n        units_pre = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',\n        units_post = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',\n        max = Number(opt['max']),\n        min = typeof opt['min'] == 'number' ? opt['min'] : 0,\n        strict = opt['strict'],\n        decimals = Number(opt['scale.decimals']),\n        point = opt['scale.point'],\n        thousand = opt['scale.thousand'],\n        original_max = max,\n        round = opt['scale.round'],\n        scale = { max: 1, labels: [], values: [] };\n    if (!max) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = (((max - min) / numlabels + min) * (i + 1)).toFixed(decimals);scale.labels.push(units_pre + label + units_post);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(original_max) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(original_max) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;var tmp_point = prop['chart.scale.point'];var tmp_thousand = prop['chart.scale.thousand'];obj.Set('chart.scale.thousand', thousand);obj.Set('chart.scale.point', point);for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.number_format(obj, ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n      obj.Set('chart.scale.thousand', tmp_thousand);obj.Set('chart.scale.point', tmp_point);\n    } else if (typeof max == 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.numberFormat(obj, ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.units_pre = units_pre;scale.units_post = units_post;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.arrayReverse(out2);return out2;\n  };RG.arrayClone = RG.array_clone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n      if (typeof obj[i] === 'number') {\n        temp[i] = function (arg) {\n          return Number(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'string') {\n        temp[i] = function (arg) {\n          return String(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'function') {\n        temp[i] = obj[i];\n      } else {\n        temp[i] = RG.arrayClone(obj[i]);\n      }\n    }\n    return temp;\n  };RG.arrayMax = RG.array_max = function (arr) {\n    var max = null,\n        ma = Math;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.arrayPad = RG.array_pad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.arraySum = RG.array_sum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.is_null(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.arrayLinearize = RG.array_linearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.array_linearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.arrayShift = RG.array_shift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.arrayReverse = RG.array_reverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.clear = RG.Clear = function (ca) {\n    var obj = ca.__object__,\n        co = ca.getContext('2d'),\n        color = arguments[1] || obj && obj.get('clearto');\n    if (!ca) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforeclear');if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {\n      for (var i in RG.text2.domNodeCache[ca.id]) {\n        var el = RG.text2.domNodeCache[ca.id][i];if (el && el.style) {\n          el.style.display = 'none';\n        }\n      }\n    }\n    if (!color || color && color === 'rgba(0,0,0,0)' || color === 'transparent') {\n      co.clearRect(-100, -100, ca.width + 200, ca.height + 200);co.globalCompositeOperation = 'source-over';\n    } else if (color) {\n      RG.path2(co, 'fs % fr -100 -100 % %', color, ca.width + 200, ca.height + 200);\n    } else {\n      RG.path2(co, 'fs % fr -100 -100 % %', obj.get('clearto'), ca.width + 200, ca.height + 200);\n    }\n    if (RG.Registry.Get('chart.background.image.' + ca.id)) {\n      var img = RG.Registry.Get('chart.background.image.' + ca.id);img.style.position = 'absolute';img.style.left = '-10000px';img.style.top = '-10000px';\n    }\n    if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {\n      RG.HideTooltip(ca);\n    }\n    ca.style.cursor = 'default';RG.FireCustomEvent(obj, 'onclear');\n  };RG.drawTitle = RG.DrawTitle = function (obj, text, gutterTop) {\n    var ca = canvas = obj.canvas,\n        co = context = obj.context,\n        prop = obj.properties;\n    gutterLeft = prop['chart.gutter.left'], gutterRight = prop['chart.gutter.right'], gutterTop = gutterTop, gutterBottom = prop['chart.gutter.bottom'], size = arguments[4] ? arguments[4] : 12, bold = prop['chart.title.bold'], italic = prop['chart.title.italic'], centerx = arguments[3] ? arguments[3] : (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft, keypos = prop['chart.key.position'], vpos = prop['chart.title.vpos'], hpos = prop['chart.title.hpos'], bgcolor = prop['chart.title.background'], x = prop['chart.title.x'], y = prop['chart.title.y'], halign = 'center', valign = 'center';\n    if (obj.type == 'bar' && prop['chart.variant'] == '3d') {\n      keypos = 'gutter';\n    }\n    co.beginPath();co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';if (keypos && keypos != 'gutter') {\n      var valign = 'center';\n    } else if (!keypos) {\n      var valign = 'center';\n    } else {\n      var valign = 'bottom';\n    }\n    if (typeof prop['chart.title.vpos'] === 'number') {\n      vpos = prop['chart.title.vpos'] * gutterTop;if (prop['chart.xaxispos'] === 'top') {\n        vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);\n      }\n    } else {\n      vpos = gutterTop - size - 5;if (prop['chart.xaxispos'] === 'top') {\n        vpos = ca.height - gutterBottom + size + 5;\n      }\n    }\n    if (typeof hpos === 'number') {\n      centerx = hpos * ca.width;\n    }\n    if (typeof x === 'number') centerx = x;if (typeof y === 'number') vpos = y;if (typeof prop['chart.title.halign'] === 'string') {\n      halign = prop['chart.title.halign'];\n    }\n    if (typeof prop['chart.title.valign'] === 'string') {\n      valign = prop['chart.title.valign'];\n    }\n    if (typeof prop['chart.title.color'] !== null) {\n      var oldColor = co.fillStyle;\n      var newColor = prop['chart.title.color'];co.fillStyle = newColor ? newColor : 'black';\n    }\n    var font = prop['chart.text.font'];if (typeof prop['chart.title.font'] === 'string') {\n      font = prop['chart.title.font'];\n    }\n    var ret = RG.text2(obj, { font: font, size: size, x: centerx, y: vpos, text: text, valign: valign, halign: halign, bounding: bgcolor != null, 'bounding.fill': bgcolor, 'bold': bold, italic: italic, tag: 'title', marker: false });co.fillStyle = oldColor;\n  };RG.getMouseXY = function (e) {\n    if (!e.target) {\n      return;\n    }\n    var el = e.target;var ca = el;var caStyle = ca.style;var offsetX = 0;var offsetY = 0;var x;var y;var borderLeft = parseInt(caStyle.borderLeftWidth) || 0;var borderTop = parseInt(caStyle.borderTopWidth) || 0;var paddingLeft = parseInt(caStyle.paddingLeft) || 0;\n    var paddingTop = parseInt(caStyle.paddingTop) || 0;\n    var additionalX = borderLeft + paddingLeft;var additionalY = borderTop + paddingTop;if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\n      if (!RG.ISIE && !RG.ISOPERA) {\n        x = e.offsetX - borderLeft - paddingLeft;y = e.offsetY - borderTop - paddingTop;\n      } else if (RG.ISIE) {\n        x = e.offsetX - paddingLeft;y = e.offsetY - paddingTop;\n      } else {\n        x = e.offsetX;y = e.offsetY;\n      }\n    } else {\n      if (typeof el.offsetParent !== 'undefined') {\n        do {\n          offsetX += el.offsetLeft;offsetY += el.offsetTop;\n        } while (el = el.offsetParent);\n      }\n      x = e.pageX - offsetX - additionalX;y = e.pageY - offsetY - additionalY;x -= 2 * (parseInt(document.body.style.borderLeftWidth) || 0);y -= 2 * (parseInt(document.body.style.borderTopWidth) || 0);\n    }\n    return [x, y];\n  };RG.getCanvasXY = function (canvas) {\n    var x = 0;var y = 0;var el = canvas;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName.toLowerCase() != 'body');var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;var paddingTop = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;var borderLeft = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;var borderTop = canvas.style.borderTopWidth ? parseInt(canvas.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.isFixed = function (canvas) {\n    var obj = canvas;var i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position == 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.register = RG.Register = function (obj) {\n    if (!obj.Get('chart.noregister')) {\n      RGraph.ObjectRegistry.Add(obj);obj.Set('chart.noregister', true);\n    }\n  };RG.redraw = RG.Redraw = function () {\n    var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;var tags = document.getElementsByTagName('canvas');for (var i = 0, len = tags.length; i < len; ++i) {\n      if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n        if (!tags[i].noclear) {\n          RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);\n        }\n      }\n    }\n    for (var i = 0, len = objectRegistry.length; i < len; ++i) {\n      if (objectRegistry[i]) {\n        var id = objectRegistry[i][0];objectRegistry[i][1].Draw();\n      }\n    }\n  };RG.redrawCanvas = RG.RedrawCanvas = function (ca) {\n    var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);if (!arguments[1] || typeof arguments[1] === 'boolean' && !arguments[1] == false) {\n      var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';RG.clear(ca, color);\n    }\n    for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        if (objects[i] && objects[i].isRGraph) {\n          objects[i].Draw();\n        }\n      }\n    }\n  };RG.Background.draw = RG.background.draw = RG.background.Draw = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        height = 0,\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        variant = prop['chart.variant'];\n    co.fillStyle = prop['chart.text.color'];if (variant == '3d') {\n      co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n    }\n    if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var bold = prop['chart.title.xaxis.bold'];if (typeof prop['chart.title.xaxis.size'] == 'number') {\n        size = prop['chart.title.xaxis.size'];\n      }\n      if (typeof prop['chart.title.xaxis.font'] == 'string') {\n        font = prop['chart.title.xaxis.font'];\n      }\n      var hpos = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;var vpos = ca.height - gutterBottom + 25;if (typeof prop['chart.title.xaxis.pos'] === 'number') {\n        vpos = ca.height - gutterBottom * prop['chart.title.xaxis.pos'];\n      }\n      if (typeof prop['chart.title.xaxis.x'] === 'number') {\n        hpos = prop['chart.title.xaxis.x'];\n      }\n      if (typeof prop['chart.title.xaxis.y'] === 'number') {\n        vpos = prop['chart.title.xaxis.y'];\n      }\n      RG.text2(prop['chart.text.accessible'] ? obj.context : co, { font: font, size: size, x: hpos, y: vpos, text: prop['chart.title.xaxis'], halign: 'center', valign: 'center', bold: bold, color: prop['chart.title.xaxis.color'] || 'black', tag: 'title xaxis' });\n    }\n    if (typeof prop['chart.title.yaxis'] == 'string' && prop['chart.title.yaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var angle = 270;var bold = prop['chart.title.yaxis.bold'];var color = prop['chart.title.yaxis.color'];if (typeof prop['chart.title.yaxis.pos'] == 'number') {\n        var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;\n      } else {\n        var yaxis_title_pos = (gutterLeft - 25) / gutterLeft * gutterLeft;\n      }\n      if (typeof prop['chart.title.yaxis.size'] === 'number') {\n        size = prop['chart.title.yaxis.size'];\n      }\n      if (typeof prop['chart.title.yaxis.font'] === 'string') {\n        font = prop['chart.title.yaxis.font'];\n      }\n      if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined') {\n        angle = 90;yaxis_title_pos = prop['chart.title.yaxis.pos'] ? ca.width - gutterRight + prop['chart.title.yaxis.pos'] * gutterRight : ca.width - gutterRight + prop['chart.text.size'] + 5;\n      } else {\n        yaxis_title_pos = yaxis_title_pos;\n      }\n      var y = (ca.height - gutterTop - gutterBottom) / 2 + gutterTop;if (typeof prop['chart.title.yaxis.x'] === 'number') {\n        yaxis_title_pos = prop['chart.title.yaxis.x'];\n      }\n      if (typeof prop['chart.title.yaxis.y'] === 'number') {\n        y = prop['chart.title.yaxis.y'];\n      }\n      co.fillStyle = color;RG.text2(prop['chart.text.accessible'] ? obj.context : co, { 'font': font, 'size': size, 'x': yaxis_title_pos, 'y': y, 'valign': 'center', 'halign': 'center', 'angle': angle, 'bold': bold, 'text': prop['chart.title.yaxis'], 'tag': 'title yaxis', accessible: false });\n    }\n    var bgcolor = prop['chart.background.color'];if (bgcolor) {\n      co.fillStyle = bgcolor;co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n    }\n    var numbars = prop['chart.ylabels.count'] || 5;var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;co.beginPath();co.fillStyle = prop['chart.background.barcolor1'];co.strokeStyle = co.fillStyle;height = ca.height - gutterBottom;for (var i = 0; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();co.fillStyle = prop['chart.background.barcolor2'];co.strokeStyle = co.fillStyle;for (var i = 1; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();var func = function func(obj, cacheCanvas, cacheContext) {\n      if (prop['chart.background.grid']) {\n        prop['chart.background.grid.autofit.numhlines'] += 0.0001;if (prop['chart.background.grid.autofit']) {\n          if (prop['chart.background.grid.autofit.align']) {\n            if (obj.type === 'hbar') {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n            if (obj.type === 'line') {\n              if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {} else if (prop['chart.labels'] && prop['chart.labels'].length) {\n                obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);\n              } else {\n                obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);\n              }\n            } else if (obj.type === 'waterfall') {\n              obj.set('backgroundGridAutofitNumvlines', obj.data.length + (prop['chart.total'] ? 1 : 0));\n            } else if ((obj.type === 'bar' || obj.type === 'scatter') && (prop['chart.labels'] && prop['chart.labels'].length || obj.type === 'bar')) {\n              var len = prop['chart.labels'] && prop['chart.labels'].length || obj.data.length;obj.set({ backgroundGridAutofitNumvlines: len });\n            } else if (obj.type === 'gantt') {\n              if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {} else {\n                obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);\n              }\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines'])) {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n          }\n          var vsize = (cacheCanvas.width - gutterLeft - gutterRight) / prop['chart.background.grid.autofit.numvlines'];var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];obj.Set('chart.background.grid.vsize', vsize);obj.Set('chart.background.grid.hsize', hsize);\n        }\n        co.beginPath();cacheContext.lineWidth = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;cacheContext.strokeStyle = prop['chart.background.grid.color'];if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([3, 5]);\n        }\n        if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([1, 3]);\n        }\n        co.beginPath();if (prop['chart.background.grid.hlines']) {\n          height = cacheCanvas.height - gutterBottom;\n          var hsize = prop['chart.background.grid.hsize'];for (y = gutterTop; y <= height; y += hsize) {\n            cacheContext.moveTo(gutterLeft, ma.round(y));cacheContext.lineTo(ca.width - gutterRight, ma.round(y));\n          }\n        }\n        if (prop['chart.background.grid.vlines']) {\n          var width = cacheCanvas.width - gutterRight;var vsize = prop['chart.background.grid.vsize'];for (x = gutterLeft; ma.round(x) <= width; x += vsize) {\n            cacheContext.moveTo(ma.round(x), gutterTop);cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);\n          }\n        }\n        if (prop['chart.background.grid.border']) {\n          cacheContext.strokeStyle = prop['chart.background.grid.color'];cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n        }\n      }\n      cacheContext.stroke();cacheContext.beginPath();cacheContext.closePath();\n    };\n    RG.cachedDraw(obj, obj.uid + '_background', func);if (variant == '3d') {\n      co.restore();\n    }\n    if (typeof co.setLineDash == 'function') {\n      co.setLineDash([1, 0]);\n    }\n    co.stroke();if (typeof obj.properties['chart.title'] == 'string') {\n      var prop = obj.properties;RG.drawTitle(obj, prop['chart.title'], obj.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2, obj);\n    }\n  };RG.numberFormat = RG.number_format = function (obj, num) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var i;var prepend = arguments[2] ? String(arguments[2]) : '';var append = arguments[3] ? String(arguments[3]) : '';var output = '';var decimal = '';var decimal_seperator = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';RegExp.$1 = '';var i, j;if (typeof prop['chart.scale.formatter'] === 'function') {\n      return prop['chart.scale.formatter'](obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {\n      output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.drawBars = RG.DrawBars = function (obj) {\n    var prop = obj.properties;var co = obj.context;var ca = obj.canvas;var hbars = prop['chart.background.hbars'];if (hbars === null) {\n      return;\n    }\n    co.beginPath();for (i = 0, len = hbars.length; i < len; ++i) {\n      var start = hbars[i][0];var length = hbars[i][1];var color = hbars[i][2];if (RG.is_null(start)) start = obj.scale2.max;\n      if (start > obj.scale2.max) start = obj.scale2.max;if (RG.is_null(length)) length = obj.scale2.max - start;if (start + length > obj.scale2.max) length = obj.scale2.max - start;if (start + length < -1 * obj.scale2.max) length = -1 * obj.scale2.max - start;if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < obj.scale2.max * -2) {\n        length = obj.scale2.max * -2;\n      }\n      var x = prop['chart.gutter.left'];var y = obj.getYCoord(start);var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var h = obj.getYCoord(start + length) - y;if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {\n        h *= -1;y = y - h;\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        y = ca.height - y;h *= -1;\n      }\n      co.fillStyle = color;co.fillRect(x, y, w, h);\n    }\n  };RG.drawInGraphLabels = RG.DrawInGraphLabels = function (obj) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var labels = prop['chart.labels.ingraph'];var labels_processed = [];var fgcolor = 'black';var bgcolor = 'white';var direction = 1;if (!labels) {\n      return;\n    }\n    for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] === 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] === 'string' || _typeof(labels[i]) === 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.noShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      for (var i = 0, len = labels_processed.length; i < len; i += 1) {\n        if (labels_processed[i]) {\n          var coords = obj.coords[i];if (coords && coords.length > 0) {\n            var x = obj.type == 'bar' ? coords[0] + coords[2] / 2 : coords[0];var y = obj.type == 'bar' ? coords[1] + coords[3] / 2 : coords[1];var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;co.beginPath();co.fillStyle = 'black';co.strokeStyle = 'black';if (obj.type === 'bar') {\n              if (obj.Get('chart.xaxispos') == 'top') {\n                length *= -1;\n              }\n              if (prop['chart.variant'] == 'dot') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else if (prop['chart.variant'] == 'arrow') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else {\n                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y - length);var text_x = ma.round(x);var text_y = y - length;\n              }\n              co.stroke();co.fill();\n            } else {\n              if (_typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][3] == 'number' && labels_processed[i][3] == -1) {\n                co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x), y + 5 + length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x) - 3, y + 10);co.lineTo(ma.round(x) + 3, y + 10);co.closePath();var text_x = x;var text_y = y + 5 + length;\n              } else {\n                var text_x = x;var text_y = y - 5 - length;co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x), y - 5 - length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x) - 3, y - 10);co.lineTo(ma.round(x) + 3, y - 10);co.closePath();\n              }\n              co.fill();\n            }\n            co.beginPath();co.fillStyle = _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][1] === 'string' ? labels_processed[i][1] : 'black';RG.text2(obj, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': text_x, 'y': text_y + (obj.properties['chart.text.accessible'] ? 2 : 0), 'text': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][0] === 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][2] === 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels ingraph' });co.fill();\n          }\n        }\n      }\n    }\n  };RG.fixEventObject = RG.FixEventObject = function (e) {\n    if (RG.ISOLD) {\n      var e = event;e.pageX = event.clientX + doc.body.scrollLeft;e.pageY = event.clientY + doc.body.scrollTop;e.target = event.srcElement;if (!doc.body.scrollTop && doc.documentElement.scrollTop) {\n        e.pageX += parseInt(doc.documentElement.scrollLeft);e.pageY += parseInt(doc.documentElement.scrollTop);\n      }\n    }\n    if (!e.stopPropagation) {\n      e.stopPropagation = function () {\n        window.event.cancelBubble = true;\n      };\n    }\n    return e;\n  };RG.hideCrosshairCoords = RG.HideCrosshairCoords = function () {\n    var div = RG.Registry.Get('chart.coordinates.coords.div');if (div && div.style.opacity == 1 && div.__object__.Get('chart.crosshairs.coords.fadeout')) {\n      var style = RG.Registry.Get('chart.coordinates.coords.div').style;setTimeout(function () {\n        style.opacity = 0.9;\n      }, 25);setTimeout(function () {\n        style.opacity = 0.8;\n      }, 50);setTimeout(function () {\n        style.opacity = 0.7;\n      }, 75);setTimeout(function () {\n        style.opacity = 0.6;\n      }, 100);setTimeout(function () {\n        style.opacity = 0.5;\n      }, 125);setTimeout(function () {\n        style.opacity = 0.4;\n      }, 150);setTimeout(function () {\n        style.opacity = 0.3;\n      }, 175);setTimeout(function () {\n        style.opacity = 0.2;\n      }, 200);setTimeout(function () {\n        style.opacity = 0.1;\n      }, 225);setTimeout(function () {\n        style.opacity = 0;\n      }, 250);setTimeout(function () {\n        style.display = 'none';\n      }, 275);\n    }\n  };RG.draw3DAxes = RG.Draw3DAxes = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'],\n        xaxis = prop['chart.variant.threed.xaxis'],\n        yaxis = prop['chart.variant.threed.yaxis'];\n    if (yaxis) {\n      RG.draw3DYAxis(obj);\n    }\n    if (xaxis) {\n      if (xaxispos === 'center') {\n        RG.path2(co, 'b m % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, gutterTop + halfGraphArea, gutterLeft + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight, gutterTop + halfGraphArea);\n      } else {\n        if (obj.type === 'hbar') {\n          var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];\n        } else {\n          var xaxisYCoord = obj.getYCoord(0);\n        }\n        RG.path2(co, 'm % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, xaxisYCoord, gutterLeft + offsetx, xaxisYCoord - offsety, ca.width - gutterRight + offsetx, xaxisYCoord - offsety, ca.width - gutterRight, xaxisYCoord);\n      }\n    }\n  };RG.draw3DYAxis = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];\n    if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {\n      var x = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;\n    } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {\n      var x = ca.width - gutterRight;\n    } else {\n      var x = gutterLeft;\n    }\n    RG.path2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', x, gutterTop, x + offsetx, gutterTop - offsety, x + offsetx, ca.height - gutterBottom - offsety, x, ca.height - gutterBottom);\n  };RG.strokedCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();co.moveTo(x + (corner_tl ? r : 0), y);co.lineTo(x + w - (corner_tr ? r : 0), y);if (corner_tr) {\n      co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);\n    }\n    co.lineTo(x + w, y + h - (corner_br ? r : 0));if (corner_br) {\n      co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);\n    }\n    co.lineTo(x + (corner_bl ? r : 0), y + h);if (corner_bl) {\n      co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    }\n    co.lineTo(x, y + (corner_tl ? r : 0));if (corner_tl) {\n      co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    }\n    co.stroke();\n  };RG.filledCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();if (corner_tl) {\n      co.moveTo(x + r, y + r);co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    } else {\n      co.fillRect(x, y, r, r);\n    }\n    if (corner_tr) {\n      co.moveTo(x + w - r, y + r);co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);\n    } else {\n      co.moveTo(x + w - r, y);co.fillRect(x + w - r, y, r, r);\n    }\n    if (corner_br) {\n      co.moveTo(x + w - r, y + h - r);co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);\n    } else {\n      co.moveTo(x + w - r, y + h - r);co.fillRect(x + w - r, y + h - r, r, r);\n    }\n    if (corner_bl) {\n      co.moveTo(x + r, y + h - r);co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    } else {\n      co.moveTo(x, y + h - r);co.fillRect(x, y + h - r, r, r);\n    }\n    co.fillRect(x + r, y, w - r - r, h);co.fillRect(x, y + r, r + 1, h - r - r);co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);co.fill();\n  };RG.hideZoomedCanvas = RG.HideZoomedCanvas = function () {\n    var interval = 10;var frames = 15;if (_typeof(RG.zoom_image) === 'object') {\n      var obj = RG.zoom_image.obj;var prop = obj.properties;\n    } else {\n      return;\n    }\n    if (prop['chart.zoom.fade.out']) {\n      for (var i = frames, j = 1; i >= 0; --i, ++j) {\n        if (_typeof(RG.zoom_image) === 'object') {\n          setTimeout(\"RGraph.zoom_image.style.opacity = \" + String(i / 10), j * interval);\n        }\n      }\n      if (_typeof(RG.zoom_background) === 'object') {\n        setTimeout(\"RGraph.zoom_background.style.opacity = \" + String(i / frames), j * interval);\n      }\n    }\n    if (_typeof(RG.zoom_image) === 'object') {\n      setTimeout(\"RGraph.zoom_image.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n    if (_typeof(RG.zoom_background) === 'object') {\n      setTimeout(\"RGraph.zoom_background.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n  };RG.addCustomEventListener = RG.AddCustomEventListener = function (obj, name, func) {\n    if (typeof RG.events[obj.uid] === 'undefined') {\n      RG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.events[obj.uid].push([obj, name, func]);return RG.events[obj.uid].length - 1;\n  };RG.fireCustomEvent = RG.FireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {\n        obj.properties['chart.events.mouseout'](obj);\n      }\n      if (obj[name]) {\n        obj[name](obj);\n      }\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.events) === 'object' && _typeof(RG.events[uid]) === 'object' && RG.events[uid].length > 0) {\n        for (var j = 0; j < RG.events[uid].length; ++j) {\n          if (RG.events[uid][j] && RG.events[uid][j][1] === name) {\n            RG.events[uid][j][2](obj);\n          }\n        }\n      }\n    }\n  };RGraph.removeAllCustomEventListeners = RGraph.RemoveAllCustomEventListeners = function () {\n    var id = arguments[0];if (id && RG.events[id]) {\n      RG.events[id] = [];\n    } else {\n      RG.events = [];\n    }\n  };RG.removeCustomEventListener = RG.RemoveCustomEventListener = function (obj, i) {\n    if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.id]) === 'object' && _typeof(RG.events[obj.id][i]) === 'object') {\n      RG.events[obj.id][i] = null;\n    }\n  };RG.drawBackgroundImage = RG.DrawBackgroundImage = function (obj) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (typeof prop['chart.background.image'] === 'string') {\n      if (typeof ca.__rgraph_background_image__ === 'undefined') {\n        var img = new Image();img.__object__ = obj;img.__canvas__ = ca;img.__context__ = co;img.src = obj.Get('chart.background.image');ca.__rgraph_background_image__ = img;\n      } else {\n        img = ca.__rgraph_background_image__;\n      }\n      img.onload = function () {\n        obj.__rgraph_background_image_loaded__ = true;RG.clear(ca);RG.redrawCanvas(ca);\n      };\n      var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var stretch = prop['chart.background.image.stretch'];var align = prop['chart.background.image.align'];if (typeof align === 'string') {\n        if (align.indexOf('right') != -1) {\n          var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;\n        } else {\n          var x = gutterLeft;\n        }\n        if (align.indexOf('bottom') != -1) {\n          var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;\n        } else {\n          var y = gutterTop;\n        }\n      } else {\n        var x = gutterLeft || 25;var y = gutterTop || 25;\n      }\n      var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;if (typeof prop['chart.background.image.w'] === 'number') w = prop['chart.background.image.w'];if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.background.image.alpha'];co.drawImage(img, x, y, w, h);co.globalAlpha = oldAlpha;\n    }\n  };RG.hasTooltips = function (obj) {\n    var prop = obj.properties;if (_typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips']) {\n      for (var i = 0, len = prop['chart.tooltips'].length; i < len; ++i) {\n        if (!RG.is_null(obj.Get('chart.tooltips')[i])) {\n          return true;\n        }\n      }\n    } else if (typeof prop['chart.tooltips'] === 'function') {\n      return true;\n    }\n    return false;\n  };RG.createUID = RG.CreateUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.OR.add = RG.OR.Add = function (obj) {\n    var uid = obj.uid;var id = obj.canvas.id;RG.ObjectRegistry.objects.byUID.push([uid, obj]);RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);\n  };RG.OR.remove = RG.OR.Remove = function (obj) {\n    var id = obj.id;var uid = obj.uid;for (var i = 0; i < RG.ObjectRegistry.objects.byUID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byUID[i] = null;\n      }\n    }\n    for (var i = 0; i < RG.ObjectRegistry.objects.byCanvasID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byCanvasID[i] && RG.ObjectRegistry.objects.byCanvasID[i][1] && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byCanvasID[i] = null;\n      }\n    }\n  };RG.OR.clear = RG.OR.Clear = function () {\n    if (arguments[0]) {\n      var id = _typeof(arguments[0]) === 'object' ? arguments[0].id : arguments[0];var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.ObjectRegistry.remove(objects[i]);\n      }\n    } else {\n      RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];\n    }\n  };RG.OR.list = RG.OR.List = function () {\n    var list = [];for (var i = 0, len = RG.ObjectRegistry.objects.byUID.length; i < len; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i]) {\n        list.push(RG.ObjectRegistry.objects.byUID[i][1].type);\n      }\n    }\n    if (arguments[0]) {\n      return list;\n    } else {\n      $p(list);\n    }\n  };RG.OR.clearByType = RG.OR.ClearByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        var uid = objects[i][0];var obj = objects[i][1];if (obj && obj.type == type) {\n          RG.ObjectRegistry.remove(obj);\n        }\n      }\n    }\n  };RG.OR.iterate = RG.OR.Iterate = function (func) {\n    var objects = RGraph.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (typeof arguments[1] === 'string') {\n        var types = arguments[1].split(/,/);for (var j = 0, len2 = types.length; j < len2; ++j) {\n          if (types[j] == objects[i][1].type) {\n            func(objects[i][1]);\n          }\n        }\n      } else {\n        func(objects[i][1]);\n      }\n    }\n  };RG.OR.getObjectsByCanvasID = function (id) {\n    var store = RG.ObjectRegistry.objects.byCanvasID;var ret = [];for (var i = 0, len = store.length; i < len; ++i) {\n      if (store[i] && store[i][0] == id) {\n        ret.push(store[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.firstbyxy = RG.OR.getFirstObjectByXY = RG.OR.getObjectByXY = function (e) {\n    var canvas = e.target;var ret = null;var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        return obj;\n      }\n    }\n  };RG.OR.getObjectsByXY = function (e) {\n    var canvas = e.target;var ret = [];var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        ret.push(obj);\n      }\n    }\n    return ret;\n  };RG.OR.get = RG.OR.getObjectByUID = function (uid) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1].uid == uid) {\n        return objects[i][1];\n      }\n    }\n  };RG.OR.bringToFront = function (obj) {\n    var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];RG.ObjectRegistry.remove(obj);RG.ObjectRegistry.add(obj);if (redraw) {\n      RG.redrawCanvas(obj.canvas);\n    }\n  };RG.OR.type = RG.OR.getObjectsByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;var ret = [];for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {\n        ret.push(objects[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.first = RG.OR.getFirstObjectByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type == type) {\n        return objects[i][1];\n      }\n    }\n    return null;\n  };RG.getAngleByXY = function (cx, cy, x, y) {\n    var angle = ma.atan((y - cy) / (x - cx));angle = ma.abs(angle);\n    if (x >= cx && y >= cy) {\n      angle += RG.TWOPI;\n    } else if (x >= cx && y < cy) {\n      angle = RG.HALFPI - angle + (RG.PI + RG.HALFPI);\n    } else if (x < cx && y < cy) {\n      angle += RG.PI;\n    } else {\n      angle = RG.PI - angle;\n    }\n    if (angle > RG.TWOPI) {\n      angle -= RG.TWOPI;\n    }\n    return angle;\n  };RG.getHypLength = function (x1, y1, x2, y2) {\n    var ret = ma.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));return ret;\n  };RG.getRadiusEndPoint = function (cx, cy, angle, radius) {\n    var x = cx + ma.cos(angle) * radius;var y = cy + ma.sin(angle) * radius;return [x, y];\n  };RG.installEventListeners = RG.InstallEventListeners = function (obj) {\n    var prop = obj.properties;if (RG.ISOLD) {\n      return;\n    }\n    if (RG.installCanvasClickListener) {\n      RG.installWindowMousedownListener(obj);RG.installWindowMouseupListener(obj);RG.installCanvasMousemoveListener(obj);RG.installCanvasMouseupListener(obj);RG.installCanvasMousedownListener(obj);RG.installCanvasClickListener(obj);\n    } else if (RG.hasTooltips(obj) || prop['chart.adjustable'] || prop['chart.annotatable'] || prop['chart.contextmenu'] || prop['chart.resizable'] || prop['chart.key.interactive'] || prop['chart.events.click'] || prop['chart.events.mousemove'] || typeof obj.onclick === 'function' || typeof obj.onmousemove === 'function') {\n      alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\n    }\n  };RG.pr = function (obj) {\n    var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n      return '';\n    }\n    switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n        str += 'function () {}';break;case 'undefined':\n        str += 'undefined';break;case 'null':\n        str += 'null';break;case 'object':\n        if (RGraph.is_null(obj)) {\n          str += indent + 'null\\n';\n        } else {\n          str += indent + 'Object {' + '\\n';\n          for (j in obj) {\n            str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\\n';\n          }\n          str += indent + '}';\n        }\n        break;default:\n        str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n    if (!arguments[1]) {\n      alert(str);\n    }\n    return str;\n  };RG.dashedLine = RG.DashedLine = function (co, x1, y1, x2, y2) {\n    var size = 5;if (typeof arguments[5] === 'number') {\n      size = arguments[5];\n    }\n    var dx = x2 - x1;var dy = y2 - y1;var num = ma.floor(ma.sqrt(dx * dx + dy * dy) / size);var xLen = dx / num;var yLen = dy / num;var count = 0;do {\n      count % 2 == 0 && count > 0 ? co.lineTo(x1, y1) : co.moveTo(x1, y1);x1 += xLen;y1 += yLen;\n    } while (count++ <= num);\n  };RG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.AJAX.getNumber = function (url, callback) {\n    RG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.AJAX.getString = function (url, callback) {\n    RG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.AJAX.getJSON = function (url, callback) {\n    RG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.AJAX.getCSV = function (url, callback) {\n    var seperator = arguments[2] ? arguments[2] : ',';RG.AJAX(url, function () {\n      var regexp = new RegExp(seperator);var arr = this.responseText.split(regexp);for (var i = 0, len = arr.length; i < len; ++i) {\n        arr[i] = parseFloat(arr[i]);\n      }\n      callback(arr);\n    });\n  };RG.rotateCanvas = RG.RotateCanvas = function (ca, x, y, angle) {\n    var co = ca.getContext('2d');co.translate(x, y);co.rotate(angle);co.translate(0 - x, 0 - y);\n  };RG.measureText = RG.MeasureText = function (text, bold, font, size) {\n    if (typeof RG.measuretext_cache === 'undefined') {\n      RG.measuretext_cache = [];\n    }\n    var str = text + ':' + bold + ':' + font + ':' + size;if (_typeof(RG.measuretext_cache) == 'object' && RG.measuretext_cache[str]) {\n      return RG.measuretext_cache[str];\n    }\n    if (!RG.measuretext_cache['text-div']) {\n      var div = document.createElement('DIV');div.style.position = 'absolute';div.style.top = '-100px';div.style.left = '-100px';document.body.appendChild(div);RG.measuretext_cache['text-div'] = div;\n    } else if (RG.measuretext_cache['text-div']) {\n      var div = RG.measuretext_cache['text-div'];\n    }\n    div.innerHTML = text.replace(/\\r\\n/g, '<br />');div.style.fontFamily = font;div.style.fontWeight = bold ? 'bold' : 'normal';div.style.fontSize = (size || 12) + 'pt';var size = [div.offsetWidth, div.offsetHeight];RG.measuretext_cache[str] = size;return size;\n  };RG.text2 = RG.Text2 = function (obj, opt) {\n    function domtext() {\n      if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {\n        opt.size = opt.size.replace(/ *italic +/, '');opt.italic = true;\n      }\n      var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;if (!ca.rgraph_domtext_wrapper) {\n        var wrapper = document.createElement('div');wrapper.id = ca.id + '_rgraph_domtext_wrapper';wrapper.className = 'rgraph_domtext_wrapper';wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';wrapper.style.width = ca.offsetWidth + 'px';wrapper.style.height = ca.offsetHeight + 'px';wrapper.style.cssFloat = ca.style.cssFloat;wrapper.style.display = ca.style.display || 'inline-block';wrapper.style.position = ca.style.position || 'relative';wrapper.style.left = ca.style.left;wrapper.style.top = ca.style.top;wrapper.style.width = ca.width + 'px';wrapper.style.height = ca.height + 'px';ca.style.position = 'absolute';ca.style.left = 0;ca.style.top = 0;ca.style.display = 'inline';ca.style.cssFloat = 'none';if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {\n          wrapper.style.transform = 'skewY(5.7deg)';\n        }\n        ca.parentNode.insertBefore(wrapper, ca);ca.parentNode.removeChild(ca);wrapper.appendChild(ca);ca.rgraph_domtext_wrapper = wrapper;\n      } else {\n        wrapper = ca.rgraph_domtext_wrapper;\n      }\n      var defaults = { size: 12, font: 'Arial', italic: 'normal', bold: 'normal', valign: 'bottom', halign: 'left', marker: true, color: co.fillStyle, bounding: { enabled: false, fill: 'rgba(255,255,255,0.7)', stroke: '#666' } };\n      opt.text = String(opt.text).replace(/\\r?\\n/g, '[[RETURN]]');if (typeof RG.text2.domNodeCache === 'undefined') {\n        RG.text2.domNodeCache = new Array();\n      }\n      if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {\n        RG.text2.domNodeCache[obj.id] = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache === 'undefined') {\n        RG.text2.domNodeDimensionCache = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {\n        RG.text2.domNodeDimensionCache[obj.id] = new Array();\n      }\n      if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {\n        var span = document.createElement('span');span.style.position = 'absolute';span.style.display = 'inline';span.style.left = opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width)) + 'px';span.style.top = opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)) + 'px';span.style.color = opt.color || defaults.color;span.style.fontFamily = opt.font || defaults.font;span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;span.style.fontStyle = opt.italic ? 'italic' : defaults.italic;span.style.fontSize = (opt.size || defaults.size) + 'pt';span.style.whiteSpace = 'nowrap';span.tag = opt.tag;if (typeof opt.angle === 'number' && opt.angle !== 0) {\n          var coords = RG.measureText(opt.text, opt.bold, opt.font, opt.size);span.style.transformOrigin = '100% 50%';span.style.transform = 'rotate(' + opt.angle + 'deg)';\n        }\n        span.style.textShadow = '{1}px {2}px {3}px {4}'.format(co.shadowOffsetX, co.shadowOffsetY, co.shadowBlur, co.shadowColor);if (opt.bounding) {\n          span.style.border = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;\n        }\n        if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' || obj.properties['chart.text.accessible.pointerevents']) && obj.properties['chart.text.accessible.pointerevents'] !== 'none') {\n          span.style.pointerEvents = 'auto';\n        } else {\n          span.style.pointerEvents = 'none';\n        }\n        span.style.padding = opt.bounding ? '2px' : null;span.__text__ = opt.text;\n        span.innerHTML = opt.text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');span.innerHTML = span.innerHTML.replace(/\\[\\[RETURN\\]\\]/g, '<br />');wrapper.appendChild(span);opt.halign = opt.halign || 'left';opt.valign = opt.valign || 'bottom';if (opt.halign === 'right') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth + 'px';span.style.textAlign = 'right';\n        } else if (opt.halign === 'center') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth / 2 + 'px';span.style.textAlign = 'center';\n        }\n        if (opt.valign === 'top') {} else if (opt.valign === 'center') {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight / 2 + 'px';\n        } else {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\n        }\n        var offsetWidth = parseFloat(span.offsetWidth),\n            offsetHeight = parseFloat(span.offsetHeight),\n            top = parseFloat(span.style.top),\n            left = parseFloat(span.style.left);RG.text2.domNodeCache[obj.id][cacheKey] = span;RG.text2.domNodeDimensionCache[obj.id][cacheKey] = { left: left, top: top, width: offsetWidth, height: offsetHeight };span.id = cacheKey;\n      } else {\n        span = RG.text2.domNodeCache[obj.id][cacheKey];span.style.display = 'inline';var offsetWidth = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,\n            offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,\n            top = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,\n            left = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;\n      }\n      if (opt.marker) {\n        RG.path2(context, 'b m % % l % % m % % l % % s', opt.x - 5, opt.y, opt.x + 5, opt.y, opt.x, opt.y - 5, opt.x, opt.y + 5);\n      }\n      if (obj.type === 'drawing.text') {\n        if (obj.properties['chart.events.mousemove']) {\n          span.addEventListener('mousemove', function (e) {\n            obj.properties['chart.events.mousemove'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.events.click']) {\n          span.addEventListener('click', function (e) {\n            obj.properties['chart.events.click'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.tooltips']) {\n          span.addEventListener(obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click', function (e) {\n            if (!RG.Registry.get('chart.tooltip') || RG.Registry.get('chart.tooltip').__index__ !== 0 || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid) {\n              RG.hideTooltip();RG.redraw();RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);\n            }\n          }, false);\n        }\n      }\n      var ret = {};ret.x = left;ret.y = top;ret.width = offsetWidth;ret.height = offsetHeight;ret.object = obj;ret.text = opt.text;ret.tag = opt.tag;RG.text2.domNodeCache.reset = function () {\n        if (arguments[0]) {\n          if (typeof arguments[0] === 'string') {\n            var ca = document.getElementById(arguments[0]);\n          } else {\n            var ca = arguments[0];\n          }\n          var nodes = RG.text2.domNodeCache[ca.id];for (j in nodes) {\n            var node = RG.text2.domNodeCache[ca.id][j];if (node && node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          }\n          RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n        } else {\n          for (i in RG.text2.domNodeCache) {\n            for (j in RG.text2.domNodeCache[i]) {\n              if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {\n                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);\n              }\n            }\n          }\n          RG.text2.domNodeCache = [];RG.text2.domNodeDimensionCache = [];\n        }\n      };RG.text2.find = function (opt) {\n        var span,\n            nodes = [];var id = typeof opt.id === 'string' ? opt.id : opt.object.id;for (i in RG.text2.domNodeCache[id]) {\n          span = RG.text2.domNodeCache[id][i];if (typeof opt.tag === 'string' && opt.tag === span.tag) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.tag) === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.tag);if (regexp.test(span.tag)) {\n              nodes.push(span);continue;\n            }\n          }\n          if (typeof opt.text === 'string' && opt.text === span.__text__) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.text) === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.text);if (regexp.test(span.__text__)) {\n              nodes.push(span);continue;\n            }\n          }\n        }\n        return nodes;\n      };ret.node = span;if (obj && obj.isRGraph && obj.coordsText) {\n        obj.coordsText.push(ret);\n      }\n      return ret;\n    }\n    if (obj && obj.isRGraph) {\n      var obj = obj;var co = obj.context;var ca = obj.canvas;\n    } else if (typeof obj == 'string') {\n      var ca = document.getElementById(obj);var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (typeof obj.getContext === 'function') {\n      var ca = obj;var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    } else if (RG.ISOLD && obj.fillText) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    }\n    if (typeof opt.boundingFill === 'string') opt['bounding.fill'] = opt.boundingFill;if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {\n      return domtext();\n    }\n    var x = opt.x,\n        y = opt.y,\n        originalX = x,\n        originalY = y,\n        text = opt.text,\n        text_multiline = typeof text === 'string' ? text.split(/\\r?\\n/g) : '',\n        numlines = text_multiline.length,\n        font = opt.font ? opt.font : 'Arial',\n        size = opt.size ? opt.size : 10,\n        size_pixels = size * 1.5,\n        bold = opt.bold,\n        italic = opt.italic,\n        halign = opt.halign ? opt.halign : 'left',\n        valign = opt.valign ? opt.valign : 'bottom',\n        tag = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',\n        marker = opt.marker,\n        angle = opt.angle || 0;\n    var bounding = opt.bounding,\n        bounding_stroke = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',\n        bounding_fill = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',\n        bounding_shadow = opt['bounding.shadow'],\n        bounding_shadow_color = opt['bounding.shadow.color'] || '#ccc',\n        bounding_shadow_blur = opt['bounding.shadow.blur'] || 3,\n        bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,\n        bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,\n        bounding_linewidth = opt['bounding.linewidth'] || 1;var ret = {};if (typeof opt.color === 'string') {\n      var orig_fillstyle = co.fillStyle;co.fillStyle = opt.color;\n    }\n    if (typeof text == 'number') {\n      text = String(text);\n    }\n    if (typeof text !== 'string') {\n      return;\n    }\n    if (angle != 0) {\n      co.save();co.translate(x, y);co.rotate(ma.PI / 180 * angle);\n      x = 0;y = 0;\n    }\n    co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;var width = 0;for (var i = 0; i < numlines; ++i) {\n      width = ma.max(width, co.measureText(text_multiline[i]).width);\n    }\n    var height = size_pixels * numlines;if (opt.marker) {\n      var marker_size = 10;var strokestyle = co.strokeStyle;co.beginPath();co.strokeStyle = 'red';co.moveTo(x, y - marker_size);co.lineTo(x, y + marker_size);co.moveTo(x - marker_size, y);co.lineTo(x + marker_size, y);co.stroke();co.strokeStyle = strokestyle;\n    }\n    if (halign == 'center') {\n      co.textAlign = 'center';var boundingX = x - 2 - width / 2;\n    } else if (halign == 'right') {\n      co.textAlign = 'right';var boundingX = x - 2 - width;\n    } else {\n      co.textAlign = 'left';var boundingX = x - 2;\n    }\n    if (valign == 'center') {\n      co.textBaseline = 'middle';y -= 1;y -= (numlines - 1) / 2 * size_pixels;var boundingY = y - size_pixels / 2 - 2;\n    } else if (valign == 'top') {\n      co.textBaseline = 'top';var boundingY = y - 2;\n    } else {\n      co.textBaseline = 'bottom';if (numlines > 1) {\n        y -= (numlines - 1) * size_pixels;\n      }\n      var boundingY = y - size_pixels - 2;\n    }\n    var boundingW = width + 4;var boundingH = height + 4;if (bounding) {\n      var pre_bounding_linewidth = co.lineWidth;var pre_bounding_strokestyle = co.strokeStyle;var pre_bounding_fillstyle = co.fillStyle;var pre_bounding_shadowcolor = co.shadowColor;var pre_bounding_shadowblur = co.shadowBlur;var pre_bounding_shadowoffsetx = co.shadowOffsetX;var pre_bounding_shadowoffsety = co.shadowOffsetY;co.lineWidth = bounding_linewidth;co.strokeStyle = bounding_stroke;co.fillStyle = bounding_fill;if (bounding_shadow) {\n        co.shadowColor = bounding_shadow_color;co.shadowBlur = bounding_shadow_blur;co.shadowOffsetX = bounding_shadow_offsetx;co.shadowOffsetY = bounding_shadow_offsety;\n      }\n      co.strokeRect(boundingX, boundingY, boundingW, boundingH);co.fillRect(boundingX, boundingY, boundingW, boundingH);co.lineWidth = pre_bounding_linewidth;co.strokeStyle = pre_bounding_strokestyle;co.fillStyle = pre_bounding_fillstyle;co.shadowColor = pre_bounding_shadowcolor;\n      co.shadowBlur = pre_bounding_shadowblur;\n      co.shadowOffsetX = pre_bounding_shadowoffsetx;\n      co.shadowOffsetY = pre_bounding_shadowoffsety;\n    }\n    if (numlines > 1) {\n      for (var i = 0; i < numlines; ++i) {\n        co.fillText(text_multiline[i], x, y + size_pixels * i);\n      }\n    } else {\n      co.fillText(text, x + 0.5, y + 0.5);\n    }\n    if (angle != 0) {\n      if (angle == 90) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      } else if (angle == 180) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        }\n      } else if (angle == 270) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      }\n      co.restore();\n    }\n    co.textBaseline = 'alphabetic';co.textAlign = 'left';ret.x = boundingX;ret.y = boundingY;ret.width = boundingW;ret.height = boundingH;\n    ret.object = obj;ret.text = text;ret.tag = tag;if (obj && obj.isRGraph && obj.coordsText) {\n      obj.coordsText.push(ret);\n    }\n    if (typeof orig_fillstyle === 'string') {\n      co.fillStyle = orig_fillstyle;\n    }\n    return ret;\n  };RG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0;var grouped_index = 0;while (--index >= 0) {\n      if (RG.is_null(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.Highlight.rect = RG.Highlight.Rect = function (obj, shape) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;if (prop['chart.tooltips.highlight']) {\n      co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.rect(shape['x'], shape['y'], shape['width'], shape['height']);co.stroke();co.fill();\n    }\n  };RG.Highlight.point = RG.Highlight.Point = function (obj, shape) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (prop['chart.tooltips.highlight']) {\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];var radius = prop['chart.highlight.point.radius'] || 2;co.arc(shape['x'], shape['y'], radius, 0, RG.TWOPI, 0);co.stroke();co.fill();\n    }\n  };RG.parseDate = function (str) {\n    str = RG.trim(str);if (str === 'now') {\n      str = new Date().toString();\n    }\n    if (str.match(/^(\\d\\d)(?:-|\\/)(\\d\\d)(?:-|\\/)(\\d\\d\\d\\d)(.*)$/)) {\n      str = '{1}/{2}/{3}{4}'.format(RegExp.$3, RegExp.$2, RegExp.$1, RegExp.$4);\n    }\n    if (str.match(/^(\\d\\d\\d\\d)(-|\\/)(\\d\\d)(-|\\/)(\\d\\d)( |T)(\\d\\d):(\\d\\d):(\\d\\d)$/)) {\n      str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;\n    }\n    if (str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d$/)) {\n      str = str.replace(/-/g, '/');\n    }\n    if (str.match(/^\\d\\d:\\d\\d:\\d\\d$/)) {\n      var dateObj = new Date();var date = dateObj.getDate();var month = dateObj.getMonth() + 1;var year = dateObj.getFullYear();if (String(month).length === 1) month = '0' + month;if (String(date).length === 1) date = '0' + date;str = year + '/' + month + '/' + date + ' ' + str;\n    }\n    return Date.parse(str);\n  };RG.resetColorsToOriginalValues = function (obj) {\n    if (obj.original_colors) {\n      for (var j in obj.original_colors) {\n        if (typeof j === 'string' && j.substr(0, 6) === 'chart.') {\n          obj.properties[j] = RG.arrayClone(obj.original_colors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.colorsParsed = false;\n  };RG.linearGradient = RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2) {\n    var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);var numColors = arguments.length - 5;for (var i = 5; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 5) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.radialGradient = RG.RadialGradient = function (obj, x1, y1, r1, x2, y2, r2, color1, color2) {\n    var gradient = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);var numColors = arguments.length - 7;for (var i = 7; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 7) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.addEventListener = RG.AddEventListener = function (id, e, func) {\n    var type = arguments[3] ? arguments[3] : 'unknown';RG.Registry.get('chart.event.handlers').push([id, e, func, type]);\n  };RG.clearEventListeners = RG.ClearEventListeners = function (id) {\n    if (id && id == 'window') {\n      window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);\n    } else {\n      var canvas = document.getElementById(id);canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);\n    }\n  };RG.hidePalette = RG.HidePalette = function () {\n    var div = RG.Registry.get('palette');if ((typeof div === 'undefined' ? 'undefined' : _typeof(div)) == 'object' && div) {\n      div.style.visibility = 'hidden';div.style.display = 'none';RG.Registry.set('palette', null);\n    }\n  };RG.random = function (min, max) {\n    var dp = arguments[2] ? arguments[2] : 0;var r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.arrayRand = RG.arrayRandom = RG.random.array = function (num, min, max) {\n    for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.random(min, max, arguments[3]));\n    }\n    return arr;\n  };RG.noShadow = RG.NoShadow = function (obj) {\n    var co = obj.context;co.shadowColor = 'rgba(0,0,0,0)';co.shadowBlur = 0;co.shadowOffsetX = 0;co.shadowOffsetY = 0;\n  };RG.setShadow = RG.SetShadow = function (obj, color, offsetx, offsety, blur) {\n    var co = obj.context;co.shadowColor = color;co.shadowOffsetX = offsetx;co.shadowOffsetY = offsety;co.shadowBlur = blur;\n  };RG.Registry.set = RG.Registry.Set = function (name, value) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    RG.Registry.store[name] = value;return value;\n  };RG.Registry.get = RG.Registry.Get = function (name) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    return RG.Registry.store[name];\n  };RG.degrees2Radians = function (deg) {\n    return deg * (RG.PI / 180);\n  };RG.log = function (n, base) {\n    return ma.log(n) / (base ? ma.log(base) : 1);\n  };RG.isArray = RG.is_array = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.trim = function (str) {\n    return RG.ltrim(RG.rtrim(str));\n  };RG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.isNull = RG.is_null = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.async = RG.Async = function (func) {\n    return setTimeout(func, arguments[1] ? arguments[1] : 1);\n  };RG.reset = RG.Reset = function (ca) {\n    ca.width = ca.width;RG.ObjectRegistry.clear(ca);ca.__rgraph_aa_translated__ = false;if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {\n      RG.text2.domNodeCache.reset(ca);\n    }\n    if (!RG.text2.domNodeCache) {\n      RG.text2.domNodeCache = [];\n    }\n    if (!RG.text2.domNodeDimensionCache) {\n      RG.text2.domNodeDimensionCache = [];\n    }\n    RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n  };RG.att = RG.attribution = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties;if (!ca || !co) {\n      return;\n    }\n    var width = ca.width,\n        height = ca.height,\n        wrapper = document.getElementById('cvs').__object__.canvas.parentNode,\n        text = prop['chart.attribution.text'] || 'Free Charts with RGraph.net',\n        x = prop['chart.attribution.x'],\n        y = prop['chart.attribution.y'],\n        bold = prop['chart.attribution.bold'],\n        italic = prop['chart.attribution.italic'],\n        font = prop['chart.attribution.font'] || 'sans-serif',\n        size = prop['chart.attribution.size'] || 8,\n        underline = prop['chart.attribution.underline'] ? 'underline' : 'none',\n        color = typeof prop['chart.attribution.color'] === 'string' ? prop['chart.attribution.color'] : '',\n        href = typeof prop['chart.attribution.href'] === 'string' ? prop['chart.attribution.href'] : 'http://www.rgraph.net/canvas/index.html';if (wrapper.attribution_node) {\n      return;\n    }\n    var measurements = RG.measureText(text, bold, font, size);var a = document.createElement('A');a.href = href;a.innerHTML = text;a.target = '_blank';a.style.position = 'absolute';a.style.left = typeof x === 'number' ? x : wrapper.offsetWidth - measurements[0] - 5 + 'px';a.style.top = typeof y === 'number' ? y : wrapper.offsetHeight - measurements[1] + 'px';a.style.fontSize = size + 'pt';a.style.fontStyle = typeof italic === 'boolean' ? italic ? 'italic' : '' : 'italic', a.style.fontWeight = bold ? 'bold' : '', a.style.textDecoration = underline;a.style.fontFamily = font;a.style.color = color;wrapper.appendChild(a);wrapper.attribution_node = a;\n  };RG.getCanvasTag = function (id) {\n    id = (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' ? id.id : id;var canvas = doc.getElementById(id);return [id, canvas];\n  };RG.Effects.updateCanvas = RG.Effects.UpdateCanvas = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.Effects.getEasingMultiplier = function (frames, frame) {\n    return ma.pow(ma.sin(frame / frames * RG.HALFPI), 3);\n  };RG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.cachedDraw = function (obj, id, func) {\n    if (!RG.cache[id]) {\n      RG.cache[id] = {};RG.cache[id].object = obj;RG.cache[id].canvas = document.createElement('canvas');RG.cache[id].canvas.setAttribute('width', obj.canvas.width);RG.cache[id].canvas.setAttribute('height', obj.canvas.height);RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);RG.cache[id].canvas.__object__ = obj;RG.cache[id].context = RG.cache[id].canvas.getContext('2d');RG.cache[id].context.translate(0.5, 0.5);func(obj, RG.cache[id].canvas, RG.cache[id].context);\n    }\n    obj.context.drawImage(RG.cache[id].canvas, -0.5, -0.5);\n  };RG.parseObjectStyleConfig = function (obj, config) {\n    var recurse = function recurse(obj, config, name, settings) {\n      var i;for (key in config) {\n        if (key.match(/^exec[0-9]*$/)) {\n          config[key](obj, settings);continue;\n        }\n        var isObject = false;var isArray = false;var value = config[key];while (key.match(/([A-Z])/)) {\n          key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n        }\n        if (!RG.isNull(value) && value.constructor) {\n          isObject = value.constructor.toString().indexOf('Object') > 0;isArray = value.constructor.toString().indexOf('Array') > 0;\n        }\n        if (isObject && !isArray) {\n          recurse(obj, config[key], name + '.' + key, settings);\n        } else if (key === 'self') {\n          settings[name] = value;\n        } else {\n          settings[name + '.' + key] = value;\n        }\n      }\n      return settings;\n    };var settings = recurse(obj, config, 'chart', {});for (key in settings) {\n      if (typeof key === 'string') {\n        obj.set(key, settings[key]);\n      }\n    }\n  };RG.path2 = function (co, p) {\n    var args = arguments;if (typeof p === 'string') {\n      p = splitstring(p);\n    }\n    RG.path2.last = RG.arrayClone(p);for (var i = 0, len = p.length; i < len; i += 1) {\n      switch (p[i]) {case 'b':\n          co.beginPath();break;case 'c':\n          co.closePath();break;case 'm':\n          co.moveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'l':\n          co.lineTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 's':\n          if (p[i + 1]) co.strokeStyle = p[i + 1];co.stroke();i++;break;case 'f':\n          if (p[i + 1]) {\n            co.fillStyle = p[i + 1];\n          }co.fill();i++;break;case 'qc':\n          co.quadraticCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'bc':\n          co.bezierCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'r':\n          co.rect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'a':\n          co.arc(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), p[i + 6] === 'true' || p[i + 6] === true || p[i + 6] === 1 || p[i + 6] === '1' ? true : false);i += 6;break;case 'at':\n          co.arcTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]));i += 5;break;case 'lw':\n          co.lineWidth = parseFloat(p[i + 1]);i++;break;case 'e':\n          co.ellipse(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]), parseFloat(p[i + 7]), p[i + 8] === 'true' ? true : false);i += 8;break;case 'lj':\n          co.lineJoin = p[i + 1];i++;break;case 'lc':\n          co.lineCap = p[i + 1];i++;break;case 'sc':\n          co.shadowColor = p[i + 1];i++;break;case 'sb':\n          co.shadowBlur = parseFloat(p[i + 1]);i++;break;case 'sx':\n          co.shadowOffsetX = parseFloat(p[i + 1]);i++;break;case 'sy':\n          co.shadowOffsetY = parseFloat(p[i + 1]);i++;break;case 'fs':\n          co.fillStyle = p[i + 1];i++;break;case 'ss':\n          co.strokeStyle = p[i + 1];i++;break;case 'fr':\n          co.fillRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'sr':\n          co.strokeRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'cl':\n          co.clip();break;case 'sa':\n          co.save();break;case 'rs':\n          co.restore();break;case 'tr':\n          co.translate(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'sl':\n          co.scale(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'ro':\n          co.rotate(parseFloat(p[i + 1]));i++;break;case 'tf':\n          co.transform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'stf':\n          co.setTransform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'cr':\n          co.clearRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'ld':\n          var parts = p[i + 1];co.setLineDash(parts);i += 1;break;case 'ldo':\n          co.lineDashOffset = p[i + 1];i++;break;case 'fo':\n          co.font = p[i + 1];i++;break;case 'ft':\n          co.fillText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'st':\n          co.strokeText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'ta':\n          co.textAlign = p[i + 1];i++;break;case 'tbl':\n          co.textBaseline = p[i + 1];i++;break;case 'ga':\n          co.globalAlpha = parseFloat(p[i + 1]);i++;break;case 'gco':\n          co.globalCompositeOperation = p[i + 1];i++;break;case 'fu':\n          p[i + 1](co.canvas.__object__);i++;break;case '':\n          break;default:\n          alert('[ERROR] Unknown option: ' + p[i]);}\n    }\n    function splitstring(p) {\n      var ret = [],\n          buffer = '',\n          inquote = false,\n          quote = '',\n          substitutionIndex = 2;for (var i = 0; i < p.length; i += 1) {\n        var chr = p[i],\n            isWS = chr.match(/ /);if (isWS) {\n          if (!inquote) {\n            if (buffer[0] === '\"' || buffer[0] === \"'\") {\n              buffer = buffer.substr(1, buffer.length - 2);\n            }\n            if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\n              buffer = args[substitutionIndex++];\n            }\n            ret.push(buffer);buffer = '';\n          } else {\n            buffer += chr;\n          }\n        } else {\n          if (chr === \"'\" || chr === '\"') {\n            inquote = !inquote;\n          }\n          buffer += chr;\n        }\n      }\n      if (buffer.trim() === '%' && args[substitutionIndex]) {\n        buffer = args[substitutionIndex++];\n      }\n      ret.push(buffer);return ret;\n    }\n  };RG.wrap = function () {};\n})(window, document);window.$p = function (v) {\n  RGraph.pr(arguments[0], arguments[1], arguments[3]);\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.core.js\n// module id = 166\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.core.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.uid = RGraph.createUID();this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.csv.js\n// module id = 167\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.csv.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.text = RG.Text = function (context, font, size, x, y, text) {\n    var args = arguments;if (typeof text != 'string' && typeof text != 'number' || text == 'undefined') {\n      return;\n    }\n    if (typeof text == 'string' && text.match(/\\r\\n/)) {\n      var dimensions = RGraph.MeasureText('M', args[11], font, size);var arr = text.split('\\r\\n');if (args[6] && args[6] == 'center') y = y - dimensions[1] * ((arr.length - 1) / 2);for (var i = 1; i < arr.length; ++i) {\n        RGraph.Text(context, font, size, args[9] == -90 ? x + size * 1.5 : x, y + dimensions[1] * i, arr[i], args[6] ? args[6] : null, args[7], args[8], args[9], args[10], args[11], args[12]);\n      }\n      text = arr[0];\n    }\n    if (document.all && RGraph.ISOLD) {\n      y += 2;\n    }\n    context.font = (args[11] ? 'Bold ' : '') + size + 'pt ' + font;var i;var origX = x;var origY = y;var originalFillStyle = context.fillStyle;var originalLineWidth = context.lineWidth;if (typeof args[6] == 'undefined') args[6] = 'bottom';if (typeof args[7] == 'undefined') args[7] = 'left';if (typeof args[8] == 'undefined') args[8] = null;if (typeof args[9] == 'undefined') args[9] = 0;if (navigator.userAgent.indexOf('Opera') != -1) {\n      context.canvas.__rgraph_valign__ = args[6];context.canvas.__rgraph_halign__ = args[7];\n    }\n    context.save();context.canvas.__rgraph_originalx__ = x;context.canvas.__rgraph_originaly__ = y;context.translate(x, y);x = 0;y = 0;if (args[9]) {\n      context.rotate(args[9] / (180 / RGraph.PI));\n    }\n    if (args[6]) {\n      var vAlign = args[6];if (vAlign == 'center') {\n        context.textBaseline = 'middle';\n      } else if (vAlign == 'top') {\n        context.textBaseline = 'top';\n      }\n    }\n    if (args[7]) {\n      var hAlign = args[7];var width = context.measureText(text).width;if (hAlign) {\n        if (hAlign == 'center') {\n          context.textAlign = 'center';\n        } else if (hAlign == 'right') {\n          context.textAlign = 'right';\n        }\n      }\n    }\n    context.fillStyle = originalFillStyle;context.save();context.fillText(text, 0, 0);context.lineWidth = 1;var width = context.measureText(text).width;var width_offset = hAlign == 'center' ? width / 2 : hAlign == 'right' ? width : 0;var height = size * 1.5;var height_offset = vAlign == 'center' ? height / 2 : vAlign == 'top' ? height : 0;var ieOffset = RGraph.ISOLD ? 2 : 0;if (args[8]) {\n      context.strokeRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);if (args[10]) {\n        context.fillStyle = args[10];context.fillRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);\n      }\n      context.fillStyle = originalFillStyle;context.fillText(text, 0, 0);\n    }\n    context.restore();context.lineWidth = originalLineWidth;context.restore();\n  };RG.getMouseXY = function (e) {\n    var el = RGraph.ISOLD ? event.srcElement : e.target;var x;var y;var paddingLeft = el.style.paddingLeft ? parseInt(el.style.paddingLeft) : 0;var paddingTop = el.style.paddingTop ? parseInt(el.style.paddingTop) : 0;var borderLeft = el.style.borderLeftWidth ? parseInt(el.style.borderLeftWidth) : 0;var borderTop = el.style.borderTopWidth ? parseInt(el.style.borderTopWidth) : 0;if (RGraph.ISIE8) e = event;if (typeof e.offsetX == 'number' && typeof e.offsetY == 'number') {\n      x = e.offsetX;y = e.offsetY;\n    } else {\n      x = 0;y = 0;while (el != document.body && el) {\n        x += el.offsetLeft;y += el.offsetTop;el = el.offsetParent;\n      }\n      x = e.pageX - x;y = e.pageY - y;\n    }\n    return [x, y];\n  };RG.oldBrowserCompat = RG.OldBrowserCompat = function (co) {\n    if (!co) {\n      return;\n    }\n    if (!co.measureText) {\n      co.measureText = function (text) {\n        var textObj = document.createElement('DIV');textObj.innerHTML = text;textObj.style.position = 'absolute';textObj.style.top = '-100px';textObj.style.left = 0;document.body.appendChild(textObj);var width = { width: textObj.offsetWidth };textObj.style.display = 'none';return width;\n      };\n    }\n    if (!co.fillText) {\n      co.fillText = function (text, targetX, targetY) {\n        return false;\n      };\n    }\n    if (!co.canvas.addEventListener) {\n      window.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n      co.canvas.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n    }\n  };RG.each = function (arr, func) {\n    for (var i = 0, len = arr.length; i < len; i += 1) {\n      if (typeof arguments[2] !== 'undefined') {\n        var ret = func.call(arguments[2], i, arr[i]);\n      } else {\n        var ret = func.call(arr, i, arr[i]);\n      }\n      if (ret === false) {\n        return;\n      }\n    }\n  };RG.getHeight = RG.GetHeight = function (obj) {\n    return obj.canvas.height;\n  };RG.getWidth = RG.GetWidth = function (obj) {\n    return obj.canvas.width;\n  };RG.timer = RG.Timer = function (label) {\n    if (typeof RG.TIMER_LAST_CHECKPOINT == 'undefined') {\n      RG.TIMER_LAST_CHECKPOINT = Date.now();\n    }\n    var now = Date.now();console.log(label + ': ' + (now - RG.TIMER_LAST_CHECKPOINT).toString());RG.TIMER_LAST_CHECKPOINT = now;\n  };RG.setConfig = RG.SetConfig = function (obj, config) {\n    for (i in config) {\n      if (typeof i === 'string') {\n        obj.Set(i, config[i]);\n      }\n    }\n    return obj;\n  };\n})(window, document);window.$empty = function (value) {\n  if (!value || value.length <= 0) {\n    return true;\n  }\n  return false;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.deprecated.js\n// module id = 168\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.deprecated.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.installWindowMousedownListener = RG.InstallWindowMousedownListener = function (obj) {\n    if (!RG.window_mousedown_event_listener) {\n      RG.window_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {\n          RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);RG.redraw();RG.hideTooltip();\n        }\n      };win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);\n    }\n  };RG.installWindowMouseupListener = RG.InstallWindowMouseupListener = function (obj) {\n    if (!RG.window_mouseup_event_listener) {\n      RG.window_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.annotating_window_onmouseup) {\n          RG.annotating_window_onmouseup(e);return;\n        }\n        if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {\n          var obj = RG.Registry.Get('chart.adjusting');if (obj && obj.type === 'line') {\n            obj.data_arr = RG.arrayLinearize(obj.data);\n          }\n          RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');\n        }\n        RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);var tags = document.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n          if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n            if (!tags[i].__object__.get('chart.annotatable')) {\n              if (!tags[i].__rgraph_trace_cover__ && !noredraw) {\n                RG.clear(tags[i]);\n              } else {\n                var noredraw = true;\n              }\n            }\n          }\n        }\n        if (!noredraw) {\n          RG.redraw();\n        }\n      };win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMouseupListener = RG.InstallCanvasMouseupListener = function (obj) {\n    if (!obj.canvas.rgraph_mouseup_event_listener) {\n      obj.canvas.rgraph_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);if (objects) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i],\n                id = objects[i].id;var link = obj.Get('link');if (obj.type == 'drawing.text' && typeof link === 'string') {\n              var link_target = obj.get('link.target');var link_options = obj.get('link.options');window.open(link, link_target ? link_target : null, link_options);\n            }\n            if (!RG.isNull(obj) && RG.tooltip) {\n              var shape = obj.getShape(e);if (shape && shape['tooltip']) {\n                var text = shape['tooltip'];if (text) {\n                  var type = shape['object'].type;RG.clear(obj.canvas);RG.redraw();RG.Registry.set('chart.tooltip.shape', shape);RG.tooltip(obj, text, 0, 0, shape['index'], e);obj.highlight(shape);if (RG.Registry.get('chart.tooltip')) {\n                    RG.Registry.get('chart.tooltip').__shape__ = shape;RG.evaluateCursor(e);\n                  }\n                  e.cancelBubble = true;e.stopPropagation();return false;\n                }\n              }\n            }\n            if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {\n              if (obj && obj.type === 'line') {\n                obj.data_arr = RG.arrayLinearize(obj.data);\n              }\n              RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');\n            }\n            RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n        }\n      };obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMousemoveListener = RG.InstallCanvasMousemoveListener = function (obj) {\n    if (!obj.canvas.rgraph_mousemove_event_listener) {\n      obj.canvas.rgraph_mousemove_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.OR.getObjectsByXY(e);var uids = [];if (objects && objects.length > 0) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i];var id = obj.id;uids[obj.uid] = true;if (!obj.getShape) {\n              continue;\n            }\n            var shape = obj.getShape(e);if (!shape && typeof obj.__mouseover_shape_index__ === 'number' || shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__) {\n              RG.fireCustomEvent(obj, 'onmouseout');\n            }\n            if (obj.coords && obj.coords.key && obj.coords.key.length) {\n              var mouseXY = RG.getMouseXY(e);for (var i = 0, overkey = false; i < obj.coords.key.length; ++i) {\n                if (mouseXY[0] >= obj.coords.key[i][0] && mouseXY[0] <= obj.coords.key[i][0] + obj.coords.key[i][2] && mouseXY[1] >= obj.coords.key[i][1] && mouseXY[1] <= obj.coords.key[i][1] + obj.coords.key[i][3]) {\n                  RG.Registry.set('key-element', obj.coords.key[i]);overkey = true;\n                }\n                if (!overkey) {\n                  RG.Registry.set('key-element', null);\n                }\n              }\n            }\n            var func = obj.get('chart.events.mousemove');if (!func && typeof obj.onmousemove == 'function') {\n              var func = obj.onmousemove;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmousemove == 'function') {\n                var func2 = obj['$' + index].onmousemove;\n              }\n            }\n            if (shape && (typeof func == 'function' || typeof func2 == 'function' || typeof obj.Get('link') === 'string')) {\n              if (obj.Get('chart.events.mousemove.revertto') == null) {\n                obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);\n              }\n              if (typeof func == 'function') RGraph.custom_events_mousemove_pointer = func(e, shape);if (typeof func2 == 'function') RGraph.custom_events_mousemove_pointer = RGraph.custom_events_mousemove_pointer || func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                for (i in RG.events[obj.uid]) {\n                  if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmousemove' && typeof RG.events[obj.uid][i][2] === 'function') {\n                    RG.events[obj.uid][i][2](obj);\n                  }\n                }\n              }\n            } else if (typeof obj.Get('chart.events.mousemove.revertto') == 'string') {\n              RG.cursor.push('default');obj.Set('chart.events.mousemove.revertto', null);\n            }\n            var func = obj.properties['chart.events.mouseover'];if (!func && typeof obj.onmouseover === 'function') {\n              func = obj.onmouseover;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmouseover == 'function') {\n                var func2 = obj['$' + index].onmouseover;\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            if (typeof RG.__mouseover_objects__ === 'undefined') {\n              RG.__mouseover_objects__ = [];\n            }\n            if (shape) {\n              if (obj.__mouseover_shape_index__ === shape.index === false) {\n                obj.__mouseover_shape_index__ = shape.index;RG.__mouseover_objects__.push(obj);if (func) func(e, shape);if (func2) func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                  for (i in RG.events[obj.uid]) {\n                    if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmouseover' && typeof RG.events[obj.uid][i][2] === 'function') {\n                      RG.events[obj.uid][i][2](obj);\n                    }\n                  }\n                }\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            var current_tooltip = RG.Registry.get('chart.tooltip');var tooltips = obj.get('chart.tooltips');var tooltips_event = obj.Get('chart.tooltips.event');if (shape && (tooltips && tooltips[shape['index']] || shape['tooltip']) && tooltips_event.indexOf('mousemove') !== -1 && (RG.isNull(current_tooltip) || obj.uid != current_tooltip.__object__.uid || current_tooltip.__index__ != shape['index'] || typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])) {\n              RG.clear(obj.canvas);RG.hideTooltip();RG.redraw();obj.canvas.rgraph_mouseup_event_listener(e);return;\n            }\n            if (obj && obj.get('chart.adjustable')) {\n              obj.Adjusting_mousemove(e);\n            }\n            if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; ++i) {\n            if (!uids[objects[i].uid]) {\n              objects[i].__mouseover_shape_index__ = null;\n            }\n          }\n        } else {\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; i++) {\n            if (typeof objects[i].__mouseover_shape_index__ === 'number') {\n              RG.fireCustomEvent(objects[i], 'onmouseout');\n            }\n            objects[i].__mouseover_shape_index__ = null;\n          }\n          RG.__mouseover_objects__ = [];\n        }\n        if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {\n          RG.drawCrosshairs(e, e.target.__object__);\n        }\n        if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {\n          RG.annotating_canvas_onmousemove(e);\n        }\n        RG.evaluateCursor(e);\n      };obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);\n    }\n  };RG.installCanvasMousedownListener = RG.InstallCanvasMousedownListener = function (obj) {\n    if (!obj.canvas.rgraph_mousedown_event_listener) {\n      obj.canvas.rgraph_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {\n          RG.annotating_canvas_onmousedown(e);return;\n        }\n        var obj = RG.ObjectRegistry.getObjectByXY(e);if (obj) {\n          var id = obj.id;if (obj && obj.isRGraph && obj.get('chart.adjustable')) {\n            var obj = RG.OR.getObjectByXY(e);if (obj && obj.isRGraph) {\n              switch (obj.type) {case 'bar':\n                  var shape = obj.getShapeByX(e);break;case 'gantt':\n                  var shape = obj.getShape(e);var data = typeof shape.subindex === 'number' ? obj.data[shape.index][shape.subindex] : obj.data[shape.index];if (shape) {\n                    var mouseXY = RG.getMouseXY(e);RG.Registry.set('chart.adjusting.gantt', { index: shape.index, subindex: shape.subindex, object: obj, mousex: mouseXY[0], mousey: mouseXY[1], event: data, event_start: data[0], event_duration: data[1], mode: mouseXY[0] > shape['x'] + shape['width'] - 5 ? 'resize' : 'move', shape: shape });\n                  }\n                  break;case 'line':\n                  var shape = obj.getShape(e);break;case 'hbar':\n                  var shape = obj.getShapeByY(e);break;default:\n                  var shape = null;}\n              if (RG.isNull(obj.properties['chart.adjustable.only']) || typeof obj.properties['chart.adjustable.only'] === 'undefined' || RG.isArray(obj.properties['chart.adjustable.only']) && obj.isAdjustable && obj.isAdjustable(shape)) {\n                RG.Registry.set('chart.adjusting.shape', shape);RG.fireCustomEvent(obj, 'onadjustbegin');RG.Registry.set('chart.adjusting', obj);RG.clear(obj.canvas);RG.redraw();obj.canvas.rgraph_mousemove_event_listener(e);\n              }\n            }\n          }\n          RG.clear(obj.canvas);RG.redraw();\n        }\n      };obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);\n    }\n  };RG.installCanvasClickListener = RG.InstallCanvasClickListener = function (obj) {\n    if (!obj.canvas.rgraph_click_event_listener) {\n      obj.canvas.rgraph_click_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);for (var i = 0, len = objects.length; i < len; i += 1) {\n          var obj = objects[i];var id = obj.id;var shape = obj.getShape(e);var func = obj.get('chart.events.click');if (!func && typeof obj.onclick == 'function') {\n            func = obj.onclick;\n          }\n          if (shape && typeof func == 'function') {\n            func(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n              for (i in RG.events[obj.uid]) {\n                if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onclick' && typeof RG.events[obj.uid][i][2] === 'function') {\n                  RG.events[obj.uid][i][2](obj);\n                }\n              }\n            }\n            return;\n          }\n          var key = RG.Registry.get('key-element');if (key) {\n            RG.fireCustomEvent(obj, 'onkeyclick');\n          }\n          if (shape) {\n            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (typeof index == 'number' && obj['$' + index]) {\n              var func = obj['$' + index].onclick;if (typeof func == 'function') {\n                func(e, shape);return;\n              }\n            }\n          }\n          if (shape || obj.overChartArea && obj.overChartArea(e)) {\n            break;\n          }\n        }\n      };obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);\n    }\n  };RG.evaluateCursor = RG.EvaluateCursor = function (e) {\n    var obj = null;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var canvas = e.target;var objects = RG.OR.getObjectsByCanvasID(canvas.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i].getShape && objects[i].getShape(e) || objects[i].overChartArea && objects[i].overChartArea(e)) {\n        var obj = objects[i];var id = obj.id;\n      }\n    }\n    if (!RG.isNull(obj)) {\n      if (obj.getShape && obj.getShape(e)) {\n        var shape = obj.getShape(e);if (obj.get('chart.tooltips')) {\n          var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {\n            text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);\n          }\n          if (text) {\n            var pointer = true;\n          }\n        }\n      }\n      if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {\n        for (var j = 0; j < obj.coords.key.length; ++j) {\n          if (mouseX > obj.coords.key[j][0] && mouseX < obj.coords.key[j][0] + obj.coords.key[j][2] && mouseY > obj.coords.key[j][1] && mouseY < obj.coords.key[j][1] + obj.coords.key[j][3]) {\n            var pointer = true;\n          }\n        }\n      }\n    }\n    if (RGraph.custom_events_mousemove_pointer) {\n      var pointer = true;RGraph.custom_events_mousemove_pointer = false;\n    }\n    var objects = RG.OR.objects.byCanvasID;for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i] && objects[i][1].Get('chart.resizable')) {\n        var resizable = true;\n      }\n    }\n    if (resizable && mouseX > e.target.width - 32 && mouseY > e.target.height - 16) {\n      pointer = true;\n    }\n    if (pointer) {\n      e.target.style.cursor = 'pointer';\n    } else if (e.target.style.cursor == 'pointer') {\n      e.target.style.cursor = 'default';\n    } else {\n      e.target.style.cursor = null;\n    }\n    if (resizable && mouseX >= e.target.width - 15 && mouseY >= e.target.height - 15) {\n      e.target.style.cursor = 'move';\n    } else if (e.target.style.cursor === 'move') {\n      e.target.style.cursor = 'default';\n    }\n    if (typeof mouse_over_key == 'boolean' && mouse_over_key) {\n      e.target.style.cursor = 'pointer';\n    }\n    if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {\n      if (obj.getShape) {\n        var shape = obj.getShape(e);if (shape && obj.isAdjustable(shape)) {\n          e.target.style.cursor = 'ns-resize';\n        }\n      } else {\n        e.target.style.cursor = 'default';\n      }\n    }\n    if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {\n      e.target.style.cursor = 'crosshair';\n    }\n    if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {\n      e.target.style.cursor = 'pointer';\n    }\n  };RG.parseTooltipText = function (tooltips, idx) {\n    if (!tooltips) {\n      return null;\n    }\n    if (typeof tooltips == 'function') {\n      var text = tooltips(idx);\n    } else if (typeof tooltips == 'string') {\n      var text = tooltips;\n    } else if ((typeof tooltips === 'undefined' ? 'undefined' : _typeof(tooltips)) == 'object' && typeof tooltips[idx] == 'function') {\n      var text = tooltips[idx](idx);\n    } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {\n      var text = tooltips[idx];\n    } else {\n      var text = '';\n    }\n    if (text == 'undefined') {\n      text = '';\n    } else if (text == 'null') {\n      text = '';\n    }\n    return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;\n  };RG.drawCrosshairs = RG.DrawCrosshairs = function (e, obj) {\n    var e = RG.fixEventObject(e),\n        width = obj.canvas.width,\n        height = obj.canvas.height,\n        mouseXY = RG.getMouseXY(e),\n        x = mouseXY[0],\n        y = mouseXY[1],\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        Mathround = Math.round,\n        prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;\n    RG.redrawCanvas(ca);if (x >= gutterLeft && y >= gutterTop && x <= width - gutterRight && y <= height - gutterBottom) {\n      var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;co.lineWidth = linewidth ? linewidth : 1;co.beginPath();co.strokeStyle = prop['chart.crosshairs.color'];if (prop['chart.crosshairs.snap']) {\n        var point = null;var dist = null;var len = null;if (obj.type == 'line') {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);if (typeof dist != 'number' || length < dist) {\n              var point = i;var dist = length;\n            }\n          }\n          x = obj.coords[point][0];y = obj.coords[point][1];for (var dataset = 0; dataset < obj.coords2.length; ++dataset) {\n            for (var point = 0; point < obj.coords2[dataset].length; ++point) {\n              if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {\n                ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;\n              }\n            }\n          }\n        } else {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            for (var j = 0; j < obj.coords[i].length; ++j) {\n              var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);if (typeof dist != 'number' || len < dist) {\n                var dataset = i;var point = j;var dist = len;\n              }\n            }\n          }\n          ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;x = obj.coords[dataset][point][0];y = obj.coords[dataset][point][1];\n        }\n      }\n      if (prop['chart.crosshairs.vline']) {\n        co.moveTo(Mathround(x), Mathround(gutterTop));co.lineTo(Mathround(x), Mathround(height - gutterBottom));\n      }\n      if (prop['chart.crosshairs.hline']) {\n        co.moveTo(Mathround(gutterLeft), Mathround(y));co.lineTo(Mathround(width - gutterRight), Mathround(y));\n      }\n      co.stroke();if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {\n        var xCoord = (x - gutterLeft) / (width - gutterLeft - gutterRight) * (prop['chart.xmax'] - prop['chart.xmin']) + prop['chart.xmin'];xCoord = xCoord.toFixed(prop['chart.scale.decimals']);var yCoord = obj.max - (y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom) * obj.max;if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {\n          yCoord = (yCoord - obj.max / 2) * 2;\n        }\n        yCoord = yCoord.toFixed(prop['chart.scale.decimals']);var div = RG.Registry.get('chart.coordinates.coords.div');var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(ca);if (!div) {\n          var div = document.createElement('DIV');div.__object__ = obj;div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.fontFamily = 'Arial, Verdana, sans-serif';div.style.fontSize = '10pt';\n          div.style.padding = '2px';div.style.opacity = 1;div.style.WebkitBorderRadius = '3px';div.style.borderRadius = '3px';div.style.MozBorderRadius = '3px';document.body.appendChild(div);RG.Registry.set('chart.coordinates.coords.div', div);\n        }\n        div.style.opacity = 1;div.style.display = 'inline';if (!prop['chart.crosshairs.coords.fixed']) {\n          div.style.left = ma.max(2, e.pageX - div.offsetWidth - 3) + 'px';div.style.top = ma.max(2, e.pageY - div.offsetHeight - 3) + 'px';\n        } else {\n          div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';div.style.top = canvasXY[1] + gutterTop + 3 + 'px';\n        }\n        div.innerHTML = '<span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);ca.__crosshairs_labels__ = div;ca.__crosshairs_x__ = xCoord;ca.__crosshairs_y__ = yCoord;\n      } else if (prop['chart.crosshairs.coords']) {\n        alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');\n      }\n      RG.fireCustomEvent(obj, 'oncrosshairs');\n    } else {\n      RG.hideCrosshairCoords();\n    }\n  };RG.allowSegmentHighlight = function (opt) {\n    var obj = opt.object,\n        count = opt.count,\n        fill = opt.fill,\n        stroke = opt.stroke;\n    if (!RG.segmentHighlightFunction) {\n      RG.segmentHighlightFunction = function (e) {\n        var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (angle > RG.TWOPI) {\n          angle -= RG.TWOPI;\n        }\n        RG.redraw();var start = 0;var end = 0;var a = ma.PI * 2 / count;var r = obj.radius;(function () {\n          for (i = 0; i < count; i += 1) {\n            if (angle < a * (i + 1)) {\n              start = i * a;end = (i + 1) * a;return;\n            }\n          }\n        })();start -= RG.HALFPI;end -= RG.HALFPI;RG.path2(obj.context, 'b m % % a % % % % % false c s % f %', obj.centerx, obj.centery, obj.centerx, obj.centery, r, start, end, stroke, fill);\n      };obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);\n    }\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.dynamic.js\n// module id = 169\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.dynamic.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Common = {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Effects.decorate = function (obj) {\n    for (i in RG.Effects.Common) {\n      if (typeof RG.Effects.Common[i] === 'function') {\n        obj[i] = RG.Effects.Common[i];\n      }\n    }\n  };RG.Effects.replaceCanvasWithDIV = RG.Effects.ReplaceCanvasWithDIV = RG.Effects.wrap = function (canvas) {\n    if (!canvas.rgraph_wrapper) {\n      var div = $('<div></div>').css({ width: canvas.width + 'px', height: canvas.height + 'px', cssFloat: canvas.style.cssFloat, left: canvas.style.left, top: canvas.style.top, display: 'inline-block' }).get(0);canvas.parentNode.insertBefore(div, canvas);canvas.parentNode.removeChild(canvas);div.appendChild(canvas);canvas.style.position = 'relative';canvas.style.left = div.offsetWidth / 2 + 'px';canvas.style.top = div.offsetHeight / 2 + 'px';canvas.style.cssFloat = '';canvas.rgraph_wrapper = div;\n    }\n    var div = canvas.rgraph_wrapper;return div;\n  };RG.Effects.Common.fadeIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.opacity = 0;RG.redrawCanvas(obj.canvas);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return obj;\n  };RG.Effects.Common.fadeOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.Effects.Common.fadeSlideIn = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.getCanvasXY(obj.canvas),\n        color = opt.color || 'white',\n        callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeSlideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var pc = -20;var step = (120 - pc) / frames;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, obj.get('clearto'));\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white ' + radius + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, color);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.expand = function () {\n    var obj = this;var opt = arguments[0] || {};var bounce = typeof opt.bounce === 'boolean' ? opt.bounce : true;var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!this.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(this.canvas);this.canvas.rgraph_wrapper = div;\n    } else {\n      div = this.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';this.canvas.style.top = this.canvas.height / 2 + 'px';this.canvas.style.left = this.canvas.width / 2 + 'px';this.canvas.style.width = 0;this.canvas.style.height = 0;this.canvas.style.opacity = 0;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);if (bounce) {\n      jQuery('#' + obj.id).animate({ opacity: 1, width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.5, function () {\n        jQuery('#' + obj.id).animate({ width: obj.canvas.width * 0.9 + 'px', height: obj.canvas.height * 0.9 + 'px', top: obj.canvas.height * 0.05 + 'px', left: obj.canvas.width * 0.05 + 'px' }, duration * 0.25, function () {\n          jQuery('#' + obj.id).animate({ width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: 0, left: 0 }, duration * 0.25, function () {\n            callback(obj);\n          });\n        });\n      });\n    } else {\n      jQuery(obj.canvas).animate({ opacity: 1, width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', left: 0, top: 0 }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.contract = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!obj.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(obj.canvas);obj.canvas.rgraph_wrapper = div;\n    } else {\n      div = obj.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';obj.canvas.style.top = 0;obj.canvas.style.left = 0;if (opt.bounce !== false) {\n      jQuery('#' + obj.id).animate({ width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.25, function () {\n        jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n          callback(obj);\n        });\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.reveal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var divs = [['rgraph_reveal_left_' + obj.id, xy[0], xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_right_' + obj.id, xy[0] + obj.canvas.width / 2, xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, obj.canvas.height / 2], ['rgraph_reveal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height / 2, obj.canvas.width, obj.canvas.height / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = document.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = opt && typeof opt.color === 'string' ? opt.color : 'white';document.body.appendChild(div);\n    }\n    RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + obj.canvas.width / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + obj.canvas.height / 2, height: 0 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.revealCircular = RG.Effects.Common.revealcircular = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var currentRadius = 0;\n    var centerx = obj.canvas.width / 2;var centery = obj.canvas.height / 2;var targetRadius = ma.max(obj.canvas.height, obj.canvas.width);var step = targetRadius / frames;var color = opt.background || opt.color || opt.backgroundColor || 'transparent';function iterator() {\n      RG.clear(obj.canvas, color);obj.context.save();obj.context.beginPath();obj.context.arc(centerx, centery, currentRadius, 0, RG.TWOPI, false);obj.context.clip();if (opt.background) {\n        RG.clear(obj.canvas, opt.background);\n      }\n      obj.draw();obj.context.restore();if (currentRadius < targetRadius) {\n        currentRadius += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Effects.Common.conceal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var divs = [['rgraph_conceal_left_' + obj.id, xy[0], xy[1], 0, obj.canvas.height], ['rgraph_conceal_right_' + obj.id, xy[0] + obj.canvas.width, xy[1], 0, obj.canvas.height], ['rgraph_conceal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, 0], ['rgraph_conceal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height, obj.canvas.width, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + obj.canvas.width / 2, width: obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + obj.canvas.height / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + obj.canvas.height / 2, height: obj.canvas.height / 2 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.clear(obj.canvas);callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsOpen = RG.Effects.Common.hblindsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;document.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsClose = RG.Effects.Common.hblindsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = 0;div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.Effects.Common.vBlindsOpen = RG.Effects.Common.vblindsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.vblindsclose = RG.Effects.Common.vBlindsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = 0;div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.slideIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var from = opt.from || 'left';div.style.overflow = 'hidden';RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);canvas.style.position = 'relative';if (from == 'left') {\n      obj.canvas.style.left = 0 - div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    } else if (from == 'top') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = 0 - div.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = div.offsetHeight + 'px';\n    } else {\n      obj.canvas.style.left = div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    }\n    jQuery('#' + obj.id).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.Effects.Common.slideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var to = opt.to || 'left';div.style.overflow = 'hidden';obj.canvas.style.position = 'relative';obj.canvas.style.left = 0;obj.canvas.style.top = 0;if (to == 'left') {\n      jQuery('#' + obj.id).animate({ left: 0 - obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'top') {\n      jQuery('#' + obj.id).animate({ left: 0, top: 0 - div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'bottom') {\n      jQuery('#' + obj.id).animate({ top: 0 + div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ left: 0 + obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.hscissorsopen = RG.Effects.Common.hScissorsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var to = opt.to || 'left';var height = obj.canvas.height / 5;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = obj.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + obj.canvas.width + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hScissorsClose = RG.Effects.Common.hscissorsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = obj.canvas.height / 5;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? xy[0] + obj.canvas.width : xy[0]) + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + 'px', width: obj.canvas.width + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: obj.canvas.width + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RGraph.clear(obj.canvas);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vScissorsOpen = RG.Effects.Common.vscissorsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = obj.canvas.height + 'px';div.style.left = xy[0] + obj.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + obj.canvas.height + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vscissorsclose = RG.Effects.Common.vScissorsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = xy[0] + width * i + 'px';div.style.top = (i % 2 == 0 ? xy[1] + obj.canvas.height : xy[1]) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + 'px', height: obj.canvas.height + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: obj.canvas.height + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.animate = function (map) {\n    var obj = this;obj.draw();var totalFrames = map && map['frames'] ? map['frames'] : 30;var currentFrame = new Array();var originalValues = new Array();var diffs = new Array();var steps = new Array();var callback = arguments[1];\n    function iterator() {\n      var id = [obj.id + '_' + obj.type];if (!currentFrame[id]) {\n        currentFrame[id] = totalFrames;originalValues[id] = {};diffs[id] = {};steps[id] = {};\n      }\n      for (var i in map) {\n        if (typeof map[i] === 'string' || typeof map[i] === 'number') {\n          if (currentFrame[id] == totalFrames) {\n            originalValues[id][i] = obj.get(i);diffs[id][i] = map[i] - originalValues[id][i];steps[id][i] = diffs[id][i] / totalFrames;\n          }\n          obj.set(i, obj.get(i) + steps[id][i]);RG.clear(obj.canvas);obj.draw();\n        }\n      }\n      if (--currentFrame[id] > 0) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        if (typeof callback === 'function') {\n          callback(obj);\n        }\n      }\n    }\n    iterator();\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.effects.js\n// module id = 170\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.effects.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HTML = RGraph.HTML || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.drawKey = RG.DrawKey = function (obj, key, colors) {\n    if (!key) {\n      return;\n    }\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        keypos = prop['chart.key.position'],\n        textsize = prop['chart.text.size'],\n        key_non_null = [],\n        colors_non_null = [];co.lineWidth = 1;co.beginPath();if (typeof prop['chart.key.vpos'] == 'number') {\n      obj.Set('chart.key.position.y', prop['chart.key.vpos'] * prop['chart.gutter.top']);\n    }\n    for (var i = 0; i < key.length; ++i) {\n      if (key[i] != null) {\n        colors_non_null.push(colors[i]);key_non_null.push(key[i]);\n      }\n    }\n    key = key_non_null;colors = colors_non_null;function DrawKey_graph(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'];var text_italic = prop['chart.key.text.italic'] ? true : false;\n      var text_bold = prop['chart.key.text.bold'] ? true : false;\n      var text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'];var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var hpos = prop['chart.yaxispos'] == 'right' ? gutterLeft + 10 : ca.width - gutterRight - 10;var vpos = gutterTop + 10;var title = prop['chart.title'];var blob_size = text_size;var hmargin = 8;var vmargin = 4;var fillstyle = prop['chart.key.background'];var text_color = prop['chart.key.text.color'];var strokestyle = '#333';var height = 0;var width = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = text_size + 'pt ' + prop['chart.text.font'];for (i = 0; i < key.length; ++i) {\n        width = Math.max(width, co.measureText(key[i]).width);\n      }\n      width += 5;width += blob_size;width += 5;width += 5;width += 5;if (prop['chart.yaxispos'] == 'left' || obj.type === 'pie' && !prop['chart.yaxispos'] || obj.type === 'hbar' && !prop['chart.yaxispos'] || obj.type === 'hbar' && prop['chart.yaxispos'] === 'center' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' || obj.type === 'rscatter' && !prop['chart.yaxispos'] || obj.type === 'radar' && !prop['chart.yaxispos'] || obj.type === 'rose' && !prop['chart.yaxispos'] || obj.type === 'funnel' && !prop['chart.yaxispos'] || obj.type === 'vprogress' && !prop['chart.yaxispos'] || obj.type === 'hprogress' && !prop['chart.yaxispos']) {\n        hpos -= width;\n      }\n      if (typeof prop['chart.key.halign'] == 'string') {\n        if (prop['chart.key.halign'] == 'left') {\n          hpos = gutterLeft + 10;\n        } else if (prop['chart.key.halign'] == 'right') {\n          hpos = ca.width - gutterRight - width;\n        }\n      }\n      if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (prop['chart.key.shadow']) {\n        co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n      }\n      co.beginPath();co.fillStyle = prop['chart.key.background'];co.strokeStyle = 'black';if (typeof prop['chart.key.position.graph.boxed'] == 'undefined' || typeof prop['chart.key.position.graph.boxed'] == 'boolean' && prop['chart.key.position.graph.boxed']) {\n        if (arguments[3] != false) {\n          co.lineWidth = typeof prop['chart.key.linewidth'] == 'number' ? prop['chart.key.linewidth'] : 1;if (prop['chart.key.rounded'] == true) {\n            co.beginPath();co.strokeStyle = strokestyle;RG.strokedCurvyRect(co, Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key), 4);co.stroke();co.fill();RG.NoShadow(obj);\n          } else {\n            co.strokeRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));co.fillRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));\n          }\n        }\n      }\n      RG.NoShadow(obj);co.beginPath();if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = key.length - 1; i >= 0; i--) {\n        var j = Number(i) + 1;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.arc(hpos + 5 + blob_size / 2, vpos + 5 * j + text_size * j - text_size + blob_size / 2, blob_size / 2, 0, 6.26, 0);co.fill();\n        } else if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'triangle') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.lineTo(hpos + blob_size / 2 + 5, vpos + 5 * j + text_size * j - text_size);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.closePath();co.fillStyle = colors[i];co.fill();\n        } else {\n          co.fillStyle = colors[i];co.fillRect(hpos + 5, vpos + 5 * j + text_size * j - text_size, text_size, text_size + 1);\n        }\n        co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) == 'object' ? text_color[i] : text_color;ret = RG.Text2(obj, { 'font': text_font, 'size': text_size, 'bold': text_bold, 'italic': text_italic, 'x': hpos + blob_size + 5 + 5, 'y': vpos + 5 * j + text_size * j + 3, 'text': key[i], 'accessible': !obj.properties['chart.key.interactive'] });obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n      co.fill();\n    }\n    function DrawKey_gutter(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'],\n          text_bold = prop['chart.key.text.bold'],\n          text_italic = prop['chart.key.text.italic'],\n          text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'],\n          text_color = prop['chart.key.text.color'],\n          gutterLeft = obj.gutterLeft,\n          gutterRight = obj.gutterRight,\n          gutterTop = obj.gutterTop,\n          gutterBottom = obj.gutterBottom,\n          hpos = (ca.width - gutterLeft - gutterRight) / 2 + obj.gutterLeft,\n          vpos = gutterTop - text_size - 5,\n          title = prop['chart.title'],\n          blob_size = text_size,\n          hmargin = 8,\n          vmargin = 4,\n          fillstyle = prop['chart.key.background'],\n          strokestyle = '#999',\n          length = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = (obj.properties['chart.key.text.italic'] ? 'italic ' : '') + (obj.properties['chart.key.text.bold'] ? 'bold ' : '') + text_size + 'pt ' + text_font;for (i = 0; i < key.length; ++i) {\n        length += hmargin;length += blob_size;length += hmargin;length += co.measureText(key[i]).width;\n      }\n      length += hmargin;if (obj.type == 'pie') {\n        if (prop['chart.align'] == 'left') {\n          var hpos = obj.radius + gutterLeft;\n        } else if (prop['chart.align'] == 'right') {\n          var hpos = ca.width - obj.radius - gutterRight;\n        } else {\n          hpos = ca.width / 2;\n        }\n      }\n      hpos -= length / 2;if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (obj.Get('chart.key.position.gutter.boxed')) {\n        if (prop['chart.key.shadow']) {\n          co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n        }\n        co.beginPath();co.fillStyle = fillstyle;co.strokeStyle = strokestyle;if (prop['chart.key.rounded']) {\n          RG.strokedCurvyRect(co, hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        } else {\n          co.rect(hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        }\n        co.stroke();co.fill();RG.NoShadow(obj);\n      }\n      if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = 0, pos = hpos; i < key.length; ++i) {\n        pos += hmargin;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.lineTo(pos + blob_size, vpos + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.arc(pos + blob_size / 2, vpos + blob_size / 2, blob_size / 2, 0, 6.28, 0);co.fill();\n        } else if (blob_shape == 'triangle') {\n          co.fillStyle = colors[i];co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size);co.lineTo(pos + blob_size / 2, vpos);co.lineTo(pos + blob_size, vpos + blob_size);co.closePath();co.fill();\n        } else {\n          co.beginPath();co.fillStyle = colors[i];co.rect(pos, vpos, blob_size, blob_size);co.fill();\n        }\n        pos += blob_size;pos += hmargin;co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) === 'object' ? text_color[i] : text_color;var ret = RG.Text2(obj, { 'font': text_font, 'bold': text_bold, 'size': text_size, 'italic': text_italic, 'x': pos, 'y': vpos + text_size + 3, 'text': key[i], accessible: !obj.properties['chart.key.interactive'] });co.fill();pos += co.measureText(key[i]).width;obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n    }\n    if (keypos && keypos == 'gutter') {\n      DrawKey_gutter(obj, key, colors);\n    } else if (keypos && keypos == 'graph') {\n      DrawKey_graph(obj, key, colors);\n    } else {\n      alert('[COMMON] (' + obj.id + ') Unknown key position: ' + keypos);\n    }\n    if (prop['chart.key.interactive']) {\n      if (!RGraph.Drawing || !RGraph.Drawing.Rect) {\n        alert('[INTERACTIVE KEY] The drawing API Rect library does not appear to have been included (which the interactive key uses)');\n      }\n      if (!RGraph.InstallWindowMousedownListener) {\n        alert('[INTERACTIVE KEY] The dynamic library does not appear to have been included');\n      }\n      for (var i = 0, len = obj.coords.key.length, maxlen = 0; i < len; i += 1) {\n        maxlen = Math.max(maxlen, obj.coords.key[i][2]);\n      }\n      for (var i = 0, len = obj.coords.key.length; i < len; i += 1) {\n        (function (idx) {\n          var arr = obj.coords.key;var value = obj.coords.key[idx];var index = idx;var rect = new RGraph.Drawing.Rect(obj.id, value[0], value[1], prop['chart.key.position'] == 'gutter' ? value[2] : maxlen, value[3]).Set('fillstyle', 'rgba(0,0,0,0)').Draw();rect.onclick = function (e, shape) {\n            var co = rect.context;co.fillStyle = prop['chart.key.interactive.highlight.label'];co.fillRect(shape.x, shape.y, shape.width, shape.height);if (typeof obj.interactiveKeyHighlight == 'function') {\n              obj.Set('chart.key.interactive.index', idx);RG.FireCustomEvent(obj, 'onbeforeinteractivekey');obj.interactiveKeyHighlight(index);RG.FireCustomEvent(obj, 'onafterinteractivekey');\n            }\n          };\n          rect.onmousemove = function (e, shape) {\n            return true;\n          };\n        })(i);\n      }\n    }\n  };RG.getKeyLength = function (key) {\n    var length = 0;for (var i = 0, len = key.length; i < len; i += 1) {\n      if (key[i] != null) {\n        ++length;\n      }\n    }\n    return length;\n  };RGraph.HTML.key = RGraph.HTML.Key = function (id, prop) {\n    var div = doc.getElementById(id);var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n      var style = '';\n      for (i in prop.tableCss) {\n        if (typeof i === 'string') {\n          style = style + i + ': ' + prop.tableCss[i] + ';';\n        }\n      }\n      return style;\n    }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';for (var i = 0; i < prop.labels.length; i += 1) {\n      str += '<tr><td><div style=\"' + function () {\n        var style = '';for (var j in prop.blobCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.blobCss[j] + ';';\n          }\n        }\n        return style;\n      }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n        var style = '';for (var j in prop.labelCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.labelCss[j] + ';';\n          }\n        }\n        return style;\n      }() + '\" ' + function () {\n        var style = '';if (prop['labelCss_' + i]) {\n          for (var j in prop['labelCss_' + i]) {\n            style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n          }\n        }\n        return style ? 'style=\"' + style + '\"' : '';\n      }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n    }\n    div.innerHTML += str + '</table>';return doc.getElementById('rgraph_key');\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.key.js\n// module id = 171\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.key.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      active = null;RGraph.allowResizing = RGraph.AllowResizing = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        pa2 = RG.path2;ca.resizing = ca.resizing || {};ca.resizing.placeHolders = ca.resizing.placeHolders || [];if (!ca.resizing.originalw) {\n      ca.resizing.originalw = ca.width;\n    }\n    if (!ca.resizing.originalh) {\n      ca.resizing.originalh = ca.height;\n    }\n    var resizeHandleSize = 15;if (!ca.resizing.__rgraph_original_width__ || !ca.resizing.__rgraph_original_height__ || !ca.resizing.__adjustX || !ca.resizing.__adjustY) {\n      ca.resizing.__rgraph_original_width__ = ca.width;ca.resizing.__rgraph_original_height__ = ca.height;ca.resizing.adjustX = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[0] == 'number' ? obj.Get('chart.resize.handle.adjust')[0] : 0;ca.resizing.adjustY = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[1] == 'number' ? obj.Get('chart.resize.handle.adjust')[1] : 0;ca.resizing.bgcolor = obj.get('chart.resize.handle.background') || 'rgba(0,0,0,0)';\n    }\n    pa2(co, 'b m % % r % % % % f %', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize, ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 2 * resizeHandleSize, resizeHandleSize, ca.resizing.bgcolor);pa2(co, 'b lw 1 m % % l % % m % % l % % s gray f transparent', ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height - resizeHandleSize + ca.resizing.adjustY, ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height + ca.resizing.adjustY, ca.width + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY), ca.width - resizeHandleSize + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY));pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 's', 'gray', 'f', 'white']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - 3 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 's', 'gray', 'f', 'gray']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 's', 'f']);if (obj.get('chart.resizable') && !ca.rgraphResizewrapper) {\n      ca.rgraphResizewrapper = $('<div id=\"rgraph_resize_container_' + ca.id + '\"></div>').css({ 'float': ca.style.cssFloat, position: 'relative' }).get(0);$(ca).wrap(ca.rgraphResizewrapper);ca.style.cssFloat = 'none';ca.style.top = 0;ca.style.left = 0;var window_onmousemove = function window_onmousemove(e) {\n        var ca = active,\n            obj = ca ? ca.__object__ : null;if (ca) {\n          e = RG.fixEventObject(e);if (ca.resizing.mousedown) {\n            var newWidth = ca.width + (e.pageX - ca.resizing.originalx);var newHeight = ca.height + (e.pageY - ca.resizing.originaly);if (newWidth > ca.resizing.originalw / 2 && (typeof obj.get('resizableMaxwidth') === 'number' ? newWidth < obj.get('resizableMaxwidth') : true)) {\n              ca.resizing.div.style.width = newWidth + 'px';\n            }\n            if (newHeight > ca.resizing.originalh / 2 && (typeof obj.get('resizableMaxheight') === 'number' ? newHeight < obj.get('resizableMaxheight') : true)) {\n              ca.resizing.div.style.height = newHeight + 'px';\n            }\n            RG.fireCustomEvent(ca.__object__, 'onresize');\n          }\n        }\n      };\n      if (typeof ca.rgraph_resize_window_mousemove_listener_installed != 'boolean') {\n        window.addEventListener('mousemove', window_onmousemove, false);ca.rgraph_resize_window_mousemove_listener_installed = true;\n      }\n      var MouseupFunc = function MouseupFunc(e) {\n        if (!ca.resizing || !ca.resizing.div || !ca.resizing.mousedown) {\n          return;\n        }\n        if (ca.resizing.div) {\n          var div = ca.resizing.div;var coords = RG.getCanvasXY(ca);var parentNode = ca.parentNode;if (ca.style.position != 'absolute') {\n            var placeHolderDIV = document.createElement('DIV');placeHolderDIV.style.width = ca.resizing.originalw + 'px';placeHolderDIV.style.height = ca.resizing.originalh + 'px';placeHolderDIV.style.display = 'inline-block';placeHolderDIV.style.position = ca.style.position;placeHolderDIV.style.left = ca.style.left;placeHolderDIV.style.top = ca.style.top;placeHolderDIV.style.cssFloat = ca.style.cssFloat;parentNode.insertBefore(placeHolderDIV, ca);\n          }\n          ca.style.backgroundColor = 'white';ca.style.position = 'absolute';ca.style.border = '1px dashed gray';ca.style.boxShadow = '2px 2px 5px #ddd';ca.style.left = 0;ca.style.top = 0;ca.width = parseInt(div.style.width);ca.height = parseInt(div.style.height);ca.getContext('2d').translate(0.5, 0.5);var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (typeof objects[i].reset === 'function') {\n              objects[i].reset();\n            }\n          }\n          RG.cache = [];RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');RG.redrawCanvas(ca);ca.resizing.mousedown = false;div.style.display = 'none';document.body.removeChild(div);\n        }\n        if (RG.Registry.Get('chart.zoomed.div') || RGraph.Registry.Get('chart.zoomed.img')) {\n          RG.Registry.Set('chart.zoomed.div', null);RG.Registry.Set('chart.zoomed.img', null);\n        }\n        RG.FireCustomEvent(ca.__object__, 'onresizeend');\n      };var window_onmouseup = MouseupFunc;if (typeof ca.rgraph_resize_window_mouseup_listener_installed != 'boolean') {\n        window.addEventListener('mouseup', window_onmouseup, false);ca.rgraph_resize_window_mouseup_listener_installed = true;\n      }\n      var canvas_onmousemove = function canvas_onmousemove(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var obj = e.target.__object__;var ca = e.target;var co = ca.getContext('2d');var cursor = ca.style.cursor;if (!ca.resizing.original_cursor) {\n          ca.resizing.original_cursor = cursor;\n        }\n        if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'move';\n        } else if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'pointer';\n        } else {\n          if (ca.resizing.original_cursor) {\n            ca.style.cursor = ca.resizing.original_cursor;ca.resizing.original_cursor = null;\n          } else {\n            ca.style.cursor = 'default';\n          }\n        }\n      };if (typeof ca.rgraph_resize_mousemove_listener_installed != 'boolean') {\n        ca.addEventListener('mousemove', canvas_onmousemove, false);ca.rgraph_resize_mousemove_listener_installed = true;\n      }\n      var canvas_onmouseout = function canvas_onmouseout(e) {\n        e.target.style.cursor = 'default';e.target.title = '';\n      };if (typeof ca.rgraph_resize_mouseout_listener_installed != 'boolean') {\n        ca.addEventListener('mouseout', canvas_onmouseout, false);ca.rgraph_resize_mouseout_listener_installed = true;\n      }\n      var canvas_onmousedown = function canvas_onmousedown(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(e.target);var ca = e.target;active = ca;if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          RG.fireCustomEvent(obj, 'onresizebegin');if (ca.resizing.original_css_border == null) {\n            ca.resizing.original_css_border = ca.style.border;\n          }\n          if (ca.resizing.original_css_shadow == null) {\n            ca.resizing.original_css_shadow = ca.style.boxShadow;\n          }\n          ca.resizing.mousedown = true;var div = document.createElement('DIV');div.style.position = 'absolute';div.style.left = canvasXY[0] + 'px';div.style.top = canvasXY[1] + 'px';div.style.width = ca.width + 'px';div.style.height = ca.height + 'px';div.style.border = '1px dotted black';div.style.backgroundColor = 'gray';div.style.opacity = 0.5;div.__canvas__ = e.target;document.body.appendChild(div);ca.resizing.div = div;ca.resizing.placeHolders.push(div);for (var i = 0; i < ca.resizing.placeHolders.length - 1; ++i) {\n            ca.resizing.placeHolders[i].style.display = 'none';\n          }\n          div.onmouseup = function (e) {\n            MouseupFunc(e);\n          };\n          ca.resizing.div.onmouseover = function (e) {\n            e = RG.fixEventObject(e);e.stopPropagation();\n          };\n          ca.resizing.originalx = e.pageX;ca.resizing.originaly = e.pageY;ca.resizing.originalCanvasX = RG.getCanvasXY(ca)[0];ca.resizing.originalCanvasY = RG.getCanvasXY(ca)[1];\n        }\n        if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height && ca.resizing.originalw && ca.resizing.originaly) {\n          RG.fireCustomEvent(ca.__object__, 'onresizebegin');ca.width = ca.resizing.originalw;ca.height = ca.resizing.originalh;if (ca.__link__ && ca.__link__.style.display === 'none') {\n            ca.__link__.style.display = 'inline';\n          }\n          if (typeof ca.parentNode.id === 'string' && ca.parentNode.id.substring(0, 24) === 'rgraph_resize_container_') {\n            ca.parentNode.style.width = ca.resizing.originalw + 'px';ca.parentNode.style.height = ca.resizing.originalh + 'px';\n          }\n          ca.style.border = ca.resizing.original_css_border;ca.style.boxShadow = ca.resizing.original_css_shadow;ca.style.left = parseInt(ca.style.left) + 'px';ca.style.top = parseInt(ca.style.top) + 'px';ca.getContext('2d').translate(0.5, 0.5);RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0; i < objects.length; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (objects[i].reset) {\n              objects[i].reset();\n            }\n            RG.redrawCanvas(objects[i].canvas);\n          }\n          RG.cache = [];if (ca.resizing.div) {\n            ca.resizing.div.style.width = ca.__original_width__ + 'px';ca.resizing.div.style.height = ca.__original_height__ + 'px';\n          }\n          RG.fireCustomEvent(ca.__object__, 'onresize');RG.fireCustomEvent(ca.__object__, 'onresizeend');\n        }\n      };if (typeof ca.rgraph_resize_mousedown_listener_installed != 'boolean') {\n        ca.addEventListener('mousedown', canvas_onmousedown, false);ca.rgraph_resize_mousedown_listener_installed = true;\n      }\n    }\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.resizing.js\n// module id = 172\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.resizing.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.sheets.js\n// module id = 173\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.sheets.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.tooltips = {};RG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '10pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', opacity: 0 };RG.tooltip = RG.Tooltip = function (obj, text, x, y, idx, e) {\n    if (RG.trim(text).length === 0) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforetooltip');if (typeof obj.get('chart.tooltips.override') == 'function') {\n      return obj.get('chart.tooltips.override')(obj, text, x, y, idx);\n    }\n    var originalX = x;var originalY = y;text = RG.getTooltipTextFromDIV(text);var timers = RG.Registry.Get('chart.tooltip.timers');if (timers && timers.length) {\n      for (i = 0; i < timers.length; ++i) {\n        clearTimeout(timers[i]);\n      }\n    }\n    RG.Registry.Set('chart.tooltip.timers', []);if (obj.get('chart.contextmenu')) {\n      RG.hideContext();\n    }\n    var tooltipObj = document.createElement('DIV');tooltipObj.className = obj.get('chart.tooltips.css.class');for (var i in RGraph.tooltips.style) {\n      if (typeof i === 'string') {\n        tooltipObj.style[i] = RGraph.tooltips.style[i];\n      }\n    }\n    tooltipObj.innerHTML = text;tooltipObj.__text__ = text;tooltipObj.__canvas__ = obj.canvas;tooltipObj.id = '__rgraph_tooltip_' + obj.canvas.id + '_' + obj.uid + '_' + idx;tooltipObj.__event__ = obj.Get('chart.tooltips.event') || 'click';tooltipObj.__object__ = obj;if (typeof idx === 'number') {\n      tooltipObj.__index__ = idx;origIdx = idx;\n    }\n    if (obj.type === 'line' || obj.type === 'radar') {\n      for (var ds = 0; ds < obj.data.length; ++ds) {\n        if (idx >= obj.data[ds].length) {\n          idx -= obj.data[ds].length;\n        } else {\n          break;\n        }\n      }\n      tooltipObj.__dataset__ = ds;tooltipObj.__index2__ = idx;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth;var height = tooltipObj.offsetHeight;tooltipObj.style.width = width + 'px';var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(obj.canvas);tooltipObj.style.left = e.pageX - (parseFloat(tooltipObj.style.paddingLeft) + width / 2) + 'px';tooltipObj.style.top = e.pageY - height - 10 + 'px';if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.isFixed(obj.canvas)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = e.pageY - scrollTop - height - 10 + 'px';\n    }\n    if (obj.get('chart.tooltips.effect') === 'fade') {\n      for (var i = 1; i <= 10; ++i) {\n        (function (index) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = index / 10;\n          }, index * 25);\n        })(i);\n      }\n    } else {\n      tooltipObj.style.opacity = 1;\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };\n    RG.Registry.Set('chart.tooltip', tooltipObj);RG.fireCustomEvent(obj, 'ontooltip');\n  };RG.getTooltipTextFromDIV = function (text) {\n    var result = /^id:(.*)/.exec(text);if (result && result[1] && document.getElementById(result[1])) {\n      text = document.getElementById(result[1]).innerHTML;\n    } else if (result && result[1]) {\n      text = '';\n    }\n    return text;\n  };RG.getTooltipWidth = function (text, obj) {\n    var div = document.createElement('DIV');div.className = obj.Get('chart.tooltips.css.class');div.style.paddingLeft = RG.tooltips.padding;div.style.paddingRight = RG.tooltips.padding;div.style.fontFamily = RG.tooltips.font_face;div.style.fontSize = RG.tooltips.font_size;div.style.visibility = 'hidden';div.style.position = 'absolute';div.style.top = '300px';div.style.left = 0;div.style.display = 'inline';div.innerHTML = RG.getTooltipTextFromDIV(text);document.body.appendChild(div);return div.offsetWidth;\n  };RG.hideTooltip = RG.HideTooltip = function () {\n    var tooltip = RG.Registry.Get('chart.tooltip');var uid = arguments[0] && arguments[0].uid ? arguments[0].uid : null;if (tooltip && tooltip.parentNode && (!uid || uid == tooltip.__canvas__.uid)) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.Registry.Set('chart.tooltip', null);\n    }\n  };RG.preLoadTooltipImages = RG.PreLoadTooltipImages = function (obj) {\n    var tooltips = obj.Get('chart.tooltips');if (RG.hasTooltips(obj)) {\n      if (obj.type == 'rscatter') {\n        tooltips = [];for (var i = 0; i < obj.data.length; ++i) {\n          tooltips.push(obj.data[3]);\n        }\n      }\n      for (var i = 0; i < tooltips.length; ++i) {\n        var div = document.createElement('DIV');div.style.position = 'absolute';div.style.opacity = 0;div.style.top = '-100px';div.style.left = '-100px';div.innerHTML = tooltips[i];document.body.appendChild(div);var img_tags = div.getElementsByTagName('IMG');for (var j = 0; j < img_tags.length; ++j) {\n          if (img_tags && img_tags[i]) {\n            var img = document.createElement('IMG');img.style.position = 'absolute';img.style.opacity = 0;img.style.top = '-100px';img.style.left = '-100px';img.src = img_tags[i].src;\n            document.body.appendChild(img);setTimeout(function () {\n              document.body.removeChild(img);\n            }, 250);\n          }\n        }\n        document.body.removeChild(div);\n      }\n    }\n  };RG.tooltips_mousemove = RG.Tooltips_mousemove = function (obj, e) {\n    var shape = obj.getShape(e);var changeCursor_tooltips = false;\n    if (shape && typeof shape['index'] == 'number' && obj.Get('chart.tooltips')[shape['index']]) {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;if (obj.Get('chart.tooltips.event') == 'onmousemove') {\n          if (!RG.Registry.Get('chart.tooltip') || RG.Registry.Get('chart.tooltip').__object__.uid != obj.uid || RG.Registry.Get('chart.tooltip').__index__ != shape['index']) {\n            RG.hideTooltip();RG.Clear(obj.canvas);RG.redraw();RG.tooltip(obj, text, e.pageX, e.pageY, shape['index']);obj.Highlight(shape);\n          }\n        }\n      }\n    } else if (shape && typeof shape['index'] == 'number') {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;\n      }\n    }\n    return changeCursor_tooltips;\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.tooltips.js\n// module id = 174\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.tooltips.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.zoom = RG.Zoom = function (e) {\n    e = RGraph.fixEventObject(e);if (e && e.target && e.target.__canvas__) {\n      var canvas = e.target.__canvas__;\n    } else if (e && e.target && e.target.__object__) {\n      var canvas = e.target.__object__.canvas;e.stopPropagation();\n    }\n    if (!canvas) {\n      var registry_canvas = RGraph.Registry.get('chart.contextmenu').__canvas__;if (registry_canvas) {\n        var canvas = registry_canvas;\n      }\n    }\n    var obj = canvas.__object__;var context = obj.context;var dataurl = canvas.toDataURL();var tmp = canvas;var coords = RG.getCanvasXY(canvas);var factor = obj.Get('chart.zoom.factor') - 1;var x = coords[0];var y = coords[1];var img = document.createElement('img');img.className = 'RGraph_zoomed_canvas';img.style.border = '1px solid #ccc';img.style.width = canvas.width + 'px';img.style.height = canvas.height + 'px';img.style.position = 'absolute';img.style.left = x + 'px';img.style.top = y + 'px';img.style.backgroundColor = 'white';img.style.opacity = obj.Get('chart.zoom.fade.in') ? 0 : 1;img.style.zIndex = 99;img.src = dataurl;document.body.appendChild(img);RGraph.zoom_image = img;RGraph.zoom_image.obj = obj;img.onclick = function (e) {\n      e = RGraph.fixEventObject(e);e.stopPropagation();return false;\n    };\n    var width = parseInt(canvas.width);var height = parseInt(canvas.height);var frames = obj.Get('chart.zoom.frames');var delay = obj.Get('chart.zoom.delay');if (obj.Get('chart.zoom.hdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = x + canvas.width / 2 - newWidth / 2;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.hdir') == 'left') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = rightHandEdge - newWidth;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.vdir') == 'up') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.vdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height / 2 + newHeight / 2;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.height = '\" + String(height * factor * (i / frames) + height) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.fade.in')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.opacity = \" + Number(i / frames), i * (delay / 2));\n      }\n    }\n    if (obj.Get('chart.zoom.shadow')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.boxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.MozBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.WebkitBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);\n      }\n    }\n    var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.position = 'fixed';div.style.top = 0;div.style.left = 0;div.style.width = screen.width + 100 + 'px';div.style.height = screen.height + 100 + 'px';div.style.zIndex = 98;div.onclick = div.oncontextmenu = function (e) {\n      return RG.hideZoomedCanvas(e);\n    };\n    div.origHeight = div.style.height;document.body.appendChild(div);RG.zoom_background = div;for (var i = 1; i <= frames; ++i) {\n      setTimeout(\"RGraph.zoom_background.style.opacity = \" + Number(i / frames) * 0.8, i * (delay / 2));\n    }\n    RG.fireCustomEvent(obj, 'onzoom');\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.common.zoom.js\n// module id = 175\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.common.zoom.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CornerGauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.min === 'number' && typeof conf.max === 'number' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'cornergauge';this.min = min;this.max = max;this.value = RGraph.stringsToNumbers(value);this.angles = {};this.angles.needle = [];this.centerpin = {};this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.strokestyle': 'black', 'chart.linewidth': 2, 'chart.title': '', 'chart.title.vpos': 0.5, 'chart.title.size': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.text.font': 'Arial', 'chart.text.color': '#666', 'chart.text.size': 10, 'chart.background.gradient.color1': '#ddd', 'chart.background.gradient.color2': 'white', 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.resizable': false, 'chart.chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.colors.ranges': null, 'chart.red.start': min + 0.9 * (this.max - min), 'chart.green.end': min + 0.7 * (this.max - min), 'chart.red.color': 'red', 'chart.yellow.color': 'yellow', 'chart.green.color': '#0f0', 'chart.value.text': true, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.value.text.boxed': true, 'chart.value.text.font': 'Arial', 'chart.value.text.size': 18, 'chart.value.text.bold': false, 'chart.value.text.decimals': 0, 'chart.centerpin.stroke': 'rgba(0,0,0,0)', 'chart.centerpin.fill': null, 'chart.centerpin.color': 'blue', 'chart.needle.colors': ['#ccc', '#D5604D', 'red', 'green', 'yellow'], 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph;var ca = this.canvas;var co = ca.getContext('2d');var prop = this.properties;var jq = jQuery;var pa = RG.Path;var win = window;var doc = document;var ma = Math;this.set = this.Set = function (name, value) {\n    if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    name = name.toLowerCase();if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (typeof this.gutterLeft == 'undefined') {\n      this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];\n    }\n    this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom);if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];this.centerx = ca.width / 2 - this.radius / 2 + Math.max(30, this.radius * 0.1);this.centery = ca.height / 2 + this.radius / 2 - this.radius * 0.1;this.coordsText = [];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawBackGround();this.DrawTickmarks();this.DrawColorBands();this.DrawLabel();this.DrawLabels();if (_typeof(this.value) === 'object') {\n      for (var i = 0, len = this.value.length; i < len; ++i) {\n        this.DrawNeedle(i, this.value[i], this.radius - 65);\n      }\n    } else {\n      this.DrawNeedle(0, this.value, this.radius - 65);\n    }\n    this.DrawCenterpin();var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;\n    prop['chart.title.y'] = this.centery + 20 - this.radius - 1.5 * size / 2;RGraph.DrawTitle(this, prop['chart.title'], this.guttertop, this.centerx + this.radius / 2, size);if (prop['chart.contextmenu']) {\n      RGraph.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RGraph.AllowResizing(this);\n    }\n    RGraph.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RGraph.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, false);co.stroke();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.stroke();RG.NoShadow(this);co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.stroke();RGraph.NoShadow(this);co.lineWidth = 0;co.fillStyle = RGraph.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius * 0.5, prop['chart.background.gradient.color1'], prop['chart.background.gradient.color2']);co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.lineTo(this.centerx - 20, this.centery + 20 - this.radius);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.beginPath();co.lineWidth = 1;co.strokeStyle = '#eee';for (var i = 0; i <= 5; ++i) {\n      var p1 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, 30);var p2 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, this.radius - 90);co.moveTo(p1[0], p1[1]);co.lineTo(p2[0], p2[1]);\n    }\n    co.stroke();\n  };this.drawNeedle = this.DrawNeedle = function (index, value, radius) {\n    var grad = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, 20, 'rgba(0,0,0,0)', prop['chart.needle.colors'][index]);\n    this.angles.needle[index] = (value - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.lineWidth = 1;\n    co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = grad;co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] - RG.HALFPI, this.angles.needle[index] - RG.HALFPI + 0.000001, false);co.arc(this.centerx, this.centery, radius - 30, this.angles.needle[index], this.angles.needle[index] + 0.000001, false);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] + RG.HALFPI, this.angles.needle[index] + RG.HALFPI + 0.000001, false);co.stroke();co.fill();\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (!prop['chart.centerpin.fill']) {\n      prop['chart.centerpin.fill'] = RG.RadialGradient(this, this.centerx + 5, this.centery - 5, 0, this.centerx + 5, this.centery - 5, 20, 'white', prop['chart.centerpin.color']);\n    }\n    co.strokeStyle = prop['chart.centerpin.stroke'];co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.lineWidth = 2;co.arc(this.centerx, this.centery, 15, 0, RGraph.TWOPI, false);co.stroke();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var numLabels = 6;co.fillStyle = prop['chart.text.color'];for (var i = 0; i < numLabels; ++i) {\n      co.beginPath();var num = Number(this.min + (this.max - this.min) * (i / (numLabels - 1))).toFixed(prop['chart.scale.decimals']);num = RG.number_format(this, num, prop['chart.units.pre'], prop['chart.units.post']);var angle = i * 18 / (180 / RG.PI);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx + ma.sin(angle) * (this.radius - 53), 'y': this.centery - ma.cos(angle) * (this.radius - 53), 'text': String(num), 'valign': 'top', 'halign': 'center', 'angle': 90 * (i / (numLabels - 1)), 'tag': 'scale' });co.fill();\n    }\n  };this.drawTickmarks = this.DrawTickmarks = function () {\n    var bigTicks = 5;var smallTicks = 25;for (var i = 0; i < smallTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (smallTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 44, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 46, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n    for (var i = 0; i < bigTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (bigTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 43, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 47, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n  };this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0, len = ranges.length; i < len; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), false);co.arc(this.centerx, this.centery, this.radius - 54 - 10 - prop['chart.text.size'] * 1.5, (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = RG.PI + RG.HALFPI;var greenEnd = greenStart + (RG.TWOPI - greenStart) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = (prop['chart.red.start'] - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = RGraph.TWOPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, redEnd, redStart, true);co.fill();\n  };this.drawLabel = this.DrawLabel = function () {\n    if (prop['chart.value.text']) {\n      co.strokeStyle = prop['chart.text.color'];co.fillStyle = prop['chart.text.color'];var value = typeof this.value == 'number' ? this.value.toFixed(prop['chart.value.text.decimals']) : this.value;if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n        for (var i = 0; i < value.length; ++i) {\n          value[i] = parseFloat(value[i]).toFixed(prop['chart.value.text.decimals']);\n        }\n        value = value.toString();\n      }\n      RG.Text2(this, { 'font': prop['chart.value.text.font'], 'size': prop['chart.value.text.size'], 'x': this.centerx + ma.cos(RG.PI / 180 * 45) * (this.radius / 3), 'y': this.centery - ma.sin(RG.PI / 180 * 45) * (this.radius / 3), 'text': prop['chart.value.text.units.pre'] + value + prop['chart.value.text.units.post'], 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.value.text.boxed'], 'boundingFill': 'white', 'bold': prop['chart.value.text.bold'], 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle > RG.TWOPI && angle < RG.PI + RG.HALFPI) {\n      return null;\n    }\n    var value = (angle - (RG.PI + RG.HALFPI)) / (RG.TWOPI - (RG.PI + RG.HALFPI)) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    if (mouseX > this.centerx && mouseY > this.centery) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - 5 && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + 5 && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.Clear(ca);RG.RedrawCanvas(ca);RG.FireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.HALFPI;\n    angle += RG.PI + RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    if (!RG.is_null(prop['chart.colors.ranges'])) {\n      for (var i = 0; i < prop['chart.colors.ranges'].length; ++i) {\n        prop['chart.colors.ranges'][i][2] = this.parseSingleColorForGradient(prop['chart.colors.ranges'][i][2]);\n      }\n    } else {\n      prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var radius_start = this.radius - 54 - prop['chart.text.size'];var radius_end = radius_start - 15;var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, radius_end);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    this[type] = func;return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0];var callback = arguments[1];var numFrames = 30;var frame = 0;var obj = this;if (typeof this.value === 'number') {\n      var origValue = Number(this.currentValue);if (this.currentValue === null) {\n        this.currentValue = this.min;origValue = this.min;\n      }\n      var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;var iterator = function iterator() {\n        frame++;obj.value = frame / numFrames * diff + origValue;\n        if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.Clear(obj.canvas);RGraph.RedrawCanvas(obj.canvas);if (frame < 30) {\n          RGraph.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];var step = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);step[i] = diff[i] / numFrames;\n      }\n      var max = this.max;var min = this.min;var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / numFrames * diff[i] + origValue[i];if (obj.value[i] > max) obj.value[i] = max;if (obj.value[i] < min) obj.value[i] = min;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n        }\n        if (frame < 30) {\n          RG.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };\n  RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.cornergauge.js\n// module id = 176\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.cornergauge.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Background = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id);\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.type = 'drawing.background';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.linewidth': 1, 'chart.title': '', 'chart.title.size': null, 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.color': 'black', 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': 'black', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.yaxis.pos': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.BACKGROUND] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa = RG.Path,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RG.drawBackgroundImage(this);RG.Background.draw(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var tooltip = prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null;\n      return { 0: this, 1: 0, 2: tooltip, 'object': this, 'index': 0, 'tooltip': tooltip };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b r % % % % f % s %', prop['chart.gutter.left'], prop['chart.gutter.top'], ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'], prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, ca.height - this.gutterRight),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.background.js\n// module id = 177\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.background.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Circle = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.circle';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.linewidth': 2, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.CIRCLE] No canvas support');return;\n  }\n  this.coords = [[this.centerx, this.centery, this.radius]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, 'b lw %', prop['chart.linewidth']);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    pa2(co, 'b a % % % % % % f % s %', this.coords[0][0], this.coords[0][1], this.radius, 0, RG.TWOPI, false, prop['chart.fillstyle'], prop['chart.strokestyle']);RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b a % % % % % % f % s %', this.centerx, this.centery, this.radius + 0.5, 0, RG.TWOPI, false, prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.circle.js\n// module id = 178\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.circle.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Image = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.src === 'string' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        src = conf.src,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        src = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.alignmentProcessed = false;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.src = src;this.img = new Image();this.img.src = this.src;this.type = 'drawing.image';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.src': null, 'chart.width': null, 'chart.height': null, 'chart.halign': 'left', 'chart.valign': 'top', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.alpha': 1, 'chart.border': false, 'chart.border.color': 'black', 'chart.border.linewidth': 1, 'chart.border.radius': 0, 'chart.background.color': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.IMAGE] No canvas support');return;\n  }\n  this.coords = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');var obj = this;this.img.onload = function () {\n      if (!obj.colorsParsed) {\n        obj.parseColors();obj.colorsParsed = true;\n      }\n      obj.width = this.width;obj.height = this.height;if (!this.alignmentProcessed) {\n        var customWidthHeight = typeof obj.properties['chart.width'] == 'number' && typeof obj.properties['chart.width'] == 'number';if (obj.properties['chart.halign'] === 'center') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] / 2 : this.width / 2;\n        } else if (obj.properties['chart.halign'] == 'right') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] : this.width;\n        }\n        if (obj.properties['chart.valign'] === 'center') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] / 2 : this.height / 2;\n        } else if (obj.properties['chart.valign'] == 'bottom') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] : this.height;\n        }\n        this.alignmentProcessed = true;\n      }\n    };\n    if (this.img.complete || this.img.readyState === 4) {\n      this.img.onload();\n    }\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.alpha'];if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.border.linewidth'];var borderRadius = 0;if (this.width || this.height) {\n        borderRadius = ma.min(this.width / 2, this.height / 2);\n      }\n      if (prop['chart.width'] / 2 > borderRadius && prop['chart.height'] / 2 > borderRadius) {\n        borderRadius = ma.min(prop['chart.width'] / 2, prop['chart.height'] / 2);\n      }\n      if (prop['chart.border.radius'] < borderRadius) {\n        borderRadius = prop['chart.border.radius'];\n      }\n      co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);\n    }\n    if (borderRadius) {\n      co.save();this.drawBackgroundColor(borderRadius);co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.clip();\n    } else {\n      this.drawBackgroundColor(0);\n    }\n    RG.noShadow(this);if (typeof prop['chart.height'] === 'number' || typeof prop['chart.width'] === 'number') {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y), prop['chart.width'] || this.width, prop['chart.height'] || this.height);\n    } else {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y));\n    }\n    if (borderRadius) {\n      co.restore();\n    }\n    if (prop['chart.border']) {\n      RG.noShadow(this);co.stroke();\n    }\n    co.globalAlpha = oldAlpha;this.img.onload = function () {\n      RG.redrawCanvas(ca);obj.coords[0] = [ma.round(obj.x), ma.round(obj.y), typeof prop['chart.width'] === 'number' ? prop['chart.width'] : this.width, typeof prop['chart.height'] == 'number' ? prop['chart.height'] : this.height];\n    };\n    RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (this.coords && this.coords[0] && mouseXY[0] >= this.coords[0][0] && mouseXY[0] <= this.coords[0][0] + this.coords[0][2] && mouseXY[1] >= this.coords[0][1] && mouseXY[1] <= this.coords[0][1] + this.coords[0][3]) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.img.width, this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.roundedRect = function (x, y, width, height, radius) {\n    co.save();co.translate(x, y);co.moveTo(width / 2, 0);co.arcTo(width, 0, width, height, ma.min(height / 2, radius));co.arcTo(width, height, 0, height, ma.min(width / 2, radius));co.arcTo(0, height, 0, 0, ma.min(height / 2, radius));co.arcTo(0, 0, radius, 0, ma.min(width / 2, radius));co.lineTo(width / 2, 0);co.restore();\n  };this.drawBackgroundColor = function (borderRadius) {\n    co.beginPath();co.fillStyle = prop['chart.background.color'];this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.fill();\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.image.js\n// module id = 179\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.image.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker1 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius == 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3],\n        text = arguments[4];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext(\"2d\");this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.text = text;this.type = 'drawing.marker1';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.linewidth': 2, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,0,0,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.align': 'center', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER1] No canvas support');return;\n  }\n  this.$0 = {};this.coords = [];this.coordsText = [];if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');var r = this.radius;if (prop['chart.align'] == 'left') {\n      this.markerCenterx = this.centerx - r - r - 3;this.markerCentery = this.centery - r - r - 3;\n    } else if (prop['chart.align'] == 'right') {\n      this.markerCenterx = this.centerx + r + r + 3;this.markerCentery = this.centery - r - r - 3;\n    } else {\n      this.markerCenterx = this.centerx;this.markerCentery = this.centery - r - r - 3;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];pa2(co, ['b', 'lw', prop['chart.linewidth']]);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.drawMarker();pa2(co, ['c', 's', prop['chart.strokestyle'], 'f', prop['chart.fillstyle']]);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] - 1, y: this.coords[0][1] - 1, text: this.text, valign: 'center', halign: 'center', tag: 'labels' });RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();this.drawMarker();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'radius': this.coords[0][2], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];this.drawMarker();co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.drawMarker = this.DrawMarker = function () {\n    var r = this.radius;if (prop['chart.align'] === 'left') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.TWOPI, false]);pa2(co, ['qc', x + r, y + r, x + r + r, y + r + r]);pa2(co, ['qc', x + r, y + r, x, y + r]);\n    } else if (prop['chart.align'] === 'right') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.PI, true]);pa2(co, ['qc', x - r, y + r, x - r - r, y + r + r]);pa2(co, ['qc', x - r, y + r, x, y + r]);\n    } else {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI / 2, RG.PI - RG.HALFPI / 2, true]);pa2(co, ['qc', x, y + r + r / 4, x, y + r + r - 2]);pa2(co, ['qc', x, y + r + r / 4, x + ma.cos(RG.HALFPI / 2) * r, y + ma.sin(RG.HALFPI / 2) * r]);\n    }\n    this.coords[0] = [x, y, r];\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.arrayClone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.markerCenterx, this.markerCentery, 0, this.markerCenterx, this.markerCentery, this.radius),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.marker1.js\n// module id = 180\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.marker1.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker2 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.text = text;this.type = 'drawing.marker2';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.voffset': 20, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER2] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.lineWidth = 1;RG.fireCustomEvent(this, 'onbeforedraw');this.metrics = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);if (this.x + this.metrics[0] >= ca.width) {\n      this.alignRight = true;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var x = this.alignRight ? this.x - this.metrics[0] - 6 : this.x,\n        y = this.y - 6 - prop['chart.voffset'] - this.metrics[1],\n        width = this.metrics[0] + 6,\n        height = this.metrics[1] + 6;this.coords[0] = [x, y, width, height];this.coordsText = [];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];co.strokeRect(x + (this.alignRight ? width : 0), y, 0, height + prop['chart.voffset'] - 6);co.strokeRect(x, y, width, height);co.fillRect(x, y, width, height);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: ma.round(this.x) - (this.alignRight ? this.metrics[0] + 3 : -3), y: this.y - 3 - prop['chart.voffset'], text: this.text, valign: 'bottom', halign: 'left', tag: 'labels' });this.coords[0].push([x, y, width, height]);RG.noShadow(this);co.textBaseline = 'alphabetic';RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.coords[0][0] && mouseX <= this.coords[0][0] + this.coords[0][2]) {\n      if (mouseY >= this.coords[0][1] && mouseY <= this.coords[0][1] + this.coords[0][3]) {\n        return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.metrics[0], this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.marker2.js\n// module id = 181\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.marker2.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker3 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.radius === 'number') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.actualRadius = 0;this.alpha = 1;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.marker3';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.fillstyle': 'rgba(255,255,255,1)', 'chart.delay': 50, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.fill': 'rgba(255,0,0,1.0)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER3] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.globalAlpha = this.alpha;pa2(co, ['b', 'a', this.centerx, this.centery, this.actualRadius, 0, 2 * Math.PI, false, 'a', this.centerx, this.centery, ma.max(this.actualRadius - 8, 0), 2 * Math.PI, 0, true, 'f', prop['chart.fillstyle']]);this.alpha = this.actualRadius ? 1 - this.actualRadius * 0.75 / this.radius : 1;co.globalAlpha = 1;if (this.actualRadius < this.radius) {\n      this.actualRadius += 2;\n    } else if (this.actualRadius >= this.radius) {\n      this.actualRadius = 0;this.alpha = 1;\n    }\n    if (!this.TIMER) {\n      var obj = this;setInterval(function () {\n        RG.redrawCanvas(ca);\n      }, prop['chart.delay']);this.TIMER = true;\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.marker3.js\n// module id = 182\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.marker3.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Poly = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.coords) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        coords = conf.coords,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        coords = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.coords = coords;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.poly';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.linewidth': 1, 'chart.strokestyle': 'black', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.override': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.2)', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.POLY] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];var obj = this;pa2(co, ['b', 'fu', function (obj) {\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];co.shadowBlur = prop['chart.shadow.blur'];\n      }\n    }, 'fu', function (obj) {\n      co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];obj.drawPoly();\n    }, 'lw', prop['chart.linewidth'], 'f', prop['chart.fillstyle'], 'fu', function () {\n      RG.noShadow(obj);\n    }, 's', prop['chart.strokestyle']]);RG.noShadow(this);\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawPoly = this.DrawPoly = function () {\n    var coords = this.coords;pa2(co, ['b', 'm', coords[0][0], coords[0][1]]);for (var i = 1, len = coords.length; i < len; ++i) {\n      co.lineTo(coords[i][0], coords[i][1]);\n    }\n    pa2(co, ['lw', prop['chart.linewidth'], 'c', 'f', co.fillStyle, 's', co.strokeStyle]);\n  };this.getShape = function (e) {\n    var coords = this.coords,\n        mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = 'rgba(0,0,0,0)';this.drawPoly();if (co.isPointInPath(mouseX, mouseY)) {\n      return { 0: this, 1: this.coords, 2: 0, 'object': this, 'coords': this.coords, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    co.fillStyle = prop['chart.fillstyle'];if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'fu', function (obj) {\n          obj.DrawPoly();\n        }, 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    var func = this.parseSingleColorForGradient;prop['chart.fillstyle'] = func(prop['chart.fillstyle']);prop['chart.strokestyle'] = func(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = func(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = func(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.poly.js\n// module id = 183\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.poly.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Rect = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.width === 'number' && typeof conf.height === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        x = conf.x,\n        y = conf.y,\n        width = conf.width,\n        height = conf.height,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        x = arguments[1],\n        y = arguments[2],\n        width = arguments[3],\n        height = arguments[4];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.coordsText = [];this.firstDraw = true;this.type = 'drawing.rect';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.tooltips.valign': 'top', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.RECT] No canvas support');return;\n  }\n  this.coords = [[Math.round(x), Math.round(y), width, height]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, ['b']);if (prop['chart.shadow']) {\n      pa2(co, ['sc', prop['chart.shadow.color'], 'sx', prop['chart.shadow.offsetx'], 'sy', prop['chart.shadow.offsety'], 'sb', prop['chart.shadow.blur']]);\n    }\n    pa2(co, ['r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.fillstyle']]);RG.NoShadow(this);pa2(co, ['s', prop['chart.strokestyle']]);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var coords = this.coords[i];var left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.rect.js\n// module id = 184\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.rect.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Text = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var y = conf.y;var text = String(conf.text);var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];var y = arguments[2];var text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.x = x;this.y = y;this.text = String(text);this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.text';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.size': 10, 'chart.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.bold': false, 'chart.angle': 0, 'chart.colors': ['black'], 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.stroke': '#ccc', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.bounding': false, 'chart.bounding.fill': 'rgba(255,255,255,0.7)', 'chart.bounding.stroke': '#777', 'chart.bounding.shadow': false, 'chart.bounding.shadow.color': '#ccc', 'chart.bounding.shadow.blur': 3, 'chart.bounding.shadow.offsetx': 3, 'chart.bounding.shadow.offsety': 3, 'chart.marker': false, 'chart.halign': 'left', 'chart.valign': 'bottom', 'chart.link': null, 'chart.link.target': '_self', 'chart.link.options': '', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)', 'chart.shadow': false, 'chart.shadow.color': '#ccc', 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3 };\n  if (!this.canvas) {\n    alert('[DRAWING.TEXT] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coords = [];this.coordsText = [];var dimensions = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);co.fillStyle = prop['chart.colors'][0];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var ret = RG.text2(this, { font: prop['chart.font'], size: prop['chart.size'], x: this.x, y: this.y, text: this.text, bold: prop['chart.bold'], angle: prop['chart.angle'], bounding: prop['chart.bounding'], 'bounding.fill': prop['chart.bounding.fill'], 'bounding.stroke': prop['chart.bounding.stroke'], 'bounding.shadow': prop['chart.bounding.shadow'], 'bounding.shadow.color': prop['chart.bounding.shadow.color'], 'bounding.shadow.blur': prop['chart.bounding.shadow.blur'], 'bounding.shadow.offsetx': prop['chart.bounding.shadow.offsetx'], 'bounding.shadow.offsety': prop['chart.bounding.shadow.offsety'], marker: prop['chart.marker'], halign: prop['chart.halign'], valign: prop['chart.valign'] });if (prop['chart.shadow']) {\n      RG.noShadow(this);\n    }\n    this.coords.push({ 0: ret.x, 'x': ret.x, 1: ret.y, 'y': ret.y, 2: ret.width, 'width': ret.width, 3: ret.height, 'height': ret.height });RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var prop = this.properties;var coords = this.coords;var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = coords[i].x;var top = coords[i].y;var width = coords[i].width;var height = coords[i].height;if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors'])[0];this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, 0, ca.width, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.text.js\n// module id = 185\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.text.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.XAxis = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var y = conf.y;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var y = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.y = y;this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.xaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.position': 'section', 'chart.colors': ['black'], 'chart.title.color': null, 'chart.text.color': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'bottom', 'chart.numlabels': 5, 'chart.scale.visible': true, 'chart.scale.formatter': null, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.invert': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.title': '', 'chart.numticks': null, 'chart.hmargin': 0, 'chart.linewidth': 1, 'chart.noendtick.left': false, 'chart.noendtick.right': false, 'chart.noxaxis': false, 'chart.max': null, 'chart.min': 0, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.XAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels' && !prop['chart.numxticks']) {\n      prop['chart.numxticks'] = value.length;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawXAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.y - (prop['chart.align'] == 'top' ? prop['chart.text.size'] * 1.5 + 5 : 0) && mouseY <= this.y + (prop['chart.align'] == 'top' ? 0 : prop['chart.text.size'] * 1.5 + 5)) {\n      var x = this.gutterLeft;var y = this.y;var w = ca.width - this.gutterLeft - this.gutterRight;var h = 15;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawXAxis = this.DrawXAxis = function () {\n    var gutterLeft = prop['chart.gutter.left'],\n        gutterRight = prop['chart.gutter.right'],\n        x = this.gutterLeft,\n        y = this.y,\n        min = +prop['chart.min'],\n        max = +prop['chart.max'],\n        labels = prop['chart.labels'],\n        labels_position = prop['chart.labels.position'],\n        color = prop['chart.colors'][0],\n        title_color = prop['chart.title.color'],\n        label_color = prop['chart.text.color'],\n        width = ca.width - this.gutterLeft - this.gutterRight,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        align = prop['chart.align'],\n        numlabels = prop['chart.numlabels'],\n        formatter = prop['chart.scale.formatter'],\n        decimals = Number(prop['chart.scale.decimals']),\n        invert = prop['chart.scale.invert'],\n        scale_visible = prop['chart.scale.visible'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        title = prop['chart.title'];\n    numticks = prop['chart.numticks'], hmargin = prop['chart.hmargin'], linewidth = prop['chart.linewidth'], noleftendtick = prop['chart.noendtick.left'], norightendtick = prop['chart.noendtick.right'], noxaxis = prop['chart.noxaxis'], xaxispos = prop['chart.xaxispos'], yaxispos = prop['chart.yaxispos'];\n    if (RG.is_null(numticks)) {\n      if (labels && labels.length) {\n        numticks = labels.length;\n      } else if (!labels && max != 0) {\n        numticks = 10;\n      } else {\n        numticks = numlabels;\n      }\n    }\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noxaxis) {\n      pa2(co, ['b', 'm', x, ma.round(y), 'l', x + width, ma.round(y), 's', co.strokeStyle]);co.beginPath();for (var i = noleftendtick ? 1 : 0; i <= numticks - (norightendtick ? 1 : 0); ++i) {\n        co.moveTo(ma.round(x + width / numticks * i), xaxispos == 'center' ? align == 'bottom' ? y - 3 : y + 3 : y);co.lineTo(ma.round(x + width / numticks * i), y + (align == 'bottom' ? 3 : -3));\n      }\n      co.stroke();\n    }\n    co.fillStyle = label_color;if (labels) {\n      numlabels = labels.length;var h = 0;var l = 0;var single_line = RG.MeasureText('Mg', false, font, size);for (var i = 0, len = labels.length; i < len; ++i) {\n        var dimensions = RG.MeasureText(labels[i], false, font, size);var h = ma.max(h, dimensions[1]);var l = ma.max(l, labels[i].split('\\r\\n').length);\n      }\n      for (var i = 0, len = labels.length; i < len; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': labels_position == 'edge' ? (width - hmargin - hmargin) / (labels.length - 1) * i + gutterLeft + hmargin : (width - hmargin - hmargin) / labels.length * i + width / labels.length / 2 + gutterLeft + hmargin, 'y': align == 'bottom' ? y + 3 : y - 3 - h + single_line[1], 'text': String(labels[i]), 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else if (scale_visible) {\n      if (max === null) {\n        alert('[DRAWING.XAXIS] If not specifying axis.labels you must specify axis.max!');\n      }\n      if (yaxispos == 'center') {\n        width /= 2;var additionalX = width;\n      } else {\n        var additionalX = 0;\n      }\n      for (var i = 0; i <= numlabels; ++i) {\n        if (i == 0 && !prop['chart.scale.zerostart']) {\n          continue;\n        }\n        var original = (max - min) / numlabels * i + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post));if (invert) {\n          var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft + additionalX;\n        } else {\n          var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin + additionalX;\n        }\n        RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + 3 : y - 3, 'text': text, 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (yaxispos == 'center') {\n        for (var i = 0; i < numlabels; ++i) {\n          var original = (max - min) / numlabels * (numlabels - i) + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.number_format(this, original.toFixed(decimals), units_pre, units_post));if (invert) {\n            var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft;\n          } else {\n            var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + size + 2 : y - size - 2, 'text': '-' + text, 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n      }\n    }\n    if (title) {\n      var dimensions = RG.MeasureText(title, false, font, size + 2);co.fillStyle = title_color;\n      RG.Text2(this, { 'font': font, 'size': size + 2, 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': align == 'bottom' ? y + dimensions[1] + 10 : y - dimensions[1] - 10, 'text': title, 'valign': 'center', 'halign': 'center', 'tag': 'title' });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.xaxis.js\n// module id = 186\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.xaxis.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.YAxis = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext(\"2d\");this.canvas.__object__ = this;this.x = x;this.coords = [];this.coordsText = [];this.original_colors = [];this.maxLabelLength = 0;this.firstDraw = true;this.type = 'drawing.yaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = (_properties = { 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.min': 0, 'chart.max': null, 'chart.colors': ['black'], 'chart.title': '', 'chart.title.color': null, 'chart.numticks': 5, 'chart.numlabels': 5, 'chart.labels.specific': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': null, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'left', 'hart.scale.formatter': null, 'chart.scale.point': '.', 'chart.scale.decimals': 0 }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.invert', false), _defineProperty(_properties, 'chart.scale.zerostart', true), _defineProperty(_properties, 'chart.scale.visible', true), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.noendtick.top', false), _defineProperty(_properties, 'chart.noendtick.bottom', false), _defineProperty(_properties, 'chart.noyaxis', false), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.xaxispos', 'bottom'), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[DRAWING.YAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawYAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.x - (prop['chart.align'] == 'right' ? 0 : this.getWidth()) && mouseX <= this.x + (prop['chart.align'] == 'right' ? this.getWidth() : 0) && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var x = this.x;var y = this.gutterTop;var w = 15;;var h = ca.height - this.gutterTop - this.gutterBottom;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - this.gutterBottom);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawYAxis = this.DrawYAxis = function () {\n    for (i in prop) {\n      if (typeof i == 'string') {\n        var key = i.replace(/^chart\\./, 'axis.');prop[key] = prop[i];\n      }\n    }\n    var x = this.x,\n        y = this.gutterTop,\n        height = ca.height - this.gutterBottom - this.gutterTop,\n        min = +prop['chart.min'] ? +prop['chart.min'] : 0,\n        max = +prop['chart.max'],\n        title = prop['chart.title'] ? prop['chart.title'] : '',\n        color = prop['chart.colors'] ? prop['chart.colors'][0] : 'black',\n        title_color = prop['chart.title.color'] ? prop['chart.title.color'] : color,\n        label_color = prop['chart.text.color'] ? prop['chart.text.color'] : color,\n        numticks = typeof prop['chart.numticks'] == 'number' ? prop['chart.numticks'] : 10,\n        labels_specific = prop['chart.labels.specific'],\n        numlabels = prop['chart.numlabels'] ? prop['chart.numlabels'] : 5,\n        font = prop['chart.text.font'] ? prop['chart.text.font'] : 'Arial',\n        size = prop['chart.text.size'] ? prop['chart.text.size'] : 10;\n    align = typeof prop['chart.align'] == 'string' ? prop['chart.align'] : 'left', formatter = prop['chart.scale.formatter'], decimals = prop['chart.scale.decimals'], invert = prop['chart.scale.invert'], scale_visible = prop['chart.scale.visible'], units_pre = prop['chart.units.pre'], units_post = prop['chart.units.post'], linewidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 1, notopendtick = prop['chart.noendtick.top'], nobottomendtick = prop['chart.noendtick.bottom'], noyaxis = prop['chart.noyaxis'], xaxispos = prop['chart.xaxispos'];\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noyaxis) {\n      pa2(co, ['b', 'm', Math.round(x), y, 'l', Math.round(x), y + height, 's', color]);if (numticks) {\n        var gap = (xaxispos == 'center' ? height / 2 : height) / numticks;var halfheight = height / 2;co.beginPath();for (var i = notopendtick ? 1 : 0; i <= numticks - (nobottomendtick || xaxispos == 'center' ? 1 : 0); ++i) {\n          pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + gap * i), 'l', x, Math.round(y + gap * i)]);\n        }\n        if (xaxispos == 'center') {\n          for (var i = 1; i <= numticks; ++i) {\n            pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + halfheight + gap * i), 'l', x, Math.round(y + halfheight + gap * i)]);\n          }\n        }\n        co.stroke();\n      }\n    }\n    co.fillStyle = label_color;var text_len = 0;if (scale_visible) {\n      if (labels_specific && labels_specific.length) {\n        var text_len = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          text_len = ma.max(text_len, co.measureText(labels_specific[i]).width);\n        }\n        for (var i = 0, len = labels_specific.length; i < len; ++i) {\n          var gap = len - 1 > 0 ? height / (len - 1) : 0;if (xaxispos == 'center') {\n            gap /= 2;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': i * gap + this.gutterTop, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });this.maxLabelLength = ma.max(this.maxLabelLength, co.measureText(labels_specific[i]).width);\n        }\n        if (xaxispos == 'center') {\n          for (var i = labels_specific.length - 2; i >= 0; --i) {\n            RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - i * gap, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      } else {\n        for (var i = 0; i <= numlabels; ++i) {\n          var original = (max - min) * ((numlabels - i) / numlabels) + min;if (original == 0 && prop['chart.scale.zerostart'] == false) {\n            continue;\n          }\n          var text = RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post);var text = String(typeof formatter == 'function' ? formatter(this, original) : text);var text_len = ma.max(text_len, co.measureText(text).width);this.maxLabelLength = text_len;if (invert) {\n            var y = height - height / numlabels * i;\n          } else {\n            var y = height / numlabels * i;\n          }\n          if (prop['chart.xaxispos'] == 'center') {\n            y = y / 2;\n          }\n          text = text.replace(/^-,([0-9])/, '-$1');RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': y + this.gutterTop, 'text': text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });if (prop['chart.xaxispos'] == 'center' && i < numlabels) {\n            RG.Text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - y, 'text': '-' + text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (title) {\n      co.beginPath();co.fillStyle = title_color;if (labels_specific) {\n        var width = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          width = Math.max(width, co.measureText(labels_specific[i]).width);\n        }\n      } else {\n        var width = co.measureText(prop['chart.units.pre'] + prop['chart.max'].toFixed(prop['chart.scale.decimals']) + prop['chart.units.post']).width;\n      }\n      RG.text2(this, { font: font, size: size + 2, x: align == 'right' ? x + width + 8 : x - width - 8, y: height / 2 + this.gutterTop, text: title, valign: 'bottom', halign: 'center', angle: align == 'right' ? 90 : -90, accessible: false });co.stroke();\n    }\n  };this.getWidth = function () {\n    var width = this.maxLabelLength;if (prop['chart.title'] && prop['chart.title'].length) {\n      width += prop['chart.text.size'] * 1.5;\n    }\n    this.width = width;return width;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.drawing.yaxis.js\n// module id = 187\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.drawing.yaxis.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Fuel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'fuel';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.angles = {};this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.colors': ['Gradient(white:red)'], 'chart.needle.color': 'red', 'chart.gutter.left': 5, 'chart.gutter.right': 5, 'chart.gutter.top': 5, 'chart.gutter.bottom': 5, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.icon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAfCAYAAAD0ma06AAAEGElEQVRIS7VXSyhtYRT+jnfe5FEMjAwUBiQGHikzRWIkkgy8YyDK+xnJK5JCeZSUGKBMiAyYkMxMJAMpSfJ+2/d8695/33NunSPnHqt2Z5+91/9/' + '/' + '/et9a/1b8Pn56dmMBhg/IWDgwNoNzc38PHxkXtN0+Tiexp9eH18fIDj1Bj63N/fw8vLS/wsmcHoqKmXT09PuL29RVFREU5OTvTJ6UIAgioQ+vLe09MTb29v8PX1RWBgICYnJ+XXIqDRWXN0dJT3nIDsWlpadP+lpSWZlD4KmL/8/' + '/7+Ls/S09N1/7y8PISHh+sK/QssDJWcHEyGCnB1dRUDAwPIzMzUx5GpAnZ1dcXy8jK2trbM5j06OsLc3JzISx8q4OzsLOOsAq6treHg4AAeHh4WJbq7u0Nzc7P+PiYmBnt7ezg9PcXExAQCAgLg5OSEx8dHuLu7Wwfc3t7G/v6+yEcjO8rIROGKaWdnZ+jr6zMDjI6OxvT0tDzr6uqS2KtksspwZ2cHjY2NuqSUhnHmilUCraysmElaWloKJpQCjI2NRX5+Pl5eXr6WlCv08/MTEMVOZDH+Zzw4CdlfX1/rDHt7ezE1NQXGkcYEKi4ulkVKYlpLGouBs/JiaGgIZL25uSlecXFxohAz/ccAz8/P4e/vj7q6Ojw8PMje5DNRy94MQ0JCUFtbK2wqKipE+sHBQbi4uPwMQ86ak5ODxMREVFdXIywsDCUlJRJDXnZlmJqaip6eHuTm5kqikGlycjIyMjL+ZrY9JSUgMzQiIgINDQ2ypaqqqkCZWXHsnjQEHB8fR0pKigAxabq7uyWOlJNxtLukTJDs7GxUVlZKDNl5oqKi8Pr6+jOAIyMjiI+Pl5JGQG4F1Qy+LN7f3fiUdGZmBsHBwRgbG8Pw8LD01ba2NmlX0rTtnTQLCwvSjEdHR3FxcSExLCwsRGRkpBR9vePzeMDyw3bT1NT0XXLiT4a7u7s4Pj4GGzd7K8GCgoKEsRR8I4Cm6hwHXV5eiv62GAE5npMTmFuBTCkzmzT7qs5Q9TlW/o6ODlvwhCHPM5SVPZIxYzNeXFxEa2srvL29YTC2GI3aMm3Zeq6urv4LMC0tDRsbG1K8k5KS9DgS0IwhKVFjSsJA22r9/f0oKCgQdvPz83JEmZ2dlcpD9maSshow0KZnlO8Csx9yK3BLKCMJPpf2xGMigdi9WXooaWdn53dxdP+amhrZh4eHh1hfX5cTW319vZyBnp+ffzNkBWBmhYaGysB/j322oCckJCArK0uGMlsJ5ubmBoPxRiMzFlomjr2MGdne3i5ANILRJEtJt6ysTG8h9gDl4am8vFwSUWron1O9LulXIOqk9pWftfdSS40yyj5Uh101wPRryuR7R1ZMX/U1pfy5IF40xcgUnGAc9wsGYxsFhy87kwAAAABJRU5ErkJggg=='), _defineProperty(_properties, 'chart.icon.redraw', true), _defineProperty(_properties, 'chart.background.image.stretch', false), _defineProperty(_properties, 'chart.background.image.x', null), _defineProperty(_properties, 'chart.background.image.y', null), _defineProperty(_properties, 'chart.labels.full', 'F'), _defineProperty(_properties, 'chart.labels.empty', 'E'), _defineProperty(_properties, 'chart.labels.count', 5), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.scale.visible', false), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - 20 - this.gutterBottom;\n    this.radius = ca.height - this.gutterTop - this.gutterBottom - 20;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.angles.start = RG.PI + RG.HALFPI - 0.5;this.angles.end = RG.PI + RG.HALFPI + 0.5;this.angles.needle = this.getAngle(this.value);this.DrawLabels();this.DrawChart();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawChart = this.DrawChart = function () {\n    this.DrawScale();if (!RG.ISOLD) {\n      this.DrawIcon();\n    }\n    this.DrawNeedle();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.scale.visible']) {\n      var radius = this.radius - 20;co.fillStyle = prop['chart.text.color'];var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx - Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.empty'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx + Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.full'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function () {\n    co.beginPath();co.lineWidth = 5;co.lineCap = 'round';co.strokeStyle = prop['chart.needle.color'];var angle = this.angles.needle;co.arc(this.centerx, this.centery, this.radius - 30, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);co.stroke();co.lineWidth = 1;var cx = this.centerx + 10;var cy = this.centery - 10;\n    var grad = co.createRadialGradient(cx, cy, 35, cx, cy, 0);grad.addColorStop(0, 'black');grad.addColorStop(1, '#eee');if (navigator.userAgent.indexOf('Firefox/6.0') > 0) {\n      grad = co.createLinearGradient(cx + 10, cy - 10, cx - 10, cy + 10);grad.addColorStop(1, '#666');grad.addColorStop(0.5, '#ccc');\n    }\n    co.beginPath();co.fillStyle = grad;co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 20, 0, RG.TWOPI, 0);co.fill();\n  };this.drawScale = this.DrawScale = function () {\n    var a, x, y;co.beginPath();co.strokeStyle = 'black';co.fillStyle = 'white';co.arc(this.centerx, this.centery, this.radius, this.angles.start, this.angles.end, false);co.arc(this.centerx, this.centery, this.radius - 10, this.angles.end, this.angles.start, true);co.closePath();co.stroke();co.fill();var start = this.angles.start;var end = this.angles.needle;co.beginPath();co.fillStyle = prop['chart.colors'][0];co.arc(this.centerx, this.centery, this.radius, start, end, false);co.arc(this.centerx, this.centery, this.radius - 10, end, start, true);co.closePath();co.fill();for (a = this.angles.start; a <= this.angles.end + 0.01; a += (this.angles.end - this.angles.start) / 5) {\n      co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10, a, a + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 15, a + 0.0001, a, true);co.stroke();\n    }\n    if (prop['chart.scale.visible']) {\n      co.fillStyle = prop['chart.text.color'];var numLabels = prop['chart.labels.count'];var decimals = prop['chart.scale.decimals'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var units_post = prop['chart.units.post'];var units_pre = prop['chart.units.pre'];for (var i = 0; i <= numLabels; ++i) {\n        a = (this.angles.end - this.angles.start) * (i / numLabels) + this.angles.start;y = this.centery - Math.sin(a - RG.PI) * (this.radius - 25);x = this.centerx - Math.cos(a - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': RG.number_format(this, (this.min + (this.max - this.min) * (i / numLabels)).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (angle >= this.angles.end) {\n      return this.max;\n    } else if (angle <= this.angles.start) {\n      return this.min;\n    }\n    var value = (angle - this.angles.start) / (this.angles.end - this.angles.start);value = value * (this.max - this.min);value = value + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var accuracy = 15;var leftMin = this.centerx - this.radius;var rightMax = this.centerx + this.radius;var topMin = this.centery - this.radius;var bottomMax = this.centery + this.radius;if (mouseXY[0] > leftMin && mouseXY[0] < rightMax && mouseXY[1] > topMin && mouseXY[1] < bottomMax) {\n      return this;\n    }\n  };this.drawIcon = this.DrawIcon = function () {\n    if (!RG.ISOLD) {\n      if (!this.__icon__ || !this.__icon__.__loaded__) {\n        var img = new Image();img.src = prop['chart.icon'];img.__object__ = this;this.__icon__ = img;img.onload = function (e) {\n          img.__loaded__ = true;var obj = img.__object__;co.drawImage(img, obj.centerx - img.width / 2, obj.centery - obj.radius + 35);obj.DrawNeedle();if (prop['chart.icon.redraw']) {\n            obj.Set('chart.icon.redraw', false);RG.Clear(obj.canvas);RG.RedrawCanvas(ca);\n          }\n        };\n      } else {\n        var img = this.__icon__;co.drawImage(img, this.centerx - img.width / 2, this.centery - this.radius + 35);\n      }\n    }\n    this.DrawNeedle();\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.angles.end - this.angles.start) + this.angles.start;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.needle.color'] = RG.array_clone(prop['chart.needle.color']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForLinearGradient(colors[i]);\n    }\n    props['chart.needle.color'] = this.parseSingleColorForRadialGradient(props['chart.needle.color']);\n  };this.reset = function () {};this.parseSingleColorForLinearGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForRadialGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var callback = arguments[1] || function () {};var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;var obj = this;var origValue = Number(this.currentValue);if (this.currentValue == null) {\n      this.currentValue = this.min;origValue = this.min;\n    }\n    var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;function iterator() {\n      frame++;obj.value = frame / numFrames * diff + origValue;\n      if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < numFrames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.fuel.js\n// module id = 188\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.fuel.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Funnel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'funnel';this.coords = [];this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUNNEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': null, 'chart.labels.sticks': false, 'chart.labels.x': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['Gradient(white:red)', 'Gradient(white:green)', 'Gradient(white:gray)', 'Gradient(white:blue)', 'Gradient(white:black)', 'Gradient(white:gray)', 'Gradient(white:pink)', 'Gradient(white:blue)', 'Gradient(white:yellow)', 'Gradient(white:green)', 'Gradient(white:red)'], 'chart.text.size': 12, 'chart.text.boxed': true, 'chart.text.halign': 'left', 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips.highlight': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var i = 0; i < data.length; ++i) {\n    data[i] = parseFloat(data[i]);\n  }\n  this.data = data;for (var i = 0; i < data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.DrawFunnel();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawLabels();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawFunnel = this.DrawFunnel = function () {\n    var width = ca.width - this.gutterLeft - this.gutterRight;var height = ca.height - this.gutterTop - this.gutterBottom;var total = RG.array_max(this.data);var accheight = this.gutterTop;if (prop['chart.shadow']) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (i = 0, len = this.data.length; i < len; ++i) {\n      var firstvalue = this.data[0];var firstwidth = firstvalue / total * width;var curvalue = this.data[i];var curwidth = curvalue / total * width;var curheight = height / this.data.length;var halfCurWidth = curwidth / 2;var nextvalue = this.data[i + 1];var nextwidth = this.data[i + 1] ? nextvalue / total * width : null;var halfNextWidth = nextwidth / 2;var center = this.gutterLeft + firstwidth / 2;var x1 = center - halfCurWidth;var y1 = accheight;var x2 = center + halfCurWidth;var y2 = accheight;var x3 = center + halfNextWidth;var y3 = accheight + curheight;var x4 = center - halfNextWidth;var y4 = accheight + curheight;if (nextwidth && i < this.data.length - 1) {\n        co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.moveTo(x1, y1);co.lineTo(x2, y2);co.lineTo(x3, y3);co.lineTo(x4, y4);co.closePath();this.coords.push([x1, y1, x2, y2, x3, y3, x4, y4]);\n      }\n      if (!prop['chart.shadow']) {\n        co.stroke();\n      }\n      co.fill();accheight += curheight;\n    }\n    if (prop['chart.shadow']) {\n      RG.NoShadow(this);for (i = 0; i < this.coords.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.beginPath();co.moveTo(this.coords[i][0], this.coords[i][1]);co.lineTo(this.coords[i][2], this.coords[i][3]);co.lineTo(this.coords[i][4], this.coords[i][5]);co.lineTo(this.coords[i][6], this.coords[i][7]);co.closePath();co.stroke();co.fill();\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var color = prop['chart.text.color'];var labels = prop['chart.labels'];var halign = prop['chart.text.halign'] == 'left' ? 'left' : 'center';var bgcolor = prop['chart.text.boxed'] ? 'white' : null;if (typeof prop['chart.labels.x'] == 'number') {\n        var x = prop['chart.labels.x'];\n      } else {\n        var x = halign == 'left' ? this.gutterLeft - 15 : (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;\n      }\n      for (var j = 0; j < this.coords.length; ++j) {\n        co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;RG.NoShadow(this);var label = labels[j];RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j][1], 'text': label, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(label).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, ma.round(this.coords[j][1]));co.lineTo(this.coords[j][0] - 10, ma.round(this.coords[j][1]));co.stroke();\n        }\n      }\n      var lastLabel = labels[j];if (lastLabel) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j - 1][5], 'text': lastLabel, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(lastLabel).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, Math.round(this.coords[j - 1][7]));co.lineTo(this.coords[j - 1][6] - 10, Math.round(this.coords[j - 1][7]));co.stroke();\n        }\n      }\n    }\n  };this.getShape = this.getSegment = function (e) {\n    var coords = this.coords;var mouseCoords = RG.getMouseXY(e);var x = mouseCoords[0];var y = mouseCoords[1];for (i = 0, len = coords.length; i < len; ++i) {\n      var segment = coords[i];\n      co.beginPath();co.moveTo(segment[0], segment[1]);co.lineTo(segment[2], segment[3]);co.lineTo(segment[4], segment[5]);co.lineTo(segment[6], segment[7]);co.lineTo(segment[8], segment[9]);if (co.isPointInPath(x, y)) {\n        var tooltip = RGraph.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: coords, 2: i, 'object': this, 'coords': segment, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      var coords = shape['coords'];pa2(co, 'b m % % l % % l % % l % % c s % f %', coords[0], coords[1], coords[2], coords[3], coords[4], coords[5], coords[6], coords[7], prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForHorizontalGradient(colors[i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForHorizontalGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForVerticalGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForHorizontalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForVerticalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - prop['chart.gutter.bottom']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];if (coords && coords.length == 8) {\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.beginPath();co.moveTo(coords[0], coords[1]);co.lineTo(coords[2], coords[3]);co.lineTo(coords[4], coords[5]);co.lineTo(coords[6], coords[7]);co.closePath();co.fill();co.stroke();co.lineWidth = pre_linewidth;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.funnel.js\n// module id = 189\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.funnel.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gantt = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gantt';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.data = data;this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 7, 'chart.background.grid.autofit.numvlines': null, 'chart.vbars': [], 'chart.hbars': [], 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.gutter.left': 75, 'chart.gutter.right': 25, 'chart.gutter.top': 35, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.align': 'bottom', 'chart.labels.inbar': null, 'chart.labels.inbar.color': 'black', 'chart.labels.inbar.bgcolor': null, 'chart.labels.inbar.align': 'left', 'chart.labels.inbar.size': 10, 'chart.labels.inbar.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.inbar.above': false, 'chart.labels.percent': true, 'chart.vmargin': 2, 'chart.title': '', 'chart.title.background': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.color': null, 'chart.title.yaxis.position': 'right', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.bold': true, 'chart.title.xaxis.color': null }, _defineProperty(_properties, 'chart.title.x', null), _defineProperty(_properties, 'chart.title.y', null), _defineProperty(_properties, 'chart.title.halign', null), _defineProperty(_properties, 'chart.title.valign', null), _defineProperty(_properties, 'chart.borders', true), _defineProperty(_properties, 'chart.defaultcolor', 'white'), _defineProperty(_properties, 'chart.coords', []), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.xmax', 0), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!data) {\n    alert('[GANTT] The Gantt chart event data is now supplied as the second argument to the constructor - please update your code');\n  } else {\n    for (var i = 0, idx = 0; i < data.length; ++i) {\n      if (typeof data[i][0] === 'string') data[i][0] = parseFloat(data[i][0]);if (typeof data[i][1] === 'string') data[i][1] = parseFloat(data[i][1]);if (typeof data[i][2] === 'string') data[i][2] = parseFloat(data[i][2]);if (typeof data[i][7] === 'string') data[i][7] = parseFloat(data[i][7]);\n    }\n  }\n  for (var i = 0, idx = 0; i < data.length; ++i) {\n    if (RGraph.isArray(this.data[i][0])) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        this['$' + idx++] = {};\n      }\n    } else {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    if (name == 'chart.events') {\n      alert('[GANTT] The chart.events property is deprecated - supply the events data as an argument to the constructor instead');this.data = value;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.graphArea = ca.width - this.gutterLeft - this.gutterRight;this.graphHeight = ca.height - this.gutterTop - this.gutterBottom;this.numEvents = this.data.length;\n    this.barHeight = this.graphHeight / this.numEvents;this.halfBarHeight = this.barHeight / 2;RG.background.Draw(this);this.drawLabels();this.DrawEvents();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];var labelsColor = prop['chart.labels.color'] || prop['chart.text.color'];var labelSpace = this.graphArea / labels.length;var x = this.gutterLeft + labelSpace / 2;var y = this.gutterTop - prop['chart.text.size'] / 2 - 5;var font = prop['chart.text.font'];var size = prop['chart.text.size'];co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';\n    if (prop['chart.labels.align'] == 'bottom') {\n      y = ca.height - this.gutterBottom + size + 2;\n    }\n    for (i = 0; i < labels.length; ++i) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': x + i * labelSpace, 'y': y, 'text': String(labels[i]), 'halign': 'center', 'valign': 'center', 'tag': 'labels.horizontal' });\n    }\n    for (var i = 0, len = this.data.length; i < len; ++i) {\n      var ev = this.data[i];var x = this.gutterLeft;var y = this.gutterTop + this.halfBarHeight + i * this.barHeight;co.fillStyle = labelsColor || prop['chart.text.color'];RG.text2(this, { 'font': font, 'size': size, 'x': x - 5, 'y': y, 'text': RG.isArray(ev[0]) ? ev[0][3] ? String(ev[0][3]) : '' : typeof ev[3] == 'string' ? ev[3] : '', 'halign': 'right', 'valign': 'center', 'tag': 'labels.vertical' });\n    }\n  };this.drawEvents = this.DrawEvents = function () {\n    var events = this.data;this.coords = [];if (prop['chart.vbars']) {\n      for (i = 0, len = prop['chart.vbars'].length; i < len; ++i) {\n        if (prop['chart.vbars'][i][0] + prop['chart.vbars'][i][1] > prop['chart.xmax']) {\n          prop['chart.vbars'][i][1] = 364 - prop['chart.vbars'][i][0];\n        }\n        var barX = this.gutterLeft + (prop['chart.vbars'][i][0] - prop['chart.xmin']) / (prop['chart.xmax'] - prop['chart.xmin']) * this.graphArea;var barY = this.gutterTop;var width = this.graphArea / (prop['chart.xmax'] - prop['chart.xmin']) * prop['chart.vbars'][i][1];var height = ca.height - this.gutterTop - this.gutterBottom;if (barX + width > ca.width - this.gutterRight) {\n          width = ca.width - this.gutterRight - barX;\n        }\n        co.fillStyle = prop['chart.vbars'][i][2];co.fillRect(barX, barY, width, height);\n      }\n    }\n    if (prop['chart.hbars']) {\n      for (i = 0, len = prop['chart.hbars'].length; i < len; ++i) {\n        if (prop['chart.hbars'][i]) {\n          var barX = this.gutterLeft,\n              barY = (ca.height - this.gutterTop - this.gutterBottom) / this.data.length * i + this.gutterTop,\n              width = this.graphArea,\n              height = this.barHeight;\n          co.fillStyle = prop['chart.hbars'][i];co.fillRect(barX, barY, width, height);\n        }\n      }\n    }\n    var sequentialIndex = 0;for (i = 0; i < events.length; ++i) {\n      if (typeof events[i][0] == 'number') {\n        this.DrawSingleEvent(events[i], i, sequentialIndex++);\n      } else {\n        for (var j = 0; j < events[i].length; ++j) {\n          var subindex = j;this.DrawSingleEvent(events[i][j], i, sequentialIndex++, subindex);\n        }\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    e = RG.fixEventObject(e);var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);var ret = { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: this.coords[i][4].index, subindex: this.coords[i][4] && typeof this.coords[i][4].subindex === 'number' ? this.coords[i][4].subindex : null, sequentialIndex: this.coords[i][5], tooltip: tooltip };return ret;\n      }\n    }\n  };this.drawSingleEvent = this.DrawSingleEvent = function (ev, index, sequentialIndex) {\n    ev.index = index;if (typeof arguments[3] === 'number') {\n      ev.subindex = arguments[3];\n    }\n    var min = prop['chart.xmin'];co.beginPath();co.strokeStyle = 'black';co.fillStyle = ev[4] ? ev[4] : prop['chart.defaultcolor'];var barStartX = this.gutterLeft + (ev[0] - min) / (prop['chart.xmax'] - min) * this.graphArea;var barStartY = this.gutterTop + index * this.barHeight;var barWidth = ev[1] / (prop['chart.xmax'] - min) * this.graphArea;if (barStartX + barWidth > ca.width - this.gutterRight) {\n      barWidth = ca.width - this.gutterRight - barStartX;\n    }\n    this.coords.push([barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin'], ev, sequentialIndex]);if (prop['chart.borders'] || ev[6]) {\n      co.strokeStyle = typeof ev[6] == 'string' ? ev[6] : 'black';co.lineWidth = typeof ev[7] == 'number' ? ev[7] : 1;co.beginPath();co.strokeRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);\n    }\n    co.beginPath();co.fillRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);co.fill();var complete = ev[2] / 100 * barWidth;if (typeof ev[2] == 'number') {\n      co.beginPath();co.fillStyle = ev[5] ? ev[5] : '#0c0';co.fillRect(barStartX, barStartY + prop['chart.vmargin'], ev[2] / 100 * barWidth, this.barHeight - 2 * prop['chart.vmargin']);if (prop['chart.labels.percent']) {\n        co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': barStartX + barWidth + 5, 'y': barStartY + this.halfBarHeight, 'text': String(ev[2]) + '%', 'valign': 'center', 'tag': 'labels.complete' });\n      }\n    }\n    if (prop['chart.labels.inbar'] && prop['chart.labels.inbar'][sequentialIndex]) {\n      var label = String(prop['chart.labels.inbar'][sequentialIndex]);var halign = prop['chart.labels.inbar.align'] == 'left' ? 'left' : 'center';halign = prop['chart.labels.inbar.align'] == 'right' ? 'right' : halign;if (halign == 'right') {\n        var x = barStartX + barWidth - 5;\n      } else if (halign == 'center') {\n        var x = barStartX + barWidth / 2;\n      } else {\n        var x = barStartX + 5;\n      }\n      if (prop['chart.labels.inbar.above']) {\n        x = barStartX + barWidth + 5;halign = 'left';\n      }\n      co.fillStyle = prop['chart.labels.inbar.color'];RG.text2(this, { 'font': prop['chart.labels.inbar.font'], 'size': prop['chart.labels.inbar.size'], 'x': x, 'y': barStartY + this.halfBarHeight, 'text': label, 'valign': 'center', 'halign': halign, 'bounding': typeof prop['chart.labels.inbar.bgcolor'] == 'string', 'boundingFill': typeof prop['chart.labels.inbar.bgcolor'] == 'string' ? prop['chart.labels.inbar.bgcolor'] : null, 'tag': 'labels.inbar' });\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var bar = RG.Registry.get('chart.adjusting.gantt');if (bar) {\n        var mouseXY = RG.getMouseXY(e),\n            obj = RG.Registry.get('chart.adjusting.gantt')['object'],\n            index = bar['index'],\n            subindex = bar['subindex'],\n            diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'],\n            eventStart = RG.Registry.get('chart.adjusting.gantt')['event_start'],\n            duration = RG.Registry.get('chart.adjusting.gantt')['event_duration'],\n            event = typeof subindex === 'number' ? obj.data[index][subindex] : obj.data[index];\n        if (bar['mode'] == 'move') {\n          diff = ma.round(diff);if (RG.isNull(subindex)) {\n            event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              obj.data[index][0] = 0;\n            } else if (eventStart + diff + obj.data[index][1] > prop['chart.xmax']) {\n              obj.data[index][0] = prop['chart.xmax'] - obj.data[index][1];\n            }\n          } else {\n            var index = RG.Registry.get('chart.adjusting.gantt').index;var subindex = RG.Registry.get('chart.adjusting.gantt').subindex;var event = this.data[index][subindex];event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              event[0] = 0;\n            } else if (eventStart + diff + event[1] > prop['chart.xmax']) {\n              event[0] = prop['chart.xmax'] - event[1];\n            }\n          }\n        } else if (bar['mode'] == 'resize') {\n          if (mouseXY[0] > ca.width - obj.gutterRight) {\n            mouseXY[0] = ca.width - obj.gutterRight;\n          }\n          var diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'];diff = ma.round(diff);if (RG.isNull(subindex)) {\n            obj.data[index][1] = duration + diff;if (obj.data[index][1] < 0) {\n              obj.data[index][1] = 1;\n            }\n          } else {\n            obj.data[index][subindex][1] = duration + diff;if (obj.data[index][subindex][1] < 0) {\n              obj.data[index][subindex][1] = 1;\n            }\n          }\n        }\n        RG.resetColorsToOriginalValues(this);RG.redrawCanvas(ca);RG.fireCustomEvent(obj, 'onadjust');\n      }\n    }\n  };this.getXCoord = function (value) {\n    var min = prop['chart.xmin'];var max = prop['chart.xmax'];var graphArea = ca.width - this.gutterLeft - this.gutterRight;if (value > max || value < min) {\n      return null;\n    }\n    var x = (value - min) / (max - min) * graphArea + this.gutterLeft;return x;\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseXY = arg;\n    } else {\n      var mouseXY = RGraph.getMouseXY(arg);\n    }\n    var mouseX = mouseXY[0];var mouseY = mouseXY[1];var value = (mouseX - this.gutterLeft) / (ca.width - this.gutterLeft - this.gutterRight);value *= prop['chart.xmax'] - prop['chart.xmin'];if (value < prop['chart.xmin'] || value > prop['chart.xmax']) {\n      value = null;\n    }\n    return value;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.arrayClone(this.data);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i) {\n      if (_typeof(this.data[i][0]) == 'object' && typeof this.data[i][0][0] === 'number') {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1, sequentialIndex += 1) {\n          this.data[i][j][4] = this.parseSingleColorForGradient(this.data[i][j][4], { start: this.data[i][j][0], duration: this.data[i][j][1] });this.data[i][j][5] = this.parseSingleColorForGradient(this.data[i][j][5], { start: this.data[i][j][0], duration: this.data[i][j][1] });\n        }\n      } else {\n        if (typeof this.data[i][4] == 'string') this.data[i][4] = this.parseSingleColorForGradient(this.data[i][4], { start: this.data[i][0], duration: this.data[i][1] });if (typeof this.data[i][5] == 'string') this.data[i][5] = this.parseSingleColorForGradient(this.data[i][5], { start: this.data[i][0], duration: this.data[i][1] });++sequentialIndex;\n      }\n    }\n    prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var opts = arguments[1] || {};if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var value = opts.start + opts.duration > prop['chart.xmax'] ? prop['chart.xmax'] : opts.start + opts.duration;var grad = co.createLinearGradient(typeof opts.start === 'number' ? this.getXCoord(opts.start) : this.gutterLeft, 0, typeof opts.start === 'number' ? this.getXCoord(value) : ca.width - this.gutterRight, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] ? arguments[1] : function () {};var canvas = obj.canvas;var context = obj.context;var numFrames = opt.frames || 30;var frame = 0;var original_events = RG.arrayClone(obj.data);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= numFrames) {\n        for (var i = 0, len = obj.data.length; i < len; ++i) {\n          if (_typeof(obj.data[i][0]) === 'object') {\n            for (var j = 0; j < obj.data[i].length; ++j) {\n              obj.data[i][j][1] = frame / numFrames * original_events[i][j][1];\n            }\n          } else {\n            obj.data[i][1] = frame / numFrames * original_events[i][1];\n          }\n        }\n        obj.reset();frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0; i < this.original_colors['data'].length; ++i) {\n      if (this.original_colors['data'][i][4]) {\n        this.data[i][4] = RG.arrayClone(this.original_colors['data'][i][4]);\n      }\n      if (this.original_colors['data'][i][5]) {\n        this.data[i][5] = RG.arrayClone(this.original_colors['data'][i][5]);\n      }\n      if (_typeof(this.original_colors['data'][i][0]) === 'object' && typeof this.original_colors['data'][i][0][0] === 'number') {\n        for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n          this.data[i][j][4] = RG.arrayClone(this.original_colors['data'][i][j][4]);this.data[i][j][5] = RG.arrayClone(this.original_colors['data'][i][j][5]);\n        }\n      }\n    }\n  };this.reset = function () {\n    this.resetColorsToOriginalValues();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.coords = [];\n  };this.sequentialIndex2Grouped = function () {\n    alert('[RGRAPH] Please post in the forum if you see this alert');\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    } else if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.sequentialIndex]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.gantt.js\n// module id = 190\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.gantt.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gauge';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.angles.start': null, 'chart.angles.end': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 15, 'chart.border.width': 10, 'chart.title.top': '', 'chart.title.top.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.top.size': 14, 'chart.title.top.color': '#333', 'chart.title.top.bold': false, 'chart.title.top.pos': null, 'chart.title.bottom': '', 'chart.title.bottom.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.bottom.size': 14, 'chart.title.bottom.color': '#333', 'chart.title.bottom.bold': false, 'chart.title.bottom.pos': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': '#666', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.background.color': 'white', 'chart.background.gradient': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.value.text': false, 'chart.value.text.y.pos': 0.5, 'chart.value.text.units.pre': null, 'chart.value.text.units.post': null, 'chart.value.text.color': 'black', 'chart.value.text.bounding': true, 'chart.value.text.bounding.fill': 'white', 'chart.value.text.bounding.stroke': 'black', 'chart.red.start': 0.9 * this.max, 'chart.red.color': '#DC3912', 'chart.red.width': 10, 'chart.yellow.color': '#FF9900', 'chart.yellow.width': 10, 'chart.green.end': 0.7 * this.max, 'chart.green.color': 'rgba(0,0,0,0)', 'chart.green.width': 10, 'chart.colors.ranges': null, 'chart.needle.size': null, 'chart.needle.tail': false, 'chart.needle.colors': ['#D5604D', 'red', 'green', 'yellow'], 'chart.needle.type': 'triangle', 'chart.needle.width': 7, 'chart.border.outer': '#ccc', 'chart.border.inner': '#f1f1f1', 'chart.border.outline': 'black', 'chart.centerpin.color': 'blue', 'chart.centerpin.radius': null, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.tickmarks.small': 25, 'chart.tickmarks.small.color': 'black', 'chart.tickmarks.medium': 0, 'chart.tickmarks.medium.color': 'black', 'chart.tickmarks.big': 5, 'chart.tickmarks.big.color': 'black', 'chart.labels.count': 5, 'chart.labels.centered': false, 'chart.labels.offset.radius': 0, 'chart.labels.offset.angle': 0, 'chart.labels.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.border.gradient': false, 'chart.adjustable': false, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.title') name = 'chart.title.top';if (name == 'chart.title.font') name = 'chart.title.top.font';if (name == 'chart.title.size') name = 'chart.title.top.size';if (name == 'chart.title.color') name = 'chart.title.top.color';if (name == 'chart.title.bold') name = 'chart.title.top.bold';if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2);this.startAngle = prop['chart.angles.start'] ? prop['chart.angles.start'] : RG.HALFPI / 3 + RG.HALFPI;this.endAngle = prop['chart.angles.end'] ? prop['chart.angles.end'] : RG.TWOPI + RG.HALFPI - RG.HALFPI / 3;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.centerpinRadius = 0.16 * this.radius;if (typeof prop['chart.centerpin.radius'] == 'number') {\n      this.centerpinRadius = prop['chart.centerpin.radius'];\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawBackGround();this.DrawGradient();this.DrawColorBands();this.DrawSmallTickmarks();this.DrawMediumTickmarks();this.DrawBigTickmarks();this.DrawLabels();this.DrawTopTitle();this.DrawBottomTitle();if (_typeof(this.value) == 'object') {\n      for (var i = 0; i < this.value.length; ++i) {\n        this.DrawNeedle(this.value[i], prop['chart.needle.colors'][i], i);\n      }\n    } else {\n      this.DrawNeedle(this.value, prop['chart.needle.colors'][0], 0);\n    }\n    this.DrawCenterpin();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);var grad = co.createRadialGradient(this.centerx + 50, this.centery - 50, 0, this.centerx + 50, this.centery - 50, 150);grad.addColorStop(0, '#eee');grad.addColorStop(1, 'white');var borderWidth = prop['chart.border.width'];co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.outer'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.inner'];co.arc(this.centerx, this.centery, this.radius - borderWidth, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();if (prop['chart.background.gradient']) {\n      co.beginPath();co.fillStyle = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius, 'rgba(255,255,255,0.6)', 'rgba(255,255,255,0.1)');co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.border.outline'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.stroke();\n  };this.drawSmallTickmarks = this.DrawSmallTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.small'];co.lineWidth = 1;for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 5, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawMediumTickmarks = this.DrawMediumTickmarks = function () {\n    if (prop['chart.tickmarks.medium']) {\n      var numTicks = prop['chart.tickmarks.medium'];co.lineWidth = 3;co.lineCap = 'round';co.strokeStyle = prop['chart.tickmarks.medium.color'];for (var i = 0; i <= numTicks; ++i) {\n        co.beginPath();var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle + (this.endAngle - this.startAngle) / (2 * numTicks);if (a > this.startAngle && a < this.endAngle) {\n          co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 6, a, a + 0.00001, 0);\n        }\n        co.stroke();\n      }\n    }\n  };this.drawBigTickmarks = this.DrawBigTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.big'];co.lineWidth = 3;co.lineCap = 'round';for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 10, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    var offset = 6;var grad = co.createRadialGradient(this.centerx + offset, this.centery - offset, 0, this.centerx + offset, this.centery - offset, 25);grad.addColorStop(0, '#ddf');grad.addColorStop(1, prop['chart.centerpin.color']);co.beginPath();co.fillStyle = grad;co.arc(this.centerx, this.centery, this.centerpinRadius, 0, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        num = prop['chart.labels.specific'] ? prop['chart.labels.specific'].length - 1 : prop['chart.labels.count'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'],\n        offseta = prop['chart.labels.offset.angle'];\n    co.beginPath();if (num) {\n      for (var i = 0; i <= num; ++i) {\n        var hyp = this.radius - 25 - prop['chart.border.width'] - prop['chart.labels.offset.radius'];var a = (this.endAngle - this.startAngle) / num;\n        a = this.startAngle + i * a;a -= RG.HALFPI;a += offseta;var x = this.centerx - ma.sin(a) * hyp;var y = this.centery + ma.cos(a) * hyp;var hAlign = x > this.centerx ? 'right' : 'left';var vAlign = y > this.centery ? 'bottom' : 'top';if (a == RG.HALFPI) {\n          vAlign = 'center';\n        } else if (a == RG.PI) {\n          hAlign = 'center';\n        } else if (a == RG.HALFPI + RG.PI) {\n          vAlign = 'center';\n        }\n        if (prop['chart.labels.centered']) {\n          hAlign = 'center';vAlign = 'center';\n        }\n        var value = (this.max - this.min) * (i / num) + this.min;RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': prop['chart.labels.specific'] ? prop['chart.labels.specific'][i] : RG.numberFormat(this, value.toFixed(value === 0 ? 0 : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), 'halign': hAlign, 'valign': vAlign, 'tag': prop['chart.labels.specific'] ? 'labels.specific' : 'labels' });\n      }\n    }\n    co.fill();if (prop['chart.value.text']) {\n      var x = this.centerx;var y = this.centery + prop['chart.value.text.y.pos'] * this.radius;var units_pre = typeof prop['chart.value.text.units.pre'] == 'string' ? prop['chart.value.text.units.pre'] : prop['chart.units.pre'];var units_post = typeof prop['chart.value.text.units.post'] == 'string' ? prop['chart.value.text.units.post'] : prop['chart.units.post'];var color = prop['chart.value.text.color'];var bounding = prop['chart.value.text.bounding'];var boundingFill = prop['chart.value.text.bounding.fill'];var boundingStroke = prop['chart.value.text.bounding.stroke'];co.fillStyle = color;RG.text2(this, { 'font': font, 'size': size + 2, 'x': x, 'y': y, 'text': RG.numberFormat(this, this.value.toFixed(prop['chart.value.text.decimals']), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'bounding': bounding, 'bounding.fill': boundingFill, 'bounding.stroke': boundingStroke, 'tag': 'value.text' });\n    }\n  };this.drawTopTitle = this.DrawTopTitle = function () {\n    var x = this.centerx;var y = this.centery - 25;if (typeof prop['chart.title.top.pos'] == 'number') {\n      y = this.centery - this.radius * prop['chart.title.top.pos'];\n    }\n    if (prop['chart.title.top']) {\n      co.fillStyle = prop['chart.title.top.color'];RG.Text2(this, { 'font': prop['chart.title.top.font'], 'size': prop['chart.title.top.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.top']), 'halign': 'center', 'valign': 'bottom', 'bold': prop['chart.title.top.bold'], 'tag': 'title.top' });\n    }\n  };this.drawBottomTitle = this.DrawBottomTitle = function () {\n    var x = this.centerx;var y = this.centery + this.centerpinRadius + 10;if (typeof prop['chart.title.bottom.pos'] == 'number') {\n      y = this.centery + this.radius * prop['chart.title.bottom.pos'];\n    }\n    if (prop['chart.title.bottom']) {\n      co.fillStyle = prop['chart.title.bottom.color'];RG.Text2(this, { 'font': prop['chart.title.bottom.font'], 'size': prop['chart.title.bottom.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.bottom']), 'halign': 'center', 'valign': 'top', 'bold': prop['chart.title.bottom.bold'], 'tag': 'title.bottom' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color, index) {\n    var type = prop['chart.needle.type'];co.lineWidth = 0.5;co.strokeStyle = 'gray';co.fillStyle = color;var angle = (this.endAngle - this.startAngle) * ((value - this.min) / (this.max - this.min));angle += this.startAngle;if (_typeof(prop['chart.needle.size']) == 'object' && prop['chart.needle.size'] && typeof prop['chart.needle.size'][index] == 'number') {\n      var size = prop['chart.needle.size'][index];\n    } else if (typeof prop['chart.needle.size'] == 'number') {\n      var size = prop['chart.needle.size'];\n    } else {\n      var size = this.radius - 25 - prop['chart.border.width'];\n    }\n    if (type == 'line') {\n      co.beginPath();co.lineWidth = prop['chart.needle.width'];co.strokeStyle = color;co.arc(this.centerx, this.centery, size, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.lineTo(this.centerx, this.centery);co.stroke();\n    } else {\n      co.beginPath();co.arc(this.centerx, this.centery, size, angle, angle + 0.00001, false);co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle + RG.HALFPI, angle + 0.00001 + RG.HALFPI, false);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle - RG.HALFPI, angle - 0.00001 - RG.HALFPI, false);co.stroke();co.fill();this.angle = angle;\n    }\n  };this.drawColorBands = this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, false);co.arc(this.centerx, this.centery, this.radius - 20 - prop['chart.border.width'], (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = this.startAngle;var greenEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.green.width']) - prop['chart.border.width'], greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.red.start'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.yellow.width']) - prop['chart.border.width'], yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = this.startAngle + (this.endAngle - this.startAngle) * ((this.max - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.red.width']) - prop['chart.border.width'], redEnd, redStart, true);co.fill();\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle >= 0 && angle <= RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - this.startAngle) / (this.endAngle - this.startAngle) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.drawGradient = this.DrawGradient = function () {\n    if (prop['chart.border.gradient']) {\n      co.beginPath();var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius - 15);grad.addColorStop(0, 'gray');grad.addColorStop(1, 'white');co.fillStyle = grad;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);\n      co.arc(this.centerx, this.centery, this.radius - 15, RG.TWOPI, 0, true);\n      co.fill();\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.border.inner'] = RG.array_clone(prop['chart.border.inner']);this.original_colors['chart.border.outer'] = RG.array_clone(prop['chart.border.outer']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.needle.colors'] = RG.array_clone(prop['chart.needle.colors']);\n    }\n    prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.border.inner'] = this.parseSingleColorForGradient(prop['chart.border.inner']);prop['chart.border.outer'] = this.parseSingleColorForGradient(prop['chart.border.outer']);if (prop['chart.colors.ranges']) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2], this.radius - 30);\n      }\n    }\n    if (prop['chart.needle.colors']) {\n      var colors = prop['chart.needle.colors'];for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var radiusStart = arguments[1] || 0;if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, radiusStart, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames || 30;var frame = 0;if (typeof obj.value === 'number') {\n      var origValue = Number(obj.currentValue);if (obj.currentValue == null) {\n        obj.currentValue = obj.min;origValue = obj.min;\n      }\n      var newValue = obj.value;var diff = newValue - origValue;var iterator = function iterator() {\n        obj.value = frame / frames * diff + origValue;if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);\n      }\n      var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / frames * diff[i] + origValue[i];if (obj.value[i] > obj.max) obj.value[i] = obj.max;if (obj.value[i] < obj.min) obj.value[i] = obj.min;\n        }\n        RG.redrawCanvas(obj.canvas);if (frame < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.gauge.js\n// module id = 191\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.gauge.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HBar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.data = data;this.type = 'hbar';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coords2 = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.max = 0;this.stackedOrGrouped = false;this.properties = (_properties = { 'chart.gutter.left': 75, 'chart.gutter.left.autosize': false, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': null, 'chart.background.grid.autofit.numvlines': 5, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.color': null, 'chart.linewidth': 1, 'chart.title': '', 'chart.title.background': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': 0.8, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.color': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.colors': ['red', 'blue', 'green', 'pink', 'yellow', 'cyan', 'navy', 'gray', 'black'], 'chart.colors.sequential': false, 'chart.xlabels.specific': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.specific': null, 'chart.labels.above.color': null, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.font': null, 'chart.labels.above.size': null, 'chart.labels.above.bold': false, 'chart.labels.above.italic': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xlabels.offsetx': 0, 'chart.xlabels.offsety': 0, 'chart.xlabels': true, 'chart.xlabels.count': 5, 'chart.contextmenu': null, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.units.pre': '', 'chart.units.post': '', 'chart.units.ingraph': false, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.xmin': 0, 'chart.xmax': 0, 'chart.axis.color': 'black', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.vmargin': 2, 'chart.vmargin.grouped': 2, 'chart.grouping': 'grouped', 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.style': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.decimals': null, 'chart.scale.zerostart': true, 'chart.noredraw': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.noaxes': false, 'chart.noxtickmarks': false, 'chart.noytickmarks': false, 'chart.numyticks': data.length, 'chart.numxticks': 10, 'chart.variant': 'hbar', 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.yaxispos': 'left' }, _defineProperty(_properties, 'chart.variant', 'hbar'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _properties);\n  if (!this.canvas) {\n    alert('[HBAR] No canvas support');return;\n  }\n  for (i = 0, len = this.data.length; i < len; ++i) {\n    if (_typeof(this.data[i]) == 'object' && !RGraph.isNull(this.data[i])) {\n      this.stackedOrGrouped = true;for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    } else if (typeof this.data[i] == 'string') {\n      this.data[i] = parseFloat(this.data[i]) || 0;\n    } else if (typeof this.data[i] === 'undefined') {\n      this.data[i] = null;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0, len = linear_data.length; i < len; ++i) {\n    this['$' + i] = {};\n  }\n  this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (prop['chart.adjustable'] && prop['chart.grouping'] === 'stacked') {\n      alert('[RGRAPH] The HBar does not support stacked charts with adjusting');\n    }\n    if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n      if (prop['chart.gutter.bottom'] === 25) {\n        this.set('gutterBottom', 80);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.gutter.left.autosize']) {\n      var len = 0;var labels = prop['chart.labels'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];for (var i = 0; i < labels.length; i += 1) {\n        var length = RG.measureText(labels[i], false, font, size)[0] || 0;\n        len = ma.max(len, length);\n      }\n      prop['chart.gutter.left'] = len + 10;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;if (prop['chart.xmin'] > 0 && prop['chart.grouping'] == 'stacked') {\n      alert('[HBAR] Using chart.xmin is not supported with stacked charts, resetting chart.xmin to zero');this.Set('chart.xmin', 0);\n    }\n    this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.graphheight = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;this.halfway = ma.round(this.graphwidth / 2 + this.gutterLeft);\n    RG.Background.draw(this);this.drawbars();this.drawAxes();this.drawLabels();if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    var halfway = this.halfway;\n    co.beginPath();co.lineWidth = prop['chart.axis.linewidth'] ? prop['chart.axis.linewidth'] + 0.001 : 1.001;co.strokeStyle = prop['chart.axis.color'];if (prop['chart.noyaxis'] == false && prop['chart.noaxes'] == false) {\n      if (prop['chart.yaxispos'] == 'center') {\n        co.moveTo(halfway, this.gutterTop);co.lineTo(halfway, ca.height - this.gutterBottom);\n      } else if (prop['chart.yaxispos'] == 'right') {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.noaxes'] == false) {\n      co.moveTo(this.gutterLeft + 0.001, ca.height - this.gutterBottom + 0.001);co.lineTo(ca.width - this.gutterRight + 0.001, ca.height - this.gutterBottom + 0.001);\n    }\n    if (prop['chart.noytickmarks'] == false && prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0 && prop['chart.noaxes'] == false) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / (prop['chart.numyticks'] > 0 ? prop['chart.numyticks'] : this.data.length);for (y = this.gutterTop; y < ca.height - this.gutterBottom - 1; y += yTickGap) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] == true) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n    }\n    if (prop['chart.noxtickmarks'] == false && prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0 && prop['chart.noaxes'] == false) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];yStart = ca.height - this.gutterBottom;yEnd = ca.height - this.gutterBottom + 3;var i = prop['chart.numxticks'];\n      while (i--) {\n        var x = ca.width - this.gutterRight - i * xTickGap;if (prop['chart.yaxispos'] === 'right') {\n          x -= xTickGap;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.yaxispos'] === 'center') {\n        var i = 5;while (i--) {\n          var x = this.gutterLeft + xTickGap * i;co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] == true) {\n        co.moveTo(this.gutterLeft, ma.round(yStart));co.lineTo(this.gutterLeft, ma.round(yEnd));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        text_size = prop['chart.text.size'],\n        font = prop['chart.text.font'],\n        offsetx = prop['chart.xlabels.offsetx'],\n        offsety = prop['chart.xlabels.offsety'];\n    if (prop['chart.units.ingraph']) {\n      units_pre = '';units_post = '';\n    }\n    if (prop['chart.xlabels']) {\n      if (RG.isArray(prop['chart.xlabels.specific'])) {\n        if (prop['chart.yaxispos'] == 'center') {\n          var halfGraphWidth = this.graphwidth / 2;var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / 2 / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + halfGraphWidth + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsetx, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = labels.length - 1; i > 0; i -= 1) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * (labels.length - i - 1) + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { font: font, size: text_size, x: this.gutterLeft + interval * i + offsetx, y: ca.height - this.gutterBottom + offsety, text: labels[i], valign: 'top', halign: 'center', tag: 'scale' });\n          }\n        }\n      } else {\n        var gap = 7;co.beginPath();co.fillStyle = prop['chart.text.color'];if (prop['chart.yaxispos'] == 'center') {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 - this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + this.graphwidth / 2 + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + i * (this.graphwidth / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[len - 1 - i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth * ((i + 1) / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.xmin'] > 0 || prop['chart.noyaxis'] == true || prop['chart.scale.zerostart'] || prop['chart.noaxes']) {\n          var x = prop['chart.yaxispos'] == 'center' ? this.gutterLeft + this.graphwidth / 2 : this.gutterLeft;if (prop['chart.yaxispos'] === 'right') {\n            var x = ca.width - this.gutterRight;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': RG.numberFormat(this, prop['chart.xmin'].toFixed(prop['chart.xmin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n        co.fill();co.stroke();\n      }\n    }\n    if (_typeof(prop['chart.labels']) == 'object') {\n      var xOffset = prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right' ? 15 : 5,\n          font = prop['chart.text.font'],\n          color = prop['chart.labels.color'] || prop['chart.text.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.fillStyle = color;var barHeight = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;\n      if (prop['chart.yaxispos'] === 'right') {\n        var x = ca.width - this.gutterRight + xOffset;var halign = 'left';\n      } else {\n        var x = this.gutterLeft - xOffset;var halign = 'right';\n      }\n      var i = 0;for (y = this.gutterTop + yTickGap / 2; y <= ca.height - this.gutterBottom; y += yTickGap) {\n        RG.text2(this, { 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.labels'][i++]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n      }\n    }\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0;if (prop['chart.xmax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.xmax'], 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'], 'strict': true });this.max = this.scale2.max;\n    } else {\n      var grouping = prop['chart.grouping'];for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = grouping == 'grouped' ? Number(RG.array_max(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(ma.abs(this.data[i]));\n        }\n        this.max = ma.max(Math.abs(this.max), Math.abs(value));\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    if (prop['chart.scale.decimals'] == null && Number(this.max) == 1) {\n      this.Set('chart.scale.decimals', 1);\n    }\n    var colorIdx = 0;this.numbars = RG.arrayLinearize(this.data).length;if (prop['chart.adjustable'] && !prop['chart.xmax']) {\n      this.set('chart.xmax', this.scale2.max);\n    }\n    if (prop['chart.variant'] === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var graphwidth = ca.width - this.gutterLeft - this.gutterRight;var halfwidth = graphwidth / 2;for (i = len = this.data.length - 1; i >= 0; --i) {\n      var width = ma.abs(this.data[i] / this.max * graphwidth);var height = this.graphheight / this.data.length;var orig_height = height;var x = this.gutterLeft;var y = this.gutterTop + i * height;var vmargin = prop['chart.vmargin'];if (prop['chart.yaxispos'] === 'right') {\n        x = ca.width - this.gutterRight - ma.abs(width);\n      }\n      if (width < 0) {\n        x -= width;width = ma.abs(width);\n      }\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      co.beginPath();if (typeof this.data[i] == 'number' || RG.isNull(this.data[i])) {\n        var barHeight = height - 2 * vmargin,\n            barWidth = (this.data[i] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * this.graphwidth,\n            barX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n          barWidth /= 2;barX += halfwidth;if (this.data[i] < 0) {\n            barWidth = (ma.abs(this.data[i]) - prop['chart.xmin']) / (this.max - prop['chart.xmin']);barWidth = barWidth * (this.graphwidth / 2);barX = this.graphwidth / 2 + this.gutterLeft - barWidth;\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          barWidth = ma.abs(barWidth);barX = ca.width - this.gutterRight - barWidth;\n        }\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n          if (prop['chart.colors'][this.numbars - colorIdx]) {\n            co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n          } else {\n            co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n          }\n        }\n        co.strokeRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);co.fillRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);this.coords.push([barX, y + vmargin, barWidth, height - 2 * vmargin, co.fillStyle, this.data[i], true]);if (prop['chart.variant'] === '3d' && typeof this.data[i] == 'number') {\n          var prevStrokeStyle = co.strokeStyle,\n              prevFillStyle = co.fillStyle;RG.noShadow(this);var barX = barX,\n              barY = y + vmargin,\n              barW = barWidth,\n              barH = height - 2 * vmargin,\n              offsetX = prop['chart.variant.threed.offsetx'],\n              offsetY = prop['chart.variant.threed.offsety'],\n              value = this.data[i];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX - (prop['chart.yaxispos'] == 'left' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW + offsetX - (prop['chart.yaxispos'] == 'center' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n            pa2(co, ['b', 'fs', prevFillStyle, 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (prop['chart.yaxispos'] == 'center') {\n          alert('[HBAR] You can\\'t have a stacked chart with the Y axis in the center, change it to grouped');\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var x = ca.width - this.gutterRight;\n        }\n        var barHeight = height - 2 * vmargin;if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = 0; j < this.data[i].length; ++j) {\n          if (prop['chart.shadow'] && prop['chart.variant'] === '3d') {\n            co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n          }\n          if (!RG.isNull(this.data[i][j])) this.data[i][j] = ma.abs(this.data[i][j]);var last = j === this.data[i].length - 1;co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var width = this.data[i][j] / this.max * this.graphwidth;var totalWidth = RG.arraySum(this.data[i]) / this.max * this.graphwidth;if (prop['chart.yaxispos'] === 'right') {\n            x -= width;\n          }\n          co.strokeRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);co.fillRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);this.coords.push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);this.coords2[i].push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = x,\n                barY = y + vmargin,\n                barW = width,\n                barH = height - 2 * vmargin,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];if (!RG.isNull(value)) {\n              pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);\n            }\n            if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (prop['chart.yaxispos'] !== 'right') {\n            x += width;\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var vmarginGrouped = prop['chart.vmargin.grouped'];var individualBarHeight = (height - 2 * vmargin - (this.data[i].length - 1) * vmarginGrouped) / this.data[i].length;\n        if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = this.data[i].length - 1; j >= 0; --j) {\n          if (prop['chart.shadow']) {\n            RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n          }\n          co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var startY = this.gutterTop + height * i + individualBarHeight * j + vmargin + vmarginGrouped * j;var width = (this.data[i][j] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * (ca.width - this.gutterLeft - this.gutterRight);var startX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n            width /= 2;startX += halfwidth;\n          } else if (prop['chart.yaxispos'] == 'right') {\n            width = ma.abs(width);startX = ca.width - this.gutterRight - ma.abs(width);;\n          }\n          if (width < 0) {\n            startX += width;width *= -1;\n          }\n          co.strokeRect(startX, startY, width, individualBarHeight);co.fillRect(startX, startY, width, individualBarHeight);this.coords.push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);this.coords2[i].push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = startX,\n                barY = startY,\n                barW = width,\n                barH = individualBarHeight,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX - (value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n        }\n        startY += vmargin;\n      }\n      co.closePath();\n    }\n    co.stroke();co.fill();if (prop['chart,yaxispos'] === 'right') {\n      pa2(co, 'cr % % % %', ca.width - this.gutterRight + prop['chart.variant.threed.offsetx'], '0', this.gutterRight, ca.height);\n    }\n    if (prop['chart.yaxispos'] === 'right' && prop['chart.variant'] === '3d') {\n      RG.draw3DYAxis(this);\n    }\n    RG.noShadow(this);this.coords = RG.arrayReverse(this.coords);if (prop['chart.grouping'] === 'grouped') {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        this.coords2[i] = RG.arrayReverse(this.coords2[i]);\n      }\n    }\n    this.redrawBars();\n  };this.redrawBars = this.RedrawBars = function () {\n    if (prop['chart.noredraw']) {\n      return;\n    }\n    var coords = this.coords;var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'];RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle'];for (var i = 0; i < coords.length; ++i) {\n      if (prop['chart.shadow']) {\n        pa2(co, 'b lw % r % % % % s % f %', prop['chart.linewidth'], coords[i][0], coords[i][1], coords[i][2], coords[i][3], prop['chart.strokestyle'], coords[i][4]);\n      }\n      var halign = 'left';if (prop['chart.labels.above'] && coords[i][6]) {\n        var border = coords[i][0] + coords[i][2] + 7 + co.measureText(prop['chart.labels.above.units.pre'] + this.coords[i][5] + prop['chart.labels.above.units.post']).width > ca.width ? true : false,\n            text = RG.numberFormat(this, this.coords[i][5].toFixed(prop['chart.labels.above.decimals']), prop['chart.labels.above.units.pre'], prop['chart.labels.above.units.post']);RG.noShadow(this);if (_typeof(prop['chart.labels.above.specific']) === 'object' && prop['chart.labels.above.specific'] && prop['chart.labels.above.specific'][i]) {\n          text = prop['chart.labels.above.specific'][i];\n        }\n        var x = coords[i][0] + coords[i][2] + 5;var y = coords[i][1] + coords[i][3] / 2;if (prop['chart.yaxispos'] === 'right') {\n          x = coords[i][0] - 5;halign = 'right';\n        } else if (prop['chart.yaxispos'] === 'center' && this.data_arr[i] < 0) {\n          x = coords[i][0] - 5;halign = 'right';\n        }\n        RG.text2(this, { font: typeof prop['chart.labels.above.font'] === 'string' ? prop['chart.labels.above.font'] : font, size: typeof prop['chart.labels.above.size'] === 'number' ? prop['chart.labels.above.size'] : size, color: typeof prop['chart.labels.above.color'] === 'string' ? prop['chart.labels.above.color'] : color, x: x, y: y, bold: prop['chart.labels.above.bold'], italic: prop['chart.labels.above.italic'], text: text, valign: 'center', halign: halign, tag: 'labels.above' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e);for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3],\n          idx = i;pa2(co, ['b', 'r', left, top, width, height]);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: left, 'x': left, 2: top, 'y': top, 3: width, 'width': width, 4: height, 'height': height, 5: idx, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.yaxispos'] == 'center') {\n      var value = (mouseX - this.gutterLeft) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value = value - this.max;\n      if (prop['chart.xmin'] > 0) {\n        value = (mouseX - this.gutterLeft - this.graphwidth / 2) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value += prop['chart.xmin'];if (mouseX < this.gutterLeft + this.graphwidth / 2) {\n          value -= 2 * prop['chart.xmin'];\n        }\n      }\n    } else if (prop['chart.yaxispos'] == 'right') {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value = this.scale2.max - value;\n    } else {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value += prop['chart.xmin'];\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= this.gutterLeft && mouseXY[0] <= ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (prop['chart.yaxispos'] == 'center') {\n      if (value > this.max || value < -1 * this.max) {\n        return null;\n      }\n      var width = (ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2;var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width + width;coord = prop['chart.gutter.left'] + coord;\n    } else {\n      if (value > this.max || value < 0) {\n        return null;\n      }\n      var width = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width;coord = prop['chart.gutter.left'] + coord;\n    }\n    return coord;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.labels.colors'] = RG.array_clone(prop['chart.labels.colors']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.labels.colors'] = this.parseSingleColorForGradient(prop['chart.labels.colors']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.yaxispos'] === 'right') {\n        parts = RG.arrayReverse(parts);\n      }\n      var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var obj = this;this.coords2.forEach(function (value, idx, arr) {\n      var shape = obj.coords2[idx][index];\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillRect(shape[0], shape[1], shape[2], shape[3]);co.strokeRect(shape[0], shape[1], shape[2], shape[3]);co.lineWidth = pre_linewidth;\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.getShapeByY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = obj.coords[i][0],\n          top = obj.coords[i][1],\n          width = obj.coords[i][2],\n          height = obj.coords[i][3];if (mouseY >= top && mouseY <= top + height) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, object: obj, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e)),\n          shape = RG.Registry.get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.is_null(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.grow = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);obj.original_data = RG.arrayClone(obj.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    function iterator() {\n      for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        var easingFactor = RG.Effects.getEasingMultiplier(frames, frame);if (_typeof(obj.data[j]) === 'object' && obj.data[j]) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            obj.data[j][k] = RG.isNull(obj.data[j][k]) ? null : obj.original_data[j][k] * easingFactor;\n          }\n        } else {\n          obj.data[j] = RG.isNull(obj.data[j]) ? null : obj.original_data[j] * easingFactor;\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    this.original_data = RG.arrayClone(this.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    if (RG.isArray(opt.data)) {\n      var xmax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            xmax = ma.max(xmax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseFloat(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseFloat(RegExp.$2);\n          }\n          xmax = ma.max(xmax, opt.data[i]);\n        } else {\n          xmax = ma.max(xmax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });if (typeof this.get('chart.xmax') === 'null') {\n        this.set('chart.xmax', scale.max);\n      }\n    }\n    this.set('labelsAbove', false);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          xmax = ma.max(xmax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(group)));\n        } else {\n          xmax = ma.max(xmax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    if (typeof opt.xmax === 'number') {\n      obj.set('xmax', opt.xmax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(obj.data),\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('xmax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redrawCanvas(obj.canvas);\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.hbar.js\n// module id = 192\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.hbar.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HProgress = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.type = 'hprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.tickmarks.zerostart': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.background': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.labels.specific': null, 'chart.labels.count': 10, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'gutter', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null }, _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'black'), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.labels.position', 'bottom'), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.border.inner', true), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[HPROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.array_linearize(value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.strokestyle') {\n      this.Set('chart.strokestyle.inner', value);this.Set('chart.strokestyle.outer', value);return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitle();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.fillStyle = prop['chart.colors'][0];co.strokeStyle = prop['chart.strokestyle.outer'];var margin = prop['chart.margin'];var barWidth = ma.min(this.width, (RG.array_sum(this.value) - this.min) / (this.max - this.min) * this.width);if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var x = this.gutterLeft; x < ca.width - this.gutterRight; x += spacing) {\n        co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), this.gutterTop + 2);co.moveTo(Math.round(x), ca.height - this.gutterBottom);co.lineTo(Math.round(x), ca.height - this.gutterBottom - 2);\n      }\n      co.stroke();\n    }\n    if (typeof this.value === 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, fill: prop['chart.colors'][0] });this.coords.push([this.gutterLeft, this.gutterTop + margin, barWidth, this.height - margin - margin]);\n    } else if (_typeof(this.value) === 'object') {\n      co.beginPath();var startPoint = this.gutterLeft;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentLength = this.value[i] / RG.arraySum(this.value) * barWidth;if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i], stroke: prop['chart.strokestyle.inner'] });\n        }\n        this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i] });this.coords.push([startPoint, this.gutterTop + margin, segmentLength, this.height - margin - margin]);startPoint += segmentLength;\n      }\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft + barWidth;var y = this.gutterTop;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y - 3);co.lineTo(x + 2, y - 7);co.lineTo(x - 2, y - 7);co.closePath();co.stroke();co.fill();co.beginPath();co.moveTo(x, y + this.height + 4);co.lineTo(x + 2, y + this.height + 9);co.lineTo(x - 2, y + this.height + 9);co.closePath();co.stroke();co.fill();\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'] + 2, 'x': this.gutterLeft + barWidth + 5, 'y': this.gutterTop + this.height / 2, 'text': String(prop['chart.units.pre'] + this.value + prop['chart.units.post']), 'valign': 'bottom', 'halign': 'left', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n    pa2(co, 'b');\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();this.tickInterval = this.width / prop['chart.numticks'];var start = prop['chart.tickmarks.zerostart'] ? 0 : this.tickInterval;if (prop['chart.labels.position'] == 'top') {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop);co.lineTo(Math.round(i), this.gutterTop - 4);\n        }\n      } else {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop + this.height);co.lineTo(Math.round(i), this.gutterTop + this.height + 4);\n        }\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var xPoints = [],\n        yPoints = [],\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'];for (i = 0, len = this.scale2.labels.length; i < len; i++) {\n      if (prop['chart.labels.position'] == 'top') {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.gutterTop - 6;var valign = 'bottom';\n      } else {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.height + this.gutterTop + 4;var valign = 'top';\n      }\n      RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': this.scale2.labels[i], 'valign': valign, 'halign': 'center', 'tag': 'scale' });\n    }\n    if (prop['chart.tickmarks.zerostart']) {\n      if (prop['chart.labels.position'] == 'top') {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': this.gutterTop - 6 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'bottom', 'halign': 'center', 'tag': 'scale' });\n      } else {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': ca.height - this.gutterBottom + 5 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, height: h, width: w });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], idx);return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: idx, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var value = (mouseXY[0] - this.gutterLeft) / this.width;value *= this.max - this.min;value += this.min;if (mouseXY[0] < this.gutterLeft) {\n      value = this.min;\n    }\n    if (mouseXY[0] > ca.width - this.gutterRight) {\n      value = this.max;\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    var last = shape.index === this.coords.length - 1;if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value == 'number') {\n        this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          valign = prop['chart.labels.position'] == 'top' ? 'bottom' : 'top',\n          step = this.width / (labels.length - 1),\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { font: font, size: size, x: this.gutterLeft + step * i + offsetx, y: prop['chart.labels.position'] == 'top' ? this.gutterTop - 7 + offsety : ca.height - this.gutterBottom + 7 + offsety, text: labels[i], valign: valign, halign: 'center', tag: 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getXCoord = function (value) {\n    var min = this.min;if (value < min || value > this.max) {\n      return null;\n    }\n    var barWidth = ca.width - this.gutterLeft - this.gutterRight;var coord = (value - min) / (this.max - min) * barWidth;coord = this.gutterLeft + coord;return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, len = 0; i < this.coords.length; ++i) {\n      len += this.coords[i][2];\n    }co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[0][1], len, this.coords[0][3]);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[0][1], width: len, height: this.coords[0][3] });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 51, y: this.coords[0][1] - 1, width: len + 52, height: this.coords[0][3] + 2 });co.stroke();co.restore();co.restore();\n  };this.drawTitle = this.DrawTitle = function () {\n    if (prop['chart.title'].length) {\n      var x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;var text = prop['chart.title'];var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;var font = prop['chart.title.font'] ? prop['chart.title.font'] : prop['chart.text.font'];if (prop['chart.labels.position'] == 'top') {\n        y = ca.height - this.gutterBottom + 5;x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;valign = 'top';\n      } else {\n        x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;y = this.gutterTop - 5;valign = 'bottom';\n      }\n      RG.Text2(this, { 'font': font, 'size': size, 'x': typeof prop['chart.title.x'] == 'number' ? prop['chart.title.x'] : x, 'y': typeof prop['chart.title.y'] == 'number' ? prop['chart.title.y'] : y, 'text': text, 'valign': prop['chart.title.valign'] ? prop['chart.title.valign'] : valign, 'halign': prop['chart.title.halign'] ? prop['chart.title.halign'] : 'center', 'bold': prop['chart.title.bold'], 'bounding': prop['chart.title.background'] ? true : false, 'boundingFill': prop['chart.title.background'], 'tag': 'title' });\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RG.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0, len = initial_value.length; i < len; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.hprogress.js\n// module id = 193\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.hprogress.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Line = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'line';this.max = 0;this.coords = [];this.coords2 = [];this.coords.key = [];this.coordsText = [];this.coordsSpline = [];this.coordsAxes = { xaxis: [], yaxis: [] };this.hasnegativevalues = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': 1, 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.hbars': null, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'white', 'chart.labels.above.font': null, 'chart.labels.above.border': true, 'chart.labels.above.offsety': 5, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xtickgap': 20, 'chart.smallxticks': 3, 'chart.largexticks': 5, 'chart.ytickgap': 20, 'chart.smallyticks': 3, 'chart.largeyticks': 5, 'chart.numyticks': 10, 'chart.linewidth': 2.01, 'chart.colors': ['red', '#0f0', '#00f', '#f0f', '#ff0', '#0ff', 'green', 'pink', 'blue', 'black'], 'chart.hmargin': 0, 'chart.tickmarks.dot.stroke': 'white', 'chart.tickmarks.dot.fill': null, 'chart.tickmarks.dot.linewidth': 3, 'chart.tickmarks': 'endcircle', 'chart.tickmarks.linewidth': null, 'chart.tickmarks.image': null, 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 3, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.tickdirection': -1, 'chart.yaxispoints': 5, 'chart.fillstyle': null, 'chart.xaxispos': 'bottom', 'chart.xaxispos.value': 0, 'chart.yaxispos': 'left', 'chart.xticks': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3, 'chart.shadow.color': 'rgba(128,128,128,0.5)', 'chart.tooltips': null, 'chart.tooltips.hotspot.xonly': false, 'chart.tooltips.hotspot.size': 5, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.highlight.style': null, 'chart.highlight.stroke': 'gray', 'chart.highlight.fill': 'white', 'chart.stepped': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': null, 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.scale.invert': false, 'chart.xlabels.inside': false, 'chart.xlabels.inside.color': 'rgba(255,255,255,0.5)', 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.noxaxis': false, 'chart.noendxtick': false, 'chart.noendytick': false, 'chart.units.post': '', 'chart.units.pre': '', 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.axesontop': false, 'chart.filled': false, 'chart.filled.range': false, 'chart.filled.range.threshold': null, 'chart.filled.range.threshold.colors': ['red', 'green'], 'chart.filled.accumulative': true, 'chart.variant': null, 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.numxticks': data && typeof data[0] == 'number' ? data.length - 1 : _typeof(data[0]) === 'object' && data[0] && typeof data[0][0] === 'number' ? data[0].length - 1 : 20 }, _defineProperty(_properties, 'chart.numyticks', 10), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.backdrop', false), _defineProperty(_properties, 'chart.backdrop.size', 30), _defineProperty(_properties, 'chart.backdrop.alpha', 0.2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.noredraw', false), _defineProperty(_properties, 'chart.outofbounds', false), _defineProperty(_properties, 'chart.outofbounds.clip', false), _defineProperty(_properties, 'chart.chromefix', true), _defineProperty(_properties, 'chart.animation.factor', 1), _defineProperty(_properties, 'chart.animation.unfold.x', false), _defineProperty(_properties, 'chart.animation.unfold.y', true), _defineProperty(_properties, 'chart.animation.unfold.initial', 2), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.curvy', false), _defineProperty(_properties, 'chart.line.visible', []), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.errorbars', false), _defineProperty(_properties, 'chart.errorbars.color', 'black'), _defineProperty(_properties, 'chart.errorbars.capped', true), _defineProperty(_properties, 'chart.errorbars.capped.width', 12), _defineProperty(_properties, 'chart.errorbars.linewidth', 1), _defineProperty(_properties, 'chart.combinedchart.effect', null), _defineProperty(_properties, 'chart.combinedchart.effect.options', null), _defineProperty(_properties, 'chart.combinedchart.effect.callback', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.dotted', false), _defineProperty(_properties, 'chart.dashed', false), _properties);\n  for (var i = 1; i < arguments.length; ++i) {\n    if (typeof arguments[i] == 'null' || !arguments[i]) {\n      arguments[i] = [];\n    }\n  }\n  this.original_data = [];if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && conf.data) {\n    if (typeof conf.data[0] === 'number' || RGraph.isNull(conf.data[0])) {\n      this.original_data[0] = RGraph.arrayClone(conf.data);\n    } else {\n      for (var i = 0; i < conf.data.length; ++i) {\n        this.original_data[i] = RGraph.arrayClone(conf.data[i]);\n      }\n    }\n  } else {\n    for (var i = 1; i < arguments.length; ++i) {\n      if (arguments[1] && _typeof(arguments[1]) == 'object' && arguments[1][0] && _typeof(arguments[1][0]) == 'object' && arguments[1][0].length) {\n        var tmp = [];for (var i = 0; i < arguments[1].length; ++i) {\n          tmp[i] = RGraph.array_clone(arguments[1][i]);\n        }\n        for (var j = 0; j < tmp.length; ++j) {\n          this.original_data[j] = RGraph.array_clone(tmp[j]);\n        }\n      } else {\n        this.original_data[i - 1] = RGraph.array_clone(arguments[i]);\n      }\n    }\n  }\n  if (!this.canvas) {\n    alert('[LINE] Fatal error: no canvas support');return;\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    for (var j = 0; j < this.original_data[i].length; ++j) {\n      if (typeof this.original_data[i][j] === 'string') {\n        this.original_data[i][j] = parseFloat(this.original_data[i][j]);\n      }\n    }\n  }\n  this.data_arr = RGraph.arrayLinearize(this.original_data);for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.tooltips' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value) {\n      var tooltips = [];for (var i = 1; i < arguments.length; i++) {\n        if (_typeof(arguments[i]) == 'object' && arguments[i][0]) {\n          for (var j = 0; j < arguments[i].length; j++) {\n            tooltips.push(arguments[i][j]);\n          }\n        } else if (typeof arguments[i] == 'function') {\n          tooltips = arguments[i];\n        } else {\n          tooltips.push(arguments[i]);\n        }\n      }\n      value = tooltips;\n    }\n    if (name == 'chart.linewidth' && navigator.userAgent.match(/Chrome/)) {\n      if (value == 1) {\n        value = 1.01;\n      } else if (RGraph.is_array(value)) {\n        for (var i = 0; i < value.length; ++i) {\n          if (typeof value[i] == 'number' && value[i] == 1) {\n            value[i] = 1.01;\n          }\n        }\n      }\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[LINE] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.xticks') {\n      name = 'chart.numxticks';\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    if (name == 'chart.ylabels.invert') {\n      name = 'chart.scale.invert';\n    }\n    this.properties[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.data = RG.array_clone(this.original_data);this.max = 0;if (prop['chart.filled'] && !prop['chart.filled.range'] && this.data.length > 1 && prop['chart.filled.accumulative']) {\n      var accumulation = [];for (var set = 0; set < this.data.length; ++set) {\n        for (var point = 0; point < this.data[set].length; ++point) {\n          this.data[set][point] = Number(accumulation[point] ? accumulation[point] : 0) + this.data[set][point];accumulation[point] = this.data[set][point];\n        }\n      }\n    }\n    if (prop['chart.ymax']) {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;if (!prop['chart.outofbounds']) {\n        for (dataset = 0; dataset < this.data.length; ++dataset) {\n          if (RGraph.isArray(this.data[dataset])) {\n            for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n              this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n            }\n          }\n        }\n      }\n    } else {\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;for (dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n          this.max = Math.max(this.max, this.data[dataset][datapoint] ? Math.abs(parseFloat(this.data[dataset][datapoint])) : 0);if (!prop['chart.outofbounds']) {\n            this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.coords = [];this.coordsText = [];this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;if (prop['chart.variant'] == '3d') {\n      RG.Draw3DAxes(this);\n    }\n    RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.axesontop'] == false) {\n      this.DrawAxes();\n    }\n    co.save();\n    co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();for (var i = 0, j = 0, len = this.data.length; i < len; i++, j++) {\n      co.beginPath();if (!prop['chart.filled']) {\n        this.SetShadow(i);\n      }\n      if (prop['chart.fillstyle']) {\n        if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'][j]) {\n          var fill = prop['chart.fillstyle'][j];\n        } else if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'].toString().indexOf('Gradient') > 0) {\n          var fill = prop['chart.fillstyle'];\n        } else if (typeof prop['chart.fillstyle'] == 'string') {\n          var fill = prop['chart.fillstyle'];\n        }\n      } else if (prop['chart.filled']) {\n        var fill = prop['chart.colors'][j];\n      } else {\n        var fill = null;\n      }\n      if (prop['chart.tickmarks'] && _typeof(prop['chart.tickmarks']) == 'object') {\n        var tickmarks = prop['chart.tickmarks'][i];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'string') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'function') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else {\n        var tickmarks = null;\n      }\n      if (prop['chart.outofbounds.clip']) {\n        pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n      this.drawLine(this.data[i], prop['chart.colors'][j], fill, this.getLineWidth(j), tickmarks, i);if (prop['chart.outofbounds.clip']) {\n        co.restore();\n      }\n      co.stroke();\n    }\n    if (prop['chart.outofbounds.clip']) {\n      pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n    }\n    if (prop['chart.filled'] && prop['chart.filled.accumulative'] && !prop['chart.curvy']) {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        co.beginPath();co.lineWidth = this.GetLineWidth(i);co.strokeStyle = !this.hidden(i) ? prop['chart.colors'][i] : 'rgba(0,0,0,0)';for (var j = 0, len = this.coords2[i].length; j < len; ++j) {\n          if (j == 0 || this.coords2[i][j][1] == null || this.coords2[i][j - 1] && this.coords2[i][j - 1][1] == null) {\n            co.moveTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          } else {\n            if (prop['chart.stepped']) {\n              co.lineTo(this.coords2[i][j][0], this.coords2[i][j - 1][1]);\n            }\n            co.lineTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          }\n        }\n        co.stroke();\n      }\n      if (prop['chart.tickmarks']) {\n        co.beginPath();co.fillStyle = 'white';for (var i = 0, len = this.coords2.length; i < len; ++i) {\n          co.beginPath();co.strokeStyle = prop['chart.colors'][i];for (var j = 0; j < this.coords2[i].length; ++j) {\n            if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n              var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], co.strokeStyle, false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n            }\n          }\n        }\n        co.stroke();co.fill();\n      }\n    } else if (prop['chart.filled'] && prop['chart.filled.accumulative'] && prop['chart.curvy']) {\n      for (var i = 0; i < this.coordsSpline.length; i += 1) {\n        co.beginPath();co.strokeStyle = prop['chart.colors'][i];co.lineWidth = this.GetLineWidth(i);for (var j = 0, len = this.coordsSpline[i].length; j < len; j += 1) {\n          var point = this.coordsSpline[i][j];j == 0 ? co.moveTo(point[0], point[1]) : co.lineTo(point[0], point[1]);\n        }\n        co.stroke();\n      }\n      for (var i = 0, len = this.coords2.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.coords2[i].length; j < len2; ++j) {\n          if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n            var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' && !RGraph.is_null(prop['chart.tickmarks']) ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];co.strokeStyle = prop['chart.colors'][i];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], prop['chart.colors'][i], false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n          }\n        }\n      }\n    }\n    if (prop['chart.outofbounds.clip']) {\n      co.restore();\n    }\n    co.restore();co.beginPath();if (prop['chart.axesontop']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();this.DrawRange();if (prop['chart.key'] && prop['chart.key'].length && RG.DrawKey) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.drawAboveLabels();\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.filled'] && prop['chart.filled.range'] && this.data.length == 2) {\n      co.beginPath();var len = this.coords.length / 2;co.lineWidth = prop['chart.linewidth'];co.strokeStyle = this.hidden(0) ? 'rgba(0,0,0,0)' : prop['chart.colors'][0];for (var i = 0; i < len; ++i) {\n        if (!RG.isNull(this.coords[i][1])) {\n          if (i == 0) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.beginPath();if (prop['chart.colors'][1]) {\n        co.strokeStyle = this.hidden(1) ? 'rgba(0,0,0,0)' : prop['chart.colors'][1];\n      }\n      for (var i = this.coords.length - 1; i >= len; --i) {\n        if (!RG.is_null(this.coords[i][1])) {\n          if (i == this.coords.length - 1) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();\n    } else if (prop['chart.filled'] && prop['chart.filled.range']) {\n      alert('[LINE] You must have only two sets of data for a filled range chart');\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    RG.noShadow(this);co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.lineCap = 'square';co.lineJoin = 'miter';co.strokeStyle = prop['chart.axis.color'];coords = { xaxis: {}, yaxis: {} };co.beginPath();if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        coords.xaxis = [this.gutterLeft, ma.round(this.grapharea / 2 + this.gutterTop), ca.width - this.gutterRight, ma.round(this.grapharea / 2 + this.gutterTop)];\n      } else if (prop['chart.xaxispos'] === 'top') {\n        coords.xaxis = [this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, this.gutterTop];\n      } else {\n        var y = ma.round(this.getYCoord(prop['chart.ymin'] != 0 ? prop['chart.ymin'] : 0));if (prop['chart.scale.invert'] && prop['chart.ymin'] === 0) {\n          y = this.getYCoord(this.scale2.max);\n        } else if (prop['chart.scale.invert'] || prop['chart.ymin'] < 0) {\n          y = this.getYCoord(0);\n        }\n        coords.xaxis = [this.gutterLeft, y, ca.width - this.gutterRight, y];\n      }\n      co.moveTo(coords.xaxis[0], coords.xaxis[1]);co.lineTo(coords.xaxis[2], coords.xaxis[3]);this.coordsAxes = coords;\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      var xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (!xTickInterval || xTickInterval <= 0) {\n        xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / (prop['chart.labels'] && prop['chart.labels'].length ? prop['chart.labels'].length - 1 : 10);\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' ? xTickInterval : 0); x <= ca.width - this.gutterRight + 1; x += xTickInterval) {\n        if (prop['chart.yaxispos'] == 'right' && x >= ca.width - this.gutterRight - 1) {\n          break;\n        }\n        if (prop['chart.noendxtick']) {\n          if (prop['chart.yaxispos'] == 'left' && x >= ca.width - this.gutterRight - 1) {\n            break;\n          } else if (prop['chart.yaxispos'] == 'right' && x == this.gutterLeft) {\n            continue;\n          }\n        }\n        var yStart = prop['chart.xaxispos'] === 'center' ? this.gutterTop + this.grapharea / 2 - 3 : ca.height - this.gutterBottom;var yEnd = prop['chart.xaxispos'] === 'center' ? yStart + 6 : ca.height - this.gutterBottom - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);if (prop['chart.ymin'] >= 0 && prop['chart.xaxispos'] === 'bottom') {\n          var yStart = this.getYCoord(prop['chart.ymin']) - (prop['chart.ymin'] >= 0 ? 0 : 3),\n              yEnd = this.getYCoord(prop['chart.ymin']) + 3;if (prop['chart.scale.invert']) {\n            yStart = ca.height - prop['chart.gutter.bottom'];yEnd = yStart + 3;\n          }\n        } else if (prop['chart.xaxispos'] == 'center') {\n          var yStart = Math.round(this.gutterTop + this.grapharea / 2) - 3,\n              yEnd = yStart + 6;\n        } else if (prop['chart.xaxispos'] == 'bottom') {\n          var yStart = this.getYCoord(0) - (prop['chart.ymin'] !== 0 ? 3 : 0),\n              yEnd = this.getYCoord(0) - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);yEnd += 0;\n        } else if (prop['chart.xaxispos'] == 'top') {\n          yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n    } else if (prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0) {\n      if (!prop['chart.noendytick']) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        } else {\n          co.moveTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    var numyticks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && numyticks > 0) {\n      var counter = 0,\n          adjustment = 0;if (prop['chart.yaxispos'] == 'right') {\n        adjustment = ca.width - this.gutterLeft - this.gutterRight;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < this.grapharea / 2 + this.gutterTop; y += interval) {\n          if (y < this.grapharea / 2 + this.gutterTop) {\n            co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n          }\n        }\n        for (y = this.gutterTop + this.halfgrapharea + interval; y <= this.grapharea + this.gutterTop; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop + interval; y <= this.grapharea + this.gutterBottom; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n        if (prop['chart.noxaxis'] && prop['chart.noendytick'] == false) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, this.gutterTop);co.lineTo(lineto, this.gutterTop);\n        }\n      } else {\n        var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < ca.height - this.gutterBottom && counter < numyticks; y += (ca.height - this.gutterTop - this.gutterBottom) / numyticks) {\n          if (ma.round(y) !== ma.round(this.coordsAxes.xaxis[1])) {\n            co.moveTo(this.gutterLeft + adjustment, ma.round(y));co.lineTo(lineto, ma.round(y));\n          }\n          var counter = counter + 1;\n        }\n        if (prop['chart.ymin'] < 0) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight, ma.round(y));co.lineTo(lineto, ma.round(y));\n        }\n      }\n    } else if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop : ca.height - this.gutterBottom);co.lineTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop - prop['chart.smallxticks'] : ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      }\n    }\n    co.stroke();co.beginPath();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.strokeStyle = 'black';co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;RG.NoShadow(this);var font = prop['chart.text.font'];var text_size = prop['chart.text.size'];var decimals = prop['chart.scale.decimals'];var context = co;var canvas = ca;var ymin = prop['chart.ymin'];if (prop['chart.ylabels'] && prop['chart.ylabels.specific'] == null) {\n      var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var numYLabels = this.scale2.labels.length;var bounding = false;var bgcolor = prop['chart.ylabels.inside'] ? prop['chart.ylabels.inside.color'] : null;var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true && align == 'left') {\n        xpos -= 10;align = 'right';bounding = true;\n      } else if (prop['chart.ylabels.inside'] == true && align == 'right') {\n        xpos += 10;align = 'left';bounding = true;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var half = this.grapharea / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half - (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n        }\n        for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n        }\n        if (prop['chart.noxaxis'] == true || ymin != 0 || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + offsety, 'text': prop['chart.units.pre'] + ymin.toFixed(ymin === 0 ? 0 : decimals) + prop['chart.units.post'], 'bounding': bounding, 'boundingFill': bgcolor, 'valign': 'center', 'halign': align, 'tag': 'scale' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var half = this.grapharea / 2;if (prop['chart.scale.invert']) {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / numYLabels * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.invert'] || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? ca.height - this.gutterBottom + offsety : this.gutterTop + offsety, 'text': (prop['chart.ymin'] != 0 ? '-' : '') + RG.numberFormat(this, prop['chart.ymin'].toFixed(ymin === 0 ? 0 : decimals), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      } else {\n        if (prop['chart.scale.invert']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': RG.numberFormat(this, this.min.toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 && !prop['chart.scale.invert'] || prop['chart.scale.zerostart'] || prop['chart.noxaxis']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? this.gutterTop + offsety : ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      }\n      if (prop['chart.noxaxis'] == true && prop['chart.ymin'] == null && prop['chart.xaxispos'] != 'center' && prop['chart.noendytick'] == false) {\n        RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + offsety : ca.height - this.gutterBottom, 'text': prop['chart.units.pre'] + Number(0).toFixed(prop['chart.scale.decimals']) + prop['chart.units.post'] + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n      }\n    } else if (prop['chart.ylabels'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var gap = this.grapharea / prop['chart.ylabels.specific'].length;var halign = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var bounding = false;var bgcolor = null;var ymin = prop['chart.ymin'] != null && prop['chart.ymin'];if (prop['chart.yaxispos'] == 'left') {\n        var x = this.gutterLeft - 5;if (prop['chart.ylabels.inside']) {\n          x += 10;halign = 'left';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      } else if (prop['chart.yaxispos'] == 'right') {\n        var x = ca.width - this.gutterRight + 5;if (prop['chart.ylabels.inside']) {\n          x -= 10;halign = 'right';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      }\n      var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.xaxispos'] == 'center') {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / ((prop['chart.ylabels.specific'].length - 1) * 2) * i;if (ymin && ymin > 0) {\n            var y = this.grapharea / 2 / (prop['chart.ylabels.specific'].length - (ymin ? 1 : 0)) * i;y += this.gutterTop;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / 2 + this.gutterTop + this.grapharea / ((reversed_labels.length - 1) * 2) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': i == 0 ? '' : String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / (reversed_labels.length - 1) * i;y = y + this.gutterTop;RG.Text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / (prop['chart.ylabels.specific'].length - 1) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      }\n    }\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var yOffset = 5,\n          bordered = false,\n          bgcolor = null;\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var angle = 0,\n          valign = 'top',\n          halign = 'center',\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.xlabels.inside']) {\n        yOffset = -5;bordered = true;bgcolor = prop['chart.xlabels.inside.color'];valign = 'bottom';\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        valign = 'bottom';yOffset += 2;\n      }\n      if (typeof prop['chart.text.angle'] == 'number' && prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yOffset = 10;if (prop['chart.xaxispos'] == 'top') {\n          yOffset = 10;\n        }\n      }\n      var numLabels = prop['chart.labels'].length,\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];for (i = 0; i < numLabels; ++i) {\n        if (prop['chart.labels'][i]) {\n          var labelX = (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) / (numLabels - 1) * i;labelX += this.gutterLeft + prop['chart.hmargin'];if (this.data.length === 0 || !this.data[0] || prop['chart.labels'].length != this.data[0].length) {\n            labelX = this.gutterLeft + prop['chart.hmargin'] + (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) * (i / (prop['chart.labels'].length - 1));\n          }\n          if (!labelX) {\n            labelX = this.gutterLeft + prop['chart.hmargin'];\n          }\n          if (prop['chart.xaxispos'] == 'top' && prop['chart.text.angle'] > 0) {\n            halign = 'left';\n          }\n          if (prop['chart.text.angle'] != 0) {\n            halign = 'right';\n          }\n          RG.Text2(this, { 'font': font, 'size': text_size, 'bold': bold, 'x': labelX + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop - yOffset - (prop['chart.xlabels.inside'] ? -22 : 0) + offsety : ca.height - this.gutterBottom + yOffset + offsety, 'text': String(prop['chart.labels'][i]), 'valign': valign, 'halign': halign, 'bounding': bordered, 'boundingFill': bgcolor, 'angle': angle, 'tag': 'labels' });\n        }\n      }\n    }\n    co.stroke();co.fill();\n  };\n  this.drawLine = this.DrawLine = function (lineData, color, fill, linewidth, tickmarks, index) {\n    if (prop['chart.animation.unfold.y'] && prop['chart.animation.factor'] != 1) {\n      for (var i = 0; i < lineData.length; ++i) {\n        lineData[i] *= prop['chart.animation.factor'];\n      }\n    }\n    var penUp = false;var yPos = null;var xPos = 0;co.lineWidth = 1;var lineCoords = [];if (index > 0) {\n      var prevLineCoords = this.coords2[index - 1];\n    }\n    var xInterval = (ca.width - 2 * prop['chart.hmargin'] - this.gutterLeft - this.gutterRight) / (lineData.length - 1);for (i = 0, len = lineData.length; i < len; i += 1) {\n      var data_point = lineData[i];var yPos = this.getYCoord(data_point);if (lineData[i] == null || prop['chart.xaxispos'] == 'bottom' && lineData[i] < this.min && !prop['chart.outofbounds'] || prop['chart.xaxispos'] == 'center' && lineData[i] < -1 * this.max && !prop['chart.outofbounds'] || (lineData[i] < this.min && prop['chart.xaxispos'] !== 'center' || lineData[i] > this.max) && !prop['chart.outofbounds']) {\n        yPos = null;\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';if (i > 0) {\n        xPos = xPos + xInterval;\n      } else {\n        xPos = prop['chart.hmargin'] + this.gutterLeft;\n      }\n      if (prop['chart.animation.unfold.x']) {\n        xPos *= prop['chart.animation.factor'];if (xPos < prop['chart.gutter.left']) {\n          xPos = prop['chart.gutter.left'];\n        }\n      }\n      this.coords.push([xPos, yPos]);lineCoords.push([xPos, yPos]);\n    }\n    co.stroke();this.coords2[index] = lineCoords;if (RG.ISOLD && prop['chart.shadow']) {\n      this.DrawIEShadow(lineCoords, co.shadowColor);\n    }\n    co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';if (fill) {\n      co.fillStyle = fill;\n    }\n    var isStepped = prop['chart.stepped'];var isFilled = prop['chart.filled'];if (prop['chart.xaxispos'] == 'top') {\n      var xAxisPos = this.gutterTop;\n    } else if (prop['chart.xaxispos'] == 'center') {\n      var xAxisPos = this.gutterTop + this.grapharea / 2;\n    } else if (prop['chart.xaxispos'] == 'bottom') {\n      var xAxisPos = this.getYCoord(prop['chart.ymin']);\n    }\n    for (var i = 0, len = lineCoords.length; i < len; i += 1) {\n      xPos = lineCoords[i][0];yPos = lineCoords[i][1];var set = index;var prevY = lineCoords[i - 1] ? lineCoords[i - 1][1] : null;var isLast = i + 1 == lineCoords.length;if (!prop['chart.outofbounds'] && (prevY < this.gutterTop || prevY > ca.height - this.gutterBottom)) {\n        penUp = true;\n      }\n      if (i == 0 || penUp || !yPos || !prevY || prevY < this.gutterTop) {\n        if (prop['chart.filled'] && !prop['chart.filled.range']) {\n          if (!prop['chart.outofbounds'] || prevY === null || yPos === null) {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (prop['chart.xaxispos'] == 'top') {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (isStepped && i > 0) {\n            co.lineTo(xPos, lineCoords[i - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        } else {\n          if (RG.ISOLD && yPos == null) {} else {\n            co.moveTo(xPos + 1, yPos);\n          }\n        }\n        if (yPos == null) {\n          penUp = true;\n        } else {\n          penUp = false;\n        }\n      } else {\n        if (isStepped) {\n          co.lineTo(xPos, lineCoords[i - 1][1]);\n        }\n        if (yPos >= this.gutterTop && yPos <= ca.height - this.gutterBottom || prop['chart.outofbounds']) {\n          if (isLast && prop['chart.filled'] && !prop['chart.filled.range'] && prop['chart.yaxispos'] == 'right') {\n            xPos -= 1;\n          }\n          if (!isStepped || !isLast) {\n            co.lineTo(xPos, yPos);if (isFilled && lineCoords[i + 1] && lineCoords[i + 1][1] == null) {\n              co.lineTo(xPos, xAxisPos);\n            }\n          } else if (isStepped && isLast) {\n            co.lineTo(xPos, yPos);\n          }\n          penUp = false;\n        } else {\n          penUp = true;\n        }\n      }\n    }\n    if (prop['chart.filled'] && !prop['chart.filled.range'] && !prop['chart.curvy']) {\n      var fillStyle = prop['chart.fillstyle'];if (index > 0 && prop['chart.filled.accumulative']) {\n        co.lineTo(xPos, prevLineCoords ? prevLineCoords[i - 1][1] : ca.height - this.gutterBottom - 1 + (prop['chart.xaxispos'] == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 : 0));for (var k = i - 1; k >= 0; --k) {\n          co.lineTo(k == 0 ? prevLineCoords[k][0] + 1 : prevLineCoords[k][0], prevLineCoords[k][1]);\n        }\n      } else {\n        if (prop['chart.xaxispos'] == 'top') {\n          co.lineTo(xPos, prop['chart.gutter.top'] + 1);co.lineTo(lineCoords[0][0], prop['chart.gutter.top'] + 1);\n        } else if (typeof lineCoords[i - 1][1] == 'number') {\n          var yPosition = this.getYCoord(0);co.lineTo(xPos, yPosition);co.lineTo(lineCoords[0][0], yPosition);\n        }\n      }\n      co.fillStyle = !this.hidden(index) ? fill : 'rgba(0,0,0,0)';co.fill();co.beginPath();\n    }\n    co.stroke();if (prop['chart.backdrop']) {\n      this.DrawBackdrop(lineCoords, color);\n    }\n    co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();if (typeof prop['chart.errorbars'] !== 'null') {\n      this.drawErrorbars();\n    }\n    this.SetShadow(index);this.redrawLine(lineCoords, color, linewidth, index);co.stroke();RG.NoShadow(this);for (var i = 0; i < lineCoords.length; ++i) {\n      i = Number(i);co.strokeStyle = color;if (isStepped && i == lineCoords.length - 1) {\n        co.beginPath();\n      }\n      if (tickmarks != 'endcircle' && tickmarks != 'endsquare' && tickmarks != 'filledendsquare' && tickmarks != 'endtick' && tickmarks != 'endtriangle' && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == 0 && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == lineCoords.length - 1) {\n        var prevX = i <= 0 ? null : lineCoords[i - 1][0];var prevY = i <= 0 ? null : lineCoords[i - 1][1];this.DrawTick(lineData, lineCoords[i][0], lineCoords[i][1], color, false, prevX, prevY, tickmarks, i, index);\n      }\n    }\n    co.restore();co.beginPath();co.arc(ca.width + 50000, ca.height + 50000, 2, 0, 6.38, 1);\n  };this.drawTick = this.DrawTick = function (lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index, dataset) {\n    if (this.hidden(dataset)) {\n      return;\n    } else if (RG.is_null(yPos)) {\n      return false;\n    } else if (yPos > ca.height - this.gutterBottom && !prop['chart.outofbounds']) {\n      return;\n    } else if (yPos < this.gutterTop && !prop['chart.outofbounds']) {\n      return;\n    }\n    co.beginPath();var offset = 0;co.lineWidth = prop['chart.tickmarks.linewidth'] ? prop['chart.tickmarks.linewidth'] : prop['chart.linewidth'];co.strokeStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle') {\n      if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle' && (index == 0 || index == lineData.length - 1)) {\n        co.beginPath();co.arc(xPos + offset, yPos + offset, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false);if (tickmarks == 'filledcircle') {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n        } else {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';\n        }\n        co.stroke();co.fill();\n      }\n    } else if (tickmarks == 'halftick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'tick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'endtick' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'cross') {\n      co.beginPath();var ticksize = prop['chart.ticksize'];co.moveTo(xPos - ticksize, yPos - ticksize);co.lineTo(xPos + ticksize, yPos + ticksize);co.moveTo(xPos + ticksize, yPos - ticksize);co.lineTo(xPos - ticksize, yPos + ticksize);co.stroke();\n    } else if (tickmarks == 'triangle' || tickmarks == 'filledtriangle' || tickmarks == 'endtriangle' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();if (tickmarks == 'filledtriangle') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n      } else {\n        co.fillStyle = 'white';\n      }\n      co.moveTo(ma.round(xPos - prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.lineTo(ma.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(ma.round(xPos + prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'borderedcircle' || tickmarks == 'dot') {\n      co.lineWidth = prop['chart.tickmarks.dot.linewidth'] || 0.00000001;pa2(co, ['b', 'a', xPos, yPos, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false, 'c', 'f', prop['chart.tickmarks.dot.fill'] || color, 's', prop['chart.tickmarks.dot.stroke'] || color]);\n    } else if (tickmarks == 'square' || tickmarks == 'filledsquare' || tickmarks == 'endsquare' && (index == 0 || index == lineData.length - 1) || tickmarks == 'filledendsquare' && (index == 0 || index == lineData.length - 1)) {\n      co.fillStyle = 'white';co.strokeStyle = co.strokeStyle;co.beginPath();co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);if (tickmarks == 'filledsquare' || tickmarks == 'filledendsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);\n      } else if (tickmarks == 'square' || tickmarks == 'endsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';co.rect(Math.round(xPos - prop['chart.ticksize'] + 1), Math.round(yPos - prop['chart.ticksize'] + 1), prop['chart.ticksize'] * 2 - 2, prop['chart.ticksize'] * 2 - 2);\n      }\n      co.stroke();co.fill();\n    } else if (tickmarks == 'filledarrow') {\n      var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5, a + 0.5, false);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'arrow') {\n      var orig_linewidth = co.lineWidth;var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);co.lineWidth;if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5 - (doc.all ? 0.1 : 0.01), a - 0.4, false);co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a + 0.5 + (doc.all ? 0.1 : 0.01), a + 0.5, true);co.stroke();co.fill();co.lineWidth = orig_linewidth;\n    } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n      var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n        img.src = tickmarks.substr(6);\n      } else {\n        img.src = tickmarks;\n      }\n      img.onload = function () {\n        if (prop['chart.tickmarks.image.halign'] === 'center') xPos -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') xPos -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yPos -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yPos -= this.height;xPos += prop['chart.tickmarks.image.offsetx'];yPos += prop['chart.tickmarks.image.offsety'];co.drawImage(this, xPos, yPos);\n      };\n    } else if (typeof tickmarks == 'function') {\n      tickmarks(this, lineData, lineData[index], index, xPos, yPos, color, prevX, prevY);\n    }\n  };this.drawRange = this.DrawRange = function () {\n    if (prop['chart.filled.range'] && prop['chart.filled']) {\n      if (RG.isNull(prop['chart.filled.range.threshold'])) {\n        prop['chart.filled.range.threshold'] = this.ymin;\n        prop['chart.filled.range.threshold.colors'] = [prop['chart.fillstyle'], prop['chart.fillstyle']];\n      }\n      for (var idx = 0; idx < 2; ++idx) {\n        var threshold_colors = prop['chart.filled.range.threshold.colors'];var y = this.getYCoord(prop['chart.filled.range.threshold']);\n        co.save();if (idx == 0) {\n          co.beginPath();co.rect(0, 0, ca.width, y);co.clip();\n        } else {\n          co.beginPath();co.rect(0, y, ca.width, ca.height);co.clip();\n        }\n        co.beginPath();co.fillStyle = idx == 1 ? prop['chart.filled.range.threshold.colors'][1] : prop['chart.filled.range.threshold.colors'][0];co.lineWidth = !this.hidden(idx) ? 1 : 0;var len = this.coords.length / 2;for (var i = 0; i < len; ++i) {\n          if (!RG.is_null(this.coords[i][1])) {\n            if (i == 0) {\n              co.moveTo(this.coords[i][0], this.coords[i][1]);\n            } else {\n              co.lineTo(this.coords[i][0], this.coords[i][1]);\n            }\n          }\n        }\n        for (var i = this.coords.length - 1; i >= len; --i) {\n          if (RG.is_null(this.coords[i][1])) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n        co.fill();co.restore();\n      }\n    }\n  };this.redrawLine = this.RedrawLine = function (coords, color, linewidth, index) {\n    if (prop['chart.noredraw'] || prop['chart.filled.range']) {\n      return;\n    }\n    co.strokeStyle = (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color && color.toString().indexOf('CanvasGradient') == -1 ? color[0] : color;co.lineWidth = linewidth;if (prop['chart.dashed']) {\n      co.setLineDash([2, 6]);\n    } else if (prop['chart.dotted']) {\n      co.setLineDash([1, 5]);\n    }\n    if (this.hidden(index)) {\n      co.strokeStyle = 'rgba(0,0,0,0)';\n    }\n    if (!RG.ISOLD && (prop['chart.curvy'] || prop['chart.spline'])) {\n      this.DrawCurvyLine(coords, this.hidden(index) ? 'rgba(0,0,0,0)' : color, linewidth, index);return;\n    }\n    co.beginPath();var len = coords.length;var width = ca.width;\n    var height = ca.height;var penUp = false;for (var i = 0; i < len; ++i) {\n      var xPos = coords[i][0];var yPos = coords[i][1];if (i > 0) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];\n      }\n      if ((i == 0 && coords[i] || yPos < this.gutterTop || prevY < this.gutterTop || yPos > height - this.gutterBottom || i > 0 && prevX > width - this.gutterRight || i > 0 && prevY > height - this.gutterBottom || prevY == null || penUp == true) && (!prop['chart.outofbounds'] || yPos == null || prevY == null)) {\n        if (RG.ISOLD && yPos == null) {} else {\n          co.moveTo(coords[i][0], coords[i][1]);\n        }\n        penUp = false;\n      } else {\n        if (prop['chart.stepped'] && i > 0) {\n          co.lineTo(coords[i][0], coords[i - 1][1]);\n        }\n        co.lineTo(coords[i][0], coords[i][1]);penUp = false;\n      }\n    }\n    if (prop['chart.colors.alternate'] && (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color[0] && color[1]) {\n      for (var i = 1; i < len; ++i) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];if (prevY != null && coords[i][1] != null) {\n          co.beginPath();co.strokeStyle = color[coords[i][1] < prevY ? 0 : 1];co.lineWidth = prop['chart.linewidth'];co.moveTo(prevX, prevY);co.lineTo(coords[i][0], coords[i][1]);co.stroke();\n        }\n      }\n    }\n    if (prop['chart.dashed'] || prop['chart.dotted']) {\n      co.setLineDash([1, 0]);\n    }\n  };this.drawIEShadow = this.DrawIEShadow = function (coords, color) {\n    var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.strokeStyle = color;co.beginPath();for (var i = 0; i < coords.length; ++i) {\n      var isNull = RG.isNull(coords[i][1]);var prevIsNull = RG.isNull(coords[i - 1]) || RG.isNull(coords[i - 1][1]);if (i == 0 || isNull || prevIsNull) {\n        if (!isNull) {\n          co.moveTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n        }\n      } else {\n        co.lineTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n      }\n    }\n    co.stroke();\n  };this.drawBackdrop = this.DrawBackdrop = function (coords, color) {\n    var size = prop['chart.backdrop.size'];co.lineWidth = size;co.globalAlpha = prop['chart.backdrop.alpha'];co.strokeStyle = color;var yCoords = [];co.beginPath();if (prop['chart.curvy'] && !RG.ISOLD) {\n      for (var i = 0; i < coords.length; ++i) {\n        yCoords.push(coords[i][1]);\n      }\n      this.DrawSpline(co, yCoords, color, null);\n    } else {\n      co.moveTo(coords[0][0], coords[0][1]);for (var j = 1; j < coords.length; ++j) {\n        co.lineTo(coords[j][0], coords[j][1]);\n      }\n    }\n    co.stroke();co.globalAlpha = 1;RG.NoShadow(this);\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[LINE] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var obj = this,\n        RG = RGraph,\n        ca = canvas = e.target,\n        co = context = this.context,\n        prop = this.properties;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (arguments[1]) {\n      obj = arguments[1];\n    }\n    for (var i = 0; i < obj.coords.length; ++i) {\n      var x = obj.coords[i][0];var y = obj.coords[i][1];if (mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size'] && mouseY <= y + prop['chart.tooltips.hotspot.size'] && mouseY >= y - prop['chart.tooltips.hotspot.size']) {\n        if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);\n        }\n        var dataset = 0;var idx = i;while (idx + 1 > this.data[dataset].length) {\n          idx -= this.data[dataset].length;dataset++;\n        }\n        return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip, 'dataset': dataset, 'index_adjusted': idx };\n      } else if (prop['chart.tooltips.hotspot.xonly'] == true && mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size']) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'],\n        font = prop['chart.labels.above.font'] || prop['chart.text.font'],\n        units_pre = prop['chart.labels.above.units.pre'],\n        units_post = prop['chart.labels.above.units.post'],\n        decimals = prop['chart.labels.above.decimals'],\n        color = prop['chart.labels.above.color'] || prop['chart.text.color'],\n        bgcolor = prop['chart.labels.above.background'] || 'white',\n        border = typeof prop['chart.labels.above.border'] === 'boolean' || typeof prop['chart.labels.above.border'] === 'number' ? prop['chart.labels.above.border'] : true,\n        offsety = prop['chart.labels.above.offsety'] + size,\n        specific = prop['chart.labels.above.specific'];co.beginPath();for (var i = 0, len = this.coords.length; i < len; i += 1) {\n      var coords = this.coords[i];RG.text2(this, { color: color, 'font': font, 'size': size, 'x': coords[0], 'y': coords[1] - offsety, 'text': specific && specific[i] ? specific[i] : specific ? null : RG.numberFormat(this, typeof decimals === 'number' ? this.data_arr[i].toFixed(decimals) : this.data_arr[i], units_pre, units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': bgcolor, 'boundingStroke': border ? 'black' : 'rgba(0,0,0,0)', 'tag': 'labels.above' });\n    }\n  };this.drawCurvyLine = this.DrawCurvyLine = function (coords, color, linewidth, index) {\n    var yCoords = [];for (var i = 0; i < coords.length; ++i) {\n      yCoords.push(coords[i][1]);\n    }\n    if (prop['chart.filled']) {\n      co.beginPath();var xaxisY = this.getYCoord(prop['chart.ymin']);co.moveTo(coords[0][0], xaxisY);this.drawSpline(co, yCoords, color, index);if (prop['chart.filled.accumulative'] && index > 0) {\n        for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; i -= 1) {\n          co.lineTo(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]);\n        }\n      } else {\n        co.lineTo(coords[coords.length - 1][0], xaxisY);\n      }\n      co.fill();\n    }\n    co.beginPath();this.DrawSpline(co, yCoords, color, index);co.stroke();\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;var xaxispos = prop['chart.xaxispos'];if (mouseY < prop['chart.gutter.top']) {\n      return xaxispos == 'bottom' || xaxispos == 'center' ? this.max : this.min;\n    } else if (mouseY > ca.height - prop['chart.gutter.bottom']) {\n      return xaxispos == 'bottom' ? this.min : this.max;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (obj.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value *= 2;value > 0 ? value += this.min : value -= this.min;return value;\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value = Math.abs(obj.max - value) * -1;return value;\n    } else {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);\n      value += obj.min;return value;\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] === 'halo') {\n        var obj = shape.object,\n            color = prop['chart.colors'][shape.dataset];RG.path2(obj.context, 'b a % % 13 0 6.2830 false f rgba(255,255,255,0.75)', shape.x, shape.y);RG.path2(obj.context, 'ga 0.15 b a % % 13 0 6.2830 false f % ga 1', shape.x, shape.y, color);RG.path2(obj.context, 'b a % % 7 0 6.2830 false f white', shape.x, shape.y);RG.path2(obj.context, 'b a % % 5 0 6.2830 false f %', shape.x, shape.y, color);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] - 5 && mouseXY[0] < ca.width - prop['chart.gutter.right'] + 5 && mouseXY[1] > prop['chart.gutter.top'] - 5 && mouseXY[1] < ca.height - prop['chart.gutter.bottom'] + 5) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);this.original_data[shape['dataset']][shape['index_adjusted']] = Number(value);RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var y;var xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.min) / (this.max - this.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if ((value < this.min || value > this.max) && prop['chart.outofbounds'] == false) {\n        return null;\n      }\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.drawSpline = this.DrawSpline = function (context, coords, color, index) {\n    this.coordsSpline[index] = [];var xCoords = [];var gutterLeft = prop['chart.gutter.left'];var gutterRight = prop['chart.gutter.right'];var hmargin = prop['chart.hmargin'];var interval = (ca.width - (gutterLeft + gutterRight) - 2 * hmargin) / (coords.length - 1);co.strokeStyle = color;for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n        coords[i] = Number(coords[i][1]);\n      }\n    }\n    var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n      P.push(coords[i]);\n    }\n    P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n      for (var t = 0; t < 10; ++t) {\n        var yCoord = Spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);co.lineTo(xCoords[xCoords.length - 1], yCoord);if (typeof index == 'number') {\n          this.coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n        }\n      }\n    }\n    co.lineTo((j - 1) * interval + gutterLeft + hmargin, P[j]);if (typeof index == 'number') {\n      this.coordsSpline[index].push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n    }\n    function Spline(t, P0, P1, P2, P3) {\n      return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.fillstyle'] = RGraph.array_clone(prop['chart.fillstyle']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.annotate.color'] = prop['chart.annotate.color'];this.original_colors['chart.title.color'] = prop['chart.title.color'];this.original_colors['chart.title.yaxis.color'] = prop['chart.title.yaxis.color'];this.original_colors['chart.key.background'] = prop['chart.key.background'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      if (_typeof(prop['chart.colors'][i]) == 'object' && prop['chart.colors'][i][0] && prop['chart.colors'][i][1]) {\n        prop['chart.colors'][i][0] = this.parseSingleColorForGradient(prop['chart.colors'][i][0]);prop['chart.colors'][i][1] = this.parseSingleColorForGradient(prop['chart.colors'][i][1]);\n      } else {\n        prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n      }\n    }\n    if (prop['chart.fillstyle']) {\n      if (typeof prop['chart.fillstyle'] == 'string') {\n        prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle'], 'vertical');\n      } else {\n        for (var i = 0; i < prop['chart.fillstyle'].length; ++i) {\n          prop['chart.fillstyle'][i] = this.parseSingleColorForGradient(prop['chart.fillstyle'][i], 'vertical');\n        }\n      }\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    var properties = ['chart.background.barcolor1', 'chart.background.barcolor2', 'chart.background.grid.color', 'chart.background.color', 'chart.text.color', 'chart.crosshairs.color', 'chart.annotate.color', 'chart.title.color', 'chart.title.yaxis.color', 'chart.key.background', 'chart.axis.color', 'chart.highlight.fill'];for (var i = 0; i < properties.length; ++i) {\n      prop[properties[i]] = this.parseSingleColorForGradient(prop[properties[i]]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    var dir = typeof arguments[1] == 'string' ? arguments[1] : 'vertical';if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (dir == 'horizontal') {\n        var grad = co.createLinearGradient(0, 0, ca.width, 0);\n      } else {\n        var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);\n      }\n      var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.setShadow = this.SetShadow = function (i) {\n    if (prop['chart.shadow']) {\n      var shadowColor = prop['chart.shadow.color'];if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object' && shadowColor[i - 1]) {\n        co.shadowColor = shadowColor[i];\n      } else if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object') {\n        co.shadowColor = shadowColor[0];\n      } else if (typeof shadowColor == 'string') {\n        co.shadowColor = shadowColor;\n      }\n      co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();if (prop['chart.curvy']) {\n        this.DrawSpline(co, coords, prop['chart.key.interactive.highlight.chart'], null);\n      } else {\n        for (var i = 0, len = coords.length; i < len; i += 1) {\n          if (i == 0 || RG.is_null(coords[i][1]) || _typeof(coords[i - 1][1]) != undefined && RG.is_null(coords[i - 1][1])) {\n            co.moveTo(coords[i][0], coords[i][1]);\n          } else {\n            co.lineTo(coords[i][0], coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.drawErrorbars = function () {\n    co.save();RG.noShadow(this);var coords = this.coords,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0.001;halfwidth = 0.0005;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      var halfwidth = prop['chart.errorbars.capped.width'] / 2 || 5,\n          color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      } else {\n        co.lineWidth = 1;\n      }\n      if (typeof errorbars === 'number' || typeof errorbars[i] === 'number') {\n        if (typeof errorbars === 'number') {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars),\n              negativeLength = positiveLength;\n        } else {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i]),\n              negativeLength = positiveLength;\n        }\n        if (positiveLength || negativeLength) {\n          pa2(co, 'lj miter lc square b m % % l % % m % % l % % l % % m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, coords[i][0], coords[i][1] + negativeLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, coords[i][1] - positiveLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] + halfwidth, coords[i][1] - positiveLength, color);pa2(co, 'lj miter lc square b m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][0]),\n            negativeLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][1]);if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : halfwidth;if (_typeof(errorbars[i]) === 'object' && typeof errorbars[i][3] === 'number') {\n          co.lineWidth = errorbars[i][3];\n        } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n          co.lineWidth = prop['chart.errorbars.linewidth'];\n        } else {\n          co.lineWidth = 1;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'lc square b  m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0], ma.round(coords[i][1] - positiveLength), coords[i][0] + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] + negativeLength, coords[i][0] - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0], ma.round(coords[i][1] + negativeLength), coords[i][0] + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n    }\n    co.restore();\n  };this.hide = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = false;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = false;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = false;\n      }\n    }\n    RG.redraw();return this;\n  };this.show = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = true;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = true;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = true;\n      }\n    }\n    RG.redraw();return this;\n  };this.hidden = function (index) {\n    return !prop['chart.line.visible'][index];\n  };this.unfold = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var initial = prop['chart.animation.unfold.initial'];prop['chart.animation.factor'] = prop['chart.animation.unfold.initial'];function iterator() {\n      prop['chart.animation.factor'] = (1 - initial) * (frame / frames) + initial;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = this.trace2 = function () {\n    var obj = this;var callback = arguments[2];var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.Set('animation.trace.clip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.foldtocenter = this.foldToCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var center_value = obj.scale2.max / 2;obj.Set('chart.ymax', obj.scale2.max);var original_data = RG.array_clone(obj.original_data);function iterator() {\n      for (var i = 0, len = obj.data.length; i < len; ++i) {\n        if (obj.data[i].length) {\n          for (var j = 0, len2 = obj.data[i].length; j < len2; ++j) {\n            var dataset = obj.original_data[i];if (dataset[j] > center_value) {\n              dataset[j] = original_data[i][j] - (original_data[i][j] - center_value) * (frame / frames);\n            } else {\n              dataset[j] = original_data[i][j] + (center_value - original_data[i][j]) / frames * frame;\n            }\n          }\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n      if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.unfoldFromCenterTrace = this.unfoldFromCenterTrace2 = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        data = RG.arrayClone(obj.original_data),\n        callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var unfoldCallback = function unfoldCallback() {\n      obj.original_data = data;obj.unfoldFromCenter({ frames: frames / 2 }, callback);\n    };var half = obj.Get('chart.xaxispos') == 'center' ? obj.min : (obj.max - obj.min) / 2 + obj.min;obj.Set('chart.ymax', obj.max);for (var i = 0, len = obj.original_data.length; i < len; ++i) {\n      for (var j = 0; j < obj.original_data[i].length; ++j) {\n        obj.original_data[i][j] = obj.Get('chart.filled') && obj.Get('chart.filled.accumulative') && i > 0 ? 0 : half;\n      }\n    }\n    RG.clear(obj.canvas);obj.trace2({ frames: frames / 2 }, unfoldCallback);return obj;\n  };this.unfoldFromCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.Draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var center_value = obj.Get('chart.xaxispos') === 'center' ? prop['chart.ymin'] : (obj.max - obj.min) / 2 + obj.min;var original_data = RG.array_clone(obj.original_data);var steps = null;obj.Set('chart.ymax', max);if (!steps) {\n      steps = [];for (var dataset = 0, len = original_data.length; dataset < len; ++dataset) {\n        steps[dataset] = [];\n        for (var i = 0, len2 = original_data[dataset].length; i < len2; ++i) {\n          if (prop['chart.filled'] && prop['chart.filled.accumulative'] && dataset > 0) {\n            steps[dataset][i] = original_data[dataset][i] / frames;obj.original_data[dataset][i] = center_value;\n          } else {\n            steps[dataset][i] = (original_data[dataset][i] - center_value) / frames;obj.original_data[dataset][i] = center_value;\n          }\n        }\n      }\n    }\n    function unfoldFromCenter() {\n      for (var dataset = 0; dataset < original_data.length; ++dataset) {\n        for (var i = 0; i < original_data[dataset].length; ++i) {\n          obj.original_data[dataset][i] += steps[dataset][i];\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (--frames > 0) {\n        RG.Effects.updateCanvas(unfoldFromCenter);\n      } else {\n        obj.original_data = RG.array_clone(original_data);RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    unfoldFromCenter();return this;\n  };RG.att(ca);this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    prop['chart.line.visible'][i] = true;\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.line.js\n// module id = 194\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.line.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Meter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'meter';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.centerx = null;this.centery = null;this.radius = null;this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.image.url': null, 'chart.background.image.offsetx': 0, 'chart.background.image.offsety': 0, 'chart.background.image.stretch': true, 'chart.background.color': 'white', 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 20, 'chart.linewidth': 1, 'chart.linewidth.segments': 0, 'chart.strokestyle': null, 'chart.border': true, 'chart.border.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.valign': 'center', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.value.text.decimals': 0, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.green.start': (this.max - this.min) * 0.35 + this.min, 'chart.green.end': this.max, 'chart.green.color': '#207A20', 'chart.yellow.start': (this.max - this.min) * 0.1 + this.min, 'chart.yellow.end': (this.max - this.min) * 0.35 + this.min, 'chart.yellow.color': '#D0AC41', 'chart.red.start': this.min, 'chart.red.end': (this.max - this.min) * 0.1 + this.min, 'chart.red.color': '#9E1E1E', 'chart.colors.ranges': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.contextmenu': null, 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.tickmarks.small.num': 100, 'chart.tickmarks.big.num': 10, 'chart.tickmarks.small.color': '#bbb', 'chart.tickmarks.big.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.labels': true, 'chart.labels.count': 10, 'chart.labels.specific': null, 'chart.segment.radius.start': 0, 'chart.needle.radius': null, 'chart.needle.tail': false, 'chart.needle.head': true, 'chart.needle.color': 'black', 'chart.needle.image.url': null, 'chart.needle.image.offsetx': 0, 'chart.needle.image.offsety': 0, 'chart.adjustable': false, 'chart.angles.start': RGraph.PI, 'chart.angles.end': RGraph.TWOPI, 'chart.centerpin.stroke': 'black', 'chart.centerpin.fill': 'white', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[METER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, ca.height - this.gutterTop - this.gutterBottom);this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawBackground();this.drawLabels();this.drawNeedle();this.drawReadout();RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (typeof prop['chart.background.image.url'] === 'string' && !this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];var img = new Image();this.__background_image__ = img;img.src = prop['chart.background.image.url'];img.onload = function () {\n        if (prop['chart.background.image.stretch']) {\n          co.drawImage(this, x, y, ca.width, ca.height);\n        } else {\n          co.drawImage(this, x, y);\n        }\n        RG.redraw();\n      };\n    } else if (this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];if (prop['chart.background.image.stretch']) {\n        co.drawImage(this.__background_image__, x, y, ca.width, ca.height);\n      } else {\n        co.drawImage(this.__background_image__, x, y);\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.fill();RG.NoShadow(this);if (prop['chart.shadow']) {\n      co.beginPath();var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);\n    }\n    if (prop['chart.tickmarks.small.num']) {\n      for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += RG.PI / prop['chart.tickmarks.small.num']) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.stroke();\n      }\n      co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - 4, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();\n    }\n    if (prop['chart.tickmarks.big.num']) {\n      var colors = ['white', 'white', prop['chart.tickmarks.big.color']];for (var j = 0; j < colors.length; ++j) {\n        for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += (prop['chart.angles.end'] - prop['chart.angles.start']) / prop['chart.tickmarks.big.num']) {\n          co.beginPath();co.strokeStyle = colors[j];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.0001, 0);co.stroke();\n        }\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius - 7, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();var ranges = prop['chart.colors.ranges'];if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : ranges[i][2];co.fillStyle = ranges[i][2];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n          co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n        } else {\n          co.lineTo(this.centerx, this.centery);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n      co.beginPath();\n    } else {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - this.properties['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.lineWidth = 1;\n    }\n    if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.linewidth'];co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawNeedle = this.DrawNeedle = function () {\n    var a = (this.value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];if (typeof prop['chart.needle.image.url'] === 'string' && !this.__needle_image__) {\n      var img = new Image();this.__needle_image__ = img;img.src = prop['chart.needle.image.url'];img.onload = function () {\n        co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();RG.redraw();\n      };\n    } else if (this.__needle_image__) {\n      co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this.__needle_image__, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();\n    }\n    var needleRadius = typeof prop['chart.needle.radius'] == 'number' ? prop['chart.needle.radius'] : this.radius * 0.7;co.fillStyle = 'black';co.lineWidth = this.radius >= 200 ? 7 : 3;co.lineCap = 'round';co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];co.arc(this.centerx, this.centery, needleRadius, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();if (prop['chart.needle.head']) {\n      co.fillStyle = prop['chart.needle.color'];co.beginPath();co.lineWidth = 1;co.arc(this.centerx, this.centery, needleRadius + 15, a, a + 0.001, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a + 0.087, a + 0.087999, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a - 0.087, a - 0.087999, 1);co.fill();\n    }\n    if (prop['chart.needle.tail']) {\n      co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];var a = (this.value - this.min) / (this.max - this.min) * (this.properties['chart.angles.end'] - this.properties['chart.angles.start']) + this.properties['chart.angles.start'] + RG.PI;co.arc(this.centerx, this.centery, 25, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();\n    }\n    var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.beginPath();co.fillStyle = prop['chart.centerpin.stroke'];co.arc(this.centerx, this.centery, r, 0 + 0.001, RG.TWOPI, 0);co.fill();co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.arc(this.centerx, this.centery, r - 2, 0 + 0.001, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.labels']) {\n      return;\n    }\n    var radius = this.radius,\n        text_size = prop['chart.text.size'],\n        text_font = prop['chart.text.font'],\n        units_post = prop['chart.units.post'],\n        units_pre = prop['chart.units.pre'],\n        centerx = this.centerx,\n        centery = this.centery,\n        min = this.min,\n        max = this.max,\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        specific = prop['chart.labels.specific'];\n    if (specific) {\n      for (var i = 0; i < specific.length; ++i) {\n        var angle = this.getAngle(specific[i][1]),\n            angle_degrees = angle * (180 / RG.PI),\n            text = specific[i][0].toString(),\n            coords = RG.getRadiusEndPoint(this.centerx, this.centery, angle, this.radius * 0.925);\n        RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': text, 'halign': 'center', 'valign': 'center', 'angle': angle_degrees + 90, 'bounding': false, 'tag': 'labels-specific', color: 'black' });\n      }\n      return;\n    }\n    co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;co.beginPath();for (var i = 0; i <= numLabels; ++i) {\n      var angle = (prop['chart.angles.end'] - prop['chart.angles.start']) * (i / numLabels) + prop['chart.angles.start'];var coords = RG.getRadiusEndPoint(centerx, centery, angle + ((i == 0 || i == numLabels) && prop['chart.border'] ? i == 0 ? 0.05 : -0.05 : 0), this.radius * 0.925 - (prop['chart.text.valign'] === 'bottom' ? 15 : 0));var angleStart = prop['chart.angles.start'],\n          angleEnd = prop['chart.angles.end'],\n          angleRange = angleEnd - angleStart,\n          angleStart_degrees = angleStart * (180 / RG.PI),\n          angleEnd_degrees = angleEnd * (180 / RG.PI),\n          angleRange_degrees = angleRange * (180 / RG.PI);\n      valign = prop['chart.text.valign'];if (prop['chart.border']) {\n        if (i == 0) {\n          halign = 'left';\n        } else if (i == numLabels) {\n          halign = 'right';\n        } else {\n          halign = 'center';\n        }\n      } else {\n        halign = 'center';\n      }\n      var value = (this.max - this.min) * (i / numLabels) + this.min;RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': RG.numberFormat(this, value.toFixed(value === 0 ? 0 : decimals), units_pre, units_post), 'halign': halign, 'valign': valign, 'angle': angleRange_degrees * (1 / numLabels) * i + angleStart_degrees - 270, 'bounding': false, 'boundingFill': i == 0 || i == numLabels ? 'white' : null, 'tag': 'scale' });\n    }\n  };this.drawReadout = this.DrawReadout = function () {\n    if (prop['chart.value.text']) {\n      co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx, 'y': this.centery - prop['chart.text.size'] - 15, 'text': prop['chart.value.text.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.text.units.post'], 'halign': 'center', 'valign': 'bottom', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });co.stroke();co.fill();\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (radius > this.radius) {\n      return null;\n    }\n    if (angle < RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = Math.max(value, this.min);value = Math.min(value, this.max);return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(this.canvas);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);var ranges = prop['chart.colors.ranges'];if (ranges && ranges.length) {\n      for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, prop['chart.segment.radius.start'], this.centerx, this.centery, this.radius * 0.85);var diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;obj.currentValue = obj.currentValue || obj.min;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var diff = obj.value - obj.currentValue;var step = diff / frames;var callback = arguments[1] || function () {};var initial = obj.currentValue;function iterator() {\n      obj.value = initial + frame++ * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.meter.js\n// module id = 195\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.meter.js?")},function(module,exports){eval("\nModalDialog = { dialog: null, background: null, offset: 50, events: [], Show: function Show(id, width) {\n    ModalDialog.id = id;ModalDialog.width = width;ModalDialog.ShowBackground();ModalDialog.ShowDialog();window.onresize = ModalDialog.Resize;document.body.addEventListener('keydown', function (e) {\n      if (e.keyCode === 27) {\n        ModalDialog.hide();\n      }\n    }, false);ModalDialog.Resize();if (typeof ModalDialog.onmodaldialog == 'function') {\n      ModalDialog.onmodaldialog();\n    }\n    ModalDialog.FireCustomEvent('onmodaldialog');\n  }, ShowBackground: function ShowBackground() {\n    ModalDialog.background = document.createElement('DIV');ModalDialog.background.className = 'ModalDialog_background';ModalDialog.background.style.position = 'fixed';ModalDialog.background.style.top = 0;ModalDialog.background.style.left = 0;ModalDialog.background.style.width = screen.width + 100 + 'px';ModalDialog.background.style.height = screen.height + 100 + 'px';ModalDialog.background.style.backgroundColor = 'rgb(204,204,204)';ModalDialog.background.style.opacity = 0;ModalDialog.background.style.zIndex = 3276;ModalDialog.background.style.filter = \"Alpha(opacity=50)\";document.body.appendChild(ModalDialog.background);ModalDialog.background.style.visibility = 'visible';\n  }, ShowDialog: function ShowDialog() {\n    if (!ModalDialog.dialog || true) {\n      ModalDialog.dialog = document.createElement('DIV');ModalDialog.dialog.id = 'ModalDialog_dialog';ModalDialog.dialog.className = 'ModalDialog_dialog';var borderRadius = '15px';ModalDialog.dialog.style.borderRadius = borderRadius;ModalDialog.dialog.style.MozBorderRadius = borderRadius;ModalDialog.dialog.style.WebkitBorderRadius = borderRadius;ModalDialog.dialog.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';ModalDialog.dialog.style.position = 'fixed';ModalDialog.dialog.style.backgroundColor = 'white';ModalDialog.dialog.style.width = parseInt(ModalDialog.width) + 'px';ModalDialog.dialog.style.border = '2px solid #999';ModalDialog.dialog.style.zIndex = 32767;ModalDialog.dialog.style.padding = '5px';ModalDialog.dialog.style.paddingTop = '25px';ModalDialog.dialog.style.opacity = 0;if (document.all) {\n        ModalDialog.dialog.style.zIndex = 32767;\n      }\n      if (navigator.userAgent.indexOf('Opera') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('MSIE') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('Safari') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      }\n      document.body.appendChild(ModalDialog.dialog);var bar = document.createElement('DIV');bar.className = 'ModalDialog_topbar';bar.style.top = 0;bar.style.left = 0;bar.style.width = '100%';bar.style.height = '20px';bar.style.backgroundColor = '#bbb';bar.style.borderBottom = '2px solid #999';bar.style.position = 'absolute';var borderRadius = '11px';bar.style.WebkitBorderTopLeftRadius = borderRadius;bar.style.WebkitBorderTopRightRadius = borderRadius;bar.style.MozBorderRadiusTopleft = borderRadius;bar.style.MozBorderRadiusTopright = borderRadius;bar.style.borderTopRightRadius = borderRadius;bar.style.borderTopLeftRadius = borderRadius;ModalDialog.dialog.appendChild(bar);var content = document.createElement('DIV');content.style.width = '100%';content.style.height = '100%';ModalDialog.dialog.appendChild(content);if (ModalDialog.id.toLowerCase().substring(0, 7) == 'string:') {\n        content.innerHTML = ModalDialog.id.substring(7);\n      } else {\n        content.innerHTML = document.getElementById(ModalDialog.id).innerHTML;\n      }\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';ModalDialog.dialog.style.top = '30%';\n    }\n    ModalDialog.dialog.style.visibility = 'visible';setTimeout('ModalDialog.dialog.style.opacity = 0.2', 50);setTimeout('ModalDialog.dialog.style.opacity = 0.4', 100);setTimeout('ModalDialog.dialog.style.opacity = 0.6', 150);setTimeout('ModalDialog.dialog.style.opacity = 0.8', 200);setTimeout('ModalDialog.dialog.style.opacity = 1', 250);setTimeout('ModalDialog.background.style.opacity = 0.1', 50);setTimeout('ModalDialog.background.style.opacity = 0.2', 100);setTimeout('ModalDialog.background.style.opacity = 0.3', 150);setTimeout('ModalDialog.background.style.opacity = 0.4', 200);setTimeout('ModalDialog.background.style.opacity = 0.5', 250);\n  }, Close: function Close() {\n    if (ModalDialog.dialog) {\n      if (document.getElementById(ModalDialog.dialog.id)) {\n        document.body.removeChild(ModalDialog.dialog);\n      }\n      ModalDialog.dialog.style.visibility = 'hidden';ModalDialog.dialog.style.opacity = 0;\n    }\n    if (ModalDialog.background) {\n      ModalDialog.background.style.visibility = 'hidden';ModalDialog.background.style.opacity = 0;if (document.getElementById(ModalDialog.background.id)) {\n        document.body.removeChild(ModalDialog.background);\n      }\n    }\n  }, Resize: function Resize() {\n    if (ModalDialog.dialog) {\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';\n    }\n    ModalDialog.background.style.width = '2500px';ModalDialog.background.style.height = '2500px';\n  }, AddCustomEventListener: function AddCustomEventListener(name, func) {\n    if (typeof ModalDialog.events == 'undefined') {\n      ModalDialog.events = [];\n    }\n    ModalDialog.events.push([name, func]);\n  }, FireCustomEvent: function FireCustomEvent(name) {\n    for (var i = 0; i < ModalDialog.events.length; ++i) {\n      if (typeof ModalDialog.events[i][0] == 'string' && ModalDialog.events[i][0] == name && typeof ModalDialog.events[i][1] == 'function') {\n        ModalDialog.events[i][1]();\n      }\n    }\n  }, isIE8: function isIE8() {\n    return document.all && navigator.userAgent.indexOf('MSIE 8') > 0;\n  } };ModalDialog.show = ModalDialog.Show;ModalDialog.draw = ModalDialog.Show;ModalDialog.Hide = ModalDialog.Close;ModalDialog.hide = ModalDialog.Close;ModalDialog.close = ModalDialog.Close;for (i in ModalDialog) {\n  if (typeof ModalDialog[i] === 'function') {\n    ModalDialog[i.toLowerCase()] = ModalDialog[i];\n  }\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.modaldialog.js\n// module id = 196\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.modaldialog.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Odometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'odo';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.border': 'black', 'chart.background.color': '#eee', 'chart.background.lines.color': '#ddd', 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.value.text': false, 'chart.value.text.decimals': 0, 'chart.needle.color': 'black', 'chart.needle.width': 2, 'chart.needle.head': true, 'chart.needle.tail': true, 'chart.needle.type': 'pointer', 'chart.needle.extra': [], 'chart.needle.triangle.border': '#aaa', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.green.max': max * 0.75, 'chart.red.min': max * 0.9, 'chart.green.color': 'Gradient(white:#0c0)', 'chart.yellow.color': 'Gradient(white:#ff0)', 'chart.red.color': 'Gradient(white:#f00)', 'chart.label.area': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.font': null, 'chart.title.bold': true, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.contextmenu': null, 'chart.linewidth': 1, 'chart.shadow.inner': false, 'chart.shadow.inner.color': 'black', 'chart.shadow.inner.offsetx': 3, 'chart.shadow.inner.offsety': 3, 'chart.shadow.inner.blur': 6, 'chart.shadow.outer': false, 'chart.shadow.outer.color': 'black', 'chart.shadow.outer.offsetx': 3, 'chart.shadow.outer.offsety': 3, 'chart.shadow.outer.blur': 6, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.border': false, 'chart.border.color1': '#BEBCB0', 'chart.border.color2': '#F0EFEA', 'chart.border.color3': '#BEBCB0', 'chart.tickmarks': true, 'chart.tickmarks.highlighted': false, 'chart.tickmarks.big.color': '#999', 'chart.zerostart': false, 'chart.labels': null }, _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.value.units.pre', ''), _defineProperty(_properties, 'chart.value.units.post', ''), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.text.size', 10), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.style') {\n      alert('[RGRAPH] The RGraph property chart.needle.style has changed to chart.needle.color');\n    }\n    if (name == 'chart.needle.thickness') {\n      name = 'chart.needle.width';\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (this.value > this.max) {\n      this.value = this.max;\n    }\n    if (this.value < this.min) {\n      this.value = this.min;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2) - (prop['chart.border'] ? 25 : 0);this.diameter = 2 * this.radius;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.range = this.max - this.min;this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && ca.width > ca.height) this.centerx = 5 + this.radius;if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];if (prop['chart.border']) {\n        this.radius -= 25;\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    co.lineWidth = prop['chart.linewidth'];this.DrawBackground();this.DrawLabels();this.DrawNeedle(this.value, prop['chart.needle.color']);if (prop['chart.needle.extra'].length > 0) {\n      for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n        var needle = prop['chart.needle.extra'][i];this.DrawNeedle(needle[0], needle[1], needle[2]);\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0) {\n      var colors = [prop['chart.needle.color']];if (prop['chart.needle.extra'].length > 0) {\n        for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n          var needle = prop['chart.needle.extra'][i];colors.push(needle[1]);\n        }\n      }\n      RG.DrawKey(this, prop['chart.key'], colors);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.beginPath();if (prop['chart.shadow.outer']) {\n      RG.setShadow(this, prop['chart.shadow.outer.color'], prop['chart.shadow.outer.offsetx'], prop['chart.shadow.outer.offsety'], prop['chart.shadow.outer.blur']);\n    }\n    var backgroundColor = prop['chart.background.color'];co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0.0001, RG.TWOPI, false);co.fill();RG.noShadow(this);co.strokeStyle = '#666';co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fill();if (prop['chart.tickmarks']) {\n      co.beginPath();co.strokeStyle = '#bbb';for (var i = 0; i <= 360; i += 3) {\n        co.arc(this.centerx, this.centery, this.radius, 0, i / 57.3, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    co.beginPath();co.lineWidth = 1;co.strokeStyle = 'black';co.fillStyle = backgroundColor;co.strokeStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius - 5, 0, RG.TWOPI, false);co.fill();co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.lines.color'];for (var i = 0; i < 360; i += 18) {\n      co.arc(this.centerx, this.centery, this.radius, 0, RG.degrees2Radians(i), false);co.lineTo(this.centerx, this.centery);\n    }\n    co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.border'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.stroke();if (prop['chart.shadow.inner']) {\n      co.beginPath();RG.SetShadow(this, prop['chart.shadow.inner.color'], prop['chart.shadow.inner.offsetx'], prop['chart.shadow.inner.offsety'], prop['chart.shadow.inner.blur']);co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0, RG.TWOPI, 0);co.fill();co.stroke();RG.NoShadow(this);\n    }\n    var greengrad = prop['chart.green.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - 2.5, -1 * RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0 - RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var yellowgrad = prop['chart.yellow.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var redgrad = prop['chart.red.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = redgrad;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();if (prop['chart.border']) {\n      var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius + 20);grad.addColorStop(0, prop['chart.border.color1']);grad.addColorStop(0.5, prop['chart.border.color2']);grad.addColorStop(1, prop['chart.border.color3']);co.beginPath();co.fillStyle = grad;co.strokeStyle = 'rgba(0,0,0,0)';\n      co.lineWidth = 0.001;co.arc(this.centerx, this.centery, this.radius + 20, 0, RG.TWOPI, 0);co.arc(this.centerx, this.centery, this.radius - 2, RG.TWOPI, 0, 1);co.fill();\n    }\n    co.lineWidth = prop['chart.linewidth'];if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (!prop['chart.tickmarks.highlighted']) {\n      for (var i = 18; i <= 360; i += 36) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];co.lineWidth = 2;co.arc(this.centerx, this.centery, this.radius - 1, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.arc(this.centerx, this.centery, this.radius - 7, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.stroke();\n      }\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color) {\n    var length = arguments[2] ? arguments[2] : this.radius - prop['chart.label.area'];co.fillStyle = '#999';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, 0, RG.TWOPI, false);co.fill();co.closePath();co.fill();co.fillStyle = color;\n    co.strokeStyle = '#666';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 8, 0, RG.TWOPI, false);co.fill();co.closePath();co.stroke();co.fill();if (prop['chart.needle.type'] == 'pointer') {\n      co.strokeStyle = color;co.lineWidth = prop['chart.needle.width'];co.lineCap = 'round';co.lineJoin = 'round';co.beginPath();co.beginPath();co.moveTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, 20, (value / this.range * 360 + 90) / (180 / RG.PI), (value / this.range * 360 + 90 + 0.01) / (180 / RG.PI), false);\n      }\n      co.arc(this.centerx, this.centery, length - 10, (value / this.range * 360 - 90) / (180 / RG.PI), (value / this.range * 360 - 90 + 0.1) / (180 / RG.PI), false);co.closePath();\n    } else if (prop['chart.needle.type'] == 'triangle') {\n      co.lineWidth = 0.01;co.lineEnd = 'square';co.lineJoin = 'miter';co.beginPath();co.fillStyle = prop['chart.needle.triangle.border'];co.arc(this.centerx, this.centery, 11, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 11, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 15, 0, RG.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;co.arc(this.centerx, this.centery, 7, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 7, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 13, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.stroke();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 7, 0, RG.TWOPI, 0);co.closePath();co.fill();\n    }\n    co.stroke();co.fill();co.beginPath();co.fillStyle = color;co.arc(this.centerx, this.centery, prop['chart.needle.type'] == 'pointer' ? 7 : 12, 0.01, RG.TWOPI, false);co.fill();if (prop['chart.needle.head'] && prop['chart.needle.type'] == 'pointer') {\n      co.lineWidth = 1;co.fillStyle = color;co.lineJoin = 'miter';co.lineCap = 'butt';co.beginPath();co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90 + 0.1) / 57.3, false);co.arc(this.centerx, this.centery, length - 20, RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 80 : 85)), RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 100 : 95)), 1);co.closePath();co.fill();\n    }\n    co.beginPath();co.fillStyle = 'gray';co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 2, 0, 6.2795, false);co.closePath();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var size = prop['chart.text.size'];var font = prop['chart.text.font'];var centerx = this.centerx;var centery = this.centery;var r = this.radius - prop['chart.label.area'] / 2;var start = this.min;var end = this.max;var decimals = prop['chart.scale.decimals'];var labels = prop['chart.labels'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];co.beginPath();co.fillStyle = prop['chart.text.color'];if (labels) {\n      for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + Math.cos(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'y': centery + Math.sin(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'text': String(labels[i]), 'valign': 'center', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (1 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 36, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (2 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 72, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.949 * r, 'y': centery + 0.31 * r, 'text': RG.number_format(this, ((end - start) * (3 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 108, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (4 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 144, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery + r, 'text': RG.number_format(this, ((end - start) * (5 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 180, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (6 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 216, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.949 * r, 'y': centery + 0.300 * r, 'text': RG.number_format(this, ((end - start) * (7 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 252, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (8 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 288, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (9 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 324, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery - r, 'text': prop['chart.zerostart'] ? RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post) : RG.number_format(this, ((end - start) * (10 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n    }\n    co.fill();if (prop['chart.value.text']) {\n      co.strokeStyle = 'black';RG.Text2(this, { 'font': font, 'size': size + 2, 'x': centerx, 'y': centery + size + 15, 'text': String(prop['chart.value.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.units.post']), 'halign': 'center', 'valign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);\n    var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (mouseXY[0] >= this.centerx && mouseXY[1] <= this.centery) {\n      angle -= RG.TWOPI;\n    }\n    var value = angle / RG.TWOPI * (this.max - this.min) + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(ca);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.TWOPI;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var current = obj.currentValue || 0;var origValue = Number(obj.currentValue);var newValue = obj.value;var diff = newValue - origValue;var step = diff / frames;var callback = arguments[1] || function () {};function iterator() {\n      obj.value = origValue + frame * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.odo.js\n// module id = 197\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.odo.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Pie = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.total = 0;this.subTotal = 0;this.angles = [];this.data = data;this.properties = [];this.type = 'pie';this.isRGraph = true;this.coords = [];this.coords.key = [];this.coordsSticks = [];this.coordsText = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.exploding = null;for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  this.properties = { 'chart.centerx.adjust': 0, 'chart.centery.adjust': 0, 'chart.colors': ['red', '#ccc', '#cfc', 'blue', 'pink', 'yellow', 'black', 'orange', 'cyan', 'purple', '#78CAEA', '#E284E9', 'white', 'blue', '#9E7BF6'], 'chart.strokestyle': 'white', 'chart.linewidth': 3, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.sticks': false, 'chart.labels.sticks.length': 7, 'chart.labels.sticks.colors': null, 'chart.labels.sticks.usecolors': true, 'chart.labels.sticks.linewidth': 1, 'chart.labels.sticks.hlength': 5, 'chart.labels.sticks.list': false, 'chart.labels.ingraph': null, 'chart.labels.ingraph.color': null, 'chart.labels.ingraph.font': null, 'chart.labels.ingraph.size': null, 'chart.labels.ingraph.bounding': true, 'chart.labels.ingraph.bounding.fill': 'white', 'chart.labels.ingraph.specific': null, 'chart.labels.ingraph.units.pre': '', 'chart.labels.ingraph.units.post': '', 'chart.labels.ingraph.radius': null, 'chart.labels.center': null, 'chart.labels.center.size': 26, 'chart.labels.center.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.center.color': 'black', 'chart.labels.center.italic': false, 'chart.labels.center.bold': false, 'chart.labels.center.units.pre': '', 'chart.labels.center.units.post': '', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': 0.5, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.style': '2d', 'chart.highlight.style.twod.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.style.twod.stroke': 'rgba(255,255,255,0.7)', 'chart.highlight.style.outline.width': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.border': false, 'chart.border.color': 'rgba(255,255,255,0.5)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.variant': 'pie', 'chart.variant.donut.width': null, 'chart.variant.threed.depth': 20, 'chart.exploded': [], 'chart.effect.roundrobin.multiplier': 1, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.centerpin': null, 'chart.centerpin.fill': 'gray', 'chart.centerpin.stroke': 'white', 'chart.origin': 0 - Math.PI / 2, 'chart.events': true, 'chart.labels.colors': [], 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, len = data.length; i < len; i++) {\n    this.total += data[i];this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    if (name == 'chart.labels.spaced') {\n      name = 'chart.labels.sticks.list';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = this.getRadius();this.centerx = this.graph.width / 2 + this.gutterLeft + prop['chart.centerx.adjust'];this.centery = this.graph.height / 2 + this.gutterTop + prop['chart.centery.adjust'];this.subTotal = this.properties['chart.origin'];this.angles = [];this.coordsText = [];if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (this.radius <= 0) {\n      return;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.labels.colors'][prop['chart.labels.colors'].length - 1]);\n      }\n    } else {\n      if (typeof prop['chart.labels.colors'] === 'undefined') {\n        prop['chart.labels.colors'] = [];\n      }\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.text.color']);\n      }\n    }\n    if (prop['chart.variant'].indexOf('3d') > 0) {\n      return this.draw3d();\n    }\n    RG.DrawTitle(this, prop['chart.title'], ca.height / 2 - this.radius - 5, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.total = RG.array_sum(this.data);var tot = this.total;var data = this.data;for (var i = 0, len = this.data.length; i < len; i++) {\n      var angle = data[i] / tot * RG.TWOPI;this.DrawSegment(angle, prop['chart.colors'][i], i == len - 1, i);\n    }\n    RG.NoShadow(this);if (prop['chart.linewidth'] > 0) {\n      this.DrawBorders();\n    }\n    var len = this.angles.length;var r = this.radius;for (var action = 0; action < 2; action += 1) {\n      for (var i = 0; i < len; i++) {\n        co.beginPath();var segment = this.angles[i];if (action === 1) {\n          co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' ? prop['chart.strokestyle'][i] : prop['chart.strokestyle'];\n        }\n        prop['chart.colors'][i] ? co.fillStyle = prop['chart.colors'][i] : null;co.lineJoin = 'round';co.arc(segment[2], segment[3], r, segment[0], segment[1], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(segment[2], segment[3], typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, segment[1], segment[0], true);\n        } else {\n          co.lineTo(segment[2], segment[3]);\n        }\n        co.closePath();action === 0 ? co.fill() : co.stroke();\n      }\n    }\n    if (prop['chart.labels.sticks']) {\n      this.DrawSticks();var strokeStyle = prop['chart.strokestyle'];\n    }\n    if (prop['chart.labels']) {\n      this.DrawLabels();\n    }\n    if (prop['chart.centerpin']) {\n      this.DrawCenterpin();\n    }\n    if (prop['chart.labels.ingraph']) {\n      this.DrawInGraphLabels();\n    }\n    if (!RG.isNull(prop['chart.labels.center'])) {\n      this.drawCenterLabel(prop['chart.labels.center']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.border']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = prop['chart.border.color'];co.arc(this.centerx, this.centery, this.radius - 2, 0, RG.TWOPI, 0);co.stroke();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    RG.NoShadow(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.events'] == true) {\n      RG.InstallEventListeners(this);\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawSegment = this.DrawSegment = function (radians, color, last, index) {\n    if (RGraph.ISOLD && radians == RG.TWOPI) {\n      radians -= 0.0001;\n    } else if (RGraph.ISOLD && radians == 0) {\n      radians = 0.001;\n    }\n    var subTotal = this.subTotal;radians = radians * prop['chart.effect.roundrobin.multiplier'];co.beginPath();color ? co.fillStyle = color : null;co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = 0;if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    if (_typeof(prop['chart.exploded']) == 'object' && prop['chart.exploded'][index] > 0 || typeof prop['chart.exploded'] == 'number') {\n      var explosion = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][index];var x = 0;var y = 0;var h = explosion;var t = subTotal + radians / 2;var x = Math.cos(t) * explosion;var y = Math.sin(t) * explosion;var r = this.radius;co.moveTo(this.centerx + x, this.centery + y);\n    } else {\n      var x = 0;var y = 0;var r = this.radius;\n    }\n    var startAngle = subTotal;var endAngle = subTotal + radians;co.arc(this.centerx + x, this.centery + y, r, startAngle, endAngle, 0);if (prop['chart.variant'] == 'donut') {\n      co.arc(this.centerx + x, this.centery + y, typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, endAngle, startAngle, true);\n    } else {\n      co.lineTo(this.centerx + x, this.centery + y);\n    }\n    co.closePath();this.angles.push([subTotal, subTotal + radians, this.centerx + x, this.centery + y]);co.fill();this.subTotal += radians;\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'].length && prop['chart.labels.sticks.list']) {\n      return this.drawLabelsList();\n    }\n    var hAlignment = 'left',\n        vAlignment = 'center',\n        labels = prop['chart.labels'],\n        context = co,\n        font = prop['chart.text.font'],\n        bold = prop['chart.labels.bold'],\n        text_size = prop['chart.text.size'],\n        cx = this.centerx,\n        cy = this.centery,\n        r = this.radius;RG.noShadow(this);co.fillStyle = 'black';co.beginPath();if (labels && labels.length) {\n      for (i = 0; i < this.angles.length; ++i) {\n        var segment = this.angles[i];if (typeof labels[i] != 'string' && typeof labels[i] != 'number') {\n          continue;\n        }\n        co.moveTo(cx, cy);var a = segment[0] + (segment[1] - segment[0]) / 2,\n            angle = (segment[1] - segment[0]) / 2 + segment[0];if (_typeof(prop['chart.exploded']) === 'object' && prop['chart.exploded'][i] || typeof prop['chart.exploded'] == 'number') {\n          var t = (segment[1] - segment[0]) / 2,\n              seperation = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i];var explosion_offsetx = Math.cos(angle) * seperation,\n              explosion_offsety = Math.sin(angle) * seperation;\n        } else {\n          var explosion_offsetx = 0,\n              explosion_offsety = 0;\n        }\n        if (prop['chart.labels.sticks']) {\n          explosion_offsetx += ma.cos(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);explosion_offsety += ma.sin(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);\n        }\n        var x = cx + explosion_offsetx + (r + 10) * Math.cos(a) + (prop['chart.labels.sticks'] ? a < RG.HALFPI || a > RG.TWOPI + RG.HALFPI ? 2 : -2 : 0),\n            y = cy + explosion_offsety + (r + 10) * Math.sin(a);if (this.coordsSticks && this.coordsSticks[i]) {\n          var x = this.coordsSticks[i][4][0] + (x < cx ? -5 : 5),\n              y = this.coordsSticks[i][4][1];\n        }\n        vAlignment = 'center';hAlignment = x < cx ? 'right' : 'left';co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels.colors']) === 'object' && prop['chart.labels.colors'] && prop['chart.labels.colors'][i]) {\n          co.fillStyle = prop['chart.labels.colors'][i];\n        }\n        RG.text2(this, { font: font, size: text_size, x: x, y: y, text: labels[i], valign: vAlignment, halign: hAlignment, tag: 'labels', bold: bold, color: prop['chart.labels.sticks.usecolors'] ? prop['chart.colors'][i] : 'black' });\n      }\n      co.fill();\n    }\n  };this.drawLabelsList = function () {\n    var segment = this.angles[i],\n        labels = prop['chart.labels'],\n        labels_right = [],\n        labels_left = [],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        text_color = prop['chart.text.color'],\n        left = [],\n        right = [],\n        centerx = this.centerx,\n        centery = this.centery,\n        radius = this.radius,\n        offset = 50;\n    for (var i = 0; i < this.angles.length; ++i) {\n      var angle = this.angles[i][0] + (this.angles[i][1] - this.angles[i][0]) / 2,\n          endpoint_inner = RG.getRadiusEndPoint(centerx, centery, angle, radius + 5),\n          endpoint_outer = RG.getRadiusEndPoint(centerx, centery, angle, radius + 10),\n          explosion = [typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i], ma.cos(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i]), ma.sin(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i])];\n      if (_typeof(prop['chart.labels.sticks.colors']) === 'object' && prop['chart.labels.sticks.colors'] && prop['chart.labels.sticks.colors'][i]) {\n        var color = prop['chart.labels.sticks.colors'][i];\n      } else if (prop['chart.labels.sticks.usecolors'] && prop['chart.colors'][i]) {\n        var color = prop['chart.colors'][i];\n      } else {\n        var color = prop['chart.text.color'];\n      }\n      if (angle > -1 * RG.HALFPI && angle < RG.HALFPI) {\n        labels_right.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      } else {\n        labels_left.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      }\n    }\n    var vspace_right = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_right.length;\n    for (var i = 0, y = prop['chart.gutter.top'] + vspace_right / 2; i < labels_right.length; y += vspace_right, i++) {\n      if (labels_right[i][2]) {\n        var x = this.centerx + this.radius + offset,\n            idx = labels_right[i][0],\n            explosionX = labels_right[i][6][0] ? labels_right[i][6][1] : 0,\n            explosionY = labels_right[i][6][0] ? labels_right[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_right[i][2], valign: 'center', halign: 'left', tag: 'labels', color: labels_right[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_right[i][0];\n        }\n        pa2(co, 'lc round lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_right[i][3][0] + explosionX, labels_right[i][3][1] + explosionY, labels_right[i][4][0] + explosionX, labels_right[i][4][1] + explosionY, this.centerx + this.radius + 25 + explosionX, ma.round(labels_right[i][4][1] + explosionY), ret.x - 5, ret.y + ret.height / 2, labels_right[i][5]);\n      }\n    }\n    var vspace_left = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_left.length;\n    for (var i = labels_left.length - 1, y = prop['chart.gutter.top'] + vspace_left / 2; i >= 0; y += vspace_left, i--) {\n      if (labels_left[i][2]) {\n        var x = this.centerx - this.radius - offset,\n            idx = labels_left[i][0],\n            explosionX = labels_left[i][6][0] ? labels_left[i][6][1] : 0,\n            explosionY = labels_left[i][6][0] ? labels_left[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_left[i][2], valign: 'center', halign: 'right', tag: 'labels', color: labels_left[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_left[i][0];\n        }\n        pa2(co, 'lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_left[i][3][0] + explosionX, labels_left[i][3][1] + explosionY, labels_left[i][4][0] + explosionX, labels_left[i][4][1] + explosionY, this.centerx - this.radius - 25 + explosionX, ma.round(labels_left[i][4][1] + explosionY), ret.x + 5 + ret.width, ret.y + ret.height / 2, labels_left[i][5]);\n      }\n    }\n  };this.drawSticks = this.DrawSticks = function () {\n    var offset = prop['chart.linewidth'] / 2,\n        exploded = prop['chart.exploded'],\n        sticks = prop['chart.labels.sticks'],\n        colors = prop['chart.colors'],\n        cx = this.centerx,\n        cy = this.centery,\n        radius = this.radius,\n        points = [],\n        linewidth = prop['chart.labels.sticks.linewidth'];\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      var segment = this.angles[i];if ((typeof sticks === 'undefined' ? 'undefined' : _typeof(sticks)) === 'object' && !sticks[i]) {\n        continue;\n      }\n      var radians = segment[1] - segment[0];co.beginPath();co.strokeStyle = typeof prop['chart.labels.sticks.colors'] === 'string' ? prop['chart.labels.sticks.colors'] : !RG.isNull(prop['chart.labels.sticks.colors']) ? prop['chart.labels.sticks.colors'][i] : 'gray';co.lineWidth = linewidth;if (typeof prop['chart.labels.sticks.color'] === 'string') {\n        co.strokeStyle = prop['chart.labels.sticks.color'];\n      }\n      if (prop['chart.labels.sticks.usecolors']) {\n        co.strokeStyle = prop['chart.colors'][i];\n      }\n      var midpoint = segment[0] + radians / 2;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && exploded[i]) {\n        var extra = exploded[i];\n      } else if (typeof exploded === 'number') {\n        var extra = exploded;\n      } else {\n        var extra = 0;\n      }\n      var stickLength = _typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length'];points[0] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + extra + offset);points[1] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra - 5);points[2] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3][0] += points[3][0] > cx ? 5 : -5;points[4] = [points[2][0] + (points[2][0] > cx ? 5 + prop['chart.labels.sticks.hlength'] : -5 - prop['chart.labels.sticks.hlength']), points[2][1]];co.moveTo(points[0][0], points[0][1]);co.quadraticCurveTo(points[2][0], points[2][1], points[4][0], points[4][1]);co.stroke();this.coordsSticks[i] = [points[0], points[1], points[2], points[3], points[4]];\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.FixEventObject(e);var accuracy = arguments[1] ? arguments[1] : 0;var canvas = ca;var context = co;var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var r = this.radius;var angles = this.angles;var ret = [];for (var i = 0, len = angles.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.arc(angles[i][2], angles[i][3], this.radius, angles[i][0], angles[i][1], false);if (this.type == 'pie' && prop['chart.variant'] == 'donut') {\n        co.arc(angles[i][2], angles[i][3], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2, angles[i][1], angles[i][0], true);\n      } else {\n        co.lineTo(angles[i][2], angles[i][3]);\n      }\n      co.closePath();if (!co.isPointInPath(mouseX, mouseY)) {\n        continue;\n      }\n      ret[0] = angles[i][2];ret[1] = angles[i][3];ret[2] = this.radius;ret[3] = angles[i][0] - RG.TWOPI;ret[4] = angles[i][1];ret[5] = i;if (ret[3] < 0) ret[3] += RG.TWOPI;if (ret[4] > RG.TWOPI) ret[4] -= RG.TWOPI;var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], ret[5]) : null;ret['object'] = this;ret['x'] = ret[0];ret['y'] = ret[1];ret['radius'] = ret[2];ret['angle.start'] = ret[3];ret['angle.end'] = ret[4];ret['index'] = ret[5];ret['tooltip'] = tooltip;return ret;\n    }\n    return null;\n  };this.drawBorders = this.DrawBorders = function () {\n    if (prop['chart.linewidth'] > 0) {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];var r = this.radius;for (var i = 0, len = this.angles.length; i < len; ++i) {\n        var segment = this.angles[i];co.beginPath();co.arc(segment[2], segment[3], r, segment[0], segment[0] + 0.001, 0);co.arc(segment[2], segment[3], prop['chart.variant'] == 'donut' ? typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : r / 2 : r, segment[0], segment[0] + 0.0001, 0);co.closePath();co.stroke();\n      }\n    }\n  };this.getRadius = function () {\n    this.graph = { width: ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], height: ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'] };\n    if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];\n    } else {\n      this.radius = Math.min(this.graph.width, this.graph.height) / 2;\n    }\n    return this.radius;\n  };this.explodeSegment = this.Explode = function (index, size) {\n    if (typeof this.exploding === 'number' && this.exploding === index) {\n      return;\n    }\n    if (!prop['chart.exploded']) {\n      prop['chart.exploded'] = [];\n    }\n    if (typeof prop['chart.exploded'] == 'number') {\n      var original_explode = prop['chart.exploded'];var exploded = prop['chart.exploded'];prop['chart.exploded'] = [];for (var i = 0, len = this.data.length; i < len; ++i) {\n        prop['chart.exploded'][i] = exploded;\n      }\n    }\n    prop['chart.exploded'][index] = typeof original_explode == 'number' ? original_explode : 0;this.exploding = index;var delay = RG.ISIE && !RG.ISIE10 ? 25 : 16.666;for (var o = 0; o < size; ++o) {\n      setTimeout(function () {\n        prop['chart.exploded'][index] += 1;RG.Clear(ca);RG.RedrawCanvas(ca);\n      }, o * delay);\n    }\n    var obj = this;setTimeout(function () {\n      obj.exploding = null;\n    }, size * delay);\n  };this.highlight_segment = function (segment) {\n    co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];co.moveTo(segment[0], segment[1]);co.arc(segment[0], segment[1], segment[2], this.angles[segment[5]][0], this.angles[segment[5]][1], 0);co.lineTo(segment[0], segment[1]);co.closePath();co.stroke();co.fill();\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] == '3d') {\n        co.lineWidth = 1;var extent = 2;co.beginPath();RG.NoShadow(this);co.fillStyle = 'rgba(0,0,0,0)';co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'], shape['y'], shape['radius'] / 5, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.fill();co.beginPath();co.shadowColor = '#666';co.shadowBlur = 3;co.shadowOffsetX = 3;co.shadowOffsetY = 3;co.fillStyle = prop['chart.colors'][shape['index']];co.strokeStyle = prop['chart.strokestyle'];co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'] - extent, shape['y'] - extent);\n        }\n        co.closePath();co.stroke();co.fill();RG.NoShadow(this);if (prop['chart.border']) {\n          co.beginPath();co.strokeStyle = prop['chart.border.color'];co.lineWidth = 5;co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] - 2, shape['angle.start'], shape['angle.end'], false);co.stroke();\n        }\n      } else if (prop['chart.highlight.style'] === 'outline') {\n        var tooltip = RG.Registry.get('chart.tooltip'),\n            index = tooltip.__index__,\n            coords = this.angles[index],\n            color = this.get('colors')[index];\n        width = this.radius / 12.5;if (typeof prop['chart.highlight.style.outline.width'] === 'number') {\n          width = prop['chart.highlight.style.outline.width'];\n        }\n        RGraph.path2(co, 'ga 0.25 b a % % % % % false a % % % % % true c f % ga 1', coords[2], coords[3], this.radius + 2 + width, coords[0], coords[1], coords[2], coords[3], this.radius + 2, coords[1], coords[0], color);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];if (prop['chart.variant'].indexOf('donut') > -1) {\n          co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);co.arc(shape['x'], shape['y'], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.arc(shape['x'], shape['y'], shape['radius'] + 1, shape['angle.start'], shape['angle.end'], false);co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (typeof prop['chart.centerpin'] == 'number' && prop['chart.centerpin'] > 0) {\n      var cx = this.centerx;var cy = this.centery;co.beginPath();co.strokeStyle = prop['chart.centerpin.stroke'] ? prop['chart.centerpin.stroke'] : prop['chart.strokestyle'];co.fillStyle = prop['chart.centerpin.fill'] ? prop['chart.centerpin.fill'] : prop['chart.strokestyle'];co.moveTo(cx, cy);co.arc(cx, cy, prop['chart.centerpin'], 0, RG.TWOPI, false);co.stroke();co.fill();\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function () {\n    var context = co;var cx = this.centerx;var cy = this.centery;var radius = prop['chart.labels.ingraph.radius'];if (radius <= 2 && radius > 0) {\n      radiusFactor = radius;\n    } else {\n      radiusFactor = 0.5;\n    }\n    if (prop['chart.variant'] == 'donut') {\n      var r = this.radius * (0.5 + radiusFactor * 0.5);if (typeof prop['chart.variant.donut.width'] == 'number') {\n        var r = this.radius - prop['chart.variant.donut.width'] + prop['chart.variant.donut.width'] / 2;\n      }\n    } else {\n      var r = this.radius * radiusFactor;\n    }\n    if (radius > 2) {\n      r = radius;\n    }\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      if (_typeof(prop['chart.exploded']) == 'object' && typeof prop['chart.exploded'][i] == 'number') {\n        var explosion = prop['chart.exploded'][i];\n      } else if (typeof prop['chart.exploded'] == 'number') {\n        var explosion = parseInt(prop['chart.exploded']);\n      } else {\n        var explosion = 0;\n      }\n      var angleStart = this.angles[i][0];var angleEnd = this.angles[i][1];var angleCenter = (angleEnd - angleStart) / 2 + angleStart;var coords = RG.getRadiusEndPoint(this.centerx, this.centery, angleCenter, r + (explosion ? explosion : 0));var x = coords[0];var y = coords[1];var text = prop['chart.labels.ingraph.specific'] && typeof prop['chart.labels.ingraph.specific'][i] == 'string' ? prop['chart.labels.ingraph.specific'][i] : RG.number_format(this, this.data[i], prop['chart.labels.ingraph.units.pre'], prop['chart.labels.ingraph.units.post']);if (text) {\n        co.beginPath();var font = typeof prop['chart.labels.ingraph.font'] === 'string' ? prop['chart.labels.ingraph.font'] : prop['chart.text.font'];var size = typeof prop['chart.labels.ingraph.size'] === 'number' ? prop['chart.labels.ingraph.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.labels.ingraph.color'] ? prop['chart.labels.ingraph.color'] : 'black';RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': text, 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.labels.ingraph.bounding'], 'bounding.fill': prop['chart.labels.ingraph.bounding.fill'], 'tag': 'labels.ingraph' });co.stroke();\n      }\n    }\n  };this.drawCenterLabel = function (label) {\n    var font = prop['chart.labels.center.font'],\n        size = prop['chart.labels.center.size'],\n        color = prop['chart.labels.center.color'],\n        unitsPre = prop['chart.labels.center.units.pre'],\n        unitsPost = prop['chart.labels.center.units.post'],\n        bold = prop['chart.labels.center.bold'],\n        italic = prop['chart.labels.center.italic'];RG.text2(this, { color: color, bold: bold, italic: italic, font: font, size: size, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', text: RG.numberFormat(this, label, unitsPre, unitsPost) });\n  };\n  this.getAngle = function (value) {\n    if (value > this.total) {\n      return null;\n    }\n    var angle = value / this.total * RG.TWOPI;angle += prop['chart.origin'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.arrayClone(prop['chart.key.colors']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.style.twod.fill'] = RG.arrayClone(prop['chart.highlight.style.twod.fill']);this.original_colors['chart.highlight.style.twod.stroke'] = RG.arrayClone(prop['chart.highlight.style.twod.stroke']);this.original_colors['chart.ingraph.bounding.fill'] = RG.arrayClone(prop['chart.ingraph.bounding.fill']);this.original_colors['chart.ingraph.color'] = RG.arrayClone(prop['chart.ingraph.color']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.style.twod.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.fill']);prop['chart.highlight.style.twod.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.stroke']);prop['chart.labels.ingraph.bounding.fill'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.bounding.fill']);prop['chart.labels.ingraph.color'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.variant'] == 'donut') {\n        var radius_start = typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2;\n      } else {\n        var radius_start = 0;\n      }\n      var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, Math.min(ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / 2);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.angles && this.angles[index]) {\n      var segment = this.angles[index];var x = segment[2];var y = segment[3];var start = segment[0];var end = segment[1];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.lineWidth = 2;co.lineJoin = 'bevel';co.beginPath();co.moveTo(x, y);co.arc(x, y, this.radius, start, end, false);co.closePath();co.fill();co.stroke();\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.draw3d = function () {\n    var scaleX = 1.5,\n        depth = prop['chart.variant.threed.depth'],\n        prop_shadow = prop['chart.shadow'],\n        prop_labels = prop['chart.labels'],\n        prop_labelsSticks = prop['chart.labels.sticks'];\n    this.set({ labels: [], labelsSticks: false, strokestyle: 'rgba(0,0,0,0)' });this.set({ variant: this.get('variant').replace(/3d/, '') });this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);for (var i = depth; i > 0; i -= 1) {\n      this.set({ centeryAdjust: i });if (i === parseInt(depth / 2)) {\n        this.set({ labels: prop_labels, labelsSticks: prop_labelsSticks });\n      }\n      if (i === 0) {\n        this.set({ shadow: prop_shadow });\n      }\n      this.draw();this.set('shadow', false);if (i <= parseInt(depth / 2)) {\n        this.set({ labels: [], labelsSticks: false });\n      }\n      if (i > 1) {\n        if (prop['chart.variant'].indexOf('donut') !== -1) {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'a', this.angles[j][2], this.angles[j][3], this.radius / 2, this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], this.angles[j][0], true, 'f', 'rgba(0,0,0,0.15)']);\n          }\n        } else {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'm', this.angles[j][2], this.angles[j][3], 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'c', 'f', 'rgba(0,0,0,0.15)']);\n          }\n        }\n      }\n    }\n    this.set({ variant: this.get('variant') + '3d', shadow: prop_shadow, labels: prop_labels, labelsSticks: prop_labelsSticks });return this;\n  };this.explode = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var maxExplode = Number(typeof opt.radius === 'number' ? opt.radius : ma.max(ca.width, ca.height));var currentExplode = Number(obj.get('exploded')) || 0;var step = (maxExplode - currentExplode) / frames;var iterator = function iterator() {\n      obj.set('exploded', currentExplode + step * frame);RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var radius = obj.getRadius();prop['chart.radius'] = 0;var iterator = function iterator() {\n      obj.set('chart.radius', frame / frames * radius);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frame = 0,\n        frames = opt.frames || 30,\n        radius = obj.getRadius(),\n        labels = obj.get('labels');\n    obj.Set('chart.events', false);obj.Set('chart.labels', []);var iterator = function iterator() {\n      obj.set('effect.roundrobin.multiplier', RG.Effects.getEasingMultiplier(frames, frame));RGraph.redrawCanvas(ca);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        obj.set({ events: true, labels: labels });RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);this.implode = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frames = opt.frames || 30,\n        frame = 0,\n        explodedMax = ma.max(ca.width, ca.height),\n        exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.pie.js\n// module id = 198\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.pie.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Radar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;if (typeof conf.data[0] === 'number' || typeof conf.data[0] === 'string') {\n      conf.data = [conf.data];\n    }\n  } else {\n    var conf = { id: conf, data: [] };if (_typeof(arguments[1]) === 'object' && typeof arguments[1][0] === 'number') {\n      for (var i = 1; i < arguments.length; ++i) {\n        conf.data.push(RGraph.arrayClone(arguments[i]));\n      }\n    } else if (_typeof(arguments[1]) === 'object' && _typeof(arguments[1][0]) === 'object' && typeof arguments[1][0][0] === 'number') {\n      conf.data = RGraph.arrayClone(arguments[1]);\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(conf.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'radar';this.isRGraph = true;this.data = [];this.max = 0;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coordsText = [];this.original_data = [];this.original_colors = [];this.firstDraw = true;for (var i = 0, len = conf.data.length; i < len; ++i) {\n    for (var j = 0; j < conf.data[i].length; ++j) {\n      if (typeof conf.data[i][j] === 'string') {\n        conf.data[i][j] = parseFloat(conf.data[i][j]);\n      }\n    }\n    this.original_data.push(RGraph.arrayClone(conf.data[i]));this.data.push(RGraph.arrayClone(conf.data[i]));this.max = Math.max(this.max, RGraph.arrayMax(conf.data[i]));\n  }\n  this.properties = (_properties = { 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.linewidth': 1, 'chart.colors': ['rgba(255,255,0,0.25)', 'rgba(0,255,255,0.25)', 'rgba(255,0,0,0.5)', 'red', 'green', 'blue', 'pink', 'aqua', 'brown', 'orange', 'grey'], 'chart.colors.alpha': null, 'chart.circle': 0, 'chart.circle.fill': 'red', 'chart.circle.stroke': 'black', 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.offset': 10, 'chart.labels.axes': '', 'chart.labels.background.fill': 'white', 'chart.labels.boxed': false, 'chart.labels.axes.bold': [], 'chart.labels.axes.boxed': null, 'chart.labels.axes.boxed.zero': true, 'chart.labels.axes.boxed.background': 'rgba(255,255,255,0.9)', 'chart.labels.specific': [], 'chart.labels.count': 5, 'chart.background.circles': true, 'chart.background.circles.count': null, 'chart.background.circles.color': '#ddd', 'chart.background.circles.poly': true, 'chart.background.circles.spokes': 24, 'chart.text.size': 12, 'chart.text.size.scale': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null }, _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.linewidth', 1), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'rgba(255,0,0,0.3)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.highlight.stroke', 'gray'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.highlight.point.radius', 2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.ymax', null), _defineProperty(_properties, 'chart.accumulative', false), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.numxticks', 5), _defineProperty(_properties, 'chart.numyticks', 5), _defineProperty(_properties, 'chart.axes.color', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlights', false), _defineProperty(_properties, 'chart.highlights.stroke', '#ddd'), _defineProperty(_properties, 'chart.highlights.fill', null), _defineProperty(_properties, 'chart.highlights.radius', 3), _defineProperty(_properties, 'chart.fill.click', null), _defineProperty(_properties, 'chart.fill.mousemove', null), _defineProperty(_properties, 'chart.fill.tooltips', null), _defineProperty(_properties, 'chart.fill.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.fill.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.fill.mousemove.redraw', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    if (this.data[dataset].length < 3) {\n      alert('[RADAR] You must specify at least 3 data points');return;\n    }\n  }\n  var idx = 0;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    for (var i = 0, len = this.data[dataset].length; i < len; ++i) {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    if (name == 'chart.color') {\n      this.properties['chart.colors'] = [value];\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coords = [];this.coords2 = [];this.coordsText = [];this.data = RG.arrayClone(this.original_data);if (prop['chart.accumulative']) {\n      for (var i = 0; i < this.data.length; ++i) {\n        if (this.data[i].length != this.data[0].length) {\n          alert('[RADAR] Error! When the radar has chart.accumulative set to true all the datasets must have the same number of elements');\n        }\n      }\n    }\n    if (RG.isNull(prop['chart.labels.axes.boxed'])) {\n      prop['chart.labels.axes.boxed'] = [];for (var i = 0; i < (prop['chart.labels.specific'].length || prop['chart.labels.count'] || 5); ++i) {\n        prop['chart.labels.axes.boxed'][i] = false;\n      }\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;if (typeof prop['chart.centerx'] == 'number') this.centerx = 2 * prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = 2 * prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (!prop['chart.ymax']) {\n      if (prop['chart.accumulative']) {\n        var accumulation = [];var len = this.original_data[0].length;\n        for (var i = 1; i < this.original_data.length; ++i) {\n          if (this.original_data[i].length != len) {\n            alert('[RADAR] Error! Stacked Radar chart datasets must all be the same size!');\n          }\n          for (var j = 0; j < this.original_data[i].length; ++j) {\n            this.data[i][j] += this.data[i - 1][j];this.max = Math.max(this.max, this.data[i][j]);\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, 'min': 0, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'min': 0, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    this.drawBackground();this.drawAxes();this.drawCircle();this.drawLabels();co.save();co.beginPath();co.arc(this.centerx, this.centery, this.radius * 2, -RG.HALFPI, RG.TWOPI * prop['chart.animation.trace.clip'] - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.clip();this.DrawChart();this.DrawHighlights();co.restore();this.drawAxisLabels();if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.diameter'] ? prop['chart.title.diameter'] : null);\n    }\n    if (prop['chart.key']) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if ((prop['chart.fill.click'] || prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) && !this.__fill_click_listeners_installed__) {\n      this.AddFillListeners();this.__fill_click_listeners_installed__ = true;\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    var color = prop['chart.background.circles.color'];var poly = prop['chart.background.circles.poly'];var spacing = prop['chart.background.circles.spacing'];var spokes = prop['chart.background.circles.spokes'];co.lineWidth = 1;if (prop['chart.background.circles'] && poly == false) {\n      co.strokeStyle = color;co.beginPath();var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.strokeStyle = color;for (var i = 0; i < 360; i += 360 / spokes) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI, (i + 0.001) / 360 * RG.TWOPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n    } else if (prop['chart.background.circles'] && poly == true) {\n      co.strokeStyle = color;var increment = 360 / this.data[0].length;\n      for (var i = 0; i < 360; i += increment) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI - RG.HALFPI, (i + 0.001) / 360 * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n      co.strokeStyle = color;var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.beginPath();for (var a = 0; a <= 360; a += 360 / this.data[0].length) {\n          co.arc(this.centerx, this.centery, r, RG.degrees2Radians(a) - RG.HALFPI, RG.degrees2Radians(a) + 0.001 - RG.HALFPI, false);\n        }\n        co.closePath();co.stroke();\n      }\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.strokeStyle = prop['chart.axes.color'];var halfsize = this.radius;co.beginPath();co.moveTo(Math.round(this.centerx), this.centery + this.radius);co.lineTo(Math.round(this.centerx), this.centery - this.radius);co.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));co.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));for (var y = this.centery - this.radius; y < this.centery + this.radius; y += this.radius / prop['chart.numyticks']) {\n      co.moveTo(this.centerx - 3, Math.round(y));co.lineTo(this.centerx + 3, Math.round(y));\n    }\n    co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));co.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);co.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);for (var x = this.centerx - this.radius; x < this.centerx + this.radius; x += this.radius / prop['chart.numxticks']) {\n      co.moveTo(Math.round(x), this.centery - 3);co.lineTo(Math.round(x), this.centery + 3);\n    }\n    co.stroke();\n  };this.drawChart = this.DrawChart = function () {\n    var alpha = prop['chart.colors.alpha'];if (typeof alpha == 'number') {\n      var oldAlpha = co.globalAlpha;co.globalAlpha = alpha;\n    }\n    var numDatasets = this.data.length;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n      co.beginPath();var coords_dataset = [];for (var i = 0; i < this.data[dataset].length; ++i) {\n        var coords = this.GetCoordinates(dataset, i);if (coords_dataset == null) {\n          coords_dataset = [];\n        }\n        coords_dataset.push(coords);this.coords.push(coords);\n      }\n      this.coords2[dataset] = coords_dataset;co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][dataset] ? prop['chart.colors'][dataset] : 'rgba(0,0,0,0)';if (co.fillStyle === 'transparent') {\n        co.fillStyle = 'rgba(0,0,0,0)';\n      }\n      co.lineWidth = prop['chart.linewidth'];for (i = 0; i < coords_dataset.length; ++i) {\n        if (i == 0) {\n          co.moveTo(coords_dataset[i][0], coords_dataset[i][1]);\n        } else {\n          co.lineTo(coords_dataset[i][0], coords_dataset[i][1]);\n        }\n      }\n      if (prop['chart.accumulative'] && dataset > 0) {\n        co.lineTo(coords_dataset[0][0], coords_dataset[0][1]);co.moveTo(last_coords[0][0], last_coords[0][1]);for (var i = coords_dataset.length - 1; i >= 0; --i) {\n          co.lineTo(last_coords[i][0], last_coords[i][1]);\n        }\n      }\n      var last_coords = coords_dataset;co.closePath();co.stroke();co.fill();\n    }\n    if (typeof alpha == 'number') {\n      co.globalAlpha = oldAlpha;\n    }\n  };this.getCoordinates = this.GetCoordinates = function (dataset, index) {\n    var len = this.data[dataset].length;var mag = this.data[dataset][index] / this.max * this.radius;var angle = RG.TWOPI / len * index;angle -= RG.HALFPI;var x = Math.cos(angle) * mag;var y = Math.sin(angle) * mag;x = this.centerx + x;y = this.centery + y;return [x, y];\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];if (labels && labels.length > 0) {\n      co.lineWidth = 1;co.strokeStyle = 'gray';co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var bgFill = prop['chart.labels.background.fill'],\n          bold = prop['chart.labels.bold'],\n          bgBoxed = prop['chart.labels.boxed'],\n          offset = prop['chart.labels.offset'],\n          font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          radius = this.radius,\n          color = prop['chart.labels.color'] || prop['chart.text.color'];\n      for (var i = 0; i < labels.length; ++i) {\n        var angle = RG.TWOPI / prop['chart.labels'].length * i;angle -= RG.HALFPI;var x = this.centerx + ma.cos(angle) * (radius + offset);var y = this.centery + ma.sin(angle) * (radius + offset);var halign = x < this.centerx ? 'right' : 'left';if (i == 0 || i / labels.length == 0.5) halign = 'center';if (labels[i] && labels[i].length) {\n          RG.text2(this, { 'color': color, 'font': font, 'size': size, 'x': x, 'y': y, 'text': labels[i], 'valign': 'center', 'halign': halign, 'bounding': bgBoxed, 'boundingFill': bgFill, 'bold': bold, 'tag': 'labels' });\n        }\n      }\n    }\n  };this.drawCircle = this.DrawCircle = function () {\n    var circle = {};circle.limit = prop['chart.circle'];circle.fill = prop['chart.circle.fill'];circle.stroke = prop['chart.circle.stroke'];if (circle.limit) {\n      var r = circle.limit / this.max * this.radius;co.fillStyle = circle.fill;co.strokeStyle = circle.stroke;co.beginPath();co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();co.stroke();\n    }\n  };this.drawAxisLabels = this.DrawAxisLabels = function () {\n    if (RG.isArray(prop['chart.labels.specific']) && prop['chart.labels.specific'].length) {\n      this.drawSpecificAxisLabels();return;\n    }\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var r = this.radius,\n        font = prop['chart.text.font'],\n        size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        color = prop['chart.labels.axes.boxed.background'],\n        drawzero = false,\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        bold = prop['chart.labels.axes.bold'],\n        boxed = prop['chart.labels.axes.boxed'],\n        centerx = this.centerx,\n        centery = this.centery,\n        scale = this.scale;co.fillStyle = prop['chart.text.color'];if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery - r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery + r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (drawzero) {\n      RG.Text2(this, { font: font, size: size, x: centerx, y: centery, text: RG.numberFormat(this, Number(0).toFixed(), units_pre, units_post), valign: 'center', halign: 'center', bounding: prop['chart.labels.axes.boxed.zero'], boundingFill: color, boundingStroke: 'rgba(0,0,0,0)', bold: prop['chart.labels.axes.bold.zero'], tag: 'scale' });\n    }\n  };this.drawSpecificAxisLabels = this.DrawSpecificAxisLabels = function () {\n    var labels = prop['chart.labels.specific'];var bold = RG.array_pad(prop['chart.labels.axes.bold'], labels.length);var boxed = RG.array_pad(prop['chart.labels.axes.boxed'], labels.length);var reversed_labels = RG.array_reverse(labels);var reversed_bold = RG.array_reverse(bold);var reversed_boxed = RG.array_reverse(boxed);var font = prop['chart.text.font'];var size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n      if (axes.indexOf('n') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery - this.radius + this.radius / labels.length * i, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('s') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery + this.radius / labels.length * (i + 1), 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });if (axes.indexOf('w') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx - this.radius + this.radius / labels.length * i, 'y': this.centery, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('e') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx + this.radius / labels.length * (i + 1), 'y': this.centery, 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });\n    }\n  };this.getShape = this.getPoint = function (e) {\n    for (var i = 0; i < this.coords.length; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltips = prop['chart.tooltips'];var index = Number(i);var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX < x + 5 && mouseX > x - 5 && mouseY > y - 5 && mouseY < y + 5) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], index);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: null, 'dataset': null, 4: index, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius) {\n      return this;\n    }\n  };this.drawHighlights = this.DrawHighlights = function () {\n    if (prop['chart.highlights']) {\n      var sequentialIdx = 0;var dataset = 0;var index = 0;var radius = prop['chart.highlights.radius'];for (var dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var index = 0; index < this.data[dataset].length; ++index) {\n          co.beginPath();co.strokeStyle = prop['chart.highlights.stroke'];co.fillStyle = prop['chart.highlights.fill'] ? prop['chart.highlights.fill'] : _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.arc(this.coords[sequentialIdx][0], this.coords[sequentialIdx][1], radius, 0, RG.TWOPI, false);co.stroke();co.fill();++sequentialIdx;\n        }\n      }\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var radius = value / this.max * this.radius;return radius;\n  };this.getAngle = function (numitems, index) {\n    var angle = RG.TWOPI / numitems * index;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.circle.fill'] = RG.array_clone(prop['chart.circle.fill']);this.original_colors['chart.circle.stroke'] = RG.array_clone(prop['chart.circle.stroke']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (typeof keyColors != 'null' && keyColors && keyColors.length) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.circle.fill'] = this.parseSingleColorForGradient(prop['chart.circle.fill']);prop['chart.circle.stroke'] = this.parseSingleColorForGradient(prop['chart.circle.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.addFillListeners = this.AddFillListeners = function (e) {\n    var obj = this;var func = function func(e) {\n      var coords = this.coords;var coords2 = this.coords2;var mouseXY = RG.getMouseXY(e);var dataset = 0;if (e.type == 'mousemove' && prop['chart.fill.mousemove.redraw']) {\n        RG.RedrawCanvas(ca);\n      }\n      for (var dataset = obj.coords2.length - 1; dataset >= 0; --dataset) {\n        co.beginPath();co.moveTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);for (var j = 0; j < obj.coords2[dataset].length; ++j) {\n          co.lineTo(obj.coords2[dataset][j][0], obj.coords2[dataset][j][1]);\n        }\n        co.lineTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n          co.lineTo(obj.coords2[dataset - 1][0][0], obj.coords2[dataset - 1][0][1]);for (var j = obj.coords2[dataset - 1].length - 1; j >= 0; --j) {\n            co.lineTo(obj.coords2[dataset - 1][j][0], obj.coords2[dataset - 1][j][1]);\n          }\n        }\n        co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n          var inPath = true;break;\n        }\n      }\n      if (inPath) {\n        var fillTooltips = prop['chart.fill.tooltips'];if (e.type == 'click') {\n          if (prop['chart.fill.click']) {\n            prop['chart.fill.click'](e, dataset);\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            obj.DatasetTooltip(e, dataset);\n          }\n        }\n        if (e.type == 'mousemove') {\n          if (prop['chart.fill.mousemove']) {\n            prop['chart.fill.mousemove'](e, dataset);\n          }\n          if (!RG.is_null(fillTooltips)) {\n            e.target.style.cursor = 'pointer';\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            e.target.style.cursor = 'pointer';\n          }\n        }\n        e.stopPropagation();\n      } else if (e.type == 'mousemove') {\n        ca.style.cursor = 'default';\n      }\n    };if (prop['chart.fill.click'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('click', func, false);\n    }\n    if (prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('mousemove', func, false);\n    }\n  };this.highlightDataset = this.HighlightDataset = function (dataset) {\n    co.beginPath();for (var j = 0; j < this.coords2[dataset].length; ++j) {\n      if (j == 0) {\n        co.moveTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);\n      } else {\n        co.lineTo(this.coords2[dataset][j][0], this.coords2[dataset][j][1]);\n      }\n    }\n    co.lineTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n      co.lineTo(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]);for (var j = this.coords2[dataset - 1].length - 1; j >= 0; --j) {\n        co.lineTo(this.coords2[dataset - 1][j][0], this.coords2[dataset - 1][j][1]);\n      }\n    }\n    co.strokeStyle = prop['chart.fill.highlight.stroke'];co.fillStyle = prop['chart.fill.highlight.fill'];co.stroke();co.fill();\n  };this.datasetTooltip = this.DatasetTooltip = function (e, dataset) {\n    this.HighlightDataset(dataset);var text = prop['chart.fill.tooltips'][dataset];var x = 0;var y = this.coords2[dataset][0][1] + RG.getCanvasXY(ca)[1];RG.Tooltip(this, text, x, y, 0, e);\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (i == 0) {\n          co.moveTo(coords[i][0], coords[i][1]);\n        } else {\n          co.lineTo(coords[i][0], coords[i][1]);\n        }\n      }\n      co.closePath();co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var callback = arguments[1] ? arguments[1] : function () {};var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var data = RG.array_clone(obj.data);function iterator() {\n      for (var i = 0, len = data.length; i < len; ++i) {\n        for (var j = 0, len2 = data[i].length; j < len2; ++j) {\n          obj.original_data[i][j] = frame / frames * data[i][j];\n        }\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);var iterator = function iterator() {\n      if (frame < frames) {\n        obj.Set('animation.trace.clip', frame / frames);frame++;RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.Set('animation.trace.clip', 1);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.radar.js\n// module id = 199\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.radar.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Rose = RGraph.Effects.Rose || {};RGraph.Rose = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.data = conf.data;this.canvas.__object__ = this;this.type = 'rose';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;this.angles = [];this.angles2 = [];this.properties = { 'chart.background.axes': true, 'chart.background.axes.color': 'black', 'chart.background.grid': true, 'chart.background.grid.color': '#ccc', 'chart.background.grid.size': null, 'chart.background.grid.radials': null, 'chart.background.grid.count': 5, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.angles.start': 0, 'chart.colors': ['rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)', 'rgba(0,255,255,0.5)', 'rgb(0,255,0)', 'gray', 'blue', 'rgb(255,128,255)', 'green', 'pink', 'gray', 'aqua'], 'chart.linewidth': 1, 'chart.colors.sequential': false, 'chart.colors.alpha': null, 'chart.margin': 0, 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.position': 'center', 'chart.labels.axes': 'nsew', 'chart.labels.boxed': false, 'chart.labels.offset': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.variant': 'stacked', 'chart.variant.threed.depth': 10, 'chart.exploded': 0, 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.animation.roundrobin.factor': 1, 'chart.animation.roundrobin.radius': true, 'chart.animation.grow.multiplier': 1, 'chart.labels.count': 5, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    } else if (_typeof(this.data[i]) === 'object') {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(this.data);for (var i = 0; i < linear_data.length; ++i) {\n    this[\"$\" + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.background.grid.spokes') name = 'chart.background.grid.radials';if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.angles = [];this.angles2 = [];this.total = 0;this.startRadians = prop['chart.angles.start'];this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - this.gutterRight + 5;\n    }\n    if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.variant'].indexOf('3d') !== -1) {\n      var scaleX = 1.5;this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);\n    }\n    this.drawBackground();if (prop['chart.variant'].indexOf('3d') !== -1) {\n      RG.setShadow(this, 'rgba(0,0,0,0.35)', 0, 15, 25);for (var i = prop['chart.variant.threed.depth']; i > 0; i -= 1) {\n        this.centery -= 1;this.drawRose({ storeAngles: false });RG.setShadow(this, 'rgba(0,0,0,0)', 0, 0, 0);for (var j = 0, len = this.angles.length; j < len; j += 1) {\n          var a = this.angles[j];pa2(co, ['b', 'm', a[4], a[5], 'a', a[4], a[5], a[3] + 1.5, a[0] - 0.01, a[1] + 0.01, false, 'c', 'f', 'rgba(0,0,0,0.1)']);\n        }\n      }\n    }\n    this.drawRose();this.drawLabels();co.strokeStyle = 'rgba(0,0,0,0)';\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.adjustable']) {\n      RG.AllowAdjusting(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      if (!RG.allowSegmentHighlight) {\n        alert('[WARNING] The segment highlight function does not exist - have you included the dynamic library?');\n      }\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : this.data.length, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.lineWidth = 1;if (prop['chart.background.grid']) {\n      if (typeof prop['chart.background.grid.count'] == 'number') {\n        prop['chart.background.grid.size'] = this.radius / prop['chart.background.grid.count'];\n      }\n      co.beginPath();co.strokeStyle = prop['chart.background.grid.color'];for (var i = prop['chart.background.grid.size']; i <= this.radius; i += prop['chart.background.grid.size']) {\n        co.moveTo(this.centerx + i, this.centery);co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.beginPath();if (typeof prop['chart.background.grid.radials'] !== 'number') {\n        prop['chart.background.grid.radials'] = this.data.length;\n      }\n      var num = 360 / prop['chart.background.grid.radials'];for (var i = num; i <= 360; i += num) {\n        co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI + this.startRadians, (i + 0.0001) / (180 / RG.PI) - RG.HALFPI + this.startRadians, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    if (prop['chart.background.axes']) {\n      co.beginPath();co.strokeStyle = prop['chart.background.axes.color'];co.moveTo(this.centerx - this.radius, ma.round(this.centery));co.lineTo(this.centerx + this.radius, ma.round(this.centery));co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / 5) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3.5);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / 5) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n      co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));co.closePath();co.stroke();\n    }\n    pa2(co, 'b c');\n  };this.drawRose = this.DrawRose = function () {\n    var max = 0,\n        data = this.data,\n        margin = RG.degrees2Radians(prop['chart.margin']),\n        opt = arguments[0] || {};co.lineWidth = prop['chart.linewidth'];if (RG.isNull(prop['chart.ymax'])) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] == 'number') {\n          max = ma.max(max, data[i]);\n        } else if (_typeof(data[i]) == 'object' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n          max = ma.max(max, data[i][0]);\n        } else {\n          max = ma.max(max, RG.arraySum(data[i]));\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': max, 'min': 0, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    this.sum = RG.arraySum(data);co.moveTo(this.centerx, this.centery);co.stroke();if (prop['chart.colors.alpha']) {\n      co.globalAlpha = prop['chart.colors.alpha'];\n    }\n    var sequentialIndex = 0;if (typeof prop['chart.variant'] == 'string' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n      var total = 0;for (var i = 0; i < data.length; ++i) {\n        total += data[i][1];\n      }\n      if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = this.data[i][1] / total * RG.TWOPI;var radius = (this.data[i][0] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        }\n        co.beginPath();var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = (this.startRadians + segmentRadians) * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[i] = [startAngle, endAngle, 0, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);this.redrawRose();\n      }\n    } else {\n      var sequentialColorIndex = 0;if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = 1 / this.data.length * RG.TWOPI;if (typeof this.data[i] == 'number') {\n          co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = prop['chart.colors'][i];\n          }\n          var radius = (this.data[i] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();co.beginPath();if (endAngle == 0) {}\n          this.angles[i] = [startAngle, endAngle, 0, radius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;\n        } else if (_typeof(this.data[i]) == 'object') {\n          var margin = prop['chart.margin'] / (180 / RG.PI);if (!this.angles2[i]) {\n            this.angles2[i] = [];\n          }\n          for (var j = 0; j < this.data[i].length; ++j) {\n            var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][j];if (prop['chart.colors.sequential']) {\n              co.fillStyle = prop['chart.colors'][sequentialColorIndex++];\n            }\n            if (j == 0) {\n              co.beginPath();var startRadius = 0;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? endRadius * prop['chart.animation.roundrobin.factor'] : endRadius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            } else {\n              co.beginPath();var startRadius = endRadius;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius + startRadius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, startRadius * prop['chart.animation.roundrobin.factor'], startAngle, endAngle, 0);co.arc(this.centerx + explodedX, this.centery + explodedY, endRadius * prop['chart.animation.roundrobin.factor'], endAngle, startAngle, true);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            }\n          }\n        }\n        this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);\n      }\n      if (prop['chart.shadow']) {\n        this.redrawRose();\n      }\n    }\n    if (prop['chart.colors.alpha']) {\n      co.globalAlpha = 1;\n    }\n    if (prop['chart.title']) {\n      RG.drawTitle(this, prop['chart.title'], ca.height / 2 - this.radius, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n  };this.redrawRose = function () {\n    var angles = this.angles;for (var i = 0; i < angles.length; ++i) {\n      pa2(co, 'b a % % % % % false a % % % % % true c f % f % ', angles[i][4], angles[i][5], angles[i][2], angles[i][0], angles[i][1], angles[i][4], angles[i][5], angles[i][3], angles[i][1], angles[i][0], angles[i][6], angles[i][7]);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;var key = prop['chart.key'];if (key && key.length) {\n      RG.DrawKey(this, key, prop['chart.colors']);\n    }\n    co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';var radius = this.radius,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        decimals = prop['chart.scale.decimals'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0);if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, radius + 10);\n    }\n    if (typeof prop['chart.text.size.scale'] == 'number') {\n      size = prop['chart.text.size.scale'];\n    }\n    var color = 'rgba(255,255,255,0.8)';if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery - radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery + radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (RG.trim(axes).length > 0) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': typeof prop['chart.ymin'] === 'number' ? RG.numberFormat(this, Number(prop['chart.ymin']).toFixed(prop['chart.ymin'] === 0 ? '0' : prop['chart.scale.decimals']), units_pre, units_post) : '0', 'valign': 'center', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (co, labels, font, size, radius) {\n    var variant = prop['chart.variant'],\n        position = prop['chart.labels.position'],\n        radius = radius + 5 + prop['chart.labels.offset'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0),\n        labelsColor = prop['chart.labels.color'] || prop['chart.text.color'],\n        angles = this.angles;\n    for (var i = 0; i < this.data.length; ++i) {\n      if (typeof variant == 'string' && variant.indexOf('non-equi-angular') !== -1) {\n        var a = Number(angles[i][0]) + (angles[i][1] - angles[i][0]) / 2;\n      } else {\n        var a = RG.TWOPI / this.data.length * (i + 1) - RG.TWOPI / (this.data.length * 2);var a = a - RG.HALFPI + (prop['chart.labels.position'] == 'edge' ? RG.TWOPI / this.data.length / 2 : 0);\n      }\n      var x = centerx + ma.cos(a) * radius;var y = centery + ma.sin(a) * radius;if (x > centerx) {\n        halign = 'left';\n      } else if (Math.round(x) == centerx) {\n        halign = 'center';\n      } else {\n        halign = 'right';\n      }\n      RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'x': x, 'y': y, 'text': String(labels[i]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.fixEventObject(e);var angles = this.angles;var ret = [];var opt = arguments[1] ? arguments[1] : { radius: true };for (var i = 0; i < angles.length; ++i) {\n      var angleStart = angles[i][0];var angleEnd = angles[i][1];var radiusStart = opt.radius === false ? 0 : angles[i][2];var radiusEnd = opt.radius === false ? this.radius : angles[i][3];var centerX = angles[i][4];var centerY = angles[i][5];var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0] - centerX;var mouseY = mouseXY[1] - centerY;co.beginPath();co.arc(centerX, centerY, radiusStart ? radiusStart : 0.01, angleStart, angleEnd, false);co.arc(centerX, centerY, radiusEnd, angleEnd, angleStart, true);co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n        angles[i][6] = i;if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], angles[i][6]);\n        }\n        angles[i]['object'] = this;angles[i]['x'] = angles[i][4];angles[i]['y'] = angles[i][5];angles[i]['angle.start'] = angles[i][0];angles[i]['angle.end'] = angles[i][1];angles[i]['radius.start'] = angles[i][2];angles[i]['radius.end'] = angles[i][3];angles[i]['index'] = angles[i][6];angles[i]['tooltip'] = tooltip ? tooltip : null;return angles[i];\n      }\n    }\n    return null;\n  };this.getExploded = this.getexploded = function (index, startAngle, endAngle, exploded) {\n    var explodedx, explodedy;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) == 'object' && typeof exploded[index] == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded[index];explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded[index];\n    } else if (typeof exploded == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded;explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded;\n    } else {\n      explodedx = 0;explodedy = 0;\n    }\n    return [explodedx, explodedy];\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.arc(shape['x'], shape['y'], shape['radius.end'], shape['angle.start'], shape['angle.end'], false);if (shape['radius.start'] > 0) {\n        co.arc(shape['x'], shape['y'], shape['radius.start'], shape['angle.end'], shape['angle.start'], true);\n      } else {\n        co.lineTo(shape['x'], shape['y']);\n      }\n      co.closePath();co.stroke();co.fill();\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (prop['chart.variant'].indexOf('3d') !== -1) {\n      radius /= -1;\n    }\n    if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var r = value / this.max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var segments = this.angles2;for (var i = 0; i < this.angles2.length; i += 1) {\n      co.beginPath();co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][2], segments[i][index][0], segments[i][index][1], false);co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][3], segments[i][index][1], segments[i][index][0], true);co.closePath();co.fill();co.stroke();\n    }\n    return;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.explode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = Number(this.Get('exploded'));function iterator() {\n      exploded = frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this;var opt = arguments[0] || {};\n    var frames = opt.frames || 30;var frame = 0;var original_margin = prop['chart.margin'];var margin = 360 / this.data.length / 2;var callback = arguments[1] || function () {};this.Set('chart.margin', margin);this.Set('chart.animation.roundrobin.factor', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animation.roundrobin.factor', frame / frames);obj.set('margin', frame / frames * original_margin);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.set('animation.roundrobin.factor', 1);obj.set('margin', original_margin);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.implode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;function iterator() {\n      obj.Set('animation.grow.multiplier', frame / frames);RG.clear(ca);RG.redrawCanvas(ca);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.rose.js\n// module id = 200\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.rose.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.RScatter = RGraph.Rscatter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && typeof conf.data[0][0] === 'number') {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = arguments[1][i];\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  this.id = conf.id;\n  this.canvas = document.getElementById(this.id);\n  this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'rscatter';this.hasTooltips = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (typeof this.data[i][j][0] === 'string') {\n        this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n      }\n      if (typeof this.data[i][j][1] === 'string') {\n        this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n      }\n    }\n  }\n  this.properties = { 'chart.background.color': 'transparent', 'chart.background.grid': true, 'chart.background.grid.diagonals': true, 'chart.background.grid.diagonals.count': null, 'chart.background.grid.radials': true, 'chart.background.grid.radials.count': null, 'chart.background.grid.linewidth': 1, 'chart.background.grid.color': '#ccc', 'chart.radius': null, 'chart.colors': [], 'chart.colors.default': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.axes': 'nsew', 'chart.labels.axes.background': 'rgba(255,255,255,0.8)', 'chart.labels.count': 5, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot': 3, 'chart.tooltips.coords.page': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.ymax': null, 'chart.ymin': 0, 'chart.tickmarks': 'cross', 'chart.ticksize': 3, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.highlight.stroke': 'transparent', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.point.radius': 3, 'chart.axes.color': 'black', 'chart.axes.numticks': null, 'chart.axes.caps': true, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.line': false, 'chart.line.close': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['black'], 'chart.line.shadow': false, 'chart.line.shadow.color': 'black', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, idx = 0; i < this.data.length; ++i) {\n    for (var j = 0, len = this.data[i].length; j < len; j += 1, idx += 1) {\n      this['$' + idx] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.count') name = 'chart.segment.highlight.count';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.coords = [];this.coords2 = [];this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var max = prop['chart.ymax'];var min = prop['chart.ymin'];if (typeof max == 'number') {\n      this.max = max;this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });\n    } else {\n      for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          this.max = Math.max(this.max, this.data[i][j][1]);\n        }\n      }\n      this.min = prop['chart.ymin'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': min, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - prop['chart.gutter.right'] + 5;\n    }\n    if (_typeof(prop['chart.key']) == 'object' && RG.is_array(prop['chart.key']) && prop['chart.key'][0]) {\n      prop['chart.colors'] = [];for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          if (typeof this.data[i][j][2] == 'string') {\n            prop['chart.colors'].push(this.data[i][j][2]);\n          }\n        }\n      }\n    }\n    this.Set('chart.tooltips', []);for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        if (typeof this.data[i][j][3] == 'string') {\n          prop['chart.tooltips'].push(this.data[i][j][3]);\n        }\n      }\n    }\n    co.beginPath();this.DrawBackground();this.DrawRscatter();this.DrawLabels();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius - 10, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.background.color'] != 'transparent') {\n      pa2(co, ['b', 'a', this.centerx, this.centery, this.radius, 0, 2 * ma.PI, -1, 'f', prop['chart.background.color']]);\n    }\n    var gridEnabled = prop['chart.background.grid'];if (gridEnabled) {\n      co.lineWidth = prop['chart.background.grid.linewidth'];if (prop['chart.background.grid.radials']) {\n        co.strokeStyle = prop['chart.background.grid.color'];if (RG.isNull(prop['chart.background.grid.radials.count'])) {\n          prop['chart.background.grid.radials.count'] = prop['chart.labels.count'];\n        }\n        var r = this.radius / prop['chart.background.grid.radials.count'];for (var i = 0, len = this.radius; i <= len; i += r) {\n          co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, 0);\n        }\n        co.stroke();\n      }\n      if (prop['chart.background.grid.diagonals']) {\n        co.strokeStyle = prop['chart.background.grid.color'];co.beginPath();var inc = 360 / (prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8);for (var i = inc; i < 360; i += inc) {\n          co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI, (i + 0.01) / (180 / RG.PI) - RG.HALFPI, 0);co.lineTo(this.centerx, this.centery);\n        }\n        co.stroke();\n      }\n    }\n    co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.axes.color'];co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));if (prop['chart.axes.caps']) {\n      co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);\n    }\n    if (!RG.isNull(prop['chart.axes.numticks'])) {\n      var numticks = prop['chart.axes.numticks'];\n    } else {\n      var numticks = prop['chart.labels.count'];\n    }\n    var caps = prop['chart.axes.caps'];if (numticks) {\n      for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / numticks) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / numticks) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n    }\n    co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);if (prop['chart.axes.caps']) {\n      co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));\n    }\n    co.closePath();co.stroke();\n  };this.drawRscatter = this.DrawRscatter = function () {\n    for (var dataset = 0; dataset < this.data.length; dataset += 1) {\n      var data = this.data[dataset];this.coords2[dataset] = [];var drawPoints = function drawPoints(obj) {\n        for (var i = 0; i < data.length; ++i) {\n          var d1 = data[i][0],\n              d2 = data[i][1],\n              a = d1 / (180 / RG.PI),\n              r = (d2 - prop['chart.ymin']) / (obj.scale2.max - obj.scale2.min) * obj.radius,\n              x = ma.sin(a) * r,\n              y = ma.cos(a) * r,\n              color = data[i][2] ? data[i][2] : prop['chart.colors.default'],\n              tooltip = data[i][3] ? data[i][3] : null;\n          if (tooltip && String(tooltip).length) {\n            obj.hasTooltips = true;\n          }\n          x = x + obj.centerx;y = obj.centery - y;obj.drawTick(x, y, color);obj.coords.push([x, y, color, tooltip]);obj.coords2[dataset].push([x, y, color, tooltip]);\n        }\n      };\n      drawPoints(this);if (prop['chart.line']) {\n        this.drawLine(dataset);\n      }\n    }\n  };this.drawLine = function (idx) {\n    var opt = { dataset: idx, coords: this.coords2[idx], color: prop['chart.line.colors'][idx], shadow: prop['chart.line.shadow'], shadowColor: prop['chart.line.shadow.color'], shadowOffsetX: prop['chart.line.shadow.offsetx'], shadowOffsetY: prop['chart.line.shadow.offsety'], shadowBlur: prop['chart.line.shadow.blur'], linewidth: prop['chart.line.linewidth'] };co.beginPath();co.strokeStyle = this.parseSingleColorForGradient(opt.color);co.lineWidth = _typeof(prop['chart.line.linewidth']) === 'object' ? prop['chart.line.linewidth'][idx] : prop['chart.line.linewidth'];co.lineCap = 'round';if (opt.shadow) {\n      RG.setShadow(this, opt.shadowColor, opt.shadowOffsetX, opt.shadowOffsetY, opt.shadowBlur);\n    }\n    for (var i = 0; i < this.coords2[idx].length; ++i) {\n      if (i === 0) {\n        co.moveTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);var startCoords = RG.arrayClone(this.coords2[idx]);\n      } else {\n        co.lineTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);\n      }\n    }\n    if (typeof prop['chart.line.close'] === 'boolean' && prop['chart.line.close'] || _typeof(prop['chart.line.close']) === 'object' && prop['chart.line.close'][idx]) {\n      co.lineTo(this.coords2[idx][0][0], this.coords2[idx][0][1]);\n    }\n    co.stroke();RG.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var key = prop['chart.key'];var r = this.radius;var axesColor = prop['chart.axes.color'];var color = prop['chart.text.color'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var decimals = prop['chart.scale.decimals'];var centerx = this.centerx;var centery = this.centery;co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, r);\n    }\n    var offset = 10;var centered = false;if (axesColor === 'rgba(0,0,0,0)' || axesColor === 'rgb(0,0,0)' || axesColor === 'transparent') {\n      offset = 0;centered = true;\n    }\n    for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n      if (axes.indexOf('n') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery - r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('s') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery + r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('e') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('w') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });\n    }\n    if (prop['chart.labels.axes'].length > 0 && prop['chart.scale.zerostart']) {\n      RG.text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': RG.numberFormat(this, Number(this.scale2.min).toFixed(this.scale2.decimals), this.scale2.units_pre, this.scale2.units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': prop['chart.labels.axes.background'], 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n    if (key && key.length) {\n      RG.drawKey(this, key, prop['chart.colors']);\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (context, labels, font_face, font_size, r) {\n    var r = r + 10,\n        color = prop['chart.labels.color'];for (var i = 0; i < labels.length; ++i) {\n      var a = 360 / labels.length * (i + 1) - 360 / (labels.length * 2);var a = a - 90 + (prop['chart.labels.position'] == 'edge' ? 360 / labels.length / 2 : 0);var x = ma.cos(a / (180 / RG.PI)) * r;var y = ma.sin(a / (180 / RG.PI)) * r;RG.Text2(this, { 'color': color, 'font': font_face, 'size': font_size, 'x': this.centerx + x, 'y': this.centery + y, 'text': String(labels[i]), 'valign': 'center', 'halign': this.centerx + x > this.centerx ? 'left' : 'right', 'tag': 'labels' });\n    }\n  };this.drawTick = this.DrawTick = function (x, y, color) {\n    var tickmarks = prop['chart.tickmarks'];var ticksize = prop['chart.ticksize'];co.strokeStyle = color;co.fillStyle = color;var prevLinewidth = co.lineWidth;co.lineWidth = 1;if (tickmarks == 'cross') {\n      co.beginPath();co.moveTo(x + ticksize, y + ticksize);co.lineTo(x - ticksize, y - ticksize);co.stroke();co.beginPath();co.moveTo(x - ticksize, y + ticksize);co.lineTo(x + ticksize, y - ticksize);co.stroke();\n    } else if (tickmarks == 'circle') {\n      co.beginPath();co.arc(x, y, ticksize, 0, 6.2830, false);co.fill();\n    } else if (tickmarks == 'square') {\n      co.beginPath();co.fillRect(x - ticksize, y - ticksize, 2 * ticksize, 2 * ticksize);co.fill();\n    } else if (tickmarks == 'diamond') {\n      co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x + ticksize, y);co.lineTo(x, y + ticksize);co.lineTo(x - ticksize, y);co.closePath();co.fill();\n    } else if (tickmarks == 'plus') {\n      co.lineWidth = 1;co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x, y + ticksize);co.moveTo(x - ticksize, y);co.lineTo(x + ticksize, y);co.stroke();\n    }\n    co.lineWidth = prevLinewidth;\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var i = 0, len = this.coords.length; i < len; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltip = this.coords[i][3];if (mouseX < x + offset && mouseX > x - offset && mouseY < y + offset && mouseY > y - offset) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: x, 2: y, 3: i, 'object': this, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var centerx = this.centerx;var centery = this.centery;var radius = this.radius;if (mouseX > centerx - radius && mouseX < centerx + radius && mouseY > centery - radius && mouseY < centery + radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    var max = this.max;if (value < 0 || value > max) {\n      return null;\n    }\n    var r = value / max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.colors.default'] = RG.arrayClone(prop['chart.colors.default']);this.original_colors['chart.background.grid.color'] = RG.arrayClone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.arrayClone(prop['chart.background.color']);this.original_colors['chart.segment.highlight.stroke'] = RG.arrayClone(prop['chart.segment.highlight.stroke']);this.original_colors['chart.segment.highlight.fill'] = RG.arrayClone(prop['chart.segment.highlight.fill']);\n    }\n    for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        this.data[i][j][2] = this.parseSingleColorForGradient(this.data[i][j][2]);\n      }\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.colors.default'] = this.parseSingleColorForGradient(prop['chart.colors.default']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords2 && this.coords2[index] && this.coords2[index].length) {\n      this.coords2[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 2, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);\n      }\n    }\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.rscatter.js\n// module id = 201\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.rscatter.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Scatter = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && (typeof conf.data[0][0] === 'number' || typeof conf.data[0][0] === 'string')) {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = RGraph.arrayClone(arguments[1][i]);\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  if (!RGraph.isArray(this.data[0][0])) {\n    this.data = [this.data];\n  }\n  for (var i = 0, len = this.data.length; i < len; ++i) {\n    for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][0] === 'string') {\n        if (this.data[i][j][0].match(/^[.0-9]+$/)) {\n          this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n        } else if (this.data[i][j][0] === '') {\n          this.data[i][j][0] = 0;\n        }\n      }\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][1] === 'string') {\n        if (this.data[i][j][1].match(/[.0-9]+/)) {\n          this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n        } else if (this.data[i][j][1] === '') {\n          this.data[i][j][1] = 0;\n        }\n      }\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.canvas.__object__ = this;this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.max = 0;this.coords = [];this.type = 'scatter';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.hbars': null, 'chart.background.vbars': null, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.tooltips': [], 'chart.tooltips.effect': 'fade', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.hotspot': 3, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.units.pre': '', 'chart.units.post': '', 'chart.numyticks': 10, 'chart.tickmarks': 'cross', 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 5, 'chart.numxticks': true, 'chart.xaxis': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.colors.bubble.graduated': true, 'chart.xmin': 0, 'chart.xmax': 0, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.invert': false, 'chart.ylabels.specific': null, 'chart.ylabels.inside': false, 'chart.contextmenu': null, 'chart.defaultcolor': 'black', 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.linewidth': 1, 'chart.crosshairs.coords': false, 'chart.crosshairs.coords.fixed': true, 'chart.crosshairs.coords.fadeout': false, 'chart.crosshairs.coords.labels.x': 'X', 'chart.crosshairs.coords.labels.y': 'Y', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.line': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['green', 'red'], 'chart.line.shadow.color': 'rgba(0,0,0,0)', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.line.stepped': false, 'chart.line.visible': true, 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.boxplot.width': 1, 'chart.boxplot.capped': true, 'chart.resizable': false, 'chart.resize.handle.background': null }, _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.labels.specific.align', 'left'), _defineProperty(_properties, 'chart.xscale', false), _defineProperty(_properties, 'chart.xscale.units.pre', ''), _defineProperty(_properties, 'chart.xscale.units.post', ''), _defineProperty(_properties, 'chart.xscale.numlabels', 10), _defineProperty(_properties, 'chart.xscale.formatter', null), _defineProperty(_properties, 'chart.xscale.decimals', 0), _defineProperty(_properties, 'chart.xscale.thousand', ','), _defineProperty(_properties, 'chart.xscale.point', '.'), _defineProperty(_properties, 'chart.noendxtick', false), _defineProperty(_properties, 'chart.noendytick', true), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.animation.trace', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _properties);\n  for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (RGraph.isNull(this.data[i][j])) {\n        this.data[i][j] = [];\n      }\n      if (this.data[i][j] && typeof this.data[i][j][0] == 'string') {\n        this.data[i][j][0] = RGraph.parseDate(this.data[i][j][0]);\n      }\n    }\n  }\n  this.data_arr = [];for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      this.data_arr.push(this.data[i][j]);\n    }\n  }\n  for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas) {\n    alert('[SCATTER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.xticks') {\n      name == 'chart.numxticks';\n    }\n    if (name == 'chart.line.colors') {\n      prop['chart.colors'] = value;\n    }\n    if (name == 'chart.tooltip.hotspot') {\n      name = 'chart.tooltips.hotspot';\n    }\n    if (name == 'chart.yaxispos' && value != 'left' && value != 'right') {\n      alert(\"[SCATTER] chart.yaxispos should be left or right. You've set it to: '\" + value + \"' Changing it to left\");value = 'left';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center') {\n        alert('[SCATTER] (' + this.id + ') chart.xaxispos should be center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.noxaxis') {\n      name = 'chart.xaxis';value = !value;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] === 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.hasTooltips = false;var overHotspot = false;this.coords = [];if (typeof prop['chart.xmin'] == 'string') prop['chart.xmin'] = RG.parseDate(prop['chart.xmin']);if (typeof prop['chart.xmax'] == 'string') prop['chart.xmax'] = RG.parseDate(prop['chart.xmax']);if (!RGraph.ISOLD) {\n      this.Set('chart.tooltips', []);for (var i = 0, len = this.data.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (this.data[i][j] && this.data[i][j][3]) {\n            prop['chart.tooltips'].push(this.data[i][j][3]);this.hasTooltips = true;\n          } else {\n            prop['chart.tooltips'].push(null);\n          }\n        }\n      }\n    }\n    this.max = 0;if (typeof prop['chart.ymax'] === 'number') {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;var decimals = prop['chart.scale.decimals'];\n    } else {\n      var i = 0;var j = 0;for (i = 0, len = this.data.length; i < len; i += 1) {\n        for (j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (!RG.isNull(this.data[i][j]) && this.data[i][j][1] != null) {\n            this.max = Math.max(this.max, _typeof(this.data[i][j][1]) == 'object' ? RG.array_max(this.data[i][j][1]) : Math.abs(this.data[i][j][1]));\n          }\n        }\n      }\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    this.grapharea = ca.height - this.gutterTop - this.gutterBottom;RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.background.vbars'] && prop['chart.background.vbars'].length) {\n      this.DrawVBars();\n    }\n    if (!prop['chart.noaxes']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();if (prop['chart.animation.trace']) {\n      co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();\n    }\n    for (i = 0; i < this.data.length; ++i) {\n      this.DrawMarks(i);co.shadowColor = prop['chart.line.shadow.color'];co.shadowOffsetX = prop['chart.line.shadow.offsetx'];co.shadowOffsetY = prop['chart.line.shadow.offsety'];co.shadowBlur = prop['chart.line.shadow.blur'];this.DrawLine(i);RG.NoShadow(this);\n    }\n    if (prop['chart.line']) {\n      for (var i = 0, len = this.data.length; i < len; i += 1) {\n        this.DrawMarks(i);\n      }\n    }\n    if (prop['chart.animation.trace']) {\n      co.restore();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.line.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.DrawAboveLabels();\n    }\n    this.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };\n  this.drawAxes = this.DrawAxes = function () {\n    var graphHeight = ca.height - this.gutterTop - this.gutterBottom;co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = (prop['chart.axis.linewidth'] || 1) + 0.001;if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.xaxis']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));co.lineTo(ca.width - this.gutterRight, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));\n      } else {\n        var y = this.getYCoord(this.scale2.min > 0 ? this.scale2.min : 0);co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    if (prop['chart.noyaxis'] === false) {\n      var numyticks = prop['chart.numyticks'];for (i = 0; i < numyticks; ++i) {\n        var y = (ca.height - this.gutterTop - this.gutterBottom) / numyticks * i;y = y + this.gutterTop;if (prop['chart.xaxispos'] == 'center' && i == numyticks / 2) {\n          continue;\n        }\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, Math.round(y));co.lineTo(ca.width - this.gutterRight, Math.round(y));\n        }\n      }\n      if (prop['chart.numyticks'] > 0) {\n        if (prop['chart.xaxispos'] == 'center' && prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n        } else if (prop['chart.xaxispos'] == 'center') {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));\n        }\n      }\n      if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'left') {\n        co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n      } else if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'right') {\n        co.moveTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));\n      }\n      if (prop['chart.xaxispos'] === 'bottom' && prop['chart.numyticks'] > 0) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(this.gutterLeft - 3, ma.round(this.getYCoord(prop['chart.ymin'])));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(ca.width - this.gutterRight, ma.round(this.getYCoord(prop['chart.ymin'])));\n        }\n      }\n    }\n    if (prop['chart.numxticks'] > 0 && prop['chart.xaxis']) {\n      var x = 0,\n          y = this.getYCoord(prop['chart.ylabels.invert'] ? this.scale2.max : this.scale2.max > 0 && this.scale2.min > 0 ? this.scale2.min : 0) - 3,\n          size = 3;if (prop['chart.ymin'] === 0 && prop['chart.xaxispos'] === 'bottom') {\n        y += 3;\n      }\n      if (this.scale2.max > 0 && this.scale2.min > 0) {\n        y += 3;\n      }\n      this.xTickGap = prop['chart.labels'] && prop['chart.labels'].length ? (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length : (ca.width - this.gutterLeft - this.gutterRight) / 10;if (typeof prop['chart.numxticks'] == 'number') {\n        this.xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' && prop['chart.noyaxis'] == false ? this.xTickGap : 0); x <= ca.width - this.gutterRight - (prop['chart.yaxispos'] == 'left' || prop['chart.noyaxis'] == true ? -1 : 1); x += this.xTickGap) {\n        if (prop['chart.yaxispos'] == 'left' && prop['chart.noendxtick'] == true && x == ca.width - this.gutterRight) {\n          continue;\n        } else if (prop['chart.yaxispos'] == 'right' && prop['chart.noendxtick'] == true && x == this.gutterLeft) {\n          continue;\n        }\n        co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y + (prop['chart.xaxispos'] === 'center' || prop['chart.ymin'] < 0 ? size * 2 : size));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        xMin = prop['chart.xmin'],\n        xMax = prop['chart.xmax'],\n        yMax = this.scale2.max,\n        yMin = prop['chart.ymin'] ? prop['chart.ymin'] : 0,\n        text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        numYLabels = prop['chart.ylabels.count'],\n        invert = prop['chart.ylabels.invert'],\n        inside = prop['chart.ylabels.inside'],\n        context = co,\n        canvas = ca,\n        boxed = false,\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    this.halfTextHeight = text_size / 2;this.halfGraphHeight = (ca.height - this.gutterTop - this.gutterBottom) / 2;if (prop['chart.ylabels']) {\n      var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n        if (prop['chart.yaxispos'] == 'left') {\n          xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n        } else {\n          xPos = ca.width - prop['chart.gutter.right'] - 5;align = 'right';boxed = true;\n        }\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific'] != null && prop['chart.ylabels.specific'].length) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 0) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0; i < labels.length; ++i) {\n            var y = this.gutterTop + i * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          var reversed_labels = RG.array_reverse(labels);for (var i = 0; i < reversed_labels.length; ++i) {\n            var y = this.gutterTop + this.grapharea / 2 + (i + 1) * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': reversed_labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          if (prop['chart.ymin'] != 0) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.grapharea / 2 + this.gutterTop + offsety, 'text': prop['chart.ylabels.specific'][prop['chart.ylabels.specific'].length - 1], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n        }\n        if (!prop['chart.ylabels.specific'] && typeof numYLabels == 'number') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n            } else {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n            }\n          }\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[len - (i + 1)], 'tag': 'scale' });\n            } else {\n              if (i == len - 1 && invert) {\n                continue;\n              }\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n            }\n          }\n          if (!invert && (yMin > 0 || prop['chart.scale.zerostart'])) {\n            RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: this.gutterTop + this.halfGraphHeight + offsety, valign: 'center', halign: align, bounding: boxed, boundingFill: 'white', text: RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n          }\n          if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.number_format(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight * 2 + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      } else {\n        var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n          if (prop['chart.yaxispos'] == 'left') {\n            xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n          } else {\n            xPos = ca.width - this.gutterRight - 5;align = 'right';boxed = true;\n          }\n        }\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 9999) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0, len = labels.length; i < len; i += 1) {\n            var y = this.gutterTop + i * (this.grapharea / (len - 1));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'halign': align, 'valign': 'center', 'bounding': boxed, 'tag': 'scale' });\n          }\n        } else {\n          if (typeof numYLabels == 'number') {\n            if (invert) {\n              for (var i = 0; i < numYLabels; ++i) {\n                var interval = (ca.height - this.gutterTop - this.gutterBottom) / numYLabels;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + (i + 1) * interval + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && !prop['chart.ymin']) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, this.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n              }\n            } else {\n              for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.grapharea - (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && prop['chart.ymin'] == 0) {\n                RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: ca.height - this.gutterBottom + offsety, valign: 'center', halign: align, boundin: boxed, boundingFill: 'white', text: RG.numberFormat(this, 0 .toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n              }\n            }\n          }\n          if ((prop['chart.ymin'] || prop['chart.scale.zerostart']) && !invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          } else if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (prop['chart.xscale']) {\n      var numXLabels = prop['chart.xscale.numlabels'],\n          y = ca.height - this.gutterBottom + 5 + text_size / 2,\n          units_pre_x = prop['chart.xscale.units.pre'],\n          units_post_x = prop['chart.xscale.units.post'],\n          decimals = prop['chart.xscale.decimals'],\n          point = prop['chart.xscale.point'],\n          thousand = prop['chart.xscale.thousand'],\n          color = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      if (!prop['chart.xmax']) {\n        var xmax = 0;var xmin = prop['chart.xmin'];for (var ds = 0, len = this.data.length; ds < len; ds += 1) {\n          for (var point = 0, len2 = this.data[ds].length; point < len2; point += 1) {\n            xmax = Math.max(xmax, this.data[ds][point][0]);\n          }\n        }\n      } else {\n        xmax = prop['chart.xmax'];xmin = prop['chart.xmin'];\n      }\n      this.xscale2 = RG.getScale2(this, { 'max': xmax, 'min': xmin, 'scale.decimals': decimals, 'scale.point': point, 'scale.thousand': thousand, 'units.pre': units_pre_x, 'units.post': units_post_x, 'ylabels.count': numXLabels, 'strict': true });this.Set('chart.xmax', this.xscale2.max);var interval = (ca.width - this.gutterLeft - this.gutterRight) / this.xscale2.labels.length;for (var i = 0, len = this.xscale2.labels.length; i < len; i += 1) {\n        var num = (prop['chart.xmax'] - prop['chart.xmin']) * ((i + 1) / numXLabels) + (xmin || 0),\n            x = this.gutterLeft + (i + 1) * interval,\n            text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, num)) : this.xscale2.labels[i];RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n      }\n      var text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, prop['chart.xmin'])) : String(prop['chart.xmin']);RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': this.gutterLeft + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n    } else {\n      var graphArea = ca.width - this.gutterLeft - this.gutterRight;var xInterval = graphArea / prop['chart.labels'].length;var xPos = this.gutterLeft;var yPos = ca.height - this.gutterBottom + 3;var labels = prop['chart.labels'];var color = prop['chart.labels.color'];var bold = prop['chart.labels.bold'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];var angle = 0;var valign = 'top';var halign = 'center';if (prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yPos += 10;\n      }\n      for (i = 0; i < labels.length; ++i) {\n        if (_typeof(labels[i]) == 'object') {\n          if (prop['chart.labels.specific.align'] == 'center') {\n            var rightEdge = 0;if (labels[i + 1] && labels[i + 1][1]) {\n              rightEdge = labels[i + 1][1];\n            } else {\n              rightEdge = prop['chart.xmax'];\n            }\n            var offset = (this.getXCoord(rightEdge) - this.getXCoord(labels[i][1])) / 2;\n          } else {\n            var offset = 5;\n          }\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': this.getXCoord(labels[i][1]) + offset + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': angle != 0 ? 'right' : prop['chart.labels.specific.align'] == 'center' ? 'center' : 'left', 'text': String(labels[i][0]), 'angle': angle, 'marker': false, 'tag': 'labels.specific' });co.beginPath();co.strokeStyle = '#bbb';co.moveTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom + 20);co.stroke();\n        } else {\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': xPos + xInterval / 2 + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': halign, 'text': String(labels[i]), 'angle': angle, 'tag': 'labels' });\n        }\n        xPos += xInterval;\n      }\n      if (_typeof(labels[0]) == 'object') {\n        co.beginPath();co.strokeStyle = '#bbb';co.moveTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom);co.lineTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom + 20);co.stroke();\n      }\n    }\n  };this.drawMarks = this.DrawMarks = function (i) {\n    this.coords[i] = [];var xmax = prop['chart.xmax'];var default_color = prop['chart.defaultcolor'];for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n      var data_points = this.data[i];if (RG.isNull(data_points[j])) {\n        continue;\n      }\n      var xCoord = data_points[j][0];var yCoord = data_points[j][1];var color = data_points[j][2] ? data_points[j][2] : default_color;var tooltip = data_points[j] && data_points[j][3] ? data_points[j][3] : null;this.DrawMark(i, xCoord, yCoord, xmax, this.scale2.max, color, tooltip, this.coords[i], data_points, j);\n    }\n  };this.drawMark = this.DrawMark = function (data_set_index, x, y, xMax, yMax, color, tooltip, coords, data, data_index) {\n    var tickmarks = prop['chart.tickmarks'],\n        tickSize = prop['chart.ticksize'],\n        xMin = prop['chart.xmin'],\n        x = (x - xMin) / (xMax - xMin) * (ca.width - this.gutterLeft - this.gutterRight),\n        originalX = x,\n        originalY = y;if (tickmarks && (typeof tickmarks === 'undefined' ? 'undefined' : _typeof(tickmarks)) == 'object') {\n      tickmarks = tickmarks[data_set_index];\n    }\n    if ((typeof tickSize === 'undefined' ? 'undefined' : _typeof(tickSize)) == 'object') {\n      var tickSize = tickSize[data_set_index];var halfTickSize = tickSize / 2;\n    } else {\n      var halfTickSize = tickSize / 2;\n    }\n    if (y && (typeof y === 'undefined' ? 'undefined' : _typeof(y)) === 'object' && typeof y[0] === 'number' && typeof y[1] === 'number' && typeof y[2] === 'number' && typeof y[3] === 'number' && typeof y[4] === 'number') {\n      this.Set('chart.boxplot', true);var y0 = this.getYCoord(y[0]),\n          y1 = this.getYCoord(y[1]),\n          y2 = this.getYCoord(y[2]),\n          y3 = this.getYCoord(y[3]),\n          y4 = this.getYCoord(y[4]),\n          col1 = y[5],\n          col2 = y[6],\n          boxWidth = typeof y[7] == 'number' ? y[7] : prop['chart.boxplot.width'];\n    } else {\n      var yCoord = this.getYCoord(y);\n    }\n    x += this.gutterLeft;co.beginPath();co.strokeStyle = color;if (prop['chart.boxplot']) {\n      boxWidth = boxWidth / prop['chart.xmax'] * (ca.width - this.gutterLeft - this.gutterRight);var halfBoxWidth = boxWidth / 2;if (prop['chart.line.visible']) {\n        co.beginPath();if (typeof y[8] === 'string') {\n          co.strokeStyle = y[8];\n        }\n        co.strokeRect(x - halfBoxWidth, y1, boxWidth, y3 - y1);if (col1) {\n          co.fillStyle = col1;co.fillRect(x - halfBoxWidth, y1, boxWidth, y2 - y1);\n        }\n        if (col2) {\n          co.fillStyle = col2;co.fillRect(x - halfBoxWidth, y2, boxWidth, y3 - y2);\n        }\n        co.stroke();co.beginPath();if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y0));co.lineTo(x + halfBoxWidth, ma.round(y0));\n        }\n        co.moveTo(ma.round(x), y0);co.lineTo(ma.round(x), y1);if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y4));co.lineTo(x + halfBoxWidth, ma.round(y4));\n        }\n        co.moveTo(ma.round(x), y4);co.lineTo(ma.round(x), y3);co.stroke();\n      }\n    }\n    if (prop['chart.line.visible'] && typeof y == 'number' && !y0 && !y1 && !y2 && !y3 && !y4) {\n      if (tickmarks == 'circle') {\n        co.arc(x, yCoord, halfTickSize, 0, 6.28, 0);co.fillStyle = color;co.fill();\n      } else if (tickmarks == 'plus') {\n        co.moveTo(x, yCoord - halfTickSize);co.lineTo(x, yCoord + halfTickSize);co.moveTo(x - halfTickSize, yCoord);co.lineTo(x + halfTickSize, yCoord);co.stroke();\n      } else if (tickmarks == 'square') {\n        co.strokeStyle = color;co.fillStyle = color;co.fillRect(x - halfTickSize, yCoord - halfTickSize, tickSize, tickSize);\n      } else if (tickmarks == 'cross') {\n        co.moveTo(x - halfTickSize, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord + halfTickSize);co.moveTo(x + halfTickSize, yCoord - halfTickSize);co.lineTo(x - halfTickSize, yCoord + halfTickSize);co.stroke();\n      } else if (tickmarks == 'diamond') {\n        co.fillStyle = co.strokeStyle;co.moveTo(x, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord);co.lineTo(x, yCoord + halfTickSize);co.lineTo(x - halfTickSize, yCoord);co.lineTo(x, yCoord - halfTickSize);co.fill();co.stroke();\n      } else if (typeof tickmarks == 'function') {\n        var graphWidth = ca.width - this.gutterLeft - this.gutterRight,\n            graphheight = ca.height - this.gutterTop - this.gutterBottom,\n            xVal = (x - this.gutterLeft) / graphWidth * xMax,\n            yVal = (graphheight - (yCoord - this.gutterTop)) / graphheight * yMax;tickmarks(this, data, x, yCoord, xVal, yVal, xMax, yMax, color, data_set_index, data_index);\n      } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n        var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n          img.src = tickmarks.substr(6);\n        } else {\n          img.src = tickmarks;\n        }\n        img.onload = function () {\n          if (prop['chart.tickmarks.image.halign'] === 'center') x -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') x -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yCoord -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yCoord -= this.height;x += prop['chart.tickmarks.image.offsetx'];yCoord += prop['chart.tickmarks.image.offsety'];co.drawImage(this, x, yCoord);\n        };\n      } else if (tickmarks === null) {} else {\n        alert('[SCATTER] (' + this.id + ') Unknown tickmark style: ' + tickmarks);\n      }\n    }\n    if (prop['chart.boxplot'] && typeof y0 === 'number' && typeof y1 === 'number' && typeof y2 === 'number' && typeof y3 === 'number' && typeof y4 === 'number') {\n      x = [x - halfBoxWidth, x + halfBoxWidth];yCoord = [y0, y1, y2, y3, y4];\n    }\n    coords.push([x, yCoord, tooltip]);\n  };this.drawLine = this.DrawLine = function (i) {\n    if (typeof prop['chart.line.visible'] == 'boolean' && prop['chart.line.visible'] == false) {\n      return;\n    }\n    if (prop['chart.line'] && this.coords[i].length >= 2) {\n      if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash(prop['chart.line.dash']);\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';co.lineWidth = this.getLineWidth(i);co.strokeStyle = prop['chart.line.colors'][i];co.beginPath();var prevY = null;var currY = null;for (var j = 0, len = this.coords[i].length; j < len; j += 1) {\n        var xPos = this.coords[i][j][0];var yPos = this.coords[i][j][1];if (j > 0) prevY = this.coords[i][j - 1][1];currY = yPos;if (j == 0 || RG.is_null(prevY) || RG.is_null(currY)) {\n          co.moveTo(xPos, yPos);\n        } else {\n          var stepped = prop['chart.line.stepped'];if (typeof stepped == 'boolean' && stepped || (typeof stepped === 'undefined' ? 'undefined' : _typeof(stepped)) == 'object' && stepped[i]) {\n            co.lineTo(this.coords[i][j][0], this.coords[i][j - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        }\n      }\n      co.stroke();if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash([1, 0]);\n      }\n    }\n    co.lineWidth = 1;\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.line.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[SCATTER] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.drawVBars = this.DrawVBars = function () {\n    var vbars = prop['chart.background.vbars'];var graphWidth = ca.width - this.gutterLeft - this.gutterRight;if (vbars) {\n      var xmax = prop['chart.xmax'];var xmin = prop['chart.xmin'];for (var i = 0, len = vbars.length; i < len; i += 1) {\n        var key = i;var value = vbars[key];if (typeof value[0] == 'string') value[0] = RG.parseDate(value[0]);if (typeof value[1] == 'string') value[1] = RG.parseDate(value[1]) - value[0];var x = (value[0] - xmin) / (xmax - xmin) * graphWidth + this.gutterLeft;var width = value[1] / (xmax - xmin) * graphWidth;co.fillStyle = value[2];co.fillRect(x, this.gutterTop, width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function (obj) {\n    var labels = obj.Get('chart.labels.ingraph');var labels_processed = [];if (!labels) {\n      return;\n    }\n    var fgcolor = 'black';var bgcolor = 'white';var direction = 1;for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] == 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] == 'string' || _typeof(labels[i]) == 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.NoShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      var i = 0;for (var set = 0; set < obj.coords.length; ++set) {\n        for (var point = 0; point < obj.coords[set].length; ++point) {\n          if (labels_processed[i]) {\n            var x = obj.coords[set][point][0];var y = obj.coords[set][point][1];var length = typeof labels_processed[i][4] == 'number' ? labels_processed[i][4] : 25;var text_x = x;var text_y = y - 5 - length;co.moveTo(x, y - 5);co.lineTo(x, y - 5 - length);co.stroke();co.beginPath();co.moveTo(x, y - 5);co.lineTo(x - 3, y - 10);co.lineTo(x + 3, y - 10);co.closePath();co.beginPath();co.fillStyle = _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][1] == 'string' ? labels_processed[i][1] : 'black';RG.text2(this, { 'font': obj.Get('chart.text.font'), 'size': obj.Get('chart.text.size'), 'x': text_x, 'y': text_y, 'text': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][0] == 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][2] == 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels.ingraph' });co.fill();\n          }\n          i++;\n        }\n      }\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var i = 0, len2 = this.coords[set].length; i < len2; ++i) {\n        var x = this.coords[set][i][0];var y = this.coords[set][i][1];var tooltip = this.data[set][i][3];if (typeof y == 'number') {\n          if (mouseX <= x + offset && mouseX >= x - offset && mouseY <= y + offset && mouseY >= y - offset) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);var index_adjusted = i;for (var ds = set - 1; ds >= 0; --ds) {\n              index_adjusted += this.data[ds].length;\n            }\n            return { 0: this, 1: x, 2: y, 3: set, 4: i, 5: this.data[set][i][3], 'object': this, 'x': x, 'y': y, 'dataset': set, 'index': i, 'tooltip': tooltip, 'index_adjusted': index_adjusted };\n          }\n        } else if (RG.is_null(y)) {} else {\n          var mark = this.data[set][i];var width = prop['chart.boxplot.width'];if (typeof mark[1][7] == 'number') {\n            width = mark[1][7];\n          }\n          if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) == 'object' && mouseX > x[0] && mouseX < x[1] && mouseY < y[1] && mouseY > y[3]) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);return { 0: this, 1: x[0], 2: x[1] - x[0], 3: y[1], 4: y[3] - y[1], 5: set, 6: i, 7: this.data[set][i][3], 'object': this, 'x': x[0], 'y': y[1], 'width': x[1] - x[0], 'height': y[3] - y[1], 'dataset': set, 'index': i, 'tooltip': tooltip };\n          }\n        }\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'];var font = prop['chart.text.font'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var point = 0, len2 = this.coords[set].length; point < len2; ++point) {\n        var x_val = this.data[set][point][0];var y_val = this.data[set][point][1];if (!RG.is_null(y_val)) {\n          if (RG.is_array(y_val)) {\n            var max = 0;for (var i = 0; i < y_val; ++i) {\n              max = Math.max(max, y_val[i]);\n            }\n            y_val = max;\n          }\n          var x_pos = this.coords[set][point][0];var y_pos = this.coords[set][point][1];RG.Text2(this, { 'font': font, 'size': size, 'x': x_pos, 'y': y_pos - 5 - size, 'text': x_val.toFixed(prop['chart.labels.above.decimals']) + ', ' + y_val.toFixed(prop['chart.labels.above.decimals']), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': 'rgba(255, 255, 255, 0.7)', 'tag': 'labels.above' });\n        }\n      }\n    }\n  };this.getYValue = this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value *= 2;if (value >= 0) {\n        value += this.min;\n        if (prop['chart.ylabels.invert']) {\n          value -= this.min;value = this.max - value;\n        }\n      } else {\n        value -= this.min;if (prop['chart.ylabels.invert']) {\n          value += this.min;value = this.max + value;value *= -1;\n        }\n      }\n    } else {\n      var value = (this.grapharea - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value += this.min;if (prop['chart.ylabels.invert']) {\n        value -= this.min;value = this.max - value;\n      }\n    }\n    return value;\n  };this.getXValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg);var mouseX = mouseXY[0];var mouseY = mouseXY[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    var width = ca.width - this.gutterLeft - this.gutterRight;var value = (mouseX - this.gutterLeft) / width * (prop['chart.xmax'] - prop['chart.xmin']);\n    value += prop['chart.xmin'];return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      if (shape['height']) {\n        RG.Highlight.Rect(this, shape);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft - 3 && mouseXY[0] < ca.width - this.gutterRight + 3 && mouseXY[1] > this.gutterTop - 3 && mouseXY[1] < ca.height - this.gutterBottom + 3) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (typeof value != 'number' && typeof value != 'string') {\n      return null;\n    }\n    if (typeof value === 'string') {\n      value = RG.parseDate(value);\n    }\n    var xmin = prop['chart.xmin'];var xmax = prop['chart.xmax'];var x;if (value < xmin) return null;if (value > xmax) return null;var gutterRight = this.gutterRight;var gutterLeft = this.gutterLeft;if (prop['chart.yaxispos'] == 'right') {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = ca.width - gutterRight - x;\n    } else {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = x + gutterLeft;\n    }\n    return x;\n  };this.getYCoord = this.getYCoordFromValue = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var invert = prop['chart.ylabels.invert'];var xaxispos = prop['chart.xaxispos'];var graphHeight = ca.height - this.gutterTop - this.gutterBottom;var halfGraphHeight = graphHeight / 2;var ymax = this.max;var ymin = prop['chart.ymin'];var coord = 0;if (value > ymax || prop['chart.xaxispos'] == 'bottom' && value < ymin || prop['chart.xaxispos'] == 'center' && (value > 0 && value < ymin || value < 0 && value > -1 * ymin)) {\n      return null;\n    }\n    if (xaxispos == 'center') {\n      coord = (Math.abs(value) - ymin) / (ymax - ymin) * halfGraphHeight;if (invert) {\n        coord = halfGraphHeight - coord;\n      }\n      if (value < 0) {\n        coord += this.gutterTop;coord += halfGraphHeight;\n      } else {\n        coord = halfGraphHeight - coord;coord += this.gutterTop;\n      }\n    } else {\n      coord = (value - ymin) / (ymax - ymin) * graphHeight;if (invert) {\n        coord = graphHeight - coord;\n      }\n      coord = graphHeight - coord;coord = this.gutterTop + coord;\n    }\n    return coord;\n  };RG.Scatter.Bubble = function (scatter, min, max, width, data) {\n    this.scatter = scatter;this.min = min;this.max = max;this.width = width;this.data = data;this.coords = [];this.type = 'scatter.bubble';\n    this.set = this.Set = function (name, value) {\n      this.scatter.set(name, value);return this;\n    };this.get = this.Get = function (name) {\n      this.scatter.get(name);\n    };this.draw = this.Draw = function () {\n      var bubble_min = this.min,\n          bubble_max = this.max,\n          bubble_data = this.data,\n          bubble_max_width = this.width;var obj_bubble = this,\n          obj_scatter = this.scatter;this.scatter.ondraw = function (obj) {\n        for (var i = 0; i < obj.coords[0].length; ++i) {\n          bubble_data[i] = ma.max(bubble_data[i], bubble_min);bubble_data[i] = ma.min(bubble_data[i], bubble_max);var r = (bubble_data[i] - bubble_min) / (bubble_max - bubble_min) * bubble_max_width,\n              color = obj_scatter.data[0][i][2] ? obj_scatter.data[0][i][2] : obj_scatter.properties['chart.defaultcolor'];co.beginPath();co.fillStyle = RG.radialGradient(obj, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, 0, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, r, prop['chart.colors.bubble.graduated'] ? 'white' : color, color);co.arc(obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, 0, RG.TWOPI, false);co.fill();obj_bubble.coords[i] = [obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, co.fillStyle];\n        }\n      };\n      this.scatter.Draw();return this;\n    };\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.background.vbars'] = RG.array_clone(prop['chart.background.vbars']);this.original_colors['chart.background.hbars'] = RG.array_clone(prop['chart.background.hbars']);this.original_colors['chart.line.colors'] = RG.array_clone(prop['chart.line.colors']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var data = this.data;if (data) {\n      for (var dataset = 0; dataset < data.length; ++dataset) {\n        for (var i = 0; i < this.data[dataset].length; ++i) {\n          if (this.data[dataset][i] && _typeof(this.data[dataset][i][1]) == 'object' && this.data[dataset][i][1]) {\n            if (typeof this.data[dataset][i][1][5] == 'string') this.data[dataset][i][1][5] = this.parseSingleColorForGradient(this.data[dataset][i][1][5]);if (typeof this.data[dataset][i][1][6] == 'string') this.data[dataset][i][1][6] = this.parseSingleColorForGradient(this.data[dataset][i][1][6]);\n          }\n          if (!RG.isNull(this.data[dataset][i])) {\n            this.data[dataset][i][2] = this.parseSingleColorForGradient(this.data[dataset][i][2]);\n          }\n        }\n      }\n    }\n    var hbars = prop['chart.background.hbars'];if (hbars) {\n      for (i = 0; i < hbars.length; ++i) {\n        hbars[i][2] = this.parseSingleColorForGradient(hbars[i][2]);\n      }\n    }\n    var vbars = prop['chart.background.vbars'];if (vbars) {\n      for (i = 0; i < vbars.length; ++i) {\n        vbars[i][2] = this.parseSingleColorForGradient(vbars[i][2]);\n      }\n    }\n    var colors = prop['chart.line.colors'];if (colors) {\n      for (i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords && this.coords[index] && this.coords[index].length) {\n      this.coords[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 3, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.trace = this.trace2 = function () {\n    var obj = this,\n        callback = arguments[2],\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {};\n    obj.Set('animationTrace', true);obj.Set('animationTraceClip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animationTraceClip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);if (_typeof(this.data[i][j][1]) === 'object') {\n          this.data[i][j][1][5] = RG.array_clone(this.original_colors['data'][i][j][1][5]);this.data[i][j][1][6] = RG.array_clone(this.original_colors['data'][i][j][1][6]);\n        }\n      }\n    }\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.scatter.js\n// module id = 202\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.scatter.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SemiCircularProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'semicircularprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.color': 'rgba(0,0,0,0)', 'chart.colors': ['#0c0'], 'chart.linewidth': 2, 'chart.strokestyle': '#666', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.width': null, 'chart.angles.start': Math.PI, 'chart.angles.end': 2 * Math.PI, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.formatter': null, 'chart.scale.round': false, 'chart.shadow': false, 'chart.shadow.color': 'rgba(220,220,220,1)', 'chart.shadow.blur': 2, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.labels.center': true, 'chart.labels.center.font': null, 'chart.labels.center.bold': false, 'chart.labels.center.italic': false, 'chart.labels.center.fade': false, 'chart.labels.center.size': 40, 'chart.labels.center.color': 'black', 'chart.labels.center.valign': 'bottom', 'chart.labels.min.color': null, 'chart.labels.min.font': null, 'chart.labels.min.bold': false, 'chart.labels.min.size': null, 'chart.labels.min.italic': false, 'chart.labels.min.offset.angle': 0, 'chart.labels.min.offsetx': 0, 'chart.labels.min.offsety': 0, 'chart.labels.max.color': null, 'chart.labels.max.font': null, 'chart.labels.max.bold': false, 'chart.labels.max.size': null, 'chart.labels.max.italic': false, 'chart.labels.max.offset.angle': 0, 'chart.labels.max.offsetx': 0, 'chart.labels.max.offsety': 0, 'chart.title': '', 'chart.title.bold': true, 'chart.title.italic': false, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.tooltips.coords.page': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[SEMICIRCULARPROGRESS] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min((ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2, ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']);this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.width = this.radius / 3;if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.width'] === 'number') this.width = prop['chart.width'];this.coords = [];this.coordsText = [];this.drawMeter();this.drawLabels();if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    this.allowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawMeter = this.DrawMeter = function () {\n    var start = prop['chart.angles.start'],\n        end = prop['chart.angles.end'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'strict': true, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': 5, 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.background.color'] !== 'rgba(0,0,0,0)') {\n      pa2(co, 'fs % fr % % % %', prop['chart.background.color'], 0, 0, ca.width, ca.height);\n    }\n    pa2(co, 'lw % b a % % % % % false a % % % % % true c s % f % sx % sy % sc % sb % f % sx 0 sy 0 sb 0 sc rgba(0,0,0,0) lw 1', prop['chart.linewidth'], this.centerx, this.centery, this.radius, start, end, this.centerx, this.centery, this.radius - this.width, end, start, prop['chart.strokestyle'], typeof prop['chart.colors'][1] !== 'undefined' ? prop['chart.colors'][1] : prop['chart.colors'][0], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow'] ? prop['chart.shadow.color'] : 'rgba(0,0,0,0)', prop['chart.shadow.blur'], typeof prop['chart.colors'][1] !== 'undefined' ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0.85)');var angle = start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min));pa2(co, 'b a % % % % % false a % % % % % true c f %', this.centerx, this.centery, this.radius, start, angle, this.centerx, this.centery, this.radius - this.width, start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min)), start, prop['chart.colors'][0]);this.coords = [[this.centerx, this.centery, this.radius, start, end, this.width, angle]];\n  };this.drawLabels = this.DrawLabels = function () {\n    var min = RG.numberFormat(this, this.scale2.min, prop['chart.units.pre'], prop['chart.units.post']);\n    var max = RG.numberFormat(this, this.scale2.max, prop['chart.units.pre'], prop['chart.units.post']);\n    if (prop['chart.angles.start'] === RGraph.PI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.start'] <= RGraph.PI) {\n      var halign = 'left';var valign = 'center';\n    } else if (prop['chart.angles.start'] >= RGraph.PI) {\n      var halign = 'right';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.start'] + prop['chart.labels.min.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.min.font'] || prop['chart.text.font'], bold: prop['chart.labels.min.bold'] || prop['chart.text.bold'], size: prop['chart.labels.min.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.min.offsetx'], y: xy[1] + prop['chart.labels.min.offsety'], valign: valign, halign: halign, text: min, color: prop['chart.labels.min.color'] || prop['chart.text.color'], italic: prop['chart.labels.min.italic'] });if (prop['chart.angles.end'] === RGraph.TWOPI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.end'] >= RGraph.TWOPI) {\n      var halign = 'right';var valign = 'center';\n    } else if (prop['chart.angles.end'] <= RGraph.TWOPI) {\n      var halign = 'left';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.end'] + prop['chart.labels.max.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.max.font'] || prop['chart.text.font'], bold: prop['chart.labels.max.bold'] || prop['chart.text.bold'], size: prop['chart.labels.max.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.max.offsetx'], y: xy[1] + prop['chart.labels.max.offsety'], valign: valign, halign: halign, text: max, color: prop['chart.labels.max.color'] || prop['chart.text.color'], italic: prop['chart.labels.max.italic'] });if (prop['chart.labels.center']) {\n      var ret = RG.text2(this, { font: prop['chart.labels.center.font'] || prop['chart.text.font'], size: prop['chart.labels.center.size'] || 50, bold: prop['chart.labels.center.bold'], italic: prop['chart.labels.center.italic'], x: this.centerx, y: this.centery, valign: prop['chart.labels.center.valign'], halign: 'center', text: RG.numberFormat(this, this.value.toFixed(prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), color: prop['chart.labels.center.color'] || prop['chart.text.color'] });if (prop['chart.labels.center.fade'] && ret.node) {\n        ret.node.style.opacity = 0;var delay = 25,\n            incr = 0.1;for (var i = 0; i < 10; ++i) {\n          (function (index) {\n            setTimeout(function () {\n              ret.node.style.opacity = incr * index;\n            }, delay * (index + 1));\n          })(i);\n        }\n      }\n    }\n    RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size']);\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], this.coords[0][6], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], this.coords[0][6], this.coords[0][3]);if (co.isPointInPath(mouseX, mouseY)) {\n      return { object: this, 0: this, x: this.coords[0][0], 1: this.coords[0][0], y: this.coords[0][1], 2: this.coords[0][1], radius: this.coords[0][2], 3: this.coords[0][2], width: this.coords[0][5], 4: this.coords[0][5], start: this.coords[0][3], 5: this.coords[0][3], end: this.coords[0][6], 6: this.coords[0][6], index: 0, tooltip: !RG.isNull(prop['chart.tooltips']) ? prop['chart.tooltips'][0] : null };\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle && mouseX >= this.centerx && mouseY > this.centery) {\n      angle += RGraph.TWOPI;\n    }\n    if (angle < prop['chart.angles.start'] && mouseX > this.centerx) {\n      angle = prop['chart.angles.end'];\n    }\n    if (angle < prop['chart.angles.start']) {\n      angle = prop['chart.angles.start'];\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      pa2(co, 'lw 5 b a % % % % % false a % % % % % true c s % f % lw 1', shape.x, shape.y, shape.radius, shape.start, shape.end, shape.x, shape.y, shape.radius - shape.width, shape.end, shape.start, prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);pa2(co, 'b a % % % % % false', this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end']);pa2(co, 'a % % % % % true', this.centerx, this.centery, this.radius - this.width, prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseXY[0], mouseXY[1]) ? this : null;\n  };this.allowAdjusting = this.AllowAdjusting = function () {};this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = this.getValue(e);if (typeof value === 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(this.canvas);\n      }\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = value / this.max * (prop['chart.angles.end'] - prop['chart.angles.start']);\n    angle += prop['chart.angles.start'];return angle;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], prop['chart.angles.start'], prop['chart.angles.end'], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.colors'][1] = this.parseSingleColorForGradient(prop['chart.colors'][1]);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        initial_value = this.currentValue,\n        opt = arguments[0] || {},\n        numFrames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        diff = this.value - Number(this.currentValue),\n        increment = diff / numFrames;\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        obj.value = initial_value + increment * frame;RG.clear(ca);RG.redrawCanvas(ca);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.semicircularprogress.js\n// module id = 203\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.semicircularprogress.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Bar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'bar';this.coords = [];this.stackedBackfaces = [];this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, variant: null, variant3dOffsetx: 10, variant3dOffsety: 5, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', hmargin: 3, hmarginGrouped: 2, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, keyTextFont: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');if (prop.variant !== '3d') {\n        prop.variant3dOffsetx = 0;prop.variant3dOffsety = 0;\n      } else {\n        this.svg.all.setAttribute('transform', 'skewY(5)');\n      }\n      RG.SVG.createDefs(this);this.coords = [];this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);if (prop.variant === '3d') {\n        RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, prop.gutterTop, prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, this.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft, this.height - prop.gutterBottom, prop.gutterLeft, prop.gutterTop), fill: '#ddd', stroke: '#ccc' } });this.threed_xaxis_group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph_3d_bar_xaxis_negative' } });RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, this.getYCoord(0), prop.gutterLeft + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight, this.getYCoord(0), prop.gutterLeft, this.getYCoord(0)), fill: '#ddd', stroke: '#ccc' } });\n      }\n      this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      var y = this.getYCoord(0);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = this.graphWidth / this.data.length,\n              height = (ma.abs(this.data[i]) - ma.abs(this.scale.min)) / (ma.abs(this.scale.max) - ma.abs(this.scale.min)) * this.graphHeight,\n              width = this.graphWidth / this.data.length - prop.hmargin - prop.hmargin,\n              x = prop.gutterLeft + prop.hmargin + outerSegment * i;if (this.scale.min >= 0 && this.scale.max > 0) {\n            y = this.getYCoord(this.scale.min) - height;\n          } else if (this.scale.min < 0 && this.scale.max > 0) {\n            height = ma.abs(this.data[i]) / (this.scale.max - this.scale.min) * this.graphHeight;y = this.getYCoord(0) - height;if (this.data[i] < 0) {\n              y = this.getYCoord(0);\n            }\n          } else if (this.scale.min < 0 && this.scale.max < 0) {\n            height = (ma.abs(this.data[i]) - ma.abs(this.scale.max)) / (ma.abs(this.scale.min) - ma.abs(this.scale.max)) * this.graphHeight;y = prop.gutterTop;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: prop.variant === '3d' && this.data[i] < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width < 0 ? 0 : width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n            this.drawTop3dFace({ rect: rect, value: this.data[i] });this.drawSide3dFace({ rect: rect, value: this.data[i] });\n          }\n          if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = this.graphWidth / this.data.length,\n              innerSegment = outerSegment - 2 * prop.hmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = (innerSegment - (this.data[i].length - 1) * prop.hmarginGrouped) / this.data[i].length,\n                x = outerSegment * i + prop.hmargin + prop.gutterLeft + j * width + (j - 1) * prop.hmarginGrouped;x = prop.gutterLeft + outerSegment * i + width * j + prop.hmargin + j * prop.hmarginGrouped;if (this.scale.min === 0 && this.scale.max > this.scale.min) {\n              var height = (this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(0) - height;\n            } else if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n              var height = (this.data[i][j] - this.scale.max) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.max);height = ma.abs(height);\n            } else if (this.scale.max > 0 && this.scale.min < 0) {\n              var height = ma.abs(this.data[i][j]) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.data[i][j] < 0 ? this.getYCoord(0) : this.getYCoord(this.data[i][j]);\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var height = ma.abs(this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.min) - height;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: prop.variant === '3d' && this.data[i][j] < 0 ? this.threed_xaxis_group : this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = this.graphWidth / this.data.length;var y = this.getYCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var height = ma.round(this.data[i][j] / (this.max - this.min) * this.graphHeight),\n                width = section - 2 * prop.hmargin,\n                x = prop.gutterLeft + i * section + prop.hmargin,\n                y = y - height;if (j === 0 && prop.shadow) {\n              var fullHeight = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphHeight);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { fill: 'white', x: x, y: this.height - prop.gutterBottom - fullHeight, width: width, height: fullHeight, 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getYCoord = function (value) {\n      if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {}\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0,\n            stacked_total = 0;;for (var i = 0; i < this.coords.length; ++i, seq++) {\n          var num = typeof this.data[i] === 'number' ? this.data[i] : data_seq[seq];if (prop.grouping === 'stacked') {\n            var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);var group = indexes[0];var datapiece = indexes[1];if (datapiece !== this.data[group].length - 1) {\n              continue;\n            } else {\n              num = RG.SVG.arraySum(this.data[group]);\n            }\n          }\n          var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n            str = prop.labelsAboveSpecific[seq];\n          } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n            continue;\n          }\n          var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (data_seq[i] >= 0) {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n          } else {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n          }\n          RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.drawTop3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(255,255,255,0.7)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_top_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(255,255,255,0.7)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x, y, x + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w, y) } });rect.rgraph_3d_top_face[i] = face;\n      }\n    };this.drawSide3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(0,0,0,0.3)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_side_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(0,0,0,0.3)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x + w, y, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y + h - prop.variant3dOffsety, x + w, y + h) } });rect.rgraph_3d_side_face[i] = face;\n      }\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            height = ma.abs(obj.getYCoord(data[i]) - obj.getYCoord(0));obj.data[i] = data[i] * multiplier;height = multiplier * height;obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i] < 0 ? obj.getYCoord(0) : obj.getYCoord(0) - height);if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped') {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n              if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeHeight = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              height = ma.abs(obj.getYCoord(data[i][j]) - obj.getYCoord(0));height = multiplier * height;obj.data[i][j] = data[i][j] * multiplier;height = ma.round(height);obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i][j] < 0 ? obj.getYCoord(0) + accumulativeHeight : obj.getYCoord(0) - height - accumulativeHeight);if (prop.variant === '3d') {\n                if (obj.coords[seq].object.rgraph_3d_side_face[0].parentNode) obj.coords[seq].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[0]);if (obj.coords[seq].object.rgraph_3d_side_face[1].parentNode) obj.coords[seq].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[1]);if (obj.coords[seq].object.rgraph_3d_top_face[0].parentNode) obj.coords[seq].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[0]);if (obj.coords[seq].object.rgraph_3d_top_face[1].parentNode) obj.coords[seq].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[seq].object });obj.drawTop3dFace({ rect: obj.coords[seq].object });if (obj.coords[seq].object.parentNode) {\n                  var parent = obj.coords[seq].object.parentNode;var node = parent.removeChild(obj.coords[seq].object);parent.appendChild(node);\n                }\n              }\n              accumulativeHeight += prop.grouping === 'stacked' ? height : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('height', accumulativeHeight);obj.stackedBackfaces[i].setAttribute('y', obj.height - prop.gutterBottom - accumulativeHeight);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {};for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('height', 0);if (this.coords[i].object.rgraph_3d_side_face) {\n          this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[1]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[1]);\n        }\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalHeight = obj.coords[i].object.getAttribute('data-original-height'),\n                height,\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));var height = ma.min((frame - opt.startFrames[i]) / framesperbar * originalHeight, originalHeight);obj.coords[i].object.setAttribute('height', height < 0 ? 0 : height);obj.coords[i].object.setAttribute('y', value >= 0 ? obj.getYCoord(0) - height : obj.getYCoord(0));if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n            if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('y', parseInt(obj.coords[i - 1].object.getAttribute('y')) - height);\n              }\n            }\n            if (prop.variant === '3d') {\n              obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped' || prop.grouping === 'stacked' && indexes[1] + 1 === obj.data[indexes[0]].length) {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.bar.js\n// module id = 204\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.bar.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.AJAX = RGraph.SVG.AJAX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.SVG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.SVG.AJAX.getNumber = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.SVG.AJAX.getString = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.SVG.AJAX.getJSON = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.SVG.AJAX.getCSV = function (url, callback) {\n    var seperator = typeof arguments[2] === 'string' ? arguments[2] : ',',\n        lineSep = typeof arguments[3] === 'string' ? arguments[3] : \"\\r?\\n\";RG.SVG.AJAX(url, function () {\n      var text = this.responseText,\n          regexp = new RegExp(seperator),\n          lines = this.responseText.split(lineSep),\n          rows = [];for (var i = 0; i < lines.length; ++i) {\n        var row = lines[i].split(seperator);for (var j = 0, len = row.length; j < len; ++j) {\n          if (row[j].match(/^[0-9.]+$/)) {\n            row[j] = parseFloat(row[j]);\n          }\n        }\n        rows.push(row);\n      }\n      callback(rows);\n    });\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.ajax.js\n// module id = 205\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.ajax.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.REG = { store: [] };RG.SVG.OR = { objects: [] };RG.SVG.TRIG = {};RG.SVG.TRIG.HALFPI = ma.PI * .4999;RG.SVG.TRIG.PI = RG.SVG.TRIG.HALFPI * 2;RG.SVG.TRIG.TWOPI = RG.SVG.TRIG.PI * 2;RG.SVG.ISIE = ua.indexOf('rident') > 0;RG.SVG.ISFF = ua.indexOf('irefox') > 0;RG.SVG.events = [];RG.SVG.ISFF = ua.indexOf('Firefox') != -1;RG.SVG.ISOPERA = ua.indexOf('Opera') != -1;RG.SVG.ISCHROME = ua.indexOf('Chrome') != -1;RG.SVG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.SVG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.SVG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.SVG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.SVG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.SVG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.SVG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.SVG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.SVG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.SVG.ISIE10UP = RG.SVG.ISIE10 || RG.SVG.ISIE11UP;RG.SVG.ISIE9UP = RG.SVG.ISIE9 || RG.SVG.ISIE10UP;RG.SVG.createSVG = function (opt) {\n    var container = opt.container;if (container.__svg__) {\n      return container.__svg__;\n    }\n    var svg = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");svg.setAttribute('style', 'top: 0; left: 0; position: absolute');svg.setAttribute('width', container.offsetWidth);svg.setAttribute('height', container.offsetHeight);svg.setAttribute('version', '1.1');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", 'xmlns', 'http://www.w3.org/2000/svg');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");container.appendChild(svg);container.__svg__ = svg;container.style.position = 'relative';var group = RG.SVG.create({ svg: svg, type: 'g', attr: { className: 'all-elements' } });container.__svg__.all = group;return svg;\n  };RG.SVG.createDefs = function (obj) {\n    if (!obj.svg.defs) {\n      var defs = RG.SVG.create({ svg: obj.svg, type: 'defs' });obj.svg.defs = defs;\n    }\n    return defs;\n  };RG.SVG.create = function (opt) {\n    var ns = \"http://www.w3.org/2000/svg\",\n        tag = doc.createElementNS(ns, opt.type);for (var o in opt.attr) {\n      if (typeof o === 'string') {\n        var name = o;if (o === 'className') {\n          name = 'class';\n        }\n        if ((opt.type === 'a' || opt.type === 'image') && o === 'xlink:href') {\n          tag.setAttributeNS('http://www.w3.org/1999/xlink', o, String(opt.attr[o]));\n        } else {\n          tag.setAttribute(name, String(opt.attr[o]));\n        }\n      }\n    }\n    for (var o in opt.style) {\n      if (typeof o === 'string') {\n        tag.style[o] = String(opt.style[o]);\n      }\n    }\n    if (opt.parent) {\n      opt.parent.appendChild(tag);\n    } else {\n      opt.svg.appendChild(tag);\n    }\n    return tag;\n  };RG.SVG.drawXAxis = function (obj) {\n    var prop = obj.properties;if (prop.xaxis) {\n      var y = obj.type === 'hbar' ? obj.height - prop.gutterBottom : obj.getYCoord(obj.scale.min < 0 && obj.scale.max < 0 ? obj.scale.max : obj.scale.min > 0 && obj.scale.max > 0 ? obj.scale.min : 0);var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft, y + 0.01, obj.width - prop.gutterRight, y), fill: prop.xaxisColor, stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': 'crispEdges', 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.height - prop.gutterBottom,\n            endY = obj.height - prop.gutterBottom + prop.xaxisTickmarksLength;\n      } else {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.getYCoord(0) - (prop.yaxisMin < 0 ? prop.xaxisTickmarksLength : 0),\n            endY = obj.getYCoord(0) + prop.xaxisTickmarksLength;if (obj.scale.min < 0 && obj.scale.max <= 0) {\n          startY = prop.gutterTop;endY = prop.gutterTop - prop.xaxisTickmarksLength;\n        }\n        if (obj.scale.min > 0 && obj.scale.max > 0) {\n          startY = obj.getYCoord(obj.scale.min);endY = obj.getYCoord(obj.scale.min) + prop.xaxisTickmarksLength;\n        }\n      }\n      if (prop.xaxisTickmarks) {\n        if (prop.xaxisScale) {\n          for (var i = 0; i < obj.scale.numlabels + (prop.yaxis && prop.xaxisMin === 0 ? 0 : 1); ++i) {\n            if (obj.type === 'hbar') {\n              var dataPoints = obj.data.length;\n            }\n            x = prop.gutterLeft + (i + (prop.yaxis && prop.xaxisMin === 0 ? 1 : 0)) * (obj.graphWidth / obj.scale.numlabels);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        } else {\n          if (prop.xaxisLabelsPosition === 'section') {\n            if (obj.type === 'bar' || obj.type === 'waterfall') {\n              var dataPoints = obj.data.length;\n            } else if (obj.type === 'line') {\n              var dataPoints = obj.data[0].length;\n            } else if (obj.type === 'scatter') {\n              var dataPoints = prop.xaxisLabels ? prop.xaxisLabels.length : 10;\n            }\n            for (var i = 0; i < dataPoints; ++i) {\n              x = prop.gutterLeft + (i + 1) * (obj.graphWidth / dataPoints);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          } else if (prop.xaxisLabelsPosition === 'edge') {\n            if (typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number') {\n              var len = prop.xaxisLabelsPositionEdgeTickmarksCount;\n            } else {\n              var len = obj.data && obj.data[0] && obj.data[0].length ? obj.data[0].length : 0;\n            }\n            for (var i = 0; i < len; ++i) {\n              var gap = obj.graphWidth / (len - 1),\n                  x = prop.gutterLeft + (i + 1) * gap;RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          }\n        }\n        if (prop.yaxis === false) {\n          RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft + 0.001, startY, prop.gutterLeft, endY), stroke: obj.properties.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", parent: obj.svg.all } });\n        }\n      }\n    }\n    if (prop.xaxisScale) {\n      var segment = obj.graphWidth / prop.xaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var x = prop.gutterLeft + segment * i + segment + prop.xaxisLabelsOffsetx;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: x, y: obj.height - prop.gutterBottom + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n      if (prop.xaxisLabelsCount > 0) {\n        var y = obj.height - prop.gutterBottom + prop.xaxisLabelsOffsety + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10),\n            str = RG.SVG.numberFormat({ object: obj, num: prop.xaxisMin.toFixed(prop.xaxisDecimals), prepend: prop.xaxisUnitsPre, append: prop.xaxisUnitsPost, point: prop.xaxisPoint, thousand: prop.xaxisThousand, formatter: prop.xaxisFormatter });var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.xaxisFormatter === 'function' ? prop.xaxisFormatter(this, prop.xaxisMin) : str, x: prop.gutterLeft + prop.xaxisLabelsOffsetx, y: y, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n    } else {\n      if (_typeof(prop.xaxisLabels) === 'object' && !RG.SVG.isNull(prop.xaxisLabels)) {\n        if (prop.xaxisLabelsPosition === 'section') {\n          var segment = (obj.width - prop.gutterLeft - prop.gutterRight) / prop.xaxisLabels.length;for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + segment / 2 + i * segment;if (obj.scale.max <= 0 && obj.scale.min < obj.scale.max) {\n              var y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'bottom';\n            } else {\n              var y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'top';\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        } else if (prop.xaxisLabelsPosition === 'edge') {\n          if (obj.type === 'line') {\n            var hmargin = prop.hmargin;\n          } else {\n            var hmargin = 0;\n          }\n          var segment = (obj.graphWidth - hmargin - hmargin) / (prop.xaxisLabels.length - 1);for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + i * segment + hmargin;if (obj.scale.max <= 0 && obj.scale.min < 0) {\n              valign = 'bottom';y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisTickmarksLength - 5) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            } else {\n              valign = 'top';y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisTickmarksLength - 5) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        }\n      }\n    }\n  };RG.SVG.drawYAxis = function (obj) {\n    var prop = obj.properties;if (prop.yaxis) {\n      if (obj.type === 'hbar') {\n        var x = obj.getXCoord(prop.xaxisMin > 0 ? prop.xaxisMin : 0);if (prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          x = obj.getXCoord(prop.xaxisMax);\n        }\n      } else {\n        var x = prop.gutterLeft;\n      }\n      var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x, prop.gutterTop, x + 0.001, obj.height - prop.gutterBottom), stroke: prop.yaxisColor, fill: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var height = (obj.graphHeight - prop.vmarginTop - prop.vmarginBottom) / prop.yaxisLabels.length,\n            y = prop.gutterTop + prop.vmarginTop,\n            len = prop.yaxisLabels.length,\n            startX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0),\n            endX = obj.getXCoord(0) - prop.yaxisTickmarksLength;if (obj.type === 'hbar' && prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          startX = obj.getXCoord(prop.xaxisMax);endX = obj.getXCoord(prop.xaxisMax) + 5;\n        }\n        if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if (prop.xaxis === false) {\n            if (obj.type === 'hbar' && prop.xaxisMin <= 0 && prop.xaxisMax < 0) {\n              var startX = obj.getXCoord(prop.xaxisMax);var endX = obj.getXCoord(prop.xaxisMax) + prop.yaxisTickmarksLength;\n            } else {\n              var startX = obj.getXCoord(0) - prop.yaxisTickmarksLength;var endX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0);\n            }\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom), endX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom) - 0.001), stroke: obj.properties.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      } else {\n        var height = obj.graphHeight / prop.yaxisLabelsCount,\n            y = prop.gutterTop,\n            len = prop.yaxisLabelsCount,\n            startX = prop.gutterLeft,\n            endX = prop.gutterLeft - prop.yaxisTickmarksLength;if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if ((prop.yaxisMin !== 0 || prop.xaxis === false) && !(obj.scale.min > 0 && obj.scale.max > 0)) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft - prop.yaxisTickmarksLength, obj.height - prop.gutterBottom, prop.gutterLeft, obj.height - prop.gutterBottom - 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      }\n    }\n    if (prop.yaxisScale) {\n      var segment = (obj.height - prop.gutterTop - prop.gutterBottom) / prop.yaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var y = obj.height - prop.gutterBottom - segment * i - segment;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n      var y = obj.height - prop.gutterBottom,\n          str = prop.yaxisUnitsPre + prop.yaxisMin.toFixed(prop.yaxisDecimals).replace(/\\./, prop.yaxisPoint) + prop.yaxisUnitsPost;var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.yaxisFormatter === 'function' ? prop.yaxisFormatter(this, prop.yaxisMin) : str, x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n    } else if (prop.yaxisLabels && prop.yaxisLabels.length) {\n      for (var i = 0; i < prop.yaxisLabels.length; ++i) {\n        var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length,\n            y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsety,\n            x = prop.gutterLeft - 7 - (prop.yaxisLinewidth || 1) + prop.yaxisLabelsOffsetx,\n            halign = 'right';if (obj.type === 'hbar' && obj.scale.min < obj.scale.max && obj.scale.max <= 0) {\n          halign = 'left';x = obj.width - prop.gutterRight + 7 + prop.yaxisLabelsOffsetx;\n        } else if (obj.type === 'hbar' && !prop.yaxisLabelsSpecific) {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length;y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsetx;\n        } else {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / (prop.yaxisLabels.length - 1);y = obj.height - prop.gutterBottom - segment * i + prop.yaxisLabelsOffsetx;\n        }\n        var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.yaxisLabels[i] ? prop.yaxisLabels[i] : '', x: x, y: y, halign: halign, valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n    }\n  };RG.SVG.drawBackground = function (obj) {\n    var prop = obj.properties;if (typeof prop.variant3dOffsetx !== 'number') prop.variant3dOffsetx = 0;if (typeof prop.variant3dOffsety !== 'number') prop.variant3dOffsety = 0;if (prop.backgroundColor) {\n      RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'rect', attr: { x: -1 + prop.variant3dOffsetx, y: -1 - prop.variant3dOffsety, width: parseFloat(obj.svg.getAttribute('width')) + 2, height: parseFloat(obj.svg.getAttribute('height')) + 2, fill: prop.backgroundColor } });\n    }\n    if (prop.backgroundImage) {\n      var attr = { 'xlink:href': prop.backgroundImage, preserveAspectRatio: prop.backgroundImageAspect || 'none', x: prop.gutterLeft, y: prop.gutterTop };if (prop.backgroundImageStretch) {\n        attr.x = prop.gutterLeft + prop.variant3dOffsetx;attr.y = prop.gutterTop + prop.variant3dOffsety;attr.width = obj.width - prop.gutterLeft - prop.gutterRight;attr.height = obj.height - prop.gutterTop - prop.gutterBottom;\n      } else {\n        if (typeof prop.backgroundImageX === 'number') {\n          attr.x = prop.backgroundImageX + prop.variant3dOffsetx;\n        }\n        if (typeof prop.backgroundImageY === 'number') {\n          attr.y = prop.backgroundImageY + prop.variant3dOffsety;\n        }\n        if (typeof prop.backgroundImageW === 'number') {\n          attr.width = prop.backgroundImageW;\n        }\n        if (typeof prop.backgroundImageH === 'number') {\n          attr.height = prop.backgroundImageH;\n        }\n      }\n      if (prop.variant === '3d') {\n        attr.x += prop.variant3dOffsetx;attr.y -= prop.variant3dOffsety;\n      }\n      var img = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'image', attr: attr, style: { opacity: typeof prop.backgroundImageOpacity === 'number' ? prop.backgroundImageOpacity : 1 } });\n    }\n    if (prop.backgroundGrid) {\n      var parts = [];if (prop.backgroundGridHlines) {\n        var count = typeof prop.backgroundGridHlinesCount === 'number' ? prop.backgroundGridHlinesCount : obj.type === 'hbar' ? prop.yaxisLabels.length || obj.data.length || 5 : prop.yaxisLabelsCount;for (var i = 0; i < count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety));\n        }\n        parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      if (prop.backgroundGridVlines) {\n        if (obj.type === 'line' && RG.SVG.isArray(obj.data[0])) {\n          var len = obj.data[0].length;\n        } else if (obj.type === 'hbar') {\n          var len = prop.xaxisLabelsCount || 10;\n        } else if (obj.type === 'scatter') {\n          var len = prop.xaxisLabels && prop.xaxisLabels.length || 10;\n        } else {\n          var len = obj.data.length;\n        }\n        var count = typeof prop.backgroundGridVlinesCount === 'number' ? prop.backgroundGridVlinesCount : len;if (prop.xaxisLabelsPosition === 'edge') {\n          count--;\n        }\n        for (var i = 0; i <= count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n        }\n      }\n      if (prop.backgroundGridBorder) {\n        parts.push('M{1} {2} L{3} {4} L{5} {6} L{7} {8} z'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      var grid = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: parts.join(' '), stroke: prop.backgroundGridColor, fill: 'rgba(0,0,0,0)', 'stroke-width': prop.backgroundGridLinewidth, 'shape-rendering': \"crispEdges\" } });\n    }\n    RG.SVG.drawTitle(obj);\n  };RG.SVG.isNull = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.SVG.getScale = function (opt) {\n    var obj = opt.object,\n        prop = obj.properties,\n        numlabels = opt.numlabels,\n        unitsPre = opt.unitsPre,\n        unitsPost = opt.unitsPost,\n        max = Number(opt.max),\n        min = Number(opt.min),\n        strict = opt.strict,\n        decimals = Number(opt.decimals),\n        point = opt.point,\n        thousand = opt.thousand,\n        originalMax = max,\n        round = opt.round,\n        scale = { max: 1, labels: [], values: [] },\n        formatter = opt.formatter;if (max === 0 && min === 0) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = ((max - min) / numlabels * (i + 1) + min).toFixed(decimals);scale.labels.push(unitsPre + label + unitsPost);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.SVG.numberFormat({ object: obj, num: value, prepend: unitsPre, append: unitsPost, point: prop.yaxisPoint, thousand: prop.yaxisThousand, formatter: formatter }));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(originalMax) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(originalMax) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;for (var i = 0; i < numlabels; ++i) {\n        var label = RG.SVG.numberFormat({ object: obj, num: ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand, formatter: formatter });scale.labels.push(label);scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n    } else if (typeof max === 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.SVG.numberFormat({ object: obj, formatter: formatter, num: ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand }));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.unitsPre = unitsPre;scale.unitsPost = unitsPost;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.SVG.arrayFill = RG.SVG.arrayPad = function (opt) {\n    var arr = opt.array,\n        len = opt.length,\n        value = opt.value ? opt.value : null;if (arr.length < len) {\n      for (var i = arr.length; i < len; i += 1) {\n        arr[i] = value;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayMax = function (arr) {\n    var max = null;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.SVG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.SVG.arrayPad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayLinearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.SVG.arrayLinearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.SVG.arrayShift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.SVG.arrayReverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.SVG.arrayClone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    if (RG.SVG.isArray(obj)) {\n      var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n        if (typeof obj[i] === 'number') {\n          temp[i] = function (arg) {\n            return Number(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'string') {\n          temp[i] = function (arg) {\n            return String(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'function') {\n          temp[i] = obj[i];\n        } else {\n          temp[i] = RG.SVG.arrayClone(obj[i]);\n        }\n      }\n    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {\n      var temp = {};for (var i in obj) {\n        if (typeof i === 'string') {\n          temp[i] = obj[i];\n        }\n      }\n    }\n    return temp;\n  };RG.SVG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.SVG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.SVG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.SVG.arrayReverse(out2);return out2;\n  };RG.SVG.isArray = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.SVG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.SVG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.SVG.numberFormat = function (opt) {\n    var obj = opt.object,\n        prepend = opt.prepend ? String(opt.prepend) : '',\n        append = opt.append ? String(opt.append) : '',\n        output = '',\n        decimal_seperator = typeof opt.point === 'string' ? opt.point : '.',\n        thousand_seperator = typeof opt.thousand === 'string' ? opt.thousand : ',',\n        num = opt.num;RegExp.$1 = '';if (typeof opt.formatter === 'function') {\n      return opt.formatter(obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    } else {\n      decimal = '';\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + thousand_seperator) == 0) {\n      output = '-' + output.substr(('-' + thousand_seperator).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.SVG.text = function (opt) {\n    var obj = opt.object,\n        parent = opt.parent || opt.object.svg.all,\n        size = opt.size,\n        bold = opt.bold,\n        font = opt.font,\n        italic = opt.italic,\n        halign = opt.halign,\n        valign = opt.valign,\n        str = opt.text,\n        x = opt.x,\n        y = opt.y,\n        color = opt.color ? opt.color : 'black',\n        background = opt.background || null,\n        padding = opt.padding || 0;if (halign === 'right') {\n      halign = 'end';\n    } else if (halign === 'center' || halign === 'middle') {\n      halign = 'middle';\n    } else {\n      halign = 'start';\n    }\n    if (valign === 'top') {\n      valign = 'hanging';\n    } else if (valign === 'center' || valign === 'middle') {\n      valign = 'central';valign = 'middle';\n    } else {\n      valign = 'bottom';\n    }\n    var text = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'text', attr: { fill: color, x: x, y: y, 'font-size': typeof size === 'number' ? size + 'pt' : size, 'font-weight': bold ? 900 : 100, 'font-family': font ? font : 'sans-serif', 'font-style': italic ? 'italic' : 'normal', 'text-anchor': halign, 'dominant-baseline': valign } });var textNode = document.createTextNode(str);text.appendChild(textNode);if (typeof background === 'string') {\n      var bbox = text.getBBox(),\n          rect = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'rect', attr: { x: bbox.x - padding, y: bbox.y - padding, width: bbox.width + padding * 2, height: bbox.height + padding * 2, fill: background } });parent.insertBefore(rect, text);\n    }\n    if (RG.SVG.ISIE && valign === 'hanging') {\n      text.setAttribute('y', y + text.scrollHeight / 2);\n    } else if (RG.SVG.ISIE && valign === 'middle') {\n      text.setAttribute('y', y + text.scrollHeight / 3);\n    }\n    if (RG.SVG.ISFF) {\n      Y = y + text.scrollHeight / 3;\n    }\n    return text;\n  };RG.SVG.createUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.SVG.isFixed = function (svg) {\n    var obj = svg.parentNode,\n        i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position === 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.SVG.REG.set = function (name, value) {\n    RG.SVG.REG.store[name] = value;return value;\n  };RG.SVG.REG.get = function (name) {\n    return RG.SVG.REG.store[name];\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.hideTooltip = function () {\n    var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.parentNode) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.SVG.REG.set('tooltip', null);\n    }\n    if (tooltip && tooltip.__object__) {\n      RG.SVG.removeHighlight(tooltip.__object__);\n    }\n  };RG.SVG.setShadow = function (options) {\n    var obj = options.object,\n        offsetx = options.offsetx || 0,\n        offsety = options.offsety || 0,\n        blur = options.blur || 0,\n        opacity = options.opacity || 0,\n        id = options.id;var filter = RG.SVG.create({ svg: obj.svg, parent: obj.svg.defs, type: 'filter', attr: { id: id, width: \"130%\", height: \"130%\" } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feOffset', attr: { result: 'offOut', 'in': 'SourceGraphic', dx: offsetx, dy: offsety } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feColorMatrix', attr: { result: 'matrixOut', 'in': 'offOut', type: 'matrix', values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 {1} 0'.format(opacity) } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feGaussianBlur', attr: { result: 'blurOut', 'in': 'matrixOut', stdDeviation: blur } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feBlend', attr: { 'in': 'SourceGraphic', 'in2': 'blurOut', mode: 'normal' } });\n  };RG.SVG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0,\n        grouped_index = 0;while (--index >= 0) {\n      if (RG.SVG.isNull(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.SVG.TRIG.toCartesian = function (options) {\n    return { x: options.cx + options.r * ma.cos(options.angle), y: options.cy + options.r * ma.sin(options.angle) };\n  };RG.SVG.TRIG.getArcPath = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = options.end - options.start;var largeArc = '0';var sweep = '0';if (options.anticlockwise && diff > 3.14) {\n      largeArc = '0';sweep = '0';\n    } else if (options.anticlockwise && diff <= 3.14) {\n      largeArc = '1';sweep = '0';\n    } else if (!options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    } else if (!options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '1';\n    }\n    if (options.start > options.end && options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '0';\n    }\n    if (options.start > options.end && options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    }\n    if (typeof options.moveto === 'boolean' && options.moveto === false) {\n      var d = [\"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath2 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", options.cx, options.cy, \"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath3 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getRadiusEndPoint = function (opt) {\n    if (arguments.length === 1) {\n      var angle = opt.angle,\n          r = opt.r;\n    } else if (arguments.length === 4) {\n      var angle = arguments[0],\n          r = arguments[1];\n    }\n    var x = ma.cos(angle) * r,\n        y = ma.sin(angle) * r;return [x, y];\n  };RG.SVG.drawTitle = function (obj) {\n    var prop = obj.properties;var valign = 'bottom';if (obj.type === 'pie') {\n      if (RG.SVG.isNull(prop.titleX)) {\n        prop.titleX = obj.centerx;prop.titleSubtitleX = obj.centerx;\n      }\n      if (RG.SVG.isNull(prop.titleY)) {\n        prop.titleY = obj.centery - obj.radius - 10;\n      }\n    }\n    if (obj.scale && obj.scale.max <= 0 && obj.scale.min < 0 && typeof prop.titleY !== 'number' && obj.type !== 'hbar') {\n      prop.titleY = obj.height - prop.gutterBottom + 10;var positionBottom = true;valign = 'top';\n    } else if (typeof prop.titleY !== 'number') {\n      var positionBottom = false;prop.titleY = prop.gutterTop - 10;valign = 'bottom';if (!RG.SVG.isNull(prop.key)) {\n        prop.titleY -= 2 * (prop.keyTextSize || prop.textSize);\n      }\n    }\n    if (prop.titleSubtitle && typeof prop.titleSubtitleY !== 'number' && !positionBottom) {\n      prop.titleY = prop.titleY - prop.titleSubtitleSize * 1.5;\n    }\n    prop.titleSubTitleSize = prop.titleSubTitleSize || prop.textSize;prop.titleSubtitleY = prop.titleSubtitleY || prop.titleY + 18;if (positionBottom && typeof prop.titleSubtitleY !== 'number') {\n      prop.titleSubtitleY = prop.titleY + 26;\n    }\n    if (prop.title) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.title.toString(), size: prop.titleSize || prop.textSize + 4 || 16, x: typeof prop.titleX === 'number' ? prop.titleX + (prop.variant3dOffsetx || 0) : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleY + (prop.variant3dOffsety || 0), halign: prop.titleHalign || 'center', valign: prop.titleValign || valign, color: prop.titleColor || prop.textColor || 'black', bold: prop.titleBold || false, italic: prop.titleItalic || false, font: prop.titleFont || prop.textFont || 'Arial' });\n    }\n    if (prop.titleSubtitle) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.titleSubtitle, size: prop.titleSubtitleSize, x: typeof prop.titleSubtitleX === 'number' ? prop.titleSubtitleX : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleSubtitleY + (prop.variant3dOffsety || 0), halign: prop.titleSubtitleHalign || 'center', valign: prop.titleSubtitleValign || valign, color: prop.titleSubtitleColor || prop.textColor || '#aaa', bold: prop.titleSubtitleBold || false, italic: prop.titleSubtitleItalic || false, font: prop.titleSubtitleFont || prop.textFont || 'Arial' });\n    }\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return String(str).replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return String(str).replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.parseColorLinear = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);if (opt && opt.direction && opt.direction === 'horizontal') {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: opt.start || 0, x2: opt.end || '100%', y1: 0, y2: 0, gradientUnits: \"userSpaceOnUse\" } });\n      } else {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: 0, x2: 0, y1: opt.start || 0, y2: opt.end || '100%', gradientUnits: \"userSpaceOnUse\" } });\n      }\n      var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-linear-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.parseColorRadial = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);var grad = RG.SVG.create({ type: 'radialGradient', parent: obj.svg.defs, attr: { id: 'RGraph-radial-gradient' + obj.gradientCounter, gradientUnits: opt.gradientUnits || 'userSpaceOnUse', cx: opt.cx || obj.centerx, cy: opt.cy || obj.centery, fx: opt.fx || obj.centerx, fy: opt.fy || obj.centery, r: opt.r || obj.radius } });var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-radial-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.resetColorsToOriginalValues = function (opt) {\n    var obj = opt.object;if (obj.originalColors) {\n      for (var j in obj.originalColors) {\n        if (typeof j === 'string') {\n          obj.properties[j] = RG.SVG.arrayClone(obj.originalColors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.originalColors = {};obj.colorsParsed = false;obj.gradientCounter = 1;\n  };RG.SVG.clear = function (svg) {\n    while (svg.all.lastChild) {\n      svg.all.removeChild(svg.all.lastChild);\n    }\n  };RG.SVG.addCustomEventListener = function (obj, name, func) {\n    if (typeof RG.SVG.events[obj.uid] === 'undefined') {\n      RG.SVG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.SVG.events[obj.uid].push({ object: obj, event: name, func: func });return RG.SVG.events[obj.uid].length - 1;\n  };RG.SVG.fireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[uid]) === 'object' && RG.SVG.events[uid].length > 0) {\n        for (var j = 0, len = RG.SVG.events[uid].length; j < len; ++j) {\n          if (RG.SVG.events[uid][j] && RG.SVG.events[uid][j].event === name) {\n            RG.SVG.events[uid][j].func(obj);\n          }\n        }\n      }\n    }\n  };RG.SVG.removeAllCustomEventListeners = function () {\n    var uid = arguments[0];if (uid && RG.SVG.events[uid]) {\n      RG.SVG.events[uid] = {};\n    } else {\n      RG.SVG.events = [];\n    }\n  };RG.SVG.removeCustomEventListener = function (obj, i) {\n    if (_typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[obj.uid]) === 'object' && _typeof(RG.SVG.events[obj.uid][i]) === 'object') {\n      RG.SVG.events[obj.uid][i] = null;\n    }\n  };RG.SVG.removeHighlight = function (obj) {\n    var highlight = RG.SVG.REG.get('highlight');if (highlight && RG.SVG.isArray(highlight) && highlight.length) {\n      for (var i = 0, len = highlight.length; i < len; ++i) {\n        if (highlight[i].parentNode) {\n          highlight[i].parentNode.removeChild(highlight[i]);\n        }\n      }\n    } else if (highlight && highlight.parentNode) {\n      if (obj.type === 'scatter') {\n        highlight.setAttribute('fill', 'transparent');\n      } else {\n        highlight.parentNode.removeChild(highlight);\n      }\n    }\n  };RG.SVG.redraw = function () {\n    if (arguments.length === 1) {\n      var svg = arguments[0];RG.SVG.clear(svg);var objects = RG.SVG.OR.get('id:' + svg.parentNode.id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.SVG.resetColorsToOriginalValues({ object: objects[i] });objects[i].draw();\n      }\n    } else {\n      var tags = RG.SVG.OR.tags();for (var i in tags) {\n        RG.SVG.redraw(tags[i]);\n      }\n    }\n  };RG.SVG.parseDate = function (str) {\n    var d = new Date();var defaults = { seconds: '00', minutes: '00', hours: '00', date: d.getDate(), month: d.getMonth() + 1, year: d.getFullYear() };var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'],\n        months_regex = months.join('|');for (var i = 0; i < months.length; ++i) {\n      months[months[i]] = i;months[months[i].substring(0, 3)] = i;months_regex = months_regex + '|' + months[i].substring(0, 3);\n    }\n    var sep = '[-./_=+~#:;,]+';var tokens = str.split(/ +/);for (var i = 0, len = tokens.length; i < len; ++i) {\n      if (tokens[i]) {\n        if (tokens[i].match(/^\\d\\d\\d\\d$/)) {\n          defaults.year = tokens[i];\n        }\n        var res = isMonth(tokens[i]);if (typeof res === 'number') {\n          defaults.month = res + 1;\n        }\n        if (tokens[i].match(/^\\d?\\d(?:st|nd|rd|th)?$/)) {\n          defaults.date = parseInt(tokens[i]);\n        }\n        if (tokens[i].match(/^(\\d\\d):(\\d\\d)(?:(\\d\\d))?$/)) {\n          defaults.hours = parseInt(RegExp.$1);defaults.minutes = parseInt(RegExp.$2);if (RegExp.$3) {\n            defaults.seconds = parseInt(RegExp.$3);\n          }\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$3);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$1);\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$1);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$3);\n        }\n      }\n    }\n    str = '{1}/{2}/{3} {4}:{5}:{6}'.format(defaults.year, String(defaults.month).length === 1 ? '0' + defaults.month : defaults.month, String(defaults.date).length === 1 ? '0' + defaults.date : defaults.date, String(defaults.hours).length === 1 ? '0' + defaults.hours : defaults.hours, String(defaults.minutes).length === 1 ? '0' + defaults.minutes : defaults.minutes, String(defaults.seconds).length === 1 ? '0' + defaults.seconds : defaults.seconds);return Date.parse(str);function isMonth(str) {\n      var res = str.toLowerCase().match(months_regex);return res ? months[res[0]] : false;\n    }\n  };RG.SVG.OR.add = function (obj) {\n    RG.SVG.OR.objects.push(obj);return obj;\n  };RG.SVG.OR.get = function () {\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'id:') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].id === arguments[0].substr(3)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 4).toLowerCase() === 'type') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].type === arguments[0].substr(5)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'uid') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].uid === arguments[0].substr(4)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    return RG.SVG.OR.objects;\n  };RG.SVG.OR.tags = function () {\n    var tags = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n      if (!tags[RG.SVG.OR.objects[i].svg.parentNode.id]) {\n        tags[RG.SVG.OR.objects[i].svg.parentNode.id] = RG.SVG.OR.objects[i].svg;\n      }\n    }\n    return tags;\n  };RG.SVG.getSVGXY = function (svg) {\n    var x = 0,\n        y = 0,\n        el = svg.parentNode;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.SVG.ISCHROME || RG.SVG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName && el.tagName.toLowerCase() != 'body');var paddingLeft = svg.style.paddingLeft ? parseInt(svg.style.paddingLeft) : 0,\n        paddingTop = svg.style.paddingTop ? parseInt(svg.style.paddingTop) : 0,\n        borderLeft = svg.style.borderLeftWidth ? parseInt(svg.style.borderLeftWidth) : 0,\n        borderTop = svg.style.borderTopWidth ? parseInt(svg.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.SVG.FX.update = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.SVG.FX.getEasingMultiplier = function (frames, frame) {\n    var multiplier = ma.pow(ma.sin(frame / frames * RG.SVG.TRIG.HALFPI), 3);return multiplier;\n  };RG.SVG.measureText = function (opt) {\n    var text = opt.text || '',\n        bold = opt.bold || false,\n        font = opt.font || 'Arial',\n        size = opt.size || 10,\n        str = text + ':' + bold + ':' + font + ':' + size;if (typeof RG.SVG.measuretext_cache === 'undefined') {\n      RG.SVG.measuretext_cache = [];\n    }\n    if (_typeof(RG.SVG.measuretext_cache) == 'object' && RG.SVG.measuretext_cache[str]) {\n      return RG.SVG.measuretext_cache[str];\n    }\n    if (!RG.SVG.measuretext_cache['text-span']) {\n      var span = document.createElement('SPAN');span.style.position = 'absolute';span.style.padding = 0;span.style.display = 'inline';span.style.top = '-200px';span.style.left = '-200px';span.style.lineHeight = '1em';document.body.appendChild(span);RG.SVG.measuretext_cache['text-span'] = span;\n    } else if (RG.SVG.measuretext_cache['text-span']) {\n      var span = RG.SVG.measuretext_cache['text-span'];\n    }\n    span.innerHTML = text.replace(/\\r\\n/g, '<br />');span.style.fontFamily = font;span.style.fontWeight = bold ? 'bold' : 'normal';span.style.fontSize = size + 'pt';var sizes = [span.offsetWidth, span.offsetHeight];RG.SVG.measuretext_cache[str] = sizes;return sizes;\n  };RG.SVG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.SVG.getAdjustedNumber = function (opt) {\n    var value = opt.value,\n        prop = opt.prop;if (typeof prop === 'string' && match(/^(\\+|-)([0-9.]+)/)) {\n      if (RegExp.$1 === '+') {\n        value += parseFloat(RegExp.$2);\n      } else if (RegExp.$1 === '-') {\n        value -= parseFloat(RegExp.$2);\n      }\n    }\n    return value;\n  };RG.SVG.attribution = function (obj) {\n    return;\n  };RG.SVG.parseGradient = function (str) {};RG.SVG.random = function (opt) {\n    var min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0,\n        r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.SVG.arrayRand = RG.SVG.arrayRandom = RG.SVG.random.array = function (opt) {\n    var num = opt.num,\n        min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0;for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.SVG.random({ min: min, max: max, dp: dp }));\n    }\n    return arr;\n  };RG.SVG.commonSetter = function (opt) {\n    var obj = opt.object,\n        name = opt.name,\n        value = opt.value;if (name === 'tooltipsEvent' && value !== 'click' && value !== 'mousemove') {\n      value = 'click';\n    }\n    return { name: name, value: value };\n  };RG.SVG.log = function (opt) {\n    var num = opt.num,\n        base = opt.base;return ma.log(num) / (base ? ma.log(base) : 1);\n  };RG.SVG.donut = function (opt) {\n    var arcPath1 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.outerRadius, start: 0, end: RG.SVG.TRIG.TWOPI, anticlockwise: false, lineto: false });var arcPath2 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.innerRadius, start: RG.SVG.TRIG.TWOPI, end: 0, anticlockwise: true, lineto: false });var path = RG.SVG.create({ svg: opt.svg, type: 'path', attr: { d: arcPath1 + arcPath2, stroke: opt.stroke, fill: opt.fill } });return path;\n  };if (typeof RG.SVG.tooltip !== 'function') {\n    RG.SVG.tooltip = function () {\n      $a('The tooltip library has not been included!');\n    };\n  }\n})(window, document);window.$p = function (obj) {\n  var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n    return '';\n  }\n  switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n      str += 'function () {}';break;case 'undefined':\n      str += 'undefined';break;case 'null':\n      str += 'null';break;case 'object':\n      if (RGraph.SVG.isNull(obj)) {\n        str += indent + 'null\\n';\n      } else {\n        str += indent + 'Object {' + '\\n';\n        for (j in obj) {\n          str += indent + '    ' + j + ' => ' + window.$p(obj[j], true, indent + '    ', counter + 1) + '\\n';\n        }\n        str += indent + '}';\n      }\n      break;default:\n      str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n  if (!arguments[1]) {\n    alert(str);\n  }\n  return str;\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.core.js\n// module id = 206\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.core.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.SVG.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.csv.js\n// module id = 207\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.csv.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.FX.decorate = function (obj) {\n    for (i in RG.SVG.FX) {\n      if (typeof RG.SVG.FX[i] === 'function') {\n        obj[i] = RG.SVG.FX[i];\n      }\n    }\n  };RG.SVG.FX.fadein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};obj.svg.style.opacity = 0;RG.SVG.redraw(this.svg);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeslidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(this.container));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadeslideout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularinoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 1,\n        radius = 0,\n        svgXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadecircularinoutwards_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, ' + color + ' ' + radius + '%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, transparent 0%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularininwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(obj.container.offsetWidth, obj.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutinwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(this.container.offsetWidth, this.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + this.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.reveal = function () {\n    var obj = this,\n        opt = arguments[0] || {};\n    color = opt.color || 'white', frames = opt.frames || 90, duration = frames / 60 * 1000, callback = opt.callback || function () {};\n    var divs = [['rgraph_reveal_left_' + this.id, 0, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_right_' + this.id, this.container.offsetWidth / 2, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_top_' + this.id, 0, 0, this.container.offsetWidth, this.container.offsetHeight / 2], ['rgraph_reveal_bottom_' + this.id, 0, this.container.offsetHeight / 2, this.container.offsetWidth, this.container.offsetHeight / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    RG.SVG.redraw(obj.svg);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + this.container.offsetWidth / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + this.container.offsetHeight / 2, height: 0 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.conceal = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        duration = frames / 60 * 1000,\n        frame = 0;var divs = [['rgraph_conceal_left_' + obj.id, 0, 0, 0, this.container.offsetHeight], ['rgraph_conceal_right_' + obj.id, this.container.offsetWidth, 0, 0, this.container.offsetHeight], ['rgraph_conceal_top_' + obj.id, 0, 0, this.container.offsetWidth, 0], ['rgraph_conceal_bottom_' + obj.id, 0, this.container.offsetHeight, this.container.offsetWidth, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + this.container.offsetWidth / 2, width: this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + this.container.offsetHeight / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + this.container.offsetHeight / 2, height: this.container.offsetHeight / 2 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.SVG.clear(obj.svg);callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color = 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.SVG.FX.vblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(obj.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;obj.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.vblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.width = 0;div.style.height = this.container.offsetHeight + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.slidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10,\n        from = opt.from || 'left';this.container.style.overflow = 'hidden';RG.SVG.redraw(this.svg);this.svg.style.position = 'relative';if (from == 'left') {\n      this.svg.style.left = 0 - this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    } else if (from == 'top') {\n      this.svg.style.left = 0;this.svg.style.top = 0 - this.container.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      this.svg.style.left = 0;this.svg.style.top = this.container.offsetHeight + 'px';\n    } else {\n      this.svg.style.left = this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    }\n    jQuery(this.svg).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.SVG.FX.slideout = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        width = this.container.offetsWidth / 10;this.container.style.overflow = 'hidden';this.svg.style.position = 'relative';this.svg.style.left = 0;this.svg.style.top = 0;if (to == 'left') {\n      jQuery(this.svg).animate({ left: 0 - this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'top') {\n      jQuery(this.svg).animate({ left: 0, top: 0 - this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'bottom') {\n      jQuery(this.svg).animate({ top: 0 + this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else {\n      jQuery(this.svg).animate({ left: 0 + this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    }\n    return this;\n  };RG.SVG.FX.hscissorsopen = function () {\n    var opt = arguments[0] || {},\n        obj = this,\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        frame = 0,\n        duration = frames / 60 * 1000,\n        width = this.container.offsetWidth / 10,\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: this.container.offsetWidth + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 60,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? this.container.offsetWidth : 0) + 'px';div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: 0, width: this.container.offsetWidth + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: this.container.offsetWidth + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(this.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: this.container.offsetHeight + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = width * i + 'px';div.style.top = (i % 2 == 0 ? this.container.offsetHeight : 0) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: 0, height: this.container.offsetHeight + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: this.container.offsetHeight + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.fx.js\n// module id = 208\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.fx.js?")},function(module,exports){eval("// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\nRGraph.SVG.HTML = RGraph.SVG.HTML || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math;\n\n    /**\n    * Draws the graph key (used by various graphs)\n    * \n    * @param object obj The graph object\n    * @param array  key An array of the texts to be listed in the key\n    * @param colors An array of the colors to be used\n    */\n    RG.SVG.drawKey = function (obj) {\n        var prop = obj.properties,\n            key = prop.key,\n            colors = prop.keyColors || prop.colors,\n            defaultFont = 'Arial',\n            blobSize = 0,\n            width = 0;\n\n        // Work out the center point of the SVG tag\n        var centerx = obj.svg.getAttribute('width') / 2;\n\n        // First measure the length so that the key can be centered\n        for (var i = 0, length = 0; i < key.length; i++) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            blobSize = ma.max(blobSize, textDimensions[1]);\n\n            width = width + 10 + blobSize + 5 + textDimensions[0];\n        }\n\n        // Center the key\n        x = centerx - width / 2;\n\n        // Loop thru the key and draw them\n        for (var i = 0, y = prop.gutterTop - 5; i < key.length; ++i) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            RG.SVG.create({\n                svg: obj.svg,\n                type: 'rect',\n                parent: obj.svg.all,\n                attr: {\n                    x: x + prop.keyOffsetx,\n                    y: y - blobSize + prop.keyOffsety,\n                    width: blobSize,\n                    height: blobSize,\n                    fill: colors[i]\n                }\n            });\n\n            RGraph.SVG.text({\n                object: obj,\n                parent: obj.svg.all,\n                size: prop.keyTextSize || prop.textSize,\n                bold: prop.keyTextBold || false,\n                font: 'Arial',\n                italic: prop.keyTextItalic || false,\n                halign: 'left',\n                valign: 'bottom',\n                text: key[i],\n                x: x + blobSize + 5 + prop.keyTextOffsetx + prop.keyOffsetx,\n                y: y + prop.keyTextOffsety + prop.keyOffsety,\n                color: 'black',\n                background: 'white',\n                padding: 0\n            });\n\n            x += 10 + blobSize + 5 + textDimensions[0];\n        }\n    };\n\n    /**\n    * Create a TABLE based HTML key. There's lots of options so it's\n    * suggested that you consult the documentation page\n    * \n    * @param mixed id   This should be a string consisting of the ID of the container\n    * @param object prop An object map of the various properties that you can use to\n    *                    configure the key. See the documentation page for a list.\n    */\n    RG.SVG.HTML.key = function (id, prop) {\n        var div = doc.getElementById(id);\n\n        /**\n        * Create the table that becomes the key\n        */\n        var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n            var style = '';\n            for (i in prop.tableCss) {\n                if (typeof i === 'string') {\n                    style = style + i + ': ' + prop.tableCss[i] + ';';\n                }\n            }\n            return style;\n        }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';\n\n        /**\n        * Add the individual key elements\n        */\n        for (var i = 0; i < prop.labels.length; i += 1) {\n            str += '<tr><td><div style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.blobCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.blobCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.labelCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.labelCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + '\" ' + function () {\n                var style = '';\n\n                if (prop['labelCss_' + i]) {\n                    for (var j in prop['labelCss_' + i]) {\n                        style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n                    }\n                }\n\n                return style ? 'style=\"' + style + '\"' : '';\n            }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n        }\n\n        div.innerHTML += str + '</table>';\n\n        // Return the TABLE object that is the HTML key\n        return doc.getElementById('rgraph_key');\n    };\n\n    // End module pattern\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.key.js\n// module id = 209\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.key.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.SVG.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.SVG.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.SVG.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.sheets.js\n// module id = 210\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.sheets.js?")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.tooltips = {};RG.SVG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '12pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', transition: 'left ease-out .25s, top ease-out .25s' };RG.SVG.tooltip = function (opt) {\n    var obj = opt.object;RG.SVG.fireCustomEvent(obj, 'onbeforetooltip');if (!opt.text || typeof opt.text === 'undefined' || RG.SVG.trim(opt.text).length === 0) {\n      return;\n    }\n    var prop = obj.properties;if (typeof prop.tooltipsOverride === 'function') {\n      return prop.tooltipsOverride(obj, opt);\n    }\n    if (!RG.SVG.REG.get('tooltip')) {\n      var tooltipObj = document.createElement('DIV');tooltipObj.className = prop.tooltipsCssClass;for (var i in RG.SVG.tooltips.style) {\n        if (typeof i === 'string') {\n          tooltipObj.style[i] = RG.SVG.tooltips.style[i];\n        }\n      }\n    } else {\n      var tooltipObj = RG.SVG.REG.get('tooltip');tooltipObj.__object__.removeHighlight();tooltipObj.style.width = '';\n    }\n    if (RG.SVG.REG.get('tooltip-lasty')) {\n      tooltipObj.style.left = RG.SVG.REG.get('tooltip-lastx') + 'px';tooltipObj.style.top = RG.SVG.REG.get('tooltip-lasty') + 'px';\n    }\n    tooltipObj.innerHTML = opt.text;tooltipObj.__text__ = opt.text;tooltipObj.id = '__rgraph_tooltip_' + obj.id + '_' + obj.uid + '_' + opt.index;tooltipObj.__event__ = prop.tooltipsEvent || 'click';tooltipObj.__object__ = obj;if (typeof opt.index === 'number') {\n      tooltipObj.__index__ = opt.index;\n    }\n    if (typeof opt.dataset === 'number') {\n      tooltipObj.__dataset__ = opt.dataset;\n    }\n    if (typeof opt.group === 'number' || RG.SVG.isNull(opt.group)) {\n      tooltipObj.__group__ = opt.group;\n    }\n    if (typeof opt.sequentialIndex === 'number') {\n      tooltipObj.__sequentialIndex__ = opt.sequentialIndex;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth,\n        height = tooltipObj.offsetHeight;tooltipObj.style.left = opt.event.pageX - width / 2 + 'px';tooltipObj.style.top = opt.event.pageY - height - 15 + 'px';tooltipObj.style.width = width + 'px';if (!RG.SVG.REG.get('tooltip-lastx')) {\n      for (var i = 0; i <= 30; ++i) {\n        (function (idx) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = idx / 30 * 1;\n          }, idx / 30 * 200);\n        })(i);\n      }\n    }\n    if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.SVG.isFixed(obj.svg)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = opt.event.pageY - scrollTop - height - 10 + 'px';\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };document.body.addEventListener('mouseup', function (e) {\n      RG.SVG.hideTooltip();\n    }, false);RG.SVG.REG.set('tooltip', tooltipObj);RG.SVG.REG.set('tooltip-lastx', parseFloat(tooltipObj.style.left));RG.SVG.REG.set('tooltip-lasty', parseFloat(tooltipObj.style.top));RG.SVG.fireCustomEvent(obj, 'ontooltip');\n  };\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.common.tooltips.js\n// module id = 211\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.common.tooltips.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.HBar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'hbar';this.coords = [];this.stackedBackfaces = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 100, gutterRight: 35, gutterTop: 35, gutterBottom: 35, gutterLeftAutosize: true, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', vmargin: 3, vmarginGrouped: 2, vmarginTop: 0, vmarginBottom: 0, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisColor: 'black', xaxisLabels: [], xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsCount: 5, xaxisScale: true, xaxisUnitsPre: '', xaxisUnitsPost: '', xaxisStrict: false, xaxisDecimals: 0, xaxisPoint: '.', xaxisThousand: ',', xaxisRound: false, xaxisMax: null, xaxisMin: 0, xaxisFormatter: null, xaxisLabelsPositionEdgeTickmarksCount: null, xaxisTextColor: null, xaxisTextBold: null, xaxisTextItalic: null, xaxisTextFont: null, xaxisTextSize: null, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisLabels: [], yaxisLabelsPosition: 'section', yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisScale: false, yaxisLabelsPositionEdgeTickmarksCount: null, yaxisColor: 'black', yaxisTextFont: null, yaxisTextSize: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'left', labelsAboveValign: 'center', labelsAboveSpecific: null, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleSize: 10, titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);if (prop.gutterLeftAutosize) {\n        for (var i = 0, len = prop.yaxisLabels.length, maxLength = 0; i < len; ++i) {\n          var sizes = RG.SVG.measureText({ text: prop.yaxisLabels[i], bold: prop.yaxisTextBold || prop.textBold, size: prop.yaxisTextSize || prop.textSize, font: prop.yaxisTextFont || prop.textFont });maxLength = ma.max(maxLength, sizes[0]);\n        }\n        prop.gutterLeft = maxLength + 15;\n      }\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.xaxisMax === 'number') {\n        max = prop.xaxisMax;\n      }\n      if (prop.xaxisMin === 'mirror' || prop.xaxisMin === 'middle' || prop.xaxisMin === 'center') {\n        var mirrorScale = true;prop.xaxisMin = prop.xaxisMax * -1;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: max, min: prop.xaxisMin, point: prop.xaxisPoint, round: prop.xaxisRound, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.xaxisPoint, round: false, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });\n      }\n      this.max = this.scale.max;prop.xaxisMax = this.scale.max;this.min = this.scale.min;prop.xaxisMin = this.scale.min;RG.SVG.drawBackground(this);this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              width = this.getWidth(this.data[i]),\n              height = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length - prop.vmargin - prop.vmargin,\n              x = this.getXCoord(this.scale.min < 0 && this.scale.max < 0 || this.scale.min > 0 && this.scale.max > 0 ? this.scale.min : 0) - (this.data[i] < 0 ? width : 0),\n              y = prop.gutterTop + prop.vmarginTop + prop.vmargin + outerSegment * i;if (this.scale.min < 0 && this.scale.max < 0) {\n            x = this.width - prop.gutterRight - width;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-original-width': width, 'data-original-height': height, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              innerSegment = outerSegment - 2 * prop.vmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = (innerSegment - (this.data[i].length - 1) * prop.vmarginGrouped) / this.data[i].length,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerSegment * i + j * height + j * prop.vmarginGrouped,\n                x = this.getXCoord(0) - (this.data[i][j] < 0 ? width : 0);if (this.scale.max < 0 && this.scale.min < this.scale.max) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.max);x = x1;width = x2 - x1;\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.min);x = this.getXCoord(this.scale.min);width = x1 - x2;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-width': width, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length;var x = this.getXCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var outerHeight = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n                width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = outerHeight - 2 * prop.vmargin,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerHeight * i;if (j === 0 && prop.shadow) {\n              var fullWidth = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphWidth);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: x, y: y, width: fullWidth, height: height, fill: 'white', 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-width': width, 'data-original-height': height, 'data-original-x': x, 'data-original-y': y, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n            x += width;\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getXCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var x;if (value < this.scale.min) {\n        return null;\n      }\n      x = (value - this.scale.min) / (this.scale.max - this.scale.min);x *= this.graphWidth;x += prop.gutterLeft;return x;\n    };this.getWidth = function (value) {\n      if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n        var x1 = this.getXCoord(this.scale.max);var x2 = this.getXCoord(value);\n      } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n        var x1 = this.getXCoord(this.scale.min);var x2 = this.getXCoord(value);\n      } else {\n        var x1 = this.getXCoord(0);var x2 = this.getXCoord(value);\n      }\n      return ma.abs(x1 - x2);\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i], direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data = RG.SVG.arrayLinearize(this.data);for (var i = 0; i < this.coords.length; ++i) {\n          var value = data[i].toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);if (RG.SVG.isArray(this.data[indexes[0]]) && prop.grouping === 'stacked') {\n            if (indexes[1] + 1 === this.data[indexes[0]].length) {\n              value = RG.SVG.arraySum(this.data[indexes[0]]);value = value.toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);\n            } else {\n              continue;\n            }\n          }\n          var str = prop.labelsAboveSpecific ? prop.labelsAboveSpecific[i].toString() : RG.SVG.numberFormat({ object: this, num: value, prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });var bold = typeof prop.labelsAboveBold === 'boolean' ? prop.labelsAboveBold : prop.textBold,\n              italic = typeof prop.labelsAboveItalic === 'boolean' ? prop.labelsAboveItalic : prop.textItalic,\n              size = prop.labelsAboveSize || prop.textSize,\n              font = prop.labelsAboveFont || prop.textFont,\n              halign = prop.labelsAboveHalign,\n              valign = prop.labelsAboveValign;var dimensions = RG.SVG.measureText({ text: str, bold: bold, font: font, size: size });var x = value >= 0 ? parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width')) + 7 + prop.labelsAboveOffsetx : parseFloat(this.coords[i].object.getAttribute('x') - 7 - prop.labelsAboveOffsetx),\n              y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height') / 2) + prop.labelsAboveOffsety,\n              width = dimensions[0],\n              height = dimensions[1],\n              halign = value >= 0 ? 'left' : 'right';if (x + width > this.width && value > 0) {\n            halign = 'right';x = this.width - 5;prop.labelsAboveBackground = prop.labelsAboveBackground || 'rgba(255,255,255,0.95)';\n          }\n          var text = RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: halign, valign: valign, font: font, size: size, bold: bold, italic: italic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            width = ma.abs(obj.getXCoord(data[i]) - obj.getXCoord(0));obj.data[i] = data[i] * multiplier;width = multiplier * width;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i] > 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeWidth = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              width = ma.abs(obj.getXCoord(data[i][j]) - obj.getXCoord(0));width = multiplier * width;obj.data[i][j] = data[i][j] * multiplier;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i][j] > 0 ? obj.getXCoord(0) + accumulativeWidth : obj.getXCoord(0) - width - accumulativeWidth);accumulativeWidth += prop.grouping === 'stacked' ? width : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('width', accumulativeWidth);obj.stackedBackfaces[i].setAttribute('x', prop.gutterLeft);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {},\n          width;for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('width', 0);\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalWidth = obj.coords[i].object.getAttribute('data-original-width'),\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));obj.coords[i].object.setAttribute('width', width = ma.min((frame - opt.startFrames[i]) / framesperbar * originalWidth, originalWidth));obj.coords[i].object.setAttribute('x', value >= 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('x', parseInt(obj.coords[i - 1].object.getAttribute('x')) + parseInt(obj.coords[i - 1].object.getAttribute('width')));\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.hbar.js\n// module id = 212\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.hbar.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Line = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));if (RG.SVG.isArray(conf.data) && RG.SVG.isArray(conf.data[0])) {\n      this.data = RG.SVG.arrayClone(conf.data);\n    } else if (RG.SVG.isArray(conf.data)) {\n      this.data = [RG.SVG.arrayClone(conf.data)];\n    } else {\n      this.data = [[]];\n    }\n    this.type = 'line';this.coords = [];this.coords2 = [];this.coordsSpline = [];this.hasMultipleDatasets = _typeof(this.data[0]) === 'object' && _typeof(this.data[1]) === 'object' ? true : false;this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.originalData = RG.SVG.arrayClone(this.data);RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageStretch: true, backgroundImageAspect: 'none', backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', 'blue', '#ff0', '#0ff', 'green'], filled: false, filledColors: [], filledClick: null, filledOpacity: 1, filledAccumulative: false, hmargin: 0, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsPosition: 'edge', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarksStyle: 'none', tickmarksSize: 5, tickmarksFill: 'white', tickmarksLinewidth: 1, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.7)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: -10, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, spline: false, title: '', titleSize: null, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: null, titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.coords = [];this.coords2 = [];this.coordsSpline = [];this.data = RG.SVG.arrayClone(this.originalData);this.tooltipsSequentialIndex = 0;var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && (!prop.filled || !prop.filledAccumulative)) {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.filled && prop.filledAccumulative) {\n          for (var j = 0; j < this.data[i].length; ++j) {\n            values[j] = values[j] || 0;values[j] = values[j] + this.data[i][j];this.data[i][j] = values[j];\n          }\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);for (var i = 0; i < this.data.length; ++i) {\n        this.drawLine(this.data[i], i);\n      }\n      this.redrawLines();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      this.drawLabelsAbove();RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawLine = function (data, index) {\n      var coords = [],\n          path = [];for (var i = 0, len = data.length; i < len; ++i) {\n        var val = data[i],\n            x = (this.graphWidth - prop.hmargin - prop.hmargin) / (len - 1) * i + prop.gutterLeft + prop.hmargin,\n            y = this.getYCoord(val);coords.push([x, y]);\n      }\n      for (var i = 0; i < coords.length; ++i) {\n        if (i === 0 || RG.SVG.isNull(data[i]) || RG.SVG.isNull(data[i - 1])) {\n          var action = 'M';\n        } else {\n          var action = 'L';\n        }\n        path.push(action + '{1} {2}'.format(coords[i][0], coords[i][1]));\n      }\n      this.coords[index] = RG.SVG.arrayClone(coords);this.coords2[index] = RG.SVG.arrayClone(coords);if (prop.spline) {\n        this.coordsSpline[index] = this.drawSpline(coords);\n      }\n      if (prop.filled === true || _typeof(prop.filled) === 'object' && prop.filled[index]) {\n        if (prop.spline) {\n          var fillPath = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n            fillPath.push('L{1} {2}'.format(this.coordsSpline[index][i][0] + (i === this.coordsSpline[index].length - 1 ? 1 : 0), this.coordsSpline[index][i][1]));\n          }\n        } else {\n          var fillPath = RG.SVG.arrayClone(path);\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][this.coords[index].length - 1][0] + 1, index > 0 && prop.filledAccumulative ? prop.spline ? this.coordsSpline[index - 1][this.coordsSpline[index - 1].length - 1][1] : this.coords[index - 1][this.coords[index - 1].length - 1][1] : this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));if (index > 0 && prop.filledAccumulative) {\n          var path2 = RG.SVG.arrayClone(path);if (index > 0 && prop.filledAccumulative) {\n            if (prop.spline) {\n              for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]));\n              }\n            } else {\n              for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n              }\n            }\n          }\n        } else {\n          fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.coords[index][0][1]));for (var i = 0; i < this.data[index].length; ++i) {\n          if (!RG.SVG.isNull(this.data[index][i])) {\n            fillPath.push('L{1} {2}'.format(this.coords[index][i][0], this.getYCoord(0)));break;\n          }\n        }\n        var fillPathObject = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: fillPath.join(' '), stroke: 'rgba(0,0,0,0)', 'fill': prop.filledColors && prop.filledColors[index] ? prop.filledColors[index] : prop.colors[index], 'fill-opacity': prop.filledOpacity, 'stroke-width': 1, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });if (prop.filledClick) {\n          var obj = this;fillPathObject.addEventListener('click', function (e) {\n            prop.filledClick(e, obj, index);\n          }, false);fillPathObject.addEventListener('mousemove', function (e) {\n            e.target.style.cursor = 'pointer';\n          }, false);\n        }\n      }\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      if (prop.spline) {\n        var str = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n          str.push('L{1} {2}'.format(this.coordsSpline[index][i][0], this.coordsSpline[index][i][1]));\n        }\n        str = str.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: str, stroke: prop['colors'][index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      } else {\n        var path2 = RG.SVG.arrayClone(path);if (prop.filled && prop.filledAccumulative && index > 0) {\n          for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n            path2.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n          }\n        }\n        path2 = path2.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path2, stroke: prop.colors[index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      }\n      if (prop.tooltips && prop.tooltips.length) {\n        var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { 'fill': 'transparent', className: \"rgraph_hotspots\" }, style: { cursor: 'pointer' } });for (var i = 0; i < this.coords[index].length && this.tooltipsSequentialIndex < prop.tooltips.length; ++i, ++this.tooltipsSequentialIndex) {\n          if (prop.tooltips[this.tooltipsSequentialIndex] && this.coords[index][i][0] && this.coords[index][i][1]) {\n            var hotspot = RG.SVG.create({ svg: this.svg, parent: group, type: 'circle', attr: { cx: this.coords[index][i][0], cy: this.coords[index][i][1], r: 5, 'data-dataset': index, 'data-index': i } });var obj = this;(function (sequentialIndex) {\n              hotspot.addEventListener(prop.tooltipsEvent, function (e) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(sequentialIndex, obj.data),\n                    index = indexes[1],\n                    dataset = indexes[0];if (RG.SVG.REG.get('tooltip') && RG.SVG.REG.get('tooltip').__index__ === index && RG.SVG.REG.get('tooltip').__dataset__ === dataset) {\n                  return;\n                }\n                RG.SVG.hideTooltip();if (prop.tooltips[sequentialIndex]) {\n                  var text = prop.tooltips[sequentialIndex];\n                }\n                RG.SVG.tooltip({ object: obj, index: index, dataset: dataset, sequentialIndex: sequentialIndex, text: text, event: e });var outer_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 13, fill: obj.properties.colors[dataset], 'fill-opacity': 0.5 }, style: { cursor: 'pointer' } });var outer_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 14, fill: 'white', 'fill-opacity': 0.75 }, style: { cursor: 'pointer' } });var inner_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 6, fill: 'white' }, style: { cursor: 'pointer' } });var inner_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 5, fill: obj.properties.colors[dataset] }, style: { cursor: 'pointer' } });RG.SVG.REG.set('highlight', [outer_highlight1, outer_highlight2, inner_highlight1, inner_highlight2]);\n              }, false);\n            })(this.tooltipsSequentialIndex);\n          }\n        }\n      }\n    };this.drawTickmarks = function (index, data, coords) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] === 'number') {\n          switch (prop.tickmarksStyle) {case 'filledcircle':case 'filledendcircle':\n              if (prop.tickmarksStyle === 'filledcircle' || i === 0 || i === data.length - 1) {\n                var circle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'circle':case 'endcircle':\n              if (prop.tickmarksStyle === 'circle' || prop.tickmarksStyle === 'endcircle' && (i === 0 || i === data.length - 1)) {\n                var outerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });var innerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.tickmarksFill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });break;\n              }\n              break;case 'endrect':case 'rect':\n              if (prop.tickmarksStyle === 'rect' || prop.tickmarksStyle === 'endrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && typeof prop.tickmarksFill[index] === 'string' ? prop.tickmarksFill[index] : prop.tickmarksFill;var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'stroke-width': prop.tickmarksLinewidth, 'stroke': prop.colors[index], 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'filledendrect':case 'filledrect':\n              if (prop.tickmarksStyle === 'filledrect' || prop.tickmarksStyle === 'filledendrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = prop.colors[index];var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }}\n        }\n      }\n    };this.redrawLines = function () {\n      if (prop.spline) {\n        for (var i = 0; i < this.coordsSpline.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coordsSpline[i].length; ++j) {\n            if (j === 0) {\n              path += 'M{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      } else {\n        for (var i = 0; i < this.coords.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coords[i].length; ++j) {\n            if (j === 0 || RG.SVG.isNull(this.data[i][j]) || RG.SVG.isNull(this.data[i][j - 1])) {\n              path += 'M{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropshadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties,\n          y;if (value > this.scale.max) {\n        return null;\n      }\n      if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y');\n    };this.drawSpline = function (coords) {\n      var xCoords = [];gutterLeft = prop.gutterLeft, gutterRight = prop.gutterRight, hmargin = prop.hmargin, interval = (this.graphWidth - 2 * hmargin) / (coords.length - 1), coordsSpline = [];for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n          coords[i] = Number(coords[i][1]);\n        }\n      }\n      var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n        P.push(coords[i]);\n      }\n      P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n        for (var t = 0; t < 10; ++t) {\n          var yCoord = spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);coordsSpline.push([xCoords[xCoords.length - 1], yCoord]);if (typeof index === 'number') {\n            coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n          }\n        }\n      }\n      coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);if (typeof index === 'number') {\n        coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n      }\n      function spline(t, P0, P1, P2, P3) {\n        return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n      }\n      return coordsSpline;\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), filledColors: RG.SVG.arrayClone(prop.filledColors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      var filledColors = prop.filledColors;if (filledColors) {\n        for (var i = 0; i < filledColors.length; ++i) {\n          filledColors[i] = RG.SVG.parseColorLinear({ object: this, color: filledColors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0;for (var dataset = 0; dataset < this.coords.length; ++dataset, seq++) {\n          for (var i = 0; i < this.coords[dataset].length; ++i, seq++) {\n            var str = RG.SVG.numberFormat({ object: this, num: this.data[dataset][i].toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n              str = prop.labelsAboveSpecific[seq];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n              continue;\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: parseFloat(this.coords[dataset][i][0]) + prop.labelsAboveOffsetx, y: parseFloat(this.coords[dataset][i][1]) + prop.labelsAboveOffsety, halign: prop.labelsAboveHalign, valign: prop.labelsAboveValign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n          seq--;\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 60,\n          obj = this;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });var clipPathRect = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'rect', attr: { x: 0, y: 0, width: 0, height: this.height } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;clipPathRect.setAttribute(\"width\", width);if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };\n  return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.line.js\n// module id = 213\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.line.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Pie = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'pie';this.angles = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, colors: ['#f66', '#6f6', '#66f', '#ff6', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], strokestyle: 'rgba(0,0,0,0)', margin: 3, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], labelsSticks: true, labelsSticksHlength: 50, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, exploded: 0, roundRobinMultiplier: 1, donut: false, donutWidth: 75, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centery);RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.max = RG.SVG.arrayMax(this.data);this.total = RG.SVG.arraySum(this.data);if (typeof prop.exploded === 'number' && prop.exploded > 0) {\n        var val = prop.exploded;prop.exploded = [];for (var i = 0; i < this.data.length; ++i) {\n          prop.exploded[i] = val;\n        }\n      }\n      this.drawSegments({ shadow: true });RG.SVG.drawTitle(this);if (prop.labelsSticks) {\n        this.drawLabelsSticks();\n      } else {\n        this.drawLabels();\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawSegments = function (opt) {\n      var start = 0,\n          end = 0,\n          angle = 0,\n          sum = RG.SVG.arraySum(this.data),\n          segment = 0;for (var i = 0, len = this.data.length; i < len; ++i) {\n        var value = this.data[i] * prop.roundRobinMultiplier;start = angle;segment = value / sum * RG.SVG.TRIG.TWOPI;end = start + segment;var explosion = RG.SVG.TRIG.getRadiusEndPoint({ angle: start + segment / 2, r: prop.exploded[i] });var explosionX = explosion[1],\n            explosionY = explosion[0];this.angles[i] = { start: start, end: end, angle: end - start, halfway: (end - start) / 2 + start, cx: this.centerx + (parseFloat(explosionX) || 0), cy: this.centery - (parseFloat(explosionY) || 0), radius: this.radius };angle += end - start;\n      }\n      if (opt.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0; i < this.angles.length; ++i) {\n        var path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius, start: this.angles[i].start, end: this.angles[i].end });if (prop.donut) {\n          var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius - donutWidth, start: this.angles[i].end, end: this.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: this.angles[i].end - RG.SVG.TRIG.HALFPI, r: this.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + this.angles[i].cx, xy[1] + this.angles[i].cy) + donut_path + \" Z\";\n        } else {\n          path = path + \" L {1} {2} \".format(this.angles[i].cx, this.angles[i].cy) + \" Z\";\n        }\n        var arc = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, fill: prop.colors[i], stroke: prop.strokestyle, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-value': value, 'data-start-angle': this.angles[i].start, 'data-end-angle': this.angles[i].end, 'data-radius': this.radius, filter: prop.shadow && opt.shadow ? 'url(#dropShadow)' : '' } });if (prop.shadow && opt.shadow) {\n          this.shadowNodes[i] = arc;\n        } else {\n          this.nodes[i] = arc;\n        }\n        if (prop.tooltips && prop.tooltips[i] && (!opt.shadow || !prop.shadow)) {\n          if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          (function (index, obj) {\n            arc.addEventListener(prop.tooltipsEvent, function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: index, sequentialIndex: index, text: prop.tooltips[index], event: e });obj.highlight(e.target);var highlight = RG.SVG.REG.get('highlight');if (prop.tooltipsEvent === 'mousemove') {\n                highlight.style.cursor = 'pointer';\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              arc.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(i, this);\n        }\n      }\n      if (prop.shadow && opt.shadow) {\n        this.redrawSegments();\n      }\n    };this.redrawSegments = function () {\n      this.drawSegments({ shadow: false });\n    };this.drawLabels = function () {\n      var angles = this.angles,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0; i < angles.length; ++i) {\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: angles[i].halfway - RG.SVG.TRIG.HALFPI, r: angles[i].radius + 15 });var x = endpoint[0] + angles[i].cx,\n            y = endpoint[1] + angles[i].cy,\n            valign,\n            halign;if (angles[i].halfway > 0 && angles[i].halfway < RG.SVG.TRIG.HALFPI) {\n          halign = 'left';valign = 'bottom';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI && angles[i].halfway < RG.SVG.TRIG.PI) {\n          halign = 'left';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI) {\n          halign = 'right';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.TWOPI) {\n          halign = 'right';valign = 'top';\n        }\n        RG.SVG.text({ object: this, parent: this.svg.all, text: typeof labels[i] === 'string' ? labels[i] : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: valign, halign: halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });\n      }\n    };this.drawLabelsSticks = function () {\n      var labels_right = [],\n          labels_left = [],\n          labels_coords = [];for (var i = 0; i < this.angles.length; ++i) {\n        var angle = this.angles[i].start + (this.angles[i].end - this.angles[i].start) / 2 - RGraph.SVG.TRIG.HALFPI,\n            endpoint_inner = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 5 }),\n            endpoint_outer = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 20 }),\n            explosion = [typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i], ma.cos(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i]), ma.sin(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i])];labels_coords[i] = [];var labels = {};if (angle > RG.SVG.TRIG.HALFPI) {\n          var index = labels_left.length;labels_left[index] = [];labels_left[index].text = prop.labels[i];labels_left[index].halign = 'right';labels = labels_left;labels_coords[i].halign = 'right';\n        } else {\n          var index = labels_right.length;labels_right[index] = [];labels_right[index].text = prop.labels[i];labels_right[index].halign = 'right';labels = labels_right;labels_coords[i].halign = 'left';\n        }\n        endpoint_inner[0] += explosion[1] || 0;endpoint_inner[1] += explosion[2] || 0;endpoint_outer[0] += explosion[1] || 0;endpoint_outer[1] += explosion[2] || 0;var x, y;if (labels[index].text) {\n          var stick = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4}'.format(this.centerx + endpoint_inner[0], this.centery + endpoint_inner[1], this.centerx + endpoint_outer[0], this.centery + endpoint_outer[1]), stroke: '#999', fill: 'rgba(0,0,0,0)' } });\n        }\n        if (stick) {\n          labels[index].stick = stick;\n        }\n        x = this.centerx + endpoint_outer[0] + (angle > 1.57 ? -50 : 50);y = this.centery + endpoint_outer[1];labels_coords[i].x = x;labels_coords[i].y = y;labels_coords[i].text = prop.labels[i];\n      }\n      var vspace_right = (this.height - prop.gutterTop - prop.gutterBottom) / labels_right.length;var vspace_left = (this.height - prop.gutterTop - prop.gutterBottom) / labels_left.length;x = y = 0;for (var i = 0; i < labels_right.length; ++i) {\n        if (labels_right[i] && labels_right[i].text) {\n          x = this.centerx + this.radius + 100;y = prop.gutterTop + vspace_right * i + vspace_right / 2;RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_right[i].text === 'string' ? labels_right[i].text : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: 'center', halign: labels_right[i].text, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_right[i].stick.setAttribute('d', labels_right[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx + this.radius + prop.labelsSticksHlength));\n        }\n      }\n      for (var i = 0; i < labels_left.length; ++i) {\n        if (labels_left[i] && labels_left[i].text) {\n          x = this.centerx - this.radius - 100;y = this.height - (prop.gutterTop + vspace_left * i + vspace_left / 2);RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_left[i].text === 'string' ? labels_left[i].text : '', font: prop.textFont, size: prop.textSize, x: x - 7, y: y, valign: 'center', halign: labels_left[i].halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_left[i].stick.setAttribute('d', labels_left[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx - this.radius - prop.labelsSticksHlength));\n        }\n      }\n    };this.highlight = function (segment) {\n      var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: segment.getAttribute('d'), fill: prop.highlightFill, stroke: prop.highlightStroke, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {\n        highlight.addEventListener('mouseout', function (e) {\n          highlight.parentNode.removeChild(highlight);RG.SVG.hideTooltip();RG.SVG.REG.set('highlight', null);\n        }, false);\n      }\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.roundRobin = function () {\n      var obj = this,\n          opt = arguments[0] || {},\n          data = RG.SVG.arrayClone(this.data),\n          prop = this.properties,\n          frame = 1,\n          frames = opt.frames || 30,\n          callback = typeof opt.callback === 'function' ? opt.callback : function () {},\n          dataSum = RG.SVG.arraySum(this.data),\n          textColor = prop.textColor;this.properties.textColor = 'rgba(0,0,0,0)';obj.draw();angles = RG.SVG.arrayClone(obj.angles);function iterator() {\n        prop.roundRobinMultiplier = 1 / frames * frame++;for (var i = 0; i < obj.angles.length; ++i) {\n          var value = obj.data[i];obj.angles[i].start = angles[i].start * prop.roundRobinMultiplier;obj.angles[i].end = angles[i].end * prop.roundRobinMultiplier;var segment = (obj.angles[i].end - obj.angles[i].start) / 2;var explodedX = ma.cos(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var explodedY = ma.sin(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var path = RG.SVG.TRIG.getArcPath({ cx: obj.centerx + explodedX, cy: obj.centery + explodedY, r: obj.radius, start: obj.angles[i].start, end: obj.angles[i].end });if (prop.donut) {\n            var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: obj.angles[i].cx, cy: obj.angles[i].cy, r: obj.radius - donutWidth, start: obj.angles[i].end, end: obj.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: obj.angles[i].end - RG.SVG.TRIG.HALFPI, r: obj.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + obj.angles[i].cx, xy[1] + obj.angles[i].cy) + donut_path + \" Z\";\n          } else {\n            path = path + \" L {1} {2} \".format(obj.angles[i].cx, obj.angles[i].cy) + \" Z\";\n          }\n          path = path + \" L {1} {2} Z\".format(obj.centerx + explodedX, obj.centery + explodedY);if (obj.shadowNodes && obj.shadowNodes[i]) {\n            obj.shadowNodes[i].setAttribute('d', path);\n          }\n          obj.nodes[i].setAttribute('d', path);\n        }\n        if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else {\n          prop.textColor = textColor;RG.SVG.redraw(obj.svg);callback(obj);\n        }\n      }\n      iterator();return this;\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.pie.js\n// module id = 214\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.pie.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Radar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = RG.SVG.arrayClone(conf.data);this.originalData = RG.SVG.arrayClone(conf.data);this.type = 'radar';this.coords = [];this.coords2 = [];this.angles = [];this.angles2 = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];this.max = 0;this.redraw = false;this.highlight_node = null;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridRadialsCount: null, backgroundGridConcentricsCount: 5, backgroundGridLinewidth: 1, backgroundGridPoly: true, colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], filled: false, filledOpacity: 0.25, filledAccumulative: true, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], scaleVisible: true, scaleUnitsPre: '', scaleUnitsPost: '', scaleMax: null, scaleMin: 0, scalePoint: '.', scaleThousand: ',', scaleRound: false, scaleDecimals: 0, scaleFormatter: null, scaleBold: null, scaleItalic: null, scaleColor: null, scaleSize: null, scaleFont: null, scaleLabelsCount: 5, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarks: 'circle', tickmarksLinewidth: 1, tickmarksSize: 6, tickmarksFill: 'white', title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, grouping: 'normal', shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');this.data = RG.SVG.arrayClone(this.originalData);if (this.data.length > 1) {\n        var len = this.data[0].length;for (var i = 1; i < this.data.length; ++i) {\n          if (this.data[i].length !== len) {\n            alert('[ERROR] The Radar chart datasets must have the same number of elements!');\n          }\n        }\n      }\n      this.angles = [];this.coords = [];this.coords2 = [];RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n        this.data = [this.data];\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        for (var j = 0; j < this.data[i].length; ++j) {\n          if (typeof this.data[i][j] === 'string') {\n            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n          }\n        }\n      }\n      if (prop.filled && prop.filledAccumulative) {\n        for (var dataset = 1; dataset < this.data.length; ++dataset) {\n          for (var i = 0; i < this.data[dataset].length; ++i) {\n            this.data[dataset][i] += this.data[dataset - 1][i];\n          }\n        }\n      }\n      this.getMaxValue();RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.scale = RG.SVG.getScale({ object: this, numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount, unitsPre: prop.scaleUnitsPre, unitsPost: prop.scaleUnitsPost, max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max, min: prop.scaleMin, point: prop.scalePoint, round: prop.scaleRound, thousand: prop.scaleThousand, decimals: prop.scaleDecimals, strict: typeof prop.scaleMax === 'number', formatter: prop.scaleFormatter });this.max = this.scale.max;this.drawBackground();this.drawRadar();this.drawTickmarks();this.drawLabels();RG.SVG.drawTitle(this);this.addTooltipHotspots();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      var obj = this;doc.body.addEventListener('mousedown', function (e) {\n        obj.hideHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBackground = function () {\n      if (prop.backgroundGrid) {\n        var grid = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_grid', fill: 'rgba(0,0,0,0)', stroke: prop.backgroundGridColor } });var origin = 0 - RG.SVG.TRIG.PI / 2,\n            radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data[0].length,\n            concentrics = prop.backgroundGridConcentricsCount,\n            step = RG.SVG.TRIG.TWOPI / radials;if (radials > 0) {\n          for (var i = 0, len = radials; i < len; ++i) {\n            var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius, angle: origin + i * step });var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: str, stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n          }\n        }\n        if (concentrics > 0) {\n          if (prop.backgroundGridPoly) {\n            for (var j = 1; j <= concentrics; j++) {\n              for (var i = 0, len = radials, path = []; i < len; ++i) {\n                var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), angle: origin + i * step });path.push('{1} {2} {3}'.format(i === 0 ? 'M' : 'L', coords.x, coords.y));\n              }\n              RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: path.join(' ') + ' z', fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          } else {\n            for (var j = 1; j <= concentrics; j++) {\n              RG.SVG.create({ svg: this.svg, type: 'circle', parent: grid, attr: { cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          }\n        }\n      }\n    };this.drawRadar = function (opt) {\n      for (var dataset = 0, len = this.data.length; dataset < len; ++dataset) {\n        this.coords2[dataset] = [];this.angles2[dataset] = [];var path = [];for (var i = 0, len2 = this.data[dataset].length; i < len2; ++i) {\n          var value = this.data[dataset][i];var xy = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.getRadius(this.data[dataset][i]), angle: RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI });xy.r = (value - prop.scaleMin) / (this.max - prop.scaleMin) * this.radius;xy.angle = RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI;path.push('{1}{2} {3}'.format(i === 0 ? 'M' : 'L', xy.x, xy.y));this.angles.push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.angles2[dataset].push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.coords.push([xy.x, xy.y]);this.coords2[dataset].push([xy.x, xy.y]);\n        }\n        if (dataset > 0 && prop.filled && prop.filledAccumulative) {\n          path.push('L {1} {2}'.format(this.coords2[dataset][0][0], this.coords2[dataset][0][1]));path.push('M {1} {2}'.format(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]));for (var i = this.coords2[dataset - 1].length - 1; i >= 0; --i) {\n            path.push('L {1} {2}'.format(this.coords2[dataset - 1][i][0], this.coords2[dataset - 1][i][1]));\n          }\n          this.redraw = true;\n        } else {\n          path.push('z');\n        }\n        var path = RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: prop.filled ? prop.colors[dataset] : 'transparent', 'fill-opacity': prop.filledOpacity, 'stroke-width': prop.linewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '', filter: prop.shadow ? 'url(#dropShadow)' : '' } });path.setAttribute('data-dataset', dataset);\n      }\n      this.redrawRadar();\n    };this.redrawRadar = function () {\n      if (this.redraw) {\n        this.redraw = false;for (var dataset = 0; dataset < this.coords2.length; ++dataset) {\n          var path = [];for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            if (i === 0) {\n              path.push('M {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            } else {\n              path.push('L {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            }\n          }\n          path.push('z');\n          RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: 'transparent', 'stroke-width': prop.linewidth } });\n        }\n      }\n    };this.drawTickmarks = function () {\n      var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_tickmarks' } });for (var i = 0; i < this.coords2.length; ++i) {\n        for (var j = 0; j < this.coords2[i].length; ++j) {\n          if (prop.tickmarks === 'circle' || prop.tickmarks === 'filledcircle') {\n            var c = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[i][j][0], cy: this.coords2[i][j][1], r: prop.tickmarksSize, fill: prop.tickmarks === 'filledcircle' ? prop.colors[i] : prop.tickmarksFill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });c.setAttribute('data-dataset', i);c.setAttribute('data-index', j);\n          } else if (prop.tickmarks === 'rect' || prop.tickmarks === 'filledrect') {\n            var halfTickmarkSize = prop.tickmarksSize / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && prop.tickmarksFill[i] ? prop.tickmarksFill[i] : prop.tickmarksFill;var s = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: this.coords2[i][j][0] - halfTickmarkSize, y: this.coords2[i][j][1] - halfTickmarkSize, width: prop.tickmarksSize, height: prop.tickmarksSize, fill: prop.tickmarks === 'filledrect' ? prop.colors[i] : fill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth } });s.setAttribute('data-dataset', i);s.setAttribute('data-index', j);\n          }\n        }\n      }\n    };this.drawLabels = function () {\n      var angles = this.angles2,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0, len = labels.length; i < len; ++i) {\n        if (!labels[i]) {\n          continue;\n        }\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: RG.SVG.TRIG.TWOPI / labels.length * i - RG.SVG.TRIG.HALFPI, r: this.radius + 15 });var x = endpoint[0] + this.centerx,\n            y = endpoint[1] + this.centery;if (i / len < 0.5) {\n          halign = 'left';\n        } else {\n          halign = 'right';\n        }\n        if (i / len < 0.25 || i / len > 0.75) {\n          valign = 'bottom';\n        } else {\n          valign = 'top';\n        }\n        if (i / len === 0) {\n          halign = 'center';\n        }\n        if (i / len === 0.25) {\n          valign = 'center';\n        }\n        if (i / len === 0.5) {\n          halign = 'center';\n        }\n        if (i / len === 0.75) {\n          valign = 'center';\n        }\n        RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: labels[i], size: typeof prop.labelsSize === 'number' ? prop.labelsSize : prop.textSize, x: x, y: y, halign: halign, valign: 'center', color: prop.labelsColor || prop.textColor, bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold, italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic, font: prop.labelsFont || prop.textFont });\n      }\n      if (prop.scaleVisible) {\n        for (var i = 0; i < this.scale.labels.length; ++i) {\n          var x = this.centerx;var y = this.centery - this.radius / this.scale.labels.length * (i + 1);RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: this.scale.labels[i], size: prop.scaleSize || prop.textSize - 2, x: x, y: y, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n        }\n        var str = RG.SVG.numberFormat({ object: this, num: this.scale.min.toFixed(prop.scaleDecimals), prepend: prop.scaleUnitsPre, append: prop.scaleUnitsPost, point: prop.scalePoint, thousand: prop.scaleThousand, formatter: prop.scaleFormatter });RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: str, size: prop.scaleSize || prop.textSize - 2, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n      }\n    };this.highlight = function (circle) {\n      circle.setAttribute('fill', prop.highlightFill);circle.setAttribute('stroke', prop.highlightStroke);circle.setAttribute('stroke-width', prop.highlightLinewidth);this.highlight_node = circle;RG.SVG.REG.set('highlight', circle);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.getMaxValue = function () {\n      var max = 0;if (prop.filled && prop.filledAccumulative) {\n        this.max = RG.SVG.arrayMax(this.data[this.data.length - 1]);\n      } else {\n        for (var dataset = 0, max = 0; dataset < this.data.length; ++dataset) {\n          this.max = ma.max(this.max, RG.SVG.arrayMax(this.data[dataset]));\n        }\n      }\n    };this.getRadius = function (value) {\n      return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n    };this.addTooltipHotspots = function () {\n      if (prop.tooltips && prop.tooltips.length > 0) {\n        if (prop.tooltipsEvent !== 'mousemove') {\n          prop.tooltipsEvent = 'click';\n        }\n        var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph-radar-tooltip-hotspots' } });for (var dataset = 0, seq = 0; dataset < this.coords2.length; ++dataset) {\n          for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            var circle = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[dataset][i][0], cy: this.coords2[dataset][i][1], r: prop.tickmarksSize, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0, 'data-sequential-index': seq }, style: { cursor: prop['tooltips'][seq] ? 'pointer' : 'default' } });(function (dataset, index, seq, obj) {\n              if (prop.tooltips[seq]) {\n                circle.addEventListener(prop.tooltipsEvent, function (e) {\n                  var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__sequentialIndex__ === seq) {\n                    return;\n                  }\n                  RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(this);\n                }, false);if (prop.tooltipsEvent === 'click') {\n                  circle.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                  }, false);\n                }\n              }\n            })(dataset, i, seq++, this);\n          }\n        }\n      }\n    };this.roundRobin = function () {};this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = this.hideHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && this.highlight_node) {\n        this.highlight_node.setAttribute('fill', 'transparent');this.highlight_node.setAttribute('stroke', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 120,\n          obj = this;\n      step = 360 / frames;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });clipPathArcPath = RG.SVG.TRIG.getArcPath2({ cx: this.angles[0].cx, cy: this.angles[0].cy, r: this.angles[0].r * 2, start: 0, end: 0 });var clipPathArc = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'path', attr: { d: clipPathArcPath } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;var deg = 360 / frames * frame++,\n            rad = RG.SVG.TRIG.TWOPI / 360 * deg;\n        clipPathArc.setAttribute('d', RG.SVG.TRIG.getArcPath2({ cx: obj.angles[0].cx, cy: obj.angles[0].cy, r: obj.angles[0].r * 2, start: 0, end: rad }));if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.radar.js\n// module id = 215\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.radar.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.Rose = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = RG.SVG.arrayClone(conf.data);\n        this.originalData = RG.SVG.arrayClone(conf.data);\n        this.type = 'rose';\n        this.angles = [];\n        this.angles2 = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n        this.max = 0;\n        this.redraw = false;\n        this.highlight_node = null;\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundGrid: true,\n            backgroundGridColor: '#ddd',\n            backgroundGridRadialsCount: null,\n            backgroundGridRadialsAngleOffset: 0,\n            backgroundGridConcentricsCount: 5,\n            backgroundGridLinewidth: 1,\n\n            strokestyle: 'white',\n            colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'],\n            colorsOpacity: 1,\n\n            textColor: 'black',\n            textFont: 'sans-serif',\n            textSize: 12,\n            textBold: false,\n            textItalic: false,\n\n            labels: [],\n            labelsFont: null,\n            labelsSize: null,\n            labelsColor: null,\n            labelsBold: null,\n            labelsItalic: null,\n            labelsRadialMargin: 10,\n            labelsAngleOffset: 0,\n\n            scaleVisible: true,\n            scaleUnitsPre: '',\n            scaleUnitsPost: '',\n            scaleMax: null,\n            scaleMin: 0,\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleRound: false,\n            scaleDecimals: 0,\n            scaleFormatter: null,\n            scaleBold: null,\n            scaleItalic: null,\n            scaleColor: null,\n            scaleSize: null,\n            scaleFont: null,\n            scaleLabelsCount: 5,\n\n            linewidth: 1,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            shadow: false,\n            shadowOffsetx: 2,\n            shadowOffsety: 2,\n            shadowBlur: 2,\n            shadowOpacity: 0.25,\n\n            margin: 0,\n            exploded: 0,\n\n            key: null,\n            keyColors: null,\n            keyOffsetx: 0,\n            keyOffsety: 0,\n            keyTextOffsetx: 0,\n            keyTextOffsety: -1,\n            keyTextSize: null,\n            keyTextBold: null,\n            keyTextItalic: null,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false,\n\n            segmentsAngleOffset: 0,\n            variant: 'normal'\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Reset the data back to the original values\n            this.data = RG.SVG.arrayClone(this.originalData);\n\n            // Reset the angles array to stop it growing\n            this.angles = [];\n\n            // Create the arrays in the angles2 array based on\n            // the data that we've been passed\n            for (var i = 0; i < this.data.length; ++i) {\n                this.angles2[i] = [];\n            }\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.graphHeight / 2 + prop.gutterTop;\n            this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            //\n            // Convert the nargin from strings to a number\n            //\n            if (typeof prop.margin === 'string' && prop.margin.match(/([0-9.]+)deg/)) {\n                prop.margin = RegExp.$1 / (180 / ma.PI);\n            }\n\n            /**\n            * Add the data to the .originalData array and work out the max value\n            * \n            * 2/5/14 Now also use this loop to ensure that the data pieces\n            *        are numbers\n            * \n            * **Is this necessary **\n            */\n            //if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n            //    this.data = [this.data];\n            //}\n\n            // Convert strings to numbers\n            for (var i = 0; i < this.data.length; ++i) {\n                if (_typeof(this.data[i]) === 'object') {\n                    for (var j = 0; j < this.data[i].length; ++j) {\n                        if (typeof this.data[i][j] === 'string') {\n                            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n                        }\n                    }\n                } else if (typeof this.data[i] === 'string') {\n                    this.data[i] = RG.SVG.stringsToNumbers(this.data[i]);\n                }\n            }\n\n            // Get the max value. This sets the maximum value on the\n            // this.max variable\n            this.getMaxValue();\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            //\n            // Get the scale\n            //\n\n            this.scale = RG.SVG.getScale({\n                object: this,\n                numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount,\n                unitsPre: prop.scaleUnitsPre,\n                unitsPost: prop.scaleUnitsPost,\n                max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max,\n                min: prop.scaleMin,\n                point: prop.scalePoint,\n                round: prop.scaleRound,\n                thousand: prop.scaleThousand,\n                decimals: prop.scaleDecimals,\n                strict: typeof prop.scaleMax === 'number',\n                formatter: prop.scaleFormatter\n            });\n\n            this.max = this.scale.max;\n\n            // Draw the background 'grid'\n            this.drawBackground();\n\n            // Draw the chart\n            this.drawRose();\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the key\n            if (typeof prop.key !== null && RG.SVG.drawKey) {\n                RG.SVG.drawKey(this);\n            } else if (!RGraph.SVG.isNull(prop.key)) {\n                alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n            }\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Create the shadow definition if needed\n            if (prop.shadow) {\n                RG.SVG.setShadow({\n                    object: this,\n                    offsetx: prop.shadowOffsetx,\n                    offsety: prop.shadowOffsety,\n                    blur: prop.shadowBlur,\n                    opacity: prop.shadowOpacity,\n                    id: 'dropShadow'\n                });\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.hideHighlight(obj);\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draw the background grid\n        //\n        this.drawBackground = function () {\n            if (prop.backgroundGrid) {\n\n                // Create the background grid group tag\n                var grid = RG.SVG.create({\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    type: 'g',\n                    attr: {\n                        className: 'rgraph_radar_grid',\n                        fill: 'rgba(0,0,0,0)',\n                        stroke: prop.backgroundGridColor\n                    }\n                });\n\n                // Draw the concentric \"rings\" grid lines that are\n                // arranged around the centerx/centery along with\n                // the radials that eminate from the center outwards\n\n                var origin = 0 - RG.SVG.TRIG.PI / 2,\n                    radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data.length,\n                    concentrics = prop.backgroundGridConcentricsCount,\n                    step = RG.SVG.TRIG.TWOPI / radials;\n\n                // First draw the radial lines that emanate from the\n                // center outwards\n                if (radials > 0) {\n                    // This draws the radials for the non-equi-angular ONLY\n                    if (prop.variant === 'non-equi-angular') {\n\n                        // Number of radials always matches the number of data pieces\n                        var radials = this.data.length;\n\n                        // Work out the total of the second part of each data bit\n                        for (var i = 0, total = 0; i < this.data.length; ++i) {\n                            total += this.data[i][1];\n                        }\n\n                        for (var i = 0, sum = 0; i < this.data.length; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + sum / total * RG.SVG.TRIG.TWOPI + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n\n                            sum += this.data[i][1];\n                        }\n\n                        // This draws the radials for normal and STACKED Rose charts\n                    } else {\n                        for (var i = 0, len = radials; i < len; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + i * step + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n                        }\n                    }\n                }\n\n                // Draw the concentrics\n                if (concentrics > 0) {\n\n                    for (var j = 1; j <= concentrics; j++) {\n\n                        // Add circle to the scene\n                        RG.SVG.create({\n                            svg: this.svg,\n                            type: 'circle',\n                            parent: grid,\n                            attr: {\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius * (j / concentrics),\n                                fill: 'transparent',\n                                stroke: prop.backgroundGridColor,\n                                'stroke-width': prop.backgroundGridLinewidth\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar\n        //\n        this.drawRose = function (opt) {\n            // Jump to another function if we're drawing a non-equi-angular chart\n            if (prop.variant === 'non-equi-angular') {\n                return this.drawRoseNonEquiAngular(opt);\n            }\n\n            var radians = RG.SVG.TRIG.TWOPI / this.data.length;\n\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radius = this.data[i] / this.scale.max * this.radius,\n                    start = i / this.data.length * RG.SVG.TRIG.TWOPI,\n                    end = i / this.data.length * RG.SVG.TRIG.TWOPI + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // Is the data piece an array or a number?\n                if (_typeof(this.data[i]) === 'object' && !RG.SVG.isNull(this.data[i])) {\n\n                    // Create a group for the parts of this segment\n                    var segment_group = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'g',\n                        parent: group,\n                        attr: {\n                            id: 'rose_' + this.id + '_segment_group_' + i\n                        }\n                    });\n\n                    for (var j = 0, sum = 0, accRadius = 0; j < this.data[i].length; ++j, ++seq) {\n\n                        sum += this.data[i][j];\n\n                        var radius = sum / this.scale.max * this.radius;\n\n                        // This (I think is the OUTER curve in the segment\n                        var arcPath = RG.SVG.TRIG.getArcPath2({\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            r: radius,\n                            start: start + prop.margin + prop.segmentsAngleOffset,\n                            end: end - prop.margin + prop.segmentsAngleOffset,\n                            anticlockwise: false\n                        });\n\n                        // The inner most segment\n                        if (j === 0) {\n                            arcPath = '{1} z'.format(arcPath);\n                        } else {\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                            arcPath = '{1} L {2} {3} {4}'.format(arcPath, this.centerx + explosion[0], this.centery + explosion[1], arcPath2);\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: segment_group,\n                            attr: {\n                                d: arcPath,\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[seq] : '',\n                                'data-index': i,\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-group': i,\n                                'data-subindex': j,\n                                'data-value': this.data[i][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': typeof prevRadius === 'number' ? prevRadius : 0,\n                                'data-sequential-index': seq\n                            }\n                        });\n\n                        // Install the tooltip listener\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        group: group,\n                                        index: index,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n\n                        // Add the segment to the angles and angles2 array\n                        this.angles.push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        var prevRadius = radius;\n                    }\n\n                    seq--;\n\n                    // A regular number\n                } else {\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-index': i,\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': prevRadius,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: index,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, this);\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar, but only the non-equi-angular variant\n        //\n        this.drawRoseNonEquiAngular = function (opt) {\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            //Loop through the data summing the second data-pieces\n            for (var i = 0, total = 0; i < this.data.length; ++i) {\n                total += parseFloat(this.data[i][1]);\n            }\n\n            // The initial angles\n            var start = 0;\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radians = this.data[i][1] / total * RG.SVG.TRIG.TWOPI,\n                    end = start + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // A stacked non-equi-angular segment\n                if (_typeof(this.data[i][0]) === 'object' && !RG.SVG.isNull(this.data[i][0])) {\n\n                    // Loop thru the set of values for this segment\n                    for (var j = 0, sum = 0; j < this.data[i][0].length; ++j, ++seq) {\n\n                        sum += this.data[i][0][j];\n\n                        // First segment in the stack or not?\n                        if (j === 0) {\n\n                            var prevRadius = 0,\n                                radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = '';\n                        } else {\n\n                            var prevRadius = radius,\n                                // The previous iterations radius\n                            radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: group,\n                            attr: {\n                                d: '{1} {2} z'.format(arcPath, arcPath2),\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-index': '[{1},{2}]'.format(i, j),\n                                'data-value': this.data[i][0][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': prevRadius,\n                                'data-sequential': seq\n                            }\n                        });\n\n                        // Add the segment to the angles array\n                        this.angles.push({\n                            object: path,\n                            index: i,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][0]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        // Install tooltips listeners\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        index: index,\n                                        group: group,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n                        var prevRadius = radius;\n                    }\n                    seq--;\n\n                    // A regular non-equi-angular segment\n                } else {\n                    var radius = this.data[i][0] / this.scale.max * this.radius;\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-index': i,\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i][0]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': 0,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, group, seq, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: seq,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, i, seq, this);\n                    }\n                }\n\n                // Increment the start angle for the next iteration of the loop\n                start += radians;\n            }\n        };\n\n        //\n        // Redraws the chart if required\n        //\n        this.redrawRose = function () {};\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the scale if required\n            if (prop.scaleVisible) {\n                for (var i = 0; i < this.scale.labels.length; ++i) {\n\n                    var x = this.centerx;\n                    var y = this.centery - this.radius / this.scale.labels.length * (i + 1);\n\n                    RG.SVG.text({\n                        object: this,\n                        svg: this.svg,\n                        parent: this.svg.all,\n                        text: this.scale.labels[i],\n                        size: prop.scaleSize || prop.textSize - 2,\n                        x: x,\n                        y: y,\n                        halign: 'center',\n                        valign: 'center',\n                        background: 'rgba(255,255,255,0.7)',\n                        padding: 2,\n                        color: prop.scaleColor || prop.textColor,\n                        bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                        italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                        font: prop.scaleFont || prop.textFont\n                    });\n                }\n\n                // Draw the zero label\n                var str = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.scale.min.toFixed(prop.scaleDecimals),\n                    prepend: prop.scaleUnitsPre,\n                    append: prop.scaleUnitsPost,\n                    point: prop.scalePoint,\n                    thousand: prop.scaleThousand,\n                    formatter: prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: str,\n                    size: prop.scaleSize || prop.textSize - 2,\n                    x: this.centerx,\n                    y: this.centery,\n                    halign: 'center',\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.scaleColor || prop.textColor,\n                    bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                    italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                    font: prop.scaleFont || prop.textFont\n                });\n            }\n\n            // Used further down\n            var halign;\n\n            // Set a default size for the labels\n            if (typeof prop.labelsSize !== 'number') {\n                prop.labelsSize = prop.textSize + 4;\n            }\n\n            // Draw the circular labels if necessary\n            for (var i = 0; i < prop.labels.length; ++i) {\n\n                if (prop.variant === 'non-equi-angular') {\n                    var angle = (this.angles2[i][0].end - this.angles2[i][0].start) / 2 + this.angles2[i][0].start - RG.SVG.TRIG.HALFPI;\n                } else {\n                    var angle = RG.SVG.TRIG.TWOPI / prop.labels.length * i - RG.SVG.TRIG.HALFPI + prop.labelsAngleOffset + (this.angles2[i][0].end - this.angles2[i][0].start) / 2;\n                }\n\n                var endpoint = RG.SVG.TRIG.getRadiusEndPoint({\n                    r: this.radius + prop.labelsRadialMargin,\n                    angle: angle\n                });\n\n                // Accommodate the explosion for the label\n                var explosion = this.getExploded({\n                    index: i,\n                    start: this.angles2[i][0].start - RG.SVG.TRIG.HALFPI,\n                    end: this.angles2[i][0].end - RG.SVG.TRIG.HALFPI\n                });\n\n                endpoint[0] += this.centerx + explosion[0];\n                endpoint[1] += this.centery + explosion[1];\n\n                // Do the alignment based on which quadrant the label is in\n                if (ma.round(endpoint[0]) > this.centerx) {\n                    halign = 'left';\n                } else if (ma.round(endpoint[0]) === this.centerx) {\n                    halign = 'center';\n                } else {\n                    halign = 'right';\n                }\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: typeof prop.labels[i] === 'string' ? prop.labels[i] : '',\n                    size: prop.labelsSize,\n                    x: endpoint[0],\n                    y: endpoint[1],\n                    halign: halign,\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.labelsColor || prop.textColor,\n                    bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold,\n                    italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic,\n                    font: prop.labelsFont || prop.textFont\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        * \n        * @param object circle The circle to highlight\n        */\n        this.highlight = function (path) {\n            var path = path.getAttribute('d');\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                parent: this.svg.all,\n                type: 'path',\n                attr: {\n                    d: path,\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            if (prop.tooltipsEvent === 'mousemove') {\n                highlight.addEventListener('mouseout', function (e) {\n                    highlight.parentNode.removeChild(highlight);\n                    RG.SVG.hideTooltip();\n\n                    RG.SVG.REG.set('highlight', null);\n                }, false);\n            }\n\n            // Store the highlight rect in the registry so\n            // it can be cleared later\n            RG.SVG.REG.set('highlight', highlight);\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorRadial({\n                        object: this,\n                        color: colors[i]\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorRadial({\n                object: this,\n                color: prop.highlightFill\n            });\n        };\n\n        //\n        // Get the maximum value\n        //\n        this.getMaxValue = function () {\n            var max = 0;\n\n            if (prop.variant === 'non-equi-angular') {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i][0] === 'number') {\n                            max = ma.max(max, this.data[i][0]);\n                        } else if (_typeof(this.data[i][0]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i][0]));\n                        }\n                    }\n                }\n            } else {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i] === 'number') {\n                            max = ma.max(max, this.data[i]);\n                        } else if (_typeof(this.data[i]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i]));\n                        }\n                    }\n                }\n            }\n\n            this.max = max;\n        };\n\n        //\n        // Gets the radius of a value\n        //\n        //@param number The value to get the radius for\n        //\n        this.getRadius = function (value) {\n            return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n        };\n\n        //\n        // A roundRobin effect for the Pie chart\n        //\n        // @param object    Options for the effect\n        // @param function  An optional callback function to call when\n        //                  the effect is complete\n        //\n        this.roundRobin = function () {};\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        * \n        * @param string   type The type of even to add\n        * @param function func \n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        // \n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Removes the tooltip highlight from the chart\n        //\n        this.removeHighlight = this.hideHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight && this.highlight_node) {\n                this.highlight_node.setAttribute('fill', 'transparent');\n                this.highlight_node.setAttribute('stroke', 'transparent');\n\n                RG.SVG.REG.set('highlight', null);\n            }\n        };\n\n        //\n        // Returns the exploded X/Y for a given explosion\n        //\n        //TODO Needs updating to current coding style, including converting\n        //     arguments to an object\n        //\n        this.getExploded = function (opt) {\n            var index = opt.index,\n                start = opt.start,\n                end = opt.end,\n                exploded = prop.exploded,\n                explodedX,\n                explodedY;\n\n            /**\n            * Retrieve any exploded - the exploded can be an array of numbers or a single number\n            * (which is applied to all segments)\n            */\n            if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && typeof exploded[index] === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded[index];\n                explodedY = ma.sin((end - start) / 2 + start) * exploded[index];\n            } else if (typeof exploded === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded;\n                explodedY = ma.sin((end - start) / 2 + start) * exploded;\n            } else {\n                explodedX = 0;\n                explodedY = 0;\n            }\n\n            return [explodedX, explodedY];\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.rose.js\n// module id = 216\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.rose.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Scatter = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'scatter';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.sequential = 0;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, xmax: 0, tickmarksStyle: 'cross', tickmarksSize: 7, colors: ['black'], line: false, lineColors: 1, lineLinewidth: 'black', yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisMin: 0, xaxisMax: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n    if (this.data[0] && !RG.SVG.isArray(this.data[0])) {\n      this.data = [];this.data[0] = conf.data;\n    }\n    if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;if (typeof prop.xaxisMin === 'string') {\n      prop.xaxisMin = RG.SVG.parseDate(prop.xaxisMin);\n    }\n    if (typeof prop.xaxisMax === 'string') {\n      prop.xaxisMax = RG.SVG.parseDate(prop.xaxisMax);\n    }\n    for (var i = 0; i < this.data.length; ++i) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j].x === 'string') {\n          this.data[i][j].x = RG.SVG.parseDate(this.data[i][j].x);\n        }\n      }\n    }\n    this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();for (var ds = 0, max = 0; ds < this.data.length; ++ds) {\n        for (var dp = 0; dp < this.data[ds].length; ++dp) {\n          max = ma.max(max, this.data[ds][dp].y);\n        }\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);var dataset_group = RGraph.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'scatter_datasets_' + this.uid } });for (var i = 0; i < this.data.length; ++i) {\n        this.drawPoints({ index: i, data: this.data[i], group: dataset_group });if (prop.line == true || _typeof(prop.line) === 'object' && prop.line[i] == true) {\n          this.drawLine({ index: i, coords: this.coords[i] });\n        }\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawPoints = function (opt) {\n      var index = opt.index,\n          data = opt.data,\n          group = opt.group;this.coords[index] = [];var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: group, attr: { className: 'scatter_dataset_' + index + '_' + this.uid } });for (var i = 0; i < data.length; ++i) {\n        var point = data[i];if (typeof point.x === 'number' && typeof point.y === 'number') {\n          var ret = this.drawSinglePoint({ dataset: data, datasetIdx: index, point: point, index: i, group: group, sequential: this.sequential++ });this.coords[index][i] = [ret.x, ret.y];\n        }\n        if (typeof data[i].tooltip === 'string' && data[i].tooltip || typeof data[i].tooltip === 'number') {\n          var _RG$SVG$create;\n\n          data[i].tooltip = String(data[i].tooltip);if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          if (!group_tooltip_hotspots) {\n            var group_tooltip_hotspots = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph-scatter-tooltip-hotspots' } });\n          }\n          var rect = RG.SVG.create((_RG$SVG$create = { svg: this.svg, parent: this.svg.all, type: 'rect' }, _defineProperty(_RG$SVG$create, 'parent', group_tooltip_hotspots), _defineProperty(_RG$SVG$create, 'attr', { x: ret.x - ret.size / 2, y: ret.y - ret.size / 2, width: ret.size, height: ret.size, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0 }), _defineProperty(_RG$SVG$create, 'style', { cursor: 'pointer' }), _RG$SVG$create));ret.mark.hotspot = rect;(function (dataset, index, seq, obj) {\n            rect.addEventListener(prop.tooltipsEvent, function (e) {\n              var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__dataset__ === dataset && tooltip.__index__ === index) {\n                return;\n              }\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: obj.data[dataset][index].tooltip, event: e });if (RG.SVG.REG.get('tooltip')) {\n                obj.highlight(this);\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(index, i, this.sequential - 1, this);\n        }\n      }\n    };this.drawSinglePoint = function (opt) {\n      var dataset = opt.dataset,\n          datasetIdx = opt.datasetIdx,\n          seq = opt.sequential,\n          point = opt.point,\n          index = opt.index,\n          valueX = opt.point.x,\n          valueY = opt.point.y,\n          conf = opt.point || {},\n          group = opt.group,\n          coordX = opt.coordx = this.getXCoord(valueX),\n          coordY = opt.coordy = this.getYCoord(valueY);if (typeof conf.type === 'undefined' && typeof conf.shape !== 'undefined') {\n        conf.type = conf.shape;\n      }\n      if (typeof conf.type === 'string') {} else if (typeof prop.tickmarksStyle === 'string') {\n        conf.type = prop.tickmarksStyle;\n      } else if (_typeof(prop.tickmarksStyle) === 'object' && typeof prop.tickmarksStyle[datasetIdx] === 'string') {\n        conf.type = prop.tickmarksStyle[datasetIdx];\n      }\n      if (typeof conf.size !== 'number' && typeof prop.tickmarksSize === 'number') {\n        conf.size = prop.tickmarksSize;\n      } else if (typeof conf.size !== 'number' && _typeof(prop.tickmarksSize) === 'object' && typeof prop.tickmarksSize[datasetIdx] === 'number') {\n        conf.size = prop.tickmarksSize[datasetIdx];\n      }\n      if (typeof conf.color === 'string') {} else if (typeof prop.colors[datasetIdx] === 'string') {\n        conf.color = prop.colors[datasetIdx];\n      } else {\n        conf.color = 'black';\n      }\n      if (typeof conf.opacity === 'undefined') {\n        conf.opacity = 1;\n      } else if (typeof conf.opacity === 'number') {}\n      if (prop.bubble) {\n        return this.drawBubble(opt, conf);\n      }\n      switch (conf.type) {case 'image:' + conf.type.substr(6):\n          var src = conf.type.substr(6);var img = new Image();img.src = src;var mark = RG.SVG.create({ svg: this.svg, type: 'image', parent: group, attr: { preserveAspectRatio: 'xMidYMid meet', 'xlink:href': src } });img.onload = function () {\n            var x = coordX - img.width / 2,\n                y = coordY - img.height / 2,\n                w = img.width,\n                h = img.height;mark.setAttribute('x', x);mark.setAttribute('y', y);mark.setAttribute('width', w);mark.setAttribute('height', h);if (mark && mark.hotspot) {\n              mark.hotspot.setAttribute('x', x);mark.hotspot.setAttribute('y', y);mark.hotspot.setAttribute('width', w);mark.hotspot.setAttribute('height', h);\n            }\n          };break;case 'triangle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} L {5} {6}'.format(coordX - conf.size / 2, coordY + conf.size / 2, coordX, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2), fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'plus':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY, coordX + conf.size / 2, coordY, coordX, coordY - conf.size / 2, coordX, coordY + conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;case 'square':case 'rect':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: coordX - conf.size / 2, y: coordY - conf.size / 2, width: conf.size, height: conf.size, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'dot':case 'circle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: coordX, cy: coordY, r: conf.size / 2, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'cross':default:\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2, coordX - conf.size / 2, coordY + conf.size / 2, coordX + conf.size / 2, coordY - conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;}\n      mark.setAttribute('data-index', index);mark.setAttribute('data-dataset', datasetIdx);mark.setAttribute('data-original-opacity', conf.opacity);mark.setAttribute('data-original-color', conf.color);mark.setAttribute('data-original-coordx', coordX);mark.setAttribute('data-original-coordy', coordY);mark.setAttribute('data-size', conf.size);mark.setAttribute('data-sequential', seq);mark.setAttribute('data-type', conf.type);return { x: coordX, y: coordY, size: conf.type.substr(0, 6) === 'image:' ? img.width : conf.size, mark: mark, type: conf.type };\n    };this.drawBubble = function (opt, conf) {\n      var size = conf.z / prop.bubbleMaxValue * prop.bubbleMaxRadius;var color = RG.SVG.parseColorRadial({ object: this, color: prop.bubbleColorsSolid ? conf.color : 'Gradient(white:' + conf.color + ')', cx: opt.coordx + size / 4, cy: opt.coordy - size / 4, fx: opt.coordx + size / 4, fy: opt.coordy - size / 4, r: size * 1.5 });var circle = RG.SVG.create({ svg: this.svg, type: 'circle', attr: { cx: opt.coordx, cy: opt.coordy, r: size, fill: color, 'fill-opacity': conf.opacity } });circle.setAttribute('data-index', opt.index);circle.setAttribute('data-dataset', opt.datasetIdx);circle.setAttribute('data-original-opacity', conf.opacity);circle.setAttribute('data-original-color', conf.color);circle.setAttribute('data-original-coordx', opt.coordx);circle.setAttribute('data-original-coordy', opt.coordy);circle.setAttribute('data-size', size);circle.setAttribute('data-sequential', opt.sequential);circle.setAttribute('data-type', 'bubble');return { x: opt.coordx, y: opt.coordy, z: opt.coordz };\n    };this.drawLine = function (opt) {\n      var linewidth = 1,\n          color = 'black';if (_typeof(prop.lineLinewidth) === 'object' && typeof prop.lineLinewidth[opt.index] === 'number') {\n        linewidth = prop.lineLinewidth[opt.index];\n      } else if (typeof prop.lineLinewidth === 'number') {\n        linewidth = prop.lineLinewidth;\n      } else {\n        linewidth = 1;\n      }\n      if (_typeof(prop.lineColors) === 'object' && prop.lineColors[opt.index]) {\n        color = prop.lineColors[opt.index];\n      } else if (prop.colors[opt.index] === 'string') {\n        color = prop.colors[opt.index];\n      } else {\n        color = 'black';\n      }\n      for (var i = 0, path = ''; i < this.coords[opt.index].length; ++i) {\n        path += '{1} {2} {3} '.format(i === 0 ? 'M' : 'L', this.coords[opt.index][i][0], this.coords[opt.index][i][1]);\n      }\n      RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path, fill: 'transparent', stroke: color, 'stroke-width': linewidth, 'stroke-linecap': 'round', 'stroke-linejoin': 'round' } });\n    };this.getXCoord = function (value) {\n      var x;if (value > prop.xaxisMax) {\n        return null;\n      }\n      if (value < prop.xaxisMin) {\n        return null;\n      }\n      x = (value - prop.xaxisMin) / (prop.xaxisMax - prop.xaxisMin);x *= this.width - prop.gutterLeft - prop.gutterRight;x = prop.gutterLeft + x;return x;\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      rect.setAttribute('fill', prop.highlightFill);RG.SVG.REG.set('highlight', rect);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors && !prop.bubble) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight) {\n        highlight.setAttribute('fill', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.scatter.js\n// module id = 217\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.scatter.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.SemiCircularProgress = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.min = RG.SVG.stringsToNumbers(conf.min);\n        this.max = RG.SVG.stringsToNumbers(conf.max);\n        this.value = RG.SVG.stringsToNumbers(conf.value);\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = conf.data;\n        this.type = 'semicircularprogress';\n        this.angles = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            width: 60,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundStrokeLinewidth: 0.25,\n            backgroundStroke: 'gray',\n            backgroundFill: 'Gradient(white:#aaa)',\n            backgroundFillOpacity: 0.25,\n\n            colors: ['#0c0'],\n            strokestyle: '#666',\n\n            textColor: 'gray',\n            textFont: 'sans-serif',\n            textSize: 10,\n            textBold: false,\n            textItalic: false,\n            unitsPre: '',\n            unitsPost: '',\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleDecimals: 0,\n            scaleFormatter: null,\n\n            labelsMin: true,\n            labelsMinSpecific: null,\n            labelsMinPoint: null,\n            labelsMinThousand: null,\n            labelsMinFormatter: null,\n            labelsMinFont: null,\n            labelsMinSize: null,\n            labelsMinBold: null,\n            labelsMinItalic: null,\n            labelsMinColor: null,\n            labelsMinDecimals: null,\n            labelsMinUnitsPre: null,\n            labelsMinUnitsPost: null,\n\n            labelsMax: true,\n            labelsMaxSpecific: null,\n            labelsMaxPoint: null,\n            labelsMaxThousand: null,\n            labelsMaxFormatter: null,\n            labelsMaxFont: null,\n            labelsMaxSize: null,\n            labelsMaxBold: null,\n            labelsMaxItalic: null,\n            labelsMaxColor: null,\n            labelsMaxDecimals: null,\n            labelsMaxUnitsPre: null,\n            labelsMaxUnitsPost: null,\n\n            labelsCenter: true,\n            labelsCenterSpecific: null,\n            labelsCenterPoint: null,\n            labelsCenterThousand: null,\n            labelsCenterFormatter: null,\n            labelsCenterFont: null,\n            labelsCenterSize: 40,\n            labelsCenterBold: true,\n            labelsCenterItalic: null,\n            labelsCenterColor: '#666',\n            labelsCenterDecimals: null,\n            labelsCenterUnitsPre: null,\n            labelsCenterUnitsPost: null,\n\n            linewidth: 0,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false\n\n            //shadow: false,\n            //shadowOffsetx: 2,\n            //shadowOffsety: 2,\n            //shadowBlur: 2,\n            //shadowOpacity: 0.25\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            // Add these\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.height - prop.gutterBottom;\n            this.radius = ma.min(this.graphWidth / 2, this.graphHeight);\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            // Set the width of the meter\n            this.progressWidth = prop.width || this.radius / 3;\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            // Draw the segments\n            this.path = this.drawMeter();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Add the tooltip event listener\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[0]) {\n\n                var obj = this;\n\n                //\n                // Add tooltip event listeners\n                //\n                this.path.addEventListener(prop.tooltipsEvent, function (e) {\n                    obj.removeHighlight();\n\n                    // Show the tooltip\n                    RG.SVG.tooltip({\n                        object: obj,\n                        index: 0,\n                        group: null,\n                        sequentialIndex: 0,\n                        text: prop.tooltips[0],\n                        event: e\n                    });\n\n                    // Highlight the rect that has been clicked on\n                    obj.highlight(e.target);\n                }, false);\n\n                this.path.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                }, false);\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draws the meter\n        //\n        this.drawMeter = function () {\n            //\n            // Draw the background to the meter\n            //\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: RG.SVG.TRIG.HALFPI,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                start: RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L \" + (this.centerx + this.radius - this.progressWidth) + \" \" + this.centery + path2 + \" L \" + (this.centerx - this.radius) + \" \" + this.centery,\n                    fill: prop.backgroundFill || prop.colors[0],\n                    stroke: prop.backgroundStroke,\n                    'stroke-width': prop.backgroundStrokeLinewidth,\n                    'fill-opacity': prop.backgroundFillOpacity\n                }\n            });\n\n            //\n            // This draws the bar that indicates the value\n            //\n            var angle = (this.value - this.min) / (this.max - this.min) * RG.SVG.TRIG.PI; // Because the Meter is always a semi-circle\n\n            // Take off half a pi because our origin is the noth axis\n            angle -= RG.SVG.TRIG.HALFPI;\n\n            // Now get the path of the inner indicator bar\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: angle,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: angle,\n                anticlockwise: false,\n                array: true\n            });\n\n            var path3 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            // Now draw the path\n            var path = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L{1} {2} \".format(path2[1], path2[2]) + path3 + ' z',\n                    fill: prop.colors[0],\n                    stroke: 'black',\n                    'stroke-width': prop.linewidth\n                }\n            });\n\n            return path;\n        };\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the min label\n            if (prop.labelsMin) {\n\n                var min = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.min.toFixed(typeof prop.labelsMinDecimals === 'number' ? prop.labelsMinDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMinUnitsPre === 'string' ? prop.labelsMinUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMinUnitsPost === 'string' ? prop.labelsMinUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMinPoint === 'string' ? prop.labelsMinPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMinThousand === 'string' ? prop.labelsMinThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMinFormatter === 'function' ? prop.labelsMinFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMinSpecific === 'string' ? prop.labelsMinSpecific : min,\n                    x: this.centerx - this.radius + this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMinFont || prop.textFont,\n                    size: prop.labelsMinSize || prop.textSize,\n                    bold: typeof prop.labelsMinBold === 'boolean' ? prop.labelsMinBold : prop.textBold,\n                    italic: typeof prop.labelsMinItalic === 'boolean' ? prop.labelsMinItalic : prop.textItalic,\n                    color: prop.labelsMinColor || prop.textColor\n                });\n            }\n\n            // Draw the max label\n            if (prop.labelsMax) {\n\n                var max = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.max.toFixed(typeof prop.labelsMaxDecimals === 'number' ? prop.labelsMaxDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMaxUnitsPre === 'string' ? prop.labelsMaxUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMaxUnitsPost === 'string' ? prop.labelsMaxUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMaxPoint === 'string' ? prop.labelsMaxPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMaxThousand === 'string' ? prop.labelsMaxThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMaxFormatter === 'function' ? prop.labelsMaxFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMaxSpecific === 'string' ? prop.labelsMaxSpecific : max,\n                    x: this.centerx + this.radius - this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMaxFont || prop.textFont,\n                    size: prop.labelsMaxSize || prop.textSize,\n                    bold: typeof prop.labelsMaxBold === 'boolean' ? prop.labelsMaxBold : prop.textBold,\n                    italic: typeof prop.labelsMaxItalic === 'boolean' ? prop.labelsMaxItalic : prop.textItalic,\n                    color: prop.labelsMaxColor || prop.textColor\n                });\n            }\n\n            // Draw the center label\n            if (prop.labelsCenter) {\n\n                var center = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.value.toFixed(typeof prop.labelsCenterDecimals === 'number' ? prop.labelsCenterDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsCenterUnitsPre === 'string' ? prop.labelsCenterUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsCenterUnitsPost === 'string' ? prop.labelsCenterUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsCenterPoint === 'string' ? prop.labelsCenterPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsCenterThousand === 'string' ? prop.labelsCenterThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsCenterFormatter === 'function' ? prop.labelsCenterFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsCenterSpecific === 'string' ? prop.labelsCenterSpecific : center,\n                    x: this.centerx,\n                    y: this.centery,\n                    valign: 'bottom',\n                    halign: 'center',\n                    font: prop.labelsCenterFont || prop.textFont,\n                    size: prop.labelsCenterSize || prop.textSize,\n                    bold: typeof prop.labelsCenterBold === 'boolean' ? prop.labelsCenterBold : prop.textBold,\n                    italic: typeof prop.labelsCenterItalic === 'boolean' ? prop.labelsCenterItalic : prop.textItalic,\n                    color: prop.labelsCenterColor || prop.textColor\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        *\n        * @param object segment The segment to highlight\n        */\n        this.highlight = function (segment) {\n            // Remove any highlight that's already been\n            // installed\n            this.removeHighlight();\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: this.path.getAttribute('d'),\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            // Store the highlight node in the registry\n            RG.SVG.REG.set('highlight', highlight);\n\n            // Add the event listener that clears the highlight path if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n        };\n\n        /**\n        * This function can be used to remove the highlight that is added\n        * by tooltips\n        */\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight) {\n                highlight.parentNode.removeChild(highlight);\n                highlight = null;\n            }\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill),\n                    backgroundColor: RG.SVG.arrayClone(prop.backgroundColor)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorLinear({\n                        object: this,\n                        color: colors[i],\n                        start: this.centerx - this.radius,\n                        end: this.centerx + this.radius,\n                        direction: 'horizontal'\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.highlightFill,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n\n            // Background color\n\n            // Background color\n            prop.backgroundColor = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.backgroundColor,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n        };\n\n        //\n        // The Bar chart grow effect\n        //\n        this.grow = function () {\n            var opt = arguments[0] || {},\n                frames = opt.frames || 30,\n                frame = 0,\n                obj = this,\n                value = opt.value;\n\n            //\n            // Copy the data\n            //\n            value = this.value;\n\n            this.draw();\n\n            var iterate = function iterate() {\n                var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);\n\n                obj.value = value * multiplier;\n\n                RG.SVG.redraw();\n\n                if (frame++ < frames) {\n                    RG.SVG.FX.update(iterate);\n                } else if (opt.callback) {\n                    obj.value = value;\n                    RG.SVG.redraw();\n                    opt.callback(obj);\n                }\n            };\n\n            iterate();\n\n            return this;\n        };\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        *\n        * @param string   type The type of even to add\n        * @param function func\n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        //\n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Remove highlight from the chart (tooltips)\n        //\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n            if (highlight && highlight.parentNode) {\n                highlight.parentNode.removeChild(highlight);\n            }\n\n            RG.SVG.REG.set('highlight', null);\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.semicircularprogress.js\n// module id = 218\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.semicircularprogress.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Waterfall = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'waterfall';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['black', 'red', 'blue'], colorsSequential: false, strokestyle: '#aaa', strokestyleConnector: null, total: true, hmargin: 5, linewidth: 1, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 5, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, yaxisTextFont: null, yaxisTextSize: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.5)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();if (prop.total) {\n        var sum = RG.SVG.arraySum(this.data);this.data.push(sum);if (prop.xaxisLabels && prop.xaxisLabels.length === this.data.length - 1) {\n          prop.xaxisLabels.push('');\n        }\n      }\n      for (var i = 0, max = 0, runningTotal = 0; i < this.data.length - (prop.total ? 1 : 0); ++i) {\n        runningTotal += this.data[i];\n        max = ma.max(max, runningTotal);\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawBars();this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;var innerWidth = this.graphWidth / this.data.length - 2 * prop.hmargin,\n          outerWidth = this.graphWidth / this.data.length;var y = this.getYCoord(0),\n          total = 0;for (var i = 0; i < this.data.length; ++i) {\n        var prevValue = this.data[i - 1],\n            nextValue = this.data[i + 1],\n            currentValue = this.data[i],\n            prevTotal = total;total += parseFloat(this.data[i]) || 0;var height = ma.abs(this.data[i] / (this.scale.max - this.scale.min) * this.graphHeight);if (prevValue === null) {\n          if (currentValue > 0) {\n            y = this.getYCoord(prevTotal) - height;\n          } else {\n            y = this.getYCoord(prevTotal);\n          }\n        } else {\n          if (i == 0 && this.data[i] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight - height;\n          } else if (this.data[i] < 0 && this.data[i - 1] > 0) {} else if (this.data[i] < 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight;\n          }\n        }\n        var fill = this.data[i] > 0 ? prop.colors[0] : prop.colors[1];if (prop.colorsSequential) {\n          fill = prop.colors[i];\n        }\n        if (i === this.data.length - 1 && this.data[this.data.length - 1] >= 0) {\n          y = this.getYCoord(0) - height;if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        } else if (i === this.data.length - 1 && this.data[this.data.length - 1] < 0) {\n          y = this.getYCoord(0);if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        }\n        var x = prop.gutterLeft + outerWidth * i + prop.hmargin;if (this.data[i] === null || typeof this.data[i] === 'undefined') {\n          var axisY = this.getYCoord(0);if (prevValue < 0) {\n            y = prevY + prevHeight;\n          } else {\n            y = prevY;\n          }\n          height = this.getYCoord(0) - this.getYCoord(total);if (!prop.colorsSequential) {\n            fill = prop.colors[3] || prop.colors[2];\n          }\n          if (height < 0) {\n            y += height;height *= -1;\n          }\n        }\n        var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { x: x, y: y, width: innerWidth, height: height, stroke: prop.strokestyle, fill: fill, 'stroke-width': prop.linewidth, 'shape-rendering': 'crispEdges', 'data-index': i, 'data-original-x': x, 'data-original-y': y, 'data-original-width': innerWidth, 'data-original-height': height, 'data-original-stroke': prop.strokestyle, 'data-original-fill': fill, 'data-value': String(this.data[i]) } });this.coords[i] = { object: rect, x: x, y: y, width: innerWidth, height: height };if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[i]) {\n          var obj = this;(function (idx) {\n            rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, text: prop.tooltips[idx], event: e });obj.highlight(e.target);\n            }, false);rect.addEventListener('mousemove', function (e) {\n              e.target.style.cursor = 'pointer';\n            }, false);\n          })(i);\n        }\n        var prevX = x,\n            prevY = y,\n            prevWidth = innerWidth,\n            prevHeight = height,\n            prevValue = this.data[i];\n      }\n      for (var i = 0; i < this.coords.length; ++i) {\n        if (this.coords[i + 1] && this.coords[i + 1].object) {\n          var x1 = Number(this.coords[i].object.getAttribute('x')) + Number(this.coords[i].object.getAttribute('width')),\n              y1 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height'))),\n              x2 = x1 + 2 * prop.hmargin,\n              y2 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height')));if (this.coords[i].object.getAttribute('data-value') === 'null') {\n            y1 = parseFloat(this.coords[i].object.getAttribute('y'));y2 = parseFloat(y1);\n          }\n          var line = RG.SVG.create({ svg: this.svg, type: 'line', parent: this.svg.all, attr: { x1: x1, y1: y1 + 0.5, x2: x2, y2: y2 + 0.5, stroke: prop.strokestyleConnector || prop.strokestyle, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-x1': x1, 'data-original-y1': y1 + 0.5, 'data-original-x2': x2, 'data-original-y2': y2 + 0.5 } });\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var total = 0;for (var i = 0; i < this.coords.length; ++i) {\n          var num = this.data[i],\n              total = total + num;if (typeof num === 'number' || RG.SVG.isNull(num)) {\n            if (RG.SVG.isNull(num)) {\n              num = total;\n            }\n            var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[i] === 'string' || typeof prop.labelsAboveSpecific[i] === 'number')) {\n              str = prop.labelsAboveSpecific[i];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[i] !== 'string' && typeof prop.labelsAboveSpecific[i] !== 'number') {\n              continue;\n            }\n            var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (this.data[i] >= 0) {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n            } else {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;return this;\n    };this.wave = function () {\n      return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.svg.waterfall.js\n// module id = 219\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.svg.waterfall.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Thermometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.canvas.__object__ = this;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.type = 'thermometer';this.isRGraph = true;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.coords = [];this.graphArea = [];this.currentValue = null;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.linewidth': 1, 'chart.background.color': 'white', 'chart.strokestyle': 'black', 'chart.colors': ['Gradient(#c00:red:#f66:#fcc)'], 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.ticksize': 2, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.numticks': 10, 'chart.units.pre': '', 'chart.units.post': '', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.title': '', 'chart.title.side': '', 'chart.title.side.bold': true, 'chart.title.side.font': null, 'chart.shadow': true, 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.shadow.color': '#ddd', 'chart.resizable': false, 'chart.contextmenu': null, 'chart.adjustable': false, 'chart.value.label': true, 'chart.value.label.decimals': null, 'chart.value.label.thousand': ',', 'chart.value.label.point': '.', 'chart.labels.count': 5, 'chart.scale.visible': false, 'chart.scale.decimals': 0, 'chart.annotatable': false, 'chart.annotate.color': 'black' }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.bulb.bottom.radius.adjust', 0), _defineProperty(_properties, 'chart.bulb.bottom.radius', null), _properties);\n  if (!this.canvas) {\n    alert('[THERMOMETER] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.ylabels.count') {\n      name = 'chart.labels.count';\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.value = ma.min(this.max, this.value);this.value = ma.max(this.min, this.value);if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.scale2 = RG.getScale2(this, { max: this.max, min: this.min, strict: true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.x = this.gutterLeft;this.width = ca.width - this.gutterLeft - this.gutterRight;this.y = this.gutterTop + this.width / 2;this.halfWidth = this.width / 2;this.bulbTopCenterx = this.gutterLeft + this.width / 2;this.bulbTopCentery = this.gutterTop + this.width / 2;this.bulbTopRadius = this.width / 2;this.bulbBottomCenterx = this.gutterLeft + this.width / 2;this.bulbBottomRadius = typeof prop['chart.bulb.bottom.radius'] === 'number' ? prop['chart.bulb.bottom.radius'] : this.width * 0.75 + prop['chart.bulb.bottom.radius.adjust'];this.bulbBottomCentery = ca.height - this.gutterBottom - this.bulbBottomRadius;this.scaleTopY = this.bulbTopCentery;this.scaleBottomY = this.bulbBottomCentery - this.bulbBottomRadius;this.scaleHeight = this.scaleBottomY - this.scaleTopY;this.height = this.getYCoord(this.min) - this.getYCoord(this.value);this.coords[0] = [this.x, this.getYCoord(this.value), this.width, this.height];this.drawBackground();this.drawBar();this.drawTickMarks();this.drawLabels();if (prop['chart.title']) {\n      this.drawTitle();\n    }\n    if (prop['chart.title.side']) {\n      this.drawSideTitle();\n    }\n    if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.pathBackground();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.background.color'];co.lineWidth = 1 + prop['chart.linewidth'];co.stroke();co.fill();co.lineWidth = 1;\n  };this.drawBar = this.DrawBar = function () {\n    this.pathBar();pa2(co, 'f %', prop['chart.colors'][0]);\n  };this.pathBar = function () {\n    var barHeight = this.coords[0][3],\n        y = this.coords[0][1] + this.coords[0][3] - barHeight;\n    RG.noShadow(this);pa2(co, 'b r % % % % a % % % 0 6.28 false', this.coords[0][0], y, this.coords[0][2], this.bulbBottomCentery - y, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.pathBackground = function () {\n    pa2(this.context, 'b   r % % % %   a % % % 0 6.28 false   m % %   a % % % 0 6.28 false', this.x, this.scaleTopY, this.coords[0][2], this.bulbBottomCentery - this.scaleTopY, this.bulbTopCenterx, this.bulbTopCentery, this.bulbTopRadius, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    if (prop['chart.numticks']) {\n      var ticksize = prop['chart.ticksize'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] / 2;co.beginPath();for (var i = 0; i <= prop['chart.numticks']; ++i) {\n        var y = this.scaleBottomY - this.scaleHeight / prop['chart.numticks'] * i;co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft + ticksize, ma.round(y));co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight - ticksize, ma.round(y));\n      }\n      co.stroke();co.lineWidth = 1;\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.value.label']) {\n      co.fillStyle = prop['chart.text.color'];var text = prop['chart.scale.visible'] ? RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals'])) : RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']);RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] + this.coords[0][2] / 2, y: this.coords[0][1] + 7, text: text, valign: 'top', halign: 'center', bounding: true, boundingFill: 'white', tag: 'value.label' });\n    }\n    if (prop['chart.scale.visible']) {\n      this.drawScale();\n    }\n  };this.drawTitle = this.DrawTitle = function () {\n    co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'] + 2, x: this.gutterLeft + this.width / 2, y: this.gutterTop - 3, text: String(prop['chart.title']), valign: 'bottom', halign: 'center', bold: true, tag: 'title' });\n  };this.drawSideTitle = this.DrawSideTitle = function () {\n    var font = prop['chart.title.side.font'] ? prop['chart.title.side.font'] : prop['chart.text.font'];var size = prop['chart.title.side.size'] ? prop['chart.title.side.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: font, size: size + 2, x: this.gutterLeft - 3, y: this.scaleHeight / 2 + this.gutterTop + this.bulbTopRadius, text: String(prop['chart.title.side']), valign: 'bottom', halign: 'center', angle: 270, bold: prop['chart.title.side.bold'], tag: 'title.side', accessible: false });\n  };this.drawScale = this.DrawScale = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        step = (this.max - this.min) / numLabels;for (var i = 1; i <= numLabels; ++i) {\n      var x = ca.width - this.gutterRight + prop['chart.linewidth'] / 2,\n          y = ca.height - this.gutterBottom - 2 * this.bulbBottomRadius - this.scaleHeight / numLabels * i,\n          text = RG.numberFormat(this, String((this.min + i * step).toFixed(decimals)), units_pre, units_post);RG.text2(this, { font: font, size: size, x: x + 6, y: y, text: text, valign: 'center', tag: 'scale' });\n    }\n    RG.text2(this, { font: font, size: size, x: x + 6, y: this.bulbBottomCentery - this.bulbBottomRadius, text: RG.numberFormat(this, this.min.toFixed(decimals), units_pre, units_post), valign: 'center', tag: 'scale' });\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0; i < this.coords.length; i++) {\n      var coords = this.coords[i],\n          left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];this.pathBar();if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : '';return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    if (arg.length === 2) {\n      var mouseX = arg[0],\n          mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n    }\n    var value = (this.scaleHeight - (mouseY - this.scaleTopY)) / this.scaleHeight;value *= this.max - this.min;value += this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      this.pathBar();pa2(co, 's % f %', prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    this.pathBackground();if (co.isPointInPath(mouseX, mouseY)) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e),\n          value = this.getValue(e);if (typeof value == 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var y = ma.abs(value - this.min) / ma.abs(this.max - this.min);\n    y = y * (this.scaleBottomY - this.scaleTopY);return this.scaleBottomY - y;\n  };this.overChartArea = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];this.pathBackground();return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        callback = arguments[1] || function () {},\n        opt = arguments[0] || {},\n        frames = opt.frames ? opt.frames : 30,\n        origValue = Number(obj.currentValue),\n        newValue = obj.value;newValue = ma.min(newValue, this.max);newValue = ma.max(newValue, this.min);var diff = newValue - origValue,\n        step = diff / frames,\n        frame = 0;function iterate() {\n      obj.value = step * frame + origValue;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterate);\n      } else {\n        callback(obj);\n      }\n    }\n    iterate();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.thermometer.js\n// module id = 220\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.thermometer.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.VProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'vprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.zerostart': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.title.side': null, 'chart.title.side.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.side.size': 12, 'chart.title.side.color': 'black', 'chart.title.side.bold': true, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.label.inner': false, 'chart.labels.count': 10, 'chart.labels.position': 'right', 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.thousand': ',', 'chart.scale.point': '.', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': '#000', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.border.inner': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[PROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.arrayLinearize(this.value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    if (name == 'chart.strokestyle') {\n      prop['chart.strokestyle.inner'] = value;prop['chart.strokestyle.outer'] = value;return;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.Drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitles();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    this.AllowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle.outer'];co.fillStyle = prop['chart.colors'][0];var margin = prop['chart.margin'];var barHeight = (ca.height - this.gutterTop - this.gutterBottom) * ((RG.arraySum(this.value) - this.min) / (this.max - this.min));if (typeof this.value === 'number') {\n      co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.inner'];if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, fill: prop['chart.colors'][0] });\n    } else if (_typeof(this.value) == 'object') {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];var startPoint = ca.height - this.gutterBottom;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentHeight = (this.value[i] - this.min) / (this.max - this.min) * (ca.height - this.gutterBottom - this.gutterTop);co.fillStyle = prop['chart.colors'][i];co.beginPath();if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, stroke: co.strokeStyle });\n        }\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, fill: co.fillStyle });this.coords.push([this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight]);startPoint -= segmentHeight;\n      }\n      co.fill();\n    }\n    if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var y = this.gutterTop; y < ca.height - this.gutterBottom; y += spacing) {\n        co.moveTo(this.gutterLeft, Math.round(y));co.lineTo(this.gutterLeft + 3, Math.round(y));co.moveTo(ca.width - this.gutterRight, Math.round(y));co.lineTo(ca.width - this.gutterRight - 3, Math.round(y));\n      }\n      co.stroke();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];if (typeof this.value == 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });this.coords.push([this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight]);\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft - 4;var y = ca.height - this.gutterBottom - barHeight;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y);co.lineTo(x - 4, y - 2);co.lineTo(x - 4, y + 2);co.closePath();co.stroke();co.fill();x += this.width + 8;co.beginPath();co.moveTo(x, y);co.lineTo(x + 4, y - 2);co.lineTo(x + 4, y + 2);co.closePath();co.stroke();co.fill();pa2(co, 'b');\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': this.coords[this.coords.length - 1][1] - 5, 'text': RGraph.number_format(this, (typeof this.value == 'number' ? this.value : RG.array_sum(this.value)).toFixed(prop['chart.scale.decimals'])), 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();for (var i = 0; prop['chart.tickmarks.zerostart'] ? i <= prop['chart.numticks'] : i < prop['chart.numticks']; i++) {\n        var startX = prop['chart.labels.position'] == 'left' ? this.gutterLeft : ca.width - prop['chart.gutter.right'];var endX = prop['chart.labels.position'] == 'left' ? startX - 4 : startX + 4;var yPos = this.height * (i / prop['chart.numticks']) + this.gutterTop;\n        co.moveTo(startX, ma.round(yPos));co.lineTo(endX, ma.round(yPos));\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var position = prop['chart.labels.position'].toLowerCase();var xAlignment = position == 'left' ? 'right' : 'left';var yAlignment = 'center';var count = prop['chart.labels.count'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var decimals = prop['chart.scale.decimals'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];if (prop['chart.tickmarks']) {\n      for (var i = 0; i < count; ++i) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 7 + offsetx : ca.width - this.gutterRight + 7 + offsetx, y: (ca.height - this.gutterTop - this.gutterBottom) / count * i + this.gutterTop + offsety, text: this.scale2.labels[this.scale2.labels.length - (i + 1)], valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (prop['chart.tickmarks.zerostart'] && this.min == 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, this.min.toFixed(this.min === 0 ? 0 : decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (this.min != 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var title_size = prop['chart.title.size'] ? prop['chart.title.size'] : text_size + 2;if (prop['chart.title'].length > 0) {\n      co.fillStyle = prop['chart.title.color'];RG.text2(this, { 'font': prop['chart.title.font'] ? prop['chart.title.font'] : text_font, 'size': title_size, 'x': this.gutterLeft + (ca.width - this.gutterLeft - this.gutterRight) / 2, 'y': this.gutterTop - 5, 'text': prop['chart.title'], 'valign': 'bottom', 'halign': 'center', 'bold': prop['chart.title.bold'], 'tag': 'title' });\n    }\n    if (typeof prop['chart.title.side'] == 'string') {\n      co.fillStyle = prop['chart.title.side.color'];RG.Text2(this, { 'font': prop['chart.title.side.font'], 'size': prop['chart.title.side.size'], 'x': prop['chart.labels.position'] == 'right' ? this.gutterLeft - 10 : ca.width - this.gutterRight + 10, 'y': this.gutterTop + this.height / 2, 'text': prop['chart.title.side'], 'valign': 'bottom', 'halign': 'center', 'angle': prop['chart.labels.position'] == 'right' ? 270 : 90, 'bold': prop['chart.title.side.bold'], 'tag': 'title.side' });\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, width: w, height: h });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: w, 'width': w, 4: h, 'height': h, 5: i, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var value = (this.height - (mouseY - this.gutterTop)) / this.height;value *= this.max - this.min;value += this.min;if (value > this.max) value = this.max;if (value < this.min) value = this.min;return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      var last = shape.index === this.coords.length - 1;this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.allowAdjusting = this.AllowAdjusting = function () {\n    return;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value === 'number') {\n        RG.FireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.RedrawCanvas(this.canvas);\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var halign = prop['chart.labels.position'] == 'right' ? 'left' : 'right';var step = this.height / (labels.length - 1);co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': prop['chart.labels.position'] == 'right' ? ca.width - this.gutterRight + 7 : this.gutterLeft - 7, 'y': this.height + this.gutterTop - step * i, 'text': labels[i], 'valign': 'center', 'halign': halign, 'tag': 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var barHeight = ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'];var coord = (value - this.min) / (this.max - this.min) * barHeight;coord = ca.height - coord - prop['chart.gutter.bottom'];return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0, len = colors.length; i < len; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, height = 0; i < this.coords.length; ++i) {\n      height += this.coords[i][3];\n    }\n    co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[this.coords.length - 1][1] - 1, this.coords[0][2], height);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2], height: height });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 1, y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2] + 2, height: height + 2 + 100 });co.stroke();co.restore();co.restore();\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.exec = function (func) {\n    func(this);return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RGraph.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0; i < obj.value.length; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0; i < obj.value.length; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0; i < initial_value.length; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.vprogress.js\n// module id = 221\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.vprogress.js?")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Waterfall = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf, data: arguments[1] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'waterfall';this.max = 0;this.data = conf.data;this.isRGraph = true;this.coords = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.hbars': null, 'chart.linewidth': 1, 'chart.axis.linewidth': 1, 'chart.xaxispos': 'bottom', 'chart.numxticks': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.strokestyle': '#666', 'chart.axis.color': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymax': null, 'chart.title': '', 'chart.title.color': 'black', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.align': 'left', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['green', 'red', 'blue'], 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.override': null, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false }, _defineProperty(_properties, 'chart.axis.color', 'black'), _defineProperty(_properties, 'chart.total', true), _defineProperty(_properties, 'chart.multiplier.x', 1), _defineProperty(_properties, 'chart.multiplier.w', 1), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.ylabels.count', 5), _defineProperty(_properties, 'chart.ymin', 0), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[WATERFALL] No canvas support');return;\n  }\n  for (var i = 0, len = this.data.length; i <= len; ++i) {\n    this['$' + i] = {};\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.total' && prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RGraph.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RGraph.DrawBackgroundImage(this);this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.halfTextHeight = prop['chart.text.size'] / 2;this.max = this.getMax(this.data);var decimals = prop['chart.scale.decimals'];this.scale2 = RG.getScale2(this, { max: typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, min: prop['chart.ymin'], strict: typeof prop['chart.ymax'] === 'number' ? true : false, 'scale.decimals': Number(decimals), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.ylabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;RG.drawBars(this);\n    RG.Background.draw(this);this.DrawAxes();this.Drawbars();this.DrawLabels();if (prop['chart.xaxispos'] === 'bottom' && prop['chart.noaxes'] === false && prop['chart.noxaxis'] === false && prop['chart.ymin'] === 0) {\n      co.strokeStyle = prop['chart.axis.color'];co.strokeRect(prop['chart.gutter.left'], ca.height - prop['chart.gutter.bottom'], ca.width - this.gutterLeft - this.gutterRight, 0);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (prop['chart.noyaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.gutterTop);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));co.lineTo(ca.width - this.gutterRight, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));\n      } else {\n        var y = ma.floor(this.getYCoord(0));co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] === false && prop['chart.numyticks'] > 0) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;for (y = this.gutterTop; y < ca.height - this.gutterBottom; y += yTickGap) {\n        if (prop['chart.xaxispos'] == 'bottom' || y != (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop) {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] || prop['chart.xaxispos'] == 'center' || prop['chart.ymin'] !== 0) {\n        co.moveTo(this.gutterLeft - 3, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));\n      }\n    }\n    if (prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length + (prop['chart.total'] ? 1 : 0);\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (prop['chart.xaxispos'] == 'center') {\n        yStart = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop - 3;yEnd = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop + 3;\n      } else {\n        yStart = this.getYCoord(0) - (this.scale2.min < 0 ? 3 : 0);yEnd = this.getYCoord(0) + 3;\n      }\n      for (x = this.gutterLeft + xTickGap; x <= ca.width - this.gutterRight + 1; x += xTickGap) {\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.noyaxis']) {\n        co.moveTo(ma.round(this.gutterLeft), yStart);co.lineTo(ma.round(this.gutterLeft), yEnd);\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.getYCoord(0));co.lineTo(ma.round(this.gutterLeft), this.getYCoord(0));\n    }\n    co.stroke();\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co,\n        numYLabels = 5,\n        interval = this.grapharea / numYLabels,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];co.beginPath();co.fillStyle = color;if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        var halfInterval = interval / 2;var halfWay = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n          RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: this.gutterTop + this.grapharea / 2 / len * i + offsety, text: this.scale2.labels[len - i - 1], valign: 'center', halign: 'right', tag: 'scale' });RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: halfWay + this.grapharea / 2 / len * (i + 1) + offsety, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart']) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: halfWay, text: '0', font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      } else {\n        for (var i = 0, len = this.scale2.values.length; i < len; ++i) {\n          var y = this.getYCoord(this.scale2.values[i]) + offsety;RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: y, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart'] || prop['chart.ymin'] !== 0) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: this.getYCoord(prop['chart.ymin'] || 0), text: RG.numberFormat(this, String(Number(prop['chart.ymin'] || 0).toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals'])), prop['chart.units.pre'], prop['chart.units.post']), font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      }\n    }\n    if (prop['chart.labels'].length > 0) {\n      interval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length;var halign = 'center';var angle = prop['chart.text.angle'];if (angle) {\n        halign = 'right';angle *= -1;\n      }\n      var labels = prop['chart.labels'],\n          labelsColor = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      for (var i = 0, len = labels.length; i < len; i += 1) {\n        RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'bold': bold, 'x': this.gutterLeft + i * interval + interval / 2 + offsetx, 'y': ca.height - this.gutterBottom + 5 + this.halfTextHeight + offsety, 'text': labels[i], 'valign': 'center', 'halign': halign, 'angle': angle, 'tag': 'labels' });\n      }\n    }\n    co.stroke();co.fill();\n  };this.drawbars = this.Drawbars = function () {\n    var context = co,\n        canvas = ca,\n        hmargin = prop['chart.hmargin'],\n        runningTotal = 0;co.lineWidth = prop['chart.linewidth'] + 0.001;for (var i = 0, len = this.data.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle'];var x = ma.round(this.gutterLeft + hmargin + this.graphwidth / (this.data.length + (prop['chart.total'] ? 1 : 0)) * i * prop['chart.multiplier.x']);var h = this.getYCoord(0) - this.getYCoord(ma.abs(this.data[i]));if (i === 0) {\n        y = this.getYCoord(0) - h;\n      } else {\n        y = this.getYCoord(runningTotal) - h;\n      }\n      y = ma.round(y);var w = (ca.width - this.gutterLeft - this.gutterRight) / (this.data.length + (prop['chart.total'] ? 1 : 0)) - 2 * prop['chart.hmargin'];w = w * prop['chart.multiplier.w'];if (this.data[i] < 0) {\n        y += h;\n      }\n      co.fillStyle = this.data[i] >= 0 ? prop['chart.colors'][0] : prop['chart.colors'][1];if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      } else {\n        RG.noShadow(this);\n      }\n      co.rect(x, ma.floor(y), w, ma.floor(h));this.coords.push([x, y, w, h]);runningTotal += this.data[i];co.stroke();co.fill();\n    }\n    this.total = runningTotal;if (prop['chart.total']) {\n      h = this.getYCoord(0) - this.getYCoord(ma.abs(runningTotal));if (prop['chart.xaxispos'] == 'center') {\n        y = runningTotal > 0 ? this.getYCoord(0) - h : this.getYCoord(0);\n      } else {\n        if (runningTotal > 0) {\n          y = this.getYCoord(0) - h;\n        } else {\n          y = this.getYCoord(0);\n        }\n      }\n      x = x + prop['chart.hmargin'] * 2 + w;co.fillStyle = prop['chart.colors'][2];pa2(co, 'b r % % % % s % f %', x, y, w, h, co.strokeStyle, co.fillStyle);var previousCoords = [x, y, w, ma.abs(h)];this.coords.push(previousCoords);\n    }\n    RG.noShadow(this);co.lineWidth = 1;co.strokeStyle = '#666';co.beginPath();for (var i = 1, len = this.coords.length; i < len; i += 1) {\n      var prev = this.coords[i - 1],\n          curr = this.coords[i],\n          prevData = this.data[i - 1];\n      var y = prevData > 0 ? prev[1] : prev[1] + prev[3];co.moveTo(prev[0] + prev[2], y);co.lineTo(curr[0], prevData > 0 ? prev[1] : prev[1] + prev[3]);\n    }\n    co.stroke();\n  };this.getShape = this.getBar = function (e) {\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getMax = function (data) {\n    var runningTotal = 0,\n        max = 0;for (var i = 0, len = data.length; i < len; i += 1) {\n      runningTotal += data[i];max = ma.max(ma.abs(runningTotal), max);\n    }\n    return ma.abs(max);\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getYCoord = function (value) {\n    if (prop['chart.xaxispos'] == 'center') {\n      if (value < -1 * this.max) {\n        return null;\n      }\n      var coord = value / this.max * (this.grapharea / 2);return this.gutterTop + this.grapharea / 2 - coord;\n    } else {\n      var coord = (value - this.scale2.min) / (this.max - this.scale2.min) * this.grapharea;coord = coord + this.gutterBottom;return ca.height - coord;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var numFrame = 0;var obj = this;var data = RG.array_clone(obj.data);for (var i = 0, len = obj.data.length; i < len; ++i) {\n      obj.data[i] /= frames;\n    }\n    if (obj.Get('chart.ymax') == null) {\n      var max = obj.getMax(data);var scale2 = RG.getScale2(obj, { 'max': max });obj.Set('chart.ymax', scale2.max);\n    }\n    function iterator() {\n      for (var i = 0; i < obj.data.length; ++i) {\n        obj.data[i] = data[i] * RG.Effects.getEasingMultiplier(frames, numFrame);\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (++numFrame < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  return this;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./other_components/rgraph/libraries/RGraph.waterfall.js\n// module id = 222\n// module chunks = 1\n\n//# sourceURL=webpack:///./other_components/rgraph/libraries/RGraph.waterfall.js?")}]),[161]);