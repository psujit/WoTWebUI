/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 191);
/******/ })
/************************************************************************/
/******/ (Array(191).concat([
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(229);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
module.exports = __webpack_require__(252);


/***/ }),
/* 192 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bar';this.max = 0;this.stackedOrGrouped = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.cachedBackgroundCanvas = null;this.firstDraw = true;this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.background.hbars': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.hmargin.grouped': 1, 'chart.strokecolor': 'rgba(0,0,0,0)', 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.size': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'rgba(0,0,0,0)', 'chart.labels.above.angle': null, 'chart.labels.above.offset': 4, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['red', '#0f0', 'blue', 'pink', 'orange', 'cyan', 'black', 'white', 'green', 'magenta'], 'chart.colors.sequential': false, 'chart.colors.reverse': false, 'chart.grouping': 'grouped', 'chart.variant': 'bar', 'chart.variant.sketch.verticals': true, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot.xonly': false, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.halign': 'right', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.text.size': 10, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.linewidth': 1, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.adjustable.only': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.numxticks': null, 'chart.bevel': false, 'chart.errorbars': false, 'chart.errorbars.color': 'black', 'chart.errorbars.capped': true, 'chart.errorbars.capped.width': 14, 'chart.errorbars.linewidth': 1, 'chart.combinedchart.effect': null, 'chart.combinedchart.effect.options': null, 'chart.combinedchart.effect.callback': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[BAR] No canvas support');return;\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (typeof data[i] === 'string') {\n      data[i] = parseFloat(data[i]);\n    } else if (_typeof(data[i]) === 'object' && data[i]) {\n      for (var j = 0; j < data[i].length; ++j) {\n        if (typeof data[i][j] === 'string') {\n          data[i][j] = parseFloat(data[i][j]);\n        }\n      }\n    } else if (typeof data[i] === 'undefined') {\n      data[i] = null;\n    }\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (_typeof(data[i]) === 'object' && !RGraph.is_null(data[i])) {\n      this.stackedOrGrouped = true;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  this.data = data;this.original_data = RGraph.arrayClone(data);this.coords = [];this.coords2 = [];this.coordsText = [];this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.xlabels.offset') {\n      name = 'chart.labels.offsety';\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    if (name == 'chart.strokestyle') {\n      name = 'chart.strokecolor';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n      if (value == 'top') {\n        for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] == 'number' && this.data[i] > 0) {\n            alert('[BAR] The data element with index ' + i + ' should be negative');\n          }\n        }\n      }\n    }\n    if (name.toLowerCase() == 'chart.linewidth' && value == 0) {\n      value = 0.0001;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if ((prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot') && _typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips'] && prop['chart.tooltips'].length > 0) {\n      alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');\n    }\n    this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;RG.background.Draw(this);this.drawbars();this.drawAxes();this.DrawLabels();if (prop['chart.bevel'] || prop['chart.bevelled']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.errorbars']) {\n      this.drawErrorbars();\n    }\n    if (prop['chart.labels.ingraph']) {\n      RG.DrawInGraphLabels(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    var xaxispos = prop['chart.xaxispos'];var yaxispos = prop['chart.yaxispos'];var isSketch = prop['chart.variant'] == 'sketch';co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (RG.ISSAFARI == -1) {\n      co.lineCap = 'square';\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (yaxispos == 'right') {\n        co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      }\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (xaxispos == 'center') {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - (isSketch ? 2 : 0)));\n      } else if (xaxispos == 'top') {\n        co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ma.round(this.getYCoord(0) - (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ma.round(this.getYCoord(0) + (isSketch ? 2 : 0)));\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && !isSketch) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;var xpos = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;if (this.properties['chart.numyticks'] > 0) {\n        for (y = this.gutterTop; xaxispos == 'center' ? y <= ca.height - this.gutterBottom : y < ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0); y += yTickGap) {\n          if (xaxispos == 'center' && y == this.gutterTop + this.grapharea / 2) {\n            continue;\n          }\n          if (xaxispos == 'top' && y == this.gutterTop) {\n            continue;\n          }\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(y));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(y));\n        }\n        if (xaxispos === 'bottom' && prop['chart.ymin'] !== 0) {\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(ca.height - prop['chart.gutter.bottom']));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(ca.height - prop['chart.gutter.bottom']));\n        }\n      }\n      if (prop['chart.noxaxis']) {\n        if (xaxispos == 'center') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));co.lineTo(xpos, Math.round(ca.height / 2));\n        } else if (xaxispos == 'top') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));co.lineTo(xpos, Math.round(this.gutterTop));\n        } else {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    if (prop['chart.noxaxis'] == false && !isSketch) {\n      if (typeof prop['chart.numxticks'] == 'number') {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      } else {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;\n      }\n      if (xaxispos == 'bottom') {\n        yStart = prop['chart.ymin'] < 0 ? this.getYCoord(0) - 3 : this.getYCoord(0);yEnd = this.getYCoord(0) + 3;\n      } else if (xaxispos == 'top') {\n        yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n      } else if (xaxispos == 'center') {\n        yStart = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + 3;yEnd = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - 3;\n      }\n      var noEndXTick = prop['chart.noendxtick'];for (x = this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0), len = ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0); x < len; x += xTickGap) {\n        if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < ca.width - this.gutterRight) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && !noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && x > this.gutterLeft && noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {\n        if (typeof prop['chart.numxticks'] == 'number' && prop['chart.numxticks'] > 0) {\n          co.moveTo(Math.round(this.gutterLeft), yStart);co.lineTo(Math.round(this.gutterLeft), yEnd);\n        }\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {\n      if (xaxispos == 'center') {\n        co.moveTo(ma.round(this.gutterLeft), ca.height / 2 - 3);co.lineTo(ma.round(this.gutterLeft), ca.height / 2 + 3);\n      } else {\n        co.moveTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom + 3);\n      }\n    }\n    co.stroke();\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokecolor'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0,\n        decimals = prop['chart.scale.decimals'];if (prop['chart.ymax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.ymax'], 'strict': prop['chart.scale.round'] ? false : true, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });\n    } else {\n      var errorbars = prop['chart.errorbars'];if (typeof errorbars === 'number') {\n        var value = errorbars;prop['chart.errorbars'] = [];for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] === 'number') {\n            prop['chart.errorbars'].push([value, null]);\n          } else if (_typeof(this.data[i]) === 'object' && !RG.isNull(this.data[i])) {\n            for (var j = 0; j < this.data[i].length; ++j) {\n              prop['chart.errorbars'].push([value, null]);\n            }\n          }\n        }\n        errorbars = prop['chart.errorbars'];\n      }\n      for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = prop['chart.grouping'] === 'grouped' ? Number(RG.arrayMax(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(this.data[i]);\n        }\n        this.max = ma.max(ma.abs(this.max), ma.abs(value) + Number(_typeof(prop['chart.errorbars']) === 'object' && _typeof(prop['chart.errorbars'][i]) === 'object' && !RG.isNull(prop['chart.errorbars'][i]) && typeof prop['chart.errorbars'][i][0] === 'number' ? prop['chart.errorbars'][i][0] : 0));\n      }\n      this.scale2 = RGraph.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.adjustable'] && !prop['chart.ymax']) {\n      this.Set('chart.ymax', this.scale2.max);\n    }\n    if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RGraph.DrawBars(this);\n    }\n    var variant = prop['chart.variant'];if (variant === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var xaxispos = prop['chart.xaxispos'],\n        width = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length,\n        orig_height = height,\n        hmargin = prop['chart.hmargin'],\n        shadow = prop['chart.shadow'],\n        shadowColor = prop['chart.shadow.color'],\n        shadowBlur = prop['chart.shadow.blur'],\n        shadowOffsetX = prop['chart.shadow.offsetx'],\n        shadowOffsetY = prop['chart.shadow.offsety'],\n        strokeStyle = prop['chart.strokecolor'],\n        colors = prop['chart.colors'],\n        sequentialColorIndex = 0;\n    var height;for (i = 0, len = this.data.length; i < len; i += 1) {\n      if (RG.arraySum(this.data[i]) < 0) {\n        var height = (RG.arraySum(this.data[i]) + this.scale2.min) / (this.scale2.max - this.scale2.min);\n      } else {\n        var height = (RG.arraySum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min);\n      }\n      height *= ma.abs(this.getYCoord(this.scale2.max) - this.getYCoord(this.scale2.min));var x = i * width + this.gutterLeft;var y = xaxispos == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - height : ca.height - height - this.gutterBottom;if (xaxispos == 'top') {\n        y = this.gutterTop + ma.abs(height);\n      }\n      if (height < 0) {\n        y += height;height = ma.abs(height);\n      }\n      if (shadow) {\n        co.shadowColor = shadowColor;co.shadowBlur = shadowBlur;co.shadowOffsetX = shadowOffsetX;co.shadowOffsetY = shadowOffsetY;\n      }\n      co.beginPath();if (typeof this.data[i] == 'number') {\n        if (xaxispos === 'bottom' && prop['chart.ymin'] < 0) {\n          if (this.data[i] >= 0) {\n            height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          } else {\n            y = this.getYCoord(0);height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          }\n        }\n        var barWidth = width - 2 * hmargin;if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        co.strokeStyle = strokeStyle;co.fillStyle = colors[0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = colors[i];\n        }\n        if (variant == 'sketch') {\n          co.lineCap = 'round';var sketchOffset = 3;co.beginPath();co.strokeStyle = colors[0];if (prop['chart.colors.sequential']) {\n            co.strokeStyle = colors[i];\n          }\n          co.moveTo(x + hmargin + 2, y + height - 2);co.lineTo(x + hmargin - 1, y - 4);co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));co.bezierCurveTo(x + (hmargin + width) * 0.33, y + 15 + (this.data[i] < 0 ? height - 10 : 0), x + (hmargin + width) * 0.66, y + 5 + (this.data[i] < 0 ? height - 10 : 0), x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0));co.moveTo(x + hmargin + width - 5, y - 5);co.lineTo(x + hmargin + width - 3, y + height - 3);if (prop['chart.variant.sketch.verticals']) {\n            for (var r = 0.2; r <= 0.8; r += 0.2) {\n              co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - r * width, y - 1);co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - r * width, y + height + (r == 0.2 ? 1 : -2));\n            }\n          }\n          co.stroke();\n        } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {\n          if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, barWidth, height]);\n          }\n          if (variant == 'glass') {\n            RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);\n          } else {\n            co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.fill();RG.NoShadow(this);co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.stroke();\n          }\n          if (variant == '3d') {\n            var prevStrokeStyle = co.strokeStyle;var prevFillStyle = co.fillStyle;if (this.data[i] >= 0) {\n              co.beginPath();co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.gutterTop + this.getYCoord(0) ? this.getYCoord(this.data[i]) - prop['chart.variant.threed.offsety'] : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.closePath();co.stroke();co.fill();if (this.data[i] > 0) {\n              co.beginPath();co.fillStyle = 'rgba(255,255,255,0.5)';co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.fillStyle = 'rgba(0,0,0,0.4)';co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.getYCoord(0) ? this.getYCoord(0) : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          } else if (variant == 'glass') {\n            var grad = co.createLinearGradient(x + hmargin, y, x + hmargin + barWidth / 2, y);grad.addColorStop(0, 'rgba(255,255,255,0.9)');grad.addColorStop(1, 'rgba(255,255,255,0.5)');co.beginPath();co.fillStyle = grad;co.fillRect(x + hmargin + 2, y + (this.data[i] > 0 ? 2 : 0), barWidth / 2 - 2, height - 2);co.fill();\n          }\n        } else if (variant == 'dot') {\n          co.beginPath();co.moveTo(x + width / 2, y);co.lineTo(x + width / 2, y + height);co.stroke();co.beginPath();co.fillStyle = this.properties['chart.colors'][i];co.arc(x + width / 2, y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[i];\n          }\n          co.stroke();co.fill();\n        } else {\n          alert('[BAR] Warning! Unknown chart.variant: ' + variant);\n        }\n        this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (this.scale2.min) {\n          alert(\"[ERROR] Stacked Bar charts with a Y min are not supported\");\n        }\n        var barWidth = width - 2 * hmargin;var redrawCoords = [];var startY = 0;var dataset = this.data[i];if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        for (j = 0; j < dataset.length; ++j) {\n          if (xaxispos == 'center') {\n            alert(\"[BAR] It's pointless having the X axis position at the center on a stacked bar chart.\");return;\n          }\n          if (this.data[i][j] < 0) {\n            alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');return;\n          }\n          co.strokeStyle = strokeStyle;\n          co.fillStyle = colors[j];if (prop['chart.colors.reverse']) {\n            co.fillStyle = colors[this.data[i].length - j - 1];\n          }\n          if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var height = dataset[j] / this.scale2.max * (ca.height - this.gutterTop - this.gutterBottom);if (xaxispos == 'center') {\n            height /= 2;\n          }\n          var totalHeight = RGraph.array_sum(dataset) / this.scale2.max * (ca.height - hmargin - this.gutterTop - this.gutterBottom);this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, width - 2 * hmargin, height + 1]);\n          }\n          if (height > 0) {\n            co.strokeRect(x + hmargin, y, width - 2 * hmargin, height);co.fillRect(x + hmargin, y, width - 2 * hmargin, height);\n          }\n          if (j == 0) {\n            var startY = y;var startX = x;\n          }\n          if (shadow) {\n            redrawCoords.push([x + hmargin, y, width - 2 * hmargin, height, co.fillStyle]);\n          }\n          if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;if (j == 0) {\n              co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();if (j == 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          y += height;\n        }\n        if (shadow) {\n          RGraph.NoShadow(this);for (k = 0; k < redrawCoords.length; ++k) {\n            co.strokeStyle = strokeStyle;co.fillStyle = redrawCoords[k][4];co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.stroke();co.fill();\n          }\n          redrawCoords = [];\n        }\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var redrawCoords = [];co.lineWidth = prop['chart.linewidth'];for (j = 0; j < this.data[i].length; ++j) {\n          co.strokeStyle = strokeStyle;co.fillStyle = colors[j];if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var individualBarWidth = (width - 2 * hmargin) / this.data[i].length;var height = (this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : -1 * this.scale2.min)) / (this.scale2.max - this.scale2.min) * (ca.height - this.gutterTop - this.gutterBottom);var groupedMargin = prop['chart.hmargin.grouped'];var startX = x + hmargin + j * individualBarWidth;if (individualBarWidth < 0) {\n            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n          }\n          if (xaxispos == 'center') {\n            height /= 2;\n          }\n          if (xaxispos == 'top') {\n            var startY = this.gutterTop;var height = Math.abs(height);\n          } else if (xaxispos == 'center') {\n            var startY = this.gutterTop + this.grapharea / 2 - height;\n          } else {\n            var startY = this.getYCoord(0);var height = ma.abs(ma.abs(this.getYCoord(this.data[i][j])) - this.getYCoord(0));if (this.data[i][j] >= 0) {\n              startY -= height;\n            }\n          }\n          co.strokeRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);co.fillRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);y += height;if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;var hmarginGrouped = prop['chart.hmargin.grouped'];if (this.data[i][j] >= 0) {\n              co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped - 1, startY);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 && startY + height - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped - 1, startY + height);co.closePath();co.fill();co.stroke();if (this.data[i][j] >= 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped, startY);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 && startY + height - 5 < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (height < 0) {\n            height = Math.abs(height);startY = startY - height;\n          }\n          this.coords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (prop['chart.shadow']) {\n            redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height, co.fillStyle]);\n          }\n        }\n        if (redrawCoords.length) {\n          RGraph.NoShadow(this);co.lineWidth = prop['chart.linewidth'];co.beginPath();for (var j = 0; j < redrawCoords.length; ++j) {\n            co.fillStyle = redrawCoords[j][4];co.strokeStyle = prop['chart.strokecolor'];co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);\n          }\n          co.fill();co.stroke();redrawCoords = [];\n        }\n      } else {\n        this.coords.push([]);\n      }\n      co.closePath();\n    }\n    if (prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right') {\n      RG.draw3DYAxis(this);\n    }\n    RGraph.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co;var text_angle = prop['chart.text.angle'],\n        text_size = prop['chart.text.size'],\n        labels = prop['chart.labels'];\n    if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'top') this.Drawlabels_top();if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();\n    }\n    if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) == 'object' && labels) {\n      var yOffset = Number(prop['chart.labels.offsety']),\n          xOffset = Number(prop['chart.labels.offsetx']),\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.text.angle'] != 0) {\n        var valign = 'center';var halign = 'right';var angle = 0 - prop['chart.text.angle'];\n      } else {\n        var valign = 'top';var halign = 'center';var angle = 0;\n      }\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;\n      var i = 0;var font = prop['chart.text.font'];for (x = this.gutterLeft + xTickGap / 2; x <= ca.width - this.gutterRight; x += xTickGap) {\n        RG.text2(this, _defineProperty({ 'font': font, 'size': text_size, 'x': x + xOffset, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + yOffset - 5 : ca.height - this.gutterBottom + yOffset + 3, 'bold': bold, 'text': String(labels[i++]), 'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign, 'halign': halign, 'tag': 'label', 'marker': false, 'angle': angle }, 'tag', 'labels'));\n      }\n    }\n    this.drawAboveLabels();\n  };this.drawlabels_top = this.Drawlabels_top = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.xaxispos'] == 'top') {\n      var context = co;var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea * (i / labels.length) + grapharea / labels.length;RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      var labels = this.scale2.labels;for (var i = 0; i < labels.length; ++i) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea / labels.length * (i + 1) + offsety, 'text': '-' + labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'text': (this.scale2.min != 0 ? '-' : '') + RGraph.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n    }\n    co.fill();\n  };this.drawlabels_center = this.Drawlabels_center = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];co.fillStyle = prop['chart.text.color'];if (prop['chart.xaxispos'] == 'center') {\n      var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var context = co;var align = '';var xpos = 0;var boxed = false;var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea / 2 / (labels.length - 1) * i;RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        for (var i = labels.length - 1; i >= 1; --i) {\n          var y = this.gutterTop + grapharea * (i / ((labels.length - 1) * 2)) + grapharea / 2;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[labels.length - i - 1]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        var y = this.gutterTop + this.halfgrapharea - this.halfgrapharea / numYLabels * (i + 1);var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      for (var i = this.scale2.labels.length - 1; i >= 0; --i) {\n        var y = this.gutterTop + this.halfgrapharea / numYLabels * (i + 1) + this.halfgrapharea;var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': '-' + text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {\n        var _RG$Text;\n\n        RG.Text2(this, (_RG$Text = { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.halfgrapharea + offsety, 'text': RG.number_format(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center' }, _defineProperty(_RG$Text, 'valign', 'center'), _defineProperty(_RG$Text, 'halign', align), _defineProperty(_RG$Text, 'bordered', boxed), _defineProperty(_RG$Text, 'tag', 'scale'), _RG$Text));\n      }\n    }\n  };this.drawlabels_bottom = this.Drawlabels_bottom = function () {\n    var text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        context = this.context,\n        align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left',\n        font = prop['chart.text.font'],\n        numYLabels = prop['chart.ylabels.count'],\n        ymin = prop['chart.ymin'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n    } else {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n    }\n    if (prop['chart.ylabels.specific'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n        var y = this.gutterTop + grapharea * (i / (labels.length - 1));RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      return;\n    }\n    var gutterTop = this.gutterTop;var halfTextHeight = this.halfTextHeight;var scale = this.scale;for (var i = 0; i < numYLabels; ++i) {\n      var text = this.scale2.labels[i];RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea - this.grapharea / numYLabels * (i + 1) + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n    }\n    if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n      RG.text2(this, { font: font, size: text_size, x: xpos + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), valign: 'center', halign: align, bordered: boxed, tag: 'scale' });\n    }\n    co.fill();\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };this.getShape = this.getBar = function (e) {\n    var obj = arguments[1] ? arguments[1] : this;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        canvas = obj.canvas,\n        context = obj.context,\n        coords = obj.coords;\n    for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var left = coords[i][0],\n          top = coords[i][1],\n          width = coords[i][2],\n          height = coords[i][3],\n          prop = obj.properties;\n      if (prop['chart.tooltips.hotspot.xonly']) {\n        pa2(co, 'b r % % % %', left, this.gutterTop, width, ca.height - this.gutterBottom);\n      } else {\n        pa2(co, 'b r % % % %', left, top, width, height);\n      }\n      if (co.isPointInPath(mouseX, mouseY)) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        var dataset = 0,\n            idx = i;\n        while (idx >= (_typeof(obj.data[dataset]) === 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {\n          if (typeof obj.data[dataset] === 'number') {\n            idx -= 1;\n          } else if (obj.data[dataset]) {\n            idx -= obj.data[dataset].length;\n          } else {\n            idx -= 1;\n          }\n          dataset++;\n        }\n        if (typeof obj.data[dataset] == 'number') {\n          idx = null;\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset };\n      }\n    }\n    return null;\n  };this.getShapeByX = function (e) {\n    var canvas = e.target;var mouseCoords = RGraph.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var left = obj.coords[i][0];var top = obj.coords[i][1];var width = obj.coords[i][2];var height = obj.coords[i][3];var prop = obj.properties;if (mouseX >= left && mouseX <= left + width) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < prop['chart.gutter.top'] || mouseY > ca.height - prop['chart.gutter.bottom'] || mouseX < prop['chart.gutter.left'] || mouseX > ca.width - prop['chart.gutter.right']) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value *= 2;if (value >= 0) {\n        value += this.scale2.min;\n      } else {\n        value -= this.scale2.min;\n      }\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value = this.scale2.max - value;value = ma.abs(value) * -1;\n    } else {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value += this.scale2.min;\n    }\n    return value;\n  };this.getYCoord = function (value) {\n    if (value > this.scale2.max) {\n      return null;\n    }\n    var co = this.context,\n        ca = this.canvas,\n        prop = this.properties;var y,\n        xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      if (value < 0) {\n        value = ma.abs(value);\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * this.grapharea;y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if (value < this.scale2.min) {\n        value = this.scale2.min;\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min);y *= ca.height - this.gutterTop - this.gutterBottom;y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= prop['chart.gutter.left'] && mouseXY[0] <= ca.width - prop['chart.gutter.right'] && mouseXY[1] >= prop['chart.gutter.top'] && mouseXY[1] <= ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');\n      if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.isNull(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.highlight.stroke'] = prop['chart.highlight.stroke'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.strokecolor'] = prop['chart.strokecolor'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.strokecolor'] = this.parseSingleColorForGradient(prop['chart.strokecolor']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RGraph.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    var coords = this.coords;var coords2 = this.coords2;var prop = this.properties;var co = this.context;var ca = this.canvas;if (prop['chart.grouping'] == 'stacked') {\n      for (var i = 0; i < coords2.length; ++i) {\n        if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {\n          var x = coords2[i][0][0];var y = coords2[i][0][1];var w = coords2[i][0][2];var arr = [];for (var j = 0; j < coords2[i].length; ++j) {\n            arr.push(coords2[i][j][3]);\n          }\n          var h = RGraph.array_sum(arr);co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 100);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    } else {\n      for (var i = 0; i < coords.length; ++i) {\n        if (coords[i]) {\n          var x = coords[i][0];var y = coords[i][1];var w = coords[i][2];var h = coords[i][3];var xaxispos = prop['chart.xaxispos'];var xaxis_ycoord = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;if (xaxispos == 'top' || xaxispos == 'center' && y + h > xaxis_ycoord) {\n            y = y - 100;h = h + 100;\n          } else {\n            y = y;h = h + 100;\n          }\n          co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 6);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    this.coords2.forEach(function (value, idx, arr) {\n      if (_typeof(value[index]) == 'object' && value[index]) {\n        var x = value[index][0];\n        var y = value[index][1];\n        var w = value[index][2];\n        var h = value[index][3];\n        co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.strokeRect(x, y, w, h);co.fillRect(x, y, w, h);\n      }\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawAboveLabels = function () {\n    var labels = prop['chart.labels.above'],\n        specific = prop['chart.labels.above.specific'],\n        color = prop['chart.labels.above.color'],\n        background = prop['chart.labels.above.background'],\n        decimals = prop['chart.labels.above.decimals'],\n        size = prop['chart.labels.above.size'],\n        angle = -1 * prop['chart.labels.above.angle'],\n        unitsPre = prop['chart.labels.above.units.pre'],\n        unitsPost = prop['chart.labels.above.units.post'],\n        coords = this.coords,\n        coords2 = this.coords2,\n        data = this.data,\n        ldata = RG.arrayLinearize(this.data),\n        offset = prop['chart.labels.above.offset'],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        grouping = prop['chart.grouping'];\n    RG.noShadow(this);co.fillStyle = typeof color === 'string' ? color : prop['chart.text.color'];if (labels && grouping === 'grouped') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (typeof data[i] === 'number' && data[i] >= 0) {\n          var angle = angle;var halign = angle ? 'left' : 'center';var valign = angle !== 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'marker': false, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'tag': 'labels.above' });sequentialIndex++;\n        } else if (typeof data[i] === 'number' && data[i] < 0) {\n          var angle = angle;var halign = angle ? 'right' : 'center';var valign = angle !== 0 ? 'center' : 'top';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + coords2[i][0][3] + offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        } else if (_typeof(data[i]) === 'object') {\n          for (var j = 0, len2 = data[i].length; j < len2; j += 1) {\n            var angle = angle;var halign = data[i][j] < 0 ? 'right' : 'left';halign = angle === 0 ? 'center' : halign;var valign = data[i][j] < 0 ? 'top' : 'bottom';valign = angle != 0 ? 'center' : valign;RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][j][0] + coords2[i][j][2] / 2, 'y': coords2[i][j][1] + (data[i][j] < 0 ? coords2[i][j][3] + offset : -offset), 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i][j]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n          }\n        }\n      }\n    } else if (labels && grouping === 'stacked') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (_typeof(data[i]) === 'object') {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(RG.arraySum(data[i])).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex += data[i].length;\n        } else {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        }\n      }\n    }\n  };this.firstDrawFunc = function () {};this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        labelsAbove = this.get('labelsAbove');opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(this.original_data);this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('ymax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.colorWave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [], colors = obj.properties['chart.colors'];if (colors.length <= obj.data.length) {\n      obj.set('chart.colors.sequential', true);colors = RG.arrayPad(colors, obj.data.length, colors[colors.length - 1]);\n    }\n    var framesperbar = opt.frames / 2,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        originalColors = RG.arrayClone(obj.properties['chart.colors']);for (var i = 0, len = originalColors.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (originalColors.length - 1) * i;opt.counters[i] = 0;\n    }\n    function iterator() {\n      ++frame;for (var i = 0, len = colors.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i] && colors[i].match(/^rgba?\\(([0-9 ]+),([0-9 ]+),([0-9 ]+)(,([ 0-9.]+)?)\\)/)) {\n          colors[i] = 'rgba({1},{2},{3},{4})'.format(RegExp.$1, RegExp.$2, RegExp.$3, (frame - opt.startFrames[i]) / framesperbar);\n        } else {\n          colors[i] = colors[i].replace(/,[0-9. ]+\\)/, ',0)');\n        }\n      }\n      if (frame >= opt.frames) {\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    if (RG.isArray(opt.data)) {\n      var ymax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            ymax = ma.max(ymax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseInt(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseInt(RegExp.$2);\n          }\n          ymax = ma.max(ymax, opt.data[i]);\n        } else {\n          ymax = ma.max(ymax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    this.set('labelsAbove', false);if (prop['chart.ymax'] == null) {\n      var ymax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          ymax = ma.max(ymax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          ymax = ma.max(ymax, ma.abs(RG.arrayMax(group)));\n        } else {\n          ymax = ma.max(ymax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    if (typeof opt.ymax === 'number') {\n      obj.set('ymax', opt.ymax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.drawErrorbars = function () {\n    var coords = this.coords,\n        color = prop['chart.errorbars.color'] || 'black',\n        default_halfwidth = ma.min(prop['chart.errorbars.capped.width'], coords[0][2]) / 2,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0;halfwidth = 0;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      }\n      var halfwidth = errorbars[i] && typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n        halfwidth = 0;\n      }\n      if (typeof errorbars[i] === 'number') {\n        length = ma.abs(this.getYCoord(errorbars[i]) - this.getYCoord(0));if (length) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - length, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - length), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - length), color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = ma.abs(this.getYCoord(errorbars[i][0]) - this.getYCoord(0));if (typeof errorbars[i][1] === 'string') {\n          color = errorbars[i][1];\n        } else if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n          halfwidth = 0;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - positiveLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] + negativeLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n      if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      }\n    }\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only']) || !RG.isArray(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};RGraph.CombinedChart = function () {\n  this.objects = [];var objects = [];if (RGraph.isArray(arguments[0])) {\n    objects = arguments[0];\n  } else {\n    for (var i = 0; i < arguments.length; i += 1) {\n      objects[i] = arguments[i];\n    }\n  }\n  for (var i = 0; i < objects.length; ++i) {\n    this.objects[i] = objects[i];this.objects[i].set({ gutterLeft: this.objects[0].get('gutter.left'), gutterRight: this.objects[0].get('gutter.right'), gutterTop: this.objects[0].get('gutter.top'), gutterBottom: this.objects[0].get('gutter.bottom') });if (this.objects[i].type == 'line') {\n      var obj = this.objects[i];obj.set('hmargin', (this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length / 2);obj.set('noaxes', true);obj.set('backgroundGrid', false);obj.set('ylabels', false);\n    }\n    if (this.objects[i].get('chart.resizable')) {\n      var resizable_object = obj;\n    }\n  }\n  if (resizable_object) {\n    var myOnresizebeforedraw = function myOnresizebeforedraw(obj) {\n      var gutterLeft = obj.get('gutterLeft');var gutterRight = obj.get('gutterRight');obj.set('hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));\n    };\n\n    RGraph.AddCustomEventListener(resizable_object, 'onresizebeforedraw', myOnresizebeforedraw);\n  }\n};RGraph.CombinedChart.prototype.add = RGraph.CombinedChart.prototype.Add = function (obj) {\n  this.objects.push(obj);\n};RGraph.CombinedChart.prototype.draw = RGraph.CombinedChart.prototype.Draw = function () {\n  for (var i = 0; i < this.objects.length; ++i) {\n    if (this.objects[i].properties['chart.combinedchart.effect']) {\n      var options = this.objects[i].properties['chart.combinedchart.effect.options'] ? eval('(' + this.objects[i].properties['chart.combinedchart.effect.options'] + ')') : null,\n          callback = this.objects[i].properties['chart.combinedchart.effect.callback'],\n          func = this.objects[i].properties['chart.combinedchart.effect'];this.objects[i][func](options, callback);\n    } else {\n      this.objects[i].draw();\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguYmFyLmpzPzBlYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5CYXI9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5kYXRhPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksZGF0YT1jb25mLmRhdGEscGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlfWVsc2V7dmFyIGlkPWNvbmYsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxkYXRhPWFyZ3VtZW50c1sxXX1cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9Y2FudmFzO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLnR5cGU9J2Jhcic7dGhpcy5tYXg9MDt0aGlzLnN0YWNrZWRPckdyb3VwZWQ9ZmFsc2U7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5jYWNoZWRCYWNrZ3JvdW5kQ2FudmFzPW51bGw7dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6JyNkZGQnLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQud2lkdGgnOjEsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbic6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzo1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOjIwLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGFzaGVkJzpmYWxzZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRvdHRlZCc6ZmFsc2UsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS54JzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnknOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uudyc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5oJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmFsaWduJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJzpudWxsLCdjaGFydC5udW15dGlja3MnOjEwLCdjaGFydC5obWFyZ2luJzo1LCdjaGFydC5obWFyZ2luLmdyb3VwZWQnOjEsJ2NoYXJ0LnN0cm9rZWNvbG9yJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0LmF4aXMubGluZXdpZHRoJzoxLCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MzUsJ2NoYXJ0Lmd1dHRlci5sZWZ0JzoyNSwnY2hhcnQuZ3V0dGVyLnJpZ2h0JzoyNSwnY2hhcnQubGFiZWxzJzpudWxsLCdjaGFydC5sYWJlbHMuYm9sZCc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmluZ3JhcGgnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZSc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5hYm92ZS5kZWNpbWFscyc6MCwnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmFib3ZlLmJhY2tncm91bmQnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQubGFiZWxzLmFib3ZlLmFuZ2xlJzpudWxsLCdjaGFydC5sYWJlbHMuYWJvdmUub2Zmc2V0Jzo0LCdjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucHJlJzonJywnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnOicnLCdjaGFydC55bGFiZWxzJzp0cnVlLCdjaGFydC55bGFiZWxzLmNvdW50Jzo1LCdjaGFydC55bGFiZWxzLmluc2lkZSc6ZmFsc2UsJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eCc6MCwnY2hhcnQueWxhYmVscy5vZmZzZXR5JzowLCdjaGFydC5sYWJlbHMub2Zmc2V0eCc6MCwnY2hhcnQubGFiZWxzLm9mZnNldHknOjAsJ2NoYXJ0LnhheGlzcG9zJzonYm90dG9tJywnY2hhcnQueWF4aXNwb3MnOidsZWZ0JywnY2hhcnQudGV4dC5hbmdsZSc6MCwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LnltaW4nOjAsJ2NoYXJ0LnltYXgnOm51bGwsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUueGF4aXMnOicnLCdjaGFydC50aXRsZS54YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS54YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMnOicnLCdjaGFydC50aXRsZS55YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS55YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMucG9zJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5wb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmhhbGlnbic6bnVsbCwnY2hhcnQudGl0bGUudmFsaWduJzpudWxsLCdjaGFydC5jb2xvcnMnOlsncmVkJywnIzBmMCcsJ2JsdWUnLCdwaW5rJywnb3JhbmdlJywnY3lhbicsJ2JsYWNrJywnd2hpdGUnLCdncmVlbicsJ21hZ2VudGEnXSwnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnOmZhbHNlLCdjaGFydC5jb2xvcnMucmV2ZXJzZSc6ZmFsc2UsJ2NoYXJ0Lmdyb3VwaW5nJzonZ3JvdXBlZCcsJ2NoYXJ0LnZhcmlhbnQnOidiYXInLCdjaGFydC52YXJpYW50LnNrZXRjaC52ZXJ0aWNhbHMnOnRydWUsJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLnhheGlzJzp0cnVlLCdjaGFydC52YXJpYW50LnRocmVlZC55YXhpcyc6dHJ1ZSwnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnOjAuMSwnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCc6MTAsJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknOjUsJ2NoYXJ0LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6JyNhYWEnLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MCwnY2hhcnQuc2hhZG93Lm9mZnNldHknOjAsJ2NoYXJ0LnNoYWRvdy5ibHVyJzoxNSwnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuaG90c3BvdC54b25seSc6ZmFsc2UsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5rZXknOm51bGwsJ2NoYXJ0LmtleS5iYWNrZ3JvdW5kJzond2hpdGUnLCdjaGFydC5rZXkucG9zaXRpb24nOidncmFwaCcsJ2NoYXJ0LmtleS5zaGFkb3cnOmZhbHNlLCdjaGFydC5rZXkuc2hhZG93LmNvbG9yJzonIzY2NicsJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6MywnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4JzoyLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknOjIsJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOmZhbHNlLCdjaGFydC5rZXkucG9zaXRpb24ueCc6bnVsbCwnY2hhcnQua2V5LnBvc2l0aW9uLnknOm51bGwsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6ZmFsc2UsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzonYmxhY2snLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkuaGFsaWduJzoncmlnaHQnLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkucm91bmRlZCc6dHJ1ZSwnY2hhcnQua2V5LnRleHQuc2l6ZSc6MTAsJ2NoYXJ0LmtleS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmtleS5jb2xvcnMnOm51bGwsJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQudW5pdHMucHJlJzonJywnY2hhcnQudW5pdHMucG9zdCc6JycsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC5zY2FsZS5yb3VuZCc6ZmFsc2UsJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCc6dHJ1ZSwnY2hhcnQuY3Jvc3NoYWlycyc6ZmFsc2UsJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InOicjMzMzJywnY2hhcnQuY3Jvc3NoYWlycy5obGluZSc6dHJ1ZSwnY2hhcnQuY3Jvc3NoYWlycy52bGluZSc6dHJ1ZSwnY2hhcnQubGluZXdpZHRoJzoxLCdjaGFydC5hbm5vdGF0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzonYmxhY2snLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlLCdjaGFydC5yZXNpemFibGUnOmZhbHNlLCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LmFkanVzdGFibGUnOmZhbHNlLCdjaGFydC5hZGp1c3RhYmxlLm9ubHknOm51bGwsJ2NoYXJ0Lm5vYXhlcyc6ZmFsc2UsJ2NoYXJ0Lm5veGF4aXMnOmZhbHNlLCdjaGFydC5ub3lheGlzJzpmYWxzZSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5udW14dGlja3MnOm51bGwsJ2NoYXJ0LmJldmVsJzpmYWxzZSwnY2hhcnQuZXJyb3JiYXJzJzpmYWxzZSwnY2hhcnQuZXJyb3JiYXJzLmNvbG9yJzonYmxhY2snLCdjaGFydC5lcnJvcmJhcnMuY2FwcGVkJzp0cnVlLCdjaGFydC5lcnJvcmJhcnMuY2FwcGVkLndpZHRoJzoxNCwnY2hhcnQuZXJyb3JiYXJzLmxpbmV3aWR0aCc6MSwnY2hhcnQuY29tYmluZWRjaGFydC5lZmZlY3QnOm51bGwsJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0Lm9wdGlvbnMnOm51bGwsJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0LmNhbGxiYWNrJzpudWxsLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbQkFSXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG5mb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoOysraSl7aWYodHlwZW9mIGRhdGFbaV09PT0nc3RyaW5nJyl7ZGF0YVtpXT1wYXJzZUZsb2F0KGRhdGFbaV0pO31lbHNlIGlmKHR5cGVvZiBkYXRhW2ldPT09J29iamVjdCcmJmRhdGFbaV0pe2Zvcih2YXIgaj0wO2o8ZGF0YVtpXS5sZW5ndGg7KytqKXtpZih0eXBlb2YgZGF0YVtpXVtqXT09PSdzdHJpbmcnKXtkYXRhW2ldW2pdPXBhcnNlRmxvYXQoZGF0YVtpXVtqXSk7fX19ZWxzZSBpZih0eXBlb2YgZGF0YVtpXT09PSd1bmRlZmluZWQnKXtkYXRhW2ldPW51bGw7fX1cbmZvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YgZGF0YVtpXT09PSdvYmplY3QnJiYhUkdyYXBoLmlzX251bGwoZGF0YVtpXSkpe3RoaXMuc3RhY2tlZE9yR3JvdXBlZD10cnVlO319XG52YXIgbGluZWFyX2RhdGE9UkdyYXBoLmFycmF5TGluZWFyaXplKGRhdGEpO2Zvcih2YXIgaT0wO2k8bGluZWFyX2RhdGEubGVuZ3RoOysraSl7dGhpc1snJCcraV09e307fVxudGhpcy5kYXRhPWRhdGE7dGhpcy5vcmlnaW5hbF9kYXRhPVJHcmFwaC5hcnJheUNsb25lKGRhdGEpO3RoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzMj1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5kYXRhX2Fycj1SR3JhcGguYXJyYXlMaW5lYXJpemUodGhpcy5kYXRhKTtpZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIGFyZ3VtZW50c1swXT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsYXJndW1lbnRzWzBdKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09PSdjaGFydC54bGFiZWxzLm9mZnNldCcpe25hbWU9J2NoYXJ0LmxhYmVscy5vZmZzZXR5Jzt9XG5pZihuYW1lPT0nY2hhcnQubGFiZWxzLmFib3ZlYmFyJyl7bmFtZT0nY2hhcnQubGFiZWxzLmFib3ZlJzt9XG5pZihuYW1lPT0nY2hhcnQuc3Ryb2tlc3R5bGUnKXtuYW1lPSdjaGFydC5zdHJva2Vjb2xvcic7fVxuaWYobmFtZT09J2NoYXJ0LnhheGlzcG9zJyl7aWYodmFsdWUhPSdib3R0b20nJiZ2YWx1ZSE9J2NlbnRlcicmJnZhbHVlIT0ndG9wJyl7YWxlcnQoJ1tCQVJdICgnK3RoaXMuaWQrJykgY2hhcnQueGF4aXNwb3Mgc2hvdWxkIGJlIHRvcCwgY2VudGVyIG9yIGJvdHRvbS4gVHJpZWQgdG8gc2V0IGl0IHRvOiAnK3ZhbHVlKycgQ2hhbmdpbmcgaXQgdG8gY2VudGVyJyk7dmFsdWU9J2NlbnRlcic7fVxuaWYodmFsdWU9PSd0b3AnKXtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YodGhpcy5kYXRhW2ldKT09J251bWJlcicmJnRoaXMuZGF0YVtpXT4wKXthbGVydCgnW0JBUl0gVGhlIGRhdGEgZWxlbWVudCB3aXRoIGluZGV4ICcraSsnIHNob3VsZCBiZSBuZWdhdGl2ZScpO319fX1cbmlmKG5hbWUudG9Mb3dlckNhc2UoKT09J2NoYXJ0LmxpbmV3aWR0aCcmJnZhbHVlPT0wKXt2YWx1ZT0wLjAwMDE7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWVdO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UnXSk9PSdzdHJpbmcnKXtSRy5EcmF3QmFja2dyb3VuZEltYWdlKHRoaXMpO31cblJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTtpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtpZihwcm9wWydjaGFydC50ZXh0LmFjY2Vzc2libGUnXSl7fWVsc2V7Y28uc2V0VHJhbnNmb3JtKDEscHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSwwLDEsMC41LDAuNSk7fX1cbmlmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO2lmKChwcm9wWydjaGFydC52YXJpYW50J109PSdweXJhbWlkJ3x8cHJvcFsnY2hhcnQudmFyaWFudCddPT0nZG90JykmJnR5cGVvZihwcm9wWydjaGFydC50b29sdGlwcyddKT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10mJnByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10ubGVuZ3RoPjApe2FsZXJ0KCdbQkFSXSAoJyt0aGlzLmlkKycpIFNvcnJ5LCB0b29sdGlwcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGRvdCBvciBweXJhbWlkIGNoYXJ0cycpO31cbnRoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzMj1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5tYXg9MDt0aGlzLmdyYXBoYXJlYT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5oYWxmZ3JhcGhhcmVhPXRoaXMuZ3JhcGhhcmVhLzI7dGhpcy5oYWxmVGV4dEhlaWdodD1wcm9wWydjaGFydC50ZXh0LnNpemUnXS8yO1JHLmJhY2tncm91bmQuRHJhdyh0aGlzKTt0aGlzLmRyYXdiYXJzKCk7dGhpcy5kcmF3QXhlcygpO3RoaXMuRHJhd0xhYmVscygpO2lmKHByb3BbJ2NoYXJ0LmJldmVsJ118fHByb3BbJ2NoYXJ0LmJldmVsbGVkJ10pe3RoaXMuRHJhd0JldmVsKCk7fVxuaWYocHJvcFsnY2hhcnQua2V5J10mJnByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCl7UkcuRHJhd0tleSh0aGlzLHByb3BbJ2NoYXJ0LmtleSddLHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt9XG5pZihwcm9wWydjaGFydC5jb250ZXh0bWVudSddKXtSRy5TaG93Q29udGV4dCh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5lcnJvcmJhcnMnXSl7dGhpcy5kcmF3RXJyb3JiYXJzKCk7fVxuaWYocHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGgnXSl7UkcuRHJhd0luR3JhcGhMYWJlbHModGhpcyk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QXhlcz10aGlzLkRyYXdBeGVzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5ub2F4ZXMnXSl7cmV0dXJuO31cbnZhciB4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddO3ZhciB5YXhpc3Bvcz1wcm9wWydjaGFydC55YXhpc3BvcyddO3ZhciBpc1NrZXRjaD1wcm9wWydjaGFydC52YXJpYW50J109PSdza2V0Y2gnO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSswLjAwMTtpZihSRy5JU1NBRkFSST09LTEpe2NvLmxpbmVDYXA9J3NxdWFyZSc7fVxuaWYocHJvcFsnY2hhcnQubm95YXhpcyddPT1mYWxzZSl7aWYoeWF4aXNwb3M9PSdyaWdodCcpe2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0Kyhpc1NrZXRjaD8zOjApLHRoaXMuZ3V0dGVyVG9wLShpc1NrZXRjaD8zOjApKTtjby5saW5lVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC0oaXNTa2V0Y2g/MjowKSxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rKGlzU2tldGNoPzU6MCkpO31lbHNle2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQtKGlzU2tldGNoPzI6MCksdGhpcy5ndXR0ZXJUb3AtKGlzU2tldGNoPzU6MCkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQtKGlzU2tldGNoPzE6MCksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKyhpc1NrZXRjaD81OjApKTt9fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddPT1mYWxzZSl7aWYoeGF4aXNwb3M9PSdjZW50ZXInKXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LShpc1NrZXRjaD81OjApLE1hdGgucm91bmQoKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wKyhpc1NrZXRjaD8yOjApKSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrKGlzU2tldGNoPzU6MCksTWF0aC5yb3VuZCgoKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikrdGhpcy5ndXR0ZXJUb3AtKGlzU2tldGNoPzI6MCkpKTt9ZWxzZSBpZih4YXhpc3Bvcz09J3RvcCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQtKGlzU2tldGNoPzM6MCksdGhpcy5ndXR0ZXJUb3AtKGlzU2tldGNoPzM6MCkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0Kyhpc1NrZXRjaD81OjApLHRoaXMuZ3V0dGVyVG9wKyhpc1NrZXRjaD8yOjApKTt9ZWxzZXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LShpc1NrZXRjaD81OjApLG1hLnJvdW5kKHRoaXMuZ2V0WUNvb3JkKDApLShpc1NrZXRjaD8yOjApKSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrKGlzU2tldGNoPzg6MCksbWEucm91bmQodGhpcy5nZXRZQ29vcmQoMCkrKGlzU2tldGNoPzI6MCkpKTt9fVxudmFyIG51bVlUaWNrcz1wcm9wWydjaGFydC5udW15dGlja3MnXTtpZihwcm9wWydjaGFydC5ub3lheGlzJ109PWZhbHNlJiYhaXNTa2V0Y2gpe3ZhciB5VGlja0dhcD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS9udW1ZVGlja3M7dmFyIHhwb3M9eWF4aXNwb3M9PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQ6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodDtpZih0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0Lm51bXl0aWNrcyddPjApe2Zvcih5PXRoaXMuZ3V0dGVyVG9wO3hheGlzcG9zPT0nY2VudGVyJz95PD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTp5PChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rKHhheGlzcG9zPT0ndG9wJz8xOjApKTt5Kz15VGlja0dhcCl7aWYoeGF4aXNwb3M9PSdjZW50ZXInJiZ5PT0odGhpcy5ndXR0ZXJUb3ArKHRoaXMuZ3JhcGhhcmVhLzIpKSl7Y29udGludWU7fVxuaWYoeGF4aXNwb3M9PSd0b3AnJiZ5PT10aGlzLmd1dHRlclRvcCl7Y29udGludWU7fVxuY28ubW92ZVRvKHhwb3MrKHlheGlzcG9zPT0nbGVmdCc/MDowKSxtYS5yb3VuZCh5KSk7Y28ubGluZVRvKHhwb3MrKHlheGlzcG9zPT0nbGVmdCc/LTM6MyksbWEucm91bmQoeSkpO31cbmlmKHhheGlzcG9zPT09J2JvdHRvbScmJnByb3BbJ2NoYXJ0LnltaW4nXSE9PTApe2NvLm1vdmVUbyh4cG9zKyh5YXhpc3Bvcz09J2xlZnQnPzA6MCksbWEucm91bmQoY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpO2NvLmxpbmVUbyh4cG9zKyh5YXhpc3Bvcz09J2xlZnQnPy0zOjMpLG1hLnJvdW5kKGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pKTt9fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddKXtpZih4YXhpc3Bvcz09J2NlbnRlcicpe2NvLm1vdmVUbyh4cG9zKyh5YXhpc3Bvcz09J2xlZnQnPy0zOjMpLE1hdGgucm91bmQoY2EuaGVpZ2h0LzIpKTtjby5saW5lVG8oeHBvcyxNYXRoLnJvdW5kKGNhLmhlaWdodC8yKSk7fWVsc2UgaWYoeGF4aXNwb3M9PSd0b3AnKXtjby5tb3ZlVG8oeHBvcysoeWF4aXNwb3M9PSdsZWZ0Jz8tMzozKSxNYXRoLnJvdW5kKHRoaXMuZ3V0dGVyVG9wKSk7Y28ubGluZVRvKHhwb3MsTWF0aC5yb3VuZCh0aGlzLmd1dHRlclRvcCkpO31lbHNle2NvLm1vdmVUbyh4cG9zKyh5YXhpc3Bvcz09J2xlZnQnPy0zOjMpLE1hdGgucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKHhwb3MsTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTt9fX1cbmlmKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXT09ZmFsc2UmJiFpc1NrZXRjaCl7aWYodHlwZW9mKHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddKT09J251bWJlcicpe3ZhciB4VGlja0dhcD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO31lbHNle3ZhciB4VGlja0dhcD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3RoaXMuZGF0YS5sZW5ndGg7fVxuaWYoeGF4aXNwb3M9PSdib3R0b20nKXt5U3RhcnQ9cHJvcFsnY2hhcnQueW1pbiddPDA/dGhpcy5nZXRZQ29vcmQoMCktMzp0aGlzLmdldFlDb29yZCgwKTt5RW5kPXRoaXMuZ2V0WUNvb3JkKDApKzM7fWVsc2UgaWYoeGF4aXNwb3M9PSd0b3AnKXt5U3RhcnQ9dGhpcy5ndXR0ZXJUb3AtMzt5RW5kPXRoaXMuZ3V0dGVyVG9wO31lbHNlIGlmKHhheGlzcG9zPT0nY2VudGVyJyl7eVN0YXJ0PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKSt0aGlzLmd1dHRlclRvcCszO3lFbmQ9KChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wLTM7fVxudmFyIG5vRW5kWFRpY2s9cHJvcFsnY2hhcnQubm9lbmR4dGljayddO2Zvcih4PXRoaXMuZ3V0dGVyTGVmdCsoeWF4aXNwb3M9PSdsZWZ0Jz94VGlja0dhcDowKSxsZW49KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrKHlheGlzcG9zPT0nbGVmdCc/NTowKSk7eDxsZW47eCs9eFRpY2tHYXApe2lmKHlheGlzcG9zPT0nbGVmdCcmJiFub0VuZFhUaWNrJiZ4PnRoaXMuZ3V0dGVyTGVmdCl7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHlFbmQpO31lbHNlIGlmKHlheGlzcG9zPT0nbGVmdCcmJm5vRW5kWFRpY2smJng+dGhpcy5ndXR0ZXJMZWZ0JiZ4PChjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSl7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHlFbmQpO31lbHNlIGlmKHlheGlzcG9zPT0ncmlnaHQnJiZ4PChjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSYmIW5vRW5kWFRpY2spe2NvLm1vdmVUbyhtYS5yb3VuZCh4KSx5U3RhcnQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSx5RW5kKTt9ZWxzZSBpZih5YXhpc3Bvcz09J3JpZ2h0JyYmeDwoY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJng+KHRoaXMuZ3V0dGVyTGVmdCkmJm5vRW5kWFRpY2spe2NvLm1vdmVUbyhtYS5yb3VuZCh4KSx5U3RhcnQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSx5RW5kKTt9fVxuaWYocHJvcFsnY2hhcnQubm95YXhpcyddfHxwcm9wWydjaGFydC5udW14dGlja3MnXT09bnVsbCl7aWYodHlwZW9mKHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddKT09J251bWJlcicmJnByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPjApe2NvLm1vdmVUbyhNYXRoLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCkseVN0YXJ0KTtjby5saW5lVG8oTWF0aC5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLHlFbmQpO319fVxuaWYocHJvcFsnY2hhcnQubm95YXhpcyddJiZwcm9wWydjaGFydC5ub3hheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW14dGlja3MnXT09bnVsbCl7aWYoeGF4aXNwb3M9PSdjZW50ZXInKXtjby5tb3ZlVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSwoY2EuaGVpZ2h0LzIpLTMpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLChjYS5oZWlnaHQvMikrMyk7fWVsc2V7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rMyk7fX1cbmNvLnN0cm9rZSgpO307dGhpcy5kcmF3YmFycz10aGlzLkRyYXdiYXJzPWZ1bmN0aW9uKClcbntjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bMF07dmFyIHByZXZYPTAscHJldlk9MCxkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO2lmKHByb3BbJ2NoYXJ0LnltYXgnXSl7dGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOnByb3BbJ2NoYXJ0LnltYXgnXSwnc3RyaWN0Jzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddP2ZhbHNlOnRydWUsJ21pbic6cHJvcFsnY2hhcnQueW1pbiddLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTt9ZWxzZXt2YXIgZXJyb3JiYXJzPXByb3BbJ2NoYXJ0LmVycm9yYmFycyddO2lmKHR5cGVvZiBlcnJvcmJhcnM9PT0nbnVtYmVyJyl7dmFyIHZhbHVlPWVycm9yYmFycztwcm9wWydjaGFydC5lcnJvcmJhcnMnXT1bXTtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldPT09J251bWJlcicpe3Byb3BbJ2NoYXJ0LmVycm9yYmFycyddLnB1c2goW3ZhbHVlLG51bGxdKTt9ZWxzZSBpZih0eXBlb2YgdGhpcy5kYXRhW2ldPT09J29iamVjdCcmJiFSRy5pc051bGwodGhpcy5kYXRhW2ldKSl7Zm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysrail7cHJvcFsnY2hhcnQuZXJyb3JiYXJzJ10ucHVzaChbdmFsdWUsbnVsbF0pO319fVxuZXJyb3JiYXJzPXByb3BbJ2NoYXJ0LmVycm9yYmFycyddO31cbmZvcihpPTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSl7aWYodHlwZW9mKHRoaXMuZGF0YVtpXSk9PSdvYmplY3QnKXt2YXIgdmFsdWU9cHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdncm91cGVkJz9OdW1iZXIoUkcuYXJyYXlNYXgodGhpcy5kYXRhW2ldLHRydWUpKTpOdW1iZXIoUkcuYXJyYXlfc3VtKHRoaXMuZGF0YVtpXSkpO31lbHNle3ZhciB2YWx1ZT1OdW1iZXIodGhpcy5kYXRhW2ldKTt9XG50aGlzLm1heD1tYS5tYXgobWEuYWJzKHRoaXMubWF4KSxtYS5hYnModmFsdWUpK1xuTnVtYmVyKCh0eXBlb2YgcHJvcFsnY2hhcnQuZXJyb3JiYXJzJ109PT0nb2JqZWN0JyYmdHlwZW9mIHByb3BbJ2NoYXJ0LmVycm9yYmFycyddW2ldPT09J29iamVjdCcmJiFSRy5pc051bGwocHJvcFsnY2hhcnQuZXJyb3JiYXJzJ11baV0pJiZ0eXBlb2YgcHJvcFsnY2hhcnQuZXJyb3JiYXJzJ11baV1bMF09PT0nbnVtYmVyJyk/cHJvcFsnY2hhcnQuZXJyb3JiYXJzJ11baV1bMF06MCkpO31cbnRoaXMuc2NhbGUyPVJHcmFwaC5nZXRTY2FsZTIodGhpcyx7J21heCc6dGhpcy5tYXgsJ21pbic6cHJvcFsnY2hhcnQueW1pbiddLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTt0aGlzLm1heD10aGlzLnNjYWxlMi5tYXg7fVxuaWYocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddJiYhcHJvcFsnY2hhcnQueW1heCddKXt0aGlzLlNldCgnY2hhcnQueW1heCcsdGhpcy5zY2FsZTIubWF4KTt9XG5pZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJ10mJnByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXS5sZW5ndGg+MCl7UkdyYXBoLkRyYXdCYXJzKHRoaXMpO31cbnZhciB2YXJpYW50PXByb3BbJ2NoYXJ0LnZhcmlhbnQnXTtpZih2YXJpYW50PT09JzNkJyl7UkcuZHJhdzNEQXhlcyh0aGlzKTt9XG52YXIgeGF4aXNwb3M9cHJvcFsnY2hhcnQueGF4aXNwb3MnXSx3aWR0aD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3RoaXMuZGF0YS5sZW5ndGgsb3JpZ19oZWlnaHQ9aGVpZ2h0LGhtYXJnaW49cHJvcFsnY2hhcnQuaG1hcmdpbiddLHNoYWRvdz1wcm9wWydjaGFydC5zaGFkb3cnXSxzaGFkb3dDb2xvcj1wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxzaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10sc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHNoYWRvd09mZnNldFk9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxzdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2Vjb2xvciddLGNvbG9ycz1wcm9wWydjaGFydC5jb2xvcnMnXSxzZXF1ZW50aWFsQ29sb3JJbmRleD0wXG52YXIgaGVpZ2h0O2ZvcihpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTxsZW47aSs9MSl7aWYoUkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKTwwKXt2YXIgaGVpZ2h0PShSRy5hcnJheVN1bSh0aGlzLmRhdGFbaV0pK3RoaXMuc2NhbGUyLm1pbikvKHRoaXMuc2NhbGUyLm1heC10aGlzLnNjYWxlMi5taW4pO31lbHNle3ZhciBoZWlnaHQ9KFJHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSktdGhpcy5zY2FsZTIubWluKS8odGhpcy5zY2FsZTIubWF4LXRoaXMuc2NhbGUyLm1pbik7fVxuaGVpZ2h0Kj1tYS5hYnModGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZTIubWF4KS10aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlMi5taW4pKTt2YXIgeD0oaSp3aWR0aCkrdGhpcy5ndXR0ZXJMZWZ0O3ZhciB5PXhheGlzcG9zPT0nY2VudGVyJz8oKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikrdGhpcy5ndXR0ZXJUb3AtaGVpZ2h0OmNhLmhlaWdodC1oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b207aWYoeGF4aXNwb3M9PSd0b3AnKXt5PXRoaXMuZ3V0dGVyVG9wK21hLmFicyhoZWlnaHQpO31cbmlmKGhlaWdodDwwKXt5Kz1oZWlnaHQ7aGVpZ2h0PW1hLmFicyhoZWlnaHQpO31cbmlmKHNoYWRvdyl7Y28uc2hhZG93Q29sb3I9c2hhZG93Q29sb3I7Y28uc2hhZG93Qmx1cj1zaGFkb3dCbHVyO2NvLnNoYWRvd09mZnNldFg9c2hhZG93T2Zmc2V0WDtjby5zaGFkb3dPZmZzZXRZPXNoYWRvd09mZnNldFk7fVxuY28uYmVnaW5QYXRoKCk7aWYodHlwZW9mIHRoaXMuZGF0YVtpXT09J251bWJlcicpe2lmKHhheGlzcG9zPT09J2JvdHRvbScmJnByb3BbJ2NoYXJ0LnltaW4nXTwwKXtpZih0aGlzLmRhdGFbaV0+PTApe2hlaWdodD1tYS5hYnModGhpcy5nZXRZQ29vcmQoMCktdGhpcy5nZXRZQ29vcmQodGhpcy5kYXRhW2ldKSk7fWVsc2V7eT10aGlzLmdldFlDb29yZCgwKTtoZWlnaHQ9bWEuYWJzKHRoaXMuZ2V0WUNvb3JkKDApLXRoaXMuZ2V0WUNvb3JkKHRoaXMuZGF0YVtpXSkpO319XG52YXIgYmFyV2lkdGg9d2lkdGgtKDIqaG1hcmdpbik7aWYoYmFyV2lkdGg8MCl7YWxlcnQoJ1tSR1JBUEhdIFdhcm5pbmc6IHlvdSBoYXZlIGEgbmVnYXRpdmUgYmFyIHdpZHRoLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdGhlIGNoYXJ0LmhtYXJnaW4gYmVpbmcgdG9vIGhpZ2ggb3IgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgbm90IGJlaW5nIHN1ZmZpY2llbnQuJyk7fVxuY28uc3Ryb2tlU3R5bGU9c3Ryb2tlU3R5bGU7Y28uZmlsbFN0eWxlPWNvbG9yc1swXTtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5maWxsU3R5bGU9Y29sb3JzW2ldO31cbmlmKHZhcmlhbnQ9PSdza2V0Y2gnKXtjby5saW5lQ2FwPSdyb3VuZCc7dmFyIHNrZXRjaE9mZnNldD0zO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPWNvbG9yc1swXTtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5zdHJva2VTdHlsZT1jb2xvcnNbaV07fVxuY28ubW92ZVRvKHgraG1hcmdpbisyLHkraGVpZ2h0LTIpO2NvLmxpbmVUbyh4K2htYXJnaW4tMSx5LTQpO2NvLm1vdmVUbyh4K2htYXJnaW4tMyx5KyAtMisodGhpcy5kYXRhW2ldPDA/aGVpZ2h0OjApKTtjby5iZXppZXJDdXJ2ZVRvKHgrKChobWFyZ2luK3dpZHRoKSowLjMzKSx5KzE1Kyh0aGlzLmRhdGFbaV08MD9oZWlnaHQtMTA6MCkseCsoKGhtYXJnaW4rd2lkdGgpKjAuNjYpLHkrNSsodGhpcy5kYXRhW2ldPDA/aGVpZ2h0LTEwOjApLHgraG1hcmdpbit3aWR0aCsgLTEseSswKyh0aGlzLmRhdGFbaV08MD9oZWlnaHQ6MCkpO2NvLm1vdmVUbyh4K2htYXJnaW4rd2lkdGgtNSx5LTUpO2NvLmxpbmVUbyh4K2htYXJnaW4rd2lkdGgtMyx5K2hlaWdodC0zKTtpZihwcm9wWydjaGFydC52YXJpYW50LnNrZXRjaC52ZXJ0aWNhbHMnXSl7Zm9yKHZhciByPTAuMjtyPD0wLjg7cis9MC4yKXtjby5tb3ZlVG8oeCtobWFyZ2luK3dpZHRoKyhyPjAuND8tMTozKS0ocip3aWR0aCkseS0xKTtjby5saW5lVG8oeCtobWFyZ2luK3dpZHRoLShyPjAuND8xOi0xKS0ocip3aWR0aCkseStoZWlnaHQrKHI9PTAuMj8xOi0yKSk7fX1cbmNvLnN0cm9rZSgpO31lbHNlIGlmKHZhcmlhbnQ9PSdiYXInfHx2YXJpYW50PT0nM2QnfHx2YXJpYW50PT0nZ2xhc3MnfHx2YXJpYW50PT0nYmV2ZWwnKXtpZihSR3JhcGguSVNPTEQmJnNoYWRvdyl7dGhpcy5EcmF3SUVTaGFkb3coW3graG1hcmdpbix5LGJhcldpZHRoLGhlaWdodF0pO31cbmlmKHZhcmlhbnQ9PSdnbGFzcycpe1JHcmFwaC5maWxsZWRDdXJ2eVJlY3QoY28seCtobWFyZ2luLHksYmFyV2lkdGgsaGVpZ2h0LDMsdGhpcy5kYXRhW2ldPjAsdGhpcy5kYXRhW2ldPjAsdGhpcy5kYXRhW2ldPDAsdGhpcy5kYXRhW2ldPDApO1JHcmFwaC5zdHJva2VkQ3VydnlSZWN0KGNvLHgraG1hcmdpbix5LGJhcldpZHRoLGhlaWdodCwzLHRoaXMuZGF0YVtpXT4wLHRoaXMuZGF0YVtpXT4wLHRoaXMuZGF0YVtpXTwwLHRoaXMuZGF0YVtpXTwwKTt9ZWxzZXtjby5iZWdpblBhdGgoKTtjby5yZWN0KHgraG1hcmdpbix5LGJhcldpZHRoLGhlaWdodCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KHRoaXMpO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCtobWFyZ2luLHksYmFyV2lkdGgsaGVpZ2h0KTtjby5zdHJva2UoKTt9XG5pZih2YXJpYW50PT0nM2QnKXt2YXIgcHJldlN0cm9rZVN0eWxlPWNvLnN0cm9rZVN0eWxlO3ZhciBwcmV2RmlsbFN0eWxlPWNvLmZpbGxTdHlsZTtpZih0aGlzLmRhdGFbaV0+PTApe2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4K2htYXJnaW4seSk7Y28ubGluZVRvKHgraG1hcmdpbitwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyh4K2htYXJnaW4rcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2JhcldpZHRoLHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oeCtobWFyZ2luK2JhcldpZHRoLHkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9XG5jby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCtobWFyZ2luK2JhcldpZHRoLHkpO2NvLmxpbmVUbyh4K2htYXJnaW4rYmFyV2lkdGgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHRoaXMuZGF0YVtpXTwwJiZ4YXhpc3Bvcz09PSdib3R0b20nP3RoaXMuZ2V0WUNvb3JkKDApOih0aGlzLmRhdGFbaV08MCYmKHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTwodGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmZ3JhcGhhcmVhKT8odGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmZ3JhcGhhcmVhKTooeS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pKSk7Y28ubGluZVRvKHgraG1hcmdpbitiYXJXaWR0aCtwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sdGhpcy5kYXRhW2ldPDAmJih5LXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXStoZWlnaHQpPCh0aGlzLmd1dHRlclRvcCt0aGlzLmdldFlDb29yZCgwKSk/dGhpcy5nZXRZQ29vcmQodGhpcy5kYXRhW2ldKS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J106KHRoaXMuZGF0YVtpXT4wP3ktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddK2hlaWdodDptYS5taW4oeS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10raGVpZ2h0LGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpKTtjby5saW5lVG8oeCtobWFyZ2luK2JhcldpZHRoLHkraGVpZ2h0KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7aWYodGhpcy5kYXRhW2ldPjApe2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT0ncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztjby5tb3ZlVG8oeCtobWFyZ2luLHkpO2NvLmxpbmVUbyh4K2htYXJnaW4rcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oeCtobWFyZ2luK3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXStiYXJXaWR0aCx5LXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHgraG1hcmdpbitiYXJXaWR0aCx5KTtjby5saW5lVG8oeCtobWFyZ2luLHkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9J3JnYmEoMCwwLDAsMC40KSc7Y28ubW92ZVRvKHgraG1hcmdpbitiYXJXaWR0aCx5KTtjby5saW5lVG8oeCtobWFyZ2luK2JhcldpZHRoK3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSx0aGlzLmRhdGFbaV08MCYmeGF4aXNwb3M9PT0nYm90dG9tJz90aGlzLmdldFlDb29yZCgwKToodGhpcy5kYXRhW2ldPDAmJih5LXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk8KHRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZmdyYXBoYXJlYSk/KHRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZmdyYXBoYXJlYSk6eS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pKTtjby5saW5lVG8oeCtobWFyZ2luK2JhcldpZHRoK3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSx0aGlzLmRhdGFbaV08MCYmKHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddK2hlaWdodCk8dGhpcy5nZXRZQ29vcmQoMCk/dGhpcy5nZXRZQ29vcmQoMCk6dGhpcy5kYXRhW2ldPjA/eS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10raGVpZ2h0Om1hLm1pbih5LXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXStoZWlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKHgraG1hcmdpbitiYXJXaWR0aCx5K2hlaWdodCk7Y28ubGluZVRvKHgraG1hcmdpbitiYXJXaWR0aCx5KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7Y28uc3Ryb2tlU3R5bGU9cHJldlN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZT1wcmV2RmlsbFN0eWxlO31lbHNlIGlmKHZhcmlhbnQ9PSdnbGFzcycpe3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgraG1hcmdpbix5LHgraG1hcmdpbisoYmFyV2lkdGgvMikseSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwncmdiYSgyNTUsMjU1LDI1NSwwLjkpJyk7Z3JhZC5hZGRDb2xvclN0b3AoMSwncmdiYSgyNTUsMjU1LDI1NSwwLjUpJyk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPWdyYWQ7Y28uZmlsbFJlY3QoeCtobWFyZ2luKzIseSsodGhpcy5kYXRhW2ldPjA/MjowKSwoYmFyV2lkdGgvMiktMixoZWlnaHQtMik7Y28uZmlsbCgpO319ZWxzZSBpZih2YXJpYW50PT0nZG90Jyl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgrKHdpZHRoLzIpLHkpO2NvLmxpbmVUbyh4Kyh3aWR0aC8yKSx5K2hlaWdodCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXRoaXMucHJvcGVydGllc1snY2hhcnQuY29sb3JzJ11baV07Y28uYXJjKHgrKHdpZHRoLzIpLHkrKHRoaXMuZGF0YVtpXT4wPzA6aGVpZ2h0KSwyLDAsNi4yOCwwKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bMF07aWYocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSl7Y28uZmlsbFN0eWxlPWNvbG9yc1tpXTt9XG5jby5zdHJva2UoKTtjby5maWxsKCk7fWVsc2V7YWxlcnQoJ1tCQVJdIFdhcm5pbmchIFVua25vd24gY2hhcnQudmFyaWFudDogJyt2YXJpYW50KTt9XG50aGlzLmNvb3Jkcy5wdXNoKFt4K2htYXJnaW4seSx3aWR0aC0oMipobWFyZ2luKSxoZWlnaHRdKTtpZih0eXBlb2YgdGhpcy5jb29yZHMyW2ldPT0ndW5kZWZpbmVkJyl7dGhpcy5jb29yZHMyW2ldPVtdO31cbnRoaXMuY29vcmRzMltpXS5wdXNoKFt4K2htYXJnaW4seSx3aWR0aC0oMipobWFyZ2luKSxoZWlnaHRdKTt9ZWxzZSBpZih0aGlzLmRhdGFbaV0mJnR5cGVvZih0aGlzLmRhdGFbaV0pPT0nb2JqZWN0JyYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09J3N0YWNrZWQnKXtpZih0aGlzLnNjYWxlMi5taW4pe2FsZXJ0KFwiW0VSUk9SXSBTdGFja2VkIEJhciBjaGFydHMgd2l0aCBhIFkgbWluIGFyZSBub3Qgc3VwcG9ydGVkXCIpO31cbnZhciBiYXJXaWR0aD13aWR0aC0oMipobWFyZ2luKTt2YXIgcmVkcmF3Q29vcmRzPVtdO3ZhciBzdGFydFk9MDt2YXIgZGF0YXNldD10aGlzLmRhdGFbaV07aWYoYmFyV2lkdGg8MCl7YWxlcnQoJ1tSR1JBUEhdIFdhcm5pbmc6IHlvdSBoYXZlIGEgbmVnYXRpdmUgYmFyIHdpZHRoLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdGhlIGNoYXJ0LmhtYXJnaW4gYmVpbmcgdG9vIGhpZ2ggb3IgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgbm90IGJlaW5nIHN1ZmZpY2llbnQuJyk7fVxuZm9yKGo9MDtqPGRhdGFzZXQubGVuZ3RoOysrail7aWYoeGF4aXNwb3M9PSdjZW50ZXInKXthbGVydChcIltCQVJdIEl0J3MgcG9pbnRsZXNzIGhhdmluZyB0aGUgWCBheGlzIHBvc2l0aW9uIGF0IHRoZSBjZW50ZXIgb24gYSBzdGFja2VkIGJhciBjaGFydC5cIik7cmV0dXJuO31cbmlmKHRoaXMuZGF0YVtpXVtqXTwwKXthbGVydCgnW0JBUl0gTmVnYXRpdmUgdmFsdWVzIGFyZSBub3QgcGVybWl0dGVkIHdpdGggYSBzdGFja2VkIGJhciBjaGFydC4gVHJ5IGEgZ3JvdXBlZCBvbmUgaW5zdGVhZC4nKTtyZXR1cm47fVxuY28uc3Ryb2tlU3R5bGU9c3Ryb2tlU3R5bGVcbmNvLmZpbGxTdHlsZT1jb2xvcnNbal07aWYocHJvcFsnY2hhcnQuY29sb3JzLnJldmVyc2UnXSl7Y28uZmlsbFN0eWxlPWNvbG9yc1t0aGlzLmRhdGFbaV0ubGVuZ3RoLWotMV07fVxuaWYocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSYmY29sb3JzW3NlcXVlbnRpYWxDb2xvckluZGV4XSl7Y28uZmlsbFN0eWxlPWNvbG9yc1tzZXF1ZW50aWFsQ29sb3JJbmRleCsrXTt9ZWxzZSBpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5maWxsU3R5bGU9Y29sb3JzW3NlcXVlbnRpYWxDb2xvckluZGV4LTFdO31cbnZhciBoZWlnaHQ9KGRhdGFzZXRbal0vdGhpcy5zY2FsZTIubWF4KSooY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKTtpZih4YXhpc3Bvcz09J2NlbnRlcicpe2hlaWdodC89Mjt9XG52YXIgdG90YWxIZWlnaHQ9KFJHcmFwaC5hcnJheV9zdW0oZGF0YXNldCkvdGhpcy5zY2FsZTIubWF4KSooY2EuaGVpZ2h0LWhtYXJnaW4tdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pO3RoaXMuY29vcmRzLnB1c2goW3graG1hcmdpbix5LHdpZHRoLSgyKmhtYXJnaW4pLGhlaWdodF0pO2lmKHR5cGVvZiB0aGlzLmNvb3JkczJbaV09PSd1bmRlZmluZWQnKXt0aGlzLmNvb3JkczJbaV09W107fVxudGhpcy5jb29yZHMyW2ldLnB1c2goW3graG1hcmdpbix5LHdpZHRoLSgyKmhtYXJnaW4pLGhlaWdodF0pO2lmKFJHcmFwaC5JU09MRCYmc2hhZG93KXt0aGlzLkRyYXdJRVNoYWRvdyhbeCtobWFyZ2luLHksd2lkdGgtKDIqaG1hcmdpbiksaGVpZ2h0KzFdKTt9XG5pZihoZWlnaHQ+MCl7Y28uc3Ryb2tlUmVjdCh4K2htYXJnaW4seSx3aWR0aC0oMipobWFyZ2luKSxoZWlnaHQpO2NvLmZpbGxSZWN0KHgraG1hcmdpbix5LHdpZHRoLSgyKmhtYXJnaW4pLGhlaWdodCk7fVxuaWYoaj09MCl7dmFyIHN0YXJ0WT15O3ZhciBzdGFydFg9eDt9XG5pZihzaGFkb3cpe3JlZHJhd0Nvb3Jkcy5wdXNoKFt4K2htYXJnaW4seSx3aWR0aC0oMipobWFyZ2luKSxoZWlnaHQsY28uZmlsbFN0eWxlXSk7fVxuaWYodmFyaWFudD09JzNkJyl7dmFyIHByZXZGaWxsU3R5bGU9Y28uZmlsbFN0eWxlO3ZhciBwcmV2U3Ryb2tlU3R5bGU9Y28uc3Ryb2tlU3R5bGU7aWYoaj09MCl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCtobWFyZ2luLHkpO2NvLmxpbmVUbyhzdGFydFgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2htYXJnaW4seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2JhcldpZHRoK2htYXJnaW4seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrYmFyV2lkdGgraG1hcmdpbix5KTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7fVxuY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCtiYXJXaWR0aCtobWFyZ2luLHkpO2NvLmxpbmVUbyhzdGFydFgrYmFyV2lkdGgraG1hcmdpbitwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrYmFyV2lkdGgraG1hcmdpbitwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10raGVpZ2h0KTtjby5saW5lVG8oc3RhcnRYK2JhcldpZHRoK2htYXJnaW4seStoZWlnaHQpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtpZihqPT0wKXtjby5maWxsU3R5bGU9J3JnYmEoMjU1LDI1NSwyNTUsMC41KSc7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCtobWFyZ2luLHkpO2NvLmxpbmVUbyhzdGFydFgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2htYXJnaW4seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2JhcldpZHRoK2htYXJnaW4seS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrYmFyV2lkdGgraG1hcmdpbix5KTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7fVxuY28uZmlsbFN0eWxlPSdyZ2JhKDAsMCwwLDAuNCknO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzdGFydFgrYmFyV2lkdGgraG1hcmdpbix5KTtjby5saW5lVG8oc3RhcnRYK2JhcldpZHRoK2htYXJnaW4rcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYK2JhcldpZHRoK2htYXJnaW4rcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddK2hlaWdodCk7Y28ubGluZVRvKHN0YXJ0WCtiYXJXaWR0aCtobWFyZ2luLHkraGVpZ2h0KTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7Y28uc3Ryb2tlU3R5bGU9cHJldlN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZT1wcmV2RmlsbFN0eWxlO31cbnkrPWhlaWdodDt9XG5pZihzaGFkb3cpe1JHcmFwaC5Ob1NoYWRvdyh0aGlzKTtmb3Ioaz0wO2s8cmVkcmF3Q29vcmRzLmxlbmd0aDsrK2spe2NvLnN0cm9rZVN0eWxlPXN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZT1yZWRyYXdDb29yZHNba11bNF07Y28uc3Ryb2tlUmVjdChyZWRyYXdDb29yZHNba11bMF0scmVkcmF3Q29vcmRzW2tdWzFdLHJlZHJhd0Nvb3Jkc1trXVsyXSxyZWRyYXdDb29yZHNba11bM10pO2NvLmZpbGxSZWN0KHJlZHJhd0Nvb3Jkc1trXVswXSxyZWRyYXdDb29yZHNba11bMV0scmVkcmF3Q29vcmRzW2tdWzJdLHJlZHJhd0Nvb3Jkc1trXVszXSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO31cbnJlZHJhd0Nvb3Jkcz1bXTt9fWVsc2UgaWYodGhpcy5kYXRhW2ldJiZ0eXBlb2YodGhpcy5kYXRhW2ldKT09J29iamVjdCcmJnByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ109PSdncm91cGVkJyl7dmFyIHJlZHJhd0Nvb3Jkcz1bXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Zm9yKGo9MDtqPHRoaXMuZGF0YVtpXS5sZW5ndGg7KytqKXtjby5zdHJva2VTdHlsZT1zdHJva2VTdHlsZTtjby5maWxsU3R5bGU9Y29sb3JzW2pdO2lmKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10mJmNvbG9yc1tzZXF1ZW50aWFsQ29sb3JJbmRleF0pe2NvLmZpbGxTdHlsZT1jb2xvcnNbc2VxdWVudGlhbENvbG9ySW5kZXgrK107fWVsc2UgaWYocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSl7Y28uZmlsbFN0eWxlPWNvbG9yc1tzZXF1ZW50aWFsQ29sb3JJbmRleC0xXTt9XG52YXIgaW5kaXZpZHVhbEJhcldpZHRoPSh3aWR0aC0oMipobWFyZ2luKSkvdGhpcy5kYXRhW2ldLmxlbmd0aDt2YXIgaGVpZ2h0PSgodGhpcy5kYXRhW2ldW2pdKyh0aGlzLmRhdGFbaV1bal08MD90aGlzLnNjYWxlMi5taW46KC0xKnRoaXMuc2NhbGUyLm1pbikpKS8odGhpcy5zY2FsZTIubWF4LXRoaXMuc2NhbGUyLm1pbikpKihjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pO3ZhciBncm91cGVkTWFyZ2luPXByb3BbJ2NoYXJ0LmhtYXJnaW4uZ3JvdXBlZCddO3ZhciBzdGFydFg9eCtobWFyZ2luKyhqKmluZGl2aWR1YWxCYXJXaWR0aCk7aWYoaW5kaXZpZHVhbEJhcldpZHRoPDApe2FsZXJ0KCdbUkdSQVBIXSBXYXJuaW5nOiB5b3UgaGF2ZSBhIG5lZ2F0aXZlIGJhciB3aWR0aC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHRoZSBjaGFydC5obWFyZ2luIGJlaW5nIHRvbyBoaWdoIG9yIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIG5vdCBiZWluZyBzdWZmaWNpZW50LicpO31cbmlmKHhheGlzcG9zPT0nY2VudGVyJyl7aGVpZ2h0Lz0yO31cbmlmKHhheGlzcG9zPT0ndG9wJyl7dmFyIHN0YXJ0WT10aGlzLmd1dHRlclRvcDt2YXIgaGVpZ2h0PU1hdGguYWJzKGhlaWdodCk7fWVsc2UgaWYoeGF4aXNwb3M9PSdjZW50ZXInKXt2YXIgc3RhcnRZPXRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8yKS1oZWlnaHQ7fWVsc2V7dmFyIHN0YXJ0WT10aGlzLmdldFlDb29yZCgwKTt2YXIgaGVpZ2h0PW1hLmFicyhtYS5hYnModGhpcy5nZXRZQ29vcmQodGhpcy5kYXRhW2ldW2pdKSktdGhpcy5nZXRZQ29vcmQoMCkpO2lmKHRoaXMuZGF0YVtpXVtqXT49MCl7c3RhcnRZLT1oZWlnaHQ7fX1cbmNvLnN0cm9rZVJlY3Qoc3RhcnRYK2dyb3VwZWRNYXJnaW4sc3RhcnRZLGluZGl2aWR1YWxCYXJXaWR0aC0oMipncm91cGVkTWFyZ2luKSxoZWlnaHQpO2NvLmZpbGxSZWN0KHN0YXJ0WCtncm91cGVkTWFyZ2luLHN0YXJ0WSxpbmRpdmlkdWFsQmFyV2lkdGgtKDIqZ3JvdXBlZE1hcmdpbiksaGVpZ2h0KTt5Kz1oZWlnaHQ7aWYodmFyaWFudD09JzNkJyl7dmFyIHByZXZGaWxsU3R5bGU9Y28uZmlsbFN0eWxlO3ZhciBwcmV2U3Ryb2tlU3R5bGU9Y28uc3Ryb2tlU3R5bGU7dmFyIGhtYXJnaW5Hcm91cGVkPXByb3BbJ2NoYXJ0LmhtYXJnaW4uZ3JvdXBlZCddO2lmKHRoaXMuZGF0YVtpXVtqXT49MCl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCtobWFyZ2luR3JvdXBlZCxzdGFydFkpO2NvLmxpbmVUbyhzdGFydFgraG1hcmdpbkdyb3VwZWQrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHN0YXJ0WS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddK2luZGl2aWR1YWxCYXJXaWR0aC1obWFyZ2luR3JvdXBlZCxzdGFydFktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYK2luZGl2aWR1YWxCYXJXaWR0aC1obWFyZ2luR3JvdXBlZCxzdGFydFkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTt9XG5jby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oc3RhcnRYK2luZGl2aWR1YWxCYXJXaWR0aC1obWFyZ2luR3JvdXBlZC0xLHN0YXJ0WSk7Y28ubGluZVRvKHN0YXJ0WCtpbmRpdmlkdWFsQmFyV2lkdGgtaG1hcmdpbkdyb3VwZWQrcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLHRoaXMuZGF0YVtpXVtqXTwwPyh0aGlzLmdldFlDb29yZCgwKSttYS5hYnMoaGVpZ2h0KS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pOnRoaXMuZ2V0WUNvb3JkKDApLWhlaWdodC1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgraW5kaXZpZHVhbEJhcldpZHRoLWhtYXJnaW5Hcm91cGVkK3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSx0aGlzLmRhdGFbaV1bal08MCYmKHN0YXJ0WStoZWlnaHQtcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTwodGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmZ3JhcGhhcmVhKT8odGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmZ3JhcGhhcmVhKTooc3RhcnRZK2hlaWdodC1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pKTtjby5saW5lVG8oc3RhcnRYK2luZGl2aWR1YWxCYXJXaWR0aC1obWFyZ2luR3JvdXBlZC0xLHN0YXJ0WStoZWlnaHQpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtpZih0aGlzLmRhdGFbaV1bal0+PTApe2NvLmZpbGxTdHlsZT0ncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oc3RhcnRYK2htYXJnaW5Hcm91cGVkLHN0YXJ0WSk7Y28ubGluZVRvKHN0YXJ0WCtobWFyZ2luR3JvdXBlZCtwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sc3RhcnRZLXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCtwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10raW5kaXZpZHVhbEJhcldpZHRoLWhtYXJnaW5Hcm91cGVkLHN0YXJ0WS1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFgraW5kaXZpZHVhbEJhcldpZHRoLWhtYXJnaW5Hcm91cGVkLHN0YXJ0WSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO31cbmNvLmZpbGxTdHlsZT0ncmdiYSgwLDAsMCwwLjQpJztjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oc3RhcnRYK2luZGl2aWR1YWxCYXJXaWR0aC1obWFyZ2luR3JvdXBlZCxzdGFydFkpO2NvLmxpbmVUbyhzdGFydFgraW5kaXZpZHVhbEJhcldpZHRoK3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXS1obWFyZ2luR3JvdXBlZCx0aGlzLmRhdGFbaV1bal08MD8odGhpcy5nZXRZQ29vcmQoMCkrbWEuYWJzKGhlaWdodCktcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTp0aGlzLmdldFlDb29yZCgwKS1oZWlnaHQtcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYK2luZGl2aWR1YWxCYXJXaWR0aCtwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10taG1hcmdpbkdyb3VwZWQsdGhpcy5kYXRhW2ldW2pdPDAmJihzdGFydFkraGVpZ2h0LTUpPCh0aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZncmFwaGFyZWEpPyh0aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZncmFwaGFyZWEpOihzdGFydFkraGVpZ2h0LXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSkpO2NvLmxpbmVUbyhzdGFydFgraW5kaXZpZHVhbEJhcldpZHRoLWhtYXJnaW5Hcm91cGVkLHN0YXJ0WStoZWlnaHQpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5zdHJva2VTdHlsZT1wcmV2U3Ryb2tlU3R5bGU7Y28uZmlsbFN0eWxlPXByZXZGaWxsU3R5bGU7fVxuaWYoaGVpZ2h0PDApe2hlaWdodD1NYXRoLmFicyhoZWlnaHQpO3N0YXJ0WT1zdGFydFktaGVpZ2h0O31cbnRoaXMuY29vcmRzLnB1c2goW3N0YXJ0WCtncm91cGVkTWFyZ2luLHN0YXJ0WSxpbmRpdmlkdWFsQmFyV2lkdGgtKDIqZ3JvdXBlZE1hcmdpbiksaGVpZ2h0XSk7aWYodHlwZW9mIHRoaXMuY29vcmRzMltpXT09J3VuZGVmaW5lZCcpe3RoaXMuY29vcmRzMltpXT1bXTt9XG50aGlzLmNvb3JkczJbaV0ucHVzaChbc3RhcnRYK2dyb3VwZWRNYXJnaW4sc3RhcnRZLGluZGl2aWR1YWxCYXJXaWR0aC0oMipncm91cGVkTWFyZ2luKSxoZWlnaHRdKTtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7cmVkcmF3Q29vcmRzLnB1c2goW3N0YXJ0WCtncm91cGVkTWFyZ2luLHN0YXJ0WSxpbmRpdmlkdWFsQmFyV2lkdGgtKDIqZ3JvdXBlZE1hcmdpbiksaGVpZ2h0LGNvLmZpbGxTdHlsZV0pO319XG5pZihyZWRyYXdDb29yZHMubGVuZ3RoKXtSR3JhcGguTm9TaGFkb3codGhpcyk7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaj0wO2o8cmVkcmF3Q29vcmRzLmxlbmd0aDsrK2ope2NvLmZpbGxTdHlsZT1yZWRyYXdDb29yZHNbal1bNF07Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXTtjby5maWxsUmVjdChyZWRyYXdDb29yZHNbal1bMF0scmVkcmF3Q29vcmRzW2pdWzFdLHJlZHJhd0Nvb3Jkc1tqXVsyXSxyZWRyYXdDb29yZHNbal1bM10pO2NvLnN0cm9rZVJlY3QocmVkcmF3Q29vcmRzW2pdWzBdLHJlZHJhd0Nvb3Jkc1tqXVsxXSxyZWRyYXdDb29yZHNbal1bMl0scmVkcmF3Q29vcmRzW2pdWzNdKTt9XG5jby5maWxsKCk7Y28uc3Ryb2tlKCk7cmVkcmF3Q29vcmRzPVtdO319ZWxzZXt0aGlzLmNvb3Jkcy5wdXNoKFtdKTt9XG5jby5jbG9zZVBhdGgoKTt9XG5pZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnJiZwcm9wWydjaGFydC55YXhpc3BvcyddPT09J3JpZ2h0Jyl7UkcuZHJhdzNEWUF4aXModGhpcyk7fVxuUkdyYXBoLm5vU2hhZG93KHRoaXMpO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIGNvbnRleHQ9Y287dmFyIHRleHRfYW5nbGU9cHJvcFsnY2hhcnQudGV4dC5hbmdsZSddLHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSxsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ11cbmlmKHByb3BbJ2NoYXJ0LnlsYWJlbHMnXSl7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpdGhpcy5EcmF3bGFiZWxzX3RvcCgpO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXRoaXMuRHJhd2xhYmVsc19jZW50ZXIoKTtpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nYm90dG9tJyl0aGlzLkRyYXdsYWJlbHNfYm90dG9tKCk7fVxuaWYodHlwZW9mKGxhYmVscyk9PSdvYmplY3QnJiZsYWJlbHMpe3ZhciB5T2Zmc2V0PU51bWJlcihwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddKSx4T2Zmc2V0PU51bWJlcihwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddKSxib2xkPXByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ11cbmlmKHByb3BbJ2NoYXJ0LnRleHQuYW5nbGUnXSE9MCl7dmFyIHZhbGlnbj0nY2VudGVyJzt2YXIgaGFsaWduPSdyaWdodCc7dmFyIGFuZ2xlPTAtcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddO31lbHNle3ZhciB2YWxpZ249J3RvcCc7dmFyIGhhbGlnbj0nY2VudGVyJzt2YXIgYW5nbGU9MDt9XG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ118fHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgYmFyV2lkdGg9KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQtdGhpcy5ndXR0ZXJMZWZ0KS9sYWJlbHMubGVuZ3RoO3hUaWNrR2FwPShjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LXRoaXMuZ3V0dGVyTGVmdCkvbGFiZWxzLmxlbmd0aFxudmFyIGk9MDt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTtmb3IoeD10aGlzLmd1dHRlckxlZnQrKHhUaWNrR2FwLzIpO3g8PWNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQ7eCs9eFRpY2tHYXApe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOngreE9mZnNldCwneSc6cHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCc/dGhpcy5ndXR0ZXJUb3AreU9mZnNldC01OihjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pK3lPZmZzZXQrMywnYm9sZCc6Ym9sZCwndGV4dCc6U3RyaW5nKGxhYmVsc1tpKytdKSwndmFsaWduJzpwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJz8nYm90dG9tJzp2YWxpZ24sJ2hhbGlnbic6aGFsaWduLCd0YWcnOidsYWJlbCcsJ21hcmtlcic6ZmFsc2UsJ2FuZ2xlJzphbmdsZSwndGFnJzonbGFiZWxzJ30pO319XG50aGlzLmRyYXdBYm92ZUxhYmVscygpO307dGhpcy5kcmF3bGFiZWxzX3RvcD10aGlzLkRyYXdsYWJlbHNfdG9wPWZ1bmN0aW9uKClcbnt2YXIgY2E9dGhpcy5jYW52YXM7dmFyIGNvPXRoaXMuY29udGV4dDt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5zdHJva2VTdHlsZT0nYmxhY2snO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSd0b3AnKXt2YXIgY29udGV4dD1jbzt2YXIgdGV4dF9zaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciBhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7dmFyIGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIG51bVlMYWJlbHM9cHJvcFsnY2hhcnQueWxhYmVscy5jb3VudCddO3ZhciB5bWluPXByb3BbJ2NoYXJ0LnltaW4nXTt2YXIgb2Zmc2V0eD1wcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXTt2YXIgb2Zmc2V0eT1wcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHknXTtpZihwcm9wWydjaGFydC55bGFiZWxzLmluc2lkZSddPT10cnVlKXt2YXIgeHBvcz1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/dGhpcy5ndXR0ZXJMZWZ0KzU6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC01O3ZhciBhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/J2xlZnQnOidyaWdodCc7dmFyIGJveGVkPXRydWU7fWVsc2V7dmFyIHhwb3M9cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdC01OmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrNTt2YXIgYm94ZWQ9ZmFsc2U7fVxuaWYodHlwZW9mKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pe3ZhciBsYWJlbHM9UkdyYXBoLmFycmF5X3JldmVyc2UocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKTt2YXIgZ3JhcGhhcmVhPWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7KytpKXt2YXIgeT10aGlzLmd1dHRlclRvcCsoZ3JhcGhhcmVhKihpL2xhYmVscy5sZW5ndGgpKSsoZ3JhcGhhcmVhL2xhYmVscy5sZW5ndGgpO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzpTdHJpbmcobGFiZWxzW2ldKSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm9yZGVyZWQnOmJveGVkLCd0YWcnOidzY2FsZSd9KTt9XG5yZXR1cm47fVxudmFyIGxhYmVscz10aGlzLnNjYWxlMi5sYWJlbHM7Zm9yKHZhciBpPTA7aTxsYWJlbHMubGVuZ3RoOysraSl7UkdyYXBoLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArKCh0aGlzLmdyYXBoYXJlYS9sYWJlbHMubGVuZ3RoKSooaSsxKSkrb2Zmc2V0eSwndGV4dCc6Jy0nK2xhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm9yZGVyZWQnOmJveGVkLCd0YWcnOidzY2FsZSd9KTt9XG5pZihwcm9wWydjaGFydC55bWluJ10hPTB8fHByb3BbJ2NoYXJ0Lm5veGF4aXMnXXx8cHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pe1JHcmFwaC5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK29mZnNldHksJ3RleHQnOih0aGlzLnNjYWxlMi5taW4hPTA/Jy0nOicnKStSR3JhcGgubnVtYmVyRm9ybWF0KHRoaXMsKHRoaXMuc2NhbGUyLm1pbi50b0ZpeGVkKCh0aGlzLnNjYWxlMi5taW49PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkpKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvcmRlcmVkJzpib3hlZCwndGFnJzonc2NhbGUnfSk7fX1cbmNvLmZpbGwoKTt9O3RoaXMuZHJhd2xhYmVsc19jZW50ZXI9dGhpcy5EcmF3bGFiZWxzX2NlbnRlcj1mdW5jdGlvbigpXG57dmFyIGNhPXRoaXMuY2FudmFzO3ZhciBjbz10aGlzLmNvbnRleHQ7dmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciBudW1ZTGFiZWxzPXByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXt2YXIgdGV4dF9zaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciBjb250ZXh0PWNvO3ZhciBhbGlnbj0nJzt2YXIgeHBvcz0wO3ZhciBib3hlZD1mYWxzZTt2YXIgeW1pbj1wcm9wWydjaGFydC55bWluJ107dmFyIG9mZnNldHg9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J107dmFyIG9mZnNldHk9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR5J107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5zdHJva2VTdHlsZT0nYmxhY2snO2lmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ109PXRydWUpe3ZhciB4cG9zPXByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQrNTpjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LTU7dmFyIGFsaWduPXByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz8nbGVmdCc6J3JpZ2h0Jzt2YXIgYm94ZWQ9dHJ1ZTt9ZWxzZXt2YXIgeHBvcz1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/dGhpcy5ndXR0ZXJMZWZ0LTU6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs1O3ZhciBhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7dmFyIGJveGVkPWZhbHNlO31cbmlmKHR5cGVvZihwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pPT0nb2JqZWN0JyYmcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKXt2YXIgbGFiZWxzPXByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXTt2YXIgZ3JhcGhhcmVhPWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7KytpKXt2YXIgeT10aGlzLmd1dHRlclRvcCsoKGdyYXBoYXJlYS8yKS8obGFiZWxzLmxlbmd0aC0xKSkqaTtSR3JhcGguVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eHBvcytvZmZzZXR4LCd5Jzp5K29mZnNldHksJ3RleHQnOlN0cmluZyhsYWJlbHNbaV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3JkZXJlZCc6Ym94ZWQsJ3RhZyc6J3NjYWxlJ30pO31cbmZvcih2YXIgaT1sYWJlbHMubGVuZ3RoLTE7aT49MTstLWkpe3ZhciB5PXRoaXMuZ3V0dGVyVG9wKyhncmFwaGFyZWEqKGkvKChsYWJlbHMubGVuZ3RoLTEpKjIpKSkrKGdyYXBoYXJlYS8yKTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndGV4dCc6U3RyaW5nKGxhYmVsc1tsYWJlbHMubGVuZ3RoLWktMV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3JkZXJlZCc6Ym94ZWQsJ3RhZyc6J3NjYWxlJ30pO31cbnJldHVybjt9XG5mb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXt2YXIgeT10aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZncmFwaGFyZWEtKCh0aGlzLmhhbGZncmFwaGFyZWEvbnVtWUxhYmVscykqKGkrMSkpO3ZhciB0ZXh0PXRoaXMuc2NhbGUyLmxhYmVsc1tpXTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndGV4dCc6dGV4dCwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm9yZGVyZWQnOmJveGVkLCd0YWcnOidzY2FsZSd9KTt9XG5mb3IodmFyIGk9KHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgtMSk7aT49MDstLWkpe3ZhciB5PXRoaXMuZ3V0dGVyVG9wKygodGhpcy5oYWxmZ3JhcGhhcmVhL251bVlMYWJlbHMpKihpKzEpKSt0aGlzLmhhbGZncmFwaGFyZWE7dmFyIHRleHQ9dGhpcy5zY2FsZTIubGFiZWxzW2ldO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzonLScrdGV4dCwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm9yZGVyZWQnOmJveGVkLCd0YWcnOidzY2FsZSd9KTt9XG5pZih0aGlzLnNjYWxlMi5taW4hPTB8fHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZmdyYXBoYXJlYStvZmZzZXR5LCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMsKHRoaXMuc2NhbGUyLm1pbi50b0ZpeGVkKCh0aGlzLnNjYWxlMi5taW49PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkpKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ3ZhbGlnbic6J2NlbnRlcicsJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvcmRlcmVkJzpib3hlZCwndGFnJzonc2NhbGUnfSk7fX19O3RoaXMuZHJhd2xhYmVsc19ib3R0b209dGhpcy5EcmF3bGFiZWxzX2JvdHRvbT1mdW5jdGlvbigpXG57dmFyIHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSx1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J10sY29udGV4dD10aGlzLmNvbnRleHQsYWxpZ249cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnPydyaWdodCc6J2xlZnQnLGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sbnVtWUxhYmVscz1wcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10seW1pbj1wcm9wWydjaGFydC55bWluJ10sb2Zmc2V0eD1wcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddXG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2NvLnN0cm9rZVN0eWxlPSdibGFjayc7aWYocHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXT09dHJ1ZSl7dmFyIHhwb3M9cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdCs1OmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQtNTt2YXIgYWxpZ249cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnPydsZWZ0JzoncmlnaHQnO3ZhciBib3hlZD10cnVlO31lbHNle3ZhciB4cG9zPXByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQtNTpjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzU7dmFyIGJveGVkPWZhbHNlO31cbmlmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSYmdHlwZW9mKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk9PSdvYmplY3QnKXt2YXIgbGFiZWxzPXByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXTt2YXIgZ3JhcGhhcmVhPWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7KytpKXt2YXIgeT10aGlzLmd1dHRlclRvcCsoZ3JhcGhhcmVhKihpLyhsYWJlbHMubGVuZ3RoLTEpKSk7UkdyYXBoLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzpsYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvcmRlcmVkJzpib3hlZCwndGFnJzonc2NhbGUnfSk7fVxucmV0dXJuO31cbnZhciBndXR0ZXJUb3A9dGhpcy5ndXR0ZXJUb3A7dmFyIGhhbGZUZXh0SGVpZ2h0PXRoaXMuaGFsZlRleHRIZWlnaHQ7dmFyIHNjYWxlPXRoaXMuc2NhbGU7Zm9yKHZhciBpPTA7aTxudW1ZTGFiZWxzOysraSl7dmFyIHRleHQ9dGhpcy5zY2FsZTIubGFiZWxzW2ldO1JHcmFwaC5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK3RoaXMuZ3JhcGhhcmVhLSgodGhpcy5ncmFwaGFyZWEvbnVtWUxhYmVscykqKGkrMSkpK29mZnNldHksJ3RleHQnOnRleHQsJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvcmRlcmVkJzpib3hlZCwndGFnJzonc2NhbGUnfSk7fVxuaWYocHJvcFsnY2hhcnQueW1pbiddIT0wfHxwcm9wWydjaGFydC5ub3hheGlzJ118fHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKXtSRy50ZXh0Mih0aGlzLHtmb250OmZvbnQsc2l6ZTp0ZXh0X3NpemUseDp4cG9zK29mZnNldHgseTpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rb2Zmc2V0eSx0ZXh0OlJHLm51bWJlckZvcm1hdCh0aGlzLCh0aGlzLnNjYWxlMi5taW4udG9GaXhlZCgodGhpcy5zY2FsZTIubWluPT09MD8wOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLHZhbGlnbjonY2VudGVyJyxoYWxpZ246YWxpZ24sYm9yZGVyZWQ6Ym94ZWQsdGFnOidzY2FsZSd9KTt9XG5jby5maWxsKCk7fTt0aGlzLmRyYXdJRVNoYWRvdz10aGlzLkRyYXdJRVNoYWRvdz1mdW5jdGlvbihjb29yZHMpXG57dmFyIGNvPXRoaXMuY29udGV4dDt2YXIgY2E9dGhpcy5jYW52YXM7dmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO3ZhciBwcmV2RmlsbFN0eWxlPWNvLmZpbGxTdHlsZTt2YXIgb2Zmc2V0eD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO3ZhciBvZmZzZXR5PXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5iZWdpblBhdGgoKTtjby5maWxsUmVjdChjb29yZHNbMF0rb2Zmc2V0eCxjb29yZHNbMV0rb2Zmc2V0eSxjb29yZHNbMl0sY29vcmRzWzNdKTtjby5maWxsKCk7Y28uZmlsbFN0eWxlPXByZXZGaWxsU3R5bGU7fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0QmFyPWZ1bmN0aW9uKGUpXG57dmFyIG9iaj1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXM7dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXSxjYW52YXM9b2JqLmNhbnZhcyxjb250ZXh0PW9iai5jb250ZXh0LGNvb3Jkcz1vYmouY29vcmRzXG5mb3IodmFyIGk9MCxsZW49Y29vcmRzLmxlbmd0aDtpPGxlbjtpKz0xKXtpZihvYmouY29vcmRzW2ldLmxlbmd0aD09MCl7Y29udGludWU7fVxudmFyIGxlZnQ9Y29vcmRzW2ldWzBdLHRvcD1jb29yZHNbaV1bMV0sd2lkdGg9Y29vcmRzW2ldWzJdLGhlaWdodD1jb29yZHNbaV1bM10scHJvcD1vYmoucHJvcGVydGllc1xuaWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC54b25seSddKXtwYTIoY28sJ2IgciAlICUgJSAlJyxsZWZ0LHRoaXMuZ3V0dGVyVG9wLHdpZHRoLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7fWVsc2V7cGEyKGNvLCdiIHIgJSAlICUgJScsbGVmdCx0b3Asd2lkdGgsaGVpZ2h0KTt9XG5pZihjby5pc1BvaW50SW5QYXRoKG1vdXNlWCxtb3VzZVkpKXtpZihwcm9wWydjaGFydC50b29sdGlwcyddKXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0P1JHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTpwcm9wWydjaGFydC50b29sdGlwcyddW2ldO31cbnZhciBkYXRhc2V0PTAsaWR4PWlcbndoaWxlKGlkeD49KHR5cGVvZiBvYmouZGF0YVtkYXRhc2V0XT09PSdvYmplY3QnJiZvYmouZGF0YVtkYXRhc2V0XT9vYmouZGF0YVtkYXRhc2V0XS5sZW5ndGg6MSkpe2lmKHR5cGVvZiBvYmouZGF0YVtkYXRhc2V0XT09PSdudW1iZXInKXtpZHgtPTE7fWVsc2UgaWYob2JqLmRhdGFbZGF0YXNldF0pe2lkeC09b2JqLmRhdGFbZGF0YXNldF0ubGVuZ3RoO31lbHNle2lkeC09MTt9XG5kYXRhc2V0Kys7fVxuaWYodHlwZW9mKG9iai5kYXRhW2RhdGFzZXRdKT09J251bWJlcicpe2lkeD1udWxsO31cbnJldHVybnswOm9iaiwxOmxlZnQsMjp0b3AsMzp3aWR0aCw0OmhlaWdodCw1OmksJ29iamVjdCc6b2JqLCd4JzpsZWZ0LCd5Jzp0b3AsJ3dpZHRoJzp3aWR0aCwnaGVpZ2h0JzpoZWlnaHQsJ2luZGV4JzppLCd0b29sdGlwJzp0b29sdGlwLCdpbmRleF9hZGp1c3RlZCc6aWR4LCdkYXRhc2V0JzpkYXRhc2V0fTt9fVxucmV0dXJuIG51bGw7fTt0aGlzLmdldFNoYXBlQnlYPWZ1bmN0aW9uKGUpXG57dmFyIGNhbnZhcz1lLnRhcmdldDt2YXIgbW91c2VDb29yZHM9UkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIG9iaj1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXM7Zm9yKHZhciBpPTAsbGVuPW9iai5jb29yZHMubGVuZ3RoO2k8bGVuO2krKyl7aWYob2JqLmNvb3Jkc1tpXS5sZW5ndGg9PTApe2NvbnRpbnVlO31cbnZhciBtb3VzZVg9bW91c2VDb29yZHNbMF07dmFyIG1vdXNlWT1tb3VzZUNvb3Jkc1sxXTt2YXIgbGVmdD1vYmouY29vcmRzW2ldWzBdO3ZhciB0b3A9b2JqLmNvb3Jkc1tpXVsxXTt2YXIgd2lkdGg9b2JqLmNvb3Jkc1tpXVsyXTt2YXIgaGVpZ2h0PW9iai5jb29yZHNbaV1bM107dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYobW91c2VYPj1sZWZ0JiZtb3VzZVg8PShsZWZ0K3dpZHRoKSl7aWYocHJvcFsnY2hhcnQudG9vbHRpcHMnXSl7dmFyIHRvb2x0aXA9UkdyYXBoLnBhcnNlVG9vbHRpcFRleHQ/UkdyYXBoLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTpwcm9wWydjaGFydC50b29sdGlwcyddW2ldO31cbnJldHVybnswOm9iaiwxOmxlZnQsMjp0b3AsMzp3aWR0aCw0OmhlaWdodCw1OmksJ29iamVjdCc6b2JqLCd4JzpsZWZ0LCd5Jzp0b3AsJ3dpZHRoJzp3aWR0aCwnaGVpZ2h0JzpoZWlnaHQsJ2luZGV4JzppLCd0b29sdGlwJzp0b29sdGlwfTt9fVxucmV0dXJuIG51bGw7fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGFyZylcbnt2YXIgY289dGhpcy5jb250ZXh0O3ZhciBjYT10aGlzLmNhbnZhczt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7aWYoYXJnLmxlbmd0aD09Mil7dmFyIG1vdXNlWD1hcmdbMF07dmFyIG1vdXNlWT1hcmdbMV07fWVsc2V7dmFyIG1vdXNlQ29vcmRzPVJHLmdldE1vdXNlWFkoYXJnKTt2YXIgbW91c2VYPW1vdXNlQ29vcmRzWzBdO3ZhciBtb3VzZVk9bW91c2VDb29yZHNbMV07fVxuaWYobW91c2VZPHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXXx8bW91c2VZPihjYS5oZWlnaHQtcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKXx8bW91c2VYPHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J118fG1vdXNlWD4oY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pKXtyZXR1cm4gbnVsbDt9XG5pZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7dmFyIHZhbHVlPSgoKHRoaXMuZ3JhcGhhcmVhLzIpLShtb3VzZVktcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKSkvdGhpcy5ncmFwaGFyZWEpKih0aGlzLnNjYWxlMi5tYXgtdGhpcy5zY2FsZTIubWluKVxudmFsdWUqPTI7aWYodmFsdWU+PTApe3ZhbHVlKz10aGlzLnNjYWxlMi5taW47fWVsc2V7dmFsdWUtPXRoaXMuc2NhbGUyLm1pbjt9fWVsc2UgaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3ZhciB2YWx1ZT0oKHRoaXMuZ3JhcGhhcmVhLShtb3VzZVktcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKSkvdGhpcy5ncmFwaGFyZWEpKih0aGlzLnNjYWxlMi5tYXgtdGhpcy5zY2FsZTIubWluKVxudmFsdWU9dGhpcy5zY2FsZTIubWF4LXZhbHVlO3ZhbHVlPW1hLmFicyh2YWx1ZSkqIC0xO31lbHNle3ZhciB2YWx1ZT0oKHRoaXMuZ3JhcGhhcmVhLShtb3VzZVktcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKSkvdGhpcy5ncmFwaGFyZWEpKih0aGlzLnNjYWxlMi5tYXgtdGhpcy5zY2FsZTIubWluKVxudmFsdWUrPXRoaXMuc2NhbGUyLm1pbjt9XG5yZXR1cm4gdmFsdWU7fTt0aGlzLmdldFlDb29yZD1mdW5jdGlvbih2YWx1ZSlcbntpZih2YWx1ZT50aGlzLnNjYWxlMi5tYXgpe3JldHVybiBudWxsO31cbnZhciBjbz10aGlzLmNvbnRleHQsY2E9dGhpcy5jYW52YXMscHJvcD10aGlzLnByb3BlcnRpZXM7dmFyIHkseGF4aXNwb3M9cHJvcFsnY2hhcnQueGF4aXNwb3MnXTtpZih4YXhpc3Bvcz09J3RvcCcpe2lmKHZhbHVlPDApe3ZhbHVlPW1hLmFicyh2YWx1ZSk7fVxueT0oKHZhbHVlLXRoaXMuc2NhbGUyLm1pbikvKHRoaXMuc2NhbGUyLm1heC10aGlzLnNjYWxlMi5taW4pKSp0aGlzLmdyYXBoYXJlYTt5PXkrdGhpcy5ndXR0ZXJUb3B9ZWxzZSBpZih4YXhpc3Bvcz09J2NlbnRlcicpe3k9KCh2YWx1ZS10aGlzLnNjYWxlMi5taW4pLyh0aGlzLnNjYWxlMi5tYXgtdGhpcy5zY2FsZTIubWluKSkqKHRoaXMuZ3JhcGhhcmVhLzIpO3k9KHRoaXMuZ3JhcGhhcmVhLzIpLXk7eSs9dGhpcy5ndXR0ZXJUb3A7fWVsc2V7aWYodmFsdWU8dGhpcy5zY2FsZTIubWluKXt2YWx1ZT10aGlzLnNjYWxlMi5taW47fVxueT0oKHZhbHVlLXRoaXMuc2NhbGUyLm1pbikvKHRoaXMuc2NhbGUyLm1heC10aGlzLnNjYWxlMi5taW4pKTt5Kj0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKTt5PWNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS15O31cbnJldHVybiB5O307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7UkcuSGlnaGxpZ2h0LlJlY3QodGhpcyxzaGFwZSk7fX07dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTtpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXt2YXIgYWRqdXN0bWVudD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5hbmdsZSddKm1vdXNlWFlbMF07bW91c2VYWVsxXS09YWRqdXN0bWVudDt9XG5pZihtb3VzZVhZWzBdPj1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddJiZtb3VzZVhZWzBdPD0oY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pJiZtb3VzZVhZWzFdPj1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ10mJm1vdXNlWFlbMV08PShjYS5oZWlnaHQtcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt2YXIgdmFsdWU9TnVtYmVyKHRoaXMuZ2V0VmFsdWUoZSkpO3ZhciBzaGFwZT1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZy5zaGFwZScpXG5pZihzaGFwZSl7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnLHNoYXBlKTtpZih0aGlzLnN0YWNrZWRPckdyb3VwZWQmJnByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ109PSdncm91cGVkJyl7dmFyIGluZGV4ZXM9Ukcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNoYXBlWydpbmRleCddLHRoaXMuZGF0YSk7aWYodHlwZW9mIHRoaXMuZGF0YVtpbmRleGVzWzBdXT09J251bWJlcicpe3RoaXMuZGF0YVtpbmRleGVzWzBdXT1OdW1iZXIodmFsdWUpO31lbHNlIGlmKCFSRy5pc051bGwodGhpcy5kYXRhW2luZGV4ZXNbMF1dKSl7dGhpcy5kYXRhW2luZGV4ZXNbMF1dW2luZGV4ZXNbMV1dPU51bWJlcih2YWx1ZSk7fX1lbHNlIGlmKHR5cGVvZiB0aGlzLmRhdGFbc2hhcGVbJ2luZGV4J11dPT0nbnVtYmVyJyl7dGhpcy5kYXRhW3NoYXBlWydpbmRleCddXT1OdW1iZXIodmFsdWUpO31cblJHLnJlZHJhd0NhbnZhcyhlLnRhcmdldCk7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYWRqdXN0Jyk7fX19O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SR3JhcGguYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ109UkdyYXBoLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXT1wcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1wcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGV4dC5jb2xvciddPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2Vjb2xvciddPXByb3BbJ2NoYXJ0LnN0cm9rZWNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmF4aXMuY29sb3InXT1wcm9wWydjaGFydC5heGlzLmNvbG9yJ107fVxudmFyIGNvbG9ycz1wcm9wWydjaGFydC5jb2xvcnMnXTtpZihjb2xvcnMpe2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO319XG52YXIgY29sb3JzPXByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXTtpZihjb2xvcnMpe2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO319XG5wcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7cHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2Vjb2xvciddKTtwcm9wWydjaGFydC5heGlzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSwwLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xLGxlbj1wYXJ0cy5sZW5ndGg7ajxsZW47KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkdyYXBoLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMuZHJhd0JldmVsPXRoaXMuRHJhd0JldmVsPWZ1bmN0aW9uKClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzO3ZhciBjb29yZHMyPXRoaXMuY29vcmRzMjt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7dmFyIGNvPXRoaXMuY29udGV4dDt2YXIgY2E9dGhpcy5jYW52YXM7aWYocHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09J3N0YWNrZWQnKXtmb3IodmFyIGk9MDtpPGNvb3JkczIubGVuZ3RoOysraSl7aWYoY29vcmRzMltpXSYmY29vcmRzMltpXVswXSYmY29vcmRzMltpXVswXVswXSl7dmFyIHg9Y29vcmRzMltpXVswXVswXTt2YXIgeT1jb29yZHMyW2ldWzBdWzFdO3ZhciB3PWNvb3JkczJbaV1bMF1bMl07dmFyIGFycj1bXTtmb3IodmFyIGo9MDtqPGNvb3JkczJbaV0ubGVuZ3RoOysrail7YXJyLnB1c2goY29vcmRzMltpXVtqXVszXSk7fVxudmFyIGg9UkdyYXBoLmFycmF5X3N1bShhcnIpO2NvLnNhdmUoKTtjby5zdHJva2VTdHlsZT0nYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCx5LHcsaCk7Y28uY2xpcCgpO2NvLnNoYWRvd0NvbG9yPSdibGFjayc7Y28uc2hhZG93T2Zmc2V0WD0wO2NvLnNoYWRvd09mZnNldFk9MDtjby5zaGFkb3dCbHVyPTIwO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeC0zLHktMyx3KzYsaCsxMDApO2NvLmxpbmVXaWR0aD01O2NvLnN0cm9rZSgpO2NvLnJlc3RvcmUoKTt9fX1lbHNle2Zvcih2YXIgaT0wO2k8Y29vcmRzLmxlbmd0aDsrK2kpe2lmKGNvb3Jkc1tpXSl7dmFyIHg9Y29vcmRzW2ldWzBdO3ZhciB5PWNvb3Jkc1tpXVsxXTt2YXIgdz1jb29yZHNbaV1bMl07dmFyIGg9Y29vcmRzW2ldWzNdO3ZhciB4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddO3ZhciB4YXhpc195Y29vcmQ9KChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wO2NvLnNhdmUoKTtjby5zdHJva2VTdHlsZT0nYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCx5LHcsaCk7Y28uY2xpcCgpO2NvLnNoYWRvd0NvbG9yPSdibGFjayc7Y28uc2hhZG93T2Zmc2V0WD0wO2NvLnNoYWRvd09mZnNldFk9MDtjby5zaGFkb3dCbHVyPTIwO2lmKHhheGlzcG9zPT0ndG9wJ3x8KHhheGlzcG9zPT0nY2VudGVyJyYmKHkraCk+eGF4aXNfeWNvb3JkKSl7eT15LTEwMDtoPWgrMTAwO31lbHNle3k9eTtoPWgrMTAwO31cbmNvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeC0zLHktMyx3KzYsaCs2KTtjby5saW5lV2lkdGg9NTtjby5zdHJva2UoKTtjby5yZXN0b3JlKCk7fX19fTt0aGlzLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0PWZ1bmN0aW9uKGluZGV4KVxue3RoaXMuY29vcmRzMi5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLGlkeCxhcnIpXG57aWYodHlwZW9mIHZhbHVlW2luZGV4XT09J29iamVjdCcmJnZhbHVlW2luZGV4XSl7dmFyIHg9dmFsdWVbaW5kZXhdWzBdXG52YXIgeT12YWx1ZVtpbmRleF1bMV1cbnZhciB3PXZhbHVlW2luZGV4XVsyXVxudmFyIGg9dmFsdWVbaW5kZXhdWzNdXG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5saW5lV2lkdGg9Mjtjby5zdHJva2VSZWN0KHgseSx3LGgpO2NvLmZpbGxSZWN0KHgseSx3LGgpO319KTt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZHJhd0Fib3ZlTGFiZWxzPWZ1bmN0aW9uKClcbnt2YXIgbGFiZWxzPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddLHNwZWNpZmljPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zcGVjaWZpYyddLGNvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvciddLGJhY2tncm91bmQ9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmJhY2tncm91bmQnXSxkZWNpbWFscz1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnXSxzaXplPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zaXplJ10sYW5nbGU9LTEqcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmFuZ2xlJ10sdW5pdHNQcmU9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSddLHVuaXRzUG9zdD1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucG9zdCddLGNvb3Jkcz10aGlzLmNvb3Jkcyxjb29yZHMyPXRoaXMuY29vcmRzMixkYXRhPXRoaXMuZGF0YSxsZGF0YT1SRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLG9mZnNldD1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUub2Zmc2V0J10sdGV4dF9mb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSxncm91cGluZz1wcm9wWydjaGFydC5ncm91cGluZyddXG5SRy5ub1NoYWRvdyh0aGlzKTtjby5maWxsU3R5bGU9dHlwZW9mIGNvbG9yPT09J3N0cmluZyc/Y29sb3I6cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmKGxhYmVscyYmZ3JvdXBpbmc9PT0nZ3JvdXBlZCcpe2Zvcih2YXIgaT0wLGxlbj1kYXRhLmxlbmd0aCxzZXF1ZW50aWFsSW5kZXg9MDtpPGxlbjtpKz0xKXtpZih0eXBlb2YgZGF0YVtpXT09PSdudW1iZXInJiZkYXRhW2ldPj0wKXt2YXIgYW5nbGU9YW5nbGU7dmFyIGhhbGlnbj0oYW5nbGU/J2xlZnQnOidjZW50ZXInKTt2YXIgdmFsaWduPWFuZ2xlIT09MD8nY2VudGVyJzonYm90dG9tJztSRy50ZXh0Mih0aGlzLHsnZm9udCc6dGV4dF9mb250LCdzaXplJzp0eXBlb2Ygc2l6ZT09PSdudW1iZXInP3NpemU6dGV4dF9zaXplLTMsJ3gnOmNvb3JkczJbaV1bMF1bMF0rKGNvb3JkczJbaV1bMF1bMl0vMiksJ3knOmNvb3JkczJbaV1bMF1bMV0tb2Zmc2V0LCd0ZXh0JzpzcGVjaWZpYz8oc3BlY2lmaWNbc2VxdWVudGlhbEluZGV4XXx8JycpOlJHLm51bWJlckZvcm1hdCh0aGlzLE51bWJlcih0eXBlb2YgZGF0YVtpXT09PSdvYmplY3QnP2RhdGFbaV1bMF06ZGF0YVtpXSkudG9GaXhlZChkZWNpbWFscyksdW5pdHNQcmUsdW5pdHNQb3N0KSwnaGFsaWduJzpoYWxpZ24sJ3ZhbGlnbic6dmFsaWduLCdhbmdsZSc6YW5nbGUsJ21hcmtlcic6ZmFsc2UsJ2JvdW5kaW5nJzp0cnVlLCdib3VuZGluZy5maWxsJzpiYWNrZ3JvdW5kLCdib3VuZGluZy5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywndGFnJzonbGFiZWxzLmFib3ZlJ30pO3NlcXVlbnRpYWxJbmRleCsrO31lbHNlIGlmKHR5cGVvZiBkYXRhW2ldPT09J251bWJlcicmJmRhdGFbaV08MCl7dmFyIGFuZ2xlPWFuZ2xlO3ZhciBoYWxpZ249YW5nbGU/J3JpZ2h0JzonY2VudGVyJzt2YXIgdmFsaWduPWFuZ2xlIT09MD8nY2VudGVyJzondG9wJztSRy50ZXh0Mih0aGlzLHsnZm9udCc6dGV4dF9mb250LCdzaXplJzp0eXBlb2Ygc2l6ZT09PSdudW1iZXInP3NpemU6dGV4dF9zaXplLTMsJ3gnOmNvb3JkczJbaV1bMF1bMF0rKGNvb3JkczJbaV1bMF1bMl0vMiksJ3knOmNvb3JkczJbaV1bMF1bMV0rY29vcmRzMltpXVswXVszXStvZmZzZXQsJ3RleHQnOnNwZWNpZmljPyhzcGVjaWZpY1tzZXF1ZW50aWFsSW5kZXhdfHwnJyk6UkcubnVtYmVyRm9ybWF0KHRoaXMsTnVtYmVyKHR5cGVvZiBkYXRhW2ldPT09J29iamVjdCc/ZGF0YVtpXVswXTpkYXRhW2ldKS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c1ByZSx1bml0c1Bvc3QpLCdoYWxpZ24nOmhhbGlnbiwndmFsaWduJzp2YWxpZ24sJ2FuZ2xlJzphbmdsZSwnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nLmZpbGwnOmJhY2tncm91bmQsJ2JvdW5kaW5nLnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdtYXJrZXInOmZhbHNlLCd0YWcnOidsYWJlbHMuYWJvdmUnfSk7c2VxdWVudGlhbEluZGV4Kys7fWVsc2UgaWYodHlwZW9mIGRhdGFbaV09PT0nb2JqZWN0Jyl7Zm9yKHZhciBqPTAsbGVuMj1kYXRhW2ldLmxlbmd0aDtqPGxlbjI7ais9MSl7dmFyIGFuZ2xlPWFuZ2xlO3ZhciBoYWxpZ249ZGF0YVtpXVtqXTwwPydyaWdodCc6J2xlZnQnO2hhbGlnbj1hbmdsZT09PTA/J2NlbnRlcic6aGFsaWduO3ZhciB2YWxpZ249ZGF0YVtpXVtqXTwwPyd0b3AnOidib3R0b20nO3ZhbGlnbj1hbmdsZSE9MD8nY2VudGVyJzp2YWxpZ247UkcudGV4dDIodGhpcyx7J2ZvbnQnOnRleHRfZm9udCwnc2l6ZSc6dHlwZW9mIHNpemU9PT0nbnVtYmVyJz9zaXplOnRleHRfc2l6ZS0zLCd4Jzpjb29yZHMyW2ldW2pdWzBdKyhjb29yZHMyW2ldW2pdWzJdLzIpLCd5Jzpjb29yZHMyW2ldW2pdWzFdKyhkYXRhW2ldW2pdPDA/Y29vcmRzMltpXVtqXVszXStvZmZzZXQ6LW9mZnNldCksJ3RleHQnOnNwZWNpZmljPyhzcGVjaWZpY1tzZXF1ZW50aWFsSW5kZXhdfHwnJyk6UkcubnVtYmVyRm9ybWF0KHRoaXMsTnVtYmVyKGRhdGFbaV1bal0pLnRvRml4ZWQoZGVjaW1hbHMpLHVuaXRzUHJlLHVuaXRzUG9zdCksJ2hhbGlnbic6aGFsaWduLCd2YWxpZ24nOnZhbGlnbiwnYW5nbGUnOmFuZ2xlLCdib3VuZGluZyc6dHJ1ZSwnYm91bmRpbmcuZmlsbCc6YmFja2dyb3VuZCwnYm91bmRpbmcuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ21hcmtlcic6ZmFsc2UsJ3RhZyc6J2xhYmVscy5hYm92ZSd9KTtzZXF1ZW50aWFsSW5kZXgrKzt9fX19ZWxzZSBpZihsYWJlbHMmJmdyb3VwaW5nPT09J3N0YWNrZWQnKXtmb3IodmFyIGk9MCxsZW49ZGF0YS5sZW5ndGgsc2VxdWVudGlhbEluZGV4PTA7aTxsZW47aSs9MSl7aWYodHlwZW9mIGRhdGFbaV09PT0nb2JqZWN0Jyl7dmFyIGFuZ2xlPWFuZ2xlO3ZhciBoYWxpZ249YW5nbGUhPTA/J2xlZnQnOidjZW50ZXInO3ZhciB2YWxpZ249YW5nbGUhPTA/J2NlbnRlcic6J2JvdHRvbSc7UkcudGV4dDIodGhpcyx7J2ZvbnQnOnRleHRfZm9udCwnc2l6ZSc6dHlwZW9mIHNpemU9PT0nbnVtYmVyJz9zaXplOnRleHRfc2l6ZS0zLCd4Jzpjb29yZHMyW2ldWzBdWzBdKyhjb29yZHMyW2ldWzBdWzJdLzIpLCd5Jzpjb29yZHMyW2ldWzBdWzFdKyhkYXRhW2ldWzBdPDA/Y29vcmRzMltpXVswXVszXTowKS1vZmZzZXQsJ3RleHQnOnNwZWNpZmljPyhzcGVjaWZpY1tzZXF1ZW50aWFsSW5kZXhdfHwnJyk6UkcubnVtYmVyRm9ybWF0KHRoaXMsTnVtYmVyKFJHLmFycmF5U3VtKGRhdGFbaV0pKS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c1ByZSx1bml0c1Bvc3QpLCdoYWxpZ24nOmhhbGlnbiwndmFsaWduJzp2YWxpZ24sJ2FuZ2xlJzphbmdsZSwnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nLmZpbGwnOmJhY2tncm91bmQsJ2JvdW5kaW5nLnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdtYXJrZXInOmZhbHNlLCd0YWcnOidsYWJlbHMuYWJvdmUnfSk7c2VxdWVudGlhbEluZGV4Kz1kYXRhW2ldLmxlbmd0aDt9ZWxzZXt2YXIgYW5nbGU9YW5nbGU7dmFyIGhhbGlnbj1hbmdsZSE9MD8nbGVmdCc6J2NlbnRlcic7dmFyIHZhbGlnbj1hbmdsZSE9MD8nY2VudGVyJzonYm90dG9tJztSRy50ZXh0Mih0aGlzLHsnZm9udCc6dGV4dF9mb250LCdzaXplJzp0eXBlb2Ygc2l6ZT09PSdudW1iZXInP3NpemU6dGV4dF9zaXplLTMsJ3gnOmNvb3JkczJbaV1bMF1bMF0rKGNvb3JkczJbaV1bMF1bMl0vMiksJ3knOmNvb3JkczJbaV1bMF1bMV0rKGRhdGFbaV1bMF08MD9jb29yZHMyW2ldWzBdWzNdOjApLW9mZnNldCwndGV4dCc6c3BlY2lmaWM/KHNwZWNpZmljW3NlcXVlbnRpYWxJbmRleF18fCcnKTpSRy5udW1iZXJGb3JtYXQodGhpcyxOdW1iZXIoZGF0YVtpXSkudG9GaXhlZChkZWNpbWFscyksdW5pdHNQcmUsdW5pdHNQb3N0KSwnaGFsaWduJzpoYWxpZ24sJ3ZhbGlnbic6dmFsaWduLCdhbmdsZSc6YW5nbGUsJ2JvdW5kaW5nJzp0cnVlLCdib3VuZGluZy5maWxsJzpiYWNrZ3JvdW5kLCdib3VuZGluZy5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnbWFya2VyJzpmYWxzZSwndGFnJzonbGFiZWxzLmFib3ZlJ30pO3NlcXVlbnRpYWxJbmRleCsrO319fX07dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMud2F2ZT1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGxhYmVsc0Fib3ZlPXRoaXMuZ2V0KCdsYWJlbHNBYm92ZScpO29wdC5mcmFtZXM9b3B0LmZyYW1lc3x8NjA7b3B0LnN0YXJ0RnJhbWVzPVtdO29wdC5jb3VudGVycz1bXTt2YXIgZnJhbWVzcGVyYmFyPW9wdC5mcmFtZXMvMyxmcmFtZT0tMSxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxvcmlnaW5hbD1SRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxfZGF0YSk7dGhpcy5zZXQoJ2xhYmVsc0Fib3ZlJyxmYWxzZSk7Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXtvcHQuc3RhcnRGcmFtZXNbaV09KChvcHQuZnJhbWVzLzIpLyhvYmouZGF0YS5sZW5ndGgtMSkpKmk7aWYodHlwZW9mIG9iai5kYXRhW2ldPT09J29iamVjdCcmJm9iai5kYXRhW2ldKXtvcHQuY291bnRlcnNbaV09W107Zm9yKHZhciBqPTA7ajxvYmouZGF0YVtpXS5sZW5ndGg7aisrKXtvcHQuY291bnRlcnNbaV1bal09MDt9fWVsc2V7b3B0LmNvdW50ZXJzW2ldPTA7fX1cbm9iai5kcmF3KCk7b2JqLlNldCgneW1heCcsb2JqLnNjYWxlMi5tYXgpO1JHLmNsZWFyKG9iai5jYW52YXMpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbnsrK2ZyYW1lO2Zvcih2YXIgaT0wLGxlbj1vYmouZGF0YS5sZW5ndGg7aTxsZW47aSs9MSl7aWYoZnJhbWU+b3B0LnN0YXJ0RnJhbWVzW2ldKXtpZih0eXBlb2Ygb2JqLmRhdGFbaV09PT0nbnVtYmVyJyl7b2JqLmRhdGFbaV09bWEubWluKG1hLmFicyhvcmlnaW5hbFtpXSksbWEuYWJzKG9yaWdpbmFsW2ldKigob3B0LmNvdW50ZXJzW2ldKyspL2ZyYW1lc3BlcmJhcikpKTtpZihvcmlnaW5hbFtpXTwwKXtvYmouZGF0YVtpXSo9LTE7fX1lbHNlIGlmKCFSRy5pc051bGwob2JqLmRhdGFbaV0pKXtmb3IodmFyIGo9MCxsZW4yPW9iai5kYXRhW2ldLmxlbmd0aDtqPGxlbjI7ais9MSl7b2JqLmRhdGFbaV1bal09bWEubWluKG1hLmFicyhvcmlnaW5hbFtpXVtqXSksbWEuYWJzKG9yaWdpbmFsW2ldW2pdKigob3B0LmNvdW50ZXJzW2ldW2pdKyspL2ZyYW1lc3BlcmJhcikpKTtpZihvcmlnaW5hbFtpXVtqXTwwKXtvYmouZGF0YVtpXVtqXSo9LTE7fX19fWVsc2V7b2JqLmRhdGFbaV09dHlwZW9mIG9iai5kYXRhW2ldPT09J29iamVjdCcmJm9iai5kYXRhW2ldP1JHLmFycmF5UGFkKFtdLG9iai5kYXRhW2ldLmxlbmd0aCwwKTooUkcuaXNOdWxsKG9iai5kYXRhW2ldKT9udWxsOjApO319XG5pZihmcmFtZT49b3B0LmZyYW1lcyl7aWYobGFiZWxzQWJvdmUpe29iai5zZXQoJ2xhYmVsc0Fib3ZlJyx0cnVlKTtSRy5yZWRyYXcoKTt9XG5jYWxsYmFjayhvYmopO31lbHNle1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmNvbG9yV2F2ZT1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9O29wdC5mcmFtZXM9b3B0LmZyYW1lc3x8NjA7b3B0LnN0YXJ0RnJhbWVzPVtdO29wdC5jb3VudGVycz1bXSxjb2xvcnM9b2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbG9ycyddO2lmKGNvbG9ycy5sZW5ndGg8PW9iai5kYXRhLmxlbmd0aCl7b2JqLnNldCgnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnLHRydWUpO2NvbG9ycz1SRy5hcnJheVBhZChjb2xvcnMsb2JqLmRhdGEubGVuZ3RoLGNvbG9yc1tjb2xvcnMubGVuZ3RoLTFdKTt9XG52YXIgZnJhbWVzcGVyYmFyPW9wdC5mcmFtZXMvMixmcmFtZT0tMSxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxvcmlnaW5hbENvbG9ycz1SRy5hcnJheUNsb25lKG9iai5wcm9wZXJ0aWVzWydjaGFydC5jb2xvcnMnXSk7Zm9yKHZhciBpPTAsbGVuPW9yaWdpbmFsQ29sb3JzLmxlbmd0aDtpPGxlbjtpKz0xKXtvcHQuc3RhcnRGcmFtZXNbaV09KChvcHQuZnJhbWVzLzIpLyhvcmlnaW5hbENvbG9ycy5sZW5ndGgtMSkpKmk7b3B0LmNvdW50ZXJzW2ldPTA7fVxuZnVuY3Rpb24gaXRlcmF0b3IoKVxueysrZnJhbWU7Zm9yKHZhciBpPTAsbGVuPWNvbG9ycy5sZW5ndGg7aTxsZW47aSs9MSl7aWYoZnJhbWU+b3B0LnN0YXJ0RnJhbWVzW2ldJiZjb2xvcnNbaV0ubWF0Y2goL15yZ2JhP1xcKChbMC05IF0rKSwoWzAtOSBdKyksKFswLTkgXSspKCwoWyAwLTkuXSspPylcXCkvKSl7Y29sb3JzW2ldPSdyZ2JhKHsxfSx7Mn0sezN9LHs0fSknLmZvcm1hdChSZWdFeHAuJDEsUmVnRXhwLiQyLFJlZ0V4cC4kMywoZnJhbWUtb3B0LnN0YXJ0RnJhbWVzW2ldKS9mcmFtZXNwZXJiYXIpO31lbHNle2NvbG9yc1tpXT1jb2xvcnNbaV0ucmVwbGFjZSgvLFswLTkuIF0rXFwpLywnLDApJyk7fX1cbmlmKGZyYW1lPj1vcHQuZnJhbWVzKXtjYWxsYmFjayhvYmopO31lbHNle1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8MzAsZnJhbWU9MCxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxvYmo9dGhpcyxsYWJlbHNBYm92ZT10aGlzLmdldCgnbGFiZWxzQWJvdmUnKVxuaWYoUkcuaXNBcnJheShvcHQuZGF0YSkpe3ZhciB5bWF4PTA7Zm9yKHZhciBpPTA7aTxvcHQuZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2Ygb3B0LmRhdGFbaV09PT0nb2JqZWN0Jyl7Zm9yKHZhciBqPTA7ajxvcHQuZGF0YVtpXS5sZW5ndGg7KytqKXtpZih0eXBlb2Ygb3B0LmRhdGFbaV1bal09PT0nc3RyaW5nJyYmb3B0LmRhdGFbaV1bal0ubWF0Y2goLyhcXCt8XFwtKShbMC05XSspLykpe2lmKFJlZ0V4cC4kMT09PScrJyl7b3B0LmRhdGFbaV1bal09dGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdK3BhcnNlSW50KFJlZ0V4cC4kMik7fWVsc2V7b3B0LmRhdGFbaV1bal09dGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdLXBhcnNlSW50KFJlZ0V4cC4kMik7fX1cbnltYXg9bWEubWF4KHltYXgsb3B0LmRhdGFbaV1bal0pO319ZWxzZSBpZih0eXBlb2Ygb3B0LmRhdGFbaV09PT0nc3RyaW5nJyYmb3B0LmRhdGFbaV0ubWF0Y2goLyhcXCt8XFwtKShbMC05XSspLykpe2lmKFJlZ0V4cC4kMT09PScrJyl7b3B0LmRhdGFbaV09dGhpcy5vcmlnaW5hbF9kYXRhW2ldK3BhcnNlSW50KFJlZ0V4cC4kMik7fWVsc2V7b3B0LmRhdGFbaV09dGhpcy5vcmlnaW5hbF9kYXRhW2ldLXBhcnNlSW50KFJlZ0V4cC4kMik7fVxueW1heD1tYS5tYXgoeW1heCxvcHQuZGF0YVtpXSk7fWVsc2V7eW1heD1tYS5tYXgoeW1heCxvcHQuZGF0YVtpXSk7fX1cbnZhciBzY2FsZT1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6eW1heH0pO3RoaXMuU2V0KCdjaGFydC55bWF4JyxzY2FsZS5tYXgpO31cbnRoaXMuc2V0KCdsYWJlbHNBYm92ZScsZmFsc2UpO2lmKHByb3BbJ2NoYXJ0LnltYXgnXT09bnVsbCl7dmFyIHltYXg9MDtmb3IodmFyIGk9MDtpPG9iai5kYXRhLmxlbmd0aDsrK2kpe2lmKFJHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdzdGFja2VkJyl7eW1heD1tYS5tYXgoeW1heCxtYS5hYnMoUkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSkpO31lbHNlIGlmKFJHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdncm91cGVkJyl7Zm9yKHZhciBqPTAsZ3JvdXA9W107ajx0aGlzLmRhdGFbaV0ubGVuZ3RoO2orKyl7Z3JvdXAucHVzaChtYS5hYnModGhpcy5kYXRhW2ldW2pdKSk7fVxueW1heD1tYS5tYXgoeW1heCxtYS5hYnMoUkcuYXJyYXlNYXgoZ3JvdXApKSk7fWVsc2V7eW1heD1tYS5tYXgoeW1heCxtYS5hYnModGhpcy5kYXRhW2ldKSk7fX1cbnZhciBzY2FsZT1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6eW1heH0pO3RoaXMuU2V0KCdjaGFydC55bWF4JyxzY2FsZS5tYXgpO31cbmlmKHR5cGVvZiBvcHQueW1heD09PSdudW1iZXInKXtvYmouc2V0KCd5bWF4JyxvcHQueW1heCk7fVxudmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbnt2YXIgZWFzaW5nTXVsdGlwbGllcj1SRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLGZyYW1lKTtmb3IodmFyIGo9MCxsZW49b2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoO2o8bGVuOysrail7aWYodHlwZW9mIG9iai5kYXRhW2pdPT09J29iamVjdCcmJiFSRy5pc051bGwob2JqLmRhdGFbal0pKXtmb3IodmFyIGs9MCxsZW4yPW9iai5kYXRhW2pdLmxlbmd0aDtrPGxlbjI7KytrKXtpZihvYmouZmlyc3REcmF3fHwhb3B0LmRhdGEpe29iai5kYXRhW2pdW2tdPWVhc2luZ011bHRpcGxpZXIqb2JqLm9yaWdpbmFsX2RhdGFbal1ba107fWVsc2UgaWYob3B0LmRhdGEmJm9wdC5kYXRhLmxlbmd0aD09PW9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCl7dmFyIGRpZmY9b3B0LmRhdGFbal1ba10tb2JqLm9yaWdpbmFsX2RhdGFbal1ba107b2JqLmRhdGFbal1ba109KGVhc2luZ011bHRpcGxpZXIqZGlmZikrb2JqLm9yaWdpbmFsX2RhdGFbal1ba107fX19ZWxzZXtpZihvYmouZmlyc3REcmF3fHwhb3B0LmRhdGEpe29iai5kYXRhW2pdPWVhc2luZ011bHRpcGxpZXIqb2JqLm9yaWdpbmFsX2RhdGFbal07fWVsc2UgaWYob3B0LmRhdGEmJm9wdC5kYXRhLmxlbmd0aD09PW9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCl7dmFyIGRpZmY9b3B0LmRhdGFbal0tb2JqLm9yaWdpbmFsX2RhdGFbal07b2JqLmRhdGFbal09KGVhc2luZ011bHRpcGxpZXIqZGlmZikrb2JqLm9yaWdpbmFsX2RhdGFbal07fX19XG5SRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWU8ZnJhbWVzKXtmcmFtZSs9MTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7aWYoUkcuaXNBcnJheShvcHQuZGF0YSkpe3ZhciBsaW5lYXJfZGF0YT1SRy5hcnJheUxpbmVhcml6ZShkYXRhKTtmb3IodmFyIGk9MDtpPGxpbmVhcl9kYXRhLmxlbmd0aDsrK2kpe2lmKCFvYmpbJyQnK2ldKXtvYmpbJyQnK2ldPXt9O319fVxub2JqLmRhdGE9ZGF0YTtvYmoub3JpZ2luYWxfZGF0YT1SRy5hcnJheUNsb25lKGRhdGEpO2lmKGxhYmVsc0Fib3ZlKXtvYmouc2V0KCdsYWJlbHNBYm92ZScsdHJ1ZSk7UkcucmVkcmF3KCk7fVxuY2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy5kcmF3RXJyb3JiYXJzPWZ1bmN0aW9uKClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzLGNvbG9yPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jb2xvciddfHwnYmxhY2snLGRlZmF1bHRfaGFsZndpZHRoPW1hLm1pbihwcm9wWydjaGFydC5lcnJvcmJhcnMuY2FwcGVkLndpZHRoJ10sY29vcmRzWzBdWzJdKS8yLHg9MCxlcnJvcmJhcnM9cHJvcFsnY2hhcnQuZXJyb3JiYXJzJ10sbGVuZ3RoPTA7aWYoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSl7cHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZC53aWR0aCddPTA7aGFsZndpZHRoPTA7fVxuY28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtmb3IodmFyIGk9MDtpPGNvb3Jkcy5sZW5ndGg7KytpKXtjb2xvcj1wcm9wWydjaGFydC5lcnJvcmJhcnMuY29sb3InXXx8J2JsYWNrJztpZihlcnJvcmJhcnNbaV0mJnR5cGVvZiBlcnJvcmJhcnNbaV1bM109PT0nbnVtYmVyJyl7Y28ubGluZVdpZHRoPWVycm9yYmFyc1tpXVszXTt9XG52YXIgaGFsZndpZHRoPShlcnJvcmJhcnNbaV0mJnR5cGVvZiBlcnJvcmJhcnNbaV1bNF09PT0nbnVtYmVyJyk/ZXJyb3JiYXJzW2ldWzRdLzI6ZGVmYXVsdF9oYWxmd2lkdGg7aWYoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSl7aGFsZndpZHRoPTA7fVxuaWYodHlwZW9mIGVycm9yYmFyc1tpXT09PSdudW1iZXInKXtsZW5ndGg9bWEuYWJzKHRoaXMuZ2V0WUNvb3JkKGVycm9yYmFyc1tpXSktdGhpcy5nZXRZQ29vcmQoMCkpO2lmKGxlbmd0aCl7cGEyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsY29vcmRzW2ldWzBdKyhjb29yZHNbaV1bMl0vMiksY29vcmRzW2ldWzFdLGNvb3Jkc1tpXVswXSsoY29vcmRzW2ldWzJdLzIpLGNvb3Jkc1tpXVsxXS1sZW5ndGgsY29vcmRzW2ldWzBdKyhjb29yZHNbaV1bMl0vMiktaGFsZndpZHRoLG1hLnJvdW5kKGNvb3Jkc1tpXVsxXS1sZW5ndGgpLGNvb3Jkc1tpXVswXSsoY29vcmRzW2ldWzJdLzIpK2hhbGZ3aWR0aCxtYS5yb3VuZChjb29yZHNbaV1bMV0tbGVuZ3RoKSxjb2xvcik7fX1lbHNlIGlmKHR5cGVvZiBlcnJvcmJhcnNbaV09PT0nb2JqZWN0JyYmIVJHLmlzTnVsbChlcnJvcmJhcnNbaV0pKXt2YXIgcG9zaXRpdmVMZW5ndGg9bWEuYWJzKHRoaXMuZ2V0WUNvb3JkKGVycm9yYmFyc1tpXVswXSktdGhpcy5nZXRZQ29vcmQoMCkpO2lmKHR5cGVvZiBlcnJvcmJhcnNbaV1bMV09PT0nc3RyaW5nJyl7Y29sb3I9ZXJyb3JiYXJzW2ldWzFdO31lbHNlIGlmKHR5cGVvZiBlcnJvcmJhcnNbaV1bMl09PT0nc3RyaW5nJyl7Y29sb3I9ZXJyb3JiYXJzW2ldWzJdO31cbmhhbGZ3aWR0aD10eXBlb2YgZXJyb3JiYXJzW2ldWzRdPT09J251bWJlcic/ZXJyb3JiYXJzW2ldWzRdLzI6ZGVmYXVsdF9oYWxmd2lkdGg7aWYoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSl7aGFsZndpZHRoPTA7fVxuaWYoIVJHLmlzTnVsbChlcnJvcmJhcnNbaV1bMF0pKXtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAlJyxjb29yZHNbaV1bMF0rKGNvb3Jkc1tpXVsyXS8yKSxjb29yZHNbaV1bMV0sY29vcmRzW2ldWzBdKyhjb29yZHNbaV1bMl0vMiksY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoLGNvb3Jkc1tpXVswXSsoY29vcmRzW2ldWzJdLzIpLWhhbGZ3aWR0aCxtYS5yb3VuZChjb29yZHNbaV1bMV0tcG9zaXRpdmVMZW5ndGgpLGNvb3Jkc1tpXVswXSsoY29vcmRzW2ldWzJdLzIpK2hhbGZ3aWR0aCxtYS5yb3VuZChjb29yZHNbaV1bMV0tcG9zaXRpdmVMZW5ndGgpLGNvbG9yKTt9XG5pZih0eXBlb2YgZXJyb3JiYXJzW2ldWzFdPT09J251bWJlcicpe3ZhciBuZWdhdGl2ZUxlbmd0aD1tYS5hYnModGhpcy5nZXRZQ29vcmQoZXJyb3JiYXJzW2ldWzFdKS10aGlzLmdldFlDb29yZCgwKSk7cGEyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsY29vcmRzW2ldWzBdKyhjb29yZHNbaV1bMl0vMiksY29vcmRzW2ldWzFdLGNvb3Jkc1tpXVswXSsoY29vcmRzW2ldWzJdLzIpLGNvb3Jkc1tpXVsxXStuZWdhdGl2ZUxlbmd0aCxjb29yZHNbaV1bMF0rKGNvb3Jkc1tpXVsyXS8yKS1oYWxmd2lkdGgsbWEucm91bmQoY29vcmRzW2ldWzFdK25lZ2F0aXZlTGVuZ3RoKSxjb29yZHNbaV1bMF0rKGNvb3Jkc1tpXVsyXS8yKStoYWxmd2lkdGgsbWEucm91bmQoY29vcmRzW2ldWzFdK25lZ2F0aXZlTGVuZ3RoKSxjb2xvcik7fX1cbmlmKGVycm9yYmFyc1tpXSYmdHlwZW9mIGVycm9yYmFyc1tpXVszXT09PSdudW1iZXInKXtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQuZXJyb3JiYXJzLmxpbmV3aWR0aCddO319fTt0aGlzLmlzQWRqdXN0YWJsZT1mdW5jdGlvbihzaGFwZSlcbntpZihSRy5pc051bGwocHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J10pfHwhUkcuaXNBcnJheShwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkpe3JldHVybiB0cnVlO31cbmlmKFJHLmlzQXJyYXkocHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J10pJiZwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXVtzaGFwZS5pbmRleF0pe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O1JHLnJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1JHcmFwaC5Db21iaW5lZENoYXJ0PWZ1bmN0aW9uKClcbnt0aGlzLm9iamVjdHM9W107dmFyIG9iamVjdHM9W107aWYoUkdyYXBoLmlzQXJyYXkoYXJndW1lbnRzWzBdKSl7b2JqZWN0cz1hcmd1bWVudHNbMF07fWVsc2V7Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krPTEpe29iamVjdHNbaV09YXJndW1lbnRzW2ldO319XG5mb3IodmFyIGk9MDtpPG9iamVjdHMubGVuZ3RoOysraSl7dGhpcy5vYmplY3RzW2ldPW9iamVjdHNbaV07dGhpcy5vYmplY3RzW2ldLnNldCh7Z3V0dGVyTGVmdDp0aGlzLm9iamVjdHNbMF0uZ2V0KCdndXR0ZXIubGVmdCcpLGd1dHRlclJpZ2h0OnRoaXMub2JqZWN0c1swXS5nZXQoJ2d1dHRlci5yaWdodCcpLGd1dHRlclRvcDp0aGlzLm9iamVjdHNbMF0uZ2V0KCdndXR0ZXIudG9wJyksZ3V0dGVyQm90dG9tOnRoaXMub2JqZWN0c1swXS5nZXQoJ2d1dHRlci5ib3R0b20nKX0pO2lmKHRoaXMub2JqZWN0c1tpXS50eXBlPT0nbGluZScpe3ZhciBvYmo9dGhpcy5vYmplY3RzW2ldO29iai5zZXQoJ2htYXJnaW4nLCgodGhpcy5vYmplY3RzWzBdLmNhbnZhcy53aWR0aC10aGlzLm9iamVjdHNbMF0uR2V0KCdjaGFydC5ndXR0ZXIucmlnaHQnKS10aGlzLm9iamVjdHNbMF0uR2V0KCdjaGFydC5ndXR0ZXIubGVmdCcpKS90aGlzLm9iamVjdHNbMF0uZGF0YS5sZW5ndGgpLzIpO29iai5zZXQoJ25vYXhlcycsdHJ1ZSk7b2JqLnNldCgnYmFja2dyb3VuZEdyaWQnLGZhbHNlKTtvYmouc2V0KCd5bGFiZWxzJyxmYWxzZSk7fVxuaWYodGhpcy5vYmplY3RzW2ldLmdldCgnY2hhcnQucmVzaXphYmxlJykpe3ZhciByZXNpemFibGVfb2JqZWN0PW9iajt9fVxuaWYocmVzaXphYmxlX29iamVjdCl7ZnVuY3Rpb24gbXlPbnJlc2l6ZWJlZm9yZWRyYXcob2JqKVxue3ZhciBndXR0ZXJMZWZ0PW9iai5nZXQoJ2d1dHRlckxlZnQnKTt2YXIgZ3V0dGVyUmlnaHQ9b2JqLmdldCgnZ3V0dGVyUmlnaHQnKTtvYmouc2V0KCdobWFyZ2luJywob2JqLmNhbnZhcy53aWR0aC1ndXR0ZXJMZWZ0LWd1dHRlclJpZ2h0KS8ob2JqLm9yaWdpbmFsX2RhdGFbMF0ubGVuZ3RoKjIpKTt9XG5SR3JhcGguQWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcihyZXNpemFibGVfb2JqZWN0LCdvbnJlc2l6ZWJlZm9yZWRyYXcnLG15T25yZXNpemViZWZvcmVkcmF3KTt9fTtSR3JhcGguQ29tYmluZWRDaGFydC5wcm90b3R5cGUuYWRkPVJHcmFwaC5Db21iaW5lZENoYXJ0LnByb3RvdHlwZS5BZGQ9ZnVuY3Rpb24ob2JqKVxue3RoaXMub2JqZWN0cy5wdXNoKG9iaik7fTtSR3JhcGguQ29tYmluZWRDaGFydC5wcm90b3R5cGUuZHJhdz1SR3JhcGguQ29tYmluZWRDaGFydC5wcm90b3R5cGUuRHJhdz1mdW5jdGlvbigpXG57Zm9yKHZhciBpPTA7aTx0aGlzLm9iamVjdHMubGVuZ3RoOysraSl7aWYodGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0J10pe3ZhciBvcHRpb25zPXRoaXMub2JqZWN0c1tpXS5wcm9wZXJ0aWVzWydjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdC5vcHRpb25zJ10/ZXZhbCgnKCcrdGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0Lm9wdGlvbnMnXSsnKScpOm51bGwsY2FsbGJhY2s9dGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0LmNhbGxiYWNrJ10sZnVuYz10aGlzLm9iamVjdHNbaV0ucHJvcGVydGllc1snY2hhcnQuY29tYmluZWRjaGFydC5lZmZlY3QnXTsodGhpcy5vYmplY3RzW2ldW2Z1bmNdKShvcHRpb25zLGNhbGxiYWNrKTt9ZWxzZXt0aGlzLm9iamVjdHNbaV0uZHJhdygpO319fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5iYXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///192\n");

/***/ }),
/* 193 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bipolar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.left) === 'object' && _typeof(conf.right) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        left = conf.left,\n        right = conf.right,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        left = arguments[1],\n        right = arguments[2];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bipolar';this.coords = [];this.coordsLeft = [];this.coordsRight = [];this.max = 0;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;for (var i = 0; i < left.length; ++i) {\n    left[i] = parseFloat(left[i]);\n  }for (var i = 0; i < right.length; ++i) {\n    right[i] = parseFloat(right[i]);\n  }this.left = left;this.right = right;this.data = [left, right];this.properties = { 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.linewidth': 1, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.autofit.numhlines': null, 'chart.margin': 2, 'chart.xtickinterval': null, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.above': false, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title.left': '', 'chart.title.right': '', 'chart.gutter.center': 60, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['#0f0'], 'chart.colors.sequential': false, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.units.pre': '', 'chart.units.post': '', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.xmax': null, 'chart.xmin': 0, 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.linewidth': 1, 'chart.noaxes': false, 'chart.xlabels': true, 'chart.numyticks': null, 'chart.numxticks': 5, 'chart.axis.linewidth': 1, 'chart.labels.count': 5, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.angle': 0.1, 'chart.clearto': 'rgba(0,0,0,0)' };\n  while (this.left.length < this.right.length) {\n    this.left.push(null);\n  }while (this.left.length > this.right.length) {\n    this.right.push(null);\n  }this.properties['chart.numyticks'] = this.left.length;var linear_data = RGraph.arrayLinearize(this.left, this.right);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return this.properties[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.gutterCenter = prop['chart.gutter.center'];this.left = this.data[0];this.right = this.data[1];this.coords = [];this.coordsText = [];if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;this.sequentialFullIndex = 0;this.getMax();this.drawBackgroundGrid();this.draw3DAxes();this.drawAxes();this.drawTicks();co.save();co.beginPath();co.rect(this.gutterLeft, this.gutterTop - (prop['chart.variant.threed.offsety'] || 0), ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom + 2 * (prop['chart.variant.threed.offsety'] || 0));co.clip();this.drawLeftBars();this.drawRightBars();this.drawLeftBars({ shadow: false });this.drawRightBars({ shadow: false });co.restore();this.drawAxes();this.drawLabels();this.drawTitles();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.draw3DAxes = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft, ma.round(ca.height - this.gutterBottom), this.gutterLeft + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + offsetx + this.axisWidth, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.axisWidth, ma.round(ca.height - this.gutterBottom));this.draw3DLeftVerticalAxis();pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ma.round(ca.height - this.gutterBottom), this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth, ma.round(ca.height - this.gutterBottom));pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom, this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom - this.axisHeight, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - this.axisHeight - offsety, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety);\n    }\n  };\n  this.draw3DLeftVerticalAxis = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.axisWidth, this.gutterTop, this.gutterLeft + this.axisWidth + offsetx, this.gutterTop - offsety, this.gutterLeft + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety, this.gutterLeft + this.axisWidth, ca.height - this.gutterBottom);\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;if (prop['chart.noaxes']) {\n      return;\n    }\n    co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft + this.axisWidth, Math.round(ca.height - this.gutterBottom));co.moveTo(ma.round(this.gutterLeft + this.axisWidth), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + this.axisWidth), this.gutterTop);co.stroke();co.beginPath();var x = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'];co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), ca.height - this.gutterBottom);co.moveTo(Math.round(x), Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.stroke();\n  };this.drawTicks = this.DrawTicks = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;var numDataPoints = this.left.length;var barHeight = (ca.height - this.gutterTop - this.gutterBottom - this.left.length * (prop['chart.margin'] * 2)) / numDataPoints;this.barHeight = barHeight;if (prop['chart.noaxes']) {\n      return;\n    }\n    if (prop['chart.numyticks'] > 0) {\n      co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth, y);co.lineTo(this.gutterLeft + this.axisWidth + 3, y);\n      }\n      co.stroke();co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'], y);co.lineTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] - 3, y);\n      }\n      co.stroke();\n    }\n    if (prop['chart.numxticks'] > 0) {\n      var xInterval = this.axisWidth / prop['chart.numxticks'];if (typeof prop['chart.xtickinterval'] == 'number') {\n        xInterval = prop['chart.xtickinterval'];\n      }\n      for (i = this.gutterLeft; i < this.gutterLeft + this.axisWidth; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n      var stoppingPoint = ca.width - this.gutterRight;for (i = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] + xInterval; i <= stoppingPoint; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n    }\n  };this.getMax = this.GetMax = function () {\n    var dec = prop['chart.scale.decimals'];if (prop['chart.xmax']) {\n      var max = prop['chart.xmax'];var min = prop['chart.xmin'];this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    } else {\n      var max = Math.max(RG.array_max(this.left), RG.array_max(this.right));this.scale2 = RG.getScale2(this, { 'max': max, 'min': prop['chart.xmin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n  };this.drawLeftBars = this.DrawLeftBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];for (var i = this.left.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.left[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth - width), ma.round(this.gutterTop + i * (this.axisHeight / this.left.length) + prop['chart.margin']), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.drawIEShadow(coords);\n      }\n      if (this.left[i] !== null) {\n        co.strokeRect(coords[0], coords[1], coords[2], coords[3]);co.fillRect(coords[0], coords[1], coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.left[i] !== null) {\n        if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        } else {\n          co.fillStyle = prop['chart.colors'][0];\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.4)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);\n      }\n      this.draw3DLeftVerticalAxis();this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsLeft.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.noShadow(this);co.lineWidth = 1;\n  };this.drawRightBars = this.DrawRightBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (var i = this.right.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.right[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth + prop['chart.gutter.center']), ma.round(prop['chart.margin'] + i * (this.axisHeight / this.right.length) + this.gutterTop), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.DrawIEShadow(coords);\n      }\n      if (this.right[i] !== null) {\n        co.strokeRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);co.fillRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.right[i] !== null) {\n        var color = co.fillStyle;if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1], color);pa2(co, 'b m % % l % % l % % l % % f %', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3], color);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.6)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(0,0,0,0.3)', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3]);\n      }\n      this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsRight.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.NoShadow(this);co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var font = prop['chart.text.font'],\n        color = prop['chart.labels.color'] || prop['chart.text.color'],\n        size = prop['chart.text.size'],\n        labels = prop['chart.labels'],\n        barAreaHeight = ca.height - this.gutterTop - this.gutterBottom;\n    co.fillStyle = color;for (var i = 0, len = labels.length; i < len; i += 1) {\n      RG.Text2(this, { 'color': color, 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] / 2, 'y': this.gutterTop + barAreaHeight / labels.length * i + barAreaHeight / labels.length / 2, 'text': String(labels[i] ? String(labels[i]) : ''), 'halign': 'center', 'valign': 'center', 'marker': false, 'tag': 'labels' });\n    }\n    co.fillStyle = prop['chart.text.color'];if (prop['chart.xlabels']) {\n      var grapharea = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea / this.scale2.labels.length * i, 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[this.scale2.labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea + prop['chart.gutter.center'] + grapharea / this.scale2.labels.length * (i + 1), 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (prop['chart.scale.zerostart']) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + this.gutterCenter, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n    if (prop['chart.labels.above']) {\n      var coordsLeft = RG.arrayReverse(this.coordsLeft);for (var i = 0; i < coordsLeft.length; ++i) {\n        if (typeof this.left[i] !== 'number') {\n          continue;\n        }\n        var coords = coordsLeft[i];RG.text2(this, { font: font, size: size, x: coords[0] - 5, y: coords[1] + coords[3] / 2, text: RG.numberFormat(this, this.left[i], prop['chart.units.pre'], prop['chart.units.post']), valign: 'center', halign: 'right', tag: 'labels.above' });\n      }\n      var coordsRight = RG.arrayReverse(this.coordsRight);for (i = 0; i < coordsRight.length; ++i) {\n        if (typeof this.right[i] != 'number') {\n          continue;\n        }\n        var coords = coordsRight[i];RG.Text2(this, { 'font': font, 'size': size, 'x': coords[0] + coords[2] + 5, 'y': coords[1] + coords[3] / 2, 'text': RG.number_format(this, this.right[i], prop['chart.units.pre'], prop['chart.units.post']), 'valign': 'center', 'halign': 'left', 'tag': 'labels.above' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.gutterLeft + 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.left']), 'halign': 'left', 'valign': 'bottom', 'tag': 'title.left' });RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': ca.width - this.gutterRight - 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.right']), 'halign': 'right', 'valign': 'bottom', 'tag': 'title.right' });RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : null);\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };\n  this.getShape = this.getBar = function (e) {\n    var canvas = this.canvas,\n        context = this.context,\n        mouseCoords = RG.getMouseXY(e);\n    for (var i = 0; i < this.coords.length; i++) {\n      var mouseX = mouseCoords[0],\n          mouseY = mouseCoords[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];\n      pa2(co, 'b r % % % %', left, top, width, height);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getValue = function (e) {\n    var obj = e.target.__object__;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];if (mouseX > this.gutterLeft && mouseX < ca.width / 2 - prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left']) / this.axisWidth;value = this.max - value * this.max;\n    }\n    if (mouseX < ca.width - this.gutterRight && mouseX > ca.width / 2 + prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left'] - this.axisWidth - prop['chart.gutter.center']) / this.axisWidth;value = value * this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (value > this.max || value < 0) {\n      return null;\n    }\n    var ret = [];var offset = value / this.max * this.axisWidth;ret[0] = this.gutterLeft + this.axisWidth - offset;ret[1] = ca.width - this.gutterRight - this.axisWidth + offset;return ret;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    props['chart.highlight.stroke'] = this.parseSingleColorForGradient(props['chart.highlight.stroke']);props['chart.highlight.fill'] = this.parseSingleColorForGradient(props['chart.highlight.fill']);props['chart.axis.color'] = this.parseSingleColorForGradient(props['chart.axis.color']);props['chart.strokestyle'] = this.parseSingleColorForGradient(props['chart.strokestyle']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawBackgroundGrid = function () {\n    if (prop['chart.background.grid']) {\n      var variant = prop['chart.variant'],\n          color = prop['chart.background.grid.color'],\n          numvlines = prop['chart.labels.count'],\n          numhlines = this.left.length,\n          vlines = prop['chart.background.grid.vlines'],\n          hlines = prop['chart.background.grid.hlines'],\n          linewidth = prop['chart.background.grid.linewidth'];if (typeof prop['chart.background.grid.autofit.numhlines'] === 'number') {\n        numhlines = prop['chart.background.grid.autofit.numhlines'];\n      }\n      if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {\n        numvlines = prop['chart.background.grid.autofit.numvlines'];\n      }\n      co.lineWidth = linewidth;if (variant == '3d') {\n        co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth + this.gutterCenter, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth + this.gutterCenter + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (variant == '3d') {\n        co.restore();\n      }\n    }\n  };this.firstDrawFunc = function () {\n    if (prop['chart.tooltips']) {\n      prop['chart.tooltips'] = RG.arrayReverse(prop['chart.tooltips']);\n    }\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  this.grow = function () {\n    var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var obj = this;var originalLeft = RG.arrayClone(this.left);var originalRight = RG.arrayClone(this.right);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < this.left.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.left[i]));\n      }\n      for (var i = 0; i < this.right.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.right[i]));\n      }\n      var scale = RG.getScale2(obj, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var i = 0; i < obj.left.length; i += 1) {\n        obj.left[i] = easingMultiplier * originalLeft[i];\n      }\n      for (var i = 0; i < obj.right.length; i += 1) {\n        obj.right[i] = easingMultiplier * originalRight[i];\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames_left = [];opt.startFrames_right = [];opt.counters_left = [];opt.counters_right = [];var framesperbar = opt.frames / 3,\n        frame_left = -1,\n        frame_right = -1,\n        callback = arguments[1] || function () {},\n        original_left = RG.arrayClone(obj.left),\n        original_right = RG.arrayClone(obj.right);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      opt.startFrames_left[i] = opt.frames / 2 / (obj.left.length - 1) * i;opt.startFrames_right[i] = opt.frames / 2 / (obj.right.length - 1) * i;opt.counters_left[i] = 0;opt.counters_right[i] = 0;\n    }\n    obj.draw();obj.set('xmax', obj.scale2.max);RG.clear(obj.canvas);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      if (typeof obj.left[i] === 'number') obj.left[i] = 0;if (typeof obj.right[i] === 'number') obj.right[i] = 0;\n    }\n    function iteratorLeft() {\n      ++frame_left;for (var i = 0, len = obj.left.length; i < len; i += 1) {\n        if (frame_left > opt.startFrames_left[i]) {\n          var isNull = RG.isNull(obj.left[i]);obj.left[i] = ma.min(ma.abs(original_left[i]), ma.abs(original_left[i] * (opt.counters_left[i]++ / framesperbar)));if (original_left[i] < 0) {\n            obj.left[i] *= -1;\n          }\n          if (isNull) {\n            obj.left[i] = null;\n          }\n        } else {\n          obj.left[i] = _typeof(obj.left[i]) === 'object' && obj.left[i] ? RG.arrayPad([], obj.left[i].length, 0) : RG.isNull(obj.left[i]) ? null : 0;\n        }\n      }\n      if (frame_left < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorLeft);\n      }\n    }\n    function iteratorRight() {\n      ++frame_right;for (var i = 0, len = obj.right.length; i < len; i += 1) {\n        if (frame_right > opt.startFrames_right[i]) {\n          var isNull = RG.isNull(obj.right[i]);obj.right[i] = ma.min(ma.abs(original_right[i]), ma.abs(original_right[i] * (opt.counters_right[i]++ / framesperbar)));if (original_right[i] < 0) {\n            obj.right[i] *= -1;\n          }\n          if (isNull) {\n            obj.right[i] = null;\n          }\n        } else {\n          obj.right[i] = _typeof(obj.right[i]) === 'object' && obj.right[i] ? RG.arrayPad([], obj.right[i].length, 0) : RG.isNull(obj.right[i]) ? null : 0;\n        }\n      }\n      if (frame_right < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorRight);\n      } else {\n        callback(this);\n      }\n    }\n    iteratorLeft();iteratorRight();return this;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguYmlwb2xhci5qcz9kYzJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguQmlwb2xhcj1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmxlZnQ9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYucmlnaHQ9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxsZWZ0PWNvbmYubGVmdCxyaWdodD1jb25mLnJpZ2h0LHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZX1lbHNle3ZhciBpZD1jb25mLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksbGVmdD1hcmd1bWVudHNbMV0scmlnaHQ9YXJndW1lbnRzWzJdfVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudHlwZT0nYmlwb2xhcic7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNMZWZ0PVtdO3RoaXMuY29vcmRzUmlnaHQ9W107dGhpcy5tYXg9MDt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTtmb3IodmFyIGk9MDtpPGxlZnQubGVuZ3RoOysraSlsZWZ0W2ldPXBhcnNlRmxvYXQobGVmdFtpXSk7Zm9yKHZhciBpPTA7aTxyaWdodC5sZW5ndGg7KytpKXJpZ2h0W2ldPXBhcnNlRmxvYXQocmlnaHRbaV0pO3RoaXMubGVmdD1sZWZ0O3RoaXMucmlnaHQ9cmlnaHQ7dGhpcy5kYXRhPVtsZWZ0LHJpZ2h0XTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6JyNkZGQnLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQubGluZXdpZHRoJzoxLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyc6bnVsbCwnY2hhcnQubWFyZ2luJzoyLCdjaGFydC54dGlja2ludGVydmFsJzpudWxsLCdjaGFydC5sYWJlbHMnOltdLCdjaGFydC5sYWJlbHMuY29sb3InOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZSc6ZmFsc2UsJ2NoYXJ0LnRleHQuc2l6ZSc6MTIsJ2NoYXJ0LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LnRleHQuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6dHJ1ZSwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzondmlzaWJsZScsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzp0cnVlLCdjaGFydC50aXRsZS5sZWZ0JzonJywnY2hhcnQudGl0bGUucmlnaHQnOicnLCdjaGFydC5ndXR0ZXIuY2VudGVyJzo2MCwnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MzAsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmNvbG9ycyc6WycjMGYwJ10sJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJzpmYWxzZSwnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonIzY2NicsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzozLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MywnY2hhcnQuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0LnhtYXgnOm51bGwsJ2NoYXJ0LnhtaW4nOjAsJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCc6dHJ1ZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOm51bGwsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LmF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQuc3Ryb2tlc3R5bGUnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5saW5ld2lkdGgnOjEsJ2NoYXJ0Lm5vYXhlcyc6ZmFsc2UsJ2NoYXJ0LnhsYWJlbHMnOnRydWUsJ2NoYXJ0Lm51bXl0aWNrcyc6bnVsbCwnY2hhcnQubnVteHRpY2tzJzo1LCdjaGFydC5heGlzLmxpbmV3aWR0aCc6MSwnY2hhcnQubGFiZWxzLmNvdW50Jzo1LCdjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4JzoxMCwnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSc6NSwnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnOjAuMSwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknfVxud2hpbGUodGhpcy5sZWZ0Lmxlbmd0aDx0aGlzLnJpZ2h0Lmxlbmd0aCl0aGlzLmxlZnQucHVzaChudWxsKTt3aGlsZSh0aGlzLmxlZnQubGVuZ3RoPnRoaXMucmlnaHQubGVuZ3RoKXRoaXMucmlnaHQucHVzaChudWxsKTt0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0Lm51bXl0aWNrcyddPXRoaXMubGVmdC5sZW5ndGg7dmFyIGxpbmVhcl9kYXRhPVJHcmFwaC5hcnJheUxpbmVhcml6ZSh0aGlzLmxlZnQsdGhpcy5yaWdodCk7Zm9yKHZhciBpPTA7aTxsaW5lYXJfZGF0YS5sZW5ndGg7KytpKXt0aGlzWyckJytpXT17fTt9XG5pZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHRoaXMucHJvcGVydGllc1tuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuZ3V0dGVyQ2VudGVyPXByb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXTt0aGlzLmxlZnQ9dGhpcy5kYXRhWzBdO3RoaXMucmlnaHQ9dGhpcy5kYXRhWzFdO3RoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzVGV4dD1bXTtpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtpZihwcm9wWydjaGFydC50ZXh0LmFjY2Vzc2libGUnXSl7fWVsc2V7Y28uc2V0VHJhbnNmb3JtKDEscHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSwwLDEsMC41LDAuNSk7fX1cbnRoaXMuYXhpc1dpZHRoPShjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10tdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzI7dGhpcy5heGlzSGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTt0aGlzLnNlcXVlbnRpYWxGdWxsSW5kZXg9MDt0aGlzLmdldE1heCgpO3RoaXMuZHJhd0JhY2tncm91bmRHcmlkKCk7dGhpcy5kcmF3M0RBeGVzKCk7dGhpcy5kcmF3QXhlcygpO3RoaXMuZHJhd1RpY2tzKCk7Y28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QodGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wLShwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J118fDApLGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0LGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSsoMioocHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddfHwwKSkpO2NvLmNsaXAoKTt0aGlzLmRyYXdMZWZ0QmFycygpO3RoaXMuZHJhd1JpZ2h0QmFycygpO3RoaXMuZHJhd0xlZnRCYXJzKHtzaGFkb3c6ZmFsc2V9KTt0aGlzLmRyYXdSaWdodEJhcnMoe3NoYWRvdzpmYWxzZX0pO2NvLnJlc3RvcmUoKTt0aGlzLmRyYXdBeGVzKCk7dGhpcy5kcmF3TGFiZWxzKCk7dGhpcy5kcmF3VGl0bGVzKCk7aWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3M0RBeGVzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXt2YXIgb2Zmc2V0eD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmF4aXMubGluZXdpZHRoJ10rMC4wMDE7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO3BhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBzICNhYWEgZiAjZGRkJyx0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSx0aGlzLmd1dHRlckxlZnQrb2Zmc2V0eCxtYS5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20tb2Zmc2V0eSksdGhpcy5ndXR0ZXJMZWZ0K29mZnNldHgrdGhpcy5heGlzV2lkdGgsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLW9mZnNldHkpLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCxtYS5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTt0aGlzLmRyYXczRExlZnRWZXJ0aWNhbEF4aXMoKTtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAjYWFhIGYgI2RkZCcsdGhpcy5ndXR0ZXJMZWZ0K3RoaXMuZ3V0dGVyQ2VudGVyK3RoaXMuYXhpc1dpZHRoLG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSksdGhpcy5ndXR0ZXJMZWZ0K3RoaXMuZ3V0dGVyQ2VudGVyK3RoaXMuYXhpc1dpZHRoK29mZnNldHgsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLW9mZnNldHkpLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmd1dHRlckNlbnRlcit0aGlzLmF4aXNXaWR0aCt0aGlzLmF4aXNXaWR0aCtvZmZzZXR4LG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS1vZmZzZXR5KSx0aGlzLmd1dHRlckxlZnQrdGhpcy5ndXR0ZXJDZW50ZXIrdGhpcy5heGlzV2lkdGgrdGhpcy5heGlzV2lkdGgsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7cGEyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgI2FhYSBmICNkZGQnLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmd1dHRlckNlbnRlcit0aGlzLmF4aXNXaWR0aCxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20sdGhpcy5ndXR0ZXJMZWZ0K3RoaXMuZ3V0dGVyQ2VudGVyK3RoaXMuYXhpc1dpZHRoLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS10aGlzLmF4aXNIZWlnaHQsdGhpcy5ndXR0ZXJMZWZ0K3RoaXMuZ3V0dGVyQ2VudGVyK3RoaXMuYXhpc1dpZHRoK29mZnNldHgsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLXRoaXMuYXhpc0hlaWdodC1vZmZzZXR5LHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmd1dHRlckNlbnRlcit0aGlzLmF4aXNXaWR0aCtvZmZzZXR4LGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS1vZmZzZXR5KTt9fVxudGhpcy5kcmF3M0RMZWZ0VmVydGljYWxBeGlzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXt2YXIgb2Zmc2V0eD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J107cGEyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgI2FhYSBmICNkZGQnLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCx0aGlzLmd1dHRlclRvcCx0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgrb2Zmc2V0eCx0aGlzLmd1dHRlclRvcC1vZmZzZXR5LHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCtvZmZzZXR4LGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS1vZmZzZXR5LHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pO319O3RoaXMuZHJhd0F4ZXM9dGhpcy5EcmF3QXhlcz1mdW5jdGlvbigpXG57Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmF4aXMubGluZXdpZHRoJ10rMC4wMDE7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO3RoaXMuYXhpc1dpZHRoPShjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10tdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzI7dGhpcy5heGlzSGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTtpZihwcm9wWydjaGFydC5ub2F4ZXMnXSl7cmV0dXJuO31cbmNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoLE1hdGgucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoKSx0aGlzLmd1dHRlclRvcCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7dmFyIHg9dGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoK3Byb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4KSx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKE1hdGgucm91bmQoeCksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4KSxNYXRoLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LE1hdGgucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28uc3Ryb2tlKCk7fTt0aGlzLmRyYXdUaWNrcz10aGlzLkRyYXdUaWNrcz1mdW5jdGlvbigpXG57Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmF4aXMubGluZXdpZHRoJ10rMC4wMDE7dmFyIG51bURhdGFQb2ludHM9dGhpcy5sZWZ0Lmxlbmd0aDt2YXIgYmFySGVpZ2h0PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS0odGhpcy5sZWZ0Lmxlbmd0aCoocHJvcFsnY2hhcnQubWFyZ2luJ10qMikpKS9udW1EYXRhUG9pbnRzO3RoaXMuYmFySGVpZ2h0PWJhckhlaWdodDtpZihwcm9wWydjaGFydC5ub2F4ZXMnXSl7cmV0dXJuO31cbmlmKHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddPjApe2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQubnVteXRpY2tzJ107KytpKXt2YXIgeT1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ10rKCgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS9wcm9wWydjaGFydC5udW15dGlja3MnXSkqaSk7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCx5KTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoKzMseSk7fVxuY28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Zm9yKHZhciBpPTA7aTxwcm9wWydjaGFydC5udW15dGlja3MnXTsrK2kpe3ZhciB5PXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSsoKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pL3Byb3BbJ2NoYXJ0Lm51bXl0aWNrcyddKSppKTtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoK3Byb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXSx5KTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoK3Byb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXS0zLHkpO31cbmNvLnN0cm9rZSgpO31cbmlmKHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPjApe3ZhciB4SW50ZXJ2YWw9dGhpcy5heGlzV2lkdGgvcHJvcFsnY2hhcnQubnVteHRpY2tzJ107aWYodHlwZW9mKHByb3BbJ2NoYXJ0Lnh0aWNraW50ZXJ2YWwnXSk9PSdudW1iZXInKXt4SW50ZXJ2YWw9cHJvcFsnY2hhcnQueHRpY2tpbnRlcnZhbCddO31cbmZvcihpPXRoaXMuZ3V0dGVyTGVmdDtpPCh0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgpO2krPXhJbnRlcnZhbCl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoaSksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8oTWF0aC5yb3VuZChpKSwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSs0KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTt9XG52YXIgc3RvcHBpbmdQb2ludD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0O2ZvcihpPSh0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgrcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddK3hJbnRlcnZhbCk7aTw9c3RvcHBpbmdQb2ludDtpKz14SW50ZXJ2YWwpe2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKGkpLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKE1hdGgucm91bmQoaSksKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkrNCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7fX19O3RoaXMuZ2V0TWF4PXRoaXMuR2V0TWF4PWZ1bmN0aW9uKClcbnt2YXIgZGVjPXByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107aWYocHJvcFsnY2hhcnQueG1heCddKXt2YXIgbWF4PXByb3BbJ2NoYXJ0LnhtYXgnXTt2YXIgbWluPXByb3BbJ2NoYXJ0LnhtaW4nXTt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6bWF4LCdtaW4nOm1pbiwnc3RyaWN0Jzp0cnVlLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt0aGlzLm1pbj10aGlzLnNjYWxlMi5taW47fWVsc2V7dmFyIG1heD1NYXRoLm1heChSRy5hcnJheV9tYXgodGhpcy5sZWZ0KSxSRy5hcnJheV9tYXgodGhpcy5yaWdodCkpO3RoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4JzptYXgsJ21pbic6cHJvcFsnY2hhcnQueG1pbiddLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt0aGlzLm1pbj10aGlzLnNjYWxlMi5taW47fX07dGhpcy5kcmF3TGVmdEJhcnM9dGhpcy5EcmF3TGVmdEJhcnM9ZnVuY3Rpb24oKVxue3ZhciBvcHQ9e307aWYodHlwZW9mIGFyZ3VtZW50c1swXT09PSdvYmplY3QnKXtvcHQuc2hhZG93PWFyZ3VtZW50c1swXS5zaGFkb3c7fWVsc2V7b3B0LnNoYWRvdz10cnVlO31cbnZhciBvZmZzZXR4PXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtmb3IodmFyIGk9KHRoaXMubGVmdC5sZW5ndGgtMSk7aT49MDtpLT0xKXtpZihwcm9wWydjaGFydC5zaGFkb3cnXSYmcHJvcFsnY2hhcnQudmFyaWFudCddIT09JzNkJyYmb3B0LnNoYWRvdyl7Y28uc2hhZG93Q29sb3I9cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uc2hhZG93Qmx1cj1wcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFg9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZPXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107fVxuaWYocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO31lbHNle2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTt9XG52YXIgd2lkdGg9KCgodGhpcy5sZWZ0W2ldLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSp0aGlzLmF4aXNXaWR0aCk7dmFyIGNvb3Jkcz1bbWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoLXdpZHRoKSxtYS5yb3VuZCh0aGlzLmd1dHRlclRvcCsoaSoodGhpcy5heGlzSGVpZ2h0L3RoaXMubGVmdC5sZW5ndGgpKStwcm9wWydjaGFydC5tYXJnaW4nXSksd2lkdGgsdGhpcy5iYXJIZWlnaHRdO2lmKFJHLklTT0xEJiZwcm9wWydjaGFydC5zaGFkb3cnXSl7dGhpcy5kcmF3SUVTaGFkb3coY29vcmRzKTt9XG5pZih0aGlzLmxlZnRbaV0hPT1udWxsKXtjby5zdHJva2VSZWN0KGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzJdLGNvb3Jkc1szXSk7Y28uZmlsbFJlY3QoY29vcmRzWzBdLGNvb3Jkc1sxXSxjb29yZHNbMl0sY29vcmRzWzNdKTt9XG5pZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnJiZ0aGlzLmxlZnRbaV0hPT1udWxsKXtpZihwcm9wWydjaGFydC5zaGFkb3cnXSYmb3B0LnNoYWRvdyl7Y28uc2hhZG93Q29sb3I9cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uc2hhZG93Qmx1cj1wcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFg9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZPXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107cGEyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGYgYmxhY2sgc2MgcmdiYSgwLDAsMCwwKSBzeCAwIHN5IDAgc2IgMCcsY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK29mZnNldHgrY29vcmRzWzJdLGNvb3Jkc1sxXS1vZmZzZXR5LGNvb3Jkc1swXStvZmZzZXR4K2Nvb3Jkc1syXSxjb29yZHNbMV0tb2Zmc2V0eStjb29yZHNbM10sY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHkrY29vcmRzWzNdKTt9XG5pZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11baV07fWVsc2V7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO31cbnBhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmICUnLGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK29mZnNldHgrY29vcmRzWzJdLGNvb3Jkc1sxXS1vZmZzZXR5LGNvb3Jkc1swXStjb29yZHNbMl0sY29vcmRzWzFdKTtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiByZ2JhKDI1NSwyNTUsMjU1LDAuNCknLGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK29mZnNldHgrY29vcmRzWzJdLGNvb3Jkc1sxXS1vZmZzZXR5LGNvb3Jkc1swXStjb29yZHNbMl0sY29vcmRzWzFdKTt9XG50aGlzLmRyYXczRExlZnRWZXJ0aWNhbEF4aXMoKTt0aGlzLmNvb3Jkcy5wdXNoKFtjb29yZHNbMF0sY29vcmRzWzFdLGNvb3Jkc1syXSxjb29yZHNbM11dKTt0aGlzLmNvb3Jkc0xlZnQucHVzaChbY29vcmRzWzBdLGNvb3Jkc1sxXSxjb29yZHNbMl0sY29vcmRzWzNdXSk7fVxuUkcubm9TaGFkb3codGhpcyk7Y28ubGluZVdpZHRoPTE7fTt0aGlzLmRyYXdSaWdodEJhcnM9dGhpcy5EcmF3UmlnaHRCYXJzPWZ1bmN0aW9uKClcbnt2YXIgb3B0PXt9O2lmKHR5cGVvZiBhcmd1bWVudHNbMF09PT0nb2JqZWN0Jyl7b3B0LnNoYWRvdz1hcmd1bWVudHNbMF0uc2hhZG93O31lbHNle29wdC5zaGFkb3c9dHJ1ZTt9XG52YXIgb2Zmc2V0eD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107aWYocHJvcFsnY2hhcnQuc2hhZG93J10mJnByb3BbJ2NoYXJ0LnZhcmlhbnQnXSE9PSczZCcmJm9wdC5zaGFkb3cpe2NvLnNoYWRvd0NvbG9yPXByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddO2NvLnNoYWRvd0JsdXI9cHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYPXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J107Y28uc2hhZG93T2Zmc2V0WT1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO31cbmZvcih2YXIgaT0odGhpcy5yaWdodC5sZW5ndGgtMSk7aT49MDtpLT0xKXtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11baV07fWVsc2V7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO31cbnZhciB3aWR0aD0oKCh0aGlzLnJpZ2h0W2ldLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSp0aGlzLmF4aXNXaWR0aCk7dmFyIGNvb3Jkcz1bbWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoK3Byb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXSksbWEucm91bmQocHJvcFsnY2hhcnQubWFyZ2luJ10rKGkqKHRoaXMuYXhpc0hlaWdodC90aGlzLnJpZ2h0Lmxlbmd0aCkpK3RoaXMuZ3V0dGVyVG9wKSx3aWR0aCx0aGlzLmJhckhlaWdodF07aWYoUkcuSVNPTEQmJnByb3BbJ2NoYXJ0LnNoYWRvdyddKXt0aGlzLkRyYXdJRVNoYWRvdyhjb29yZHMpO31cbmlmKHRoaXMucmlnaHRbaV0hPT1udWxsKXtjby5zdHJva2VSZWN0KG1hLnJvdW5kKGNvb3Jkc1swXSksTWF0aC5yb3VuZChjb29yZHNbMV0pLGNvb3Jkc1syXSxjb29yZHNbM10pO2NvLmZpbGxSZWN0KG1hLnJvdW5kKGNvb3Jkc1swXSksTWF0aC5yb3VuZChjb29yZHNbMV0pLGNvb3Jkc1syXSxjb29yZHNbM10pO31cbmlmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcmJnRoaXMucmlnaHRbaV0hPT1udWxsKXt2YXIgY29sb3I9Y28uZmlsbFN0eWxlO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddJiZvcHQuc2hhZG93KXtjby5zaGFkb3dDb2xvcj1wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFk9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiBibGFjayBzYyByZ2JhKDAsMCwwLDApIHN4IDAgc3kgMCBzYiAwJyxjb29yZHNbMF0rb2Zmc2V0eCxjb29yZHNbMV0tb2Zmc2V0eSxjb29yZHNbMF0rb2Zmc2V0eCtjb29yZHNbMl0sY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK29mZnNldHgrY29vcmRzWzJdLGNvb3Jkc1sxXS1vZmZzZXR5K2Nvb3Jkc1szXSxjb29yZHNbMF0rb2Zmc2V0eCxjb29yZHNbMV0tb2Zmc2V0eStjb29yZHNbM10pO31cbnBhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmICUnLGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK29mZnNldHgrY29vcmRzWzJdLGNvb3Jkc1sxXS1vZmZzZXR5LGNvb3Jkc1swXStjb29yZHNbMl0sY29vcmRzWzFdLGNvbG9yKTtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiAlJyxjb29yZHNbMF0rY29vcmRzWzJdLGNvb3Jkc1sxXSxjb29yZHNbMF0rY29vcmRzWzJdK29mZnNldHgsY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK2Nvb3Jkc1syXStvZmZzZXR4LGNvb3Jkc1sxXS1vZmZzZXR5K2Nvb3Jkc1szXSxjb29yZHNbMF0rY29vcmRzWzJdLGNvb3Jkc1sxXStjb29yZHNbM10sY29sb3IpO3BhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmIHJnYmEoMjU1LDI1NSwyNTUsMC42KScsY29vcmRzWzBdLGNvb3Jkc1sxXSxjb29yZHNbMF0rb2Zmc2V0eCxjb29yZHNbMV0tb2Zmc2V0eSxjb29yZHNbMF0rb2Zmc2V0eCtjb29yZHNbMl0sY29vcmRzWzFdLW9mZnNldHksY29vcmRzWzBdK2Nvb3Jkc1syXSxjb29yZHNbMV0pO3BhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmIHJnYmEoMCwwLDAsMC4zKScsY29vcmRzWzBdK2Nvb3Jkc1syXSxjb29yZHNbMV0sY29vcmRzWzBdK2Nvb3Jkc1syXStvZmZzZXR4LGNvb3Jkc1sxXS1vZmZzZXR5LGNvb3Jkc1swXStjb29yZHNbMl0rb2Zmc2V0eCxjb29yZHNbMV0tb2Zmc2V0eStjb29yZHNbM10sY29vcmRzWzBdK2Nvb3Jkc1syXSxjb29yZHNbMV0rY29vcmRzWzNdKTt9XG50aGlzLmNvb3Jkcy5wdXNoKFtjb29yZHNbMF0sY29vcmRzWzFdLGNvb3Jkc1syXSxjb29yZHNbM11dKTt0aGlzLmNvb3Jkc1JpZ2h0LnB1c2goW2Nvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzJdLGNvb3Jkc1szXV0pO31cblJHLk5vU2hhZG93KHRoaXMpO2NvLmxpbmVXaWR0aD0xO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sY29sb3I9cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ118fHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSxzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXSxiYXJBcmVhSGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbVxuY28uZmlsbFN0eWxlPWNvbG9yO2Zvcih2YXIgaT0wLGxlbj1sYWJlbHMubGVuZ3RoO2k8bGVuO2krPTEpe1JHLlRleHQyKHRoaXMseydjb2xvcic6Y29sb3IsJ2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOnRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCsocHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddLzIpLCd5Jzp0aGlzLmd1dHRlclRvcCsoKGJhckFyZWFIZWlnaHQvbGFiZWxzLmxlbmd0aCkqKGkpKSsoKGJhckFyZWFIZWlnaHQvbGFiZWxzLmxlbmd0aCkvMiksJ3RleHQnOlN0cmluZyhsYWJlbHNbaV0/U3RyaW5nKGxhYmVsc1tpXSk6JycpLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCdtYXJrZXInOmZhbHNlLCd0YWcnOidsYWJlbHMnfSk7fVxuY28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtpZihwcm9wWydjaGFydC54bGFiZWxzJ10pe3ZhciBncmFwaGFyZWE9KGNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXS10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvMjtmb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6dGhpcy5ndXR0ZXJMZWZ0KygoZ3JhcGhhcmVhL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpKmkpLCd5JzpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rMywndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgtaS0xXSwndmFsaWduJzondG9wJywnaGFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOnRoaXMuZ3V0dGVyTGVmdCtncmFwaGFyZWErcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddKygoZ3JhcGhhcmVhL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpKihpKzEpKSwneSc6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzMsJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzondG9wJywnaGFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7fVxuaWYocHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgsJ3knOmNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSszLCd0ZXh0JzonMCcsJ3ZhbGlnbic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgrdGhpcy5ndXR0ZXJDZW50ZXIsJ3knOmNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSszLCd0ZXh0JzonMCcsJ3ZhbGlnbic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO319XG5pZihwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUnXSl7dmFyIGNvb3Jkc0xlZnQ9UkcuYXJyYXlSZXZlcnNlKHRoaXMuY29vcmRzTGVmdCk7Zm9yKHZhciBpPTA7aTxjb29yZHNMZWZ0Lmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLmxlZnRbaV0hPT0nbnVtYmVyJyl7Y29udGludWU7fVxudmFyIGNvb3Jkcz1jb29yZHNMZWZ0W2ldO1JHLnRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUseDpjb29yZHNbMF0tNSx5OmNvb3Jkc1sxXSsoY29vcmRzWzNdLzIpLHRleHQ6UkcubnVtYmVyRm9ybWF0KHRoaXMsdGhpcy5sZWZ0W2ldLHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSksdmFsaWduOidjZW50ZXInLGhhbGlnbjoncmlnaHQnLHRhZzonbGFiZWxzLmFib3ZlJ30pO31cbnZhciBjb29yZHNSaWdodD1SRy5hcnJheVJldmVyc2UodGhpcy5jb29yZHNSaWdodCk7Zm9yKGk9MDtpPGNvb3Jkc1JpZ2h0Lmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLnJpZ2h0W2ldIT0nbnVtYmVyJyl7Y29udGludWU7fVxudmFyIGNvb3Jkcz1jb29yZHNSaWdodFtpXTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y29vcmRzWzBdK2Nvb3Jkc1syXSs1LCd5Jzpjb29yZHNbMV0rKGNvb3Jkc1szXS8yKSwndGV4dCc6UkcubnVtYmVyX2Zvcm1hdCh0aGlzLHRoaXMucmlnaHRbaV0scHJvcFsnY2hhcnQudW5pdHMucHJlJ10scHJvcFsnY2hhcnQudW5pdHMucG9zdCddKSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonbGVmdCcsJ3RhZyc6J2xhYmVscy5hYm92ZSd9KTt9fX07dGhpcy5kcmF3VGl0bGVzPXRoaXMuRHJhd1RpdGxlcz1mdW5jdGlvbigpXG57UkcuVGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwneCc6dGhpcy5ndXR0ZXJMZWZ0KzUsJ3knOnRoaXMuZ3V0dGVyVG9wLTUsJ3RleHQnOlN0cmluZyhwcm9wWydjaGFydC50aXRsZS5sZWZ0J10pLCdoYWxpZ24nOidsZWZ0JywndmFsaWduJzonYm90dG9tJywndGFnJzondGl0bGUubGVmdCd9KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6cHJvcFsnY2hhcnQudGV4dC5mb250J10sJ3NpemUnOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCd4JzpjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LTUsJ3knOnRoaXMuZ3V0dGVyVG9wLTUsJ3RleHQnOlN0cmluZyhwcm9wWydjaGFydC50aXRsZS5yaWdodCddKSwnaGFsaWduJzoncmlnaHQnLCd2YWxpZ24nOidib3R0b20nLCd0YWcnOid0aXRsZS5yaWdodCd9KTtSRy5kcmF3VGl0bGUodGhpcyxwcm9wWydjaGFydC50aXRsZSddLHRoaXMuZ3V0dGVyVG9wLG51bGwscHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddP3Byb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXTpudWxsKTt9O3RoaXMuZHJhd0lFU2hhZG93PXRoaXMuRHJhd0lFU2hhZG93PWZ1bmN0aW9uKGNvb3Jkcylcbnt2YXIgcHJldkZpbGxTdHlsZT1jby5maWxsU3R5bGU7dmFyIG9mZnNldHg9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTt2YXIgb2Zmc2V0eT1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFJlY3QoY29vcmRzWzBdK29mZnNldHgsY29vcmRzWzFdK29mZnNldHksY29vcmRzWzJdLGNvb3Jkc1szXSk7Y28uZmlsbCgpO2NvLmZpbGxTdHlsZT1wcmV2RmlsbFN0eWxlO31cbnRoaXMuZ2V0U2hhcGU9dGhpcy5nZXRCYXI9ZnVuY3Rpb24oZSlcbnt2YXIgY2FudmFzPXRoaXMuY2FudmFzLGNvbnRleHQ9dGhpcy5jb250ZXh0LG1vdXNlQ29vcmRzPVJHLmdldE1vdXNlWFkoZSlcbmZvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMubGVuZ3RoO2krKyl7dmFyIG1vdXNlWD1tb3VzZUNvb3Jkc1swXSxtb3VzZVk9bW91c2VDb29yZHNbMV0sbGVmdD10aGlzLmNvb3Jkc1tpXVswXSx0b3A9dGhpcy5jb29yZHNbaV1bMV0sd2lkdGg9dGhpcy5jb29yZHNbaV1bMl0saGVpZ2h0PXRoaXMuY29vcmRzW2ldWzNdXG5wYTIoY28sJ2IgciAlICUgJSAlJyxsZWZ0LHRvcCx3aWR0aCxoZWlnaHQpO2lmKGNvLmlzUG9pbnRJblBhdGgobW91c2VYLG1vdXNlWSkpe3ZhciB0b29sdGlwPVJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTtyZXR1cm57MDp0aGlzLDE6bGVmdCwyOnRvcCwzOndpZHRoLDQ6aGVpZ2h0LDU6aSwnb2JqZWN0Jzp0aGlzLCd4JzpsZWZ0LCd5Jzp0b3AsJ3dpZHRoJzp3aWR0aCwnaGVpZ2h0JzpoZWlnaHQsJ2luZGV4JzppLCd0b29sdGlwJzp0b29sdGlwfTt9fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXtSRy5IaWdobGlnaHQuUmVjdCh0aGlzLHNoYXBlKTt9fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG9iaj1lLnRhcmdldC5fX29iamVjdF9fO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdO2lmKG1vdXNlWD50aGlzLmd1dHRlckxlZnQmJm1vdXNlWDwoKGNhLndpZHRoLzIpLShwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10vMikpKXt2YXIgdmFsdWU9KG1vdXNlWC1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddKS90aGlzLmF4aXNXaWR0aDt2YWx1ZT10aGlzLm1heC0odmFsdWUqdGhpcy5tYXgpO31cbmlmKG1vdXNlWDwoY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJm1vdXNlWD4oKGNhLndpZHRoLzIpKyhwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10vMikpKXt2YXIgdmFsdWU9KG1vdXNlWC1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLXRoaXMuYXhpc1dpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXSkvdGhpcy5heGlzV2lkdGg7dmFsdWU9KHZhbHVlKnRoaXMubWF4KTt9XG5yZXR1cm4gdmFsdWU7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcpe3ZhciBhZGp1c3RtZW50PXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10qbW91c2VYWVswXTttb3VzZVhZWzFdLT1hZGp1c3RtZW50O31cbmlmKG1vdXNlWFlbMF0+cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSYmbW91c2VYWVswXTwoY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pJiZtb3VzZVhZWzFdPnByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSYmbW91c2VYWVsxXTwoY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0WENvb3JkPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTwwKXtyZXR1cm4gbnVsbDt9XG52YXIgcmV0PVtdO3ZhciBvZmZzZXQ9KCh2YWx1ZS90aGlzLm1heCkqdGhpcy5heGlzV2lkdGgpO3JldFswXT0odGhpcy5ndXR0ZXJMZWZ0K3RoaXMuYXhpc1dpZHRoKS1vZmZzZXQ7cmV0WzFdPShjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LXRoaXMuYXhpc1dpZHRoKStvZmZzZXQ7cmV0dXJuIHJldDt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYXhpcy5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7fVxudmFyIHByb3BzPXRoaXMucHJvcGVydGllczt2YXIgY29sb3JzPXByb3BzWydjaGFydC5jb2xvcnMnXTtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTt9XG5wcm9wc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BzWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wc1snY2hhcnQuYXhpcy5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BzWydjaGFydC5heGlzLmNvbG9yJ10pO3Byb3BzWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BzWydjaGFydC5zdHJva2VzdHlsZSddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10sMCxjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwwKTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTE7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZEdyaWQ9ZnVuY3Rpb24oKVxue2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCddKXt2YXIgdmFyaWFudD1wcm9wWydjaGFydC52YXJpYW50J10sY29sb3I9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10sbnVtdmxpbmVzPXByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLG51bWhsaW5lcz10aGlzLmxlZnQubGVuZ3RoLHZsaW5lcz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJ10saGxpbmVzPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnXSxsaW5ld2lkdGg9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmxpbmV3aWR0aCddO2lmKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnXT09PSdudW1iZXInKXtudW1obGluZXM9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJ107fVxuaWYodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyddPT09J251bWJlcicpe251bXZsaW5lcz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnXTt9XG5jby5saW5lV2lkdGg9bGluZXdpZHRoO2lmKHZhcmlhbnQ9PSczZCcpe2NvLnNhdmUoKTtjby50cmFuc2xhdGUocHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLC0xKnByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7fVxuaWYodmxpbmVzKXtmb3IodmFyIGk9MDtpPD1udW12bGluZXM7aSs9MSl7cGEyKGNvLCdiIG0gJSAlIGwgJSAlIHMgJScsdGhpcy5ndXR0ZXJMZWZ0Kyh0aGlzLmF4aXNXaWR0aC9udW12bGluZXMpKmksdGhpcy5ndXR0ZXJUb3AsdGhpcy5ndXR0ZXJMZWZ0Kyh0aGlzLmF4aXNXaWR0aC9udW12bGluZXMpKmksdGhpcy5ndXR0ZXJUb3ArdGhpcy5heGlzSGVpZ2h0LGNvbG9yKTt9fVxuaWYoaGxpbmVzKXtmb3IodmFyIGk9MDtpPD1udW1obGluZXM7aSs9MSl7cGEyKGNvLCdiIG0gJSAlIGwgJSAlIHMgJScsdGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wKyh0aGlzLmF4aXNIZWlnaHQvbnVtaGxpbmVzKSppLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCx0aGlzLmd1dHRlclRvcCsodGhpcy5heGlzSGVpZ2h0L251bWhsaW5lcykqaSxjb2xvcik7fX1cbmlmKHZsaW5lcyl7Zm9yKHZhciBpPTA7aTw9bnVtdmxpbmVzO2krPTEpe3BhMihjbywnYiBtICUgJSBsICUgJSBzICUnLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmd1dHRlckNlbnRlcit0aGlzLmF4aXNXaWR0aCsodGhpcy5heGlzV2lkdGgvbnVtdmxpbmVzKSppLHRoaXMuZ3V0dGVyVG9wLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmd1dHRlckNlbnRlcit0aGlzLmF4aXNXaWR0aCsodGhpcy5heGlzV2lkdGgvbnVtdmxpbmVzKSppLHRoaXMuZ3V0dGVyVG9wK3RoaXMuYXhpc0hlaWdodCxjb2xvcik7fX1cbmlmKGhsaW5lcyl7Zm9yKHZhciBpPTA7aTw9bnVtaGxpbmVzO2krPTEpe3BhMihjbywnYiBtICUgJSBsICUgJSBzICUnLHRoaXMuZ3V0dGVyTGVmdCt0aGlzLmF4aXNXaWR0aCt0aGlzLmd1dHRlckNlbnRlcix0aGlzLmd1dHRlclRvcCsodGhpcy5heGlzSGVpZ2h0L251bWhsaW5lcykqaSx0aGlzLmd1dHRlckxlZnQrdGhpcy5heGlzV2lkdGgrdGhpcy5ndXR0ZXJDZW50ZXIrdGhpcy5heGlzV2lkdGgsdGhpcy5ndXR0ZXJUb3ArKHRoaXMuYXhpc0hlaWdodC9udW1obGluZXMpKmksY29sb3IpO319XG5pZih2YXJpYW50PT0nM2QnKXtjby5yZXN0b3JlKCk7fX19O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMnXSl7cHJvcFsnY2hhcnQudG9vbHRpcHMnXT1SRy5hcnJheVJldmVyc2UocHJvcFsnY2hhcnQudG9vbHRpcHMnXSk7fX07UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fVxudGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHwzMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIG9iaj10aGlzO3ZhciBvcmlnaW5hbExlZnQ9UkcuYXJyYXlDbG9uZSh0aGlzLmxlZnQpO3ZhciBvcmlnaW5hbFJpZ2h0PVJHLmFycmF5Q2xvbmUodGhpcy5yaWdodCk7aWYoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LnhtYXgnXSkpe3ZhciB4bWF4PTA7Zm9yKHZhciBpPTA7aTx0aGlzLmxlZnQubGVuZ3RoO2krPTEpe3htYXg9bWEubWF4KHhtYXgsbWEuYWJzKHRoaXMubGVmdFtpXSkpO31cbmZvcih2YXIgaT0wO2k8dGhpcy5yaWdodC5sZW5ndGg7aSs9MSl7eG1heD1tYS5tYXgoeG1heCxtYS5hYnModGhpcy5yaWdodFtpXSkpO31cbnZhciBzY2FsZT1SRy5nZXRTY2FsZTIob2JqLHsnbWF4Jzp4bWF4fSk7dGhpcy5TZXQoJ2NoYXJ0LnhtYXgnLHNjYWxlLm1heCk7fVxudmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbnt2YXIgZWFzaW5nTXVsdGlwbGllcj1SRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLGZyYW1lKTtmb3IodmFyIGk9MDtpPG9iai5sZWZ0Lmxlbmd0aDtpKz0xKXtvYmoubGVmdFtpXT1lYXNpbmdNdWx0aXBsaWVyKm9yaWdpbmFsTGVmdFtpXTt9XG5mb3IodmFyIGk9MDtpPG9iai5yaWdodC5sZW5ndGg7aSs9MSl7b2JqLnJpZ2h0W2ldPWVhc2luZ011bHRpcGxpZXIqb3JpZ2luYWxSaWdodFtpXTt9XG5SRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWU8ZnJhbWVzKXtmcmFtZSs9MTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy53YXZlPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e307b3B0LmZyYW1lcz1vcHQuZnJhbWVzfHw2MDtvcHQuc3RhcnRGcmFtZXNfbGVmdD1bXTtvcHQuc3RhcnRGcmFtZXNfcmlnaHQ9W107b3B0LmNvdW50ZXJzX2xlZnQ9W107b3B0LmNvdW50ZXJzX3JpZ2h0PVtdO3ZhciBmcmFtZXNwZXJiYXI9b3B0LmZyYW1lcy8zLGZyYW1lX2xlZnQ9LTEsZnJhbWVfcmlnaHQ9LTEsY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe30sb3JpZ2luYWxfbGVmdD1SRy5hcnJheUNsb25lKG9iai5sZWZ0KSxvcmlnaW5hbF9yaWdodD1SRy5hcnJheUNsb25lKG9iai5yaWdodCk7Zm9yKHZhciBpPTAsbGVuPW9iai5sZWZ0Lmxlbmd0aDtpPGxlbjtpKz0xKXtvcHQuc3RhcnRGcmFtZXNfbGVmdFtpXT0oKG9wdC5mcmFtZXMvMikvKG9iai5sZWZ0Lmxlbmd0aC0xKSkqaTtvcHQuc3RhcnRGcmFtZXNfcmlnaHRbaV09KChvcHQuZnJhbWVzLzIpLyhvYmoucmlnaHQubGVuZ3RoLTEpKSppO29wdC5jb3VudGVyc19sZWZ0W2ldPTA7b3B0LmNvdW50ZXJzX3JpZ2h0W2ldPTA7fVxub2JqLmRyYXcoKTtvYmouc2V0KCd4bWF4JyxvYmouc2NhbGUyLm1heCk7UkcuY2xlYXIob2JqLmNhbnZhcyk7Zm9yKHZhciBpPTAsbGVuPW9iai5sZWZ0Lmxlbmd0aDtpPGxlbjtpKz0xKXtpZih0eXBlb2Ygb2JqLmxlZnRbaV09PT0nbnVtYmVyJylvYmoubGVmdFtpXT0wO2lmKHR5cGVvZiBvYmoucmlnaHRbaV09PT0nbnVtYmVyJylvYmoucmlnaHRbaV09MDt9XG5mdW5jdGlvbiBpdGVyYXRvckxlZnQoKVxueysrZnJhbWVfbGVmdDtmb3IodmFyIGk9MCxsZW49b2JqLmxlZnQubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGZyYW1lX2xlZnQ+b3B0LnN0YXJ0RnJhbWVzX2xlZnRbaV0pe3ZhciBpc051bGw9UkcuaXNOdWxsKG9iai5sZWZ0W2ldKTtvYmoubGVmdFtpXT1tYS5taW4obWEuYWJzKG9yaWdpbmFsX2xlZnRbaV0pLG1hLmFicyhvcmlnaW5hbF9sZWZ0W2ldKigob3B0LmNvdW50ZXJzX2xlZnRbaV0rKykvZnJhbWVzcGVyYmFyKSkpO2lmKG9yaWdpbmFsX2xlZnRbaV08MCl7b2JqLmxlZnRbaV0qPS0xO31cbmlmKGlzTnVsbCl7b2JqLmxlZnRbaV09bnVsbDt9fWVsc2V7b2JqLmxlZnRbaV09dHlwZW9mIG9iai5sZWZ0W2ldPT09J29iamVjdCcmJm9iai5sZWZ0W2ldP1JHLmFycmF5UGFkKFtdLG9iai5sZWZ0W2ldLmxlbmd0aCwwKTooUkcuaXNOdWxsKG9iai5sZWZ0W2ldKT9udWxsOjApO319XG5pZihmcmFtZV9sZWZ0PG9wdC5mcmFtZXMpe1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvckxlZnQpO319XG5mdW5jdGlvbiBpdGVyYXRvclJpZ2h0KClcbnsrK2ZyYW1lX3JpZ2h0O2Zvcih2YXIgaT0wLGxlbj1vYmoucmlnaHQubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGZyYW1lX3JpZ2h0Pm9wdC5zdGFydEZyYW1lc19yaWdodFtpXSl7dmFyIGlzTnVsbD1SRy5pc051bGwob2JqLnJpZ2h0W2ldKTtvYmoucmlnaHRbaV09bWEubWluKG1hLmFicyhvcmlnaW5hbF9yaWdodFtpXSksbWEuYWJzKG9yaWdpbmFsX3JpZ2h0W2ldKigob3B0LmNvdW50ZXJzX3JpZ2h0W2ldKyspL2ZyYW1lc3BlcmJhcikpKTtpZihvcmlnaW5hbF9yaWdodFtpXTwwKXtvYmoucmlnaHRbaV0qPS0xO31cbmlmKGlzTnVsbCl7b2JqLnJpZ2h0W2ldPW51bGw7fX1lbHNle29iai5yaWdodFtpXT10eXBlb2Ygb2JqLnJpZ2h0W2ldPT09J29iamVjdCcmJm9iai5yaWdodFtpXT9SRy5hcnJheVBhZChbXSxvYmoucmlnaHRbaV0ubGVuZ3RoLDApOihSRy5pc051bGwob2JqLnJpZ2h0W2ldKT9udWxsOjApO319XG5pZihmcmFtZV9yaWdodDxvcHQuZnJhbWVzKXtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3JSaWdodCk7fWVsc2V7Y2FsbGJhY2sodGhpcyk7fX1cbml0ZXJhdG9yTGVmdCgpO2l0ZXJhdG9yUmlnaHQoKTtyZXR1cm4gdGhpczt9O307XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguYmlwb2xhci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///193\n");

/***/ }),
/* 194 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.annotating_canvas_onmousedown = function (e) {\n    if (e.button === 0) {\n      e.target.__object__.Set('chart.mousedown', true);var obj = e.target.__object__,\n          prop = obj.properties;\n      obj.context.beginPath();obj.context.strokeStyle = obj.Get('chart.annotate.color');obj.context.lineWidth = obj.Get('chart.annotate.linewidth');var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      RG.Registry.Set('annotate.actions', [obj.Get('chart.annotate.color')]);obj.context.moveTo(mouseX, mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.Registry.Set('started.annotating', false);RG.Registry.Set('chart.annotating', obj);RG.FireCustomEvent(obj, 'onannotatebegin');\n    }\n    return false;\n  };RG.annotating_window_onmouseup = function (e) {\n    var obj = RG.Registry.Get('chart.annotating');var win = window;if (e.button != 0 || !obj) {\n      return;\n    }\n    var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n      if (tags[i].__object__) {\n        tags[i].__object__.Set('chart.mousedown', false);\n      }\n    }\n    if (RG.Registry.Get('annotate.actions') && RG.Registry.Get('annotate.actions').length > 0 && win.localStorage) {\n      var id = '__rgraph_annotations_' + e.target.id + '__';var annotations = win.localStorage[id] ? win.localStorage[id] + '|' : '';annotations += RG.Registry.Get('annotate.actions');win.localStorage[id] = annotations;\n    }\n    RG.Registry.Set('annotate.actions', []);RG.FireCustomEvent(obj, 'onannotateend');\n  };RGraph.annotating_canvas_onmousemove = function (e) {\n    var obj = e.target.__object__;var prop = obj.properties;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var lastXY = RG.Registry.Get('annotate.last.coordinates');if (obj.Get('chart.mousedown')) {\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      obj.context.beginPath();if (!lastXY) {\n        obj.context.moveTo(mouseX, mouseY);\n      } else {\n        obj.context.strokeStyle = obj.properties['chart.annotate.color'];obj.context.moveTo(lastXY[0], lastXY[1]);obj.context.lineTo(mouseX, mouseY);\n      }\n      RG.Registry.Set('annotate.actions', RG.Registry.Get('annotate.actions') + '|' + mouseX + ',' + mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.FireCustomEvent(obj, 'onannotate');obj.context.stroke();\n    }\n  };RG.ShowPalette = RG.Showpalette = function (e) {\n    var isSafari = navigator.userAgent.indexOf('Safari') ? true : false;e = RG.FixEventObject(e);var canvas = e.target.parentNode.__canvas__,\n        context = canvas.getContext('2d'),\n        obj = canvas.__object__,\n        div = document.createElement('DIV'),\n        coords = RG.getMouseXY(e);\n    div.__object__ = obj;div.className = 'RGraph_palette';div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.left = 0;div.style.top = 0;div.style.padding = '3px';div.style.paddingLeft = '5px';div.style.opacity = 0;div.style.boxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.MozBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';var colors = ['Black', 'Red', 'Yellow', 'Green', 'Orange', 'White', 'Magenta', 'Pink'];for (var i = 0, len = colors.length; i < len; i += 1) {\n      var div2 = doc.createElement('DIV');div2.cssClass = 'RGraph_palette_color';div2.style.fontSize = '12pt';div2.style.cursor = 'pointer';div2.style.padding = '1px';div2.style.paddingRight = '10px';div2.style.textAlign = 'left';var span = document.createElement('SPAN');span.style.display = 'inline-block';span.style.marginRight = '9px';span.style.width = '17px';span.style.height = '17px';span.style.top = '2px';span.style.position = 'relative';span.style.backgroundColor = colors[i];div2.appendChild(span);div2.innerHTML += colors[i];div2.onmouseover = function () {\n        this.style.backgroundColor = '#eee';\n      };\n      div2.onmouseout = function () {\n        this.style.backgroundColor = '';\n      };\n      div2.onclick = function (e) {\n        var color = this.childNodes[0].style.backgroundColor;obj.Set('chart.annotate.color', color);\n      };\n      div.appendChild(div2);\n    }\n    doc.body.appendChild(div);div.style.left = e.pageX + 'px';div.style.top = e.pageY + 'px';if (e.pageX + (div.offsetWidth + 5) > document.body.offsetWidth) {\n      div.style.left = e.pageX - div.offsetWidth + 'px';\n    }\n    RGraph.Registry.Set('chart.palette', div);setTimeout(function () {\n      div.style.opacity = 0.2;\n    }, 50);setTimeout(function () {\n      div.style.opacity = 0.4;\n    }, 100);setTimeout(function () {\n      div.style.opacity = 0.6;\n    }, 150);setTimeout(function () {\n      div.style.opacity = 0.8;\n    }, 200);setTimeout(function () {\n      div.style.opacity = 1;\n    }, 250);RGraph.hideContext();window.onclick = function () {\n      RG.hidePalette();\n    };\n    e.stopPropagation();return false;\n  };RG.clearAnnotations = RG.ClearAnnotations = function (canvas) {\n    if (typeof canvas === 'string') {\n      var id = canvas;canvas = doc.getElementById(id);\n    } else {\n      var id = canvas.id;\n    }\n    var obj = canvas.__object__;if (win.localStorage && win.localStorage['__rgraph_annotations_' + id + '__'] && win.localStorage['__rgraph_annotations_' + id + '__'].length) {\n      win.localStorage['__rgraph_annotations_' + id + '__'] = [];RGraph.FireCustomEvent(obj, 'onannotateclear');\n    }\n  };RG.replayAnnotations = RG.ReplayAnnotations = function (obj) {\n    if (!win.localStorage) {\n      return;\n    }\n    var context = obj.context;var annotations = win.localStorage['__rgraph_annotations_' + obj.id + '__'];var i, len, move, coords;context.beginPath();context.lineWidth = obj.Get('annotate.linewidth');if (annotations && annotations.length) {\n      annotations = annotations.split('|');\n    } else {\n      return;\n    }\n    for (i = 0, len = annotations.length; i < len; ++i) {\n      if (annotations[i].match(/[a-z]+/)) {\n        context.stroke();context.beginPath();context.strokeStyle = annotations[i];move = true;continue;\n      }\n      coords = annotations[i].split(',');coords[0] = Number(coords[0]);coords[1] = Number(coords[1]);if (move) {\n        context.moveTo(coords[0], coords[1]);move = false;\n      } else {\n        context.lineTo(coords[0], coords[1]);\n      }\n    }\n    context.stroke();\n  };window.addEventListener('load', function (e) {\n    setTimeout(function () {\n      var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n        if (tags[i].__object__ && tags[i].__object__.isRGraph && tags[i].__object__.Get('chart.annotatable')) {\n          RG.replayAnnotations(tags[i].__object__);\n        }\n      }\n    }, 100);\n  }, false);\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmFubm90YXRlLmpzPzBiODkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aDtSRy5hbm5vdGF0aW5nX2NhbnZhc19vbm1vdXNlZG93bj1mdW5jdGlvbihlKVxue2lmKGUuYnV0dG9uPT09MCl7ZS50YXJnZXQuX19vYmplY3RfXy5TZXQoJ2NoYXJ0Lm1vdXNlZG93bicsdHJ1ZSk7dmFyIG9iaj1lLnRhcmdldC5fX29iamVjdF9fLHByb3A9b2JqLnByb3BlcnRpZXNcbm9iai5jb250ZXh0LmJlZ2luUGF0aCgpO29iai5jb250ZXh0LnN0cm9rZVN0eWxlPW9iai5HZXQoJ2NoYXJ0LmFubm90YXRlLmNvbG9yJyk7b2JqLmNvbnRleHQubGluZVdpZHRoPW9iai5HZXQoJ2NoYXJ0LmFubm90YXRlLmxpbmV3aWR0aCcpO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSksbW91c2VYPW1vdXNlWFlbMF0sbW91c2VZPW1vdXNlWFlbMV1cbmlmKG9iai50eXBlPT09J2JhcicmJnByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcpe3ZhciBhZGp1c3RtZW50PXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10qbW91c2VYWVswXTttb3VzZVktPWFkanVzdG1lbnQ7fVxuUkcuUmVnaXN0cnkuU2V0KCdhbm5vdGF0ZS5hY3Rpb25zJyxbb2JqLkdldCgnY2hhcnQuYW5ub3RhdGUuY29sb3InKV0pO29iai5jb250ZXh0Lm1vdmVUbyhtb3VzZVgsbW91c2VZKTtSRy5SZWdpc3RyeS5TZXQoJ2Fubm90YXRlLmxhc3QuY29vcmRpbmF0ZXMnLFttb3VzZVgsbW91c2VZXSk7UkcuUmVnaXN0cnkuU2V0KCdzdGFydGVkLmFubm90YXRpbmcnLGZhbHNlKTtSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LmFubm90YXRpbmcnLG9iaik7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hbm5vdGF0ZWJlZ2luJyk7fVxucmV0dXJuIGZhbHNlO307UkcuYW5ub3RhdGluZ193aW5kb3dfb25tb3VzZXVwPWZ1bmN0aW9uKGUpXG57dmFyIG9iaj1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFubm90YXRpbmcnKTt2YXIgd2luPXdpbmRvdztpZihlLmJ1dHRvbiE9MHx8IW9iail7cmV0dXJuO31cbnZhciB0YWdzPWRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7Zm9yKHZhciBpPTA7aTx0YWdzLmxlbmd0aDsrK2kpe2lmKHRhZ3NbaV0uX19vYmplY3RfXyl7dGFnc1tpXS5fX29iamVjdF9fLlNldCgnY2hhcnQubW91c2Vkb3duJyxmYWxzZSk7fX1cbmlmKFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUuYWN0aW9ucycpJiZSRy5SZWdpc3RyeS5HZXQoJ2Fubm90YXRlLmFjdGlvbnMnKS5sZW5ndGg+MCYmd2luLmxvY2FsU3RvcmFnZSl7dmFyIGlkPSdfX3JncmFwaF9hbm5vdGF0aW9uc18nK2UudGFyZ2V0LmlkKydfXyc7dmFyIGFubm90YXRpb25zPXdpbi5sb2NhbFN0b3JhZ2VbaWRdP3dpbi5sb2NhbFN0b3JhZ2VbaWRdKyd8JzonJzthbm5vdGF0aW9ucys9UkcuUmVnaXN0cnkuR2V0KCdhbm5vdGF0ZS5hY3Rpb25zJyk7d2luLmxvY2FsU3RvcmFnZVtpZF09YW5ub3RhdGlvbnM7fVxuUkcuUmVnaXN0cnkuU2V0KCdhbm5vdGF0ZS5hY3Rpb25zJyxbXSk7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hbm5vdGF0ZWVuZCcpO307UkdyYXBoLmFubm90YXRpbmdfY2FudmFzX29ubW91c2Vtb3ZlPWZ1bmN0aW9uKGUpXG57dmFyIG9iaj1lLnRhcmdldC5fX29iamVjdF9fO3ZhciBwcm9wPW9iai5wcm9wZXJ0aWVzO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdO3ZhciBtb3VzZVk9bW91c2VYWVsxXTt2YXIgbGFzdFhZPVJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUubGFzdC5jb29yZGluYXRlcycpO2lmKG9iai5HZXQoJ2NoYXJ0Lm1vdXNlZG93bicpKXtpZihvYmoudHlwZT09PSdiYXInJiZwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXt2YXIgYWRqdXN0bWVudD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5hbmdsZSddKm1vdXNlWFlbMF07bW91c2VZLT1hZGp1c3RtZW50O31cbm9iai5jb250ZXh0LmJlZ2luUGF0aCgpO2lmKCFsYXN0WFkpe29iai5jb250ZXh0Lm1vdmVUbyhtb3VzZVgsbW91c2VZKX1lbHNle29iai5jb250ZXh0LnN0cm9rZVN0eWxlPW9iai5wcm9wZXJ0aWVzWydjaGFydC5hbm5vdGF0ZS5jb2xvciddO29iai5jb250ZXh0Lm1vdmVUbyhsYXN0WFlbMF0sbGFzdFhZWzFdKTtvYmouY29udGV4dC5saW5lVG8obW91c2VYLG1vdXNlWSk7fVxuUkcuUmVnaXN0cnkuU2V0KCdhbm5vdGF0ZS5hY3Rpb25zJyxSRy5SZWdpc3RyeS5HZXQoJ2Fubm90YXRlLmFjdGlvbnMnKSsnfCcrbW91c2VYKycsJyttb3VzZVkpO1JHLlJlZ2lzdHJ5LlNldCgnYW5ub3RhdGUubGFzdC5jb29yZGluYXRlcycsW21vdXNlWCxtb3VzZVldKTtSRy5GaXJlQ3VzdG9tRXZlbnQob2JqLCdvbmFubm90YXRlJyk7b2JqLmNvbnRleHQuc3Ryb2tlKCk7fX07UkcuU2hvd1BhbGV0dGU9UkcuU2hvd3BhbGV0dGU9ZnVuY3Rpb24oZSlcbnt2YXIgaXNTYWZhcmk9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKT90cnVlOmZhbHNlO2U9UkcuRml4RXZlbnRPYmplY3QoZSk7dmFyIGNhbnZhcz1lLnRhcmdldC5wYXJlbnROb2RlLl9fY2FudmFzX18sY29udGV4dD1jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxvYmo9Y2FudmFzLl9fb2JqZWN0X18sZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpLGNvb3Jkcz1SRy5nZXRNb3VzZVhZKGUpXG5kaXYuX19vYmplY3RfXz1vYmo7ZGl2LmNsYXNzTmFtZT0nUkdyYXBoX3BhbGV0dGUnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J3doaXRlJztkaXYuc3R5bGUuYm9yZGVyPScxcHggc29saWQgYmxhY2snO2Rpdi5zdHlsZS5sZWZ0PTA7ZGl2LnN0eWxlLnRvcD0wO2Rpdi5zdHlsZS5wYWRkaW5nPSczcHgnO2Rpdi5zdHlsZS5wYWRkaW5nTGVmdD0nNXB4JztkaXYuc3R5bGUub3BhY2l0eT0wO2Rpdi5zdHlsZS5ib3hTaGFkb3c9J3JnYmEoOTYsOTYsOTYsMC41KSAzcHggM3B4IDNweCc7ZGl2LnN0eWxlLldlYmtpdEJveFNoYWRvdz0ncmdiYSg5Niw5Niw5NiwwLjUpIDNweCAzcHggM3B4JztkaXYuc3R5bGUuTW96Qm94U2hhZG93PSdyZ2JhKDk2LDk2LDk2LDAuNSkgM3B4IDNweCAzcHgnO3ZhciBjb2xvcnM9WydCbGFjaycsJ1JlZCcsJ1llbGxvdycsJ0dyZWVuJywnT3JhbmdlJywnV2hpdGUnLCdNYWdlbnRhJywnUGluayddO2Zvcih2YXIgaT0wLGxlbj1jb2xvcnMubGVuZ3RoO2k8bGVuO2krPTEpe3ZhciBkaXYyPWRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYyLmNzc0NsYXNzPSdSR3JhcGhfcGFsZXR0ZV9jb2xvcic7ZGl2Mi5zdHlsZS5mb250U2l6ZT0nMTJwdCc7ZGl2Mi5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO2RpdjIuc3R5bGUucGFkZGluZz0nMXB4JztkaXYyLnN0eWxlLnBhZGRpbmdSaWdodD0nMTBweCc7ZGl2Mi5zdHlsZS50ZXh0QWxpZ249J2xlZnQnO3ZhciBzcGFuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NQQU4nKTtzcGFuLnN0eWxlLmRpc3BsYXk9J2lubGluZS1ibG9jayc7c3Bhbi5zdHlsZS5tYXJnaW5SaWdodD0nOXB4JztzcGFuLnN0eWxlLndpZHRoPScxN3B4JztzcGFuLnN0eWxlLmhlaWdodD0nMTdweCc7c3Bhbi5zdHlsZS50b3A9JzJweCc7c3Bhbi5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO3NwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yc1tpXTtkaXYyLmFwcGVuZENoaWxkKHNwYW4pO2RpdjIuaW5uZXJIVE1MKz1jb2xvcnNbaV07ZGl2Mi5vbm1vdXNlb3Zlcj1mdW5jdGlvbigpXG57dGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9JyNlZWUnO31cbmRpdjIub25tb3VzZW91dD1mdW5jdGlvbigpXG57dGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Jyc7fVxuZGl2Mi5vbmNsaWNrPWZ1bmN0aW9uKGUpXG57dmFyIGNvbG9yPXRoaXMuY2hpbGROb2Rlc1swXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7b2JqLlNldCgnY2hhcnQuYW5ub3RhdGUuY29sb3InLGNvbG9yKTt9XG5kaXYuYXBwZW5kQ2hpbGQoZGl2Mik7fVxuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtkaXYuc3R5bGUubGVmdD1lLnBhZ2VYKydweCc7ZGl2LnN0eWxlLnRvcD1lLnBhZ2VZKydweCc7aWYoKGUucGFnZVgrKGRpdi5vZmZzZXRXaWR0aCs1KSk+ZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCl7ZGl2LnN0eWxlLmxlZnQ9KGUucGFnZVgtZGl2Lm9mZnNldFdpZHRoKSsncHgnO31cblJHcmFwaC5SZWdpc3RyeS5TZXQoJ2NoYXJ0LnBhbGV0dGUnLGRpdik7c2V0VGltZW91dChmdW5jdGlvbigpe2Rpdi5zdHlsZS5vcGFjaXR5PTAuMjt9LDUwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGl2LnN0eWxlLm9wYWNpdHk9MC40O30sMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGl2LnN0eWxlLm9wYWNpdHk9MC42O30sMTUwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGl2LnN0eWxlLm9wYWNpdHk9MC44O30sMjAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGl2LnN0eWxlLm9wYWNpdHk9MTt9LDI1MCk7UkdyYXBoLmhpZGVDb250ZXh0KCk7d2luZG93Lm9uY2xpY2s9ZnVuY3Rpb24oKVxue1JHLmhpZGVQYWxldHRlKCk7fVxuZS5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gZmFsc2U7fTtSRy5jbGVhckFubm90YXRpb25zPVJHLkNsZWFyQW5ub3RhdGlvbnM9ZnVuY3Rpb24oY2FudmFzKVxue2lmKHR5cGVvZiBjYW52YXM9PT0nc3RyaW5nJyl7dmFyIGlkPWNhbnZhcztjYW52YXM9ZG9jLmdldEVsZW1lbnRCeUlkKGlkKTt9ZWxzZXt2YXIgaWQ9Y2FudmFzLmlkfVxudmFyIG9iaj1jYW52YXMuX19vYmplY3RfXztpZih3aW4ubG9jYWxTdG9yYWdlJiZ3aW4ubG9jYWxTdG9yYWdlWydfX3JncmFwaF9hbm5vdGF0aW9uc18nK2lkKydfXyddJiZ3aW4ubG9jYWxTdG9yYWdlWydfX3JncmFwaF9hbm5vdGF0aW9uc18nK2lkKydfXyddLmxlbmd0aCl7d2luLmxvY2FsU3RvcmFnZVsnX19yZ3JhcGhfYW5ub3RhdGlvbnNfJytpZCsnX18nXT1bXTtSR3JhcGguRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hbm5vdGF0ZWNsZWFyJyk7fX07UkcucmVwbGF5QW5ub3RhdGlvbnM9UkcuUmVwbGF5QW5ub3RhdGlvbnM9ZnVuY3Rpb24ob2JqKVxue2lmKCF3aW4ubG9jYWxTdG9yYWdlKXtyZXR1cm47fVxudmFyIGNvbnRleHQ9b2JqLmNvbnRleHQ7dmFyIGFubm90YXRpb25zPXdpbi5sb2NhbFN0b3JhZ2VbJ19fcmdyYXBoX2Fubm90YXRpb25zXycrb2JqLmlkKydfXyddO3ZhciBpLGxlbixtb3ZlLGNvb3Jkcztjb250ZXh0LmJlZ2luUGF0aCgpO2NvbnRleHQubGluZVdpZHRoPW9iai5HZXQoJ2Fubm90YXRlLmxpbmV3aWR0aCcpO2lmKGFubm90YXRpb25zJiZhbm5vdGF0aW9ucy5sZW5ndGgpe2Fubm90YXRpb25zPWFubm90YXRpb25zLnNwbGl0KCd8Jyk7fWVsc2V7cmV0dXJuO31cbmZvcihpPTAsbGVuPWFubm90YXRpb25zLmxlbmd0aDtpPGxlbjsrK2kpe2lmKGFubm90YXRpb25zW2ldLm1hdGNoKC9bYS16XSsvKSl7Y29udGV4dC5zdHJva2UoKTtjb250ZXh0LmJlZ2luUGF0aCgpO2NvbnRleHQuc3Ryb2tlU3R5bGU9YW5ub3RhdGlvbnNbaV07bW92ZT10cnVlO2NvbnRpbnVlO31cbmNvb3Jkcz1hbm5vdGF0aW9uc1tpXS5zcGxpdCgnLCcpO2Nvb3Jkc1swXT1OdW1iZXIoY29vcmRzWzBdKTtjb29yZHNbMV09TnVtYmVyKGNvb3Jkc1sxXSk7aWYobW92ZSl7Y29udGV4dC5tb3ZlVG8oY29vcmRzWzBdLGNvb3Jkc1sxXSk7bW92ZT1mYWxzZTt9ZWxzZXtjb250ZXh0LmxpbmVUbyhjb29yZHNbMF0sY29vcmRzWzFdKTt9fVxuY29udGV4dC5zdHJva2UoKTt9O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJyxmdW5jdGlvbihlKVxue3NldFRpbWVvdXQoZnVuY3Rpb24oKVxue3ZhciB0YWdzPWRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7Zm9yKHZhciBpPTA7aTx0YWdzLmxlbmd0aDsrK2kpe2lmKHRhZ3NbaV0uX19vYmplY3RfXyYmdGFnc1tpXS5fX29iamVjdF9fLmlzUkdyYXBoJiZ0YWdzW2ldLl9fb2JqZWN0X18uR2V0KCdjaGFydC5hbm5vdGF0YWJsZScpKXtSRy5yZXBsYXlBbm5vdGF0aW9ucyh0YWdzW2ldLl9fb2JqZWN0X18pO319fSwxMDApO30sZmFsc2UpO30pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmFubm90YXRlLmpzIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///194\n");

/***/ }),
/* 195 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.contextmenu = RG.Contextmenu = function (obj, menuitems, e) {\n    var canvas = obj.canvas;e = RG.FixEventObject(e);RG.FireCustomEvent(obj, 'onbeforecontextmenu');if (RG.Registry.Get('chart.contextmenu')) {\n      RG.HideContext();\n    }\n    RG.HideZoomedCanvas();RG.HidePalette();obj.Set('chart.mousedown', false);var x = e.pageX;var y = e.pageY;var div = document.createElement('div');var bg = document.createElement('div');div.className = 'RGraph_contextmenu';div.__canvas__ = canvas;div.style.position = 'absolute';div.style.left = 0;div.style.top = 0;div.style.border = '1px solid #666';div.style.backgroundColor = 'white';div.style.boxShadow = '1px 1px 3px #ddd';div.style.MozBoxShadow = '1px 1px 3px #ddd';div.style.WebkitBoxShadow = '1px 1px 3px #ddd';div.style.opacity = 0;bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg.style.opacity = 0;div = document.body.appendChild(div);bg = div.appendChild(bg);for (i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('div');menuitem.__object__ = obj;menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = div;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.textAlign = 'left';menuitem.style.fontWeight = 'normal';menuitem.innerHTML = menuitems[i][0];if (RG.is_array(menuitems[i][1])) {\n          menuitem.style.backgroundImage = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAQUlEQVQImY3NoQ2AMABE0ZewABMyGQ6mqWODzlAclBSFO8HZl8uf0FFxCHtwYkt4Y6ChYE44cGH9/fyae2p2LAleW9oVTQuVf6gAAAAASUVORK5CYII=)';menuitem.style.backgroundRepeat = 'no-repeat';menuitem.style.backgroundPosition = '97% center';\n        }\n        if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              RG.HideContextSubmenu();e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              RG.HideContextSubmenu();event.srcElement.style.backgroundColor = '#eee';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      div.appendChild(menuitem);if (menuitems[i] && menuitems[i][1] && typeof menuitems[i][1] == 'function') {\n        menuitem.addEventListener('click', menuitems[i][1], false);\n      } else if (menuitems[i] && menuitems[i][1] && RG.is_array(menuitems[i][1])) {\n        (function () {\n          var tmp = menuitems[i][1];menuitem.addEventListener('mouseover', function (e) {\n            RG.Contextmenu_submenu(obj, tmp, e.target);\n          }, false);\n        })();\n      }\n    }\n    div.style.width = div.offsetWidth + 10 + 'px';div.style.height = div.offsetHeight - 2 + 'px';if (x + div.offsetWidth > document.body.offsetWidth) {\n      x -= div.offsetWidth;\n    }\n    div.style.left = x + 'px';div.style.top = y + 'px';setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 1\", 250);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 1\", 250);RG.Registry.Set('chart.contextmenu', div);RG.Registry.Set('chart.contextmenu.bg', bg);RG.Registry.Get('chart.contextmenu').oncontextmenu = function () {\n      return false;\n    };RG.Registry.Get('chart.contextmenu.bg').oncontextmenu = function () {\n      return false;\n    };canvas.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('resize', function () {\n      RG.HideContext();\n    }, false);if (typeof obj.getShape == 'function') {\n      RG.Registry.Get('chart.contextmenu').__shape__ = obj.getShape(e);\n    }\n    e.stopPropagation();RG.FireCustomEvent(obj, 'oncontextmenu');return false;\n  };RG.hideContext = RG.HideContext = function () {\n    var cm = RG.Registry.Get('chart.contextmenu');var cmbg = RG.Registry.Get('chart.contextmenu.bg');RG.HideContextSubmenu();if (cm) {\n      cm.parentNode.removeChild(cm);cmbg.parentNode.removeChild(cmbg);cm.style.visibility = 'hidden';cm.style.display = 'none';RG.Registry.Set('chart.contextmenu', null);cmbg.style.visibility = 'hidden';cmbg.style.display = 'none';RG.Registry.Set('chart.contextmenu.bg', null);\n    }\n  };RG.hideContextSubmenu = RG.HideContextSubmenu = function () {\n    var sub = RG.Registry.Get('chart.contextmenu.submenu');if (sub) {\n      sub.style.visibility = 'none';sub.style.display = 'none';RG.Registry.Set('chart.contextmenu.submenu', null);\n    }\n  };RG.showContext = RG.ShowContext = function (obj) {\n    RG.HidePalette();if (obj.Get('chart.contextmenu') && obj.Get('chart.contextmenu').length) {\n      var isOpera = navigator.userAgent.indexOf('Opera') >= 0;var isSafari = navigator.userAgent.indexOf('Safari') >= 0;var isChrome = navigator.userAgent.indexOf('Chrome') >= 0;var isMacFirefox = navigator.userAgent.indexOf('Firefox') > 0 && navigator.userAgent.indexOf('Mac') > 0;var isIE9 = navigator.userAgent.indexOf('MSIE 9') >= 0;if ((!isOpera && !isSafari || isChrome) && !isMacFirefox) {\n        obj.canvas.oncontextmenu = function (e) {\n          e = RG.FixEventObject(e);if (e.ctrlKey) return true;RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);return false;\n        };\n      } else {\n        obj.canvas.addEventListener('dblclick', function (e) {\n          if (e.ctrlKey) return true;if (!RG.Registry.Get('chart.contextmenu')) {\n            RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);\n          }\n        }, false);\n      }\n    }\n  };RG.contextmenu_submenu = RG.Contextmenu_submenu = function (obj, menuitems, parentMenuItem) {\n    RG.HideContextSubmenu();var canvas = obj.canvas;var context = obj.context;var menu = parentMenuItem.parentNode;var subMenu = document.createElement('DIV');subMenu.style.position = 'absolute';subMenu.style.width = '100px';subMenu.style.top = menu.offsetTop + parentMenuItem.offsetTop + 'px';subMenu.style.left = menu.offsetLeft + menu.offsetWidth - (RG.ISOLD ? 9 : 0) + 'px';subMenu.style.backgroundColor = 'white';subMenu.style.border = '1px solid black';subMenu.className = 'RGraph_contextmenu';subMenu.__contextmenu__ = menu;subMenu.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.WebkitBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.filter = 'progid:DXImageTransform.Microsoft.Shadow(color=#aaaaaa,direction=135)';document.body.appendChild(subMenu);for (var i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('DIV');menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = menu;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.fontWeight = 'normal';menuitem.style.textAlign = 'left';menuitem.innerHTML = menuitems[i][0];if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.backgroundColor = 'rgba(0,0,0,0.2)';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      subMenu.appendChild(menuitem);if (menuitems[i] && menuitems[i][1]) {\n        if (document.all) {\n          menuitem.attachEvent('onclick', menuitems[i][1]);\n        } else {\n          menuitem.addEventListener('click', menuitems[i][1], false);\n        }\n      }\n    }\n    var bg = document.createElement('DIV');bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg = subMenu.appendChild(bg);RG.Registry.Set('chart.contextmenu.submenu', subMenu);\n  };RG.showPNG = function () {\n    if (RG.ISIE8) {\n      alert('[RGRAPH PNG] Sorry, showing a PNG is not supported on MSIE8.');return;\n    }\n    if (arguments[0] && arguments[0].id) {\n      var canvas = arguments[0];var event = arguments[1];\n    } else if (RG.Registry.Get('chart.contextmenu')) {\n      var canvas = RG.Registry.Get('chart.contextmenu').__canvas__;\n    } else {\n      alert('[RGRAPH SHOWPNG] Could not find canvas!');\n    }\n    var obj = canvas.__object__;var bg = document.createElement('DIV');bg.id = '__rgraph_image_bg__';bg.style.position = 'fixed';bg.style.top = '-10px';bg.style.left = '-10px';bg.style.width = '5000px';bg.style.height = '5000px';bg.style.backgroundColor = 'rgb(204,204,204)';bg.style.opacity = 0;document.body.appendChild(bg);var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.border = '1px solid black';div.style.position = 'fixed';div.style.top = '20%';div.style.width = canvas.width + 'px';div.style.height = canvas.height + 35 + 'px';div.style.left = document.body.clientWidth / 2 - canvas.width / 2 + 'px';div.style.padding = '5px';div.style.borderRadius = '10px';div.style.MozBorderRadius = '10px';div.style.WebkitBorderRadius = '10px';div.style.boxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.MozBoxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 0 0 15px';div.__canvas__ = canvas;div.__object__ = obj;div.id = '__rgraph_image_div__';document.body.appendChild(div);div.innerHTML += '<div style=\"position: absolute; margin-left: 10px; top: ' + canvas.height + 'px; width: ' + (canvas.width - 50) + 'px; height: 25px\"><span style=\"font-size: 12pt;display: inline; display: inline-block; width: 65px; text-align: right\">URL:</span><textarea style=\"float: right; overflow: hidden; height: 20px; width: ' + (canvas.width - obj.gutterLeft - obj.gutterRight - 80) + 'px\" onclick=\"this.select()\" readonly=\"readonly\" id=\"__rgraph_dataurl__\">' + canvas.toDataURL() + '</textarea></div>';div.innerHTML += '<div style=\"position: absolute; top: ' + (canvas.height + 25) + 'px; left: ' + (obj.gutterLeft - 65 + canvas.width / 2) + 'px; width: ' + (canvas.width - obj.gutterRight) + 'px; font-size: 65%\">A link using the URL: <a href=\"' + canvas.toDataURL() + '\">View</a></div>';\n    var img = document.createElement('IMG');RG.Registry.Set('chart.png', img);img.__canvas__ = canvas;img.__object__ = obj;img.id = '__rgraph_image_img__';img.className = 'RGraph_png';img.src = canvas.toDataURL();div.appendChild(img);setTimeout(function () {\n      document.getElementById(\"__rgraph_dataurl__\").select();\n    }, 50);window.addEventListener('resize', function (e) {\n      var img = RG.Registry.Get('chart.png');img.style.left = document.body.clientWidth / 2 - img.width / 2 + 'px';\n    }, false);bg.onclick = function (e) {\n      var div = document.getElementById(\"__rgraph_image_div__\");var bg = document.getElementById(\"__rgraph_image_bg__\");if (div) {\n        div.style.opacity = 0;div.parentNode.removeChild(div);div.id = '';div.style.display = 'none';div = null;\n      }\n      if (bg) {\n        bg.style.opacity = 0;bg.id = '';bg.style.display = 'none';bg = null;\n      }\n    };\n    window.addEventListener('resize', function (e) {\n      bg.onclick(e);\n    }, false);\n    RG.showpng_image_bg = bg;RG.showpng_image_div = div;setTimeout('RGraph.showpng_image_div.style.opacity = 0.2', 50);setTimeout('RGraph.showpng_image_div.style.opacity = 0.4', 100);setTimeout('RGraph.showpng_image_div.style.opacity = 0.6', 150);setTimeout('RGraph.showpng_image_div.style.opacity = 0.8', 200);setTimeout('RGraph.showpng_image_div.style.opacity = 1', 250);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.1', 50);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.2', 100);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.3', 150);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.4', 200);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.5', 250);img.onclick = function (e) {\n      if (e.stopPropagation) e.stopPropagation();else event.cancelBubble = true;\n    };\n    if (event && event.stopPropagation) {\n      event.stopPropagation();\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmNvbnRleHQuanM/MTBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLmNvbnRleHRtZW51PVJHLkNvbnRleHRtZW51PWZ1bmN0aW9uKG9iaixtZW51aXRlbXMsZSlcbnt2YXIgY2FudmFzPW9iai5jYW52YXM7ZT1SRy5GaXhFdmVudE9iamVjdChlKTtSRy5GaXJlQ3VzdG9tRXZlbnQob2JqLCdvbmJlZm9yZWNvbnRleHRtZW51Jyk7aWYoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKXtSRy5IaWRlQ29udGV4dCgpO31cblJHLkhpZGVab29tZWRDYW52YXMoKTtSRy5IaWRlUGFsZXR0ZSgpO29iai5TZXQoJ2NoYXJ0Lm1vdXNlZG93bicsZmFsc2UpO3ZhciB4PWUucGFnZVg7dmFyIHk9ZS5wYWdlWTt2YXIgZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3ZhciBiZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtkaXYuY2xhc3NOYW1lPSdSR3JhcGhfY29udGV4dG1lbnUnO2Rpdi5fX2NhbnZhc19fPWNhbnZhcztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUubGVmdD0wO2Rpdi5zdHlsZS50b3A9MDtkaXYuc3R5bGUuYm9yZGVyPScxcHggc29saWQgIzY2Nic7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj0nd2hpdGUnO2Rpdi5zdHlsZS5ib3hTaGFkb3c9JzFweCAxcHggM3B4ICNkZGQnO2Rpdi5zdHlsZS5Nb3pCb3hTaGFkb3c9JzFweCAxcHggM3B4ICNkZGQnO2Rpdi5zdHlsZS5XZWJraXRCb3hTaGFkb3c9JzFweCAxcHggM3B4ICNkZGQnO2Rpdi5zdHlsZS5vcGFjaXR5PTA7YmcuY2xhc3NOYW1lPSdSR3JhcGhfY29udGV4dG1lbnVfYmFja2dyb3VuZCc7Ymcuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztiZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9JyNjY2MnO2JnLnN0eWxlLmJvcmRlclJpZ2h0PScxcHggc29saWQgI2FhYSc7Ymcuc3R5bGUudG9wPTA7Ymcuc3R5bGUubGVmdD0wO2JnLnN0eWxlLndpZHRoPScxOHB4JztiZy5zdHlsZS5oZWlnaHQ9JzEwMCUnO2JnLnN0eWxlLm9wYWNpdHk9MDtkaXY9ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO2JnPWRpdi5hcHBlbmRDaGlsZChiZyk7Zm9yKGk9MDtpPG1lbnVpdGVtcy5sZW5ndGg7KytpKXt2YXIgbWVudWl0ZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7bWVudWl0ZW0uX19vYmplY3RfXz1vYmo7bWVudWl0ZW0uX19jYW52YXNfXz1jYW52YXM7bWVudWl0ZW0uX19jb250ZXh0bWVudV9fPWRpdjttZW51aXRlbS5jbGFzc05hbWU9J1JHcmFwaF9jb250ZXh0bWVudV9pdGVtJztpZihtZW51aXRlbXNbaV0pe21lbnVpdGVtLnN0eWxlLnBhZGRpbmc9JzJweCA1cHggMnB4IDIzcHgnO21lbnVpdGVtLnN0eWxlLmZvbnRGYW1pbHk9J0FyaWFsJzttZW51aXRlbS5zdHlsZS5mb250U2l6ZT0nMTBwdCc7bWVudWl0ZW0uc3R5bGUudGV4dEFsaWduPSdsZWZ0JzttZW51aXRlbS5zdHlsZS5mb250V2VpZ2h0PSdub3JtYWwnO21lbnVpdGVtLmlubmVySFRNTD1tZW51aXRlbXNbaV1bMF07aWYoUkcuaXNfYXJyYXkobWVudWl0ZW1zW2ldWzFdKSl7bWVudWl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlPSd1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBY0FBQUFIQ0FZQUFBREVVbGZUQUFBQVFVbEVRVlFJbVkzTm9RMkFNQUJFMFpld0FCTXlHUTZtcVdPRHpsQWNsQlNGTzhIWmw4dWYwRkZ4Q0h0d1lrdDRZNkNoWUU0NGNHSDkvZnlhZTJwMkxBbGVXOW9WVFF1VmY2Z0FBQUFBU1VWT1JLNUNZSUk9KSc7bWVudWl0ZW0uc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0nbm8tcmVwZWF0JzttZW51aXRlbS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249Jzk3JSBjZW50ZXInO31cbmlmKG1lbnVpdGVtc1tpXVsxXSl7aWYobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcil7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKGUpe1JHLkhpZGVDb250ZXh0U3VibWVudSgpO2UudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvcj0ncmdiYSgwLDAsMCwwLjIpJztlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO21lbnVpdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvcj0naW5oZXJpdCc7ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9LGZhbHNlKTt9ZWxzZXttZW51aXRlbS5hdHRhY2hFdmVudChcIm9ubW91c2VvdmVyXCIsZnVuY3Rpb24oKXtSRy5IaWRlQ29udGV4dFN1Ym1lbnUoKTtldmVudC5zcmNFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvcj0nI2VlZSc7ZXZlbnQuc3JjRWxlbWVudC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO21lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW91dFwiLGZ1bmN0aW9uKCl7ZXZlbnQuc3JjRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J2luaGVyaXQnO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9LGZhbHNlKTt9fWVsc2V7aWYobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcil7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0nZGVmYXVsdCc7fSxmYWxzZSk7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9LGZhbHNlKTt9ZWxzZXttZW51aXRlbS5hdHRhY2hFdmVudChcIm9ubW91c2VvdmVyXCIsZnVuY3Rpb24oKXtldmVudC5zcmNFbGVtZW50LnN0eWxlLmN1cnNvcj0nZGVmYXVsdCd9LGZhbHNlKTttZW51aXRlbS5hdHRhY2hFdmVudChcIm9ubW91c2VvdXRcIixmdW5jdGlvbigpe2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9LGZhbHNlKTt9fX1lbHNle21lbnVpdGVtLnN0eWxlLmJvcmRlckJvdHRvbT0nMXB4IHNvbGlkICNkZGQnO21lbnVpdGVtLnN0eWxlLm1hcmdpbkxlZnQ9JzI1cHgnO31cbmRpdi5hcHBlbmRDaGlsZChtZW51aXRlbSk7aWYobWVudWl0ZW1zW2ldJiZtZW51aXRlbXNbaV1bMV0mJnR5cGVvZihtZW51aXRlbXNbaV1bMV0pPT0nZnVuY3Rpb24nKXttZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsbWVudWl0ZW1zW2ldWzFdLGZhbHNlKTt9ZWxzZSBpZihtZW51aXRlbXNbaV0mJm1lbnVpdGVtc1tpXVsxXSYmUkcuaXNfYXJyYXkobWVudWl0ZW1zW2ldWzFdKSl7KGZ1bmN0aW9uKClcbnt2YXIgdG1wPW1lbnVpdGVtc1tpXVsxXTttZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLGZ1bmN0aW9uKGUpe1JHLkNvbnRleHRtZW51X3N1Ym1lbnUob2JqLHRtcCxlLnRhcmdldCk7fSxmYWxzZSk7fSkoKTt9fVxuZGl2LnN0eWxlLndpZHRoPShkaXYub2Zmc2V0V2lkdGgrMTApKydweCc7ZGl2LnN0eWxlLmhlaWdodD0oZGl2Lm9mZnNldEhlaWdodC0yKSsncHgnO2lmKHgrZGl2Lm9mZnNldFdpZHRoPmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpe3gtPWRpdi5vZmZzZXRXaWR0aDt9XG5kaXYuc3R5bGUubGVmdD14KydweCc7ZGl2LnN0eWxlLnRvcD15KydweCc7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSBvYmouc3R5bGUub3BhY2l0eSA9IDAuMlwiLDUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC40XCIsMTAwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC42XCIsMTUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC44XCIsMjAwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMVwiLDI1MCk7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudS5iZycpKSBvYmouc3R5bGUub3BhY2l0eSA9IDAuMlwiLDUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC40XCIsMTAwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC42XCIsMTUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC44XCIsMjAwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMVwiLDI1MCk7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudScsZGl2KTtSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJyxiZyk7UkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpLm9uY29udGV4dG1lbnU9ZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2U7fTtSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykub25jb250ZXh0bWVudT1mdW5jdGlvbigpe3JldHVybiBmYWxzZTt9O2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKXtSRy5IaWRlQ29udGV4dCgpO30sZmFsc2UpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKVxue1JHLkhpZGVDb250ZXh0KCk7fSxmYWxzZSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsZnVuY3Rpb24oKVxue1JHLkhpZGVDb250ZXh0KCk7fSxmYWxzZSk7aWYodHlwZW9mKG9iai5nZXRTaGFwZSk9PSdmdW5jdGlvbicpe1JHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUnKS5fX3NoYXBlX189b2JqLmdldFNoYXBlKGUpO31cbmUuc3RvcFByb3BhZ2F0aW9uKCk7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25jb250ZXh0bWVudScpO3JldHVybiBmYWxzZTt9O1JHLmhpZGVDb250ZXh0PVJHLkhpZGVDb250ZXh0PWZ1bmN0aW9uKClcbnt2YXIgY209UkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpO3ZhciBjbWJnPVJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUuYmcnKTtSRy5IaWRlQ29udGV4dFN1Ym1lbnUoKTtpZihjbSl7Y20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbSk7Y21iZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtYmcpO2NtLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbic7Y20uc3R5bGUuZGlzcGxheT0nbm9uZSc7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudScsbnVsbCk7Y21iZy5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nO2NtYmcuc3R5bGUuZGlzcGxheT0nbm9uZSc7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudS5iZycsbnVsbCk7fX07UkcuaGlkZUNvbnRleHRTdWJtZW51PVJHLkhpZGVDb250ZXh0U3VibWVudT1mdW5jdGlvbigpXG57dmFyIHN1Yj1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LnN1Ym1lbnUnKTtpZihzdWIpe3N1Yi5zdHlsZS52aXNpYmlsaXR5PSdub25lJztzdWIuc3R5bGUuZGlzcGxheT0nbm9uZSc7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudS5zdWJtZW51JyxudWxsKTt9fTtSRy5zaG93Q29udGV4dD1SRy5TaG93Q29udGV4dD1mdW5jdGlvbihvYmopXG57UkcuSGlkZVBhbGV0dGUoKTtpZihvYmouR2V0KCdjaGFydC5jb250ZXh0bWVudScpJiZvYmouR2V0KCdjaGFydC5jb250ZXh0bWVudScpLmxlbmd0aCl7dmFyIGlzT3BlcmE9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPcGVyYScpPj0wO3ZhciBpc1NhZmFyaT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpPj0wO3ZhciBpc0Nocm9tZT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpPj0wO3ZhciBpc01hY0ZpcmVmb3g9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+MCYmbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNYWMnKT4wO3ZhciBpc0lFOT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgOScpPj0wO2lmKCgoIWlzT3BlcmEmJiFpc1NhZmFyaSl8fGlzQ2hyb21lKSYmIWlzTWFjRmlyZWZveCl7b2JqLmNhbnZhcy5vbmNvbnRleHRtZW51PWZ1bmN0aW9uKGUpXG57ZT1SRy5GaXhFdmVudE9iamVjdChlKTtpZihlLmN0cmxLZXkpcmV0dXJuIHRydWU7UkcuQ29udGV4dG1lbnUob2JqLG9iai5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JyksZSk7cmV0dXJuIGZhbHNlO319ZWxzZXtvYmouY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJyxmdW5jdGlvbihlKVxue2lmKGUuY3RybEtleSlyZXR1cm4gdHJ1ZTtpZighUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKXtSRy5Db250ZXh0bWVudShvYmosb2JqLkdldCgnY2hhcnQuY29udGV4dG1lbnUnKSxlKTt9fSxmYWxzZSk7fX19O1JHLmNvbnRleHRtZW51X3N1Ym1lbnU9UkcuQ29udGV4dG1lbnVfc3VibWVudT1mdW5jdGlvbihvYmosbWVudWl0ZW1zLHBhcmVudE1lbnVJdGVtKVxue1JHLkhpZGVDb250ZXh0U3VibWVudSgpO3ZhciBjYW52YXM9b2JqLmNhbnZhczt2YXIgY29udGV4dD1vYmouY29udGV4dDt2YXIgbWVudT1wYXJlbnRNZW51SXRlbS5wYXJlbnROb2RlO3ZhciBzdWJNZW51PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO3N1Yk1lbnUuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztzdWJNZW51LnN0eWxlLndpZHRoPScxMDBweCc7c3ViTWVudS5zdHlsZS50b3A9bWVudS5vZmZzZXRUb3ArcGFyZW50TWVudUl0ZW0ub2Zmc2V0VG9wKydweCc7c3ViTWVudS5zdHlsZS5sZWZ0PShtZW51Lm9mZnNldExlZnQrbWVudS5vZmZzZXRXaWR0aC0oUkcuSVNPTEQ/OTowKSkrJ3B4JztzdWJNZW51LnN0eWxlLmJhY2tncm91bmRDb2xvcj0nd2hpdGUnO3N1Yk1lbnUuc3R5bGUuYm9yZGVyPScxcHggc29saWQgYmxhY2snO3N1Yk1lbnUuY2xhc3NOYW1lPSdSR3JhcGhfY29udGV4dG1lbnUnO3N1Yk1lbnUuX19jb250ZXh0bWVudV9fPW1lbnU7c3ViTWVudS5zdHlsZS5ib3hTaGFkb3c9JzNweCAzcHggM3B4IHJnYmEoOTYsOTYsOTYsMC41KSc7c3ViTWVudS5zdHlsZS5Nb3pCb3hTaGFkb3c9JzNweCAzcHggM3B4IHJnYmEoOTYsOTYsOTYsMC41KSc7c3ViTWVudS5zdHlsZS5XZWJraXRCb3hTaGFkb3c9JzNweCAzcHggM3B4IHJnYmEoOTYsOTYsOTYsMC41KSc7c3ViTWVudS5zdHlsZS5maWx0ZXI9J3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5TaGFkb3coY29sb3I9I2FhYWFhYSxkaXJlY3Rpb249MTM1KSc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdWJNZW51KTtmb3IodmFyIGk9MDtpPG1lbnVpdGVtcy5sZW5ndGg7KytpKXt2YXIgbWVudWl0ZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7bWVudWl0ZW0uX19jYW52YXNfXz1jYW52YXM7bWVudWl0ZW0uX19jb250ZXh0bWVudV9fPW1lbnU7bWVudWl0ZW0uY2xhc3NOYW1lPSdSR3JhcGhfY29udGV4dG1lbnVfaXRlbSc7aWYobWVudWl0ZW1zW2ldKXttZW51aXRlbS5zdHlsZS5wYWRkaW5nPScycHggNXB4IDJweCAyM3B4JzttZW51aXRlbS5zdHlsZS5mb250RmFtaWx5PSdBcmlhbCc7bWVudWl0ZW0uc3R5bGUuZm9udFNpemU9JzEwcHQnO21lbnVpdGVtLnN0eWxlLmZvbnRXZWlnaHQ9J25vcm1hbCc7bWVudWl0ZW0uc3R5bGUudGV4dEFsaWduPSdsZWZ0JzttZW51aXRlbS5pbm5lckhUTUw9bWVudWl0ZW1zW2ldWzBdO2lmKG1lbnVpdGVtc1tpXVsxXSl7aWYobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcil7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvcj0ncmdiYSgwLDAsMCwwLjIpJztlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO21lbnVpdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvcj0naW5oZXJpdCc7ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9LGZhbHNlKTt9ZWxzZXttZW51aXRlbS5hdHRhY2hFdmVudChcIm9ubW91c2VvdmVyXCIsZnVuY3Rpb24oKXtldmVudC5zcmNFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvcj0ncmdiYSgwLDAsMCwwLjIpJztldmVudC5zcmNFbGVtZW50LnN0eWxlLmN1cnNvcj0ncG9pbnRlcid9LGZhbHNlKTttZW51aXRlbS5hdHRhY2hFdmVudChcIm9ubW91c2VvdXRcIixmdW5jdGlvbigpe2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yPSdpbmhlcml0JztldmVudC5zcmNFbGVtZW50LnN0eWxlLmN1cnNvcj0nZGVmYXVsdCc7fSxmYWxzZSk7fX1lbHNle2lmKG1lbnVpdGVtLmFkZEV2ZW50TGlzdGVuZXIpe21lbnVpdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixmdW5jdGlvbihlKXtlLnRhcmdldC5zdHlsZS5jdXJzb3I9J2RlZmF1bHQnO30sZmFsc2UpO21lbnVpdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGUpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0nZGVmYXVsdCc7fSxmYWxzZSk7fWVsc2V7bWVudWl0ZW0uYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3ZlclwiLGZ1bmN0aW9uKCl7ZXZlbnQuc3JjRWxlbWVudC5zdHlsZS5jdXJzb3I9J2RlZmF1bHQnfSxmYWxzZSk7bWVudWl0ZW0uYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtldmVudC5zcmNFbGVtZW50LnN0eWxlLmN1cnNvcj0nZGVmYXVsdCc7fSxmYWxzZSk7fX19ZWxzZXttZW51aXRlbS5zdHlsZS5ib3JkZXJCb3R0b209JzFweCBzb2xpZCAjZGRkJzttZW51aXRlbS5zdHlsZS5tYXJnaW5MZWZ0PScyNXB4Jzt9XG5zdWJNZW51LmFwcGVuZENoaWxkKG1lbnVpdGVtKTtpZihtZW51aXRlbXNbaV0mJm1lbnVpdGVtc1tpXVsxXSl7aWYoZG9jdW1lbnQuYWxsKXttZW51aXRlbS5hdHRhY2hFdmVudCgnb25jbGljaycsbWVudWl0ZW1zW2ldWzFdKTt9ZWxzZXttZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsbWVudWl0ZW1zW2ldWzFdLGZhbHNlKTt9fX1cbnZhciBiZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtiZy5jbGFzc05hbWU9J1JHcmFwaF9jb250ZXh0bWVudV9iYWNrZ3JvdW5kJztiZy5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2JnLnN0eWxlLmJhY2tncm91bmRDb2xvcj0nI2NjYyc7Ymcuc3R5bGUuYm9yZGVyUmlnaHQ9JzFweCBzb2xpZCAjYWFhJztiZy5zdHlsZS50b3A9MDtiZy5zdHlsZS5sZWZ0PTA7Ymcuc3R5bGUud2lkdGg9JzE4cHgnO2JnLnN0eWxlLmhlaWdodD0nMTAwJSc7Ymc9c3ViTWVudS5hcHBlbmRDaGlsZChiZyk7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudS5zdWJtZW51JyxzdWJNZW51KTt9O1JHLnNob3dQTkc9ZnVuY3Rpb24oKVxue2lmKFJHLklTSUU4KXthbGVydCgnW1JHUkFQSCBQTkddIFNvcnJ5LCBzaG93aW5nIGEgUE5HIGlzIG5vdCBzdXBwb3J0ZWQgb24gTVNJRTguJyk7cmV0dXJuO31cbmlmKGFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLmlkKXt2YXIgY2FudmFzPWFyZ3VtZW50c1swXTt2YXIgZXZlbnQ9YXJndW1lbnRzWzFdO31lbHNlIGlmKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUnKSl7dmFyIGNhbnZhcz1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykuX19jYW52YXNfXzt9ZWxzZXthbGVydCgnW1JHUkFQSCBTSE9XUE5HXSBDb3VsZCBub3QgZmluZCBjYW52YXMhJyk7fVxudmFyIG9iaj1jYW52YXMuX19vYmplY3RfXzt2YXIgYmc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7YmcuaWQ9J19fcmdyYXBoX2ltYWdlX2JnX18nO2JnLnN0eWxlLnBvc2l0aW9uPSdmaXhlZCc7Ymcuc3R5bGUudG9wPSctMTBweCc7Ymcuc3R5bGUubGVmdD0nLTEwcHgnO2JnLnN0eWxlLndpZHRoPSc1MDAwcHgnO2JnLnN0eWxlLmhlaWdodD0nNTAwMHB4JztiZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J3JnYigyMDQsMjA0LDIwNCknO2JnLnN0eWxlLm9wYWNpdHk9MDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJnKTt2YXIgZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J3doaXRlJztkaXYuc3R5bGUub3BhY2l0eT0wO2Rpdi5zdHlsZS5ib3JkZXI9JzFweCBzb2xpZCBibGFjayc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdmaXhlZCc7ZGl2LnN0eWxlLnRvcD0nMjAlJztkaXYuc3R5bGUud2lkdGg9Y2FudmFzLndpZHRoKydweCc7ZGl2LnN0eWxlLmhlaWdodD1jYW52YXMuaGVpZ2h0KzM1KydweCc7ZGl2LnN0eWxlLmxlZnQ9KGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgvMiktKGNhbnZhcy53aWR0aC8yKSsncHgnO2Rpdi5zdHlsZS5wYWRkaW5nPSc1cHgnO2Rpdi5zdHlsZS5ib3JkZXJSYWRpdXM9JzEwcHgnO2Rpdi5zdHlsZS5Nb3pCb3JkZXJSYWRpdXM9JzEwcHgnO2Rpdi5zdHlsZS5XZWJraXRCb3JkZXJSYWRpdXM9JzEwcHgnO2Rpdi5zdHlsZS5ib3hTaGFkb3c9JzAgMCAxNXB4IHJnYmEoOTYsOTYsOTYsMC41KSc7ZGl2LnN0eWxlLk1vekJveFNoYWRvdz0nMCAwIDE1cHggcmdiYSg5Niw5Niw5NiwwLjUpJztkaXYuc3R5bGUuV2Via2l0Qm94U2hhZG93PSdyZ2JhKDk2LDk2LDk2LDAuNSkgMCAwIDE1cHgnO2Rpdi5fX2NhbnZhc19fPWNhbnZhcztkaXYuX19vYmplY3RfXz1vYmo7ZGl2LmlkPSdfX3JncmFwaF9pbWFnZV9kaXZfXyc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO2Rpdi5pbm5lckhUTUwrPSc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBtYXJnaW4tbGVmdDogMTBweDsgdG9wOiAnK2NhbnZhcy5oZWlnaHQrJ3B4OyB3aWR0aDogJysoY2FudmFzLndpZHRoLTUwKSsncHg7IGhlaWdodDogMjVweFwiPjxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMnB0O2Rpc3BsYXk6IGlubGluZTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogNjVweDsgdGV4dC1hbGlnbjogcmlnaHRcIj5VUkw6PC9zcGFuPjx0ZXh0YXJlYSBzdHlsZT1cImZsb2F0OiByaWdodDsgb3ZlcmZsb3c6IGhpZGRlbjsgaGVpZ2h0OiAyMHB4OyB3aWR0aDogJysoY2FudmFzLndpZHRoLW9iai5ndXR0ZXJMZWZ0LW9iai5ndXR0ZXJSaWdodC04MCkrJ3B4XCIgb25jbGljaz1cInRoaXMuc2VsZWN0KClcIiByZWFkb25seT1cInJlYWRvbmx5XCIgaWQ9XCJfX3JncmFwaF9kYXRhdXJsX19cIj4nK2NhbnZhcy50b0RhdGFVUkwoKSsnPC90ZXh0YXJlYT48L2Rpdj4nO2Rpdi5pbm5lckhUTUwrPSc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcrKGNhbnZhcy5oZWlnaHQrMjUpKydweDsgbGVmdDogJysob2JqLmd1dHRlckxlZnQtNjUrKGNhbnZhcy53aWR0aC8yKSkrJ3B4OyB3aWR0aDogJysoY2FudmFzLndpZHRoLW9iai5ndXR0ZXJSaWdodCkrJ3B4OyBmb250LXNpemU6IDY1JVwiPkEgbGluayB1c2luZyB0aGUgVVJMOiA8YSBocmVmPVwiJytjYW52YXMudG9EYXRhVVJMKCkrJ1wiPlZpZXc8L2E+PC9kaXY+J1xudmFyIGltZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTUcnKTtSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LnBuZycsaW1nKTtpbWcuX19jYW52YXNfXz1jYW52YXM7aW1nLl9fb2JqZWN0X189b2JqO2ltZy5pZD0nX19yZ3JhcGhfaW1hZ2VfaW1nX18nO2ltZy5jbGFzc05hbWU9J1JHcmFwaF9wbmcnO2ltZy5zcmM9Y2FudmFzLnRvRGF0YVVSTCgpO2Rpdi5hcHBlbmRDaGlsZChpbWcpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fcmdyYXBoX2RhdGF1cmxfX1wiKS5zZWxlY3QoKTt9LDUwKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJyxmdW5jdGlvbihlKXt2YXIgaW1nPVJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQucG5nJyk7aW1nLnN0eWxlLmxlZnQ9KGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgvMiktKGltZy53aWR0aC8yKSsncHgnO30sZmFsc2UpO2JnLm9uY2xpY2s9ZnVuY3Rpb24oZSlcbnt2YXIgZGl2PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19yZ3JhcGhfaW1hZ2VfZGl2X19cIik7dmFyIGJnPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19yZ3JhcGhfaW1hZ2VfYmdfX1wiKTtpZihkaXYpe2Rpdi5zdHlsZS5vcGFjaXR5PTA7ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtkaXYuaWQ9Jyc7ZGl2LnN0eWxlLmRpc3BsYXk9J25vbmUnO2Rpdj1udWxsO31cbmlmKGJnKXtiZy5zdHlsZS5vcGFjaXR5PTA7YmcuaWQ9Jyc7Ymcuc3R5bGUuZGlzcGxheT0nbm9uZSc7Ymc9bnVsbDt9fVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsZnVuY3Rpb24oZSl7Ymcub25jbGljayhlKTt9LGZhbHNlKVxuUkcuc2hvd3BuZ19pbWFnZV9iZz1iZztSRy5zaG93cG5nX2ltYWdlX2Rpdj1kaXY7c2V0VGltZW91dCgnUkdyYXBoLnNob3dwbmdfaW1hZ2VfZGl2LnN0eWxlLm9wYWNpdHkgPSAwLjInLDUwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9kaXYuc3R5bGUub3BhY2l0eSA9IDAuNCcsMTAwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9kaXYuc3R5bGUub3BhY2l0eSA9IDAuNicsMTUwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9kaXYuc3R5bGUub3BhY2l0eSA9IDAuOCcsMjAwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9kaXYuc3R5bGUub3BhY2l0eSA9IDEnLDI1MCk7c2V0VGltZW91dCgnUkdyYXBoLnNob3dwbmdfaW1hZ2VfYmcuc3R5bGUub3BhY2l0eSA9IDAuMScsNTApO3NldFRpbWVvdXQoJ1JHcmFwaC5zaG93cG5nX2ltYWdlX2JnLnN0eWxlLm9wYWNpdHkgPSAwLjInLDEwMCk7c2V0VGltZW91dCgnUkdyYXBoLnNob3dwbmdfaW1hZ2VfYmcuc3R5bGUub3BhY2l0eSA9IDAuMycsMTUwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9iZy5zdHlsZS5vcGFjaXR5ID0gMC40JywyMDApO3NldFRpbWVvdXQoJ1JHcmFwaC5zaG93cG5nX2ltYWdlX2JnLnN0eWxlLm9wYWNpdHkgPSAwLjUnLDI1MCk7aW1nLm9uY2xpY2s9ZnVuY3Rpb24oZSlcbntpZihlLnN0b3BQcm9wYWdhdGlvbillLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgZXZlbnQuY2FuY2VsQnViYmxlPXRydWU7fVxuaWYoZXZlbnQmJmV2ZW50LnN0b3BQcm9wYWdhdGlvbil7ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7fX07fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uY29udGV4dC5qcyJdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///195\n");

/***/ }),
/* 196 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Highlight = {};RG.Registry = {};RG.Registry.store = [];RG.Registry.store['chart.event.handlers'] = [];RG.Registry.store['__rgraph_event_listeners__'] = [];RG.Background = {};RG.background = {};RG.objects = [];RG.Resizing = {};RG.events = [];RG.cursor = [];RG.Effects = RG.Effects || {};RG.cache = [];RG.ObjectRegistry = {};RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];RG.OR = RG.ObjectRegistry;RG.PI = ma.PI;RG.HALFPI = RG.PI / 2;RG.TWOPI = RG.PI * 2;RG.ISFF = ua.indexOf('Firefox') != -1;RG.ISOPERA = ua.indexOf('Opera') != -1;RG.ISCHROME = ua.indexOf('Chrome') != -1;RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.ISOLD = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8;RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;RG.ISIE9UP = RG.ISIE9 || RG.ISIE10UP;RG.getScale = function (max, obj) {\n    if (max == 0) {\n      return ['0.2', '0.4', '0.6', '0.8', '1.0'];\n    }\n    var original_max = max;if (max <= 1) {\n      if (max > 0.5) {\n        return [0.2, 0.4, 0.6, 0.8, Number(1).toFixed(1)];\n      } else if (max >= 0.1) {\n        return obj.Get('chart.scale.round') ? [0.2, 0.4, 0.6, 0.8, 1] : [0.1, 0.2, 0.3, 0.4, 0.5];\n      } else {\n        var tmp = max;var exp = 0;while (tmp < 1.01) {\n          exp += 1;tmp *= 10;\n        }\n        var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];if (max <= '5e-' + exp) {\n          ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\n        }\n        return ret;\n      }\n    }\n    if (String(max).indexOf('.') > 0) {\n      max = String(max).replace(/\\.\\d+$/, '');\n    }\n    var interval = ma.pow(10, Number(String(Number(max)).length - 1));var topValue = interval;while (topValue < max) {\n      topValue += interval / 2;\n    }\n    if (Number(original_max) > Number(topValue)) {\n      topValue += interval / 2;\n    }\n    if (max < 10) {\n      topValue = Number(original_max) <= 5 ? 5 : 10;\n    }\n    if (obj && typeof obj.Get('chart.scale.round') == 'boolean' && obj.Get('chart.scale.round')) {\n      topValue = 10 * interval;\n    }\n    return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\n  };RG.getScale2 = function (obj, opt) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        numlabels = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,\n        units_pre = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',\n        units_post = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',\n        max = Number(opt['max']),\n        min = typeof opt['min'] == 'number' ? opt['min'] : 0,\n        strict = opt['strict'],\n        decimals = Number(opt['scale.decimals']),\n        point = opt['scale.point'],\n        thousand = opt['scale.thousand'],\n        original_max = max,\n        round = opt['scale.round'],\n        scale = { max: 1, labels: [], values: [] };\n    if (!max) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = (((max - min) / numlabels + min) * (i + 1)).toFixed(decimals);scale.labels.push(units_pre + label + units_post);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(original_max) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(original_max) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;var tmp_point = prop['chart.scale.point'];var tmp_thousand = prop['chart.scale.thousand'];obj.Set('chart.scale.thousand', thousand);obj.Set('chart.scale.point', point);for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.number_format(obj, ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n      obj.Set('chart.scale.thousand', tmp_thousand);obj.Set('chart.scale.point', tmp_point);\n    } else if (typeof max == 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.numberFormat(obj, ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.units_pre = units_pre;scale.units_post = units_post;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.arrayReverse(out2);return out2;\n  };RG.arrayClone = RG.array_clone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n      if (typeof obj[i] === 'number') {\n        temp[i] = function (arg) {\n          return Number(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'string') {\n        temp[i] = function (arg) {\n          return String(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'function') {\n        temp[i] = obj[i];\n      } else {\n        temp[i] = RG.arrayClone(obj[i]);\n      }\n    }\n    return temp;\n  };RG.arrayMax = RG.array_max = function (arr) {\n    var max = null,\n        ma = Math;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.arrayPad = RG.array_pad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.arraySum = RG.array_sum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.is_null(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.arrayLinearize = RG.array_linearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.array_linearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.arrayShift = RG.array_shift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.arrayReverse = RG.array_reverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.clear = RG.Clear = function (ca) {\n    var obj = ca.__object__,\n        co = ca.getContext('2d'),\n        color = arguments[1] || obj && obj.get('clearto');\n    if (!ca) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforeclear');if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {\n      for (var i in RG.text2.domNodeCache[ca.id]) {\n        var el = RG.text2.domNodeCache[ca.id][i];if (el && el.style) {\n          el.style.display = 'none';\n        }\n      }\n    }\n    if (!color || color && color === 'rgba(0,0,0,0)' || color === 'transparent') {\n      co.clearRect(-100, -100, ca.width + 200, ca.height + 200);co.globalCompositeOperation = 'source-over';\n    } else if (color) {\n      RG.path2(co, 'fs % fr -100 -100 % %', color, ca.width + 200, ca.height + 200);\n    } else {\n      RG.path2(co, 'fs % fr -100 -100 % %', obj.get('clearto'), ca.width + 200, ca.height + 200);\n    }\n    if (RG.Registry.Get('chart.background.image.' + ca.id)) {\n      var img = RG.Registry.Get('chart.background.image.' + ca.id);img.style.position = 'absolute';img.style.left = '-10000px';img.style.top = '-10000px';\n    }\n    if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {\n      RG.HideTooltip(ca);\n    }\n    ca.style.cursor = 'default';RG.FireCustomEvent(obj, 'onclear');\n  };RG.drawTitle = RG.DrawTitle = function (obj, text, gutterTop) {\n    var ca = canvas = obj.canvas,\n        co = context = obj.context,\n        prop = obj.properties;\n    gutterLeft = prop['chart.gutter.left'], gutterRight = prop['chart.gutter.right'], gutterTop = gutterTop, gutterBottom = prop['chart.gutter.bottom'], size = arguments[4] ? arguments[4] : 12, bold = prop['chart.title.bold'], italic = prop['chart.title.italic'], centerx = arguments[3] ? arguments[3] : (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft, keypos = prop['chart.key.position'], vpos = prop['chart.title.vpos'], hpos = prop['chart.title.hpos'], bgcolor = prop['chart.title.background'], x = prop['chart.title.x'], y = prop['chart.title.y'], halign = 'center', valign = 'center';\n    if (obj.type == 'bar' && prop['chart.variant'] == '3d') {\n      keypos = 'gutter';\n    }\n    co.beginPath();co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';if (keypos && keypos != 'gutter') {\n      var valign = 'center';\n    } else if (!keypos) {\n      var valign = 'center';\n    } else {\n      var valign = 'bottom';\n    }\n    if (typeof prop['chart.title.vpos'] === 'number') {\n      vpos = prop['chart.title.vpos'] * gutterTop;if (prop['chart.xaxispos'] === 'top') {\n        vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);\n      }\n    } else {\n      vpos = gutterTop - size - 5;if (prop['chart.xaxispos'] === 'top') {\n        vpos = ca.height - gutterBottom + size + 5;\n      }\n    }\n    if (typeof hpos === 'number') {\n      centerx = hpos * ca.width;\n    }\n    if (typeof x === 'number') centerx = x;if (typeof y === 'number') vpos = y;if (typeof prop['chart.title.halign'] === 'string') {\n      halign = prop['chart.title.halign'];\n    }\n    if (typeof prop['chart.title.valign'] === 'string') {\n      valign = prop['chart.title.valign'];\n    }\n    if (typeof prop['chart.title.color'] !== null) {\n      var oldColor = co.fillStyle;\n      var newColor = prop['chart.title.color'];co.fillStyle = newColor ? newColor : 'black';\n    }\n    var font = prop['chart.text.font'];if (typeof prop['chart.title.font'] === 'string') {\n      font = prop['chart.title.font'];\n    }\n    var ret = RG.text2(obj, { font: font, size: size, x: centerx, y: vpos, text: text, valign: valign, halign: halign, bounding: bgcolor != null, 'bounding.fill': bgcolor, 'bold': bold, italic: italic, tag: 'title', marker: false });co.fillStyle = oldColor;\n  };RG.getMouseXY = function (e) {\n    if (!e.target) {\n      return;\n    }\n    var el = e.target;var ca = el;var caStyle = ca.style;var offsetX = 0;var offsetY = 0;var x;var y;var borderLeft = parseInt(caStyle.borderLeftWidth) || 0;var borderTop = parseInt(caStyle.borderTopWidth) || 0;var paddingLeft = parseInt(caStyle.paddingLeft) || 0;\n    var paddingTop = parseInt(caStyle.paddingTop) || 0;\n    var additionalX = borderLeft + paddingLeft;var additionalY = borderTop + paddingTop;if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\n      if (!RG.ISIE && !RG.ISOPERA) {\n        x = e.offsetX - borderLeft - paddingLeft;y = e.offsetY - borderTop - paddingTop;\n      } else if (RG.ISIE) {\n        x = e.offsetX - paddingLeft;y = e.offsetY - paddingTop;\n      } else {\n        x = e.offsetX;y = e.offsetY;\n      }\n    } else {\n      if (typeof el.offsetParent !== 'undefined') {\n        do {\n          offsetX += el.offsetLeft;offsetY += el.offsetTop;\n        } while (el = el.offsetParent);\n      }\n      x = e.pageX - offsetX - additionalX;y = e.pageY - offsetY - additionalY;x -= 2 * (parseInt(document.body.style.borderLeftWidth) || 0);y -= 2 * (parseInt(document.body.style.borderTopWidth) || 0);\n    }\n    return [x, y];\n  };RG.getCanvasXY = function (canvas) {\n    var x = 0;var y = 0;var el = canvas;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName.toLowerCase() != 'body');var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;var paddingTop = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;var borderLeft = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;var borderTop = canvas.style.borderTopWidth ? parseInt(canvas.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.isFixed = function (canvas) {\n    var obj = canvas;var i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position == 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.register = RG.Register = function (obj) {\n    if (!obj.Get('chart.noregister')) {\n      RGraph.ObjectRegistry.Add(obj);obj.Set('chart.noregister', true);\n    }\n  };RG.redraw = RG.Redraw = function () {\n    var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;var tags = document.getElementsByTagName('canvas');for (var i = 0, len = tags.length; i < len; ++i) {\n      if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n        if (!tags[i].noclear) {\n          RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);\n        }\n      }\n    }\n    for (var i = 0, len = objectRegistry.length; i < len; ++i) {\n      if (objectRegistry[i]) {\n        var id = objectRegistry[i][0];objectRegistry[i][1].Draw();\n      }\n    }\n  };RG.redrawCanvas = RG.RedrawCanvas = function (ca) {\n    var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);if (!arguments[1] || typeof arguments[1] === 'boolean' && !arguments[1] == false) {\n      var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';RG.clear(ca, color);\n    }\n    for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        if (objects[i] && objects[i].isRGraph) {\n          objects[i].Draw();\n        }\n      }\n    }\n  };RG.Background.draw = RG.background.draw = RG.background.Draw = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        height = 0,\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        variant = prop['chart.variant'];\n    co.fillStyle = prop['chart.text.color'];if (variant == '3d') {\n      co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n    }\n    if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var bold = prop['chart.title.xaxis.bold'];if (typeof prop['chart.title.xaxis.size'] == 'number') {\n        size = prop['chart.title.xaxis.size'];\n      }\n      if (typeof prop['chart.title.xaxis.font'] == 'string') {\n        font = prop['chart.title.xaxis.font'];\n      }\n      var hpos = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;var vpos = ca.height - gutterBottom + 25;if (typeof prop['chart.title.xaxis.pos'] === 'number') {\n        vpos = ca.height - gutterBottom * prop['chart.title.xaxis.pos'];\n      }\n      if (typeof prop['chart.title.xaxis.x'] === 'number') {\n        hpos = prop['chart.title.xaxis.x'];\n      }\n      if (typeof prop['chart.title.xaxis.y'] === 'number') {\n        vpos = prop['chart.title.xaxis.y'];\n      }\n      RG.text2(prop['chart.text.accessible'] ? obj.context : co, { font: font, size: size, x: hpos, y: vpos, text: prop['chart.title.xaxis'], halign: 'center', valign: 'center', bold: bold, color: prop['chart.title.xaxis.color'] || 'black', tag: 'title xaxis' });\n    }\n    if (typeof prop['chart.title.yaxis'] == 'string' && prop['chart.title.yaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var angle = 270;var bold = prop['chart.title.yaxis.bold'];var color = prop['chart.title.yaxis.color'];if (typeof prop['chart.title.yaxis.pos'] == 'number') {\n        var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;\n      } else {\n        var yaxis_title_pos = (gutterLeft - 25) / gutterLeft * gutterLeft;\n      }\n      if (typeof prop['chart.title.yaxis.size'] === 'number') {\n        size = prop['chart.title.yaxis.size'];\n      }\n      if (typeof prop['chart.title.yaxis.font'] === 'string') {\n        font = prop['chart.title.yaxis.font'];\n      }\n      if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined') {\n        angle = 90;yaxis_title_pos = prop['chart.title.yaxis.pos'] ? ca.width - gutterRight + prop['chart.title.yaxis.pos'] * gutterRight : ca.width - gutterRight + prop['chart.text.size'] + 5;\n      } else {\n        yaxis_title_pos = yaxis_title_pos;\n      }\n      var y = (ca.height - gutterTop - gutterBottom) / 2 + gutterTop;if (typeof prop['chart.title.yaxis.x'] === 'number') {\n        yaxis_title_pos = prop['chart.title.yaxis.x'];\n      }\n      if (typeof prop['chart.title.yaxis.y'] === 'number') {\n        y = prop['chart.title.yaxis.y'];\n      }\n      co.fillStyle = color;RG.text2(prop['chart.text.accessible'] ? obj.context : co, { 'font': font, 'size': size, 'x': yaxis_title_pos, 'y': y, 'valign': 'center', 'halign': 'center', 'angle': angle, 'bold': bold, 'text': prop['chart.title.yaxis'], 'tag': 'title yaxis', accessible: false });\n    }\n    var bgcolor = prop['chart.background.color'];if (bgcolor) {\n      co.fillStyle = bgcolor;co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n    }\n    var numbars = prop['chart.ylabels.count'] || 5;var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;co.beginPath();co.fillStyle = prop['chart.background.barcolor1'];co.strokeStyle = co.fillStyle;height = ca.height - gutterBottom;for (var i = 0; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();co.fillStyle = prop['chart.background.barcolor2'];co.strokeStyle = co.fillStyle;for (var i = 1; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();var func = function func(obj, cacheCanvas, cacheContext) {\n      if (prop['chart.background.grid']) {\n        prop['chart.background.grid.autofit.numhlines'] += 0.0001;if (prop['chart.background.grid.autofit']) {\n          if (prop['chart.background.grid.autofit.align']) {\n            if (obj.type === 'hbar') {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n            if (obj.type === 'line') {\n              if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {} else if (prop['chart.labels'] && prop['chart.labels'].length) {\n                obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);\n              } else {\n                obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);\n              }\n            } else if (obj.type === 'waterfall') {\n              obj.set('backgroundGridAutofitNumvlines', obj.data.length + (prop['chart.total'] ? 1 : 0));\n            } else if ((obj.type === 'bar' || obj.type === 'scatter') && (prop['chart.labels'] && prop['chart.labels'].length || obj.type === 'bar')) {\n              var len = prop['chart.labels'] && prop['chart.labels'].length || obj.data.length;obj.set({ backgroundGridAutofitNumvlines: len });\n            } else if (obj.type === 'gantt') {\n              if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {} else {\n                obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);\n              }\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines'])) {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n          }\n          var vsize = (cacheCanvas.width - gutterLeft - gutterRight) / prop['chart.background.grid.autofit.numvlines'];var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];obj.Set('chart.background.grid.vsize', vsize);obj.Set('chart.background.grid.hsize', hsize);\n        }\n        co.beginPath();cacheContext.lineWidth = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;cacheContext.strokeStyle = prop['chart.background.grid.color'];if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([3, 5]);\n        }\n        if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([1, 3]);\n        }\n        co.beginPath();if (prop['chart.background.grid.hlines']) {\n          height = cacheCanvas.height - gutterBottom;\n          var hsize = prop['chart.background.grid.hsize'];for (y = gutterTop; y <= height; y += hsize) {\n            cacheContext.moveTo(gutterLeft, ma.round(y));cacheContext.lineTo(ca.width - gutterRight, ma.round(y));\n          }\n        }\n        if (prop['chart.background.grid.vlines']) {\n          var width = cacheCanvas.width - gutterRight;var vsize = prop['chart.background.grid.vsize'];for (x = gutterLeft; ma.round(x) <= width; x += vsize) {\n            cacheContext.moveTo(ma.round(x), gutterTop);cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);\n          }\n        }\n        if (prop['chart.background.grid.border']) {\n          cacheContext.strokeStyle = prop['chart.background.grid.color'];cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n        }\n      }\n      cacheContext.stroke();cacheContext.beginPath();cacheContext.closePath();\n    };\n    RG.cachedDraw(obj, obj.uid + '_background', func);if (variant == '3d') {\n      co.restore();\n    }\n    if (typeof co.setLineDash == 'function') {\n      co.setLineDash([1, 0]);\n    }\n    co.stroke();if (typeof obj.properties['chart.title'] == 'string') {\n      var prop = obj.properties;RG.drawTitle(obj, prop['chart.title'], obj.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2, obj);\n    }\n  };RG.numberFormat = RG.number_format = function (obj, num) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var i;var prepend = arguments[2] ? String(arguments[2]) : '';var append = arguments[3] ? String(arguments[3]) : '';var output = '';var decimal = '';var decimal_seperator = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';RegExp.$1 = '';var i, j;if (typeof prop['chart.scale.formatter'] === 'function') {\n      return prop['chart.scale.formatter'](obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {\n      output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.drawBars = RG.DrawBars = function (obj) {\n    var prop = obj.properties;var co = obj.context;var ca = obj.canvas;var hbars = prop['chart.background.hbars'];if (hbars === null) {\n      return;\n    }\n    co.beginPath();for (i = 0, len = hbars.length; i < len; ++i) {\n      var start = hbars[i][0];var length = hbars[i][1];var color = hbars[i][2];if (RG.is_null(start)) start = obj.scale2.max;\n      if (start > obj.scale2.max) start = obj.scale2.max;if (RG.is_null(length)) length = obj.scale2.max - start;if (start + length > obj.scale2.max) length = obj.scale2.max - start;if (start + length < -1 * obj.scale2.max) length = -1 * obj.scale2.max - start;if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < obj.scale2.max * -2) {\n        length = obj.scale2.max * -2;\n      }\n      var x = prop['chart.gutter.left'];var y = obj.getYCoord(start);var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var h = obj.getYCoord(start + length) - y;if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {\n        h *= -1;y = y - h;\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        y = ca.height - y;h *= -1;\n      }\n      co.fillStyle = color;co.fillRect(x, y, w, h);\n    }\n  };RG.drawInGraphLabels = RG.DrawInGraphLabels = function (obj) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var labels = prop['chart.labels.ingraph'];var labels_processed = [];var fgcolor = 'black';var bgcolor = 'white';var direction = 1;if (!labels) {\n      return;\n    }\n    for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] === 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] === 'string' || _typeof(labels[i]) === 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.noShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      for (var i = 0, len = labels_processed.length; i < len; i += 1) {\n        if (labels_processed[i]) {\n          var coords = obj.coords[i];if (coords && coords.length > 0) {\n            var x = obj.type == 'bar' ? coords[0] + coords[2] / 2 : coords[0];var y = obj.type == 'bar' ? coords[1] + coords[3] / 2 : coords[1];var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;co.beginPath();co.fillStyle = 'black';co.strokeStyle = 'black';if (obj.type === 'bar') {\n              if (obj.Get('chart.xaxispos') == 'top') {\n                length *= -1;\n              }\n              if (prop['chart.variant'] == 'dot') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else if (prop['chart.variant'] == 'arrow') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else {\n                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y - length);var text_x = ma.round(x);var text_y = y - length;\n              }\n              co.stroke();co.fill();\n            } else {\n              if (_typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][3] == 'number' && labels_processed[i][3] == -1) {\n                co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x), y + 5 + length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x) - 3, y + 10);co.lineTo(ma.round(x) + 3, y + 10);co.closePath();var text_x = x;var text_y = y + 5 + length;\n              } else {\n                var text_x = x;var text_y = y - 5 - length;co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x), y - 5 - length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x) - 3, y - 10);co.lineTo(ma.round(x) + 3, y - 10);co.closePath();\n              }\n              co.fill();\n            }\n            co.beginPath();co.fillStyle = _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][1] === 'string' ? labels_processed[i][1] : 'black';RG.text2(obj, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': text_x, 'y': text_y + (obj.properties['chart.text.accessible'] ? 2 : 0), 'text': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][0] === 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][2] === 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels ingraph' });co.fill();\n          }\n        }\n      }\n    }\n  };RG.fixEventObject = RG.FixEventObject = function (e) {\n    if (RG.ISOLD) {\n      var e = event;e.pageX = event.clientX + doc.body.scrollLeft;e.pageY = event.clientY + doc.body.scrollTop;e.target = event.srcElement;if (!doc.body.scrollTop && doc.documentElement.scrollTop) {\n        e.pageX += parseInt(doc.documentElement.scrollLeft);e.pageY += parseInt(doc.documentElement.scrollTop);\n      }\n    }\n    if (!e.stopPropagation) {\n      e.stopPropagation = function () {\n        window.event.cancelBubble = true;\n      };\n    }\n    return e;\n  };RG.hideCrosshairCoords = RG.HideCrosshairCoords = function () {\n    var div = RG.Registry.Get('chart.coordinates.coords.div');if (div && div.style.opacity == 1 && div.__object__.Get('chart.crosshairs.coords.fadeout')) {\n      var style = RG.Registry.Get('chart.coordinates.coords.div').style;setTimeout(function () {\n        style.opacity = 0.9;\n      }, 25);setTimeout(function () {\n        style.opacity = 0.8;\n      }, 50);setTimeout(function () {\n        style.opacity = 0.7;\n      }, 75);setTimeout(function () {\n        style.opacity = 0.6;\n      }, 100);setTimeout(function () {\n        style.opacity = 0.5;\n      }, 125);setTimeout(function () {\n        style.opacity = 0.4;\n      }, 150);setTimeout(function () {\n        style.opacity = 0.3;\n      }, 175);setTimeout(function () {\n        style.opacity = 0.2;\n      }, 200);setTimeout(function () {\n        style.opacity = 0.1;\n      }, 225);setTimeout(function () {\n        style.opacity = 0;\n      }, 250);setTimeout(function () {\n        style.display = 'none';\n      }, 275);\n    }\n  };RG.draw3DAxes = RG.Draw3DAxes = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'],\n        xaxis = prop['chart.variant.threed.xaxis'],\n        yaxis = prop['chart.variant.threed.yaxis'];\n    if (yaxis) {\n      RG.draw3DYAxis(obj);\n    }\n    if (xaxis) {\n      if (xaxispos === 'center') {\n        RG.path2(co, 'b m % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, gutterTop + halfGraphArea, gutterLeft + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight, gutterTop + halfGraphArea);\n      } else {\n        if (obj.type === 'hbar') {\n          var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];\n        } else {\n          var xaxisYCoord = obj.getYCoord(0);\n        }\n        RG.path2(co, 'm % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, xaxisYCoord, gutterLeft + offsetx, xaxisYCoord - offsety, ca.width - gutterRight + offsetx, xaxisYCoord - offsety, ca.width - gutterRight, xaxisYCoord);\n      }\n    }\n  };RG.draw3DYAxis = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];\n    if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {\n      var x = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;\n    } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {\n      var x = ca.width - gutterRight;\n    } else {\n      var x = gutterLeft;\n    }\n    RG.path2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', x, gutterTop, x + offsetx, gutterTop - offsety, x + offsetx, ca.height - gutterBottom - offsety, x, ca.height - gutterBottom);\n  };RG.strokedCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();co.moveTo(x + (corner_tl ? r : 0), y);co.lineTo(x + w - (corner_tr ? r : 0), y);if (corner_tr) {\n      co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);\n    }\n    co.lineTo(x + w, y + h - (corner_br ? r : 0));if (corner_br) {\n      co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);\n    }\n    co.lineTo(x + (corner_bl ? r : 0), y + h);if (corner_bl) {\n      co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    }\n    co.lineTo(x, y + (corner_tl ? r : 0));if (corner_tl) {\n      co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    }\n    co.stroke();\n  };RG.filledCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();if (corner_tl) {\n      co.moveTo(x + r, y + r);co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    } else {\n      co.fillRect(x, y, r, r);\n    }\n    if (corner_tr) {\n      co.moveTo(x + w - r, y + r);co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);\n    } else {\n      co.moveTo(x + w - r, y);co.fillRect(x + w - r, y, r, r);\n    }\n    if (corner_br) {\n      co.moveTo(x + w - r, y + h - r);co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);\n    } else {\n      co.moveTo(x + w - r, y + h - r);co.fillRect(x + w - r, y + h - r, r, r);\n    }\n    if (corner_bl) {\n      co.moveTo(x + r, y + h - r);co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    } else {\n      co.moveTo(x, y + h - r);co.fillRect(x, y + h - r, r, r);\n    }\n    co.fillRect(x + r, y, w - r - r, h);co.fillRect(x, y + r, r + 1, h - r - r);co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);co.fill();\n  };RG.hideZoomedCanvas = RG.HideZoomedCanvas = function () {\n    var interval = 10;var frames = 15;if (_typeof(RG.zoom_image) === 'object') {\n      var obj = RG.zoom_image.obj;var prop = obj.properties;\n    } else {\n      return;\n    }\n    if (prop['chart.zoom.fade.out']) {\n      for (var i = frames, j = 1; i >= 0; --i, ++j) {\n        if (_typeof(RG.zoom_image) === 'object') {\n          setTimeout(\"RGraph.zoom_image.style.opacity = \" + String(i / 10), j * interval);\n        }\n      }\n      if (_typeof(RG.zoom_background) === 'object') {\n        setTimeout(\"RGraph.zoom_background.style.opacity = \" + String(i / frames), j * interval);\n      }\n    }\n    if (_typeof(RG.zoom_image) === 'object') {\n      setTimeout(\"RGraph.zoom_image.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n    if (_typeof(RG.zoom_background) === 'object') {\n      setTimeout(\"RGraph.zoom_background.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n  };RG.addCustomEventListener = RG.AddCustomEventListener = function (obj, name, func) {\n    if (typeof RG.events[obj.uid] === 'undefined') {\n      RG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.events[obj.uid].push([obj, name, func]);return RG.events[obj.uid].length - 1;\n  };RG.fireCustomEvent = RG.FireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {\n        obj.properties['chart.events.mouseout'](obj);\n      }\n      if (obj[name]) {\n        obj[name](obj);\n      }\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.events) === 'object' && _typeof(RG.events[uid]) === 'object' && RG.events[uid].length > 0) {\n        for (var j = 0; j < RG.events[uid].length; ++j) {\n          if (RG.events[uid][j] && RG.events[uid][j][1] === name) {\n            RG.events[uid][j][2](obj);\n          }\n        }\n      }\n    }\n  };RGraph.removeAllCustomEventListeners = RGraph.RemoveAllCustomEventListeners = function () {\n    var id = arguments[0];if (id && RG.events[id]) {\n      RG.events[id] = [];\n    } else {\n      RG.events = [];\n    }\n  };RG.removeCustomEventListener = RG.RemoveCustomEventListener = function (obj, i) {\n    if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.id]) === 'object' && _typeof(RG.events[obj.id][i]) === 'object') {\n      RG.events[obj.id][i] = null;\n    }\n  };RG.drawBackgroundImage = RG.DrawBackgroundImage = function (obj) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (typeof prop['chart.background.image'] === 'string') {\n      if (typeof ca.__rgraph_background_image__ === 'undefined') {\n        var img = new Image();img.__object__ = obj;img.__canvas__ = ca;img.__context__ = co;img.src = obj.Get('chart.background.image');ca.__rgraph_background_image__ = img;\n      } else {\n        img = ca.__rgraph_background_image__;\n      }\n      img.onload = function () {\n        obj.__rgraph_background_image_loaded__ = true;RG.clear(ca);RG.redrawCanvas(ca);\n      };\n      var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var stretch = prop['chart.background.image.stretch'];var align = prop['chart.background.image.align'];if (typeof align === 'string') {\n        if (align.indexOf('right') != -1) {\n          var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;\n        } else {\n          var x = gutterLeft;\n        }\n        if (align.indexOf('bottom') != -1) {\n          var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;\n        } else {\n          var y = gutterTop;\n        }\n      } else {\n        var x = gutterLeft || 25;var y = gutterTop || 25;\n      }\n      var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;if (typeof prop['chart.background.image.w'] === 'number') w = prop['chart.background.image.w'];if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.background.image.alpha'];co.drawImage(img, x, y, w, h);co.globalAlpha = oldAlpha;\n    }\n  };RG.hasTooltips = function (obj) {\n    var prop = obj.properties;if (_typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips']) {\n      for (var i = 0, len = prop['chart.tooltips'].length; i < len; ++i) {\n        if (!RG.is_null(obj.Get('chart.tooltips')[i])) {\n          return true;\n        }\n      }\n    } else if (typeof prop['chart.tooltips'] === 'function') {\n      return true;\n    }\n    return false;\n  };RG.createUID = RG.CreateUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.OR.add = RG.OR.Add = function (obj) {\n    var uid = obj.uid;var id = obj.canvas.id;RG.ObjectRegistry.objects.byUID.push([uid, obj]);RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);\n  };RG.OR.remove = RG.OR.Remove = function (obj) {\n    var id = obj.id;var uid = obj.uid;for (var i = 0; i < RG.ObjectRegistry.objects.byUID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byUID[i] = null;\n      }\n    }\n    for (var i = 0; i < RG.ObjectRegistry.objects.byCanvasID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byCanvasID[i] && RG.ObjectRegistry.objects.byCanvasID[i][1] && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byCanvasID[i] = null;\n      }\n    }\n  };RG.OR.clear = RG.OR.Clear = function () {\n    if (arguments[0]) {\n      var id = _typeof(arguments[0]) === 'object' ? arguments[0].id : arguments[0];var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.ObjectRegistry.remove(objects[i]);\n      }\n    } else {\n      RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];\n    }\n  };RG.OR.list = RG.OR.List = function () {\n    var list = [];for (var i = 0, len = RG.ObjectRegistry.objects.byUID.length; i < len; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i]) {\n        list.push(RG.ObjectRegistry.objects.byUID[i][1].type);\n      }\n    }\n    if (arguments[0]) {\n      return list;\n    } else {\n      $p(list);\n    }\n  };RG.OR.clearByType = RG.OR.ClearByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        var uid = objects[i][0];var obj = objects[i][1];if (obj && obj.type == type) {\n          RG.ObjectRegistry.remove(obj);\n        }\n      }\n    }\n  };RG.OR.iterate = RG.OR.Iterate = function (func) {\n    var objects = RGraph.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (typeof arguments[1] === 'string') {\n        var types = arguments[1].split(/,/);for (var j = 0, len2 = types.length; j < len2; ++j) {\n          if (types[j] == objects[i][1].type) {\n            func(objects[i][1]);\n          }\n        }\n      } else {\n        func(objects[i][1]);\n      }\n    }\n  };RG.OR.getObjectsByCanvasID = function (id) {\n    var store = RG.ObjectRegistry.objects.byCanvasID;var ret = [];for (var i = 0, len = store.length; i < len; ++i) {\n      if (store[i] && store[i][0] == id) {\n        ret.push(store[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.firstbyxy = RG.OR.getFirstObjectByXY = RG.OR.getObjectByXY = function (e) {\n    var canvas = e.target;var ret = null;var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        return obj;\n      }\n    }\n  };RG.OR.getObjectsByXY = function (e) {\n    var canvas = e.target;var ret = [];var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        ret.push(obj);\n      }\n    }\n    return ret;\n  };RG.OR.get = RG.OR.getObjectByUID = function (uid) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1].uid == uid) {\n        return objects[i][1];\n      }\n    }\n  };RG.OR.bringToFront = function (obj) {\n    var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];RG.ObjectRegistry.remove(obj);RG.ObjectRegistry.add(obj);if (redraw) {\n      RG.redrawCanvas(obj.canvas);\n    }\n  };RG.OR.type = RG.OR.getObjectsByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;var ret = [];for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {\n        ret.push(objects[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.first = RG.OR.getFirstObjectByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type == type) {\n        return objects[i][1];\n      }\n    }\n    return null;\n  };RG.getAngleByXY = function (cx, cy, x, y) {\n    var angle = ma.atan((y - cy) / (x - cx));angle = ma.abs(angle);\n    if (x >= cx && y >= cy) {\n      angle += RG.TWOPI;\n    } else if (x >= cx && y < cy) {\n      angle = RG.HALFPI - angle + (RG.PI + RG.HALFPI);\n    } else if (x < cx && y < cy) {\n      angle += RG.PI;\n    } else {\n      angle = RG.PI - angle;\n    }\n    if (angle > RG.TWOPI) {\n      angle -= RG.TWOPI;\n    }\n    return angle;\n  };RG.getHypLength = function (x1, y1, x2, y2) {\n    var ret = ma.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));return ret;\n  };RG.getRadiusEndPoint = function (cx, cy, angle, radius) {\n    var x = cx + ma.cos(angle) * radius;var y = cy + ma.sin(angle) * radius;return [x, y];\n  };RG.installEventListeners = RG.InstallEventListeners = function (obj) {\n    var prop = obj.properties;if (RG.ISOLD) {\n      return;\n    }\n    if (RG.installCanvasClickListener) {\n      RG.installWindowMousedownListener(obj);RG.installWindowMouseupListener(obj);RG.installCanvasMousemoveListener(obj);RG.installCanvasMouseupListener(obj);RG.installCanvasMousedownListener(obj);RG.installCanvasClickListener(obj);\n    } else if (RG.hasTooltips(obj) || prop['chart.adjustable'] || prop['chart.annotatable'] || prop['chart.contextmenu'] || prop['chart.resizable'] || prop['chart.key.interactive'] || prop['chart.events.click'] || prop['chart.events.mousemove'] || typeof obj.onclick === 'function' || typeof obj.onmousemove === 'function') {\n      alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\n    }\n  };RG.pr = function (obj) {\n    var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n      return '';\n    }\n    switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n        str += 'function () {}';break;case 'undefined':\n        str += 'undefined';break;case 'null':\n        str += 'null';break;case 'object':\n        if (RGraph.is_null(obj)) {\n          str += indent + 'null\\n';\n        } else {\n          str += indent + 'Object {' + '\\n';\n          for (j in obj) {\n            str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\\n';\n          }\n          str += indent + '}';\n        }\n        break;default:\n        str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n    if (!arguments[1]) {\n      alert(str);\n    }\n    return str;\n  };RG.dashedLine = RG.DashedLine = function (co, x1, y1, x2, y2) {\n    var size = 5;if (typeof arguments[5] === 'number') {\n      size = arguments[5];\n    }\n    var dx = x2 - x1;var dy = y2 - y1;var num = ma.floor(ma.sqrt(dx * dx + dy * dy) / size);var xLen = dx / num;var yLen = dy / num;var count = 0;do {\n      count % 2 == 0 && count > 0 ? co.lineTo(x1, y1) : co.moveTo(x1, y1);x1 += xLen;y1 += yLen;\n    } while (count++ <= num);\n  };RG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.AJAX.getNumber = function (url, callback) {\n    RG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.AJAX.getString = function (url, callback) {\n    RG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.AJAX.getJSON = function (url, callback) {\n    RG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.AJAX.getCSV = function (url, callback) {\n    var seperator = arguments[2] ? arguments[2] : ',';RG.AJAX(url, function () {\n      var regexp = new RegExp(seperator);var arr = this.responseText.split(regexp);for (var i = 0, len = arr.length; i < len; ++i) {\n        arr[i] = parseFloat(arr[i]);\n      }\n      callback(arr);\n    });\n  };RG.rotateCanvas = RG.RotateCanvas = function (ca, x, y, angle) {\n    var co = ca.getContext('2d');co.translate(x, y);co.rotate(angle);co.translate(0 - x, 0 - y);\n  };RG.measureText = RG.MeasureText = function (text, bold, font, size) {\n    if (typeof RG.measuretext_cache === 'undefined') {\n      RG.measuretext_cache = [];\n    }\n    var str = text + ':' + bold + ':' + font + ':' + size;if (_typeof(RG.measuretext_cache) == 'object' && RG.measuretext_cache[str]) {\n      return RG.measuretext_cache[str];\n    }\n    if (!RG.measuretext_cache['text-div']) {\n      var div = document.createElement('DIV');div.style.position = 'absolute';div.style.top = '-100px';div.style.left = '-100px';document.body.appendChild(div);RG.measuretext_cache['text-div'] = div;\n    } else if (RG.measuretext_cache['text-div']) {\n      var div = RG.measuretext_cache['text-div'];\n    }\n    div.innerHTML = text.replace(/\\r\\n/g, '<br />');div.style.fontFamily = font;div.style.fontWeight = bold ? 'bold' : 'normal';div.style.fontSize = (size || 12) + 'pt';var size = [div.offsetWidth, div.offsetHeight];RG.measuretext_cache[str] = size;return size;\n  };RG.text2 = RG.Text2 = function (obj, opt) {\n    function domtext() {\n      if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {\n        opt.size = opt.size.replace(/ *italic +/, '');opt.italic = true;\n      }\n      var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;if (!ca.rgraph_domtext_wrapper) {\n        var wrapper = document.createElement('div');wrapper.id = ca.id + '_rgraph_domtext_wrapper';wrapper.className = 'rgraph_domtext_wrapper';wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';wrapper.style.width = ca.offsetWidth + 'px';wrapper.style.height = ca.offsetHeight + 'px';wrapper.style.cssFloat = ca.style.cssFloat;wrapper.style.display = ca.style.display || 'inline-block';wrapper.style.position = ca.style.position || 'relative';wrapper.style.left = ca.style.left;wrapper.style.top = ca.style.top;wrapper.style.width = ca.width + 'px';wrapper.style.height = ca.height + 'px';ca.style.position = 'absolute';ca.style.left = 0;ca.style.top = 0;ca.style.display = 'inline';ca.style.cssFloat = 'none';if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {\n          wrapper.style.transform = 'skewY(5.7deg)';\n        }\n        ca.parentNode.insertBefore(wrapper, ca);ca.parentNode.removeChild(ca);wrapper.appendChild(ca);ca.rgraph_domtext_wrapper = wrapper;\n      } else {\n        wrapper = ca.rgraph_domtext_wrapper;\n      }\n      var defaults = { size: 12, font: 'Arial', italic: 'normal', bold: 'normal', valign: 'bottom', halign: 'left', marker: true, color: co.fillStyle, bounding: { enabled: false, fill: 'rgba(255,255,255,0.7)', stroke: '#666' } };\n      opt.text = String(opt.text).replace(/\\r?\\n/g, '[[RETURN]]');if (typeof RG.text2.domNodeCache === 'undefined') {\n        RG.text2.domNodeCache = new Array();\n      }\n      if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {\n        RG.text2.domNodeCache[obj.id] = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache === 'undefined') {\n        RG.text2.domNodeDimensionCache = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {\n        RG.text2.domNodeDimensionCache[obj.id] = new Array();\n      }\n      if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {\n        var span = document.createElement('span');span.style.position = 'absolute';span.style.display = 'inline';span.style.left = opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width)) + 'px';span.style.top = opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)) + 'px';span.style.color = opt.color || defaults.color;span.style.fontFamily = opt.font || defaults.font;span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;span.style.fontStyle = opt.italic ? 'italic' : defaults.italic;span.style.fontSize = (opt.size || defaults.size) + 'pt';span.style.whiteSpace = 'nowrap';span.tag = opt.tag;if (typeof opt.angle === 'number' && opt.angle !== 0) {\n          var coords = RG.measureText(opt.text, opt.bold, opt.font, opt.size);span.style.transformOrigin = '100% 50%';span.style.transform = 'rotate(' + opt.angle + 'deg)';\n        }\n        span.style.textShadow = '{1}px {2}px {3}px {4}'.format(co.shadowOffsetX, co.shadowOffsetY, co.shadowBlur, co.shadowColor);if (opt.bounding) {\n          span.style.border = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;\n        }\n        if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' || obj.properties['chart.text.accessible.pointerevents']) && obj.properties['chart.text.accessible.pointerevents'] !== 'none') {\n          span.style.pointerEvents = 'auto';\n        } else {\n          span.style.pointerEvents = 'none';\n        }\n        span.style.padding = opt.bounding ? '2px' : null;span.__text__ = opt.text;\n        span.innerHTML = opt.text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');span.innerHTML = span.innerHTML.replace(/\\[\\[RETURN\\]\\]/g, '<br />');wrapper.appendChild(span);opt.halign = opt.halign || 'left';opt.valign = opt.valign || 'bottom';if (opt.halign === 'right') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth + 'px';span.style.textAlign = 'right';\n        } else if (opt.halign === 'center') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth / 2 + 'px';span.style.textAlign = 'center';\n        }\n        if (opt.valign === 'top') {} else if (opt.valign === 'center') {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight / 2 + 'px';\n        } else {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\n        }\n        var offsetWidth = parseFloat(span.offsetWidth),\n            offsetHeight = parseFloat(span.offsetHeight),\n            top = parseFloat(span.style.top),\n            left = parseFloat(span.style.left);RG.text2.domNodeCache[obj.id][cacheKey] = span;RG.text2.domNodeDimensionCache[obj.id][cacheKey] = { left: left, top: top, width: offsetWidth, height: offsetHeight };span.id = cacheKey;\n      } else {\n        span = RG.text2.domNodeCache[obj.id][cacheKey];span.style.display = 'inline';var offsetWidth = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,\n            offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,\n            top = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,\n            left = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;\n      }\n      if (opt.marker) {\n        RG.path2(context, 'b m % % l % % m % % l % % s', opt.x - 5, opt.y, opt.x + 5, opt.y, opt.x, opt.y - 5, opt.x, opt.y + 5);\n      }\n      if (obj.type === 'drawing.text') {\n        if (obj.properties['chart.events.mousemove']) {\n          span.addEventListener('mousemove', function (e) {\n            obj.properties['chart.events.mousemove'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.events.click']) {\n          span.addEventListener('click', function (e) {\n            obj.properties['chart.events.click'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.tooltips']) {\n          span.addEventListener(obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click', function (e) {\n            if (!RG.Registry.get('chart.tooltip') || RG.Registry.get('chart.tooltip').__index__ !== 0 || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid) {\n              RG.hideTooltip();RG.redraw();RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);\n            }\n          }, false);\n        }\n      }\n      var ret = {};ret.x = left;ret.y = top;ret.width = offsetWidth;ret.height = offsetHeight;ret.object = obj;ret.text = opt.text;ret.tag = opt.tag;RG.text2.domNodeCache.reset = function () {\n        if (arguments[0]) {\n          if (typeof arguments[0] === 'string') {\n            var ca = document.getElementById(arguments[0]);\n          } else {\n            var ca = arguments[0];\n          }\n          var nodes = RG.text2.domNodeCache[ca.id];for (j in nodes) {\n            var node = RG.text2.domNodeCache[ca.id][j];if (node && node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          }\n          RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n        } else {\n          for (i in RG.text2.domNodeCache) {\n            for (j in RG.text2.domNodeCache[i]) {\n              if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {\n                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);\n              }\n            }\n          }\n          RG.text2.domNodeCache = [];RG.text2.domNodeDimensionCache = [];\n        }\n      };RG.text2.find = function (opt) {\n        var span,\n            nodes = [];var id = typeof opt.id === 'string' ? opt.id : opt.object.id;for (i in RG.text2.domNodeCache[id]) {\n          span = RG.text2.domNodeCache[id][i];if (typeof opt.tag === 'string' && opt.tag === span.tag) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.tag) === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.tag);if (regexp.test(span.tag)) {\n              nodes.push(span);continue;\n            }\n          }\n          if (typeof opt.text === 'string' && opt.text === span.__text__) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.text) === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.text);if (regexp.test(span.__text__)) {\n              nodes.push(span);continue;\n            }\n          }\n        }\n        return nodes;\n      };ret.node = span;if (obj && obj.isRGraph && obj.coordsText) {\n        obj.coordsText.push(ret);\n      }\n      return ret;\n    }\n    if (obj && obj.isRGraph) {\n      var obj = obj;var co = obj.context;var ca = obj.canvas;\n    } else if (typeof obj == 'string') {\n      var ca = document.getElementById(obj);var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (typeof obj.getContext === 'function') {\n      var ca = obj;var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    } else if (RG.ISOLD && obj.fillText) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    }\n    if (typeof opt.boundingFill === 'string') opt['bounding.fill'] = opt.boundingFill;if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {\n      return domtext();\n    }\n    var x = opt.x,\n        y = opt.y,\n        originalX = x,\n        originalY = y,\n        text = opt.text,\n        text_multiline = typeof text === 'string' ? text.split(/\\r?\\n/g) : '',\n        numlines = text_multiline.length,\n        font = opt.font ? opt.font : 'Arial',\n        size = opt.size ? opt.size : 10,\n        size_pixels = size * 1.5,\n        bold = opt.bold,\n        italic = opt.italic,\n        halign = opt.halign ? opt.halign : 'left',\n        valign = opt.valign ? opt.valign : 'bottom',\n        tag = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',\n        marker = opt.marker,\n        angle = opt.angle || 0;\n    var bounding = opt.bounding,\n        bounding_stroke = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',\n        bounding_fill = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',\n        bounding_shadow = opt['bounding.shadow'],\n        bounding_shadow_color = opt['bounding.shadow.color'] || '#ccc',\n        bounding_shadow_blur = opt['bounding.shadow.blur'] || 3,\n        bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,\n        bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,\n        bounding_linewidth = opt['bounding.linewidth'] || 1;var ret = {};if (typeof opt.color === 'string') {\n      var orig_fillstyle = co.fillStyle;co.fillStyle = opt.color;\n    }\n    if (typeof text == 'number') {\n      text = String(text);\n    }\n    if (typeof text !== 'string') {\n      return;\n    }\n    if (angle != 0) {\n      co.save();co.translate(x, y);co.rotate(ma.PI / 180 * angle);\n      x = 0;y = 0;\n    }\n    co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;var width = 0;for (var i = 0; i < numlines; ++i) {\n      width = ma.max(width, co.measureText(text_multiline[i]).width);\n    }\n    var height = size_pixels * numlines;if (opt.marker) {\n      var marker_size = 10;var strokestyle = co.strokeStyle;co.beginPath();co.strokeStyle = 'red';co.moveTo(x, y - marker_size);co.lineTo(x, y + marker_size);co.moveTo(x - marker_size, y);co.lineTo(x + marker_size, y);co.stroke();co.strokeStyle = strokestyle;\n    }\n    if (halign == 'center') {\n      co.textAlign = 'center';var boundingX = x - 2 - width / 2;\n    } else if (halign == 'right') {\n      co.textAlign = 'right';var boundingX = x - 2 - width;\n    } else {\n      co.textAlign = 'left';var boundingX = x - 2;\n    }\n    if (valign == 'center') {\n      co.textBaseline = 'middle';y -= 1;y -= (numlines - 1) / 2 * size_pixels;var boundingY = y - size_pixels / 2 - 2;\n    } else if (valign == 'top') {\n      co.textBaseline = 'top';var boundingY = y - 2;\n    } else {\n      co.textBaseline = 'bottom';if (numlines > 1) {\n        y -= (numlines - 1) * size_pixels;\n      }\n      var boundingY = y - size_pixels - 2;\n    }\n    var boundingW = width + 4;var boundingH = height + 4;if (bounding) {\n      var pre_bounding_linewidth = co.lineWidth;var pre_bounding_strokestyle = co.strokeStyle;var pre_bounding_fillstyle = co.fillStyle;var pre_bounding_shadowcolor = co.shadowColor;var pre_bounding_shadowblur = co.shadowBlur;var pre_bounding_shadowoffsetx = co.shadowOffsetX;var pre_bounding_shadowoffsety = co.shadowOffsetY;co.lineWidth = bounding_linewidth;co.strokeStyle = bounding_stroke;co.fillStyle = bounding_fill;if (bounding_shadow) {\n        co.shadowColor = bounding_shadow_color;co.shadowBlur = bounding_shadow_blur;co.shadowOffsetX = bounding_shadow_offsetx;co.shadowOffsetY = bounding_shadow_offsety;\n      }\n      co.strokeRect(boundingX, boundingY, boundingW, boundingH);co.fillRect(boundingX, boundingY, boundingW, boundingH);co.lineWidth = pre_bounding_linewidth;co.strokeStyle = pre_bounding_strokestyle;co.fillStyle = pre_bounding_fillstyle;co.shadowColor = pre_bounding_shadowcolor;\n      co.shadowBlur = pre_bounding_shadowblur;\n      co.shadowOffsetX = pre_bounding_shadowoffsetx;\n      co.shadowOffsetY = pre_bounding_shadowoffsety;\n    }\n    if (numlines > 1) {\n      for (var i = 0; i < numlines; ++i) {\n        co.fillText(text_multiline[i], x, y + size_pixels * i);\n      }\n    } else {\n      co.fillText(text, x + 0.5, y + 0.5);\n    }\n    if (angle != 0) {\n      if (angle == 90) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      } else if (angle == 180) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        }\n      } else if (angle == 270) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      }\n      co.restore();\n    }\n    co.textBaseline = 'alphabetic';co.textAlign = 'left';ret.x = boundingX;ret.y = boundingY;ret.width = boundingW;ret.height = boundingH;\n    ret.object = obj;ret.text = text;ret.tag = tag;if (obj && obj.isRGraph && obj.coordsText) {\n      obj.coordsText.push(ret);\n    }\n    if (typeof orig_fillstyle === 'string') {\n      co.fillStyle = orig_fillstyle;\n    }\n    return ret;\n  };RG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0;var grouped_index = 0;while (--index >= 0) {\n      if (RG.is_null(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.Highlight.rect = RG.Highlight.Rect = function (obj, shape) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;if (prop['chart.tooltips.highlight']) {\n      co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.rect(shape['x'], shape['y'], shape['width'], shape['height']);co.stroke();co.fill();\n    }\n  };RG.Highlight.point = RG.Highlight.Point = function (obj, shape) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (prop['chart.tooltips.highlight']) {\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];var radius = prop['chart.highlight.point.radius'] || 2;co.arc(shape['x'], shape['y'], radius, 0, RG.TWOPI, 0);co.stroke();co.fill();\n    }\n  };RG.parseDate = function (str) {\n    str = RG.trim(str);if (str === 'now') {\n      str = new Date().toString();\n    }\n    if (str.match(/^(\\d\\d)(?:-|\\/)(\\d\\d)(?:-|\\/)(\\d\\d\\d\\d)(.*)$/)) {\n      str = '{1}/{2}/{3}{4}'.format(RegExp.$3, RegExp.$2, RegExp.$1, RegExp.$4);\n    }\n    if (str.match(/^(\\d\\d\\d\\d)(-|\\/)(\\d\\d)(-|\\/)(\\d\\d)( |T)(\\d\\d):(\\d\\d):(\\d\\d)$/)) {\n      str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;\n    }\n    if (str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d$/)) {\n      str = str.replace(/-/g, '/');\n    }\n    if (str.match(/^\\d\\d:\\d\\d:\\d\\d$/)) {\n      var dateObj = new Date();var date = dateObj.getDate();var month = dateObj.getMonth() + 1;var year = dateObj.getFullYear();if (String(month).length === 1) month = '0' + month;if (String(date).length === 1) date = '0' + date;str = year + '/' + month + '/' + date + ' ' + str;\n    }\n    return Date.parse(str);\n  };RG.resetColorsToOriginalValues = function (obj) {\n    if (obj.original_colors) {\n      for (var j in obj.original_colors) {\n        if (typeof j === 'string' && j.substr(0, 6) === 'chart.') {\n          obj.properties[j] = RG.arrayClone(obj.original_colors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.colorsParsed = false;\n  };RG.linearGradient = RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2) {\n    var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);var numColors = arguments.length - 5;for (var i = 5; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 5) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.radialGradient = RG.RadialGradient = function (obj, x1, y1, r1, x2, y2, r2, color1, color2) {\n    var gradient = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);var numColors = arguments.length - 7;for (var i = 7; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 7) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.addEventListener = RG.AddEventListener = function (id, e, func) {\n    var type = arguments[3] ? arguments[3] : 'unknown';RG.Registry.get('chart.event.handlers').push([id, e, func, type]);\n  };RG.clearEventListeners = RG.ClearEventListeners = function (id) {\n    if (id && id == 'window') {\n      window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);\n    } else {\n      var canvas = document.getElementById(id);canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);\n    }\n  };RG.hidePalette = RG.HidePalette = function () {\n    var div = RG.Registry.get('palette');if ((typeof div === 'undefined' ? 'undefined' : _typeof(div)) == 'object' && div) {\n      div.style.visibility = 'hidden';div.style.display = 'none';RG.Registry.set('palette', null);\n    }\n  };RG.random = function (min, max) {\n    var dp = arguments[2] ? arguments[2] : 0;var r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.arrayRand = RG.arrayRandom = RG.random.array = function (num, min, max) {\n    for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.random(min, max, arguments[3]));\n    }\n    return arr;\n  };RG.noShadow = RG.NoShadow = function (obj) {\n    var co = obj.context;co.shadowColor = 'rgba(0,0,0,0)';co.shadowBlur = 0;co.shadowOffsetX = 0;co.shadowOffsetY = 0;\n  };RG.setShadow = RG.SetShadow = function (obj, color, offsetx, offsety, blur) {\n    var co = obj.context;co.shadowColor = color;co.shadowOffsetX = offsetx;co.shadowOffsetY = offsety;co.shadowBlur = blur;\n  };RG.Registry.set = RG.Registry.Set = function (name, value) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    RG.Registry.store[name] = value;return value;\n  };RG.Registry.get = RG.Registry.Get = function (name) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    return RG.Registry.store[name];\n  };RG.degrees2Radians = function (deg) {\n    return deg * (RG.PI / 180);\n  };RG.log = function (n, base) {\n    return ma.log(n) / (base ? ma.log(base) : 1);\n  };RG.isArray = RG.is_array = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.trim = function (str) {\n    return RG.ltrim(RG.rtrim(str));\n  };RG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.isNull = RG.is_null = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.async = RG.Async = function (func) {\n    return setTimeout(func, arguments[1] ? arguments[1] : 1);\n  };RG.reset = RG.Reset = function (ca) {\n    ca.width = ca.width;RG.ObjectRegistry.clear(ca);ca.__rgraph_aa_translated__ = false;if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {\n      RG.text2.domNodeCache.reset(ca);\n    }\n    if (!RG.text2.domNodeCache) {\n      RG.text2.domNodeCache = [];\n    }\n    if (!RG.text2.domNodeDimensionCache) {\n      RG.text2.domNodeDimensionCache = [];\n    }\n    RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n  };RG.att = RG.attribution = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties;if (!ca || !co) {\n      return;\n    }\n    var width = ca.width,\n        height = ca.height,\n        wrapper = document.getElementById('cvs').__object__.canvas.parentNode,\n        text = prop['chart.attribution.text'] || 'Free Charts with RGraph.net',\n        x = prop['chart.attribution.x'],\n        y = prop['chart.attribution.y'],\n        bold = prop['chart.attribution.bold'],\n        italic = prop['chart.attribution.italic'],\n        font = prop['chart.attribution.font'] || 'sans-serif',\n        size = prop['chart.attribution.size'] || 8,\n        underline = prop['chart.attribution.underline'] ? 'underline' : 'none',\n        color = typeof prop['chart.attribution.color'] === 'string' ? prop['chart.attribution.color'] : '',\n        href = typeof prop['chart.attribution.href'] === 'string' ? prop['chart.attribution.href'] : 'http://www.rgraph.net/canvas/index.html';if (wrapper.attribution_node) {\n      return;\n    }\n    var measurements = RG.measureText(text, bold, font, size);var a = document.createElement('A');a.href = href;a.innerHTML = text;a.target = '_blank';a.style.position = 'absolute';a.style.left = typeof x === 'number' ? x : wrapper.offsetWidth - measurements[0] - 5 + 'px';a.style.top = typeof y === 'number' ? y : wrapper.offsetHeight - measurements[1] + 'px';a.style.fontSize = size + 'pt';a.style.fontStyle = typeof italic === 'boolean' ? italic ? 'italic' : '' : 'italic', a.style.fontWeight = bold ? 'bold' : '', a.style.textDecoration = underline;a.style.fontFamily = font;a.style.color = color;wrapper.appendChild(a);wrapper.attribution_node = a;\n  };RG.getCanvasTag = function (id) {\n    id = (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' ? id.id : id;var canvas = doc.getElementById(id);return [id, canvas];\n  };RG.Effects.updateCanvas = RG.Effects.UpdateCanvas = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.Effects.getEasingMultiplier = function (frames, frame) {\n    return ma.pow(ma.sin(frame / frames * RG.HALFPI), 3);\n  };RG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.cachedDraw = function (obj, id, func) {\n    if (!RG.cache[id]) {\n      RG.cache[id] = {};RG.cache[id].object = obj;RG.cache[id].canvas = document.createElement('canvas');RG.cache[id].canvas.setAttribute('width', obj.canvas.width);RG.cache[id].canvas.setAttribute('height', obj.canvas.height);RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);RG.cache[id].canvas.__object__ = obj;RG.cache[id].context = RG.cache[id].canvas.getContext('2d');RG.cache[id].context.translate(0.5, 0.5);func(obj, RG.cache[id].canvas, RG.cache[id].context);\n    }\n    obj.context.drawImage(RG.cache[id].canvas, -0.5, -0.5);\n  };RG.parseObjectStyleConfig = function (obj, config) {\n    var recurse = function recurse(obj, config, name, settings) {\n      var i;for (key in config) {\n        if (key.match(/^exec[0-9]*$/)) {\n          config[key](obj, settings);continue;\n        }\n        var isObject = false;var isArray = false;var value = config[key];while (key.match(/([A-Z])/)) {\n          key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n        }\n        if (!RG.isNull(value) && value.constructor) {\n          isObject = value.constructor.toString().indexOf('Object') > 0;isArray = value.constructor.toString().indexOf('Array') > 0;\n        }\n        if (isObject && !isArray) {\n          recurse(obj, config[key], name + '.' + key, settings);\n        } else if (key === 'self') {\n          settings[name] = value;\n        } else {\n          settings[name + '.' + key] = value;\n        }\n      }\n      return settings;\n    };var settings = recurse(obj, config, 'chart', {});for (key in settings) {\n      if (typeof key === 'string') {\n        obj.set(key, settings[key]);\n      }\n    }\n  };RG.path2 = function (co, p) {\n    var args = arguments;if (typeof p === 'string') {\n      p = splitstring(p);\n    }\n    RG.path2.last = RG.arrayClone(p);for (var i = 0, len = p.length; i < len; i += 1) {\n      switch (p[i]) {case 'b':\n          co.beginPath();break;case 'c':\n          co.closePath();break;case 'm':\n          co.moveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'l':\n          co.lineTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 's':\n          if (p[i + 1]) co.strokeStyle = p[i + 1];co.stroke();i++;break;case 'f':\n          if (p[i + 1]) {\n            co.fillStyle = p[i + 1];\n          }co.fill();i++;break;case 'qc':\n          co.quadraticCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'bc':\n          co.bezierCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'r':\n          co.rect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'a':\n          co.arc(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), p[i + 6] === 'true' || p[i + 6] === true || p[i + 6] === 1 || p[i + 6] === '1' ? true : false);i += 6;break;case 'at':\n          co.arcTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]));i += 5;break;case 'lw':\n          co.lineWidth = parseFloat(p[i + 1]);i++;break;case 'e':\n          co.ellipse(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]), parseFloat(p[i + 7]), p[i + 8] === 'true' ? true : false);i += 8;break;case 'lj':\n          co.lineJoin = p[i + 1];i++;break;case 'lc':\n          co.lineCap = p[i + 1];i++;break;case 'sc':\n          co.shadowColor = p[i + 1];i++;break;case 'sb':\n          co.shadowBlur = parseFloat(p[i + 1]);i++;break;case 'sx':\n          co.shadowOffsetX = parseFloat(p[i + 1]);i++;break;case 'sy':\n          co.shadowOffsetY = parseFloat(p[i + 1]);i++;break;case 'fs':\n          co.fillStyle = p[i + 1];i++;break;case 'ss':\n          co.strokeStyle = p[i + 1];i++;break;case 'fr':\n          co.fillRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'sr':\n          co.strokeRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'cl':\n          co.clip();break;case 'sa':\n          co.save();break;case 'rs':\n          co.restore();break;case 'tr':\n          co.translate(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'sl':\n          co.scale(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'ro':\n          co.rotate(parseFloat(p[i + 1]));i++;break;case 'tf':\n          co.transform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'stf':\n          co.setTransform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'cr':\n          co.clearRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'ld':\n          var parts = p[i + 1];co.setLineDash(parts);i += 1;break;case 'ldo':\n          co.lineDashOffset = p[i + 1];i++;break;case 'fo':\n          co.font = p[i + 1];i++;break;case 'ft':\n          co.fillText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'st':\n          co.strokeText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'ta':\n          co.textAlign = p[i + 1];i++;break;case 'tbl':\n          co.textBaseline = p[i + 1];i++;break;case 'ga':\n          co.globalAlpha = parseFloat(p[i + 1]);i++;break;case 'gco':\n          co.globalCompositeOperation = p[i + 1];i++;break;case 'fu':\n          p[i + 1](co.canvas.__object__);i++;break;case '':\n          break;default:\n          alert('[ERROR] Unknown option: ' + p[i]);}\n    }\n    function splitstring(p) {\n      var ret = [],\n          buffer = '',\n          inquote = false,\n          quote = '',\n          substitutionIndex = 2;for (var i = 0; i < p.length; i += 1) {\n        var chr = p[i],\n            isWS = chr.match(/ /);if (isWS) {\n          if (!inquote) {\n            if (buffer[0] === '\"' || buffer[0] === \"'\") {\n              buffer = buffer.substr(1, buffer.length - 2);\n            }\n            if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\n              buffer = args[substitutionIndex++];\n            }\n            ret.push(buffer);buffer = '';\n          } else {\n            buffer += chr;\n          }\n        } else {\n          if (chr === \"'\" || chr === '\"') {\n            inquote = !inquote;\n          }\n          buffer += chr;\n        }\n      }\n      if (buffer.trim() === '%' && args[substitutionIndex]) {\n        buffer = args[substitutionIndex++];\n      }\n      ret.push(buffer);return ret;\n    }\n  };RG.wrap = function () {};\n})(window, document);window.$p = function (v) {\n  RGraph.pr(arguments[0], arguments[1], arguments[3]);\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmNvcmUuanM/OWMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLkhpZ2hsaWdodD17fTtSRy5SZWdpc3RyeT17fTtSRy5SZWdpc3RyeS5zdG9yZT1bXTtSRy5SZWdpc3RyeS5zdG9yZVsnY2hhcnQuZXZlbnQuaGFuZGxlcnMnXT1bXTtSRy5SZWdpc3RyeS5zdG9yZVsnX19yZ3JhcGhfZXZlbnRfbGlzdGVuZXJzX18nXT1bXTtSRy5CYWNrZ3JvdW5kPXt9O1JHLmJhY2tncm91bmQ9e307Ukcub2JqZWN0cz1bXTtSRy5SZXNpemluZz17fTtSRy5ldmVudHM9W107UkcuY3Vyc29yPVtdO1JHLkVmZmVjdHM9UkcuRWZmZWN0c3x8e307UkcuY2FjaGU9W107UkcuT2JqZWN0UmVnaXN0cnk9e307UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cz17fTtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEPVtdO1JHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRD1bXTtSRy5PUj1SRy5PYmplY3RSZWdpc3RyeTtSRy5QST1tYS5QSTtSRy5IQUxGUEk9UkcuUEkvMjtSRy5UV09QST1SRy5QSSoyO1JHLklTRkY9dWEuaW5kZXhPZignRmlyZWZveCcpIT0tMTtSRy5JU09QRVJBPXVhLmluZGV4T2YoJ09wZXJhJykhPS0xO1JHLklTQ0hST01FPXVhLmluZGV4T2YoJ0Nocm9tZScpIT0tMTtSRy5JU1NBRkFSST11YS5pbmRleE9mKCdTYWZhcmknKSE9LTEmJiFSRy5JU0NIUk9NRTtSRy5JU1dFQktJVD11YS5pbmRleE9mKCdXZWJLaXQnKSE9LTE7UkcuSVNJRT11YS5pbmRleE9mKCdUcmlkZW50Jyk+MHx8bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJyk+MDtSRy5JU0lFNj11YS5pbmRleE9mKCdNU0lFIDYnKT4wO1JHLklTSUU3PXVhLmluZGV4T2YoJ01TSUUgNycpPjA7UkcuSVNJRTg9dWEuaW5kZXhPZignTVNJRSA4Jyk+MDtSRy5JU0lFOT11YS5pbmRleE9mKCdNU0lFIDknKT4wO1JHLklTSUUxMD11YS5pbmRleE9mKCdNU0lFIDEwJyk+MDtSRy5JU09MRD1SR3JhcGguSVNJRTZ8fFJHcmFwaC5JU0lFN3x8UkdyYXBoLklTSUU4O1JHLklTSUUxMVVQPXVhLmluZGV4T2YoJ01TSUUnKT09LTEmJnVhLmluZGV4T2YoJ1RyaWRlbnQnKT4wO1JHLklTSUUxMFVQPVJHLklTSUUxMHx8UkcuSVNJRTExVVA7UkcuSVNJRTlVUD1SRy5JU0lFOXx8UkcuSVNJRTEwVVA7UkcuZ2V0U2NhbGU9ZnVuY3Rpb24obWF4LG9iailcbntpZihtYXg9PTApe3JldHVyblsnMC4yJywnMC40JywnMC42JywnMC44JywnMS4wJ107fVxudmFyIG9yaWdpbmFsX21heD1tYXg7aWYobWF4PD0xKXtpZihtYXg+MC41KXtyZXR1cm5bMC4yLDAuNCwwLjYsMC44LE51bWJlcigxKS50b0ZpeGVkKDEpXTt9ZWxzZSBpZihtYXg+PTAuMSl7cmV0dXJuIG9iai5HZXQoJ2NoYXJ0LnNjYWxlLnJvdW5kJyk/WzAuMiwwLjQsMC42LDAuOCwxXTpbMC4xLDAuMiwwLjMsMC40LDAuNV07fWVsc2V7dmFyIHRtcD1tYXg7dmFyIGV4cD0wO3doaWxlKHRtcDwxLjAxKXtleHArPTE7dG1wKj0xMDt9XG52YXIgcmV0PVsnMmUtJytleHAsJzRlLScrZXhwLCc2ZS0nK2V4cCwnOGUtJytleHAsJzEwZS0nK2V4cF07aWYobWF4PD0oJzVlLScrZXhwKSl7cmV0PVsnMWUtJytleHAsJzJlLScrZXhwLCczZS0nK2V4cCwnNGUtJytleHAsJzVlLScrZXhwXTt9XG5yZXR1cm4gcmV0O319XG5pZihTdHJpbmcobWF4KS5pbmRleE9mKCcuJyk+MCl7bWF4PVN0cmluZyhtYXgpLnJlcGxhY2UoL1xcLlxcZCskLywnJyk7fVxudmFyIGludGVydmFsPW1hLnBvdygxMCxOdW1iZXIoU3RyaW5nKE51bWJlcihtYXgpKS5sZW5ndGgtMSkpO3ZhciB0b3BWYWx1ZT1pbnRlcnZhbDt3aGlsZSh0b3BWYWx1ZTxtYXgpe3RvcFZhbHVlKz0oaW50ZXJ2YWwvMik7fVxuaWYoTnVtYmVyKG9yaWdpbmFsX21heCk+TnVtYmVyKHRvcFZhbHVlKSl7dG9wVmFsdWUrPShpbnRlcnZhbC8yKTt9XG5pZihtYXg8MTApe3RvcFZhbHVlPShOdW1iZXIob3JpZ2luYWxfbWF4KTw9NT81OjEwKTt9XG5pZihvYmomJnR5cGVvZihvYmouR2V0KCdjaGFydC5zY2FsZS5yb3VuZCcpKT09J2Jvb2xlYW4nJiZvYmouR2V0KCdjaGFydC5zY2FsZS5yb3VuZCcpKXt0b3BWYWx1ZT0xMCppbnRlcnZhbDt9XG5yZXR1cm5bdG9wVmFsdWUqMC4yLHRvcFZhbHVlKjAuNCx0b3BWYWx1ZSowLjYsdG9wVmFsdWUqMC44LHRvcFZhbHVlXTt9O1JHLmdldFNjYWxlMj1mdW5jdGlvbihvYmosb3B0KVxue3ZhciBjYT1vYmouY2FudmFzLGNvPW9iai5jb250ZXh0LHByb3A9b2JqLnByb3BlcnRpZXMsbnVtbGFiZWxzPXR5cGVvZiBvcHRbJ3lsYWJlbHMuY291bnQnXT09J251bWJlcic/b3B0Wyd5bGFiZWxzLmNvdW50J106NSx1bml0c19wcmU9dHlwZW9mIG9wdFsndW5pdHMucHJlJ109PSdzdHJpbmcnP29wdFsndW5pdHMucHJlJ106JycsdW5pdHNfcG9zdD10eXBlb2Ygb3B0Wyd1bml0cy5wb3N0J109PSdzdHJpbmcnP29wdFsndW5pdHMucG9zdCddOicnLG1heD1OdW1iZXIob3B0WydtYXgnXSksbWluPXR5cGVvZiBvcHRbJ21pbiddPT0nbnVtYmVyJz9vcHRbJ21pbiddOjAsc3RyaWN0PW9wdFsnc3RyaWN0J10sZGVjaW1hbHM9TnVtYmVyKG9wdFsnc2NhbGUuZGVjaW1hbHMnXSkscG9pbnQ9b3B0WydzY2FsZS5wb2ludCddLHRob3VzYW5kPW9wdFsnc2NhbGUudGhvdXNhbmQnXSxvcmlnaW5hbF9tYXg9bWF4LHJvdW5kPW9wdFsnc2NhbGUucm91bmQnXSxzY2FsZT17bWF4OjEsbGFiZWxzOltdLHZhbHVlczpbXX1cbmlmKCFtYXgpe3ZhciBtYXg9MTtmb3IodmFyIGk9MDtpPG51bWxhYmVsczsrK2kpe3ZhciBsYWJlbD0oKCgobWF4LW1pbikvbnVtbGFiZWxzKSttaW4pKihpKzEpKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS5sYWJlbHMucHVzaCh1bml0c19wcmUrbGFiZWwrdW5pdHNfcG9zdCk7c2NhbGUudmFsdWVzLnB1c2gocGFyc2VGbG9hdChsYWJlbCkpfX1lbHNlIGlmKG1heDw9MSYmIXN0cmljdCl7dmFyIGFycj1bMSwwLjUsMC4xMCwwLjA1LDAuMDEwLDAuMDA1LDAuMDAxMCwwLjAwMDUsMC4wMDAxMCwwLjAwMDA1LDAuMDAwMDEwLDAuMDAwMDA1LDAuMDAwMDAxMCwwLjAwMDAwMDUsMC4wMDAwMDAxMCwwLjAwMDAwMDA1LDAuMDAwMDAwMDEwLDAuMDAwMDAwMDA1LDAuMDAwMDAwMDAxMCwwLjAwMDAwMDAwMDUsMC4wMDAwMDAwMDAxMCwwLjAwMDAwMDAwMDA1LDAuMDAwMDAwMDAwMDEwLDAuMDAwMDAwMDAwMDA1LDAuMDAwMDAwMDAwMDAxMCwwLjAwMDAwMDAwMDAwMDVdLHZhbHM9W107Zm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoOysraSl7aWYobWF4PmFycltpXSl7aS0tO2JyZWFrO319XG5zY2FsZS5tYXg9YXJyW2ldXG5zY2FsZS5sYWJlbHM9W107c2NhbGUudmFsdWVzPVtdO2Zvcih2YXIgaj0wO2o8bnVtbGFiZWxzOysrail7dmFyIHZhbHVlPSgoKChhcnJbaV0tbWluKS9udW1sYWJlbHMpKihqKzEpKSttaW4pLnRvRml4ZWQoZGVjaW1hbHMpO3NjYWxlLnZhbHVlcy5wdXNoKHZhbHVlKTtzY2FsZS5sYWJlbHMucHVzaChSRy5udW1iZXJGb3JtYXQob2JqLHZhbHVlLHVuaXRzX3ByZSx1bml0c19wb3N0KSk7fX1lbHNlIGlmKCFzdHJpY3Qpe21heD1tYS5jZWlsKG1heCk7dmFyIGludGVydmFsPW1hLnBvdygxMCxtYS5tYXgoMSxOdW1iZXIoU3RyaW5nKE51bWJlcihtYXgpLU51bWJlcihtaW4pKS5sZW5ndGgtMSkpKTt2YXIgdG9wVmFsdWU9aW50ZXJ2YWw7d2hpbGUodG9wVmFsdWU8bWF4KXt0b3BWYWx1ZSs9KGludGVydmFsLzIpO31cbmlmKE51bWJlcihvcmlnaW5hbF9tYXgpPk51bWJlcih0b3BWYWx1ZSkpe3RvcFZhbHVlKz0oaW50ZXJ2YWwvMik7fVxuaWYobWF4PD0xMCl7dG9wVmFsdWU9KE51bWJlcihvcmlnaW5hbF9tYXgpPD01PzU6MTApO31cbmlmKG9iaiYmdHlwZW9mKHJvdW5kKT09J2Jvb2xlYW4nJiZyb3VuZCl7dG9wVmFsdWU9MTAqaW50ZXJ2YWw7fVxuc2NhbGUubWF4PXRvcFZhbHVlO3ZhciB0bXBfcG9pbnQ9cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXTt2YXIgdG1wX3Rob3VzYW5kPXByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ107b2JqLlNldCgnY2hhcnQuc2NhbGUudGhvdXNhbmQnLHRob3VzYW5kKTtvYmouU2V0KCdjaGFydC5zY2FsZS5wb2ludCcscG9pbnQpO2Zvcih2YXIgaT0wO2k8bnVtbGFiZWxzOysraSl7c2NhbGUubGFiZWxzLnB1c2goUkcubnVtYmVyX2Zvcm1hdChvYmosKCgoKGkrMSkvbnVtbGFiZWxzKSoodG9wVmFsdWUtbWluKSkrbWluKS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCkpO3NjYWxlLnZhbHVlcy5wdXNoKCgoKChpKzEpL251bWxhYmVscykqKHRvcFZhbHVlLW1pbikpK21pbikudG9GaXhlZChkZWNpbWFscykpO31cbm9iai5TZXQoJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJyx0bXBfdGhvdXNhbmQpO29iai5TZXQoJ2NoYXJ0LnNjYWxlLnBvaW50Jyx0bXBfcG9pbnQpO31lbHNlIGlmKHR5cGVvZihtYXgpPT0nbnVtYmVyJyYmc3RyaWN0KXtmb3IodmFyIGk9MDtpPG51bWxhYmVsczsrK2kpe3NjYWxlLmxhYmVscy5wdXNoKFJHLm51bWJlckZvcm1hdChvYmosKCgoKGkrMSkvbnVtbGFiZWxzKSoobWF4LW1pbikpK21pbikudG9GaXhlZChkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpKTtzY2FsZS52YWx1ZXMucHVzaCgoKCgoaSsxKS9udW1sYWJlbHMpKihtYXgtbWluKSkrbWluKS50b0ZpeGVkKGRlY2ltYWxzKSk7fVxuc2NhbGUubWF4PW1heDt9XG5zY2FsZS51bml0c19wcmU9dW5pdHNfcHJlO3NjYWxlLnVuaXRzX3Bvc3Q9dW5pdHNfcG9zdDtzY2FsZS5wb2ludD1wb2ludDtzY2FsZS5kZWNpbWFscz1kZWNpbWFscztzY2FsZS50aG91c2FuZD10aG91c2FuZDtzY2FsZS5udW1sYWJlbHM9bnVtbGFiZWxzO3NjYWxlLnJvdW5kPUJvb2xlYW4ocm91bmQpO3NjYWxlLm1pbj1taW47Zm9yKHZhciBpPTA7aTxzY2FsZS52YWx1ZXMubGVuZ3RoOysraSl7c2NhbGUudmFsdWVzW2ldPXBhcnNlRmxvYXQoc2NhbGUudmFsdWVzW2ldKTt9XG5yZXR1cm4gc2NhbGU7fTtSRy5hcnJheUludmVydD1mdW5jdGlvbihhcnIpXG57Zm9yKHZhciBpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47KytpKXthcnJbaV09IWFycltpXTt9XG5yZXR1cm4gYXJyO307UkcuYXJyYXlUcmltPWZ1bmN0aW9uKGFycilcbnt2YXIgb3V0PVtdLGNvbnRlbnQ9ZmFsc2U7Zm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7aWYoYXJyW2ldKXtjb250ZW50PXRydWU7fVxuaWYoY29udGVudCl7b3V0LnB1c2goYXJyW2ldKTt9fVxub3V0PVJHLmFycmF5UmV2ZXJzZShvdXQpO3ZhciBvdXQyPVtdLGNvbnRlbnQ9ZmFsc2U7Zm9yKHZhciBpPTA7aTxvdXQubGVuZ3RoO2krKyl7aWYob3V0W2ldKXtjb250ZW50PXRydWU7fVxuaWYoY29udGVudCl7b3V0Mi5wdXNoKG91dFtpXSk7fX1cbm91dDI9UkcuYXJyYXlSZXZlcnNlKG91dDIpO3JldHVybiBvdXQyO307UkcuYXJyYXlDbG9uZT1SRy5hcnJheV9jbG9uZT1mdW5jdGlvbihvYmopXG57aWYob2JqPT09bnVsbHx8dHlwZW9mIG9iaiE9PSdvYmplY3QnKXtyZXR1cm4gb2JqO31cbnZhciB0ZW1wPVtdO2Zvcih2YXIgaT0wLGxlbj1vYmoubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mIG9ialtpXT09PSdudW1iZXInKXt0ZW1wW2ldPShmdW5jdGlvbihhcmcpe3JldHVybiBOdW1iZXIoYXJnKTt9KShvYmpbaV0pO31lbHNlIGlmKHR5cGVvZiBvYmpbaV09PT0nc3RyaW5nJyl7dGVtcFtpXT0oZnVuY3Rpb24oYXJnKXtyZXR1cm4gU3RyaW5nKGFyZyk7fSkob2JqW2ldKTt9ZWxzZSBpZih0eXBlb2Ygb2JqW2ldPT09J2Z1bmN0aW9uJyl7dGVtcFtpXT1vYmpbaV07fWVsc2V7dGVtcFtpXT1SRy5hcnJheUNsb25lKG9ialtpXSk7fX1cbnJldHVybiB0ZW1wO307UkcuYXJyYXlNYXg9UkcuYXJyYXlfbWF4PWZ1bmN0aW9uKGFycilcbnt2YXIgbWF4PW51bGwsbWE9TWF0aFxuaWYodHlwZW9mIGFycj09PSdudW1iZXInKXtyZXR1cm4gYXJyO31cbmlmKFJHLmlzTnVsbChhcnIpKXtyZXR1cm4gMDt9XG5mb3IodmFyIGk9MCxsZW49YXJyLmxlbmd0aDtpPGxlbjsrK2kpe2lmKHR5cGVvZiBhcnJbaV09PT0nbnVtYmVyJyl7dmFyIHZhbD1hcmd1bWVudHNbMV0/bWEuYWJzKGFycltpXSk6YXJyW2ldO2lmKHR5cGVvZiBtYXg9PT0nbnVtYmVyJyl7bWF4PW1hLm1heChtYXgsdmFsKTt9ZWxzZXttYXg9dmFsO319fVxucmV0dXJuIG1heDt9O1JHLmFycmF5TWluPWZ1bmN0aW9uKGFycilcbnt2YXIgbWF4PW51bGwsbWluPW51bGwsbWE9TWF0aDtpZih0eXBlb2YgYXJyPT09J251bWJlcicpe3JldHVybiBhcnI7fVxuaWYoUkcuaXNOdWxsKGFycikpe3JldHVybiAwO31cbmZvcih2YXIgaT0wLGxlbj1hcnIubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mIGFycltpXT09PSdudW1iZXInKXt2YXIgdmFsPWFyZ3VtZW50c1sxXT9tYS5hYnMoYXJyW2ldKTphcnJbaV07aWYodHlwZW9mIG1pbj09PSdudW1iZXInKXttaW49bWEubWluKG1pbix2YWwpO31lbHNle21pbj12YWw7fX19XG5yZXR1cm4gbWluO307UkcuYXJyYXlQYWQ9UkcuYXJyYXlfcGFkPWZ1bmN0aW9uKGFycixsZW4pXG57aWYoYXJyLmxlbmd0aDxsZW4pe3ZhciB2YWw9YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO2Zvcih2YXIgaT1hcnIubGVuZ3RoO2k8bGVuO2krPTEpe2FycltpXT12YWw7fX1cbnJldHVybiBhcnI7fTtSRy5hcnJheVN1bT1SRy5hcnJheV9zdW09ZnVuY3Rpb24oYXJyKVxue2lmKHR5cGVvZiBhcnI9PT0nbnVtYmVyJyl7cmV0dXJuIGFycjt9XG5pZihSRy5pc19udWxsKGFycikpe3JldHVybiAwO31cbnZhciBpLHN1bSxsZW49YXJyLmxlbmd0aDtmb3IoaT0wLHN1bT0wO2k8bGVuO3N1bSs9YXJyW2krK10pO3JldHVybiBzdW07fTtSRy5hcnJheUxpbmVhcml6ZT1SRy5hcnJheV9saW5lYXJpemU9ZnVuY3Rpb24oKVxue3ZhciBhcnI9W10sYXJncz1hcmd1bWVudHNcbmZvcih2YXIgaT0wLGxlbj1hcmdzLmxlbmd0aDtpPGxlbjsrK2kpe2lmKHR5cGVvZiBhcmdzW2ldPT09J29iamVjdCcmJmFyZ3NbaV0pe2Zvcih2YXIgaj0wLGxlbjI9YXJnc1tpXS5sZW5ndGg7ajxsZW4yOysrail7dmFyIHN1Yj1SRy5hcnJheV9saW5lYXJpemUoYXJnc1tpXVtqXSk7Zm9yKHZhciBrPTAsbGVuMz1zdWIubGVuZ3RoO2s8bGVuMzsrK2spe2Fyci5wdXNoKHN1YltrXSk7fX19ZWxzZXthcnIucHVzaChhcmdzW2ldKTt9fVxucmV0dXJuIGFycjt9O1JHLmFycmF5U2hpZnQ9UkcuYXJyYXlfc2hpZnQ9ZnVuY3Rpb24oYXJyKVxue3ZhciByZXQ9W107Zm9yKHZhciBpPTEsbGVuPWFyci5sZW5ndGg7aTxsZW47KytpKXtyZXQucHVzaChhcnJbaV0pO31cbnJldHVybiByZXQ7fTtSRy5hcnJheVJldmVyc2U9UkcuYXJyYXlfcmV2ZXJzZT1mdW5jdGlvbihhcnIpXG57aWYoIWFycil7cmV0dXJuO31cbnZhciBuZXdhcnI9W107Zm9yKHZhciBpPWFyci5sZW5ndGgtMTtpPj0wO2ktPTEpe25ld2Fyci5wdXNoKGFycltpXSk7fVxucmV0dXJuIG5ld2Fycjt9O1JHLmFicz1mdW5jdGlvbih2YWx1ZSlcbntpZih0eXBlb2YgdmFsdWU9PT0nc3RyaW5nJyl7dmFsdWU9cGFyc2VGbG9hdCh2YWx1ZSl8fDA7fVxuaWYodHlwZW9mIHZhbHVlPT09J251bWJlcicpe3JldHVybiBtYS5hYnModmFsdWUpO31cbmlmKHR5cGVvZiB2YWx1ZT09PSdvYmplY3QnKXtmb3IoaSBpbiB2YWx1ZSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJ3x8dHlwZW9mIGk9PT0nbnVtYmVyJ3x8dHlwZW9mIGk9PT0nb2JqZWN0Jyl7dmFsdWVbaV09UkcuYWJzKHZhbHVlW2ldKTt9fVxucmV0dXJuIHZhbHVlO31cbnJldHVybiAwO307UkcuY2xlYXI9UkcuQ2xlYXI9ZnVuY3Rpb24oY2EpXG57dmFyIG9iaj1jYS5fX29iamVjdF9fLGNvPWNhLmdldENvbnRleHQoJzJkJyksY29sb3I9YXJndW1lbnRzWzFdfHwob2JqJiZvYmouZ2V0KCdjbGVhcnRvJykpXG5pZighY2Epe3JldHVybjt9XG5SRy5maXJlQ3VzdG9tRXZlbnQob2JqLCdvbmJlZm9yZWNsZWFyJyk7aWYoUkcudGV4dDIuZG9tTm9kZUNhY2hlJiZSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbY2EuaWRdKXtmb3IodmFyIGkgaW4gUkcudGV4dDIuZG9tTm9kZUNhY2hlW2NhLmlkXSl7dmFyIGVsPVJHLnRleHQyLmRvbU5vZGVDYWNoZVtjYS5pZF1baV07aWYoZWwmJmVsLnN0eWxlKXtlbC5zdHlsZS5kaXNwbGF5PSdub25lJzt9fX1cbmlmKCFjb2xvcnx8KGNvbG9yJiZjb2xvcj09PSdyZ2JhKDAsMCwwLDApJ3x8Y29sb3I9PT0ndHJhbnNwYXJlbnQnKSl7Y28uY2xlYXJSZWN0KC0xMDAsLTEwMCxjYS53aWR0aCsyMDAsY2EuaGVpZ2h0KzIwMCk7Y28uZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPSdzb3VyY2Utb3Zlcic7fWVsc2UgaWYoY29sb3Ipe1JHLnBhdGgyKGNvLCdmcyAlIGZyIC0xMDAgLTEwMCAlICUnLGNvbG9yLGNhLndpZHRoKzIwMCxjYS5oZWlnaHQrMjAwKTt9ZWxzZXtSRy5wYXRoMihjbywnZnMgJSBmciAtMTAwIC0xMDAgJSAlJyxvYmouZ2V0KCdjbGVhcnRvJyksY2Eud2lkdGgrMjAwLGNhLmhlaWdodCsyMDApO31cbmlmKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS4nK2NhLmlkKSl7dmFyIGltZz1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuJytjYS5pZCk7aW1nLnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7aW1nLnN0eWxlLmxlZnQ9Jy0xMDAwMHB4JztpbWcuc3R5bGUudG9wPSctMTAwMDBweCc7fVxuaWYoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwJykmJm9iaiYmIW9iai5nZXQoJ2NoYXJ0LnRvb2x0aXBzLm5vaGlkZW9uY2xlYXInKSl7UkcuSGlkZVRvb2x0aXAoY2EpO31cbmNhLnN0eWxlLmN1cnNvcj0nZGVmYXVsdCc7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25jbGVhcicpO307UkcuZHJhd1RpdGxlPVJHLkRyYXdUaXRsZT1mdW5jdGlvbihvYmosdGV4dCxndXR0ZXJUb3ApXG57dmFyIGNhPWNhbnZhcz1vYmouY2FudmFzLGNvPWNvbnRleHQ9b2JqLmNvbnRleHQscHJvcD1vYmoucHJvcGVydGllc1xuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLGd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLGd1dHRlclRvcD1ndXR0ZXJUb3AsZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSxzaXplPWFyZ3VtZW50c1s0XT9hcmd1bWVudHNbNF06MTIsYm9sZD1wcm9wWydjaGFydC50aXRsZS5ib2xkJ10saXRhbGljPXByb3BbJ2NoYXJ0LnRpdGxlLml0YWxpYyddLGNlbnRlcng9KGFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106KChjYS53aWR0aC1ndXR0ZXJMZWZ0LWd1dHRlclJpZ2h0KS8yKStndXR0ZXJMZWZ0KSxrZXlwb3M9cHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uJ10sdnBvcz1wcm9wWydjaGFydC50aXRsZS52cG9zJ10saHBvcz1wcm9wWydjaGFydC50aXRsZS5ocG9zJ10sYmdjb2xvcj1wcm9wWydjaGFydC50aXRsZS5iYWNrZ3JvdW5kJ10seD1wcm9wWydjaGFydC50aXRsZS54J10seT1wcm9wWydjaGFydC50aXRsZS55J10saGFsaWduPSdjZW50ZXInLHZhbGlnbj0nY2VudGVyJ1xuaWYob2JqLnR5cGU9PSdiYXInJiZwcm9wWydjaGFydC52YXJpYW50J109PSczZCcpe2tleXBvcz0nZ3V0dGVyJzt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddP3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXTonYmxhY2snO2lmKGtleXBvcyYma2V5cG9zIT0nZ3V0dGVyJyl7dmFyIHZhbGlnbj0nY2VudGVyJzt9ZWxzZSBpZigha2V5cG9zKXt2YXIgdmFsaWduPSdjZW50ZXInO31lbHNle3ZhciB2YWxpZ249J2JvdHRvbSc7fVxuaWYodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnZwb3MnXT09PSdudW1iZXInKXt2cG9zPXByb3BbJ2NoYXJ0LnRpdGxlLnZwb3MnXSpndXR0ZXJUb3A7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09PSd0b3AnKXt2cG9zPXByb3BbJ2NoYXJ0LnRpdGxlLnZwb3MnXSpndXR0ZXJCb3R0b20rZ3V0dGVyVG9wKyhjYS5oZWlnaHQtZ3V0dGVyVG9wLWd1dHRlckJvdHRvbSk7fX1lbHNle3Zwb3M9Z3V0dGVyVG9wLXNpemUtNTtpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT09J3RvcCcpe3Zwb3M9Y2EuaGVpZ2h0LWd1dHRlckJvdHRvbStzaXplKzU7fX1cbmlmKHR5cGVvZiBocG9zPT09J251bWJlcicpe2NlbnRlcng9aHBvcypjYS53aWR0aDt9XG5pZih0eXBlb2YgeD09PSdudW1iZXInKWNlbnRlcng9eDtpZih0eXBlb2YgeT09PSdudW1iZXInKXZwb3M9eTtpZih0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUuaGFsaWduJ109PT0nc3RyaW5nJyl7aGFsaWduPXByb3BbJ2NoYXJ0LnRpdGxlLmhhbGlnbiddO31cbmlmKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS52YWxpZ24nXT09PSdzdHJpbmcnKXt2YWxpZ249cHJvcFsnY2hhcnQudGl0bGUudmFsaWduJ107fVxuaWYodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10hPT1udWxsKXt2YXIgb2xkQ29sb3I9Y28uZmlsbFN0eWxlXG52YXIgbmV3Q29sb3I9cHJvcFsnY2hhcnQudGl0bGUuY29sb3InXTtjby5maWxsU3R5bGU9bmV3Q29sb3I/bmV3Q29sb3I6J2JsYWNrJzt9XG52YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTtpZih0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUuZm9udCddPT09J3N0cmluZycpe2ZvbnQ9cHJvcFsnY2hhcnQudGl0bGUuZm9udCddO31cbnZhciByZXQ9UkcudGV4dDIob2JqLHtmb250OmZvbnQsc2l6ZTpzaXplLHg6Y2VudGVyeCx5OnZwb3MsdGV4dDp0ZXh0LHZhbGlnbjp2YWxpZ24saGFsaWduOmhhbGlnbixib3VuZGluZzpiZ2NvbG9yIT1udWxsLCdib3VuZGluZy5maWxsJzpiZ2NvbG9yLCdib2xkJzpib2xkLGl0YWxpYzppdGFsaWMsdGFnOid0aXRsZScsbWFya2VyOmZhbHNlfSk7Y28uZmlsbFN0eWxlPW9sZENvbG9yO307UkcuZ2V0TW91c2VYWT1mdW5jdGlvbihlKVxue2lmKCFlLnRhcmdldCl7cmV0dXJuO31cbnZhciBlbD1lLnRhcmdldDt2YXIgY2E9ZWw7dmFyIGNhU3R5bGU9Y2Euc3R5bGU7dmFyIG9mZnNldFg9MDt2YXIgb2Zmc2V0WT0wO3ZhciB4O3ZhciB5O3ZhciBib3JkZXJMZWZ0PXBhcnNlSW50KGNhU3R5bGUuYm9yZGVyTGVmdFdpZHRoKXx8MDt2YXIgYm9yZGVyVG9wPXBhcnNlSW50KGNhU3R5bGUuYm9yZGVyVG9wV2lkdGgpfHwwO3ZhciBwYWRkaW5nTGVmdD1wYXJzZUludChjYVN0eWxlLnBhZGRpbmdMZWZ0KXx8MFxudmFyIHBhZGRpbmdUb3A9cGFyc2VJbnQoY2FTdHlsZS5wYWRkaW5nVG9wKXx8MFxudmFyIGFkZGl0aW9uYWxYPWJvcmRlckxlZnQrcGFkZGluZ0xlZnQ7dmFyIGFkZGl0aW9uYWxZPWJvcmRlclRvcCtwYWRkaW5nVG9wO2lmKHR5cGVvZiBlLm9mZnNldFg9PT0nbnVtYmVyJyYmdHlwZW9mIGUub2Zmc2V0WT09PSdudW1iZXInKXtpZighUkcuSVNJRSYmIVJHLklTT1BFUkEpe3g9ZS5vZmZzZXRYLWJvcmRlckxlZnQtcGFkZGluZ0xlZnQ7eT1lLm9mZnNldFktYm9yZGVyVG9wLXBhZGRpbmdUb3A7fWVsc2UgaWYoUkcuSVNJRSl7eD1lLm9mZnNldFgtcGFkZGluZ0xlZnQ7eT1lLm9mZnNldFktcGFkZGluZ1RvcDt9ZWxzZXt4PWUub2Zmc2V0WDt5PWUub2Zmc2V0WTt9fWVsc2V7aWYodHlwZW9mIGVsLm9mZnNldFBhcmVudCE9PSd1bmRlZmluZWQnKXtkb3tvZmZzZXRYKz1lbC5vZmZzZXRMZWZ0O29mZnNldFkrPWVsLm9mZnNldFRvcDt9d2hpbGUoKGVsPWVsLm9mZnNldFBhcmVudCkpO31cbng9ZS5wYWdlWC1vZmZzZXRYLWFkZGl0aW9uYWxYO3k9ZS5wYWdlWS1vZmZzZXRZLWFkZGl0aW9uYWxZO3gtPSgyKihwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmJvcmRlckxlZnRXaWR0aCl8fDApKTt5LT0oMioocGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJUb3BXaWR0aCl8fDApKTt9XG5yZXR1cm5beCx5XTt9O1JHLmdldENhbnZhc1hZPWZ1bmN0aW9uKGNhbnZhcylcbnt2YXIgeD0wO3ZhciB5PTA7dmFyIGVsPWNhbnZhcztkb3t4Kz1lbC5vZmZzZXRMZWZ0O3krPWVsLm9mZnNldFRvcDtpZihlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PSd0YWJsZScmJihSRy5JU0NIUk9NRXx8UkcuSVNTQUZBUkkpKXt4Kz1wYXJzZUludChlbC5ib3JkZXIpfHwwO3krPXBhcnNlSW50KGVsLmJvcmRlcil8fDA7fVxuZWw9ZWwub2Zmc2V0UGFyZW50O313aGlsZShlbCYmZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpIT0nYm9keScpO3ZhciBwYWRkaW5nTGVmdD1jYW52YXMuc3R5bGUucGFkZGluZ0xlZnQ/cGFyc2VJbnQoY2FudmFzLnN0eWxlLnBhZGRpbmdMZWZ0KTowO3ZhciBwYWRkaW5nVG9wPWNhbnZhcy5zdHlsZS5wYWRkaW5nVG9wP3BhcnNlSW50KGNhbnZhcy5zdHlsZS5wYWRkaW5nVG9wKTowO3ZhciBib3JkZXJMZWZ0PWNhbnZhcy5zdHlsZS5ib3JkZXJMZWZ0V2lkdGg/cGFyc2VJbnQoY2FudmFzLnN0eWxlLmJvcmRlckxlZnRXaWR0aCk6MDt2YXIgYm9yZGVyVG9wPWNhbnZhcy5zdHlsZS5ib3JkZXJUb3BXaWR0aD9wYXJzZUludChjYW52YXMuc3R5bGUuYm9yZGVyVG9wV2lkdGgpOjA7aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+MCl7eCs9cGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpfHwwO3krPXBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUuYm9yZGVyVG9wV2lkdGgpfHwwO31cbnJldHVyblt4K3BhZGRpbmdMZWZ0K2JvcmRlckxlZnQseStwYWRkaW5nVG9wK2JvcmRlclRvcF07fTtSRy5pc0ZpeGVkPWZ1bmN0aW9uKGNhbnZhcylcbnt2YXIgb2JqPWNhbnZhczt2YXIgaT0wO3doaWxlKG9iaiYmb2JqLnRhZ05hbWUudG9Mb3dlckNhc2UoKSE9J2JvZHknJiZpPDk5KXtpZihvYmouc3R5bGUucG9zaXRpb249PSdmaXhlZCcpe3JldHVybiBvYmo7fVxub2JqPW9iai5vZmZzZXRQYXJlbnQ7fVxucmV0dXJuIGZhbHNlO307UkcucmVnaXN0ZXI9UkcuUmVnaXN0ZXI9ZnVuY3Rpb24ob2JqKVxue2lmKCFvYmouR2V0KCdjaGFydC5ub3JlZ2lzdGVyJykpe1JHcmFwaC5PYmplY3RSZWdpc3RyeS5BZGQob2JqKTtvYmouU2V0KCdjaGFydC5ub3JlZ2lzdGVyJyx0cnVlKTt9fTtSRy5yZWRyYXc9UkcuUmVkcmF3PWZ1bmN0aW9uKClcbnt2YXIgb2JqZWN0UmVnaXN0cnk9UkdyYXBoLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRDt2YXIgdGFncz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7Zm9yKHZhciBpPTAsbGVuPXRhZ3MubGVuZ3RoO2k8bGVuOysraSl7aWYodGFnc1tpXS5fX29iamVjdF9fJiZ0YWdzW2ldLl9fb2JqZWN0X18uaXNSR3JhcGgpe2lmKCF0YWdzW2ldLm5vY2xlYXIpe1JHcmFwaC5jbGVhcih0YWdzW2ldLGFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCk7fX19XG5mb3IodmFyIGk9MCxsZW49b2JqZWN0UmVnaXN0cnkubGVuZ3RoO2k8bGVuOysraSl7aWYob2JqZWN0UmVnaXN0cnlbaV0pe3ZhciBpZD1vYmplY3RSZWdpc3RyeVtpXVswXTtvYmplY3RSZWdpc3RyeVtpXVsxXS5EcmF3KCk7fX19O1JHLnJlZHJhd0NhbnZhcz1SRy5SZWRyYXdDYW52YXM9ZnVuY3Rpb24oY2EpXG57dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoY2EuaWQpO2lmKCFhcmd1bWVudHNbMV18fCh0eXBlb2YgYXJndW1lbnRzWzFdPT09J2Jvb2xlYW4nJiYhYXJndW1lbnRzWzFdPT1mYWxzZSkpe3ZhciBjb2xvcj1hcmd1bWVudHNbMl18fGNhLl9fb2JqZWN0X18uZ2V0KCdjbGVhcnRvJyl8fCd0cmFuc3BhcmVudCc7UkcuY2xlYXIoY2EsY29sb3IpO31cbmZvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjsrK2kpe2lmKG9iamVjdHNbaV0pe2lmKG9iamVjdHNbaV0mJm9iamVjdHNbaV0uaXNSR3JhcGgpe29iamVjdHNbaV0uRHJhdygpO319fX07UkcuQmFja2dyb3VuZC5kcmF3PVJHLmJhY2tncm91bmQuZHJhdz1SRy5iYWNrZ3JvdW5kLkRyYXc9ZnVuY3Rpb24ob2JqKVxue3ZhciBjYT1vYmouY2FudmFzLGNvPW9iai5jb250ZXh0LHByb3A9b2JqLnByb3BlcnRpZXMsaGVpZ2h0PTAsZ3V0dGVyTGVmdD1vYmouZ3V0dGVyTGVmdCxndXR0ZXJSaWdodD1vYmouZ3V0dGVyUmlnaHQsZ3V0dGVyVG9wPW9iai5ndXR0ZXJUb3AsZ3V0dGVyQm90dG9tPW9iai5ndXR0ZXJCb3R0b20sdmFyaWFudD1wcm9wWydjaGFydC52YXJpYW50J11cbmNvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYodmFyaWFudD09JzNkJyl7Y28uc2F2ZSgpO2NvLnRyYW5zbGF0ZShwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sLTEqcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTt9XG5pZih0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMnXT09PSdzdHJpbmcnJiZwcm9wWydjaGFydC50aXRsZS54YXhpcyddLmxlbmd0aCl7dmFyIHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMjt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgYm9sZD1wcm9wWydjaGFydC50aXRsZS54YXhpcy5ib2xkJ107aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnXSk9PSdudW1iZXInKXtzaXplPXByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnXTt9XG5pZih0eXBlb2YocHJvcFsnY2hhcnQudGl0bGUueGF4aXMuZm9udCddKT09J3N0cmluZycpe2ZvbnQ9cHJvcFsnY2hhcnQudGl0bGUueGF4aXMuZm9udCddO31cbnZhciBocG9zPSgoY2Eud2lkdGgtZ3V0dGVyTGVmdC1ndXR0ZXJSaWdodCkvMikrZ3V0dGVyTGVmdDt2YXIgdnBvcz1jYS5oZWlnaHQtZ3V0dGVyQm90dG9tKzI1O2lmKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS54YXhpcy5wb3MnXT09PSdudW1iZXInKXt2cG9zPWNhLmhlaWdodC0oZ3V0dGVyQm90dG9tKnByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzLnBvcyddKTt9XG5pZih0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMueCddPT09J251bWJlcicpe2hwb3M9cHJvcFsnY2hhcnQudGl0bGUueGF4aXMueCddO31cbmlmKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS54YXhpcy55J109PT0nbnVtYmVyJyl7dnBvcz1wcm9wWydjaGFydC50aXRsZS54YXhpcy55J107fVxuUkcudGV4dDIocHJvcFsnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJ10/b2JqLmNvbnRleHQ6Y28se2ZvbnQ6Zm9udCxzaXplOnNpemUseDpocG9zLHk6dnBvcyx0ZXh0OnByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzJ10saGFsaWduOidjZW50ZXInLHZhbGlnbjonY2VudGVyJyxib2xkOmJvbGQsY29sb3I6cHJvcFsnY2hhcnQudGl0bGUueGF4aXMuY29sb3InXXx8J2JsYWNrJyx0YWc6J3RpdGxlIHhheGlzJ30pO31cbmlmKHR5cGVvZihwcm9wWydjaGFydC50aXRsZS55YXhpcyddKT09J3N0cmluZycmJnByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzJ10ubGVuZ3RoKXt2YXIgc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSsyO3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciBhbmdsZT0yNzA7dmFyIGJvbGQ9cHJvcFsnY2hhcnQudGl0bGUueWF4aXMuYm9sZCddO3ZhciBjb2xvcj1wcm9wWydjaGFydC50aXRsZS55YXhpcy5jb2xvciddO2lmKHR5cGVvZihwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3MnXSk9PSdudW1iZXInKXt2YXIgeWF4aXNfdGl0bGVfcG9zPXByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnBvcyddKmd1dHRlckxlZnQ7fWVsc2V7dmFyIHlheGlzX3RpdGxlX3Bvcz0oKGd1dHRlckxlZnQtMjUpL2d1dHRlckxlZnQpKmd1dHRlckxlZnQ7fVxuaWYodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnXT09PSdudW1iZXInKXtzaXplPXByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnXTt9XG5pZih0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueWF4aXMuZm9udCddPT09J3N0cmluZycpe2ZvbnQ9cHJvcFsnY2hhcnQudGl0bGUueWF4aXMuZm9udCddO31cbmlmKHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLmFsaWduJ109PSdyaWdodCd8fHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnBvc2l0aW9uJ109PSdyaWdodCd8fChvYmoudHlwZT09PSdoYmFyJyYmcHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdyaWdodCcmJnR5cGVvZiBwcm9wWydjaGFydC50aXRsZS55YXhpcy5hbGlnbiddPT09J3VuZGVmaW5lZCcmJnR5cGVvZiBwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3NpdGlvbiddPT09J3VuZGVmaW5lZCcpKXthbmdsZT05MDt5YXhpc190aXRsZV9wb3M9cHJvcFsnY2hhcnQudGl0bGUueWF4aXMucG9zJ10/KGNhLndpZHRoLWd1dHRlclJpZ2h0KSsocHJvcFsnY2hhcnQudGl0bGUueWF4aXMucG9zJ10qZ3V0dGVyUmlnaHQpOmNhLndpZHRoLWd1dHRlclJpZ2h0K3Byb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKzU7fWVsc2V7eWF4aXNfdGl0bGVfcG9zPXlheGlzX3RpdGxlX3Bvczt9XG52YXIgeT0oKGNhLmhlaWdodC1ndXR0ZXJUb3AtZ3V0dGVyQm90dG9tKS8yKStndXR0ZXJUb3A7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLngnXT09PSdudW1iZXInKXt5YXhpc190aXRsZV9wb3M9cHJvcFsnY2hhcnQudGl0bGUueWF4aXMueCddO31cbmlmKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS55YXhpcy55J109PT0nbnVtYmVyJyl7eT1wcm9wWydjaGFydC50aXRsZS55YXhpcy55J107fVxuY28uZmlsbFN0eWxlPWNvbG9yO1JHLnRleHQyKHByb3BbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddP29iai5jb250ZXh0OmNvLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eWF4aXNfdGl0bGVfcG9zLCd5Jzp5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdhbmdsZSc6YW5nbGUsJ2JvbGQnOmJvbGQsJ3RleHQnOnByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzJ10sJ3RhZyc6J3RpdGxlIHlheGlzJyxhY2Nlc3NpYmxlOmZhbHNlfSk7fVxudmFyIGJnY29sb3I9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2lmKGJnY29sb3Ipe2NvLmZpbGxTdHlsZT1iZ2NvbG9yO2NvLmZpbGxSZWN0KGd1dHRlckxlZnQrMC41LGd1dHRlclRvcCswLjUsY2Eud2lkdGgtZ3V0dGVyTGVmdC1ndXR0ZXJSaWdodCxjYS5oZWlnaHQtZ3V0dGVyVG9wLWd1dHRlckJvdHRvbSk7fVxudmFyIG51bWJhcnM9KHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXXx8NSk7dmFyIGJhckhlaWdodD0oY2EuaGVpZ2h0LWd1dHRlckJvdHRvbS1ndXR0ZXJUb3ApL251bWJhcnM7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ107Y28uc3Ryb2tlU3R5bGU9Y28uZmlsbFN0eWxlO2hlaWdodD0oY2EuaGVpZ2h0LWd1dHRlckJvdHRvbSk7Zm9yKHZhciBpPTA7aTxudW1iYXJzO2krPTIpe2NvLnJlY3QoZ3V0dGVyTGVmdCwoaSpiYXJIZWlnaHQpK2d1dHRlclRvcCxjYS53aWR0aC1ndXR0ZXJMZWZ0LWd1dHRlclJpZ2h0LGJhckhlaWdodCk7fVxuY28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddO2NvLnN0cm9rZVN0eWxlPWNvLmZpbGxTdHlsZTtmb3IodmFyIGk9MTtpPG51bWJhcnM7aSs9Mil7Y28ucmVjdChndXR0ZXJMZWZ0LChpKmJhckhlaWdodCkrZ3V0dGVyVG9wLGNhLndpZHRoLWd1dHRlckxlZnQtZ3V0dGVyUmlnaHQsYmFySGVpZ2h0KTt9XG5jby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7dmFyIGZ1bmM9ZnVuY3Rpb24ob2JqLGNhY2hlQ2FudmFzLGNhY2hlQ29udGV4dClcbntpZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQnXSl7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJ10rPTAuMDAwMTtpZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdCddKXtpZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbiddKXtpZihvYmoudHlwZT09PSdoYmFyJyl7b2JqLnNldCgnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJyxvYmouZGF0YS5sZW5ndGgpO31cbmlmKG9iai50eXBlPT09J2xpbmUnKXtpZih0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJ109PT0nbnVtYmVyJyl7fWVsc2UgaWYocHJvcFsnY2hhcnQubGFiZWxzJ10mJnByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCl7b2JqLlNldCgnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJyxwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgtMSk7fWVsc2V7b2JqLlNldCgnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJyxvYmouZGF0YVswXS5sZW5ndGgtMSk7fX1lbHNlIGlmKG9iai50eXBlPT09J3dhdGVyZmFsbCcpe29iai5zZXQoJ2JhY2tncm91bmRHcmlkQXV0b2ZpdE51bXZsaW5lcycsb2JqLmRhdGEubGVuZ3RoKyhwcm9wWydjaGFydC50b3RhbCddPzE6MCkpO31lbHNlIGlmKChvYmoudHlwZT09PSdiYXInfHxvYmoudHlwZT09PSdzY2F0dGVyJykmJigocHJvcFsnY2hhcnQubGFiZWxzJ10mJnByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCl8fG9iai50eXBlPT09J2JhcicpKXt2YXIgbGVuPShwcm9wWydjaGFydC5sYWJlbHMnXSYmcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoKXx8b2JqLmRhdGEubGVuZ3RoO29iai5zZXQoe2JhY2tncm91bmRHcmlkQXV0b2ZpdE51bXZsaW5lczpsZW59KTt9ZWxzZSBpZihvYmoudHlwZT09PSdnYW50dCcpe2lmKHR5cGVvZiBvYmouZ2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnKT09PSdudW1iZXInKXt9ZWxzZXtvYmouc2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnLHByb3BbJ2NoYXJ0LnhtYXgnXSk7fVxub2JqLnNldCgnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJyxvYmouZGF0YS5sZW5ndGgpO31lbHNlIGlmKG9iai50eXBlPT09J2hiYXInJiZSRy5pc051bGwocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJ10pKXtvYmouc2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnLG9iai5kYXRhLmxlbmd0aCk7fX1cbnZhciB2c2l6ZT0oKGNhY2hlQ2FudmFzLndpZHRoLWd1dHRlckxlZnQtZ3V0dGVyUmlnaHQpKS9wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnXTt2YXIgaHNpemU9KGNhY2hlQ2FudmFzLmhlaWdodC1ndXR0ZXJUb3AtZ3V0dGVyQm90dG9tKS9wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnXTtvYmouU2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudnNpemUnLHZzaXplKTtvYmouU2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnLGhzaXplKTt9XG5jby5iZWdpblBhdGgoKTtjYWNoZUNvbnRleHQubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCddP3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCddOjE7Y2FjaGVDb250ZXh0LnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kYXNoZWQnXSYmdHlwZW9mIGNhY2hlQ29udGV4dC5zZXRMaW5lRGFzaD09J2Z1bmN0aW9uJyl7Y2FjaGVDb250ZXh0LnNldExpbmVEYXNoKFszLDVdKTt9XG5pZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZG90dGVkJ10mJnR5cGVvZiBjYWNoZUNvbnRleHQuc2V0TGluZURhc2g9PSdmdW5jdGlvbicpe2NhY2hlQ29udGV4dC5zZXRMaW5lRGFzaChbMSwzXSk7fVxuY28uYmVnaW5QYXRoKCk7aWYocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyddKXtoZWlnaHQ9KGNhY2hlQ2FudmFzLmhlaWdodC1ndXR0ZXJCb3R0b20pXG52YXIgaHNpemU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhzaXplJ107Zm9yKHk9Z3V0dGVyVG9wO3k8PWhlaWdodDt5Kz1oc2l6ZSl7Y2FjaGVDb250ZXh0Lm1vdmVUbyhndXR0ZXJMZWZ0LG1hLnJvdW5kKHkpKTtjYWNoZUNvbnRleHQubGluZVRvKGNhLndpZHRoLWd1dHRlclJpZ2h0LG1hLnJvdW5kKHkpKTt9fVxuaWYocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyddKXt2YXIgd2lkdGg9KGNhY2hlQ2FudmFzLndpZHRoLWd1dHRlclJpZ2h0KTt2YXIgdnNpemU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZzaXplJ107Zm9yKHg9Z3V0dGVyTGVmdDttYS5yb3VuZCh4KTw9d2lkdGg7eCs9dnNpemUpe2NhY2hlQ29udGV4dC5tb3ZlVG8obWEucm91bmQoeCksZ3V0dGVyVG9wKTtjYWNoZUNvbnRleHQubGluZVRvKG1hLnJvdW5kKHgpLGNhLmhlaWdodC1ndXR0ZXJCb3R0b20pO319XG5pZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYm9yZGVyJ10pe2NhY2hlQ29udGV4dC5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXTtjYWNoZUNvbnRleHQuc3Ryb2tlUmVjdChtYS5yb3VuZChndXR0ZXJMZWZ0KSxtYS5yb3VuZChndXR0ZXJUb3ApLGNhLndpZHRoLWd1dHRlckxlZnQtZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LWd1dHRlclRvcC1ndXR0ZXJCb3R0b20pO319XG5jYWNoZUNvbnRleHQuc3Ryb2tlKCk7Y2FjaGVDb250ZXh0LmJlZ2luUGF0aCgpO2NhY2hlQ29udGV4dC5jbG9zZVBhdGgoKTt9XG5SRy5jYWNoZWREcmF3KG9iaixvYmoudWlkKydfYmFja2dyb3VuZCcsZnVuYyk7aWYodmFyaWFudD09JzNkJyl7Y28ucmVzdG9yZSgpO31cbmlmKHR5cGVvZiBjby5zZXRMaW5lRGFzaD09J2Z1bmN0aW9uJyl7Y28uc2V0TGluZURhc2goWzEsMF0pO31cbmNvLnN0cm9rZSgpO2lmKHR5cGVvZihvYmoucHJvcGVydGllc1snY2hhcnQudGl0bGUnXSk9PSdzdHJpbmcnKXt2YXIgcHJvcD1vYmoucHJvcGVydGllcztSRy5kcmF3VGl0bGUob2JqLHByb3BbJ2NoYXJ0LnRpdGxlJ10sb2JqLmd1dHRlclRvcCxudWxsLHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMixvYmopO319O1JHLm51bWJlckZvcm1hdD1SRy5udW1iZXJfZm9ybWF0PWZ1bmN0aW9uKG9iaixudW0pXG57dmFyIGNhPW9iai5jYW52YXM7dmFyIGNvPW9iai5jb250ZXh0O3ZhciBwcm9wPW9iai5wcm9wZXJ0aWVzO3ZhciBpO3ZhciBwcmVwZW5kPWFyZ3VtZW50c1syXT9TdHJpbmcoYXJndW1lbnRzWzJdKTonJzt2YXIgYXBwZW5kPWFyZ3VtZW50c1szXT9TdHJpbmcoYXJndW1lbnRzWzNdKTonJzt2YXIgb3V0cHV0PScnO3ZhciBkZWNpbWFsPScnO3ZhciBkZWNpbWFsX3NlcGVyYXRvcj10eXBlb2YgcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXT09J3N0cmluZyc/cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXTonLic7dmFyIHRob3VzYW5kX3NlcGVyYXRvcj10eXBlb2YgcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXT09J3N0cmluZyc/cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXTonLCc7UmVnRXhwLiQxPScnO3ZhciBpLGo7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LnNjYWxlLmZvcm1hdHRlciddPT09J2Z1bmN0aW9uJyl7cmV0dXJuIHByb3BbJ2NoYXJ0LnNjYWxlLmZvcm1hdHRlciddKG9iaixudW0pO31cbmlmKFN0cmluZyhudW0pLmluZGV4T2YoJ2UnKT4wKXtyZXR1cm4gU3RyaW5nKHByZXBlbmQrU3RyaW5nKG51bSkrYXBwZW5kKTt9XG5udW09U3RyaW5nKG51bSk7aWYobnVtLmluZGV4T2YoJy4nKT4wKXt2YXIgdG1wPW51bTtudW09bnVtLnJlcGxhY2UoL1xcLiguKikvLCcnKTtkZWNpbWFsPXRtcC5yZXBsYWNlKC8oLiopXFwuKC4qKS8sJyQyJyk7fVxudmFyIHNlcGVyYXRvcj10aG91c2FuZF9zZXBlcmF0b3I7dmFyIGZvdW5kUG9pbnQ7Zm9yKGk9KG51bS5sZW5ndGgtMSksaj0wO2k+PTA7aisrLGktLSl7dmFyIGNoYXJhY3Rlcj1udW0uY2hhckF0KGkpO2lmKGolMz09MCYmaiE9MCl7b3V0cHV0Kz1zZXBlcmF0b3I7fVxub3V0cHV0Kz1jaGFyYWN0ZXI7fVxudmFyIHJldj1vdXRwdXQ7b3V0cHV0PScnO2ZvcihpPShyZXYubGVuZ3RoLTEpO2k+PTA7aS0tKXtvdXRwdXQrPXJldi5jaGFyQXQoaSk7fVxuaWYob3V0cHV0LmluZGV4T2YoJy0nK3Byb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10pPT0wKXtvdXRwdXQ9Jy0nK291dHB1dC5zdWJzdHIoKCctJytwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddKS5sZW5ndGgpO31cbmlmKGRlY2ltYWwubGVuZ3RoKXtvdXRwdXQ9b3V0cHV0K2RlY2ltYWxfc2VwZXJhdG9yK2RlY2ltYWw7ZGVjaW1hbD0nJztSZWdFeHAuJDE9Jyc7fVxuaWYob3V0cHV0LmNoYXJBdCgwKT09Jy0nKXtvdXRwdXQ9b3V0cHV0LnJlcGxhY2UoLy0vLCcnKTtwcmVwZW5kPSctJytwcmVwZW5kO31cbnJldHVybiBwcmVwZW5kK291dHB1dCthcHBlbmQ7fTtSRy5kcmF3QmFycz1SRy5EcmF3QmFycz1mdW5jdGlvbihvYmopXG57dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7dmFyIGNvPW9iai5jb250ZXh0O3ZhciBjYT1vYmouY2FudmFzO3ZhciBoYmFycz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJ107aWYoaGJhcnM9PT1udWxsKXtyZXR1cm47fVxuY28uYmVnaW5QYXRoKCk7Zm9yKGk9MCxsZW49aGJhcnMubGVuZ3RoO2k8bGVuOysraSl7dmFyIHN0YXJ0PWhiYXJzW2ldWzBdO3ZhciBsZW5ndGg9aGJhcnNbaV1bMV07dmFyIGNvbG9yPWhiYXJzW2ldWzJdO2lmKFJHLmlzX251bGwoc3RhcnQpKXN0YXJ0PW9iai5zY2FsZTIubWF4XG5pZihzdGFydD5vYmouc2NhbGUyLm1heClzdGFydD1vYmouc2NhbGUyLm1heDtpZihSRy5pc19udWxsKGxlbmd0aCkpbGVuZ3RoPW9iai5zY2FsZTIubWF4LXN0YXJ0O2lmKHN0YXJ0K2xlbmd0aD5vYmouc2NhbGUyLm1heClsZW5ndGg9b2JqLnNjYWxlMi5tYXgtc3RhcnQ7aWYoc3RhcnQrbGVuZ3RoPCgtMSpvYmouc2NhbGUyLm1heCkpbGVuZ3RoPSgtMSpvYmouc2NhbGUyLm1heCktc3RhcnQ7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicmJnN0YXJ0PT1vYmouc2NhbGUyLm1heCYmbGVuZ3RoPChvYmouc2NhbGUyLm1heCogLTIpKXtsZW5ndGg9b2JqLnNjYWxlMi5tYXgqIC0yO31cbnZhciB4PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dmFyIHk9b2JqLmdldFlDb29yZChzdGFydCk7dmFyIHc9Y2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXS1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt2YXIgaD1vYmouZ2V0WUNvb3JkKHN0YXJ0K2xlbmd0aCkteTtpZihSRy5JU09QRVJBIT0tMSYmcHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicmJmg8MCl7aCo9LTE7eT15LWg7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3k9Y2EuaGVpZ2h0LXk7aCo9LTE7fVxuY28uZmlsbFN0eWxlPWNvbG9yO2NvLmZpbGxSZWN0KHgseSx3LGgpO319O1JHLmRyYXdJbkdyYXBoTGFiZWxzPVJHLkRyYXdJbkdyYXBoTGFiZWxzPWZ1bmN0aW9uKG9iailcbnt2YXIgY2E9b2JqLmNhbnZhczt2YXIgY289b2JqLmNvbnRleHQ7dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7dmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaCddO3ZhciBsYWJlbHNfcHJvY2Vzc2VkPVtdO3ZhciBmZ2NvbG9yPSdibGFjayc7dmFyIGJnY29sb3I9J3doaXRlJzt2YXIgZGlyZWN0aW9uPTE7aWYoIWxhYmVscyl7cmV0dXJuO31cbmZvcih2YXIgaT0wLGxlbj1sYWJlbHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKHR5cGVvZiBsYWJlbHNbaV09PT0nbnVtYmVyJyl7Zm9yKHZhciBqPTA7ajxsYWJlbHNbaV07KytqKXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2gobnVsbCk7fX1lbHNlIGlmKHR5cGVvZiBsYWJlbHNbaV09PT0nc3RyaW5nJ3x8dHlwZW9mIGxhYmVsc1tpXT09PSdvYmplY3QnKXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2gobGFiZWxzW2ldKTt9ZWxzZXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2goJycpO319XG5SRy5ub1NoYWRvdyhvYmopO2lmKGxhYmVsc19wcm9jZXNzZWQmJmxhYmVsc19wcm9jZXNzZWQubGVuZ3RoPjApe2Zvcih2YXIgaT0wLGxlbj1sYWJlbHNfcHJvY2Vzc2VkLmxlbmd0aDtpPGxlbjtpKz0xKXtpZihsYWJlbHNfcHJvY2Vzc2VkW2ldKXt2YXIgY29vcmRzPW9iai5jb29yZHNbaV07aWYoY29vcmRzJiZjb29yZHMubGVuZ3RoPjApe3ZhciB4PShvYmoudHlwZT09J2Jhcic/Y29vcmRzWzBdKyhjb29yZHNbMl0vMik6Y29vcmRzWzBdKTt2YXIgeT0ob2JqLnR5cGU9PSdiYXInP2Nvb3Jkc1sxXSsoY29vcmRzWzNdLzIpOmNvb3Jkc1sxXSk7dmFyIGxlbmd0aD10eXBlb2YgbGFiZWxzX3Byb2Nlc3NlZFtpXVs0XT09PSdudW1iZXInP2xhYmVsc19wcm9jZXNzZWRbaV1bNF06MjU7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPSdibGFjayc7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztpZihvYmoudHlwZT09PSdiYXInKXtpZihvYmouR2V0KCdjaGFydC54YXhpc3BvcycpPT0ndG9wJyl7bGVuZ3RoKj0tMTt9XG5pZihwcm9wWydjaGFydC52YXJpYW50J109PSdkb3QnKXtjby5tb3ZlVG8obWEucm91bmQoeCksb2JqLmNvb3Jkc1tpXVsxXS01KTtjby5saW5lVG8obWEucm91bmQoeCksb2JqLmNvb3Jkc1tpXVsxXS01LWxlbmd0aCk7dmFyIHRleHRfeD1tYS5yb3VuZCh4KTt2YXIgdGV4dF95PW9iai5jb29yZHNbaV1bMV0tNS1sZW5ndGg7fWVsc2UgaWYocHJvcFsnY2hhcnQudmFyaWFudCddPT0nYXJyb3cnKXtjby5tb3ZlVG8obWEucm91bmQoeCksb2JqLmNvb3Jkc1tpXVsxXS01KTtjby5saW5lVG8obWEucm91bmQoeCksb2JqLmNvb3Jkc1tpXVsxXS01LWxlbmd0aCk7dmFyIHRleHRfeD1tYS5yb3VuZCh4KTt2YXIgdGV4dF95PW9iai5jb29yZHNbaV1bMV0tNS1sZW5ndGg7fWVsc2V7Y28uYXJjKG1hLnJvdW5kKHgpLHksMi41LDAsNi4yOCwwKTtjby5tb3ZlVG8obWEucm91bmQoeCkseSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHktbGVuZ3RoKTt2YXIgdGV4dF94PW1hLnJvdW5kKHgpO3ZhciB0ZXh0X3k9eS1sZW5ndGg7fVxuY28uc3Ryb2tlKCk7Y28uZmlsbCgpO31lbHNle2lmKHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldPT0nb2JqZWN0JyYmdHlwZW9mIGxhYmVsc19wcm9jZXNzZWRbaV1bM109PSdudW1iZXInJiZsYWJlbHNfcHJvY2Vzc2VkW2ldWzNdPT0tMSl7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLHkrNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHkrNStsZW5ndGgpO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhtYS5yb3VuZCh4KSx5KzUpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KS0zLHkrMTApO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSszLHkrMTApO2NvLmNsb3NlUGF0aCgpO3ZhciB0ZXh0X3g9eDt2YXIgdGV4dF95PXkrNStsZW5ndGg7fWVsc2V7dmFyIHRleHRfeD14O3ZhciB0ZXh0X3k9eS01LWxlbmd0aDtjby5tb3ZlVG8obWEucm91bmQoeCkseS01KTtjby5saW5lVG8obWEucm91bmQoeCkseS01LWxlbmd0aCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLHktNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLTMseS0xMCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpKzMseS0xMCk7Y28uY2xvc2VQYXRoKCk7fVxuY28uZmlsbCgpO31cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT0odHlwZW9mIGxhYmVsc19wcm9jZXNzZWRbaV09PT0nb2JqZWN0JyYmdHlwZW9mIGxhYmVsc19wcm9jZXNzZWRbaV1bMV09PT0nc3RyaW5nJyk/bGFiZWxzX3Byb2Nlc3NlZFtpXVsxXTonYmxhY2snO1JHLnRleHQyKG9iaix7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwneCc6dGV4dF94LCd5Jzp0ZXh0X3krKG9iai5wcm9wZXJ0aWVzWydjaGFydC50ZXh0LmFjY2Vzc2libGUnXT8yOjApLCd0ZXh0JzoodHlwZW9mIGxhYmVsc19wcm9jZXNzZWRbaV09PT0nb2JqZWN0JyYmdHlwZW9mIGxhYmVsc19wcm9jZXNzZWRbaV1bMF09PT0nc3RyaW5nJyk/bGFiZWxzX3Byb2Nlc3NlZFtpXVswXTpsYWJlbHNfcHJvY2Vzc2VkW2ldLCd2YWxpZ24nOidib3R0b20nLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6dHJ1ZSwnYm91bmRpbmcuZmlsbCc6KHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldPT09J29iamVjdCcmJnR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzJdPT09J3N0cmluZycpP2xhYmVsc19wcm9jZXNzZWRbaV1bMl06J3doaXRlJywndGFnJzonbGFiZWxzIGluZ3JhcGgnfSk7Y28uZmlsbCgpO319fX19O1JHLmZpeEV2ZW50T2JqZWN0PVJHLkZpeEV2ZW50T2JqZWN0PWZ1bmN0aW9uKGUpXG57aWYoUkcuSVNPTEQpe3ZhciBlPWV2ZW50O2UucGFnZVg9KGV2ZW50LmNsaWVudFgrZG9jLmJvZHkuc2Nyb2xsTGVmdCk7ZS5wYWdlWT0oZXZlbnQuY2xpZW50WStkb2MuYm9keS5zY3JvbGxUb3ApO2UudGFyZ2V0PWV2ZW50LnNyY0VsZW1lbnQ7aWYoIWRvYy5ib2R5LnNjcm9sbFRvcCYmZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Ape2UucGFnZVgrPXBhcnNlSW50KGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCk7ZS5wYWdlWSs9cGFyc2VJbnQoZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO319XG5pZighZS5zdG9wUHJvcGFnYXRpb24pe2Uuc3RvcFByb3BhZ2F0aW9uPWZ1bmN0aW9uKCl7d2luZG93LmV2ZW50LmNhbmNlbEJ1YmJsZT10cnVlO319XG5yZXR1cm4gZTt9O1JHLmhpZGVDcm9zc2hhaXJDb29yZHM9UkcuSGlkZUNyb3NzaGFpckNvb3Jkcz1mdW5jdGlvbigpXG57dmFyIGRpdj1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvb3JkaW5hdGVzLmNvb3Jkcy5kaXYnKTtpZihkaXYmJmRpdi5zdHlsZS5vcGFjaXR5PT0xJiZkaXYuX19vYmplY3RfXy5HZXQoJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmZhZGVvdXQnKSl7dmFyIHN0eWxlPVJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29vcmRpbmF0ZXMuY29vcmRzLmRpdicpLnN0eWxlO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzdHlsZS5vcGFjaXR5PTAuOTt9LDI1KTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3R5bGUub3BhY2l0eT0wLjg7fSw1MCk7c2V0VGltZW91dChmdW5jdGlvbigpe3N0eWxlLm9wYWNpdHk9MC43O30sNzUpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzdHlsZS5vcGFjaXR5PTAuNjt9LDEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe3N0eWxlLm9wYWNpdHk9MC41O30sMTI1KTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3R5bGUub3BhY2l0eT0wLjQ7fSwxNTApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzdHlsZS5vcGFjaXR5PTAuMzt9LDE3NSk7c2V0VGltZW91dChmdW5jdGlvbigpe3N0eWxlLm9wYWNpdHk9MC4yO30sMjAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3R5bGUub3BhY2l0eT0wLjE7fSwyMjUpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzdHlsZS5vcGFjaXR5PTA7fSwyNTApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzdHlsZS5kaXNwbGF5PSdub25lJzt9LDI3NSk7fX07UkcuZHJhdzNEQXhlcz1SRy5EcmF3M0RBeGVzPWZ1bmN0aW9uKG9iailcbnt2YXIgcHJvcD1vYmoucHJvcGVydGllcyxjbz1vYmouY29udGV4dCxjYT1vYmouY2FudmFzO3ZhciBndXR0ZXJMZWZ0PW9iai5ndXR0ZXJMZWZ0LGd1dHRlclJpZ2h0PW9iai5ndXR0ZXJSaWdodCxndXR0ZXJUb3A9b2JqLmd1dHRlclRvcCxndXR0ZXJCb3R0b209b2JqLmd1dHRlckJvdHRvbSx4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddLGdyYXBoQXJlYT1jYS5oZWlnaHQtZ3V0dGVyVG9wLWd1dHRlckJvdHRvbSxoYWxmR3JhcGhBcmVhPWdyYXBoQXJlYS8yLG9mZnNldHg9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLG9mZnNldHk9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddLHhheGlzPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLnhheGlzJ10seWF4aXM9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQueWF4aXMnXVxuaWYoeWF4aXMpe1JHLmRyYXczRFlBeGlzKG9iaik7fVxuaWYoeGF4aXMpe2lmKHhheGlzcG9zPT09J2NlbnRlcicpe1JHLnBhdGgyKGNvLCdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGMgcyAjYWFhIGYgI2RkZCcsZ3V0dGVyTGVmdCxndXR0ZXJUb3AraGFsZkdyYXBoQXJlYSxndXR0ZXJMZWZ0K29mZnNldHgsZ3V0dGVyVG9wK2hhbGZHcmFwaEFyZWEtb2Zmc2V0eSxjYS53aWR0aC1ndXR0ZXJSaWdodCtvZmZzZXR4LGd1dHRlclRvcCtoYWxmR3JhcGhBcmVhLW9mZnNldHksY2Eud2lkdGgtZ3V0dGVyUmlnaHQsZ3V0dGVyVG9wK2hhbGZHcmFwaEFyZWEpO31lbHNle2lmKG9iai50eXBlPT09J2hiYXInKXt2YXIgeGF4aXNZQ29vcmQ9b2JqLmNhbnZhcy5oZWlnaHQtb2JqLnByb3BlcnRpZXNbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt9ZWxzZXt2YXIgeGF4aXNZQ29vcmQ9b2JqLmdldFlDb29yZCgwKTt9XG5SRy5wYXRoMihjbywnbSAlICUgbCAlICUgbCAlICUgbCAlICUgYyBzICNhYWEgZiAjZGRkJyxndXR0ZXJMZWZ0LHhheGlzWUNvb3JkLGd1dHRlckxlZnQrb2Zmc2V0eCx4YXhpc1lDb29yZC1vZmZzZXR5LGNhLndpZHRoLWd1dHRlclJpZ2h0K29mZnNldHgseGF4aXNZQ29vcmQtb2Zmc2V0eSxjYS53aWR0aC1ndXR0ZXJSaWdodCx4YXhpc1lDb29yZCk7fX19O1JHLmRyYXczRFlBeGlzPWZ1bmN0aW9uKG9iailcbnt2YXIgcHJvcD1vYmoucHJvcGVydGllcyxjbz1vYmouY29udGV4dCxjYT1vYmouY2FudmFzO3ZhciBndXR0ZXJMZWZ0PW9iai5ndXR0ZXJMZWZ0LGd1dHRlclJpZ2h0PW9iai5ndXR0ZXJSaWdodCxndXR0ZXJUb3A9b2JqLmd1dHRlclRvcCxndXR0ZXJCb3R0b209b2JqLmd1dHRlckJvdHRvbSx4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddLGdyYXBoQXJlYT1jYS5oZWlnaHQtZ3V0dGVyVG9wLWd1dHRlckJvdHRvbSxoYWxmR3JhcGhBcmVhPWdyYXBoQXJlYS8yLG9mZnNldHg9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLG9mZnNldHk9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddXG5pZigob2JqLnR5cGU9PT0naGJhcid8fG9iai50eXBlPT09J2JhcicpJiZwcm9wWydjaGFydC55YXhpc3BvcyddPT09J2NlbnRlcicpe3ZhciB4PSgoY2Eud2lkdGgtZ3V0dGVyTGVmdC1ndXR0ZXJSaWdodCkvMikrZ3V0dGVyTGVmdDt9ZWxzZSBpZigob2JqLnR5cGU9PT0naGJhcid8fG9iai50eXBlPT09J2JhcicpJiZwcm9wWydjaGFydC55YXhpc3BvcyddPT09J3JpZ2h0Jyl7dmFyIHg9Y2Eud2lkdGgtZ3V0dGVyUmlnaHQ7fWVsc2V7dmFyIHg9Z3V0dGVyTGVmdDt9XG5SRy5wYXRoMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBzICNhYWEgZiAjZGRkJyx4LGd1dHRlclRvcCx4K29mZnNldHgsZ3V0dGVyVG9wLW9mZnNldHkseCtvZmZzZXR4LGNhLmhlaWdodC1ndXR0ZXJCb3R0b20tb2Zmc2V0eSx4LGNhLmhlaWdodC1ndXR0ZXJCb3R0b20pO307Ukcuc3Ryb2tlZEN1cnZ5UmVjdD1mdW5jdGlvbihjbyx4LHksdyxoKVxue3ZhciByPWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06Mzt2YXIgY29ybmVyX3RsPShhcmd1bWVudHNbNl18fGFyZ3VtZW50c1s2XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX3RyPShhcmd1bWVudHNbN118fGFyZ3VtZW50c1s3XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX2JyPShhcmd1bWVudHNbOF18fGFyZ3VtZW50c1s4XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX2JsPShhcmd1bWVudHNbOV18fGFyZ3VtZW50c1s5XT09bnVsbCk/dHJ1ZTpmYWxzZTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCsoY29ybmVyX3RsP3I6MCkseSk7Y28ubGluZVRvKHgrdy0oY29ybmVyX3RyP3I6MCkseSk7aWYoY29ybmVyX3RyKXtjby5hcmMoeCt3LXIseStyLHIsUkcuUEkrUkcuSEFMRlBJLFJHLlRXT1BJLGZhbHNlKTt9XG5jby5saW5lVG8oeCt3LHkraC0oY29ybmVyX2JyP3I6MCkpO2lmKGNvcm5lcl9icil7Y28uYXJjKHgrdy1yLHktcitoLHIsUkcuVFdPUEksUkcuSEFMRlBJLGZhbHNlKTt9XG5jby5saW5lVG8oeCsoY29ybmVyX2JsP3I6MCkseStoKTtpZihjb3JuZXJfYmwpe2NvLmFyYyh4K3IseS1yK2gscixSRy5IQUxGUEksUkcuUEksZmFsc2UpO31cbmNvLmxpbmVUbyh4LHkrKGNvcm5lcl90bD9yOjApKTtpZihjb3JuZXJfdGwpe2NvLmFyYyh4K3IseStyLHIsUkcuUEksUkcuUEkrUkcuSEFMRlBJLGZhbHNlKTt9XG5jby5zdHJva2UoKTt9O1JHLmZpbGxlZEN1cnZ5UmVjdD1mdW5jdGlvbihjbyx4LHksdyxoKVxue3ZhciByPWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06Mzt2YXIgY29ybmVyX3RsPShhcmd1bWVudHNbNl18fGFyZ3VtZW50c1s2XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX3RyPShhcmd1bWVudHNbN118fGFyZ3VtZW50c1s3XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX2JyPShhcmd1bWVudHNbOF18fGFyZ3VtZW50c1s4XT09bnVsbCk/dHJ1ZTpmYWxzZTt2YXIgY29ybmVyX2JsPShhcmd1bWVudHNbOV18fGFyZ3VtZW50c1s5XT09bnVsbCk/dHJ1ZTpmYWxzZTtjby5iZWdpblBhdGgoKTtpZihjb3JuZXJfdGwpe2NvLm1vdmVUbyh4K3IseStyKTtjby5hcmMoeCtyLHkrcixyLFJHLlBJLFJHLlBJK1JHLkhBTEZQSSxmYWxzZSk7fWVsc2V7Y28uZmlsbFJlY3QoeCx5LHIscik7fVxuaWYoY29ybmVyX3RyKXtjby5tb3ZlVG8oeCt3LXIseStyKTtjby5hcmMoeCt3LXIseStyLHIsUkcuUEkrUkcuSEFMRlBJLDAsZmFsc2UpO31lbHNle2NvLm1vdmVUbyh4K3ctcix5KTtjby5maWxsUmVjdCh4K3ctcix5LHIscik7fVxuaWYoY29ybmVyX2JyKXtjby5tb3ZlVG8oeCt3LXIseStoLXIpO2NvLmFyYyh4K3ctcix5LXIraCxyLDAsUkcuSEFMRlBJLGZhbHNlKTt9ZWxzZXtjby5tb3ZlVG8oeCt3LXIseStoLXIpO2NvLmZpbGxSZWN0KHgrdy1yLHkraC1yLHIscik7fVxuaWYoY29ybmVyX2JsKXtjby5tb3ZlVG8oeCtyLHkraC1yKTtjby5hcmMoeCtyLHktcitoLHIsUkcuSEFMRlBJLFJHLlBJLGZhbHNlKTt9ZWxzZXtjby5tb3ZlVG8oeCx5K2gtcik7Y28uZmlsbFJlY3QoeCx5K2gtcixyLHIpO31cbmNvLmZpbGxSZWN0KHgrcix5LHctci1yLGgpO2NvLmZpbGxSZWN0KHgseStyLHIrMSxoLXItcik7Y28uZmlsbFJlY3QoeCt3LXItMSx5K3IscisxLGgtci1yKTtjby5maWxsKCk7fTtSRy5oaWRlWm9vbWVkQ2FudmFzPVJHLkhpZGVab29tZWRDYW52YXM9ZnVuY3Rpb24oKVxue3ZhciBpbnRlcnZhbD0xMDt2YXIgZnJhbWVzPTE1O2lmKHR5cGVvZiBSRy56b29tX2ltYWdlPT09J29iamVjdCcpe3ZhciBvYmo9Ukcuem9vbV9pbWFnZS5vYmo7dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7fWVsc2V7cmV0dXJuO31cbmlmKHByb3BbJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnXSl7Zm9yKHZhciBpPWZyYW1lcyxqPTE7aT49MDstLWksKytqKXtpZih0eXBlb2YgUkcuem9vbV9pbWFnZT09PSdvYmplY3QnKXtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUub3BhY2l0eSA9IFwiK1N0cmluZyhpLzEwKSxqKmludGVydmFsKTt9fVxuaWYodHlwZW9mIFJHLnpvb21fYmFja2dyb3VuZD09PSdvYmplY3QnKXtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21fYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gXCIrU3RyaW5nKGkvZnJhbWVzKSxqKmludGVydmFsKTt9fVxuaWYodHlwZW9mIFJHLnpvb21faW1hZ2U9PT0nb2JqZWN0Jyl7c2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcIixwcm9wWydjaGFydC56b29tLmZhZGUub3V0J10/KGZyYW1lcyppbnRlcnZhbCkrMTA6MCk7fVxuaWYodHlwZW9mIFJHLnpvb21fYmFja2dyb3VuZD09PSdvYmplY3QnKXtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21fYmFja2dyb3VuZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXCIscHJvcFsnY2hhcnQuem9vbS5mYWRlLm91dCddPyhmcmFtZXMqaW50ZXJ2YWwpKzEwOjApO319O1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXI9UkcuQWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihvYmosbmFtZSxmdW5jKVxue2lmKHR5cGVvZiBSRy5ldmVudHNbb2JqLnVpZF09PT0ndW5kZWZpbmVkJyl7UkcuZXZlbnRzW29iai51aWRdPVtdO31cbmlmKG5hbWUuc3Vic3RyKDAsMikhPT0nb24nKXtuYW1lPSdvbicrbmFtZTt9XG5SRy5ldmVudHNbb2JqLnVpZF0ucHVzaChbb2JqLG5hbWUsZnVuY10pO3JldHVybiBSRy5ldmVudHNbb2JqLnVpZF0ubGVuZ3RoLTE7fTtSRy5maXJlQ3VzdG9tRXZlbnQ9UkcuRmlyZUN1c3RvbUV2ZW50PWZ1bmN0aW9uKG9iaixuYW1lKVxue2lmKG9iaiYmb2JqLmlzUkdyYXBoKXtpZihuYW1lLm1hdGNoKC8ob24pP21vdXNlb3V0LykmJnR5cGVvZiBvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLm1vdXNlb3V0J109PT0nZnVuY3Rpb24nKXsob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmV2ZW50cy5tb3VzZW91dCddKShvYmopO31cbmlmKG9ialtuYW1lXSl7KG9ialtuYW1lXSkob2JqKTt9XG52YXIgdWlkPW9iai51aWQ7aWYodHlwZW9mIHVpZD09PSdzdHJpbmcnJiZ0eXBlb2YgUkcuZXZlbnRzPT09J29iamVjdCcmJnR5cGVvZiBSRy5ldmVudHNbdWlkXT09PSdvYmplY3QnJiZSRy5ldmVudHNbdWlkXS5sZW5ndGg+MCl7Zm9yKHZhciBqPTA7ajxSRy5ldmVudHNbdWlkXS5sZW5ndGg7KytqKXtpZihSRy5ldmVudHNbdWlkXVtqXSYmUkcuZXZlbnRzW3VpZF1bal1bMV09PT1uYW1lKXtSRy5ldmVudHNbdWlkXVtqXVsyXShvYmopO319fX19O1JHcmFwaC5yZW1vdmVBbGxDdXN0b21FdmVudExpc3RlbmVycz1SR3JhcGguUmVtb3ZlQWxsQ3VzdG9tRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKVxue3ZhciBpZD1hcmd1bWVudHNbMF07aWYoaWQmJlJHLmV2ZW50c1tpZF0pe1JHLmV2ZW50c1tpZF09W107fWVsc2V7UkcuZXZlbnRzPVtdO319O1JHLnJlbW92ZUN1c3RvbUV2ZW50TGlzdGVuZXI9UkcuUmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihvYmosaSlcbntpZih0eXBlb2YgUkcuZXZlbnRzPT09J29iamVjdCcmJnR5cGVvZiBSRy5ldmVudHNbb2JqLmlkXT09PSdvYmplY3QnJiZ0eXBlb2YgUkcuZXZlbnRzW29iai5pZF1baV09PT0nb2JqZWN0Jyl7UkcuZXZlbnRzW29iai5pZF1baV09bnVsbDt9fTtSRy5kcmF3QmFja2dyb3VuZEltYWdlPVJHLkRyYXdCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24ob2JqKVxue3ZhciBwcm9wPW9iai5wcm9wZXJ0aWVzO3ZhciBjYT1vYmouY2FudmFzO3ZhciBjbz1vYmouY29udGV4dDtpZih0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZSddPT09J3N0cmluZycpe2lmKHR5cGVvZiBjYS5fX3JncmFwaF9iYWNrZ3JvdW5kX2ltYWdlX189PT0ndW5kZWZpbmVkJyl7dmFyIGltZz1uZXcgSW1hZ2UoKTtpbWcuX19vYmplY3RfXz1vYmo7aW1nLl9fY2FudmFzX189Y2E7aW1nLl9fY29udGV4dF9fPWNvO2ltZy5zcmM9b2JqLkdldCgnY2hhcnQuYmFja2dyb3VuZC5pbWFnZScpO2NhLl9fcmdyYXBoX2JhY2tncm91bmRfaW1hZ2VfXz1pbWc7fWVsc2V7aW1nPWNhLl9fcmdyYXBoX2JhY2tncm91bmRfaW1hZ2VfXzt9XG5pbWcub25sb2FkPWZ1bmN0aW9uKClcbntvYmouX19yZ3JhcGhfYmFja2dyb3VuZF9pbWFnZV9sb2FkZWRfXz10cnVlO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO31cbnZhciBndXR0ZXJMZWZ0PW9iai5ndXR0ZXJMZWZ0O3ZhciBndXR0ZXJSaWdodD1vYmouZ3V0dGVyUmlnaHQ7dmFyIGd1dHRlclRvcD1vYmouZ3V0dGVyVG9wO3ZhciBndXR0ZXJCb3R0b209b2JqLmd1dHRlckJvdHRvbTt2YXIgc3RyZXRjaD1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnXTt2YXIgYWxpZ249cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5hbGlnbiddO2lmKHR5cGVvZiBhbGlnbj09PSdzdHJpbmcnKXtpZihhbGlnbi5pbmRleE9mKCdyaWdodCcpIT0tMSl7dmFyIHg9Y2Eud2lkdGgtKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UudyddfHxpbWcud2lkdGgpLWd1dHRlclJpZ2h0O31lbHNle3ZhciB4PWd1dHRlckxlZnQ7fVxuaWYoYWxpZ24uaW5kZXhPZignYm90dG9tJykhPS0xKXt2YXIgeT1jYS5oZWlnaHQtKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuaCddfHxpbWcuaGVpZ2h0KS1ndXR0ZXJCb3R0b207fWVsc2V7dmFyIHk9Z3V0dGVyVG9wO319ZWxzZXt2YXIgeD1ndXR0ZXJMZWZ0fHwyNTt2YXIgeT1ndXR0ZXJUb3B8fDI1O31cbnZhciB4PXR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLngnXT09PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueCddOng7dmFyIHk9dHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSddPT09J251bWJlcic/cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS55J106eTt2YXIgdz1zdHJldGNoP2NhLndpZHRoLWd1dHRlckxlZnQtZ3V0dGVyUmlnaHQ6aW1nLndpZHRoO3ZhciBoPXN0cmV0Y2g/Y2EuaGVpZ2h0LWd1dHRlclRvcC1ndXR0ZXJCb3R0b206aW1nLmhlaWdodDtpZih0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53J109PT0nbnVtYmVyJyl3PXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UudyddO2lmKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnXT09PSdudW1iZXInKWg9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5oJ107dmFyIG9sZEFscGhhPWNvLmdsb2JhbEFscGhhO2NvLmdsb2JhbEFscGhhPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxwaGEnXTtjby5kcmF3SW1hZ2UoaW1nLHgseSx3LGgpO2NvLmdsb2JhbEFscGhhPW9sZEFscGhhO319O1JHLmhhc1Rvb2x0aXBzPWZ1bmN0aW9uKG9iailcbnt2YXIgcHJvcD1vYmoucHJvcGVydGllcztpZih0eXBlb2YgcHJvcFsnY2hhcnQudG9vbHRpcHMnXT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10pe2Zvcih2YXIgaT0wLGxlbj1wcm9wWydjaGFydC50b29sdGlwcyddLmxlbmd0aDtpPGxlbjsrK2kpe2lmKCFSRy5pc19udWxsKG9iai5HZXQoJ2NoYXJ0LnRvb2x0aXBzJylbaV0pKXtyZXR1cm4gdHJ1ZTt9fX1lbHNlIGlmKHR5cGVvZiBwcm9wWydjaGFydC50b29sdGlwcyddPT09J2Z1bmN0aW9uJyl7cmV0dXJuIHRydWU7fVxucmV0dXJuIGZhbHNlO307UkcuY3JlYXRlVUlEPVJHLkNyZWF0ZVVJRD1mdW5jdGlvbigpXG57cmV0dXJuJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLGZ1bmN0aW9uKGMpXG57dmFyIHI9bWEucmFuZG9tKCkqMTZ8MCx2PWM9PSd4Jz9yOihyJjB4M3wweDgpO3JldHVybiB2LnRvU3RyaW5nKDE2KTt9KTt9O1JHLk9SLmFkZD1SRy5PUi5BZGQ9ZnVuY3Rpb24ob2JqKVxue3ZhciB1aWQ9b2JqLnVpZDt2YXIgaWQ9b2JqLmNhbnZhcy5pZDtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlELnB1c2goW3VpZCxvYmpdKTtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSUQucHVzaChbaWQsb2JqXSk7fTtSRy5PUi5yZW1vdmU9UkcuT1IuUmVtb3ZlPWZ1bmN0aW9uKG9iailcbnt2YXIgaWQ9b2JqLmlkO3ZhciB1aWQ9b2JqLnVpZDtmb3IodmFyIGk9MDtpPFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQubGVuZ3RoOysraSl7aWYoUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXSYmUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXVsxXS51aWQ9PXVpZCl7UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXT1udWxsO319XG5mb3IodmFyIGk9MDtpPFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRC5sZW5ndGg7KytpKXtpZihSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSURbaV0mJlJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRFtpXVsxXSYmUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieUNhbnZhc0lEW2ldWzFdLnVpZD09dWlkKXtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSURbaV09bnVsbDt9fX07UkcuT1IuY2xlYXI9UkcuT1IuQ2xlYXI9ZnVuY3Rpb24oKVxue2lmKGFyZ3VtZW50c1swXSl7dmFyIGlkPSh0eXBlb2YgYXJndW1lbnRzWzBdPT09J29iamVjdCc/YXJndW1lbnRzWzBdLmlkOmFyZ3VtZW50c1swXSk7dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoaWQpO2Zvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjsrK2kpe1JHLk9iamVjdFJlZ2lzdHJ5LnJlbW92ZShvYmplY3RzW2ldKTt9fWVsc2V7UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cz17fTtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEPVtdO1JHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRD1bXTt9fTtSRy5PUi5saXN0PVJHLk9SLkxpc3Q9ZnVuY3Rpb24oKVxue3ZhciBsaXN0PVtdO2Zvcih2YXIgaT0wLGxlbj1SRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlELmxlbmd0aDtpPGxlbjsrK2kpe2lmKFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSURbaV0pe2xpc3QucHVzaChSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEW2ldWzFdLnR5cGUpO319XG5pZihhcmd1bWVudHNbMF0pe3JldHVybiBsaXN0O31lbHNleyRwKGxpc3QpO319O1JHLk9SLmNsZWFyQnlUeXBlPVJHLk9SLkNsZWFyQnlUeXBlPWZ1bmN0aW9uKHR5cGUpXG57dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRDtmb3IodmFyIGk9MCxsZW49b2JqZWN0cy5sZW5ndGg7aTxsZW47KytpKXtpZihvYmplY3RzW2ldKXt2YXIgdWlkPW9iamVjdHNbaV1bMF07dmFyIG9iaj1vYmplY3RzW2ldWzFdO2lmKG9iaiYmb2JqLnR5cGU9PXR5cGUpe1JHLk9iamVjdFJlZ2lzdHJ5LnJlbW92ZShvYmopO319fX07UkcuT1IuaXRlcmF0ZT1SRy5PUi5JdGVyYXRlPWZ1bmN0aW9uKGZ1bmMpXG57dmFyIG9iamVjdHM9UkdyYXBoLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQ7Zm9yKHZhciBpPTAsbGVuPW9iamVjdHMubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mIGFyZ3VtZW50c1sxXT09PSdzdHJpbmcnKXt2YXIgdHlwZXM9YXJndW1lbnRzWzFdLnNwbGl0KC8sLyk7Zm9yKHZhciBqPTAsbGVuMj10eXBlcy5sZW5ndGg7ajxsZW4yOysrail7aWYodHlwZXNbal09PW9iamVjdHNbaV1bMV0udHlwZSl7ZnVuYyhvYmplY3RzW2ldWzFdKTt9fX1lbHNle2Z1bmMob2JqZWN0c1tpXVsxXSk7fX19O1JHLk9SLmdldE9iamVjdHNCeUNhbnZhc0lEPWZ1bmN0aW9uKGlkKVxue3ZhciBzdG9yZT1SRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSUQ7dmFyIHJldD1bXTtmb3IodmFyIGk9MCxsZW49c3RvcmUubGVuZ3RoO2k8bGVuOysraSl7aWYoc3RvcmVbaV0mJnN0b3JlW2ldWzBdPT1pZCl7cmV0LnB1c2goc3RvcmVbaV1bMV0pO319XG5yZXR1cm4gcmV0O307UkcuT1IuZmlyc3RieXh5PVJHLk9SLmdldEZpcnN0T2JqZWN0QnlYWT1SRy5PUi5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIGNhbnZhcz1lLnRhcmdldDt2YXIgcmV0PW51bGw7dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoY2FudmFzLmlkKTtmb3IodmFyIGk9KG9iamVjdHMubGVuZ3RoLTEpO2k+PTA7LS1pKXt2YXIgb2JqPW9iamVjdHNbaV0uZ2V0T2JqZWN0QnlYWShlKTtpZihvYmope3JldHVybiBvYmo7fX19O1JHLk9SLmdldE9iamVjdHNCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIGNhbnZhcz1lLnRhcmdldDt2YXIgcmV0PVtdO3ZhciBvYmplY3RzPVJHLk9iamVjdFJlZ2lzdHJ5LmdldE9iamVjdHNCeUNhbnZhc0lEKGNhbnZhcy5pZCk7Zm9yKHZhciBpPShvYmplY3RzLmxlbmd0aC0xKTtpPj0wOy0taSl7dmFyIG9iaj1vYmplY3RzW2ldLmdldE9iamVjdEJ5WFkoZSk7aWYob2JqKXtyZXQucHVzaChvYmopO319XG5yZXR1cm4gcmV0O307UkcuT1IuZ2V0PVJHLk9SLmdldE9iamVjdEJ5VUlEPWZ1bmN0aW9uKHVpZClcbnt2YXIgb2JqZWN0cz1SRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEO2Zvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjsrK2kpe2lmKG9iamVjdHNbaV0mJm9iamVjdHNbaV1bMV0udWlkPT11aWQpe3JldHVybiBvYmplY3RzW2ldWzFdO319fTtSRy5PUi5icmluZ1RvRnJvbnQ9ZnVuY3Rpb24ob2JqKVxue3ZhciByZWRyYXc9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP3RydWU6YXJndW1lbnRzWzFdO1JHLk9iamVjdFJlZ2lzdHJ5LnJlbW92ZShvYmopO1JHLk9iamVjdFJlZ2lzdHJ5LmFkZChvYmopO2lmKHJlZHJhdyl7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO319O1JHLk9SLnR5cGU9UkcuT1IuZ2V0T2JqZWN0c0J5VHlwZT1mdW5jdGlvbih0eXBlKVxue3ZhciBvYmplY3RzPVJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQ7dmFyIHJldD1bXTtmb3IodmFyIGk9MCxsZW49b2JqZWN0cy5sZW5ndGg7aTxsZW47KytpKXtpZihvYmplY3RzW2ldJiZvYmplY3RzW2ldWzFdJiZvYmplY3RzW2ldWzFdLnR5cGUmJm9iamVjdHNbaV1bMV0udHlwZSYmb2JqZWN0c1tpXVsxXS50eXBlPT10eXBlKXtyZXQucHVzaChvYmplY3RzW2ldWzFdKTt9fVxucmV0dXJuIHJldDt9O1JHLk9SLmZpcnN0PVJHLk9SLmdldEZpcnN0T2JqZWN0QnlUeXBlPWZ1bmN0aW9uKHR5cGUpXG57dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRDtmb3IodmFyIGk9MCxsZW49b2JqZWN0cy5sZW5ndGg7aTxsZW47KytpKXtpZihvYmplY3RzW2ldJiZvYmplY3RzW2ldWzFdJiZvYmplY3RzW2ldWzFdLnR5cGU9PXR5cGUpe3JldHVybiBvYmplY3RzW2ldWzFdO319XG5yZXR1cm4gbnVsbDt9O1JHLmdldEFuZ2xlQnlYWT1mdW5jdGlvbihjeCxjeSx4LHkpXG57dmFyIGFuZ2xlPW1hLmF0YW4oKHktY3kpLyh4LWN4KSk7YW5nbGU9bWEuYWJzKGFuZ2xlKVxuaWYoeD49Y3gmJnk+PWN5KXthbmdsZSs9UkcuVFdPUEk7fWVsc2UgaWYoeD49Y3gmJnk8Y3kpe2FuZ2xlPShSRy5IQUxGUEktYW5nbGUpKyhSRy5QSStSRy5IQUxGUEkpO31lbHNlIGlmKHg8Y3gmJnk8Y3kpe2FuZ2xlKz1SRy5QSTt9ZWxzZXthbmdsZT1SRy5QSS1hbmdsZTt9XG5pZihhbmdsZT5SRy5UV09QSSl7YW5nbGUtPVJHLlRXT1BJO31cbnJldHVybiBhbmdsZTt9O1JHLmdldEh5cExlbmd0aD1mdW5jdGlvbih4MSx5MSx4Mix5Milcbnt2YXIgcmV0PW1hLnNxcnQoKCh4Mi14MSkqKHgyLXgxKSkrKCh5Mi15MSkqKHkyLXkxKSkpO3JldHVybiByZXQ7fTtSRy5nZXRSYWRpdXNFbmRQb2ludD1mdW5jdGlvbihjeCxjeSxhbmdsZSxyYWRpdXMpXG57dmFyIHg9Y3grKG1hLmNvcyhhbmdsZSkqcmFkaXVzKTt2YXIgeT1jeSsobWEuc2luKGFuZ2xlKSpyYWRpdXMpO3JldHVyblt4LHldO307UkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzPVJHLkluc3RhbGxFdmVudExpc3RlbmVycz1mdW5jdGlvbihvYmopXG57dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYoUkcuSVNPTEQpe3JldHVybjt9XG5pZihSRy5pbnN0YWxsQ2FudmFzQ2xpY2tMaXN0ZW5lcil7UkcuaW5zdGFsbFdpbmRvd01vdXNlZG93bkxpc3RlbmVyKG9iaik7UkcuaW5zdGFsbFdpbmRvd01vdXNldXBMaXN0ZW5lcihvYmopO1JHLmluc3RhbGxDYW52YXNNb3VzZW1vdmVMaXN0ZW5lcihvYmopO1JHLmluc3RhbGxDYW52YXNNb3VzZXVwTGlzdGVuZXIob2JqKTtSRy5pbnN0YWxsQ2FudmFzTW91c2Vkb3duTGlzdGVuZXIob2JqKTtSRy5pbnN0YWxsQ2FudmFzQ2xpY2tMaXN0ZW5lcihvYmopO31lbHNlIGlmKFJHLmhhc1Rvb2x0aXBzKG9iail8fHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXXx8cHJvcFsnY2hhcnQuYW5ub3RhdGFibGUnXXx8cHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXXx8cHJvcFsnY2hhcnQucmVzaXphYmxlJ118fHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSddfHxwcm9wWydjaGFydC5ldmVudHMuY2xpY2snXXx8cHJvcFsnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSddfHx0eXBlb2Ygb2JqLm9uY2xpY2s9PT0nZnVuY3Rpb24nfHx0eXBlb2Ygb2JqLm9ubW91c2Vtb3ZlPT09J2Z1bmN0aW9uJyl7YWxlcnQoJ1tSR1JBUEhdIFlvdSBhcHBlYXIgdG8gaGF2ZSB1c2VkIGR5bmFtaWMgZmVhdHVyZXMgYnV0IG5vdCBpbmNsdWRlZCB0aGUgZmlsZTogUkdyYXBoLmNvbW1vbi5keW5hbWljLmpzJyk7fX07UkcucHI9ZnVuY3Rpb24ob2JqKVxue3ZhciBpbmRlbnQ9KGFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06JyAgICAnKTt2YXIgc3RyPScnO3ZhciBjb3VudGVyPXR5cGVvZiBhcmd1bWVudHNbM109PSdudW1iZXInP2FyZ3VtZW50c1szXTowO2lmKGNvdW50ZXI+PTUpe3JldHVybicnO31cbnN3aXRjaCh0eXBlb2Ygb2JqKXtjYXNlJ3N0cmluZyc6c3RyKz1vYmorJyAoJysodHlwZW9mIG9iaikrJywgJytvYmoubGVuZ3RoKycpJzticmVhaztjYXNlJ251bWJlcic6c3RyKz1vYmorJyAoJysodHlwZW9mIG9iaikrJyknO2JyZWFrO2Nhc2UnYm9vbGVhbic6c3RyKz1vYmorJyAoJysodHlwZW9mIG9iaikrJyknO2JyZWFrO2Nhc2UnZnVuY3Rpb24nOnN0cis9J2Z1bmN0aW9uICgpIHt9JzticmVhaztjYXNlJ3VuZGVmaW5lZCc6c3RyKz0ndW5kZWZpbmVkJzticmVhaztjYXNlJ251bGwnOnN0cis9J251bGwnO2JyZWFrO2Nhc2Unb2JqZWN0JzppZihSR3JhcGguaXNfbnVsbChvYmopKXtzdHIrPWluZGVudCsnbnVsbFxcbic7fWVsc2V7c3RyKz1pbmRlbnQrJ09iamVjdCB7JysnXFxuJ1xuZm9yKGogaW4gb2JqKXtzdHIrPWluZGVudCsnICAgICcraisnID0+ICcrUkdyYXBoLnByKG9ialtqXSx0cnVlLGluZGVudCsnICAgICcsY291bnRlcisxKSsnXFxuJzt9XG5zdHIrPWluZGVudCsnfSc7fVxuYnJlYWs7ZGVmYXVsdDpzdHIrPSdVbmtub3duIHR5cGU6ICcrdHlwZW9mIG9iaisnJzticmVhazt9XG5pZighYXJndW1lbnRzWzFdKXthbGVydChzdHIpO31cbnJldHVybiBzdHI7fTtSRy5kYXNoZWRMaW5lPVJHLkRhc2hlZExpbmU9ZnVuY3Rpb24oY28seDEseTEseDIseTIpXG57dmFyIHNpemU9NTtpZih0eXBlb2YgYXJndW1lbnRzWzVdPT09J251bWJlcicpe3NpemU9YXJndW1lbnRzWzVdO31cbnZhciBkeD14Mi14MTt2YXIgZHk9eTIteTE7dmFyIG51bT1tYS5mbG9vcihtYS5zcXJ0KChkeCpkeCkrKGR5KmR5KSkvc2l6ZSk7dmFyIHhMZW49ZHgvbnVtO3ZhciB5TGVuPWR5L251bTt2YXIgY291bnQ9MDtkb3soY291bnQlMj09MCYmY291bnQ+MCk/Y28ubGluZVRvKHgxLHkxKTpjby5tb3ZlVG8oeDEseTEpO3gxKz14TGVuO3kxKz15TGVuO313aGlsZShjb3VudCsrPD1udW0pO307UkcuQUpBWD1mdW5jdGlvbih1cmwsY2FsbGJhY2spXG57aWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXt2YXIgaHR0cFJlcXVlc3Q9bmV3IFhNTEh0dHBSZXF1ZXN0KCk7fWVsc2UgaWYod2luZG93LkFjdGl2ZVhPYmplY3Qpe3ZhciBodHRwUmVxdWVzdD1uZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO31cbmh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpXG57aWYodGhpcy5yZWFkeVN0YXRlPT00JiZ0aGlzLnN0YXR1cz09MjAwKXt0aGlzLl9fdXNlcl9jYWxsYmFja19fPWNhbGxiYWNrO3RoaXMuX191c2VyX2NhbGxiYWNrX18odGhpcy5yZXNwb25zZVRleHQpO319XG5odHRwUmVxdWVzdC5vcGVuKCdHRVQnLHVybCx0cnVlKTtodHRwUmVxdWVzdC5zZW5kKCk7fTtSRy5BSkFYLlBPU1Q9ZnVuY3Rpb24odXJsLGRhdGEsY2FsbGJhY2spXG57dmFyIGNydW1icz1bXTtpZih3aW5kb3cuWE1MSHR0cFJlcXVlc3Qpe3ZhciBodHRwUmVxdWVzdD1uZXcgWE1MSHR0cFJlcXVlc3QoKTt9ZWxzZSBpZih3aW5kb3cuQWN0aXZlWE9iamVjdCl7dmFyIGh0dHBSZXF1ZXN0PW5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7fVxuaHR0cFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKClcbntpZih0aGlzLnJlYWR5U3RhdGU9PTQmJnRoaXMuc3RhdHVzPT0yMDApe3RoaXMuX191c2VyX2NhbGxiYWNrX189Y2FsbGJhY2s7dGhpcy5fX3VzZXJfY2FsbGJhY2tfXyh0aGlzLnJlc3BvbnNlVGV4dCk7fX1cbmh0dHBSZXF1ZXN0Lm9wZW4oJ1BPU1QnLHVybCx0cnVlKTtodHRwUmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7Zm9yKGkgaW4gZGF0YSl7aWYodHlwZW9mIGk9PSdzdHJpbmcnKXtjcnVtYnMucHVzaChpKyc9JytlbmNvZGVVUklDb21wb25lbnQoZGF0YVtpXSkpO319XG5odHRwUmVxdWVzdC5zZW5kKGNydW1icy5qb2luKCcmJykpO307UkcuQUpBWC5nZXROdW1iZXI9ZnVuY3Rpb24odXJsLGNhbGxiYWNrKVxue1JHLkFKQVgodXJsLGZ1bmN0aW9uKClcbnt2YXIgbnVtPXBhcnNlRmxvYXQodGhpcy5yZXNwb25zZVRleHQpO2NhbGxiYWNrKG51bSk7fSk7fTtSRy5BSkFYLmdldFN0cmluZz1mdW5jdGlvbih1cmwsY2FsbGJhY2spXG57UkcuQUpBWCh1cmwsZnVuY3Rpb24oKVxue3ZhciBzdHI9U3RyaW5nKHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhzdHIpO30pO307UkcuQUpBWC5nZXRKU09OPWZ1bmN0aW9uKHVybCxjYWxsYmFjaylcbntSRy5BSkFYKHVybCxmdW5jdGlvbigpXG57dmFyIGpzb249ZXZhbCgnKCcrdGhpcy5yZXNwb25zZVRleHQrJyknKTtjYWxsYmFjayhqc29uKTt9KTt9O1JHLkFKQVguZ2V0Q1NWPWZ1bmN0aW9uKHVybCxjYWxsYmFjaylcbnt2YXIgc2VwZXJhdG9yPWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06JywnO1JHLkFKQVgodXJsLGZ1bmN0aW9uKClcbnt2YXIgcmVnZXhwPW5ldyBSZWdFeHAoc2VwZXJhdG9yKTt2YXIgYXJyPXRoaXMucmVzcG9uc2VUZXh0LnNwbGl0KHJlZ2V4cCk7Zm9yKHZhciBpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47KytpKXthcnJbaV09cGFyc2VGbG9hdChhcnJbaV0pO31cbmNhbGxiYWNrKGFycik7fSk7fTtSRy5yb3RhdGVDYW52YXM9UkcuUm90YXRlQ2FudmFzPWZ1bmN0aW9uKGNhLHgseSxhbmdsZSlcbnt2YXIgY289Y2EuZ2V0Q29udGV4dCgnMmQnKTtjby50cmFuc2xhdGUoeCx5KTtjby5yb3RhdGUoYW5nbGUpO2NvLnRyYW5zbGF0ZSgwLXgsMC15KTt9O1JHLm1lYXN1cmVUZXh0PVJHLk1lYXN1cmVUZXh0PWZ1bmN0aW9uKHRleHQsYm9sZCxmb250LHNpemUpXG57aWYodHlwZW9mIFJHLm1lYXN1cmV0ZXh0X2NhY2hlPT09J3VuZGVmaW5lZCcpe1JHLm1lYXN1cmV0ZXh0X2NhY2hlPVtdO31cbnZhciBzdHI9dGV4dCsnOicrYm9sZCsnOicrZm9udCsnOicrc2l6ZTtpZih0eXBlb2YgUkcubWVhc3VyZXRleHRfY2FjaGU9PSdvYmplY3QnJiZSRy5tZWFzdXJldGV4dF9jYWNoZVtzdHJdKXtyZXR1cm4gUkcubWVhc3VyZXRleHRfY2FjaGVbc3RyXTt9XG5pZighUkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtZGl2J10pe3ZhciBkaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLnRvcD0nLTEwMHB4JztkaXYuc3R5bGUubGVmdD0nLTEwMHB4Jztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7UkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtZGl2J109ZGl2O31lbHNlIGlmKFJHLm1lYXN1cmV0ZXh0X2NhY2hlWyd0ZXh0LWRpdiddKXt2YXIgZGl2PVJHLm1lYXN1cmV0ZXh0X2NhY2hlWyd0ZXh0LWRpdiddO31cbmRpdi5pbm5lckhUTUw9dGV4dC5yZXBsYWNlKC9cXHJcXG4vZywnPGJyIC8+Jyk7ZGl2LnN0eWxlLmZvbnRGYW1pbHk9Zm9udDtkaXYuc3R5bGUuZm9udFdlaWdodD1ib2xkPydib2xkJzonbm9ybWFsJztkaXYuc3R5bGUuZm9udFNpemU9KHNpemV8fDEyKSsncHQnO3ZhciBzaXplPVtkaXYub2Zmc2V0V2lkdGgsZGl2Lm9mZnNldEhlaWdodF07UkcubWVhc3VyZXRleHRfY2FjaGVbc3RyXT1zaXplO3JldHVybiBzaXplO307UkcudGV4dDI9UkcuVGV4dDI9ZnVuY3Rpb24ob2JqLG9wdClcbntmdW5jdGlvbiBkb210ZXh0KClcbntpZihTdHJpbmcob3B0LnNpemUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaXRhbGljJykhPT0tMSl7b3B0LnNpemU9b3B0LnNpemUucmVwbGFjZSgvICppdGFsaWMgKy8sJycpO29wdC5pdGFsaWM9dHJ1ZTt9XG52YXIgY2FjaGVLZXk9bWEuYWJzKHBhcnNlSW50KG9wdC54KSkrJ18nK21hLmFicyhwYXJzZUludChvcHQueSkpKydfJytTdHJpbmcob3B0LnRleHQpLnJlcGxhY2UoL1teYS16QS1aMC05XSsvZywnXycpKydfJytvYmouY2FudmFzLmlkO2lmKCFjYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyKXt2YXIgd3JhcHBlcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTt3cmFwcGVyLmlkPWNhLmlkKydfcmdyYXBoX2RvbXRleHRfd3JhcHBlcic7d3JhcHBlci5jbGFzc05hbWU9J3JncmFwaF9kb210ZXh0X3dyYXBwZXInO3dyYXBwZXIuc3R5bGUub3ZlcmZsb3c9b2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyddIT1mYWxzZSYmb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyddIT0naGlkZGVuJz8ndmlzaWJsZSc6J2hpZGRlbic7d3JhcHBlci5zdHlsZS53aWR0aD1jYS5vZmZzZXRXaWR0aCsncHgnO3dyYXBwZXIuc3R5bGUuaGVpZ2h0PWNhLm9mZnNldEhlaWdodCsncHgnO3dyYXBwZXIuc3R5bGUuY3NzRmxvYXQ9Y2Euc3R5bGUuY3NzRmxvYXQ7d3JhcHBlci5zdHlsZS5kaXNwbGF5PWNhLnN0eWxlLmRpc3BsYXl8fCdpbmxpbmUtYmxvY2snO3dyYXBwZXIuc3R5bGUucG9zaXRpb249Y2Euc3R5bGUucG9zaXRpb258fCdyZWxhdGl2ZSc7d3JhcHBlci5zdHlsZS5sZWZ0PWNhLnN0eWxlLmxlZnQ7d3JhcHBlci5zdHlsZS50b3A9Y2Euc3R5bGUudG9wO3dyYXBwZXIuc3R5bGUud2lkdGg9Y2Eud2lkdGgrJ3B4Jzt3cmFwcGVyLnN0eWxlLmhlaWdodD1jYS5oZWlnaHQrJ3B4JztjYS5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2NhLnN0eWxlLmxlZnQ9MDtjYS5zdHlsZS50b3A9MDtjYS5zdHlsZS5kaXNwbGF5PSdpbmxpbmUnO2NhLnN0eWxlLmNzc0Zsb2F0PSdub25lJztpZigob2JqLnR5cGU9PT0nYmFyJ3x8b2JqLnR5cGU9PT0nYmlwb2xhcid8fG9iai50eXBlPT09J2hiYXInKSYmb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcpe3dyYXBwZXIuc3R5bGUudHJhbnNmb3JtPSdza2V3WSg1LjdkZWcpJzt9XG5jYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLGNhKTtjYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhKTt3cmFwcGVyLmFwcGVuZENoaWxkKGNhKTtjYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyPXdyYXBwZXI7fWVsc2V7d3JhcHBlcj1jYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyO31cbnZhciBkZWZhdWx0cz17c2l6ZToxMixmb250OidBcmlhbCcsaXRhbGljOidub3JtYWwnLGJvbGQ6J25vcm1hbCcsdmFsaWduOidib3R0b20nLGhhbGlnbjonbGVmdCcsbWFya2VyOnRydWUsY29sb3I6Y28uZmlsbFN0eWxlLGJvdW5kaW5nOntlbmFibGVkOmZhbHNlLGZpbGw6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsc3Ryb2tlOicjNjY2J319XG5vcHQudGV4dD1TdHJpbmcob3B0LnRleHQpLnJlcGxhY2UoL1xccj9cXG4vZywnW1tSRVRVUk5dXScpO2lmKHR5cGVvZiBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGU9PT0ndW5kZWZpbmVkJyl7UkcudGV4dDIuZG9tTm9kZUNhY2hlPW5ldyBBcnJheSgpO31cbmlmKHR5cGVvZiBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbb2JqLmlkXT09PSd1bmRlZmluZWQnKXtSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbb2JqLmlkXT1uZXcgQXJyYXkoKTt9XG5pZih0eXBlb2YgUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlPT09J3VuZGVmaW5lZCcpe1JHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZT1uZXcgQXJyYXkoKTt9XG5pZih0eXBlb2YgUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF09PT0ndW5kZWZpbmVkJyl7UkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF09bmV3IEFycmF5KCk7fVxuaWYoIVJHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdfHwhUkcudGV4dDIuZG9tTm9kZUNhY2hlW29iai5pZF1bY2FjaGVLZXldKXt2YXIgc3Bhbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7c3Bhbi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO3NwYW4uc3R5bGUuZGlzcGxheT0naW5saW5lJztzcGFuLnN0eWxlLmxlZnQ9KG9wdC54KihwYXJzZUludChjYS5vZmZzZXRXaWR0aCkvcGFyc2VJbnQoY2Eud2lkdGgpKSkrJ3B4JztzcGFuLnN0eWxlLnRvcD0ob3B0LnkqKHBhcnNlSW50KGNhLm9mZnNldEhlaWdodCkvcGFyc2VJbnQoY2EuaGVpZ2h0KSkpKydweCc7c3Bhbi5zdHlsZS5jb2xvcj1vcHQuY29sb3J8fGRlZmF1bHRzLmNvbG9yO3NwYW4uc3R5bGUuZm9udEZhbWlseT1vcHQuZm9udHx8ZGVmYXVsdHMuZm9udDtzcGFuLnN0eWxlLmZvbnRXZWlnaHQ9b3B0LmJvbGQ/J2JvbGQnOmRlZmF1bHRzLmJvbGQ7c3Bhbi5zdHlsZS5mb250U3R5bGU9b3B0Lml0YWxpYz8naXRhbGljJzpkZWZhdWx0cy5pdGFsaWM7c3Bhbi5zdHlsZS5mb250U2l6ZT0ob3B0LnNpemV8fGRlZmF1bHRzLnNpemUpKydwdCc7c3Bhbi5zdHlsZS53aGl0ZVNwYWNlPSdub3dyYXAnO3NwYW4udGFnPW9wdC50YWc7aWYodHlwZW9mIG9wdC5hbmdsZT09PSdudW1iZXInJiZvcHQuYW5nbGUhPT0wKXt2YXIgY29vcmRzPVJHLm1lYXN1cmVUZXh0KG9wdC50ZXh0LG9wdC5ib2xkLG9wdC5mb250LG9wdC5zaXplKTtzcGFuLnN0eWxlLnRyYW5zZm9ybU9yaWdpbj0nMTAwJSA1MCUnO3NwYW4uc3R5bGUudHJhbnNmb3JtPSdyb3RhdGUoJytvcHQuYW5nbGUrJ2RlZyknO31cbnNwYW4uc3R5bGUudGV4dFNoYWRvdz0nezF9cHggezJ9cHggezN9cHggezR9Jy5mb3JtYXQoY28uc2hhZG93T2Zmc2V0WCxjby5zaGFkb3dPZmZzZXRZLGNvLnNoYWRvd0JsdXIsY28uc2hhZG93Q29sb3IpO2lmKG9wdC5ib3VuZGluZyl7c3Bhbi5zdHlsZS5ib3JkZXI9JzFweCBzb2xpZCAnKyhvcHRbJ2JvdW5kaW5nLnN0cm9rZSddfHxkZWZhdWx0cy5ib3VuZGluZy5zdHJva2UpO3NwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yPW9wdFsnYm91bmRpbmcuZmlsbCddfHxkZWZhdWx0cy5ib3VuZGluZy5maWxsO31cbmlmKCh0eXBlb2Ygb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJ109PT0ndW5kZWZpbmVkJ3x8b2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJ10pJiZvYmoucHJvcGVydGllc1snY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnXSE9PSdub25lJyl7c3Bhbi5zdHlsZS5wb2ludGVyRXZlbnRzPSdhdXRvJzt9ZWxzZXtzcGFuLnN0eWxlLnBvaW50ZXJFdmVudHM9J25vbmUnO31cbnNwYW4uc3R5bGUucGFkZGluZz1vcHQuYm91bmRpbmc/JzJweCc6bnVsbDtzcGFuLl9fdGV4dF9fPW9wdC50ZXh0XG5zcGFuLmlubmVySFRNTD1vcHQudGV4dC5yZXBsYWNlKCcmJywnJmFtcDsnKS5yZXBsYWNlKCc8JywnJmx0OycpLnJlcGxhY2UoJz4nLCcmZ3Q7Jyk7c3Bhbi5pbm5lckhUTUw9c3Bhbi5pbm5lckhUTUwucmVwbGFjZSgvXFxbXFxbUkVUVVJOXFxdXFxdL2csJzxiciAvPicpO3dyYXBwZXIuYXBwZW5kQ2hpbGQoc3Bhbik7b3B0LmhhbGlnbj1vcHQuaGFsaWdufHwnbGVmdCc7b3B0LnZhbGlnbj1vcHQudmFsaWdufHwnYm90dG9tJztpZihvcHQuaGFsaWduPT09J3JpZ2h0Jyl7c3Bhbi5zdHlsZS5sZWZ0PXBhcnNlRmxvYXQoc3Bhbi5zdHlsZS5sZWZ0KS1zcGFuLm9mZnNldFdpZHRoKydweCc7c3Bhbi5zdHlsZS50ZXh0QWxpZ249J3JpZ2h0Jzt9ZWxzZSBpZihvcHQuaGFsaWduPT09J2NlbnRlcicpe3NwYW4uc3R5bGUubGVmdD1wYXJzZUZsb2F0KHNwYW4uc3R5bGUubGVmdCktKHNwYW4ub2Zmc2V0V2lkdGgvMikrJ3B4JztzcGFuLnN0eWxlLnRleHRBbGlnbj0nY2VudGVyJzt9XG5pZihvcHQudmFsaWduPT09J3RvcCcpe31lbHNlIGlmKG9wdC52YWxpZ249PT0nY2VudGVyJyl7c3Bhbi5zdHlsZS50b3A9cGFyc2VGbG9hdChzcGFuLnN0eWxlLnRvcCktKHNwYW4ub2Zmc2V0SGVpZ2h0LzIpKydweCc7fWVsc2V7c3Bhbi5zdHlsZS50b3A9cGFyc2VGbG9hdChzcGFuLnN0eWxlLnRvcCktc3Bhbi5vZmZzZXRIZWlnaHQrJ3B4Jzt9XG52YXIgb2Zmc2V0V2lkdGg9cGFyc2VGbG9hdChzcGFuLm9mZnNldFdpZHRoKSxvZmZzZXRIZWlnaHQ9cGFyc2VGbG9hdChzcGFuLm9mZnNldEhlaWdodCksdG9wPXBhcnNlRmxvYXQoc3Bhbi5zdHlsZS50b3ApLGxlZnQ9cGFyc2VGbG9hdChzcGFuLnN0eWxlLmxlZnQpO1JHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdW2NhY2hlS2V5XT1zcGFuO1JHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZVtvYmouaWRdW2NhY2hlS2V5XT17bGVmdDpsZWZ0LHRvcDp0b3Asd2lkdGg6b2Zmc2V0V2lkdGgsaGVpZ2h0Om9mZnNldEhlaWdodH07c3Bhbi5pZD1jYWNoZUtleTt9ZWxzZXtzcGFuPVJHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdW2NhY2hlS2V5XTtzcGFuLnN0eWxlLmRpc3BsYXk9J2lubGluZSc7dmFyIG9mZnNldFdpZHRoPVJHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZVtvYmouaWRdW2NhY2hlS2V5XS53aWR0aCxvZmZzZXRIZWlnaHQ9UkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF1bY2FjaGVLZXldLmhlaWdodCx0b3A9UkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF1bY2FjaGVLZXldLnRvcCxsZWZ0PVJHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZVtvYmouaWRdW2NhY2hlS2V5XS5sZWZ0O31cbmlmKG9wdC5tYXJrZXIpe1JHLnBhdGgyKGNvbnRleHQsJ2IgbSAlICUgbCAlICUgbSAlICUgbCAlICUgcycsb3B0LngtNSxvcHQueSxvcHQueCs1LG9wdC55LG9wdC54LG9wdC55LTUsb3B0Lngsb3B0LnkrNSk7fVxuaWYob2JqLnR5cGU9PT0nZHJhd2luZy50ZXh0Jyl7aWYob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnXSl7c3Bhbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGUpeyhvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSddKShlLG9iaik7fSxmYWxzZSk7fVxuaWYob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmV2ZW50cy5jbGljayddKXtzcGFuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbihlKXsob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmV2ZW50cy5jbGljayddKShlLG9iaik7fSxmYWxzZSk7fVxuaWYob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRvb2x0aXBzJ10pe3NwYW4uYWRkRXZlbnRMaXN0ZW5lcihvYmoucHJvcGVydGllc1snY2hhcnQudG9vbHRpcHMuZXZlbnQnXS5pbmRleE9mKCdtb3VzZW1vdmUnKSE9PS0xPydtb3VzZW1vdmUnOidjbGljaycsZnVuY3Rpb24oZSlcbntpZighUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJyl8fFJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQudG9vbHRpcCcpLl9faW5kZXhfXyE9PTB8fFJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQudG9vbHRpcCcpLl9fb2JqZWN0X18udWlkIT1vYmoudWlkKXtSRy5oaWRlVG9vbHRpcCgpO1JHLnJlZHJhdygpO1JHLnRvb2x0aXAob2JqLG9iai5wcm9wZXJ0aWVzWydjaGFydC50b29sdGlwcyddWzBdLG9wdC54LG9wdC55LDAsZSk7fX0sZmFsc2UpO319XG52YXIgcmV0PXt9O3JldC54PWxlZnQ7cmV0Lnk9dG9wO3JldC53aWR0aD1vZmZzZXRXaWR0aDtyZXQuaGVpZ2h0PW9mZnNldEhlaWdodDtyZXQub2JqZWN0PW9iajtyZXQudGV4dD1vcHQudGV4dDtyZXQudGFnPW9wdC50YWc7UkcudGV4dDIuZG9tTm9kZUNhY2hlLnJlc2V0PWZ1bmN0aW9uKClcbntpZihhcmd1bWVudHNbMF0pe2lmKHR5cGVvZiBhcmd1bWVudHNbMF09PT0nc3RyaW5nJyl7dmFyIGNhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFyZ3VtZW50c1swXSl9ZWxzZXt2YXIgY2E9YXJndW1lbnRzWzBdO31cbnZhciBub2Rlcz1SRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbY2EuaWRdO2ZvcihqIGluIG5vZGVzKXt2YXIgbm9kZT1SRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbY2EuaWRdW2pdO2lmKG5vZGUmJm5vZGUucGFyZW50Tm9kZSl7bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO319XG5SRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbY2EuaWRdPVtdO1JHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZVtjYS5pZF09W107fWVsc2V7Zm9yKGkgaW4gUkcudGV4dDIuZG9tTm9kZUNhY2hlKXtmb3IoaiBpbiBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbaV0pe2lmKFJHLnRleHQyLmRvbU5vZGVDYWNoZVtpXVtqXSYmUkcudGV4dDIuZG9tTm9kZUNhY2hlW2ldW2pdLnBhcmVudE5vZGUpe1JHLnRleHQyLmRvbU5vZGVDYWNoZVtpXVtqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKFJHLnRleHQyLmRvbU5vZGVDYWNoZVtpXVtqXSk7fX19XG5SRy50ZXh0Mi5kb21Ob2RlQ2FjaGU9W107UkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlPVtdO319O1JHLnRleHQyLmZpbmQ9ZnVuY3Rpb24ob3B0KVxue3ZhciBzcGFuLG5vZGVzPVtdO3ZhciBpZD10eXBlb2Ygb3B0LmlkPT09J3N0cmluZyc/b3B0LmlkOm9wdC5vYmplY3QuaWQ7Zm9yKGkgaW4gUkcudGV4dDIuZG9tTm9kZUNhY2hlW2lkXSl7c3Bhbj1SRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbaWRdW2ldO2lmKHR5cGVvZiBvcHQudGFnPT09J3N0cmluZycmJm9wdC50YWc9PT1zcGFuLnRhZyl7bm9kZXMucHVzaChzcGFuKTtjb250aW51ZTt9XG5pZih0eXBlb2Ygb3B0LnRhZz09PSdvYmplY3QnJiZvcHQudGFnLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignUmVnRXhwJykpe3ZhciByZWdleHA9bmV3IFJlZ0V4cChvcHQudGFnKTtpZihyZWdleHAudGVzdChzcGFuLnRhZykpe25vZGVzLnB1c2goc3Bhbik7Y29udGludWU7fX1cbmlmKHR5cGVvZiBvcHQudGV4dD09PSdzdHJpbmcnJiZvcHQudGV4dD09PXNwYW4uX190ZXh0X18pe25vZGVzLnB1c2goc3Bhbik7Y29udGludWU7fVxuaWYodHlwZW9mIG9wdC50ZXh0PT09J29iamVjdCcmJm9wdC50ZXh0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignUmVnRXhwJykpe3ZhciByZWdleHA9bmV3IFJlZ0V4cChvcHQudGV4dCk7aWYocmVnZXhwLnRlc3Qoc3Bhbi5fX3RleHRfXykpe25vZGVzLnB1c2goc3Bhbik7Y29udGludWU7fX19XG5yZXR1cm4gbm9kZXM7fTtyZXQubm9kZT1zcGFuO2lmKG9iaiYmb2JqLmlzUkdyYXBoJiZvYmouY29vcmRzVGV4dCl7b2JqLmNvb3Jkc1RleHQucHVzaChyZXQpO31cbnJldHVybiByZXQ7fVxuaWYob2JqJiZvYmouaXNSR3JhcGgpe3ZhciBvYmo9b2JqO3ZhciBjbz1vYmouY29udGV4dDt2YXIgY2E9b2JqLmNhbnZhczt9ZWxzZSBpZih0eXBlb2Ygb2JqPT0nc3RyaW5nJyl7dmFyIGNhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iaik7dmFyIGNvPWNhLmdldENvbnRleHQoJzJkJyk7dmFyIG9iaj1jYS5fX29iamVjdF9fO31lbHNlIGlmKHR5cGVvZiBvYmouZ2V0Q29udGV4dD09PSdmdW5jdGlvbicpe3ZhciBjYT1vYmo7dmFyIGNvPWNhLmdldENvbnRleHQoJzJkJyk7dmFyIG9iaj1jYS5fX29iamVjdF9fO31lbHNlIGlmKG9iai50b1N0cmluZygpLmluZGV4T2YoJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCcpIT0tMXx8UkdyYXBoLklTSUU4JiZvYmoubW92ZVRvKXt2YXIgY289b2JqO3ZhciBjYT1vYmouY2FudmFzO3ZhciBvYmo9Y2EuX19vYmplY3RfXzt9ZWxzZSBpZihSRy5JU09MRCYmb2JqLmZpbGxUZXh0KXt2YXIgY289b2JqO3ZhciBjYT1vYmouY2FudmFzO3ZhciBvYmo9Y2EuX19vYmplY3RfXzt9XG5pZih0eXBlb2Ygb3B0LmJvdW5kaW5nRmlsbD09PSdzdHJpbmcnKW9wdFsnYm91bmRpbmcuZmlsbCddPW9wdC5ib3VuZGluZ0ZpbGw7aWYodHlwZW9mIG9wdC5ib3VuZGluZ1N0cm9rZT09PSdzdHJpbmcnKW9wdFsnYm91bmRpbmcuc3Ryb2tlJ109b3B0LmJvdW5kaW5nU3Ryb2tlO2lmKG9iaiYmb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddJiZvcHQuYWNjZXNzaWJsZSE9PWZhbHNlKXtyZXR1cm4gZG9tdGV4dCgpO31cbnZhciB4PW9wdC54LHk9b3B0Lnksb3JpZ2luYWxYPXgsb3JpZ2luYWxZPXksdGV4dD1vcHQudGV4dCx0ZXh0X211bHRpbGluZT10eXBlb2YgdGV4dD09PSdzdHJpbmcnP3RleHQuc3BsaXQoL1xccj9cXG4vZyk6JycsbnVtbGluZXM9dGV4dF9tdWx0aWxpbmUubGVuZ3RoLGZvbnQ9b3B0LmZvbnQ/b3B0LmZvbnQ6J0FyaWFsJyxzaXplPW9wdC5zaXplP29wdC5zaXplOjEwLHNpemVfcGl4ZWxzPXNpemUqMS41LGJvbGQ9b3B0LmJvbGQsaXRhbGljPW9wdC5pdGFsaWMsaGFsaWduPW9wdC5oYWxpZ24/b3B0LmhhbGlnbjonbGVmdCcsdmFsaWduPW9wdC52YWxpZ24/b3B0LnZhbGlnbjonYm90dG9tJyx0YWc9dHlwZW9mIG9wdC50YWc9PSdzdHJpbmcnJiZvcHQudGFnLmxlbmd0aD4wP29wdC50YWc6JycsbWFya2VyPW9wdC5tYXJrZXIsYW5nbGU9b3B0LmFuZ2xlfHwwXG52YXIgYm91bmRpbmc9b3B0LmJvdW5kaW5nLGJvdW5kaW5nX3N0cm9rZT1vcHRbJ2JvdW5kaW5nLnN0cm9rZSddP29wdFsnYm91bmRpbmcuc3Ryb2tlJ106J2JsYWNrJyxib3VuZGluZ19maWxsPW9wdFsnYm91bmRpbmcuZmlsbCddP29wdFsnYm91bmRpbmcuZmlsbCddOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLGJvdW5kaW5nX3NoYWRvdz1vcHRbJ2JvdW5kaW5nLnNoYWRvdyddLGJvdW5kaW5nX3NoYWRvd19jb2xvcj1vcHRbJ2JvdW5kaW5nLnNoYWRvdy5jb2xvciddfHwnI2NjYycsYm91bmRpbmdfc2hhZG93X2JsdXI9b3B0Wydib3VuZGluZy5zaGFkb3cuYmx1ciddfHwzLGJvdW5kaW5nX3NoYWRvd19vZmZzZXR4PW9wdFsnYm91bmRpbmcuc2hhZG93Lm9mZnNldHgnXXx8Myxib3VuZGluZ19zaGFkb3dfb2Zmc2V0eT1vcHRbJ2JvdW5kaW5nLnNoYWRvdy5vZmZzZXR5J118fDMsYm91bmRpbmdfbGluZXdpZHRoPW9wdFsnYm91bmRpbmcubGluZXdpZHRoJ118fDE7dmFyIHJldD17fTtpZih0eXBlb2Ygb3B0LmNvbG9yPT09J3N0cmluZycpe3ZhciBvcmlnX2ZpbGxzdHlsZT1jby5maWxsU3R5bGU7Y28uZmlsbFN0eWxlPW9wdC5jb2xvcjt9XG5pZih0eXBlb2YgdGV4dD09J251bWJlcicpe3RleHQ9U3RyaW5nKHRleHQpO31cbmlmKHR5cGVvZiB0ZXh0IT09J3N0cmluZycpe3JldHVybjt9XG5pZihhbmdsZSE9MCl7Y28uc2F2ZSgpO2NvLnRyYW5zbGF0ZSh4LHkpO2NvLnJvdGF0ZSgobWEuUEkvMTgwKSphbmdsZSlcbng9MDt5PTA7fVxuY28uZm9udD0ob3B0Lml0YWxpYz8naXRhbGljICc6JycpKyhvcHQuYm9sZD8nYm9sZCAnOicnKStzaXplKydwdCAnK2ZvbnQ7dmFyIHdpZHRoPTA7Zm9yKHZhciBpPTA7aTxudW1saW5lczsrK2kpe3dpZHRoPW1hLm1heCh3aWR0aCxjby5tZWFzdXJlVGV4dCh0ZXh0X211bHRpbGluZVtpXSkud2lkdGgpO31cbnZhciBoZWlnaHQ9c2l6ZV9waXhlbHMqbnVtbGluZXM7aWYob3B0Lm1hcmtlcil7dmFyIG1hcmtlcl9zaXplPTEwO3ZhciBzdHJva2VzdHlsZT1jby5zdHJva2VTdHlsZTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT0ncmVkJztjby5tb3ZlVG8oeCx5LW1hcmtlcl9zaXplKTtjby5saW5lVG8oeCx5K21hcmtlcl9zaXplKTtjby5tb3ZlVG8oeC1tYXJrZXJfc2l6ZSx5KTtjby5saW5lVG8oeCttYXJrZXJfc2l6ZSx5KTtjby5zdHJva2UoKTtjby5zdHJva2VTdHlsZT1zdHJva2VzdHlsZTt9XG5pZihoYWxpZ249PSdjZW50ZXInKXtjby50ZXh0QWxpZ249J2NlbnRlcic7dmFyIGJvdW5kaW5nWD14LTItKHdpZHRoLzIpO31lbHNlIGlmKGhhbGlnbj09J3JpZ2h0Jyl7Y28udGV4dEFsaWduPSdyaWdodCc7dmFyIGJvdW5kaW5nWD14LTItd2lkdGg7fWVsc2V7Y28udGV4dEFsaWduPSdsZWZ0Jzt2YXIgYm91bmRpbmdYPXgtMjt9XG5pZih2YWxpZ249PSdjZW50ZXInKXtjby50ZXh0QmFzZWxpbmU9J21pZGRsZSc7eS09MTt5LT0oKG51bWxpbmVzLTEpLzIpKnNpemVfcGl4ZWxzO3ZhciBib3VuZGluZ1k9eS0oc2l6ZV9waXhlbHMvMiktMjt9ZWxzZSBpZih2YWxpZ249PSd0b3AnKXtjby50ZXh0QmFzZWxpbmU9J3RvcCc7dmFyIGJvdW5kaW5nWT15LTI7fWVsc2V7Y28udGV4dEJhc2VsaW5lPSdib3R0b20nO2lmKG51bWxpbmVzPjEpe3ktPSgobnVtbGluZXMtMSkqc2l6ZV9waXhlbHMpO31cbnZhciBib3VuZGluZ1k9eS1zaXplX3BpeGVscy0yO31cbnZhciBib3VuZGluZ1c9d2lkdGgrNDt2YXIgYm91bmRpbmdIPWhlaWdodCs0O2lmKGJvdW5kaW5nKXt2YXIgcHJlX2JvdW5kaW5nX2xpbmV3aWR0aD1jby5saW5lV2lkdGg7dmFyIHByZV9ib3VuZGluZ19zdHJva2VzdHlsZT1jby5zdHJva2VTdHlsZTt2YXIgcHJlX2JvdW5kaW5nX2ZpbGxzdHlsZT1jby5maWxsU3R5bGU7dmFyIHByZV9ib3VuZGluZ19zaGFkb3djb2xvcj1jby5zaGFkb3dDb2xvcjt2YXIgcHJlX2JvdW5kaW5nX3NoYWRvd2JsdXI9Y28uc2hhZG93Qmx1cjt2YXIgcHJlX2JvdW5kaW5nX3NoYWRvd29mZnNldHg9Y28uc2hhZG93T2Zmc2V0WDt2YXIgcHJlX2JvdW5kaW5nX3NoYWRvd29mZnNldHk9Y28uc2hhZG93T2Zmc2V0WTtjby5saW5lV2lkdGg9Ym91bmRpbmdfbGluZXdpZHRoO2NvLnN0cm9rZVN0eWxlPWJvdW5kaW5nX3N0cm9rZTtjby5maWxsU3R5bGU9Ym91bmRpbmdfZmlsbDtpZihib3VuZGluZ19zaGFkb3cpe2NvLnNoYWRvd0NvbG9yPWJvdW5kaW5nX3NoYWRvd19jb2xvcjtjby5zaGFkb3dCbHVyPWJvdW5kaW5nX3NoYWRvd19ibHVyO2NvLnNoYWRvd09mZnNldFg9Ym91bmRpbmdfc2hhZG93X29mZnNldHg7Y28uc2hhZG93T2Zmc2V0WT1ib3VuZGluZ19zaGFkb3dfb2Zmc2V0eTt9XG5jby5zdHJva2VSZWN0KGJvdW5kaW5nWCxib3VuZGluZ1ksYm91bmRpbmdXLGJvdW5kaW5nSCk7Y28uZmlsbFJlY3QoYm91bmRpbmdYLGJvdW5kaW5nWSxib3VuZGluZ1csYm91bmRpbmdIKTtjby5saW5lV2lkdGg9cHJlX2JvdW5kaW5nX2xpbmV3aWR0aDtjby5zdHJva2VTdHlsZT1wcmVfYm91bmRpbmdfc3Ryb2tlc3R5bGU7Y28uZmlsbFN0eWxlPXByZV9ib3VuZGluZ19maWxsc3R5bGU7Y28uc2hhZG93Q29sb3I9cHJlX2JvdW5kaW5nX3NoYWRvd2NvbG9yXG5jby5zaGFkb3dCbHVyPXByZV9ib3VuZGluZ19zaGFkb3dibHVyXG5jby5zaGFkb3dPZmZzZXRYPXByZV9ib3VuZGluZ19zaGFkb3dvZmZzZXR4XG5jby5zaGFkb3dPZmZzZXRZPXByZV9ib3VuZGluZ19zaGFkb3dvZmZzZXR5fVxuaWYobnVtbGluZXM+MSl7Zm9yKHZhciBpPTA7aTxudW1saW5lczsrK2kpe2NvLmZpbGxUZXh0KHRleHRfbXVsdGlsaW5lW2ldLHgseSsoc2l6ZV9waXhlbHMqaSkpO319ZWxzZXtjby5maWxsVGV4dCh0ZXh0LHgrMC41LHkrMC41KTt9XG5pZihhbmdsZSE9MCl7aWYoYW5nbGU9PTkwKXtpZihoYWxpZ249PSdsZWZ0Jyl7aWYodmFsaWduPT0nYm90dG9tJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fVxuaWYodmFsaWduPT0nY2VudGVyJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0oaGVpZ2h0LzIpLTI7Ym91bmRpbmdZPW9yaWdpbmFsWS0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSd0b3AnKXtib3VuZGluZ1g9b3JpZ2luYWxYLWhlaWdodC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fX1lbHNlIGlmKGhhbGlnbj09J2NlbnRlcicpe2lmKHZhbGlnbj09J2JvdHRvbScpe2JvdW5kaW5nWD1vcmlnaW5hbFgtMjtib3VuZGluZ1k9b3JpZ2luYWxZLSh3aWR0aC8yKS0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSdjZW50ZXInKXtib3VuZGluZ1g9b3JpZ2luYWxYLShoZWlnaHQvMiktMjtib3VuZGluZ1k9b3JpZ2luYWxZLSh3aWR0aC8yKS0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSd0b3AnKXtib3VuZGluZ1g9b3JpZ2luYWxYLWhlaWdodC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktKHdpZHRoLzIpLTI7Ym91bmRpbmdXPWhlaWdodCs0O2JvdW5kaW5nSD13aWR0aCs0O319ZWxzZSBpZihoYWxpZ249PSdyaWdodCcpe2lmKHZhbGlnbj09J2JvdHRvbScpe2JvdW5kaW5nWD1vcmlnaW5hbFgtMjtib3VuZGluZ1k9b3JpZ2luYWxZLXdpZHRoLTI7Ym91bmRpbmdXPWhlaWdodCs0O2JvdW5kaW5nSD13aWR0aCs0O31cbmlmKHZhbGlnbj09J2NlbnRlcicpe2JvdW5kaW5nWD1vcmlnaW5hbFgtKGhlaWdodC8yKS0yO2JvdW5kaW5nWT1vcmlnaW5hbFktd2lkdGgtMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fVxuaWYodmFsaWduPT0ndG9wJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC1oZWlnaHQtMjtib3VuZGluZ1k9b3JpZ2luYWxZLXdpZHRoLTI7Ym91bmRpbmdXPWhlaWdodCs0O2JvdW5kaW5nSD13aWR0aCs0O319fWVsc2UgaWYoYW5nbGU9PTE4MCl7aWYoaGFsaWduPT0nbGVmdCcpe2lmKHZhbGlnbj09J2JvdHRvbScpe2JvdW5kaW5nWD1vcmlnaW5hbFgtd2lkdGgtMjtib3VuZGluZ1k9b3JpZ2luYWxZLTI7Ym91bmRpbmdXPXdpZHRoKzQ7Ym91bmRpbmdIPWhlaWdodCs0O31cbmlmKHZhbGlnbj09J2NlbnRlcicpe2JvdW5kaW5nWD1vcmlnaW5hbFgtd2lkdGgtMjtib3VuZGluZ1k9b3JpZ2luYWxZLShoZWlnaHQvMiktMjtib3VuZGluZ1c9d2lkdGgrNDtib3VuZGluZ0g9aGVpZ2h0KzQ7fVxuaWYodmFsaWduPT0ndG9wJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC13aWR0aC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktaGVpZ2h0LTI7Ym91bmRpbmdXPXdpZHRoKzQ7Ym91bmRpbmdIPWhlaWdodCs0O319ZWxzZSBpZihoYWxpZ249PSdjZW50ZXInKXtpZih2YWxpZ249PSdib3R0b20nKXtib3VuZGluZ1g9b3JpZ2luYWxYLSh3aWR0aC8yKS0yO2JvdW5kaW5nWT1vcmlnaW5hbFktMjtib3VuZGluZ1c9d2lkdGgrNDtib3VuZGluZ0g9aGVpZ2h0KzQ7fVxuaWYodmFsaWduPT0nY2VudGVyJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0od2lkdGgvMiktMjtib3VuZGluZ1k9b3JpZ2luYWxZLShoZWlnaHQvMiktMjtib3VuZGluZ1c9d2lkdGgrNDtib3VuZGluZ0g9aGVpZ2h0KzQ7fVxuaWYodmFsaWduPT0ndG9wJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0od2lkdGgvMiktMjtib3VuZGluZ1k9b3JpZ2luYWxZLWhlaWdodC0yO2JvdW5kaW5nVz13aWR0aCs0O2JvdW5kaW5nSD1oZWlnaHQrNDt9fWVsc2UgaWYoaGFsaWduPT0ncmlnaHQnKXtpZih2YWxpZ249PSdib3R0b20nKXtib3VuZGluZ1g9b3JpZ2luYWxYLTI7Ym91bmRpbmdZPW9yaWdpbmFsWS0yO2JvdW5kaW5nVz13aWR0aCs0O2JvdW5kaW5nSD1oZWlnaHQrNDt9XG5pZih2YWxpZ249PSdjZW50ZXInKXtib3VuZGluZ1g9b3JpZ2luYWxYLTI7Ym91bmRpbmdZPW9yaWdpbmFsWS0oaGVpZ2h0LzIpLTI7Ym91bmRpbmdXPXdpZHRoKzQ7Ym91bmRpbmdIPWhlaWdodCs0O31cbmlmKHZhbGlnbj09J3RvcCcpe2JvdW5kaW5nWD1vcmlnaW5hbFgtMjtib3VuZGluZ1k9b3JpZ2luYWxZLWhlaWdodC0yO2JvdW5kaW5nVz13aWR0aCs0O2JvdW5kaW5nSD1oZWlnaHQrNDt9fX1lbHNlIGlmKGFuZ2xlPT0yNzApe2lmKGhhbGlnbj09J2xlZnQnKXtpZih2YWxpZ249PSdib3R0b20nKXtib3VuZGluZ1g9b3JpZ2luYWxYLWhlaWdodC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktd2lkdGgtMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fVxuaWYodmFsaWduPT0nY2VudGVyJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0oaGVpZ2h0LzIpLTQ7Ym91bmRpbmdZPW9yaWdpbmFsWS13aWR0aC0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSd0b3AnKXtib3VuZGluZ1g9b3JpZ2luYWxYLTI7Ym91bmRpbmdZPW9yaWdpbmFsWS13aWR0aC0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9fWVsc2UgaWYoaGFsaWduPT0nY2VudGVyJyl7aWYodmFsaWduPT0nYm90dG9tJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC1oZWlnaHQtMjtib3VuZGluZ1k9b3JpZ2luYWxZLSh3aWR0aC8yKS0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSdjZW50ZXInKXtib3VuZGluZ1g9b3JpZ2luYWxYLShoZWlnaHQvMiktNDtib3VuZGluZ1k9b3JpZ2luYWxZLSh3aWR0aC8yKS0yO2JvdW5kaW5nVz1oZWlnaHQrNDtib3VuZGluZ0g9d2lkdGgrNDt9XG5pZih2YWxpZ249PSd0b3AnKXtib3VuZGluZ1g9b3JpZ2luYWxYLTI7Ym91bmRpbmdZPW9yaWdpbmFsWS0od2lkdGgvMiktMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fX1lbHNlIGlmKGhhbGlnbj09J3JpZ2h0Jyl7aWYodmFsaWduPT0nYm90dG9tJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC1oZWlnaHQtMjtib3VuZGluZ1k9b3JpZ2luYWxZLTI7Ym91bmRpbmdXPWhlaWdodCs0O2JvdW5kaW5nSD13aWR0aCs0O31cbmlmKHZhbGlnbj09J2NlbnRlcicpe2JvdW5kaW5nWD1vcmlnaW5hbFgtKGhlaWdodC8yKS0yO2JvdW5kaW5nWT1vcmlnaW5hbFktMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fVxuaWYodmFsaWduPT0ndG9wJyl7Ym91bmRpbmdYPW9yaWdpbmFsWC0yO2JvdW5kaW5nWT1vcmlnaW5hbFktMjtib3VuZGluZ1c9aGVpZ2h0KzQ7Ym91bmRpbmdIPXdpZHRoKzQ7fX19XG5jby5yZXN0b3JlKCk7fVxuY28udGV4dEJhc2VsaW5lPSdhbHBoYWJldGljJztjby50ZXh0QWxpZ249J2xlZnQnO3JldC54PWJvdW5kaW5nWDtyZXQueT1ib3VuZGluZ1k7cmV0LndpZHRoPWJvdW5kaW5nVztyZXQuaGVpZ2h0PWJvdW5kaW5nSFxucmV0Lm9iamVjdD1vYmo7cmV0LnRleHQ9dGV4dDtyZXQudGFnPXRhZztpZihvYmomJm9iai5pc1JHcmFwaCYmb2JqLmNvb3Jkc1RleHQpe29iai5jb29yZHNUZXh0LnB1c2gocmV0KTt9XG5pZih0eXBlb2Ygb3JpZ19maWxsc3R5bGU9PT0nc3RyaW5nJyl7Y28uZmlsbFN0eWxlPW9yaWdfZmlsbHN0eWxlO31cbnJldHVybiByZXQ7fTtSRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQ9ZnVuY3Rpb24oaW5kZXgsZGF0YSlcbnt2YXIgZ3JvdXA9MDt2YXIgZ3JvdXBlZF9pbmRleD0wO3doaWxlKC0taW5kZXg+PTApe2lmKFJHLmlzX251bGwoZGF0YVtncm91cF0pKXtncm91cCsrO2dyb3VwZWRfaW5kZXg9MDtjb250aW51ZTt9XG5pZih0eXBlb2YgZGF0YVtncm91cF09PSdudW1iZXInKXtncm91cCsrXG5ncm91cGVkX2luZGV4PTA7Y29udGludWU7fVxuZ3JvdXBlZF9pbmRleCsrO2lmKGdyb3VwZWRfaW5kZXg+PWRhdGFbZ3JvdXBdLmxlbmd0aCl7Z3JvdXArKztncm91cGVkX2luZGV4PTA7fX1cbnJldHVybltncm91cCxncm91cGVkX2luZGV4XTt9O1JHLkhpZ2hsaWdodC5yZWN0PVJHLkhpZ2hsaWdodC5SZWN0PWZ1bmN0aW9uKG9iaixzaGFwZSlcbnt2YXIgY2E9b2JqLmNhbnZhczt2YXIgY289b2JqLmNvbnRleHQ7dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2NvLmxpbmVXaWR0aD0xO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTtjby5yZWN0KHNoYXBlWyd4J10sc2hhcGVbJ3knXSxzaGFwZVsnd2lkdGgnXSxzaGFwZVsnaGVpZ2h0J10pO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9fTtSRy5IaWdobGlnaHQucG9pbnQ9UkcuSGlnaGxpZ2h0LlBvaW50PWZ1bmN0aW9uKG9iaixzaGFwZSlcbnt2YXIgcHJvcD1vYmoucHJvcGVydGllczt2YXIgY2E9b2JqLmNhbnZhczt2YXIgY289b2JqLmNvbnRleHQ7aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTt2YXIgcmFkaXVzPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5wb2ludC5yYWRpdXMnXXx8Mjtjby5hcmMoc2hhcGVbJ3gnXSxzaGFwZVsneSddLHJhZGl1cywwLFJHLlRXT1BJLDApO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9fTtSRy5wYXJzZURhdGU9ZnVuY3Rpb24oc3RyKVxue3N0cj1SRy50cmltKHN0cik7aWYoc3RyPT09J25vdycpe3N0cj0obmV3IERhdGUoKSkudG9TdHJpbmcoKTt9XG5pZihzdHIubWF0Y2goL14oXFxkXFxkKSg/Oi18XFwvKShcXGRcXGQpKD86LXxcXC8pKFxcZFxcZFxcZFxcZCkoLiopJC8pKXtzdHI9J3sxfS97Mn0vezN9ezR9Jy5mb3JtYXQoUmVnRXhwLiQzLFJlZ0V4cC4kMixSZWdFeHAuJDEsUmVnRXhwLiQ0KTt9XG5pZihzdHIubWF0Y2goL14oXFxkXFxkXFxkXFxkKSgtfFxcLykoXFxkXFxkKSgtfFxcLykoXFxkXFxkKSggfFQpKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkkLykpe3N0cj1SZWdFeHAuJDErJy0nK1JlZ0V4cC4kMysnLScrUmVnRXhwLiQ1KydUJytSZWdFeHAuJDcrJzonK1JlZ0V4cC4kOCsnOicrUmVnRXhwLiQ5O31cbmlmKHN0ci5tYXRjaCgvXlxcZFxcZFxcZFxcZC1cXGRcXGQtXFxkXFxkJC8pKXtzdHI9c3RyLnJlcGxhY2UoLy0vZywnLycpO31cbmlmKHN0ci5tYXRjaCgvXlxcZFxcZDpcXGRcXGQ6XFxkXFxkJC8pKXt2YXIgZGF0ZU9iaj1uZXcgRGF0ZSgpO3ZhciBkYXRlPWRhdGVPYmouZ2V0RGF0ZSgpO3ZhciBtb250aD1kYXRlT2JqLmdldE1vbnRoKCkrMTt2YXIgeWVhcj1kYXRlT2JqLmdldEZ1bGxZZWFyKCk7aWYoU3RyaW5nKG1vbnRoKS5sZW5ndGg9PT0xKW1vbnRoPScwJyttb250aDtpZihTdHJpbmcoZGF0ZSkubGVuZ3RoPT09MSlkYXRlPScwJytkYXRlO3N0cj0oeWVhcisnLycrbW9udGgrJy8nK2RhdGUpKycgJytzdHI7fVxucmV0dXJuIERhdGUucGFyc2Uoc3RyKTt9O1JHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcz1mdW5jdGlvbihvYmopXG57aWYob2JqLm9yaWdpbmFsX2NvbG9ycyl7Zm9yKHZhciBqIGluIG9iai5vcmlnaW5hbF9jb2xvcnMpe2lmKHR5cGVvZiBqPT09J3N0cmluZycmJmouc3Vic3RyKDAsNik9PT0nY2hhcnQuJyl7b2JqLnByb3BlcnRpZXNbal09UkcuYXJyYXlDbG9uZShvYmoub3JpZ2luYWxfY29sb3JzW2pdKTt9fX1cbmlmKHR5cGVvZiBvYmoucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzPT09J2Z1bmN0aW9uJyl7b2JqLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcygpO31cbm9iai5jb2xvcnNQYXJzZWQ9ZmFsc2U7fTtSRy5saW5lYXJHcmFkaWVudD1SRy5MaW5lYXJHcmFkaWVudD1mdW5jdGlvbihvYmoseDEseTEseDIseTIsY29sb3IxLGNvbG9yMilcbnt2YXIgZ3JhZGllbnQ9b2JqLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoeDEseTEseDIseTIpO3ZhciBudW1Db2xvcnM9YXJndW1lbnRzLmxlbmd0aC01O2Zvcih2YXIgaT01O2k8YXJndW1lbnRzLmxlbmd0aDsrK2kpe3ZhciBjb2xvcj1hcmd1bWVudHNbaV07dmFyIHN0b3A9KGktNSkvKG51bUNvbG9ycy0xKTtncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCxjb2xvcik7fVxucmV0dXJuIGdyYWRpZW50O307UkcucmFkaWFsR3JhZGllbnQ9UkcuUmFkaWFsR3JhZGllbnQ9ZnVuY3Rpb24ob2JqLHgxLHkxLHIxLHgyLHkyLHIyLGNvbG9yMSxjb2xvcjIpXG57dmFyIGdyYWRpZW50PW9iai5jb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgxLHkxLHIxLHgyLHkyLHIyKTt2YXIgbnVtQ29sb3JzPWFyZ3VtZW50cy5sZW5ndGgtNztmb3IodmFyIGk9NztpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXt2YXIgY29sb3I9YXJndW1lbnRzW2ldO3ZhciBzdG9wPShpLTcpLyhudW1Db2xvcnMtMSk7Z3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsY29sb3IpO31cbnJldHVybiBncmFkaWVudDt9O1JHLmFkZEV2ZW50TGlzdGVuZXI9UkcuQWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihpZCxlLGZ1bmMpXG57dmFyIHR5cGU9YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTondW5rbm93bic7UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5ldmVudC5oYW5kbGVycycpLnB1c2goW2lkLGUsZnVuYyx0eXBlXSk7fTtSRy5jbGVhckV2ZW50TGlzdGVuZXJzPVJHLkNsZWFyRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oaWQpXG57aWYoaWQmJmlkPT0nd2luZG93Jyl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsd2luZG93Ll9fcmdyYXBoX21vdXNlZG93bl9ldmVudF9saXN0ZW5lcl9pbnN0YWxsZWRfXyxmYWxzZSk7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLHdpbmRvdy5fX3JncmFwaF9tb3VzZXVwX2V2ZW50X2xpc3RlbmVyX2luc3RhbGxlZF9fLGZhbHNlKTt9ZWxzZXt2YXIgY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsY2FudmFzLl9fcmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXJfaW5zdGFsbGVkX18sZmFsc2UpO2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGNhbnZhcy5fX3JncmFwaF9tb3VzZW1vdmVfZXZlbnRfbGlzdGVuZXJfaW5zdGFsbGVkX18sZmFsc2UpO2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLGNhbnZhcy5fX3JncmFwaF9tb3VzZWRvd25fZXZlbnRfbGlzdGVuZXJfaW5zdGFsbGVkX18sZmFsc2UpO2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsY2FudmFzLl9fcmdyYXBoX2NsaWNrX2V2ZW50X2xpc3RlbmVyX2luc3RhbGxlZF9fLGZhbHNlKTt9fTtSRy5oaWRlUGFsZXR0ZT1SRy5IaWRlUGFsZXR0ZT1mdW5jdGlvbigpXG57dmFyIGRpdj1SRy5SZWdpc3RyeS5nZXQoJ3BhbGV0dGUnKTtpZih0eXBlb2YgZGl2PT0nb2JqZWN0JyYmZGl2KXtkaXYuc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztkaXYuc3R5bGUuZGlzcGxheT0nbm9uZSc7UkcuUmVnaXN0cnkuc2V0KCdwYWxldHRlJyxudWxsKTt9fTtSRy5yYW5kb209ZnVuY3Rpb24obWluLG1heClcbnt2YXIgZHA9YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTowO3ZhciByPW1hLnJhbmRvbSgpO3JldHVybiBOdW1iZXIoKCgobWF4LW1pbikqcikrbWluKS50b0ZpeGVkKGRwKSk7fTtSRy5hcnJheVJhbmQ9UkcuYXJyYXlSYW5kb209UkcucmFuZG9tLmFycmF5PWZ1bmN0aW9uKG51bSxtaW4sbWF4KVxue2Zvcih2YXIgaT0wLGFycj1bXTtpPG51bTtpKz0xKXthcnIucHVzaChSRy5yYW5kb20obWluLG1heCxhcmd1bWVudHNbM10pKTt9XG5yZXR1cm4gYXJyO307Ukcubm9TaGFkb3c9UkcuTm9TaGFkb3c9ZnVuY3Rpb24ob2JqKVxue3ZhciBjbz1vYmouY29udGV4dDtjby5zaGFkb3dDb2xvcj0ncmdiYSgwLDAsMCwwKSc7Y28uc2hhZG93Qmx1cj0wO2NvLnNoYWRvd09mZnNldFg9MDtjby5zaGFkb3dPZmZzZXRZPTA7fTtSRy5zZXRTaGFkb3c9UkcuU2V0U2hhZG93PWZ1bmN0aW9uKG9iaixjb2xvcixvZmZzZXR4LG9mZnNldHksYmx1cilcbnt2YXIgY289b2JqLmNvbnRleHQ7Y28uc2hhZG93Q29sb3I9Y29sb3I7Y28uc2hhZG93T2Zmc2V0WD1vZmZzZXR4O2NvLnNoYWRvd09mZnNldFk9b2Zmc2V0eTtjby5zaGFkb3dCbHVyPWJsdXI7fTtSRy5SZWdpc3RyeS5zZXQ9UkcuUmVnaXN0cnkuU2V0PWZ1bmN0aW9uKG5hbWUsdmFsdWUpXG57bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvZyxmdW5jdGlvbihzdHIpXG57cmV0dXJuJy4nK1N0cmluZyhSZWdFeHAuJDEpLnRvTG93ZXJDYXNlKCk7fSk7aWYobmFtZS5zdWJzdHIoMCw2KSE9PSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxuUkcuUmVnaXN0cnkuc3RvcmVbbmFtZV09dmFsdWU7cmV0dXJuIHZhbHVlO307UkcuUmVnaXN0cnkuZ2V0PVJHLlJlZ2lzdHJ5LkdldD1mdW5jdGlvbihuYW1lKVxue25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csZnVuY3Rpb24oc3RyKVxue3JldHVybicuJytTdHJpbmcoUmVnRXhwLiQxKS50b0xvd2VyQ2FzZSgpO30pO2lmKG5hbWUuc3Vic3RyKDAsNikhPT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbnJldHVybiBSRy5SZWdpc3RyeS5zdG9yZVtuYW1lXTt9O1JHLmRlZ3JlZXMyUmFkaWFucz1mdW5jdGlvbihkZWcpXG57cmV0dXJuIGRlZyooUkcuUEkvMTgwKTt9O1JHLmxvZz1mdW5jdGlvbihuLGJhc2UpXG57cmV0dXJuIG1hLmxvZyhuKS8oYmFzZT9tYS5sb2coYmFzZSk6MSk7fTtSRy5pc0FycmF5PVJHLmlzX2FycmF5PWZ1bmN0aW9uKG9iailcbntpZihvYmomJm9iai5jb25zdHJ1Y3Rvcil7dmFyIHBvcz1vYmouY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKCdBcnJheScpO31lbHNle3JldHVybiBmYWxzZTt9XG5yZXR1cm4gb2JqIT1udWxsJiZ0eXBlb2YgcG9zPT09J251bWJlcicmJnBvcz4wJiZwb3M8MjA7fTtSRy50cmltPWZ1bmN0aW9uKHN0cilcbntyZXR1cm4gUkcubHRyaW0oUkcucnRyaW0oc3RyKSk7fTtSRy5sdHJpbT1mdW5jdGlvbihzdHIpXG57cmV0dXJuIHN0ci5yZXBsYWNlKC9eKFxcc3xcXDApKy8sJycpO307UkcucnRyaW09ZnVuY3Rpb24oc3RyKVxue3JldHVybiBzdHIucmVwbGFjZSgvKFxcc3xcXDApKyQvLCcnKTt9O1JHLmlzTnVsbD1SRy5pc19udWxsPWZ1bmN0aW9uKGFyZylcbntpZihhcmc9PW51bGx8fHR5cGVvZiBhcmc9PT0nb2JqZWN0JyYmIWFyZyl7cmV0dXJuIHRydWU7fVxucmV0dXJuIGZhbHNlO307UkcuYXN5bmM9UkcuQXN5bmM9ZnVuY3Rpb24oZnVuYylcbntyZXR1cm4gc2V0VGltZW91dChmdW5jLGFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MSk7fTtSRy5yZXNldD1SRy5SZXNldD1mdW5jdGlvbihjYSlcbntjYS53aWR0aD1jYS53aWR0aDtSRy5PYmplY3RSZWdpc3RyeS5jbGVhcihjYSk7Y2EuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPWZhbHNlO2lmKFJHLnRleHQyLmRvbU5vZGVDYWNoZSYmUkcudGV4dDIuZG9tTm9kZUNhY2hlLnJlc2V0KXtSRy50ZXh0Mi5kb21Ob2RlQ2FjaGUucmVzZXQoY2EpO31cbmlmKCFSRy50ZXh0Mi5kb21Ob2RlQ2FjaGUpe1JHLnRleHQyLmRvbU5vZGVDYWNoZT1bXTt9XG5pZighUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlKXtSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGU9W107fVxuUkcudGV4dDIuZG9tTm9kZUNhY2hlW2NhLmlkXT1bXTtSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbY2EuaWRdPVtdO307UkcuYXR0PVJHLmF0dHJpYnV0aW9uPWZ1bmN0aW9uKG9iailcbnt2YXIgY2E9b2JqLmNhbnZhcyxjbz1vYmouY29udGV4dCxwcm9wPW9iai5wcm9wZXJ0aWVzO2lmKCFjYXx8IWNvKXtyZXR1cm47fVxudmFyIHdpZHRoPWNhLndpZHRoLGhlaWdodD1jYS5oZWlnaHQsd3JhcHBlcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3ZzJykuX19vYmplY3RfXy5jYW52YXMucGFyZW50Tm9kZSx0ZXh0PXByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLnRleHQnXXx8J0ZyZWUgQ2hhcnRzIHdpdGggUkdyYXBoLm5ldCcseD1wcm9wWydjaGFydC5hdHRyaWJ1dGlvbi54J10seT1wcm9wWydjaGFydC5hdHRyaWJ1dGlvbi55J10sYm9sZD1wcm9wWydjaGFydC5hdHRyaWJ1dGlvbi5ib2xkJ10saXRhbGljPXByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLml0YWxpYyddLGZvbnQ9cHJvcFsnY2hhcnQuYXR0cmlidXRpb24uZm9udCddfHwnc2Fucy1zZXJpZicsc2l6ZT1wcm9wWydjaGFydC5hdHRyaWJ1dGlvbi5zaXplJ118fDgsdW5kZXJsaW5lPXByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLnVuZGVybGluZSddPyd1bmRlcmxpbmUnOidub25lJyxjb2xvcj10eXBlb2YgcHJvcFsnY2hhcnQuYXR0cmlidXRpb24uY29sb3InXT09PSdzdHJpbmcnP3Byb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLmNvbG9yJ106JycsaHJlZj10eXBlb2YgcHJvcFsnY2hhcnQuYXR0cmlidXRpb24uaHJlZiddPT09J3N0cmluZyc/cHJvcFsnY2hhcnQuYXR0cmlidXRpb24uaHJlZiddOidodHRwOi8vd3d3LnJncmFwaC5uZXQvY2FudmFzL2luZGV4Lmh0bWwnO2lmKHdyYXBwZXIuYXR0cmlidXRpb25fbm9kZSl7cmV0dXJuO31cbnZhciBtZWFzdXJlbWVudHM9UkcubWVhc3VyZVRleHQodGV4dCxib2xkLGZvbnQsc2l6ZSk7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQScpO2EuaHJlZj1ocmVmO2EuaW5uZXJIVE1MPXRleHQ7YS50YXJnZXQ9J19ibGFuayc7YS5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Euc3R5bGUubGVmdD10eXBlb2YgeD09PSdudW1iZXInP3g6d3JhcHBlci5vZmZzZXRXaWR0aC1tZWFzdXJlbWVudHNbMF0tNSsncHgnO2Euc3R5bGUudG9wPXR5cGVvZiB5PT09J251bWJlcic/eTp3cmFwcGVyLm9mZnNldEhlaWdodC1tZWFzdXJlbWVudHNbMV0rJ3B4JzthLnN0eWxlLmZvbnRTaXplPXNpemUrJ3B0JzthLnN0eWxlLmZvbnRTdHlsZT10eXBlb2YgaXRhbGljPT09J2Jvb2xlYW4nPyhpdGFsaWM/J2l0YWxpYyc6JycpOidpdGFsaWMnLGEuc3R5bGUuZm9udFdlaWdodD1ib2xkPydib2xkJzonJyxhLnN0eWxlLnRleHREZWNvcmF0aW9uPXVuZGVybGluZTthLnN0eWxlLmZvbnRGYW1pbHk9Zm9udDthLnN0eWxlLmNvbG9yPWNvbG9yO3dyYXBwZXIuYXBwZW5kQ2hpbGQoYSk7d3JhcHBlci5hdHRyaWJ1dGlvbl9ub2RlPWE7fTtSRy5nZXRDYW52YXNUYWc9ZnVuY3Rpb24oaWQpXG57aWQ9dHlwZW9mIGlkPT09J29iamVjdCc/aWQuaWQ6aWQ7dmFyIGNhbnZhcz1kb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO3JldHVybltpZCxjYW52YXNdO307UkcuRWZmZWN0cy51cGRhdGVDYW52YXM9UkcuRWZmZWN0cy5VcGRhdGVDYW52YXM9ZnVuY3Rpb24oZnVuYylcbnt3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbi5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luLm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8KGZ1bmN0aW9uKGZ1bmMpe3NldFRpbWVvdXQoZnVuYywxNi42NjYpO30pO3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuYyk7fTtSRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXI9ZnVuY3Rpb24oZnJhbWVzLGZyYW1lKVxue3JldHVybiBtYS5wb3cobWEuc2luKChmcmFtZS9mcmFtZXMpKlJHLkhBTEZQSSksMyk7fTtSRy5zdHJpbmdzVG9OdW1iZXJzPWZ1bmN0aW9uKHN0cilcbnt2YXIgc2VwPWFyZ3VtZW50c1sxXXx8JywnO2lmKHR5cGVvZiBzdHI9PT0nbnVtYmVyJyl7cmV0dXJuIHN0cjt9XG5pZih0eXBlb2Ygc3RyPT09J3N0cmluZycpe2lmKHN0ci5pbmRleE9mKHNlcCkhPS0xKXtzdHI9c3RyLnNwbGl0KHNlcCk7fWVsc2V7c3RyPXBhcnNlRmxvYXQoc3RyKTt9fVxuaWYodHlwZW9mIHN0cj09PSdvYmplY3QnKXtmb3IodmFyIGk9MCxsZW49c3RyLmxlbmd0aDtpPGxlbjtpKz0xKXtzdHJbaV09cGFyc2VGbG9hdChzdHJbaV0pO319XG5yZXR1cm4gc3RyO307UkcuY2FjaGVkRHJhdz1mdW5jdGlvbihvYmosaWQsZnVuYylcbntpZighUkcuY2FjaGVbaWRdKXtSRy5jYWNoZVtpZF09e307UkcuY2FjaGVbaWRdLm9iamVjdD1vYmo7UkcuY2FjaGVbaWRdLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtSRy5jYWNoZVtpZF0uY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLG9iai5jYW52YXMud2lkdGgpO1JHLmNhY2hlW2lkXS5jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLG9iai5jYW52YXMuaGVpZ2h0KTtSRy5jYWNoZVtpZF0uY2FudmFzLnNldEF0dHJpYnV0ZSgnaWQnLCdiYWNrZ3JvdW5kX2NhY2hlZF9jYW52YXMnK29iai5jYW52YXMuaWQpO1JHLmNhY2hlW2lkXS5jYW52YXMuX19vYmplY3RfXz1vYmo7UkcuY2FjaGVbaWRdLmNvbnRleHQ9UkcuY2FjaGVbaWRdLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1JHLmNhY2hlW2lkXS5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTtmdW5jKG9iaixSRy5jYWNoZVtpZF0uY2FudmFzLFJHLmNhY2hlW2lkXS5jb250ZXh0KTt9XG5vYmouY29udGV4dC5kcmF3SW1hZ2UoUkcuY2FjaGVbaWRdLmNhbnZhcywtMC41LC0wLjUpO307UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZz1mdW5jdGlvbihvYmosY29uZmlnKVxue3ZhciByZWN1cnNlPWZ1bmN0aW9uKG9iaixjb25maWcsbmFtZSxzZXR0aW5ncylcbnt2YXIgaTtmb3Ioa2V5IGluIGNvbmZpZyl7aWYoa2V5Lm1hdGNoKC9eZXhlY1swLTldKiQvKSl7KGNvbmZpZ1trZXldKShvYmosc2V0dGluZ3MpO2NvbnRpbnVlO31cbnZhciBpc09iamVjdD1mYWxzZTt2YXIgaXNBcnJheT1mYWxzZTt2YXIgdmFsdWU9Y29uZmlnW2tleV07d2hpbGUoa2V5Lm1hdGNoKC8oW0EtWl0pLykpe2tleT1rZXkucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZighUkcuaXNOdWxsKHZhbHVlKSYmdmFsdWUuY29uc3RydWN0b3Ipe2lzT2JqZWN0PXZhbHVlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignT2JqZWN0Jyk+MDtpc0FycmF5PXZhbHVlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignQXJyYXknKT4wO31cbmlmKGlzT2JqZWN0JiYhaXNBcnJheSl7cmVjdXJzZShvYmosY29uZmlnW2tleV0sbmFtZSsnLicra2V5LHNldHRpbmdzKTt9ZWxzZSBpZihrZXk9PT0nc2VsZicpe3NldHRpbmdzW25hbWVdPXZhbHVlO31lbHNle3NldHRpbmdzW25hbWUrJy4nK2tleV09dmFsdWU7fX1cbnJldHVybiBzZXR0aW5nczt9O3ZhciBzZXR0aW5ncz1yZWN1cnNlKG9iaixjb25maWcsJ2NoYXJ0Jyx7fSk7Zm9yKGtleSBpbiBzZXR0aW5ncyl7aWYodHlwZW9mIGtleT09PSdzdHJpbmcnKXtvYmouc2V0KGtleSxzZXR0aW5nc1trZXldKTt9fX07UkcucGF0aDI9ZnVuY3Rpb24oY28scClcbnt2YXIgYXJncz1hcmd1bWVudHM7aWYodHlwZW9mIHA9PT0nc3RyaW5nJyl7cD1zcGxpdHN0cmluZyhwKTt9XG5SRy5wYXRoMi5sYXN0PVJHLmFycmF5Q2xvbmUocCk7Zm9yKHZhciBpPTAsbGVuPXAubGVuZ3RoO2k8bGVuO2krPTEpe3N3aXRjaChwW2ldKXtjYXNlJ2InOmNvLmJlZ2luUGF0aCgpO2JyZWFrO2Nhc2UnYyc6Y28uY2xvc2VQYXRoKCk7YnJlYWs7Y2FzZSdtJzpjby5tb3ZlVG8ocGFyc2VGbG9hdChwW2krMV0pLHBhcnNlRmxvYXQocFtpKzJdKSk7aSs9MjticmVhaztjYXNlJ2wnOmNvLmxpbmVUbyhwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pKTtpKz0yO2JyZWFrO2Nhc2Uncyc6aWYocFtpKzFdKWNvLnN0cm9rZVN0eWxlPXBbaSsxXTtjby5zdHJva2UoKTtpKys7YnJlYWs7Y2FzZSdmJzppZihwW2krMV0pe2NvLmZpbGxTdHlsZT1wW2krMV07fWNvLmZpbGwoKTtpKys7YnJlYWs7Y2FzZSdxYyc6Y28ucXVhZHJhdGljQ3VydmVUbyhwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pLHBhcnNlRmxvYXQocFtpKzNdKSxwYXJzZUZsb2F0KHBbaSs0XSkpO2krPTQ7YnJlYWs7Y2FzZSdiYyc6Y28uYmV6aWVyQ3VydmVUbyhwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pLHBhcnNlRmxvYXQocFtpKzNdKSxwYXJzZUZsb2F0KHBbaSs0XSkscGFyc2VGbG9hdChwW2krNV0pLHBhcnNlRmxvYXQocFtpKzZdKSk7aSs9NjticmVhaztjYXNlJ3InOmNvLnJlY3QocGFyc2VGbG9hdChwW2krMV0pLHBhcnNlRmxvYXQocFtpKzJdKSxwYXJzZUZsb2F0KHBbaSszXSkscGFyc2VGbG9hdChwW2krNF0pKTtpKz00O2JyZWFrO2Nhc2UnYSc6Y28uYXJjKHBhcnNlRmxvYXQocFtpKzFdKSxwYXJzZUZsb2F0KHBbaSsyXSkscGFyc2VGbG9hdChwW2krM10pLHBhcnNlRmxvYXQocFtpKzRdKSxwYXJzZUZsb2F0KHBbaSs1XSkscFtpKzZdPT09J3RydWUnfHxwW2krNl09PT10cnVlfHxwW2krNl09PT0xfHxwW2krNl09PT0nMSc/dHJ1ZTpmYWxzZSk7aSs9NjticmVhaztjYXNlJ2F0Jzpjby5hcmNUbyhwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pLHBhcnNlRmxvYXQocFtpKzNdKSxwYXJzZUZsb2F0KHBbaSs0XSkscGFyc2VGbG9hdChwW2krNV0pKTtpKz01O2JyZWFrO2Nhc2UnbHcnOmNvLmxpbmVXaWR0aD1wYXJzZUZsb2F0KHBbaSsxXSk7aSsrO2JyZWFrO2Nhc2UnZSc6Y28uZWxsaXBzZShwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pLHBhcnNlRmxvYXQocFtpKzNdKSxwYXJzZUZsb2F0KHBbaSs0XSkscGFyc2VGbG9hdChwW2krNV0pLHBhcnNlRmxvYXQocFtpKzZdKSxwYXJzZUZsb2F0KHBbaSs3XSkscFtpKzhdPT09J3RydWUnP3RydWU6ZmFsc2UpO2krPTg7YnJlYWs7Y2FzZSdsaic6Y28ubGluZUpvaW49cFtpKzFdO2krKzticmVhaztjYXNlJ2xjJzpjby5saW5lQ2FwPXBbaSsxXTtpKys7YnJlYWs7Y2FzZSdzYyc6Y28uc2hhZG93Q29sb3I9cFtpKzFdO2krKzticmVhaztjYXNlJ3NiJzpjby5zaGFkb3dCbHVyPXBhcnNlRmxvYXQocFtpKzFdKTtpKys7YnJlYWs7Y2FzZSdzeCc6Y28uc2hhZG93T2Zmc2V0WD1wYXJzZUZsb2F0KHBbaSsxXSk7aSsrO2JyZWFrO2Nhc2Unc3knOmNvLnNoYWRvd09mZnNldFk9cGFyc2VGbG9hdChwW2krMV0pO2krKzticmVhaztjYXNlJ2ZzJzpjby5maWxsU3R5bGU9cFtpKzFdO2krKzticmVhaztjYXNlJ3NzJzpjby5zdHJva2VTdHlsZT1wW2krMV07aSsrO2JyZWFrO2Nhc2UnZnInOmNvLmZpbGxSZWN0KHBhcnNlRmxvYXQocFtpKzFdKSxwYXJzZUZsb2F0KHBbaSsyXSkscGFyc2VGbG9hdChwW2krM10pLHBhcnNlRmxvYXQocFtpKzRdKSk7aSs9NDticmVhaztjYXNlJ3NyJzpjby5zdHJva2VSZWN0KHBhcnNlRmxvYXQocFtpKzFdKSxwYXJzZUZsb2F0KHBbaSsyXSkscGFyc2VGbG9hdChwW2krM10pLHBhcnNlRmxvYXQocFtpKzRdKSk7aSs9NDticmVhaztjYXNlJ2NsJzpjby5jbGlwKCk7YnJlYWs7Y2FzZSdzYSc6Y28uc2F2ZSgpO2JyZWFrO2Nhc2UncnMnOmNvLnJlc3RvcmUoKTticmVhaztjYXNlJ3RyJzpjby50cmFuc2xhdGUocGFyc2VGbG9hdChwW2krMV0pLHBhcnNlRmxvYXQocFtpKzJdKSk7aSs9MjticmVhaztjYXNlJ3NsJzpjby5zY2FsZShwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pKTtpKz0yO2JyZWFrO2Nhc2Uncm8nOmNvLnJvdGF0ZShwYXJzZUZsb2F0KHBbaSsxXSkpO2krKzticmVhaztjYXNlJ3RmJzpjby50cmFuc2Zvcm0ocGFyc2VGbG9hdChwW2krMV0pLHBhcnNlRmxvYXQocFtpKzJdKSxwYXJzZUZsb2F0KHBbaSszXSkscGFyc2VGbG9hdChwW2krNF0pLHBhcnNlRmxvYXQocFtpKzVdKSxwYXJzZUZsb2F0KHBbaSs2XSkpO2krPTY7YnJlYWs7Y2FzZSdzdGYnOmNvLnNldFRyYW5zZm9ybShwYXJzZUZsb2F0KHBbaSsxXSkscGFyc2VGbG9hdChwW2krMl0pLHBhcnNlRmxvYXQocFtpKzNdKSxwYXJzZUZsb2F0KHBbaSs0XSkscGFyc2VGbG9hdChwW2krNV0pLHBhcnNlRmxvYXQocFtpKzZdKSk7aSs9NjticmVhaztjYXNlJ2NyJzpjby5jbGVhclJlY3QocGFyc2VGbG9hdChwW2krMV0pLHBhcnNlRmxvYXQocFtpKzJdKSxwYXJzZUZsb2F0KHBbaSszXSkscGFyc2VGbG9hdChwW2krNF0pKTtpKz00O2JyZWFrO2Nhc2UnbGQnOnZhciBwYXJ0cz1wW2krMV07Y28uc2V0TGluZURhc2gocGFydHMpO2krPTE7YnJlYWs7Y2FzZSdsZG8nOmNvLmxpbmVEYXNoT2Zmc2V0PXBbaSsxXTtpKys7YnJlYWs7Y2FzZSdmbyc6Y28uZm9udD1wW2krMV07aSsrO2JyZWFrO2Nhc2UnZnQnOmNvLmZpbGxUZXh0KHBbaSsxXSxwYXJzZUZsb2F0KHBbaSsyXSkscGFyc2VGbG9hdChwW2krM10pKTtpKz0zO2JyZWFrO2Nhc2Unc3QnOmNvLnN0cm9rZVRleHQocFtpKzFdLHBhcnNlRmxvYXQocFtpKzJdKSxwYXJzZUZsb2F0KHBbaSszXSkpO2krPTM7YnJlYWs7Y2FzZSd0YSc6Y28udGV4dEFsaWduPXBbaSsxXTtpKys7YnJlYWs7Y2FzZSd0YmwnOmNvLnRleHRCYXNlbGluZT1wW2krMV07aSsrO2JyZWFrO2Nhc2UnZ2EnOmNvLmdsb2JhbEFscGhhPXBhcnNlRmxvYXQocFtpKzFdKTtpKys7YnJlYWs7Y2FzZSdnY28nOmNvLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1wW2krMV07aSsrO2JyZWFrO2Nhc2UnZnUnOihwW2krMV0pKGNvLmNhbnZhcy5fX29iamVjdF9fKTtpKys7YnJlYWs7Y2FzZScnOmJyZWFrO2RlZmF1bHQ6YWxlcnQoJ1tFUlJPUl0gVW5rbm93biBvcHRpb246ICcrcFtpXSk7fX1cbmZ1bmN0aW9uIHNwbGl0c3RyaW5nKHApXG57dmFyIHJldD1bXSxidWZmZXI9JycsaW5xdW90ZT1mYWxzZSxxdW90ZT0nJyxzdWJzdGl0dXRpb25JbmRleD0yO2Zvcih2YXIgaT0wO2k8cC5sZW5ndGg7aSs9MSl7dmFyIGNocj1wW2ldLGlzV1M9Y2hyLm1hdGNoKC8gLyk7aWYoaXNXUyl7aWYoIWlucXVvdGUpe2lmKGJ1ZmZlclswXT09PSdcIid8fGJ1ZmZlclswXT09PVwiJ1wiKXtidWZmZXI9YnVmZmVyLnN1YnN0cigxLGJ1ZmZlci5sZW5ndGgtMik7fVxuaWYoYnVmZmVyLnRyaW0oKT09PSclJyYmdHlwZW9mIGFyZ3Nbc3Vic3RpdHV0aW9uSW5kZXhdIT09J3VuZGVmaW5lZCcpe2J1ZmZlcj1hcmdzW3N1YnN0aXR1dGlvbkluZGV4KytdO31cbnJldC5wdXNoKGJ1ZmZlcik7YnVmZmVyPScnO31lbHNle2J1ZmZlcis9Y2hyO319ZWxzZXtpZihjaHI9PT1cIidcInx8Y2hyPT09J1wiJyl7aW5xdW90ZT0haW5xdW90ZTt9XG5idWZmZXIrPWNocjt9fVxuaWYoYnVmZmVyLnRyaW0oKT09PSclJyYmYXJnc1tzdWJzdGl0dXRpb25JbmRleF0pe2J1ZmZlcj1hcmdzW3N1YnN0aXR1dGlvbkluZGV4KytdO31cbnJldC5wdXNoKGJ1ZmZlcik7cmV0dXJuIHJldDt9fTtSRy53cmFwPWZ1bmN0aW9uKCl7fTt9KSh3aW5kb3csZG9jdW1lbnQpO3dpbmRvdy4kcD1mdW5jdGlvbih2KVxue1JHcmFwaC5wcihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1szXSk7fTt3aW5kb3cuJGE9ZnVuY3Rpb24odilcbnthbGVydCh2KTt9O3dpbmRvdy4kY2w9ZnVuY3Rpb24odilcbntyZXR1cm4gY29uc29sZS5sb2codik7fTtpZighU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQpe1N0cmluZy5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKClcbnt2YXIgYXJncz1hcmd1bWVudHM7cmV0dXJuIHRoaXMucmVwbGFjZSgveyhcXGQrKX0vZyxmdW5jdGlvbihzdHIsaWR4KVxue3JldHVybiB0eXBlb2YgYXJnc1tpZHgtMV0hPT0ndW5kZWZpbmVkJz9hcmdzW2lkeC0xXTpzdHI7fSk7fTt9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmNvcmUuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///196\n");

/***/ }),
/* 197 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.uid = RGraph.createUID();this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmNzdi5qcz9lYTdjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguQ1NWPWZ1bmN0aW9uKHVybCxmdW5jKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO3RoaXMudXJsPXVybDt0aGlzLnJlYWR5PWZ1bmM7dGhpcy5kYXRhPW51bGw7dGhpcy5udW1yb3dzPW51bGw7dGhpcy5udW1jb2xzPW51bGw7dGhpcy5zZXBlcmF0b3I9YXJndW1lbnRzWzJdfHwnLCc7dGhpcy5lbmRvZmxpbmU9YXJndW1lbnRzWzNdfHwvXFxyP1xcbi87dGhpcy51aWQ9UkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMuc3BsaXRDU1Y9ZnVuY3Rpb24oc3RyLHNwbGl0KVxue3ZhciBhcnI9W107dmFyIGZpZWxkPScnO3ZhciBpbkRvdWJsZVF1b3Rlcz1mYWxzZTt2YXIgaW5TaW5nbGVRdW90ZXM9ZmFsc2U7dmFyIHByZXNlcnZlPSh0eXBlb2Ygc3BsaXQ9PT0nb2JqZWN0JyYmc3BsaXQucHJlc2VydmUpP3RydWU6ZmFsc2U7aWYodHlwZW9mIHNwbGl0PT09J29iamVjdCcpe2lmKHR5cGVvZiBzcGxpdC5jaGFyPT09J3N0cmluZycpe3NwbGl0PXNwbGl0LmNoYXI7fWVsc2V7c3BsaXQ9JywnO319XG5mb3IodmFyIGk9MCxsZW49c3RyLmxlbmd0aDtpPGxlbjtpKz0xKXtjaGFyPXN0ci5jaGFyQXQoaSk7aWYoKGNoYXI9PT0nXCInKSYmIWluRG91YmxlUXVvdGVzKXtpbkRvdWJsZVF1b3Rlcz10cnVlO2NvbnRpbnVlO31lbHNlIGlmKChjaGFyPT09J1wiJykmJmluRG91YmxlUXVvdGVzKXtpbkRvdWJsZVF1b3Rlcz1mYWxzZTtjb250aW51ZTt9XG5pZigoY2hhcj09PVwiJ1wiKSYmIWluU2luZ2xlUXVvdGVzKXtpblNpbmdsZVF1b3Rlcz10cnVlO2NvbnRpbnVlO31lbHNlIGlmKChjaGFyPT09XCInXCIpJiZpblNpbmdsZVF1b3Rlcyl7aW5TaW5nbGVRdW90ZXM9ZmFsc2U7Y29udGludWU7fWVsc2UgaWYoY2hhcj09PXNwbGl0JiYhaW5Eb3VibGVRdW90ZXMmJiFpblNpbmdsZVF1b3Rlcyl7YXJyLnB1c2goZmllbGQpO2ZpZWxkPScnO2NvbnRpbnVlO31lbHNle2ZpZWxkPWZpZWxkK2NoYXI7fX1cbmFyci5wdXNoKGZpZWxkKTtpZighcHJlc2VydmUpe2ZvcihpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47aSs9MSl7YXJyW2ldPWFycltpXS50cmltKCk7fX1cbnJldHVybiBhcnI7fTt0aGlzLmZldGNoPWZ1bmN0aW9uKClcbnt2YXIgc2VwPXRoaXMuc2VwZXJhdG9yLGVvbD10aGlzLmVuZG9mbGluZSxvYmo9dGhpcztpZih0aGlzLnVybC5zdWJzdHJpbmcoMCwzKT09PSdpZDonfHx0aGlzLnVybC5zdWJzdHJpbmcoMCw0KT09PSdzdHI6Jyl7aWYodGhpcy51cmwuc3Vic3RyaW5nKDAsMyk9PT0naWQ6Jyl7dmFyIGRhdGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy51cmwuc3Vic3RyaW5nKDMpKS5pbm5lckhUTUwudHJpbSgpO31lbHNlIGlmKHRoaXMudXJsLnN1YnN0cmluZygwLDQpPT09J3N0cjonKXt2YXIgZGF0YT10aGlzLnVybC5zdWJzdHJpbmcoNCkudHJpbSgpO31cbm9iai5kYXRhPWRhdGEuc3BsaXQoZW9sKTtvYmoubnVtcm93cz1vYmouZGF0YS5sZW5ndGg7Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgcm93PW9iai5zcGxpdENTVihvYmouZGF0YVtpXSx7cHJlc2VydmU6ZmFsc2UsY2hhcjpzZXB9KTtpZighb2JqLm51bWNvbHMpe29iai5udW1jb2xzPXJvdy5sZW5ndGg7fVxuZm9yKHZhciBqPTA7ajxyb3cubGVuZ3RoO2orPTEpe2lmKCgvXlxcLT9bMC05Ll0rJC8pLnRlc3Qocm93W2pdKSl7cm93W2pdPXBhcnNlRmxvYXQocm93W2pdKTt9XG5vYmouZGF0YVtpXT1yb3c7fX1cbm9iai5yZWFkeShvYmopO31lbHNle1JHcmFwaC5BSkFYLmdldFN0cmluZyh0aGlzLnVybCxmdW5jdGlvbihkYXRhKVxue2RhdGE9ZGF0YS5yZXBsYWNlKC8oXFxyP1xcbikrJC8sJycpO29iai5kYXRhPWRhdGEuc3BsaXQoZW9sKTtvYmoubnVtcm93cz1vYmouZGF0YS5sZW5ndGg7Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgcm93PW9iai5zcGxpdENTVihvYmouZGF0YVtpXSx7cHJlc2VydmU6ZmFsc2UsY2hhcjpzZXB9KTtpZighb2JqLm51bWNvbHMpe29iai5udW1jb2xzPXJvdy5sZW5ndGg7fVxuZm9yKHZhciBqPTA7ajxyb3cubGVuZ3RoO2orPTEpe2lmKCgvXlxcLT9bMC05Ll0rJC8pLnRlc3Qocm93W2pdKSl7cm93W2pdPXBhcnNlRmxvYXQocm93W2pdKTt9XG5vYmouZGF0YVtpXT1yb3c7fX1cbm9iai5yZWFkeShvYmopO30pO319O3RoaXMuZ2V0Um93PWZ1bmN0aW9uKGluZGV4KVxue3ZhciByb3c9W107dmFyIHN0YXJ0PWFyZ3VtZW50c1sxXXx8MDtmb3IodmFyIGk9c3RhcnQ7aTx0aGlzLm51bWNvbHM7aSs9MSl7cm93LnB1c2godGhpcy5kYXRhW2luZGV4XVtpXSk7fVxucmV0dXJuIHJvdzt9O3RoaXMuZ2V0Q29sPXRoaXMuZ2V0Q29sdW1uPWZ1bmN0aW9uKGluZGV4KVxue3ZhciBjb2w9W107dmFyIHN0YXJ0PWFyZ3VtZW50c1sxXXx8MDtmb3IodmFyIGk9c3RhcnQ7aTx0aGlzLm51bXJvd3M7aSs9MSl7Y29sLnB1c2godGhpcy5kYXRhW2ldW2luZGV4XSk7fVxucmV0dXJuIGNvbDt9O3RoaXMuZmV0Y2goKTt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5jc3YuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///197\n");

/***/ }),
/* 198 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.text = RG.Text = function (context, font, size, x, y, text) {\n    var args = arguments;if (typeof text != 'string' && typeof text != 'number' || text == 'undefined') {\n      return;\n    }\n    if (typeof text == 'string' && text.match(/\\r\\n/)) {\n      var dimensions = RGraph.MeasureText('M', args[11], font, size);var arr = text.split('\\r\\n');if (args[6] && args[6] == 'center') y = y - dimensions[1] * ((arr.length - 1) / 2);for (var i = 1; i < arr.length; ++i) {\n        RGraph.Text(context, font, size, args[9] == -90 ? x + size * 1.5 : x, y + dimensions[1] * i, arr[i], args[6] ? args[6] : null, args[7], args[8], args[9], args[10], args[11], args[12]);\n      }\n      text = arr[0];\n    }\n    if (document.all && RGraph.ISOLD) {\n      y += 2;\n    }\n    context.font = (args[11] ? 'Bold ' : '') + size + 'pt ' + font;var i;var origX = x;var origY = y;var originalFillStyle = context.fillStyle;var originalLineWidth = context.lineWidth;if (typeof args[6] == 'undefined') args[6] = 'bottom';if (typeof args[7] == 'undefined') args[7] = 'left';if (typeof args[8] == 'undefined') args[8] = null;if (typeof args[9] == 'undefined') args[9] = 0;if (navigator.userAgent.indexOf('Opera') != -1) {\n      context.canvas.__rgraph_valign__ = args[6];context.canvas.__rgraph_halign__ = args[7];\n    }\n    context.save();context.canvas.__rgraph_originalx__ = x;context.canvas.__rgraph_originaly__ = y;context.translate(x, y);x = 0;y = 0;if (args[9]) {\n      context.rotate(args[9] / (180 / RGraph.PI));\n    }\n    if (args[6]) {\n      var vAlign = args[6];if (vAlign == 'center') {\n        context.textBaseline = 'middle';\n      } else if (vAlign == 'top') {\n        context.textBaseline = 'top';\n      }\n    }\n    if (args[7]) {\n      var hAlign = args[7];var width = context.measureText(text).width;if (hAlign) {\n        if (hAlign == 'center') {\n          context.textAlign = 'center';\n        } else if (hAlign == 'right') {\n          context.textAlign = 'right';\n        }\n      }\n    }\n    context.fillStyle = originalFillStyle;context.save();context.fillText(text, 0, 0);context.lineWidth = 1;var width = context.measureText(text).width;var width_offset = hAlign == 'center' ? width / 2 : hAlign == 'right' ? width : 0;var height = size * 1.5;var height_offset = vAlign == 'center' ? height / 2 : vAlign == 'top' ? height : 0;var ieOffset = RGraph.ISOLD ? 2 : 0;if (args[8]) {\n      context.strokeRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);if (args[10]) {\n        context.fillStyle = args[10];context.fillRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);\n      }\n      context.fillStyle = originalFillStyle;context.fillText(text, 0, 0);\n    }\n    context.restore();context.lineWidth = originalLineWidth;context.restore();\n  };RG.getMouseXY = function (e) {\n    var el = RGraph.ISOLD ? event.srcElement : e.target;var x;var y;var paddingLeft = el.style.paddingLeft ? parseInt(el.style.paddingLeft) : 0;var paddingTop = el.style.paddingTop ? parseInt(el.style.paddingTop) : 0;var borderLeft = el.style.borderLeftWidth ? parseInt(el.style.borderLeftWidth) : 0;var borderTop = el.style.borderTopWidth ? parseInt(el.style.borderTopWidth) : 0;if (RGraph.ISIE8) e = event;if (typeof e.offsetX == 'number' && typeof e.offsetY == 'number') {\n      x = e.offsetX;y = e.offsetY;\n    } else {\n      x = 0;y = 0;while (el != document.body && el) {\n        x += el.offsetLeft;y += el.offsetTop;el = el.offsetParent;\n      }\n      x = e.pageX - x;y = e.pageY - y;\n    }\n    return [x, y];\n  };RG.oldBrowserCompat = RG.OldBrowserCompat = function (co) {\n    if (!co) {\n      return;\n    }\n    if (!co.measureText) {\n      co.measureText = function (text) {\n        var textObj = document.createElement('DIV');textObj.innerHTML = text;textObj.style.position = 'absolute';textObj.style.top = '-100px';textObj.style.left = 0;document.body.appendChild(textObj);var width = { width: textObj.offsetWidth };textObj.style.display = 'none';return width;\n      };\n    }\n    if (!co.fillText) {\n      co.fillText = function (text, targetX, targetY) {\n        return false;\n      };\n    }\n    if (!co.canvas.addEventListener) {\n      window.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n      co.canvas.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n    }\n  };RG.each = function (arr, func) {\n    for (var i = 0, len = arr.length; i < len; i += 1) {\n      if (typeof arguments[2] !== 'undefined') {\n        var ret = func.call(arguments[2], i, arr[i]);\n      } else {\n        var ret = func.call(arr, i, arr[i]);\n      }\n      if (ret === false) {\n        return;\n      }\n    }\n  };RG.getHeight = RG.GetHeight = function (obj) {\n    return obj.canvas.height;\n  };RG.getWidth = RG.GetWidth = function (obj) {\n    return obj.canvas.width;\n  };RG.timer = RG.Timer = function (label) {\n    if (typeof RG.TIMER_LAST_CHECKPOINT == 'undefined') {\n      RG.TIMER_LAST_CHECKPOINT = Date.now();\n    }\n    var now = Date.now();console.log(label + ': ' + (now - RG.TIMER_LAST_CHECKPOINT).toString());RG.TIMER_LAST_CHECKPOINT = now;\n  };RG.setConfig = RG.SetConfig = function (obj, config) {\n    for (i in config) {\n      if (typeof i === 'string') {\n        obj.Set(i, config[i]);\n      }\n    }\n    return obj;\n  };\n})(window, document);window.$empty = function (value) {\n  if (!value || value.length <= 0) {\n    return true;\n  }\n  return false;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmRlcHJlY2F0ZWQuanM/NmIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLnRleHQ9UkcuVGV4dD1mdW5jdGlvbihjb250ZXh0LGZvbnQsc2l6ZSx4LHksdGV4dClcbnt2YXIgYXJncz1hcmd1bWVudHM7aWYoKHR5cGVvZih0ZXh0KSE9J3N0cmluZycmJnR5cGVvZih0ZXh0KSE9J251bWJlcicpfHx0ZXh0PT0ndW5kZWZpbmVkJyl7cmV0dXJuO31cbmlmKHR5cGVvZih0ZXh0KT09J3N0cmluZycmJnRleHQubWF0Y2goL1xcclxcbi8pKXt2YXIgZGltZW5zaW9ucz1SR3JhcGguTWVhc3VyZVRleHQoJ00nLGFyZ3NbMTFdLGZvbnQsc2l6ZSk7dmFyIGFycj10ZXh0LnNwbGl0KCdcXHJcXG4nKTtpZihhcmdzWzZdJiZhcmdzWzZdPT0nY2VudGVyJyl5PSh5LShkaW1lbnNpb25zWzFdKigoYXJyLmxlbmd0aC0xKS8yKSkpO2Zvcih2YXIgaT0xO2k8YXJyLmxlbmd0aDsrK2kpe1JHcmFwaC5UZXh0KGNvbnRleHQsZm9udCxzaXplLGFyZ3NbOV09PS05MD8oeCsoc2l6ZSoxLjUpKTp4LHkrKGRpbWVuc2lvbnNbMV0qaSksYXJyW2ldLGFyZ3NbNl0/YXJnc1s2XTpudWxsLGFyZ3NbN10sYXJnc1s4XSxhcmdzWzldLGFyZ3NbMTBdLGFyZ3NbMTFdLGFyZ3NbMTJdKTt9XG50ZXh0PWFyclswXTt9XG5pZihkb2N1bWVudC5hbGwmJlJHcmFwaC5JU09MRCl7eSs9Mjt9XG5jb250ZXh0LmZvbnQ9KGFyZ3NbMTFdPydCb2xkICc6JycpK3NpemUrJ3B0ICcrZm9udDt2YXIgaTt2YXIgb3JpZ1g9eDt2YXIgb3JpZ1k9eTt2YXIgb3JpZ2luYWxGaWxsU3R5bGU9Y29udGV4dC5maWxsU3R5bGU7dmFyIG9yaWdpbmFsTGluZVdpZHRoPWNvbnRleHQubGluZVdpZHRoO2lmKHR5cGVvZihhcmdzWzZdKT09J3VuZGVmaW5lZCcpYXJnc1s2XT0nYm90dG9tJztpZih0eXBlb2YoYXJnc1s3XSk9PSd1bmRlZmluZWQnKWFyZ3NbN109J2xlZnQnO2lmKHR5cGVvZihhcmdzWzhdKT09J3VuZGVmaW5lZCcpYXJnc1s4XT1udWxsO2lmKHR5cGVvZihhcmdzWzldKT09J3VuZGVmaW5lZCcpYXJnc1s5XT0wO2lmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignT3BlcmEnKSE9LTEpe2NvbnRleHQuY2FudmFzLl9fcmdyYXBoX3ZhbGlnbl9fPWFyZ3NbNl07Y29udGV4dC5jYW52YXMuX19yZ3JhcGhfaGFsaWduX189YXJnc1s3XTt9XG5jb250ZXh0LnNhdmUoKTtjb250ZXh0LmNhbnZhcy5fX3JncmFwaF9vcmlnaW5hbHhfXz14O2NvbnRleHQuY2FudmFzLl9fcmdyYXBoX29yaWdpbmFseV9fPXk7Y29udGV4dC50cmFuc2xhdGUoeCx5KTt4PTA7eT0wO2lmKGFyZ3NbOV0pe2NvbnRleHQucm90YXRlKGFyZ3NbOV0vKDE4MC9SR3JhcGguUEkpKTt9XG5pZihhcmdzWzZdKXt2YXIgdkFsaWduPWFyZ3NbNl07aWYodkFsaWduPT0nY2VudGVyJyl7Y29udGV4dC50ZXh0QmFzZWxpbmU9J21pZGRsZSc7fWVsc2UgaWYodkFsaWduPT0ndG9wJyl7Y29udGV4dC50ZXh0QmFzZWxpbmU9J3RvcCc7fX1cbmlmKGFyZ3NbN10pe3ZhciBoQWxpZ249YXJnc1s3XTt2YXIgd2lkdGg9Y29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtpZihoQWxpZ24pe2lmKGhBbGlnbj09J2NlbnRlcicpe2NvbnRleHQudGV4dEFsaWduPSdjZW50ZXInO31lbHNlIGlmKGhBbGlnbj09J3JpZ2h0Jyl7Y29udGV4dC50ZXh0QWxpZ249J3JpZ2h0Jzt9fX1cbmNvbnRleHQuZmlsbFN0eWxlPW9yaWdpbmFsRmlsbFN0eWxlO2NvbnRleHQuc2F2ZSgpO2NvbnRleHQuZmlsbFRleHQodGV4dCwwLDApO2NvbnRleHQubGluZVdpZHRoPTE7dmFyIHdpZHRoPWNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7dmFyIHdpZHRoX29mZnNldD0oaEFsaWduPT0nY2VudGVyJz8od2lkdGgvMik6KGhBbGlnbj09J3JpZ2h0Jz93aWR0aDowKSk7dmFyIGhlaWdodD1zaXplKjEuNTt2YXIgaGVpZ2h0X29mZnNldD0odkFsaWduPT0nY2VudGVyJz8oaGVpZ2h0LzIpOih2QWxpZ249PSd0b3AnP2hlaWdodDowKSk7dmFyIGllT2Zmc2V0PVJHcmFwaC5JU09MRD8yOjA7aWYoYXJnc1s4XSl7Y29udGV4dC5zdHJva2VSZWN0KC0zLXdpZHRoX29mZnNldCwwLTMtaGVpZ2h0LWllT2Zmc2V0K2hlaWdodF9vZmZzZXQsd2lkdGgrNixoZWlnaHQrNik7aWYoYXJnc1sxMF0pe2NvbnRleHQuZmlsbFN0eWxlPWFyZ3NbMTBdO2NvbnRleHQuZmlsbFJlY3QoLTMtd2lkdGhfb2Zmc2V0LDAtMy1oZWlnaHQtaWVPZmZzZXQraGVpZ2h0X29mZnNldCx3aWR0aCs2LGhlaWdodCs2KTt9XG5jb250ZXh0LmZpbGxTdHlsZT1vcmlnaW5hbEZpbGxTdHlsZTtjb250ZXh0LmZpbGxUZXh0KHRleHQsMCwwKTt9XG5jb250ZXh0LnJlc3RvcmUoKTtjb250ZXh0LmxpbmVXaWR0aD1vcmlnaW5hbExpbmVXaWR0aDtjb250ZXh0LnJlc3RvcmUoKTt9O1JHLmdldE1vdXNlWFk9ZnVuY3Rpb24oZSlcbnt2YXIgZWw9KFJHcmFwaC5JU09MRD9ldmVudC5zcmNFbGVtZW50OmUudGFyZ2V0KTt2YXIgeDt2YXIgeTt2YXIgcGFkZGluZ0xlZnQ9ZWwuc3R5bGUucGFkZGluZ0xlZnQ/cGFyc2VJbnQoZWwuc3R5bGUucGFkZGluZ0xlZnQpOjA7dmFyIHBhZGRpbmdUb3A9ZWwuc3R5bGUucGFkZGluZ1RvcD9wYXJzZUludChlbC5zdHlsZS5wYWRkaW5nVG9wKTowO3ZhciBib3JkZXJMZWZ0PWVsLnN0eWxlLmJvcmRlckxlZnRXaWR0aD9wYXJzZUludChlbC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpOjA7dmFyIGJvcmRlclRvcD1lbC5zdHlsZS5ib3JkZXJUb3BXaWR0aD9wYXJzZUludChlbC5zdHlsZS5ib3JkZXJUb3BXaWR0aCk6MDtpZihSR3JhcGguSVNJRTgpZT1ldmVudDtpZih0eXBlb2YoZS5vZmZzZXRYKT09J251bWJlcicmJnR5cGVvZihlLm9mZnNldFkpPT0nbnVtYmVyJyl7eD1lLm9mZnNldFg7eT1lLm9mZnNldFk7fWVsc2V7eD0wO3k9MDt3aGlsZShlbCE9ZG9jdW1lbnQuYm9keSYmZWwpe3grPWVsLm9mZnNldExlZnQ7eSs9ZWwub2Zmc2V0VG9wO2VsPWVsLm9mZnNldFBhcmVudDt9XG54PWUucGFnZVgteDt5PWUucGFnZVkteTt9XG5yZXR1cm5beCx5XTt9O1JHLm9sZEJyb3dzZXJDb21wYXQ9UkcuT2xkQnJvd3NlckNvbXBhdD1mdW5jdGlvbihjbylcbntpZighY28pe3JldHVybjt9XG5pZighY28ubWVhc3VyZVRleHQpe2NvLm1lYXN1cmVUZXh0PWZ1bmN0aW9uKHRleHQpXG57dmFyIHRleHRPYmo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7dGV4dE9iai5pbm5lckhUTUw9dGV4dDt0ZXh0T2JqLnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7dGV4dE9iai5zdHlsZS50b3A9Jy0xMDBweCc7dGV4dE9iai5zdHlsZS5sZWZ0PTA7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0T2JqKTt2YXIgd2lkdGg9e3dpZHRoOnRleHRPYmoub2Zmc2V0V2lkdGh9O3RleHRPYmouc3R5bGUuZGlzcGxheT0nbm9uZSc7cmV0dXJuIHdpZHRoO319XG5pZighY28uZmlsbFRleHQpe2NvLmZpbGxUZXh0PWZ1bmN0aW9uKHRleHQsdGFyZ2V0WCx0YXJnZXRZKVxue3JldHVybiBmYWxzZTt9fVxuaWYoIWNvLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihldixmdW5jLGJ1YmJsZSlcbntyZXR1cm4gdGhpcy5hdHRhY2hFdmVudCgnb24nK2V2LGZ1bmMpO31cbmNvLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGV2LGZ1bmMsYnViYmxlKVxue3JldHVybiB0aGlzLmF0dGFjaEV2ZW50KCdvbicrZXYsZnVuYyk7fX19O1JHLmVhY2g9ZnVuY3Rpb24oYXJyLGZ1bmMpXG57Zm9yKHZhciBpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47aSs9MSl7aWYodHlwZW9mIGFyZ3VtZW50c1syXSE9PSd1bmRlZmluZWQnKXt2YXIgcmV0PWZ1bmMuY2FsbChhcmd1bWVudHNbMl0saSxhcnJbaV0pO31lbHNle3ZhciByZXQ9ZnVuYy5jYWxsKGFycixpLGFycltpXSk7fVxuaWYocmV0PT09ZmFsc2Upe3JldHVybjt9fX07UkcuZ2V0SGVpZ2h0PVJHLkdldEhlaWdodD1mdW5jdGlvbihvYmopXG57cmV0dXJuIG9iai5jYW52YXMuaGVpZ2h0O307UkcuZ2V0V2lkdGg9UkcuR2V0V2lkdGg9ZnVuY3Rpb24ob2JqKVxue3JldHVybiBvYmouY2FudmFzLndpZHRoO307UkcudGltZXI9UkcuVGltZXI9ZnVuY3Rpb24obGFiZWwpXG57aWYodHlwZW9mIFJHLlRJTUVSX0xBU1RfQ0hFQ0tQT0lOVD09J3VuZGVmaW5lZCcpe1JHLlRJTUVSX0xBU1RfQ0hFQ0tQT0lOVD1EYXRlLm5vdygpO31cbnZhciBub3c9RGF0ZS5ub3coKTtjb25zb2xlLmxvZyhsYWJlbCsnOiAnKyhub3ctUkcuVElNRVJfTEFTVF9DSEVDS1BPSU5UKS50b1N0cmluZygpKTtSRy5USU1FUl9MQVNUX0NIRUNLUE9JTlQ9bm93O307Ukcuc2V0Q29uZmlnPVJHLlNldENvbmZpZz1mdW5jdGlvbihvYmosY29uZmlnKVxue2ZvcihpIGluIGNvbmZpZyl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7b2JqLlNldChpLGNvbmZpZ1tpXSk7fX1cbnJldHVybiBvYmo7fTt9KSh3aW5kb3csZG9jdW1lbnQpO3dpbmRvdy4kZW1wdHk9ZnVuY3Rpb24odmFsdWUpXG57aWYoIXZhbHVlfHx2YWx1ZS5sZW5ndGg8PTApe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5kZXByZWNhdGVkLmpzIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///198\n");

/***/ }),
/* 199 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.installWindowMousedownListener = RG.InstallWindowMousedownListener = function (obj) {\n    if (!RG.window_mousedown_event_listener) {\n      RG.window_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {\n          RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);RG.redraw();RG.hideTooltip();\n        }\n      };win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);\n    }\n  };RG.installWindowMouseupListener = RG.InstallWindowMouseupListener = function (obj) {\n    if (!RG.window_mouseup_event_listener) {\n      RG.window_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.annotating_window_onmouseup) {\n          RG.annotating_window_onmouseup(e);return;\n        }\n        if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {\n          var obj = RG.Registry.Get('chart.adjusting');if (obj && obj.type === 'line') {\n            obj.data_arr = RG.arrayLinearize(obj.data);\n          }\n          RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');\n        }\n        RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);var tags = document.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n          if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n            if (!tags[i].__object__.get('chart.annotatable')) {\n              if (!tags[i].__rgraph_trace_cover__ && !noredraw) {\n                RG.clear(tags[i]);\n              } else {\n                var noredraw = true;\n              }\n            }\n          }\n        }\n        if (!noredraw) {\n          RG.redraw();\n        }\n      };win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMouseupListener = RG.InstallCanvasMouseupListener = function (obj) {\n    if (!obj.canvas.rgraph_mouseup_event_listener) {\n      obj.canvas.rgraph_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);if (objects) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i],\n                id = objects[i].id;var link = obj.Get('link');if (obj.type == 'drawing.text' && typeof link === 'string') {\n              var link_target = obj.get('link.target');var link_options = obj.get('link.options');window.open(link, link_target ? link_target : null, link_options);\n            }\n            if (!RG.isNull(obj) && RG.tooltip) {\n              var shape = obj.getShape(e);if (shape && shape['tooltip']) {\n                var text = shape['tooltip'];if (text) {\n                  var type = shape['object'].type;RG.clear(obj.canvas);RG.redraw();RG.Registry.set('chart.tooltip.shape', shape);RG.tooltip(obj, text, 0, 0, shape['index'], e);obj.highlight(shape);if (RG.Registry.get('chart.tooltip')) {\n                    RG.Registry.get('chart.tooltip').__shape__ = shape;RG.evaluateCursor(e);\n                  }\n                  e.cancelBubble = true;e.stopPropagation();return false;\n                }\n              }\n            }\n            if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {\n              if (obj && obj.type === 'line') {\n                obj.data_arr = RG.arrayLinearize(obj.data);\n              }\n              RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');\n            }\n            RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n        }\n      };obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMousemoveListener = RG.InstallCanvasMousemoveListener = function (obj) {\n    if (!obj.canvas.rgraph_mousemove_event_listener) {\n      obj.canvas.rgraph_mousemove_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.OR.getObjectsByXY(e);var uids = [];if (objects && objects.length > 0) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i];var id = obj.id;uids[obj.uid] = true;if (!obj.getShape) {\n              continue;\n            }\n            var shape = obj.getShape(e);if (!shape && typeof obj.__mouseover_shape_index__ === 'number' || shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__) {\n              RG.fireCustomEvent(obj, 'onmouseout');\n            }\n            if (obj.coords && obj.coords.key && obj.coords.key.length) {\n              var mouseXY = RG.getMouseXY(e);for (var i = 0, overkey = false; i < obj.coords.key.length; ++i) {\n                if (mouseXY[0] >= obj.coords.key[i][0] && mouseXY[0] <= obj.coords.key[i][0] + obj.coords.key[i][2] && mouseXY[1] >= obj.coords.key[i][1] && mouseXY[1] <= obj.coords.key[i][1] + obj.coords.key[i][3]) {\n                  RG.Registry.set('key-element', obj.coords.key[i]);overkey = true;\n                }\n                if (!overkey) {\n                  RG.Registry.set('key-element', null);\n                }\n              }\n            }\n            var func = obj.get('chart.events.mousemove');if (!func && typeof obj.onmousemove == 'function') {\n              var func = obj.onmousemove;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmousemove == 'function') {\n                var func2 = obj['$' + index].onmousemove;\n              }\n            }\n            if (shape && (typeof func == 'function' || typeof func2 == 'function' || typeof obj.Get('link') === 'string')) {\n              if (obj.Get('chart.events.mousemove.revertto') == null) {\n                obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);\n              }\n              if (typeof func == 'function') RGraph.custom_events_mousemove_pointer = func(e, shape);if (typeof func2 == 'function') RGraph.custom_events_mousemove_pointer = RGraph.custom_events_mousemove_pointer || func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                for (i in RG.events[obj.uid]) {\n                  if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmousemove' && typeof RG.events[obj.uid][i][2] === 'function') {\n                    RG.events[obj.uid][i][2](obj);\n                  }\n                }\n              }\n            } else if (typeof obj.Get('chart.events.mousemove.revertto') == 'string') {\n              RG.cursor.push('default');obj.Set('chart.events.mousemove.revertto', null);\n            }\n            var func = obj.properties['chart.events.mouseover'];if (!func && typeof obj.onmouseover === 'function') {\n              func = obj.onmouseover;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmouseover == 'function') {\n                var func2 = obj['$' + index].onmouseover;\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            if (typeof RG.__mouseover_objects__ === 'undefined') {\n              RG.__mouseover_objects__ = [];\n            }\n            if (shape) {\n              if (obj.__mouseover_shape_index__ === shape.index === false) {\n                obj.__mouseover_shape_index__ = shape.index;RG.__mouseover_objects__.push(obj);if (func) func(e, shape);if (func2) func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                  for (i in RG.events[obj.uid]) {\n                    if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmouseover' && typeof RG.events[obj.uid][i][2] === 'function') {\n                      RG.events[obj.uid][i][2](obj);\n                    }\n                  }\n                }\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            var current_tooltip = RG.Registry.get('chart.tooltip');var tooltips = obj.get('chart.tooltips');var tooltips_event = obj.Get('chart.tooltips.event');if (shape && (tooltips && tooltips[shape['index']] || shape['tooltip']) && tooltips_event.indexOf('mousemove') !== -1 && (RG.isNull(current_tooltip) || obj.uid != current_tooltip.__object__.uid || current_tooltip.__index__ != shape['index'] || typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])) {\n              RG.clear(obj.canvas);RG.hideTooltip();RG.redraw();obj.canvas.rgraph_mouseup_event_listener(e);return;\n            }\n            if (obj && obj.get('chart.adjustable')) {\n              obj.Adjusting_mousemove(e);\n            }\n            if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; ++i) {\n            if (!uids[objects[i].uid]) {\n              objects[i].__mouseover_shape_index__ = null;\n            }\n          }\n        } else {\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; i++) {\n            if (typeof objects[i].__mouseover_shape_index__ === 'number') {\n              RG.fireCustomEvent(objects[i], 'onmouseout');\n            }\n            objects[i].__mouseover_shape_index__ = null;\n          }\n          RG.__mouseover_objects__ = [];\n        }\n        if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {\n          RG.drawCrosshairs(e, e.target.__object__);\n        }\n        if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {\n          RG.annotating_canvas_onmousemove(e);\n        }\n        RG.evaluateCursor(e);\n      };obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);\n    }\n  };RG.installCanvasMousedownListener = RG.InstallCanvasMousedownListener = function (obj) {\n    if (!obj.canvas.rgraph_mousedown_event_listener) {\n      obj.canvas.rgraph_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {\n          RG.annotating_canvas_onmousedown(e);return;\n        }\n        var obj = RG.ObjectRegistry.getObjectByXY(e);if (obj) {\n          var id = obj.id;if (obj && obj.isRGraph && obj.get('chart.adjustable')) {\n            var obj = RG.OR.getObjectByXY(e);if (obj && obj.isRGraph) {\n              switch (obj.type) {case 'bar':\n                  var shape = obj.getShapeByX(e);break;case 'gantt':\n                  var shape = obj.getShape(e);var data = typeof shape.subindex === 'number' ? obj.data[shape.index][shape.subindex] : obj.data[shape.index];if (shape) {\n                    var mouseXY = RG.getMouseXY(e);RG.Registry.set('chart.adjusting.gantt', { index: shape.index, subindex: shape.subindex, object: obj, mousex: mouseXY[0], mousey: mouseXY[1], event: data, event_start: data[0], event_duration: data[1], mode: mouseXY[0] > shape['x'] + shape['width'] - 5 ? 'resize' : 'move', shape: shape });\n                  }\n                  break;case 'line':\n                  var shape = obj.getShape(e);break;case 'hbar':\n                  var shape = obj.getShapeByY(e);break;default:\n                  var shape = null;}\n              if (RG.isNull(obj.properties['chart.adjustable.only']) || typeof obj.properties['chart.adjustable.only'] === 'undefined' || RG.isArray(obj.properties['chart.adjustable.only']) && obj.isAdjustable && obj.isAdjustable(shape)) {\n                RG.Registry.set('chart.adjusting.shape', shape);RG.fireCustomEvent(obj, 'onadjustbegin');RG.Registry.set('chart.adjusting', obj);RG.clear(obj.canvas);RG.redraw();obj.canvas.rgraph_mousemove_event_listener(e);\n              }\n            }\n          }\n          RG.clear(obj.canvas);RG.redraw();\n        }\n      };obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);\n    }\n  };RG.installCanvasClickListener = RG.InstallCanvasClickListener = function (obj) {\n    if (!obj.canvas.rgraph_click_event_listener) {\n      obj.canvas.rgraph_click_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);for (var i = 0, len = objects.length; i < len; i += 1) {\n          var obj = objects[i];var id = obj.id;var shape = obj.getShape(e);var func = obj.get('chart.events.click');if (!func && typeof obj.onclick == 'function') {\n            func = obj.onclick;\n          }\n          if (shape && typeof func == 'function') {\n            func(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n              for (i in RG.events[obj.uid]) {\n                if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onclick' && typeof RG.events[obj.uid][i][2] === 'function') {\n                  RG.events[obj.uid][i][2](obj);\n                }\n              }\n            }\n            return;\n          }\n          var key = RG.Registry.get('key-element');if (key) {\n            RG.fireCustomEvent(obj, 'onkeyclick');\n          }\n          if (shape) {\n            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (typeof index == 'number' && obj['$' + index]) {\n              var func = obj['$' + index].onclick;if (typeof func == 'function') {\n                func(e, shape);return;\n              }\n            }\n          }\n          if (shape || obj.overChartArea && obj.overChartArea(e)) {\n            break;\n          }\n        }\n      };obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);\n    }\n  };RG.evaluateCursor = RG.EvaluateCursor = function (e) {\n    var obj = null;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var canvas = e.target;var objects = RG.OR.getObjectsByCanvasID(canvas.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i].getShape && objects[i].getShape(e) || objects[i].overChartArea && objects[i].overChartArea(e)) {\n        var obj = objects[i];var id = obj.id;\n      }\n    }\n    if (!RG.isNull(obj)) {\n      if (obj.getShape && obj.getShape(e)) {\n        var shape = obj.getShape(e);if (obj.get('chart.tooltips')) {\n          var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {\n            text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);\n          }\n          if (text) {\n            var pointer = true;\n          }\n        }\n      }\n      if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {\n        for (var j = 0; j < obj.coords.key.length; ++j) {\n          if (mouseX > obj.coords.key[j][0] && mouseX < obj.coords.key[j][0] + obj.coords.key[j][2] && mouseY > obj.coords.key[j][1] && mouseY < obj.coords.key[j][1] + obj.coords.key[j][3]) {\n            var pointer = true;\n          }\n        }\n      }\n    }\n    if (RGraph.custom_events_mousemove_pointer) {\n      var pointer = true;RGraph.custom_events_mousemove_pointer = false;\n    }\n    var objects = RG.OR.objects.byCanvasID;for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i] && objects[i][1].Get('chart.resizable')) {\n        var resizable = true;\n      }\n    }\n    if (resizable && mouseX > e.target.width - 32 && mouseY > e.target.height - 16) {\n      pointer = true;\n    }\n    if (pointer) {\n      e.target.style.cursor = 'pointer';\n    } else if (e.target.style.cursor == 'pointer') {\n      e.target.style.cursor = 'default';\n    } else {\n      e.target.style.cursor = null;\n    }\n    if (resizable && mouseX >= e.target.width - 15 && mouseY >= e.target.height - 15) {\n      e.target.style.cursor = 'move';\n    } else if (e.target.style.cursor === 'move') {\n      e.target.style.cursor = 'default';\n    }\n    if (typeof mouse_over_key == 'boolean' && mouse_over_key) {\n      e.target.style.cursor = 'pointer';\n    }\n    if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {\n      if (obj.getShape) {\n        var shape = obj.getShape(e);if (shape && obj.isAdjustable(shape)) {\n          e.target.style.cursor = 'ns-resize';\n        }\n      } else {\n        e.target.style.cursor = 'default';\n      }\n    }\n    if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {\n      e.target.style.cursor = 'crosshair';\n    }\n    if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {\n      e.target.style.cursor = 'pointer';\n    }\n  };RG.parseTooltipText = function (tooltips, idx) {\n    if (!tooltips) {\n      return null;\n    }\n    if (typeof tooltips == 'function') {\n      var text = tooltips(idx);\n    } else if (typeof tooltips == 'string') {\n      var text = tooltips;\n    } else if ((typeof tooltips === 'undefined' ? 'undefined' : _typeof(tooltips)) == 'object' && typeof tooltips[idx] == 'function') {\n      var text = tooltips[idx](idx);\n    } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {\n      var text = tooltips[idx];\n    } else {\n      var text = '';\n    }\n    if (text == 'undefined') {\n      text = '';\n    } else if (text == 'null') {\n      text = '';\n    }\n    return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;\n  };RG.drawCrosshairs = RG.DrawCrosshairs = function (e, obj) {\n    var e = RG.fixEventObject(e),\n        width = obj.canvas.width,\n        height = obj.canvas.height,\n        mouseXY = RG.getMouseXY(e),\n        x = mouseXY[0],\n        y = mouseXY[1],\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        Mathround = Math.round,\n        prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;\n    RG.redrawCanvas(ca);if (x >= gutterLeft && y >= gutterTop && x <= width - gutterRight && y <= height - gutterBottom) {\n      var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;co.lineWidth = linewidth ? linewidth : 1;co.beginPath();co.strokeStyle = prop['chart.crosshairs.color'];if (prop['chart.crosshairs.snap']) {\n        var point = null;var dist = null;var len = null;if (obj.type == 'line') {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);if (typeof dist != 'number' || length < dist) {\n              var point = i;var dist = length;\n            }\n          }\n          x = obj.coords[point][0];y = obj.coords[point][1];for (var dataset = 0; dataset < obj.coords2.length; ++dataset) {\n            for (var point = 0; point < obj.coords2[dataset].length; ++point) {\n              if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {\n                ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;\n              }\n            }\n          }\n        } else {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            for (var j = 0; j < obj.coords[i].length; ++j) {\n              var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);if (typeof dist != 'number' || len < dist) {\n                var dataset = i;var point = j;var dist = len;\n              }\n            }\n          }\n          ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;x = obj.coords[dataset][point][0];y = obj.coords[dataset][point][1];\n        }\n      }\n      if (prop['chart.crosshairs.vline']) {\n        co.moveTo(Mathround(x), Mathround(gutterTop));co.lineTo(Mathround(x), Mathround(height - gutterBottom));\n      }\n      if (prop['chart.crosshairs.hline']) {\n        co.moveTo(Mathround(gutterLeft), Mathround(y));co.lineTo(Mathround(width - gutterRight), Mathround(y));\n      }\n      co.stroke();if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {\n        var xCoord = (x - gutterLeft) / (width - gutterLeft - gutterRight) * (prop['chart.xmax'] - prop['chart.xmin']) + prop['chart.xmin'];xCoord = xCoord.toFixed(prop['chart.scale.decimals']);var yCoord = obj.max - (y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom) * obj.max;if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {\n          yCoord = (yCoord - obj.max / 2) * 2;\n        }\n        yCoord = yCoord.toFixed(prop['chart.scale.decimals']);var div = RG.Registry.get('chart.coordinates.coords.div');var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(ca);if (!div) {\n          var div = document.createElement('DIV');div.__object__ = obj;div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.fontFamily = 'Arial, Verdana, sans-serif';div.style.fontSize = '10pt';\n          div.style.padding = '2px';div.style.opacity = 1;div.style.WebkitBorderRadius = '3px';div.style.borderRadius = '3px';div.style.MozBorderRadius = '3px';document.body.appendChild(div);RG.Registry.set('chart.coordinates.coords.div', div);\n        }\n        div.style.opacity = 1;div.style.display = 'inline';if (!prop['chart.crosshairs.coords.fixed']) {\n          div.style.left = ma.max(2, e.pageX - div.offsetWidth - 3) + 'px';div.style.top = ma.max(2, e.pageY - div.offsetHeight - 3) + 'px';\n        } else {\n          div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';div.style.top = canvasXY[1] + gutterTop + 3 + 'px';\n        }\n        div.innerHTML = '<span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);ca.__crosshairs_labels__ = div;ca.__crosshairs_x__ = xCoord;ca.__crosshairs_y__ = yCoord;\n      } else if (prop['chart.crosshairs.coords']) {\n        alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');\n      }\n      RG.fireCustomEvent(obj, 'oncrosshairs');\n    } else {\n      RG.hideCrosshairCoords();\n    }\n  };RG.allowSegmentHighlight = function (opt) {\n    var obj = opt.object,\n        count = opt.count,\n        fill = opt.fill,\n        stroke = opt.stroke;\n    if (!RG.segmentHighlightFunction) {\n      RG.segmentHighlightFunction = function (e) {\n        var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (angle > RG.TWOPI) {\n          angle -= RG.TWOPI;\n        }\n        RG.redraw();var start = 0;var end = 0;var a = ma.PI * 2 / count;var r = obj.radius;(function () {\n          for (i = 0; i < count; i += 1) {\n            if (angle < a * (i + 1)) {\n              start = i * a;end = (i + 1) * a;return;\n            }\n          }\n        })();start -= RG.HALFPI;end -= RG.HALFPI;RG.path2(obj.context, 'b m % % a % % % % % false c s % f %', obj.centerx, obj.centery, obj.centerx, obj.centery, r, start, end, stroke, fill);\n      };obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmR5bmFtaWMuanM/MTZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLmluc3RhbGxXaW5kb3dNb3VzZWRvd25MaXN0ZW5lcj1SRy5JbnN0YWxsV2luZG93TW91c2Vkb3duTGlzdGVuZXI9ZnVuY3Rpb24ob2JqKVxue2lmKCFSRy53aW5kb3dfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyKXtSRy53aW5kb3dfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyPWZ1bmN0aW9uKGUpXG57aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+PTApd2luLmV2ZW50PWU7ZT1SRy5maXhFdmVudE9iamVjdChlKTtpZihSRy5IaWRlVG9vbHRpcCYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwJykpe1JHLmNsZWFyKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcCcpLl9fY2FudmFzX18pO1JHLnJlZHJhdygpO1JHLmhpZGVUb29sdGlwKCk7fX07d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsUkcud2luZG93X21vdXNlZG93bl9ldmVudF9saXN0ZW5lcixmYWxzZSk7fX07UkcuaW5zdGFsbFdpbmRvd01vdXNldXBMaXN0ZW5lcj1SRy5JbnN0YWxsV2luZG93TW91c2V1cExpc3RlbmVyPWZ1bmN0aW9uKG9iailcbntpZighUkcud2luZG93X21vdXNldXBfZXZlbnRfbGlzdGVuZXIpe1JHLndpbmRvd19tb3VzZXVwX2V2ZW50X2xpc3RlbmVyPWZ1bmN0aW9uKGUpXG57aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+PTApd2luLmV2ZW50PWU7ZT1SRy5maXhFdmVudE9iamVjdChlKTtpZihSRy5hbm5vdGF0aW5nX3dpbmRvd19vbm1vdXNldXApe1JHLmFubm90YXRpbmdfd2luZG93X29ubW91c2V1cChlKTtyZXR1cm47fVxuaWYoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKXx8UkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKSl7dmFyIG9iaj1SRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpO2lmKG9iaiYmb2JqLnR5cGU9PT0nbGluZScpe29iai5kYXRhX2Fycj1SRy5hcnJheUxpbmVhcml6ZShvYmouZGF0YSk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJyksJ29uYWRqdXN0ZW5kJyk7fVxuUkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcnLG51bGwpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyxudWxsKTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcsbnVsbCk7dmFyIHRhZ3M9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpO2Zvcih2YXIgaT0wO2k8dGFncy5sZW5ndGg7KytpKXtpZih0YWdzW2ldLl9fb2JqZWN0X18mJnRhZ3NbaV0uX19vYmplY3RfXy5pc1JHcmFwaCl7aWYoIXRhZ3NbaV0uX19vYmplY3RfXy5nZXQoJ2NoYXJ0LmFubm90YXRhYmxlJykpe2lmKCF0YWdzW2ldLl9fcmdyYXBoX3RyYWNlX2NvdmVyX18mJiFub3JlZHJhdyl7UkcuY2xlYXIodGFnc1tpXSk7fWVsc2V7dmFyIG5vcmVkcmF3PXRydWU7fX19fVxuaWYoIW5vcmVkcmF3KXtSRy5yZWRyYXcoKTt9fTt3aW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsUkcud2luZG93X21vdXNldXBfZXZlbnRfbGlzdGVuZXIsZmFsc2UpO319O1JHLmluc3RhbGxDYW52YXNNb3VzZXVwTGlzdGVuZXI9UkcuSW5zdGFsbENhbnZhc01vdXNldXBMaXN0ZW5lcj1mdW5jdGlvbihvYmopXG57aWYoIW9iai5jYW52YXMucmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXIpe29iai5jYW52YXMucmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXI9ZnVuY3Rpb24oZSlcbntpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKT49MCl3aW5kb3cuZXZlbnQ9ZTtlPVJHLmZpeEV2ZW50T2JqZWN0KGUpO3ZhciBvYmplY3RzPVJHLk9iamVjdFJlZ2lzdHJ5LmdldE9iamVjdHNCeVhZKGUpO2lmKG9iamVjdHMpe2Zvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgb2JqPW9iamVjdHNbaV0saWQ9b2JqZWN0c1tpXS5pZDt2YXIgbGluaz1vYmouR2V0KCdsaW5rJyk7aWYob2JqLnR5cGU9PSdkcmF3aW5nLnRleHQnJiZ0eXBlb2YgbGluaz09PSdzdHJpbmcnKXt2YXIgbGlua190YXJnZXQ9b2JqLmdldCgnbGluay50YXJnZXQnKTt2YXIgbGlua19vcHRpb25zPW9iai5nZXQoJ2xpbmsub3B0aW9ucycpO3dpbmRvdy5vcGVuKGxpbmssbGlua190YXJnZXQ/bGlua190YXJnZXQ6bnVsbCxsaW5rX29wdGlvbnMpO31cbmlmKCFSRy5pc051bGwob2JqKSYmUkcudG9vbHRpcCl7dmFyIHNoYXBlPW9iai5nZXRTaGFwZShlKTtpZihzaGFwZSYmc2hhcGVbJ3Rvb2x0aXAnXSl7dmFyIHRleHQ9c2hhcGVbJ3Rvb2x0aXAnXTtpZih0ZXh0KXt2YXIgdHlwZT1zaGFwZVsnb2JqZWN0J10udHlwZTtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXcoKTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LnRvb2x0aXAuc2hhcGUnLHNoYXBlKTtSRy50b29sdGlwKG9iaix0ZXh0LDAsMCxzaGFwZVsnaW5kZXgnXSxlKTtvYmouaGlnaGxpZ2h0KHNoYXBlKTtpZihSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LnRvb2x0aXAnKSl7UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJykuX19zaGFwZV9fPXNoYXBlO1JHLmV2YWx1YXRlQ3Vyc29yKGUpO31cbmUuY2FuY2VsQnViYmxlPXRydWU7ZS5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gZmFsc2U7fX19XG5pZihSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZycpfHxSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpKXtpZihvYmomJm9iai50eXBlPT09J2xpbmUnKXtvYmouZGF0YV9hcnI9UkcuYXJyYXlMaW5lYXJpemUob2JqLmRhdGEpO31cblJHLmZpcmVDdXN0b21FdmVudChSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZycpLCdvbmFkanVzdGVuZCcpO31cblJHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nJyxudWxsKTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LmFkanVzdGluZy5zaGFwZScsbnVsbCk7UkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnLG51bGwpO2lmKHNoYXBlfHwob2JqLm92ZXJDaGFydEFyZWEmJm9iai5vdmVyQ2hhcnRBcmVhKGUpKSl7YnJlYWs7fX19fTtvYmouY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLG9iai5jYW52YXMucmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXIsZmFsc2UpO319O1JHLmluc3RhbGxDYW52YXNNb3VzZW1vdmVMaXN0ZW5lcj1SRy5JbnN0YWxsQ2FudmFzTW91c2Vtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24ob2JqKVxue2lmKCFvYmouY2FudmFzLnJncmFwaF9tb3VzZW1vdmVfZXZlbnRfbGlzdGVuZXIpe29iai5jYW52YXMucmdyYXBoX21vdXNlbW92ZV9ldmVudF9saXN0ZW5lcj1mdW5jdGlvbihlKVxue2lmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpPj0wKXdpbmRvdy5ldmVudD1lO2U9UkcuZml4RXZlbnRPYmplY3QoZSk7dmFyIG9iamVjdHM9UkcuT1IuZ2V0T2JqZWN0c0J5WFkoZSk7dmFyIHVpZHM9W107aWYob2JqZWN0cyYmb2JqZWN0cy5sZW5ndGg+MCl7Zm9yKHZhciBpPTAsbGVuPW9iamVjdHMubGVuZ3RoO2k8bGVuO2krPTEpe3ZhciBvYmo9b2JqZWN0c1tpXTt2YXIgaWQ9b2JqLmlkO3VpZHNbb2JqLnVpZF09dHJ1ZTtpZighb2JqLmdldFNoYXBlKXtjb250aW51ZTt9XG52YXIgc2hhcGU9b2JqLmdldFNoYXBlKGUpO2lmKCghc2hhcGUmJnR5cGVvZiBvYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXz09PSdudW1iZXInKXx8KHNoYXBlJiZ0eXBlb2Ygb2JqLl9fbW91c2VvdmVyX3NoYXBlX2luZGV4X189PT0nbnVtYmVyJyYmc2hhcGUuaW5kZXghPT1vYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXykpe1JHLmZpcmVDdXN0b21FdmVudChvYmosJ29ubW91c2VvdXQnKTt9XG5pZihvYmouY29vcmRzJiZvYmouY29vcmRzLmtleSYmb2JqLmNvb3Jkcy5rZXkubGVuZ3RoKXt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2Zvcih2YXIgaT0wLG92ZXJrZXk9ZmFsc2U7aTxvYmouY29vcmRzLmtleS5sZW5ndGg7KytpKXtpZihtb3VzZVhZWzBdPj1vYmouY29vcmRzLmtleVtpXVswXSYmbW91c2VYWVswXTw9KG9iai5jb29yZHMua2V5W2ldWzBdK29iai5jb29yZHMua2V5W2ldWzJdKSYmbW91c2VYWVsxXT49b2JqLmNvb3Jkcy5rZXlbaV1bMV0mJm1vdXNlWFlbMV08PShvYmouY29vcmRzLmtleVtpXVsxXStvYmouY29vcmRzLmtleVtpXVszXSkpe1JHLlJlZ2lzdHJ5LnNldCgna2V5LWVsZW1lbnQnLG9iai5jb29yZHMua2V5W2ldKTtvdmVya2V5PXRydWU7fVxuaWYoIW92ZXJrZXkpe1JHLlJlZ2lzdHJ5LnNldCgna2V5LWVsZW1lbnQnLG51bGwpO319fVxudmFyIGZ1bmM9b2JqLmdldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZScpO2lmKCFmdW5jJiZ0eXBlb2Ygb2JqLm9ubW91c2Vtb3ZlPT0nZnVuY3Rpb24nKXt2YXIgZnVuYz1vYmoub25tb3VzZW1vdmU7fVxuaWYoc2hhcGUpe3ZhciBpbmRleD1zaGFwZVsnb2JqZWN0J10udHlwZT09J3NjYXR0ZXInP3NoYXBlWydpbmRleF9hZGp1c3RlZCddOnNoYXBlWydpbmRleCddO2lmKHR5cGVvZihvYmpbJyQnK2luZGV4XSk9PSdvYmplY3QnJiZ0eXBlb2Yob2JqWyckJytpbmRleF0ub25tb3VzZW1vdmUpPT0nZnVuY3Rpb24nKXt2YXIgZnVuYzI9b2JqWyckJytpbmRleF0ub25tb3VzZW1vdmU7fX1cbmlmKHNoYXBlJiYodHlwZW9mKGZ1bmMpPT0nZnVuY3Rpb24nfHx0eXBlb2YoZnVuYzIpPT0nZnVuY3Rpb24nfHx0eXBlb2Ygb2JqLkdldCgnbGluaycpPT09J3N0cmluZycpKXtpZihvYmouR2V0KCdjaGFydC5ldmVudHMubW91c2Vtb3ZlLnJldmVydHRvJyk9PW51bGwpe29iai5TZXQoJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUucmV2ZXJ0dG8nLGUudGFyZ2V0LnN0eWxlLmN1cnNvcik7fVxuaWYodHlwZW9mKGZ1bmMpPT0nZnVuY3Rpb24nKVJHcmFwaC5jdXN0b21fZXZlbnRzX21vdXNlbW92ZV9wb2ludGVyPWZ1bmMoZSxzaGFwZSk7aWYodHlwZW9mKGZ1bmMyKT09J2Z1bmN0aW9uJylSR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlcj1SR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlcnx8ZnVuYzIoZSxzaGFwZSk7aWYodHlwZW9mIFJHLmV2ZW50cz09PSdvYmplY3QnJiZ0eXBlb2YgUkcuZXZlbnRzW29iai51aWRdPT09J29iamVjdCcpe2ZvcihpIGluIFJHLmV2ZW50c1tvYmoudWlkXSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyYmdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXVtpXT09PSdvYmplY3QnJiZSRy5ldmVudHNbb2JqLnVpZF1baV1bMV09PT0nb25tb3VzZW1vdmUnJiZ0eXBlb2YgUkcuZXZlbnRzW29iai51aWRdW2ldWzJdPT09J2Z1bmN0aW9uJyl7KFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXSkob2JqKTt9fX19ZWxzZSBpZih0eXBlb2Yob2JqLkdldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZS5yZXZlcnR0bycpKT09J3N0cmluZycpe1JHLmN1cnNvci5wdXNoKCdkZWZhdWx0Jyk7b2JqLlNldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZS5yZXZlcnR0bycsbnVsbCk7fVxudmFyIGZ1bmM9b2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmV2ZW50cy5tb3VzZW92ZXInXTtpZighZnVuYyYmdHlwZW9mIG9iai5vbm1vdXNlb3Zlcj09PSdmdW5jdGlvbicpe2Z1bmM9b2JqLm9ubW91c2VvdmVyO31cbmlmKHNoYXBlKXt2YXIgaW5kZXg9c2hhcGVbJ29iamVjdCddLnR5cGU9PSdzY2F0dGVyJz9zaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXTpzaGFwZVsnaW5kZXgnXTtpZih0eXBlb2Yob2JqWyckJytpbmRleF0pPT0nb2JqZWN0JyYmdHlwZW9mKG9ialsnJCcraW5kZXhdLm9ubW91c2VvdmVyKT09J2Z1bmN0aW9uJyl7dmFyIGZ1bmMyPW9ialsnJCcraW5kZXhdLm9ubW91c2VvdmVyO319ZWxzZXtvYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXz1udWxsO1JHLl9fbW91c2VvdmVyX29iamVjdHNfXz1bXTt9XG5pZih0eXBlb2YgUkcuX19tb3VzZW92ZXJfb2JqZWN0c19fPT09J3VuZGVmaW5lZCcpe1JHLl9fbW91c2VvdmVyX29iamVjdHNfXz1bXTt9XG5pZihzaGFwZSl7aWYoKG9iai5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fPT09c2hhcGUuaW5kZXgpPT09ZmFsc2Upe29iai5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fPXNoYXBlLmluZGV4O1JHLl9fbW91c2VvdmVyX29iamVjdHNfXy5wdXNoKG9iaik7aWYoZnVuYylmdW5jKGUsc2hhcGUpO2lmKGZ1bmMyKWZ1bmMyKGUsc2hhcGUpO2lmKHR5cGVvZiBSRy5ldmVudHM9PT0nb2JqZWN0JyYmdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXT09PSdvYmplY3QnKXtmb3IoaSBpbiBSRy5ldmVudHNbb2JqLnVpZF0pe2lmKHR5cGVvZiBpPT09J3N0cmluZycmJnR5cGVvZiBSRy5ldmVudHNbb2JqLnVpZF1baV09PT0nb2JqZWN0JyYmUkcuZXZlbnRzW29iai51aWRdW2ldWzFdPT09J29ubW91c2VvdmVyJyYmdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXT09PSdmdW5jdGlvbicpeyhSRy5ldmVudHNbb2JqLnVpZF1baV1bMl0pKG9iaik7fX19fX1lbHNle29iai5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fPW51bGw7UkcuX19tb3VzZW92ZXJfb2JqZWN0c19fPVtdO31cbnZhciBjdXJyZW50X3Rvb2x0aXA9UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJyk7dmFyIHRvb2x0aXBzPW9iai5nZXQoJ2NoYXJ0LnRvb2x0aXBzJyk7dmFyIHRvb2x0aXBzX2V2ZW50PW9iai5HZXQoJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jyk7aWYoc2hhcGUmJih0b29sdGlwcyYmdG9vbHRpcHNbc2hhcGVbJ2luZGV4J11dfHxzaGFwZVsndG9vbHRpcCddKSYmdG9vbHRpcHNfZXZlbnQuaW5kZXhPZignbW91c2Vtb3ZlJykhPT0tMSYmKFJHLmlzTnVsbChjdXJyZW50X3Rvb2x0aXApfHxvYmoudWlkIT1jdXJyZW50X3Rvb2x0aXAuX19vYmplY3RfXy51aWR8fChjdXJyZW50X3Rvb2x0aXAuX19pbmRleF9fIT1zaGFwZVsnaW5kZXgnXSl8fCh0eXBlb2Ygc2hhcGVbJ2RhdGFzZXQnXT09PSdudW1iZXInJiZzaGFwZVsnZGF0YXNldCddIT1jdXJyZW50X3Rvb2x0aXAuX19zaGFwZV9fWydkYXRhc2V0J10pKSl7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcuaGlkZVRvb2x0aXAoKTtSRy5yZWRyYXcoKTtvYmouY2FudmFzLnJncmFwaF9tb3VzZXVwX2V2ZW50X2xpc3RlbmVyKGUpO3JldHVybjt9XG5pZihvYmomJm9iai5nZXQoJ2NoYXJ0LmFkanVzdGFibGUnKSl7b2JqLkFkanVzdGluZ19tb3VzZW1vdmUoZSk7fVxuaWYoc2hhcGV8fChvYmoub3ZlckNoYXJ0QXJlYSYmb2JqLm92ZXJDaGFydEFyZWEoZSkpKXticmVhazt9fVxudmFyIG9iamVjdHM9UkcuT1IuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoZS50YXJnZXQuaWQpO2Zvcih2YXIgaT0wO2k8b2JqZWN0cy5sZW5ndGg7KytpKXtpZighdWlkc1tvYmplY3RzW2ldLnVpZF0pe29iamVjdHNbaV0uX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXz1udWxsO319fWVsc2V7dmFyIG9iamVjdHM9UkcuT1IuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoZS50YXJnZXQuaWQpO2Zvcih2YXIgaT0wO2k8b2JqZWN0cy5sZW5ndGg7aSsrKXtpZih0eXBlb2Ygb2JqZWN0c1tpXS5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fPT09J251bWJlcicpe1JHLmZpcmVDdXN0b21FdmVudChvYmplY3RzW2ldLCdvbm1vdXNlb3V0Jyk7fVxub2JqZWN0c1tpXS5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fPW51bGw7fVxuUkcuX19tb3VzZW92ZXJfb2JqZWN0c19fPVtdO31cbmlmKGUudGFyZ2V0JiZlLnRhcmdldC5fX29iamVjdF9fJiZlLnRhcmdldC5fX29iamVjdF9fLmdldCgnY2hhcnQuY3Jvc3NoYWlycycpKXtSRy5kcmF3Q3Jvc3NoYWlycyhlLGUudGFyZ2V0Ll9fb2JqZWN0X18pO31cbmlmKGUudGFyZ2V0Ll9fb2JqZWN0X18mJmUudGFyZ2V0Ll9fb2JqZWN0X18uZ2V0KCdjaGFydC5hbm5vdGF0YWJsZScpJiZSRy5hbm5vdGF0aW5nX2NhbnZhc19vbm1vdXNlbW92ZSl7UkcuYW5ub3RhdGluZ19jYW52YXNfb25tb3VzZW1vdmUoZSk7fVxuUkcuZXZhbHVhdGVDdXJzb3IoZSk7fTtvYmouY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2Vtb3ZlX2V2ZW50X2xpc3RlbmVyLGZhbHNlKTt9fTtSRy5pbnN0YWxsQ2FudmFzTW91c2Vkb3duTGlzdGVuZXI9UkcuSW5zdGFsbENhbnZhc01vdXNlZG93bkxpc3RlbmVyPWZ1bmN0aW9uKG9iailcbntpZighb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyKXtvYmouY2FudmFzLnJncmFwaF9tb3VzZWRvd25fZXZlbnRfbGlzdGVuZXI9ZnVuY3Rpb24oZSlcbntpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKT49MCl3aW5kb3cuZXZlbnQ9ZTtlPVJHLmZpeEV2ZW50T2JqZWN0KGUpO2lmKGUudGFyZ2V0Ll9fb2JqZWN0X18mJmUudGFyZ2V0Ll9fb2JqZWN0X18uZ2V0KCdjaGFydC5hbm5vdGF0YWJsZScpJiZSRy5hbm5vdGF0aW5nX2NhbnZhc19vbm1vdXNlZG93bil7UkcuYW5ub3RhdGluZ19jYW52YXNfb25tb3VzZWRvd24oZSk7cmV0dXJuO31cbnZhciBvYmo9UkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0QnlYWShlKTtpZihvYmope3ZhciBpZD1vYmouaWQ7aWYob2JqJiZvYmouaXNSR3JhcGgmJm9iai5nZXQoJ2NoYXJ0LmFkanVzdGFibGUnKSl7dmFyIG9iaj1SRy5PUi5nZXRPYmplY3RCeVhZKGUpO2lmKG9iaiYmb2JqLmlzUkdyYXBoKXtzd2l0Y2gob2JqLnR5cGUpe2Nhc2UnYmFyJzp2YXIgc2hhcGU9b2JqLmdldFNoYXBlQnlYKGUpO2JyZWFrO2Nhc2UnZ2FudHQnOnZhciBzaGFwZT1vYmouZ2V0U2hhcGUoZSk7dmFyIGRhdGE9dHlwZW9mIHNoYXBlLnN1YmluZGV4PT09J251bWJlcic/b2JqLmRhdGFbc2hhcGUuaW5kZXhdW3NoYXBlLnN1YmluZGV4XTpvYmouZGF0YVtzaGFwZS5pbmRleF07aWYoc2hhcGUpe3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7UkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnLHtpbmRleDpzaGFwZS5pbmRleCxzdWJpbmRleDpzaGFwZS5zdWJpbmRleCxvYmplY3Q6b2JqLG1vdXNleDptb3VzZVhZWzBdLG1vdXNleTptb3VzZVhZWzFdLGV2ZW50OmRhdGEsZXZlbnRfc3RhcnQ6ZGF0YVswXSxldmVudF9kdXJhdGlvbjpkYXRhWzFdLG1vZGU6KG1vdXNlWFlbMF0+KHNoYXBlWyd4J10rc2hhcGVbJ3dpZHRoJ10tNSk/J3Jlc2l6ZSc6J21vdmUnKSxzaGFwZTpzaGFwZX0pO31cbmJyZWFrO2Nhc2UnbGluZSc6dmFyIHNoYXBlPW9iai5nZXRTaGFwZShlKTticmVhaztjYXNlJ2hiYXInOnZhciBzaGFwZT1vYmouZ2V0U2hhcGVCeVkoZSk7YnJlYWs7ZGVmYXVsdDp2YXIgc2hhcGU9bnVsbDt9XG5pZihSRy5pc051bGwob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKXx8dHlwZW9mIG9iai5wcm9wZXJ0aWVzWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXT09PSd1bmRlZmluZWQnfHwoUkcuaXNBcnJheShvYmoucHJvcGVydGllc1snY2hhcnQuYWRqdXN0YWJsZS5vbmx5J10pJiZvYmouaXNBZGp1c3RhYmxlJiZvYmouaXNBZGp1c3RhYmxlKHNoYXBlKSkpe1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyxzaGFwZSk7UkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hZGp1c3RiZWdpbicpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nJyxvYmopO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhdygpO29iai5jYW52YXMucmdyYXBoX21vdXNlbW92ZV9ldmVudF9saXN0ZW5lcihlKTt9fX1cblJHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhdygpO319O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxvYmouY2FudmFzLnJncmFwaF9tb3VzZWRvd25fZXZlbnRfbGlzdGVuZXIsZmFsc2UpO319O1JHLmluc3RhbGxDYW52YXNDbGlja0xpc3RlbmVyPVJHLkluc3RhbGxDYW52YXNDbGlja0xpc3RlbmVyPWZ1bmN0aW9uKG9iailcbntpZighb2JqLmNhbnZhcy5yZ3JhcGhfY2xpY2tfZXZlbnRfbGlzdGVuZXIpe29iai5jYW52YXMucmdyYXBoX2NsaWNrX2V2ZW50X2xpc3RlbmVyPWZ1bmN0aW9uKGUpXG57aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+PTApd2luZG93LmV2ZW50PWU7ZT1SRy5maXhFdmVudE9iamVjdChlKTt2YXIgb2JqZWN0cz1SRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlYWShlKTtmb3IodmFyIGk9MCxsZW49b2JqZWN0cy5sZW5ndGg7aTxsZW47aSs9MSl7dmFyIG9iaj1vYmplY3RzW2ldO3ZhciBpZD1vYmouaWQ7dmFyIHNoYXBlPW9iai5nZXRTaGFwZShlKTt2YXIgZnVuYz1vYmouZ2V0KCdjaGFydC5ldmVudHMuY2xpY2snKTtpZighZnVuYyYmdHlwZW9mKG9iai5vbmNsaWNrKT09J2Z1bmN0aW9uJyl7ZnVuYz1vYmoub25jbGljazt9XG5pZihzaGFwZSYmdHlwZW9mIGZ1bmM9PSdmdW5jdGlvbicpe2Z1bmMoZSxzaGFwZSk7aWYodHlwZW9mIFJHLmV2ZW50cz09PSdvYmplY3QnJiZ0eXBlb2YgUkcuZXZlbnRzW29iai51aWRdPT09J29iamVjdCcpe2ZvcihpIGluIFJHLmV2ZW50c1tvYmoudWlkXSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyYmdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXVtpXT09PSdvYmplY3QnJiZSRy5ldmVudHNbb2JqLnVpZF1baV1bMV09PT0nb25jbGljaycmJnR5cGVvZiBSRy5ldmVudHNbb2JqLnVpZF1baV1bMl09PT0nZnVuY3Rpb24nKXsoUkcuZXZlbnRzW29iai51aWRdW2ldWzJdKShvYmopO319fVxucmV0dXJuO31cbnZhciBrZXk9UkcuUmVnaXN0cnkuZ2V0KCdrZXktZWxlbWVudCcpO2lmKGtleSl7UkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb25rZXljbGljaycpO31cbmlmKHNoYXBlKXt2YXIgaW5kZXg9c2hhcGVbJ29iamVjdCddLnR5cGU9PSdzY2F0dGVyJz9zaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXTpzaGFwZVsnaW5kZXgnXTtpZih0eXBlb2YoaW5kZXgpPT0nbnVtYmVyJyYmb2JqWyckJytpbmRleF0pe3ZhciBmdW5jPW9ialsnJCcraW5kZXhdLm9uY2xpY2s7aWYodHlwZW9mKGZ1bmMpPT0nZnVuY3Rpb24nKXtmdW5jKGUsc2hhcGUpO3JldHVybjt9fX1cbmlmKHNoYXBlfHwob2JqLm92ZXJDaGFydEFyZWEmJm9iai5vdmVyQ2hhcnRBcmVhKGUpKSl7YnJlYWs7fX19O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLG9iai5jYW52YXMucmdyYXBoX2NsaWNrX2V2ZW50X2xpc3RlbmVyLGZhbHNlKTt9fTtSRy5ldmFsdWF0ZUN1cnNvcj1SRy5FdmFsdWF0ZUN1cnNvcj1mdW5jdGlvbihlKVxue3ZhciBvYmo9bnVsbDt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVg9bW91c2VYWVswXTt2YXIgbW91c2VZPW1vdXNlWFlbMV07dmFyIGNhbnZhcz1lLnRhcmdldDt2YXIgb2JqZWN0cz1SRy5PUi5nZXRPYmplY3RzQnlDYW52YXNJRChjYW52YXMuaWQpO2Zvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjtpKz0xKXtpZigob2JqZWN0c1tpXS5nZXRTaGFwZSYmb2JqZWN0c1tpXS5nZXRTaGFwZShlKSl8fChvYmplY3RzW2ldLm92ZXJDaGFydEFyZWEmJm9iamVjdHNbaV0ub3ZlckNoYXJ0QXJlYShlKSkpe3ZhciBvYmo9b2JqZWN0c1tpXTt2YXIgaWQ9b2JqLmlkO319XG5pZighUkcuaXNOdWxsKG9iaikpe2lmKG9iai5nZXRTaGFwZSYmb2JqLmdldFNoYXBlKGUpKXt2YXIgc2hhcGU9b2JqLmdldFNoYXBlKGUpO2lmKG9iai5nZXQoJ2NoYXJ0LnRvb2x0aXBzJykpe3ZhciB0ZXh0PVJHLnBhcnNlVG9vbHRpcFRleHQob2JqLmdldCgnY2hhcnQudG9vbHRpcHMnKSxzaGFwZVsnaW5kZXgnXSk7aWYoIXRleHQmJnNoYXBlWydvYmplY3QnXS50eXBlPT0nc2NhdHRlcicmJnNoYXBlWydpbmRleF9hZGp1c3RlZCddKXt0ZXh0PVJHLnBhcnNlVG9vbHRpcFRleHQob2JqLmdldCgnY2hhcnQudG9vbHRpcHMnKSxzaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXSk7fVxuaWYodGV4dCl7dmFyIHBvaW50ZXI9dHJ1ZTt9fX1cbmlmKCFSRy5pc051bGwob2JqKSYmb2JqLkdldCgnY2hhcnQua2V5LmludGVyYWN0aXZlJykpe2Zvcih2YXIgaj0wO2o8b2JqLmNvb3Jkcy5rZXkubGVuZ3RoOysrail7aWYobW91c2VYPm9iai5jb29yZHMua2V5W2pdWzBdJiZtb3VzZVg8KG9iai5jb29yZHMua2V5W2pdWzBdK29iai5jb29yZHMua2V5W2pdWzJdKSYmbW91c2VZPm9iai5jb29yZHMua2V5W2pdWzFdJiZtb3VzZVk8KG9iai5jb29yZHMua2V5W2pdWzFdK29iai5jb29yZHMua2V5W2pdWzNdKSl7dmFyIHBvaW50ZXI9dHJ1ZTt9fX19XG5pZihSR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlcil7dmFyIHBvaW50ZXI9dHJ1ZTtSR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlcj1mYWxzZTt9XG52YXIgb2JqZWN0cz1SRy5PUi5vYmplY3RzLmJ5Q2FudmFzSUQ7Zm9yKHZhciBpPTAsbGVuPW9iamVjdHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKG9iamVjdHNbaV0mJm9iamVjdHNbaV1bMV0uR2V0KCdjaGFydC5yZXNpemFibGUnKSl7dmFyIHJlc2l6YWJsZT10cnVlO319XG5pZihyZXNpemFibGUmJm1vdXNlWD4oZS50YXJnZXQud2lkdGgtMzIpJiZtb3VzZVk+KGUudGFyZ2V0LmhlaWdodC0xNikpe3BvaW50ZXI9dHJ1ZTt9XG5pZihwb2ludGVyKXtlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO31lbHNlIGlmKGUudGFyZ2V0LnN0eWxlLmN1cnNvcj09J3BvaW50ZXInKXtlLnRhcmdldC5zdHlsZS5jdXJzb3I9J2RlZmF1bHQnO31lbHNle2UudGFyZ2V0LnN0eWxlLmN1cnNvcj1udWxsO31cbmlmKHJlc2l6YWJsZSYmbW91c2VYPj0oZS50YXJnZXQud2lkdGgtMTUpJiZtb3VzZVk+PShlLnRhcmdldC5oZWlnaHQtMTUpKXtlLnRhcmdldC5zdHlsZS5jdXJzb3I9J21vdmUnO31lbHNlIGlmKGUudGFyZ2V0LnN0eWxlLmN1cnNvcj09PSdtb3ZlJyl7ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9XG5pZih0eXBlb2YgbW91c2Vfb3Zlcl9rZXk9PSdib29sZWFuJyYmbW91c2Vfb3Zlcl9rZXkpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fVxuaWYob2JqJiZvYmoudHlwZT09J2xpbmUnJiZvYmouZ2V0KCdjaGFydC5hZGp1c3RhYmxlJykpe2lmKG9iai5nZXRTaGFwZSl7dmFyIHNoYXBlPW9iai5nZXRTaGFwZShlKTtpZihzaGFwZSYmb2JqLmlzQWRqdXN0YWJsZShzaGFwZSkpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0nbnMtcmVzaXplJzt9fWVsc2V7ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9fVxuaWYoZS50YXJnZXQuX19vYmplY3RfXyYmZS50YXJnZXQuX19vYmplY3RfXy5nZXQoJ2NoYXJ0LmFubm90YXRhYmxlJykpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0nY3Jvc3NoYWlyJzt9XG5pZihvYmomJm9iai50eXBlPT09J2RyYXdpbmcudGV4dCcmJnNoYXBlJiZ0eXBlb2Ygb2JqLmdldCgnbGluaycpPT09J3N0cmluZycpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fX07UkcucGFyc2VUb29sdGlwVGV4dD1mdW5jdGlvbih0b29sdGlwcyxpZHgpXG57aWYoIXRvb2x0aXBzKXtyZXR1cm4gbnVsbDt9XG5pZih0eXBlb2YgdG9vbHRpcHM9PSdmdW5jdGlvbicpe3ZhciB0ZXh0PXRvb2x0aXBzKGlkeCk7fWVsc2UgaWYodHlwZW9mIHRvb2x0aXBzPT0nc3RyaW5nJyl7dmFyIHRleHQ9dG9vbHRpcHM7fWVsc2UgaWYodHlwZW9mIHRvb2x0aXBzPT0nb2JqZWN0JyYmdHlwZW9mIHRvb2x0aXBzW2lkeF09PSdmdW5jdGlvbicpe3ZhciB0ZXh0PXRvb2x0aXBzW2lkeF0oaWR4KTt9ZWxzZSBpZih0eXBlb2YgdG9vbHRpcHNbaWR4XT09J3N0cmluZycmJnRvb2x0aXBzW2lkeF0pe3ZhciB0ZXh0PXRvb2x0aXBzW2lkeF07fWVsc2V7dmFyIHRleHQ9Jyc7fVxuaWYodGV4dD09J3VuZGVmaW5lZCcpe3RleHQ9Jyc7fWVsc2UgaWYodGV4dD09J251bGwnKXt0ZXh0PScnO31cbnJldHVybiBSRy5nZXRUb29sdGlwVGV4dEZyb21ESVY/UkcuZ2V0VG9vbHRpcFRleHRGcm9tRElWKHRleHQpOnRleHQ7fTtSRy5kcmF3Q3Jvc3NoYWlycz1SRy5EcmF3Q3Jvc3NoYWlycz1mdW5jdGlvbihlLG9iailcbnt2YXIgZT1SRy5maXhFdmVudE9iamVjdChlKSx3aWR0aD1vYmouY2FudmFzLndpZHRoLGhlaWdodD1vYmouY2FudmFzLmhlaWdodCxtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSkseD1tb3VzZVhZWzBdLHk9bW91c2VYWVsxXSxndXR0ZXJMZWZ0PW9iai5ndXR0ZXJMZWZ0LGd1dHRlclJpZ2h0PW9iai5ndXR0ZXJSaWdodCxndXR0ZXJUb3A9b2JqLmd1dHRlclRvcCxndXR0ZXJCb3R0b209b2JqLmd1dHRlckJvdHRvbSxNYXRocm91bmQ9TWF0aC5yb3VuZCxwcm9wPW9iai5wcm9wZXJ0aWVzLGNvPW9iai5jb250ZXh0LGNhPW9iai5jYW52YXNcblJHLnJlZHJhd0NhbnZhcyhjYSk7aWYoeD49Z3V0dGVyTGVmdCYmeT49Z3V0dGVyVG9wJiZ4PD0od2lkdGgtZ3V0dGVyUmlnaHQpJiZ5PD0oaGVpZ2h0LWd1dHRlckJvdHRvbSkpe3ZhciBsaW5ld2lkdGg9cHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5saW5ld2lkdGgnXT9wcm9wWydjaGFydC5jcm9zc2hhaXJzLmxpbmV3aWR0aCddOjE7Y28ubGluZVdpZHRoPWxpbmV3aWR0aD9saW5ld2lkdGg6MTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ107aWYocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5zbmFwJ10pe3ZhciBwb2ludD1udWxsO3ZhciBkaXN0PW51bGw7dmFyIGxlbj1udWxsO2lmKG9iai50eXBlPT0nbGluZScpe2Zvcih2YXIgaT0wO2k8b2JqLmNvb3Jkcy5sZW5ndGg7KytpKXt2YXIgbGVuZ3RoPVJHLmdldEh5cExlbmd0aChvYmouY29vcmRzW2ldWzBdLG9iai5jb29yZHNbaV1bMV0seCx5KTtpZih0eXBlb2YgZGlzdCE9J251bWJlcid8fGxlbmd0aDxkaXN0KXt2YXIgcG9pbnQ9aTt2YXIgZGlzdD1sZW5ndGg7fX1cbng9b2JqLmNvb3Jkc1twb2ludF1bMF07eT1vYmouY29vcmRzW3BvaW50XVsxXTtmb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PG9iai5jb29yZHMyLmxlbmd0aDsrK2RhdGFzZXQpe2Zvcih2YXIgcG9pbnQ9MDtwb2ludDxvYmouY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7Kytwb2ludCl7aWYob2JqLmNvb3JkczJbZGF0YXNldF1bcG9pbnRdWzBdPT14JiZvYmouY29vcmRzMltkYXRhc2V0XVtwb2ludF1bMV09PXkpe2NhLl9fY3Jvc3NoYWlyc19zbmFwX2RhdGFzZXRfXz1kYXRhc2V0O2NhLl9fY3Jvc3NoYWlyc19zbmFwX3BvaW50X189cG9pbnQ7fX19fWVsc2V7Zm9yKHZhciBpPTA7aTxvYmouY29vcmRzLmxlbmd0aDsrK2kpe2Zvcih2YXIgaj0wO2o8b2JqLmNvb3Jkc1tpXS5sZW5ndGg7KytqKXt2YXIgbGVuPVJHLmdldEh5cExlbmd0aChvYmouY29vcmRzW2ldW2pdWzBdLG9iai5jb29yZHNbaV1bal1bMV0seCx5KTtpZih0eXBlb2YoZGlzdCkhPSdudW1iZXInfHxsZW48ZGlzdCl7dmFyIGRhdGFzZXQ9aTt2YXIgcG9pbnQ9ajt2YXIgZGlzdD1sZW47fX19XG5jYS5fX2Nyb3NzaGFpcnNfc25hcF9kYXRhc2V0X189ZGF0YXNldDtjYS5fX2Nyb3NzaGFpcnNfc25hcF9wb2ludF9fPXBvaW50O3g9b2JqLmNvb3Jkc1tkYXRhc2V0XVtwb2ludF1bMF07eT1vYmouY29vcmRzW2RhdGFzZXRdW3BvaW50XVsxXTt9fVxuaWYocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy52bGluZSddKXtjby5tb3ZlVG8oTWF0aHJvdW5kKHgpLE1hdGhyb3VuZChndXR0ZXJUb3ApKTtjby5saW5lVG8oTWF0aHJvdW5kKHgpLE1hdGhyb3VuZChoZWlnaHQtZ3V0dGVyQm90dG9tKSk7fVxuaWYocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5obGluZSddKXtjby5tb3ZlVG8oTWF0aHJvdW5kKGd1dHRlckxlZnQpLE1hdGhyb3VuZCh5KSk7Y28ubGluZVRvKE1hdGhyb3VuZCh3aWR0aC1ndXR0ZXJSaWdodCksTWF0aHJvdW5kKHkpKTt9XG5jby5zdHJva2UoKTtpZihvYmoudHlwZT09J3NjYXR0ZXInJiZwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvb3JkcyddKXt2YXIgeENvb3JkPSgoKHgtZ3V0dGVyTGVmdCkvKHdpZHRoLWd1dHRlckxlZnQtZ3V0dGVyUmlnaHQpKSoocHJvcFsnY2hhcnQueG1heCddLXByb3BbJ2NoYXJ0LnhtaW4nXSkpK3Byb3BbJ2NoYXJ0LnhtaW4nXTt4Q29vcmQ9eENvb3JkLnRvRml4ZWQocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSk7dmFyIHlDb29yZD1vYmoubWF4LSgoKHktcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKS8oaGVpZ2h0LWd1dHRlclRvcC1ndXR0ZXJCb3R0b20pKSpvYmoubWF4KTtpZihvYmoudHlwZT09J3NjYXR0ZXInJiZvYmoucHJvcGVydGllc1snY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe3lDb29yZD0oeUNvb3JkLShvYmoubWF4LzIpKSoyO31cbnlDb29yZD15Q29vcmQudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKTt2YXIgZGl2PVJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuY29vcmRpbmF0ZXMuY29vcmRzLmRpdicpO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIGNhbnZhc1hZPVJHLmdldENhbnZhc1hZKGNhKTtpZighZGl2KXt2YXIgZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5fX29iamVjdF9fPW9iajtkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPSd3aGl0ZSc7ZGl2LnN0eWxlLmJvcmRlcj0nMXB4IHNvbGlkIGJsYWNrJztkaXYuc3R5bGUuZm9udEZhbWlseT0nQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnO2Rpdi5zdHlsZS5mb250U2l6ZT0nMTBwdCdcbmRpdi5zdHlsZS5wYWRkaW5nPScycHgnO2Rpdi5zdHlsZS5vcGFjaXR5PTE7ZGl2LnN0eWxlLldlYmtpdEJvcmRlclJhZGl1cz0nM3B4JztkaXYuc3R5bGUuYm9yZGVyUmFkaXVzPSczcHgnO2Rpdi5zdHlsZS5Nb3pCb3JkZXJSYWRpdXM9JzNweCc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuY29vcmRpbmF0ZXMuY29vcmRzLmRpdicsZGl2KTt9XG5kaXYuc3R5bGUub3BhY2l0eT0xO2Rpdi5zdHlsZS5kaXNwbGF5PSdpbmxpbmUnO2lmKCFwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5maXhlZCddKXtkaXYuc3R5bGUubGVmdD1tYS5tYXgoMiwoZS5wYWdlWC1kaXYub2Zmc2V0V2lkdGgtMykpKydweCc7ZGl2LnN0eWxlLnRvcD1tYS5tYXgoMiwoZS5wYWdlWS1kaXYub2Zmc2V0SGVpZ2h0LTMpKSsncHgnO31lbHNle2Rpdi5zdHlsZS5sZWZ0PWNhbnZhc1hZWzBdK2d1dHRlckxlZnQrMysncHgnO2Rpdi5zdHlsZS50b3A9Y2FudmFzWFlbMV0rZ3V0dGVyVG9wKzMrJ3B4Jzt9XG5kaXYuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT1cImNvbG9yOiAjNjY2XCI+Jytwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5sYWJlbHMueCddKyc6PC9zcGFuPiAnK3hDb29yZCsnPGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6ICM2NjZcIj4nK3Byb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmxhYmVscy55J10rJzo8L3NwYW4+ICcreUNvb3JkO29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLFJHLmhpZGVDcm9zc2hhaXJDb29yZHMsZmFsc2UpO2NhLl9fY3Jvc3NoYWlyc19sYWJlbHNfXz1kaXY7Y2EuX19jcm9zc2hhaXJzX3hfXz14Q29vcmQ7Y2EuX19jcm9zc2hhaXJzX3lfXz15Q29vcmQ7fWVsc2UgaWYocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMnXSl7YWxlcnQoJ1tSR1JBUEhdIFNob3dpbmcgY3Jvc3NoYWlyIGNvb3JkaW5hdGVzIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRoZSBTY2F0dGVyIGNoYXJ0Jyk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb25jcm9zc2hhaXJzJyk7fWVsc2V7UkcuaGlkZUNyb3NzaGFpckNvb3JkcygpO319O1JHLmFsbG93U2VnbWVudEhpZ2hsaWdodD1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0LGNvdW50PW9wdC5jb3VudCxmaWxsPW9wdC5maWxsLHN0cm9rZT1vcHQuc3Ryb2tlXG5pZighUkcuc2VnbWVudEhpZ2hsaWdodEZ1bmN0aW9uKXtSRy5zZWdtZW50SGlnaGxpZ2h0RnVuY3Rpb249ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBhbmdsZT1SRy5nZXRBbmdsZUJ5WFkob2JqLmNlbnRlcngsb2JqLmNlbnRlcnksbW91c2VYWVswXSxtb3VzZVhZWzFdKTthbmdsZSs9UkcuSEFMRlBJO2lmKGFuZ2xlPlJHLlRXT1BJKXthbmdsZS09UkcuVFdPUEk7fVxuUkcucmVkcmF3KCk7dmFyIHN0YXJ0PTA7dmFyIGVuZD0wO3ZhciBhPShtYS5QSSoyKS9jb3VudDt2YXIgcj1vYmoucmFkaXVzOyhmdW5jdGlvbigpXG57Zm9yKGk9MDtpPGNvdW50O2krPTEpe2lmKGFuZ2xlPChhKihpKzEpKSl7c3RhcnQ9aSphO2VuZD0oaSsxKSphO3JldHVybjt9fX0pKCk7c3RhcnQtPVJHLkhBTEZQSTtlbmQtPVJHLkhBTEZQSTtSRy5wYXRoMihvYmouY29udGV4dCwnYiBtICUgJSBhICUgJSAlICUgJSBmYWxzZSBjIHMgJSBmICUnLG9iai5jZW50ZXJ4LG9iai5jZW50ZXJ5LG9iai5jZW50ZXJ4LG9iai5jZW50ZXJ5LHIsc3RhcnQsZW5kLHN0cm9rZSxmaWxsKTt9O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxSRy5zZWdtZW50SGlnaGxpZ2h0RnVuY3Rpb24sZmFsc2UpO319fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZHluYW1pYy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///199\n");

/***/ }),
/* 200 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Common = {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Effects.decorate = function (obj) {\n    for (i in RG.Effects.Common) {\n      if (typeof RG.Effects.Common[i] === 'function') {\n        obj[i] = RG.Effects.Common[i];\n      }\n    }\n  };RG.Effects.replaceCanvasWithDIV = RG.Effects.ReplaceCanvasWithDIV = RG.Effects.wrap = function (canvas) {\n    if (!canvas.rgraph_wrapper) {\n      var div = $('<div></div>').css({ width: canvas.width + 'px', height: canvas.height + 'px', cssFloat: canvas.style.cssFloat, left: canvas.style.left, top: canvas.style.top, display: 'inline-block' }).get(0);canvas.parentNode.insertBefore(div, canvas);canvas.parentNode.removeChild(canvas);div.appendChild(canvas);canvas.style.position = 'relative';canvas.style.left = div.offsetWidth / 2 + 'px';canvas.style.top = div.offsetHeight / 2 + 'px';canvas.style.cssFloat = '';canvas.rgraph_wrapper = div;\n    }\n    var div = canvas.rgraph_wrapper;return div;\n  };RG.Effects.Common.fadeIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.opacity = 0;RG.redrawCanvas(obj.canvas);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return obj;\n  };RG.Effects.Common.fadeOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.Effects.Common.fadeSlideIn = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.getCanvasXY(obj.canvas),\n        color = opt.color || 'white',\n        callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeSlideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var pc = -20;var step = (120 - pc) / frames;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, obj.get('clearto'));\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white ' + radius + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, color);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.expand = function () {\n    var obj = this;var opt = arguments[0] || {};var bounce = typeof opt.bounce === 'boolean' ? opt.bounce : true;var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!this.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(this.canvas);this.canvas.rgraph_wrapper = div;\n    } else {\n      div = this.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';this.canvas.style.top = this.canvas.height / 2 + 'px';this.canvas.style.left = this.canvas.width / 2 + 'px';this.canvas.style.width = 0;this.canvas.style.height = 0;this.canvas.style.opacity = 0;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);if (bounce) {\n      jQuery('#' + obj.id).animate({ opacity: 1, width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.5, function () {\n        jQuery('#' + obj.id).animate({ width: obj.canvas.width * 0.9 + 'px', height: obj.canvas.height * 0.9 + 'px', top: obj.canvas.height * 0.05 + 'px', left: obj.canvas.width * 0.05 + 'px' }, duration * 0.25, function () {\n          jQuery('#' + obj.id).animate({ width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: 0, left: 0 }, duration * 0.25, function () {\n            callback(obj);\n          });\n        });\n      });\n    } else {\n      jQuery(obj.canvas).animate({ opacity: 1, width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', left: 0, top: 0 }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.contract = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!obj.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(obj.canvas);obj.canvas.rgraph_wrapper = div;\n    } else {\n      div = obj.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';obj.canvas.style.top = 0;obj.canvas.style.left = 0;if (opt.bounce !== false) {\n      jQuery('#' + obj.id).animate({ width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.25, function () {\n        jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n          callback(obj);\n        });\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.reveal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var divs = [['rgraph_reveal_left_' + obj.id, xy[0], xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_right_' + obj.id, xy[0] + obj.canvas.width / 2, xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, obj.canvas.height / 2], ['rgraph_reveal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height / 2, obj.canvas.width, obj.canvas.height / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = document.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = opt && typeof opt.color === 'string' ? opt.color : 'white';document.body.appendChild(div);\n    }\n    RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + obj.canvas.width / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + obj.canvas.height / 2, height: 0 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.revealCircular = RG.Effects.Common.revealcircular = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var currentRadius = 0;\n    var centerx = obj.canvas.width / 2;var centery = obj.canvas.height / 2;var targetRadius = ma.max(obj.canvas.height, obj.canvas.width);var step = targetRadius / frames;var color = opt.background || opt.color || opt.backgroundColor || 'transparent';function iterator() {\n      RG.clear(obj.canvas, color);obj.context.save();obj.context.beginPath();obj.context.arc(centerx, centery, currentRadius, 0, RG.TWOPI, false);obj.context.clip();if (opt.background) {\n        RG.clear(obj.canvas, opt.background);\n      }\n      obj.draw();obj.context.restore();if (currentRadius < targetRadius) {\n        currentRadius += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Effects.Common.conceal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var divs = [['rgraph_conceal_left_' + obj.id, xy[0], xy[1], 0, obj.canvas.height], ['rgraph_conceal_right_' + obj.id, xy[0] + obj.canvas.width, xy[1], 0, obj.canvas.height], ['rgraph_conceal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, 0], ['rgraph_conceal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height, obj.canvas.width, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + obj.canvas.width / 2, width: obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + obj.canvas.height / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + obj.canvas.height / 2, height: obj.canvas.height / 2 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.clear(obj.canvas);callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsOpen = RG.Effects.Common.hblindsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;document.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsClose = RG.Effects.Common.hblindsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = 0;div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.Effects.Common.vBlindsOpen = RG.Effects.Common.vblindsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.vblindsclose = RG.Effects.Common.vBlindsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = 0;div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.slideIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var from = opt.from || 'left';div.style.overflow = 'hidden';RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);canvas.style.position = 'relative';if (from == 'left') {\n      obj.canvas.style.left = 0 - div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    } else if (from == 'top') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = 0 - div.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = div.offsetHeight + 'px';\n    } else {\n      obj.canvas.style.left = div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    }\n    jQuery('#' + obj.id).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.Effects.Common.slideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var to = opt.to || 'left';div.style.overflow = 'hidden';obj.canvas.style.position = 'relative';obj.canvas.style.left = 0;obj.canvas.style.top = 0;if (to == 'left') {\n      jQuery('#' + obj.id).animate({ left: 0 - obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'top') {\n      jQuery('#' + obj.id).animate({ left: 0, top: 0 - div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'bottom') {\n      jQuery('#' + obj.id).animate({ top: 0 + div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ left: 0 + obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.hscissorsopen = RG.Effects.Common.hScissorsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var to = opt.to || 'left';var height = obj.canvas.height / 5;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = obj.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + obj.canvas.width + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hScissorsClose = RG.Effects.Common.hscissorsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = obj.canvas.height / 5;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? xy[0] + obj.canvas.width : xy[0]) + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + 'px', width: obj.canvas.width + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: obj.canvas.width + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RGraph.clear(obj.canvas);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vScissorsOpen = RG.Effects.Common.vscissorsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = obj.canvas.height + 'px';div.style.left = xy[0] + obj.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + obj.canvas.height + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vscissorsclose = RG.Effects.Common.vScissorsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = xy[0] + width * i + 'px';div.style.top = (i % 2 == 0 ? xy[1] + obj.canvas.height : xy[1]) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + 'px', height: obj.canvas.height + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: obj.canvas.height + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.animate = function (map) {\n    var obj = this;obj.draw();var totalFrames = map && map['frames'] ? map['frames'] : 30;var currentFrame = new Array();var originalValues = new Array();var diffs = new Array();var steps = new Array();var callback = arguments[1];\n    function iterator() {\n      var id = [obj.id + '_' + obj.type];if (!currentFrame[id]) {\n        currentFrame[id] = totalFrames;originalValues[id] = {};diffs[id] = {};steps[id] = {};\n      }\n      for (var i in map) {\n        if (typeof map[i] === 'string' || typeof map[i] === 'number') {\n          if (currentFrame[id] == totalFrames) {\n            originalValues[id][i] = obj.get(i);diffs[id][i] = map[i] - originalValues[id][i];steps[id][i] = diffs[id][i] / totalFrames;\n          }\n          obj.set(i, obj.get(i) + steps[id][i]);RG.clear(obj.canvas);obj.draw();\n        }\n      }\n      if (--currentFrame[id] > 0) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        if (typeof callback === 'function') {\n          callback(obj);\n        }\n      }\n    }\n    iterator();\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmVmZmVjdHMuanM/OGVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkVmZmVjdHM9UkdyYXBoLkVmZmVjdHN8fHt9O1JHcmFwaC5FZmZlY3RzLkNvbW1vbj17fTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57dmFyIFJHPVJHcmFwaCx1YT1uYXZpZ2F0b3IudXNlckFnZW50LG1hPU1hdGg7UkcuRWZmZWN0cy5kZWNvcmF0ZT1mdW5jdGlvbihvYmopXG57Zm9yKGkgaW4gUkcuRWZmZWN0cy5Db21tb24pe2lmKHR5cGVvZiBSRy5FZmZlY3RzLkNvbW1vbltpXT09PSdmdW5jdGlvbicpe29ialtpXT1SRy5FZmZlY3RzLkNvbW1vbltpXTt9fX07UkcuRWZmZWN0cy5yZXBsYWNlQ2FudmFzV2l0aERJVj1SRy5FZmZlY3RzLlJlcGxhY2VDYW52YXNXaXRoRElWPVJHLkVmZmVjdHMud3JhcD1mdW5jdGlvbihjYW52YXMpXG57aWYoIWNhbnZhcy5yZ3JhcGhfd3JhcHBlcil7dmFyIGRpdj0kKCc8ZGl2PjwvZGl2PicpLmNzcyh7d2lkdGg6Y2FudmFzLndpZHRoKydweCcsaGVpZ2h0OmNhbnZhcy5oZWlnaHQrJ3B4Jyxjc3NGbG9hdDpjYW52YXMuc3R5bGUuY3NzRmxvYXQsbGVmdDpjYW52YXMuc3R5bGUubGVmdCx0b3A6Y2FudmFzLnN0eWxlLnRvcCxkaXNwbGF5OidpbmxpbmUtYmxvY2snfSkuZ2V0KDApO2NhbnZhcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkaXYsY2FudmFzKTtjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO2Rpdi5hcHBlbmRDaGlsZChjYW52YXMpO2NhbnZhcy5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO2NhbnZhcy5zdHlsZS5sZWZ0PShkaXYub2Zmc2V0V2lkdGgvMikrJ3B4JztjYW52YXMuc3R5bGUudG9wPShkaXYub2Zmc2V0SGVpZ2h0LzIpKydweCc7Y2FudmFzLnN0eWxlLmNzc0Zsb2F0PScnO2NhbnZhcy5yZ3JhcGhfd3JhcHBlcj1kaXY7fVxudmFyIGRpdj1jYW52YXMucmdyYXBoX3dyYXBwZXI7cmV0dXJuIGRpdjt9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVJbj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtvYmouY2FudmFzLnN0eWxlLm9wYWNpdHk9MDtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Zm9yKHZhciBpPTE7aTw9ZnJhbWVzOysraSl7KGZ1bmN0aW9uKGluZGV4KVxue3NldFRpbWVvdXQoZnVuY3Rpb24oKVxue29iai5jYW52YXMuc3R5bGUub3BhY2l0eT0oaW5kZXgvZnJhbWVzKTtpZihpbmRleD49ZnJhbWVzKXtjYWxsYmFjayhvYmopO319LChpbmRleC9mcmFtZXMpKmR1cmF0aW9uKTt9KShpKX1cbnJldHVybiBvYmo7fTtSRy5FZmZlY3RzLkNvbW1vbi5mYWRlT3V0PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O2Zvcih2YXIgaT0xO2k8PWZyYW1lczsrK2kpeyhmdW5jdGlvbihpbmRleClcbntzZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntvYmouY2FudmFzLnN0eWxlLm9wYWNpdHk9MS0oaW5kZXgvZnJhbWVzKTtpZihpbmRleD49ZnJhbWVzKXtjYWxsYmFjayhvYmopO319LChpbmRleC9mcmFtZXMpKmR1cmF0aW9uKTt9KShpKX1cbnJldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24uZmFkZVNsaWRlSW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8MzAsZnJhbWU9MCxwYz0tMjAsc3RlcD0oMTIwLXBjKS9mcmFtZXMsY2FudmFzWFk9UkcuZ2V0Q2FudmFzWFkob2JqLmNhbnZhcyksY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCsnXCI+PC9kaXY+JykuY3NzKHtiYWNrZ3JvdW5kOidsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCByZ2JhKDI1NSwyNTUsMjU1LDApICcrcGMrJyUsICcrY29sb3IrJyAnKyhwYysyMCkrJyUpJyx3aWR0aDpvYmouY2FudmFzLndpZHRoKydweCcsaGVpZ2h0Om9iai5jYW52YXMuaGVpZ2h0KydweCcsdG9wOmNhbnZhc1hZWzFdKydweCcsbGVmdDpjYW52YXNYWVswXSsncHgnLHBvc2l0aW9uOidhYnNvbHV0ZSd9KS5hcHBlbmRUbygkKG9iai5jYW52YXMucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntpZihwYzwxMjApeyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5jc3Moe2JhY2tncm91bmQ6J2xpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJytwYysnJSwgJytjb2xvcisnICcrKHBjKzIwKSsnJSknfSk7cGMrPXN0ZXA7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNleyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO307UkcuRWZmZWN0cy5Db21tb24uZmFkZVNsaWRlT3V0PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7dmFyIHBjPS0yMDt2YXIgc3RlcD0oMTIwLXBjKS9mcmFtZXM7dmFyIGNhbnZhc1hZPVJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3ZhciBjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZSc7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCsnXCI+PC9kaXY+JykuY3NzKHtiYWNrZ3JvdW5kOidsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAnK2NvbG9yKycgJytwYysnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnKyhwYysyMCkrJyUpJyx3aWR0aDpvYmouY2FudmFzLndpZHRoKydweCcsaGVpZ2h0Om9iai5jYW52YXMuaGVpZ2h0KydweCcsdG9wOmNhbnZhc1hZWzFdKydweCcsbGVmdDpjYW52YXNYWVswXSsncHgnLHBvc2l0aW9uOidhYnNvbHV0ZSd9KS5hcHBlbmRUbygkKG9iai5jYW52YXMucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntpZihwYzwxMjApeyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5jc3Moe2JhY2tncm91bmQ6J2xpbmVhci1ncmFkaWVudCgxMzVkZWcsICcrY29sb3IrJyAnK3BjKyclLCByZ2JhKDI1NSwyNTUsMjU1LDApICcrKHBjKzIwKSsnJSknfSk7cGMrPXN0ZXA7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle1JHLmNsZWFyKG9iai5jYW52YXMsb2JqLmdldCgnY2xlYXJ0bycpKVxuJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7fTtSRy5FZmZlY3RzLkNvbW1vbi5mYWRlQ2lyY3VsYXJJbk91dHdhcmRzPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MTIwO3ZhciBmcmFtZT0wO3ZhciByYWRpdXM9MDt2YXIgY2FudmFzWFk9UkcuZ2V0Q2FudmFzWFkob2JqLmNhbnZhcyk7dmFyIGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJzt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKydcIj48L2Rpdj4nKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCB3aGl0ZSAnK3JhZGl1cysnJSknLHdpZHRoOm9iai5jYW52YXMud2lkdGgrJ3B4JyxoZWlnaHQ6b2JqLmNhbnZhcy5oZWlnaHQrJ3B4Jyx0b3A6Y2FudmFzWFlbMV0sbGVmdDpjYW52YXNYWVswXSxwb3NpdGlvbjonYWJzb2x1dGUnfSkuYXBwZW5kVG8oJChvYmouY2FudmFzLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57aWYoZnJhbWU8ZnJhbWVzKXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAnKygoZnJhbWUrKy8gZnJhbWVzKSAqIDEwMCkgKyAnJSwgJyArIGNvbG9yICsgJyAnICsgKChmcmFtZSsrIC9mcmFtZXMpKjE1MCkrJyUpJ30pO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTt9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVDaXJjdWxhck91dE91dHdhcmRzPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MTIwO3ZhciBmcmFtZT0wO3ZhciBjYW52YXNYWT1SRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7JCgnPGRpdiBpZD1cInJncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQrJ1wiPjwvZGl2PicpLmNzcyh7YmFja2dyb3VuZDoncmFkaWFsLWdyYWRpZW50KHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUsIHdoaXRlIDAlKScsd2lkdGg6b2JqLmNhbnZhcy53aWR0aCsncHgnLGhlaWdodDpvYmouY2FudmFzLmhlaWdodCsncHgnLHRvcDpjYW52YXNYWVsxXSxsZWZ0OmNhbnZhc1hZWzBdLHBvc2l0aW9uOidhYnNvbHV0ZSd9KS5hcHBlbmRUbygkKG9iai5jYW52YXMucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntpZihmcmFtZTxmcmFtZXMpeyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudCgnK2NvbG9yKycgJysoKGZyYW1lKysvIGZyYW1lcykgKiAxMDApICsgJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArICgoZnJhbWUrKyAvZnJhbWVzKSoxNTApKyclKSd9KTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7UkcuY2xlYXIob2JqLmNhbnZhcyxjb2xvcik7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7fTtSRy5FZmZlY3RzLkNvbW1vbi5mYWRlQ2lyY3VsYXJJbklud2FyZHM9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHwxMjA7dmFyIGZyYW1lPTA7dmFyIHJhZGl1cz1tYS5tYXgob2JqLmNhbnZhcy53aWR0aCxvYmouY2FudmFzLmhlaWdodCk7dmFyIGNhbnZhc1hZPVJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3ZhciBjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZSc7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCsnXCI+PC9kaXY+JykuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAxMDAlLCByZ2JhKDI1NSwyNTUsMjU1LDApIDAlKScsd2lkdGg6b2JqLmNhbnZhcy53aWR0aCsncHgnLGhlaWdodDpvYmouY2FudmFzLmhlaWdodCsncHgnLHRvcDpjYW52YXNYWVsxXSsncHgnLGxlZnQ6Y2FudmFzWFlbMF0rJ3B4Jyxwb3NpdGlvbjonYWJzb2x1dGUnfSkuYXBwZW5kVG8oJChvYmouY2FudmFzLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57aWYoZnJhbWU8ZnJhbWVzKXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQoJytjb2xvcisnICcrKCgoZnJhbWVzLWZyYW1lKyspL2ZyYW1lcykqMTAwKSsnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnKygoKGZyYW1lcy1mcmFtZSsrKS9mcmFtZXMpKjEyMCkrJyUpJ30pO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTt9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVDaXJjdWxhck91dElud2FyZHM9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHwxMjA7dmFyIGZyYW1lPTA7dmFyIHJhZGl1cz1tYS5tYXgob2JqLmNhbnZhcy53aWR0aCxvYmouY2FudmFzLmhlaWdodCk7dmFyIGNhbnZhc1hZPVJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3ZhciBjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZSc7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCsnXCI+PC9kaXY+JykuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAwJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAwJSknLHdpZHRoOm9iai5jYW52YXMud2lkdGgrJ3B4JyxoZWlnaHQ6b2JqLmNhbnZhcy5oZWlnaHQrJ3B4Jyx0b3A6Y2FudmFzWFlbMV0sbGVmdDpjYW52YXNYWVswXSxwb3NpdGlvbjonYWJzb2x1dGUnfSkuYXBwZW5kVG8oJChvYmouY2FudmFzLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57aWYoZnJhbWU8ZnJhbWVzKXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAnKygoKGZyYW1lcy1mcmFtZSsrKS9mcmFtZXMpKjEwMCkrJyUsICcrY29sb3IrJyAnKygoKGZyYW1lcy1mcmFtZSsrKS9mcmFtZXMpKjEyMCkrJyUpJ30pO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtSRy5jbGVhcihvYmouY2FudmFzKTskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTt9O1JHLkVmZmVjdHMuQ29tbW9uLmV4cGFuZD1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgYm91bmNlPXR5cGVvZiBvcHQuYm91bmNlPT09J2Jvb2xlYW4nP29wdC5ib3VuY2U6dHJ1ZTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDYwO3ZhciBkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtpZighdGhpcy5jYW52YXMucmdyYXBoX3dyYXBwZXIpe3ZhciBkaXY9UkcuRWZmZWN0cy53cmFwKHRoaXMuY2FudmFzKTt0aGlzLmNhbnZhcy5yZ3JhcGhfd3JhcHBlcj1kaXY7fWVsc2V7ZGl2PXRoaXMuY2FudmFzLnJncmFwaF93cmFwcGVyO31cbmRpdi5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO3RoaXMuY2FudmFzLnN0eWxlLnRvcD0odGhpcy5jYW52YXMuaGVpZ2h0LzIpKydweCc7dGhpcy5jYW52YXMuc3R5bGUubGVmdD0odGhpcy5jYW52YXMud2lkdGgvMikrJ3B4Jzt0aGlzLmNhbnZhcy5zdHlsZS53aWR0aD0wO3RoaXMuY2FudmFzLnN0eWxlLmhlaWdodD0wO3RoaXMuY2FudmFzLnN0eWxlLm9wYWNpdHk9MDtSRy5jbGVhcih0aGlzLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKHRoaXMuY2FudmFzKTtpZihib3VuY2Upe2pRdWVyeSgnIycrb2JqLmlkKS5hbmltYXRlKHtvcGFjaXR5OjEsd2lkdGg6KG9iai5jYW52YXMud2lkdGgqMS4yKSsncHgnLGhlaWdodDoob2JqLmNhbnZhcy5oZWlnaHQqMS4yKSsncHgnLGxlZnQ6KG9iai5jYW52YXMud2lkdGgqIC0wLjEpKydweCcsdG9wOihvYmouY2FudmFzLmhlaWdodCogLTAuMSkrJ3B4J30sZHVyYXRpb24qMC41LGZ1bmN0aW9uKClcbntqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7d2lkdGg6KG9iai5jYW52YXMud2lkdGgqMC45KSsncHgnLGhlaWdodDoob2JqLmNhbnZhcy5oZWlnaHQqMC45KSsncHgnLHRvcDoob2JqLmNhbnZhcy5oZWlnaHQqMC4wNSkrJ3B4JyxsZWZ0OihvYmouY2FudmFzLndpZHRoKjAuMDUpKydweCd9LGR1cmF0aW9uKjAuMjUsZnVuY3Rpb24oKVxue2pRdWVyeSgnIycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDpvYmouY2FudmFzLndpZHRoKydweCcsaGVpZ2h0Om9iai5jYW52YXMuaGVpZ2h0KydweCcsdG9wOjAsbGVmdDowfSxkdXJhdGlvbiowLjI1LGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9KTt9KTt9KTt9ZWxzZXtqUXVlcnkob2JqLmNhbnZhcykuYW5pbWF0ZSh7b3BhY2l0eToxLHdpZHRoOm9iai5jYW52YXMud2lkdGgrJ3B4JyxoZWlnaHQ6b2JqLmNhbnZhcy5oZWlnaHQrJ3B4JyxsZWZ0OjAsdG9wOjB9LGR1cmF0aW9uLGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9KX1cbnJldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24uY29udHJhY3Q9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307aWYoIW9iai5jYW52YXMucmdyYXBoX3dyYXBwZXIpe3ZhciBkaXY9UkcuRWZmZWN0cy53cmFwKG9iai5jYW52YXMpO29iai5jYW52YXMucmdyYXBoX3dyYXBwZXI9ZGl2O31lbHNle2Rpdj1vYmouY2FudmFzLnJncmFwaF93cmFwcGVyO31cbmRpdi5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO29iai5jYW52YXMuc3R5bGUudG9wPTA7b2JqLmNhbnZhcy5zdHlsZS5sZWZ0PTA7aWYob3B0LmJvdW5jZSE9PWZhbHNlKXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7d2lkdGg6KG9iai5jYW52YXMud2lkdGgqMS4yKSsncHgnLGhlaWdodDoob2JqLmNhbnZhcy5oZWlnaHQqMS4yKSsncHgnLGxlZnQ6KG9iai5jYW52YXMud2lkdGgqIC0wLjEpKydweCcsdG9wOihvYmouY2FudmFzLmhlaWdodCogLTAuMSkrJ3B4J30sZHVyYXRpb24qMC4yNSxmdW5jdGlvbigpXG57alF1ZXJ5KCcjJytvYmouaWQpLmFuaW1hdGUoe29wYWNpdHk6MCx3aWR0aDowLGhlaWdodDowLGxlZnQ6KG9iai5jYW52YXMud2lkdGgqMC41KSsncHgnLHRvcDoob2JqLmNhbnZhcy5oZWlnaHQqMC41KSsncHgnfSxkdXJhdGlvbiowLjc1LGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9KTt9KTt9ZWxzZXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7b3BhY2l0eTowLHdpZHRoOjAsaGVpZ2h0OjAsbGVmdDoob2JqLmNhbnZhcy53aWR0aCowLjUpKydweCcsdG9wOihvYmouY2FudmFzLmhlaWdodCowLjUpKydweCd9LGR1cmF0aW9uKjAuNzUsZnVuY3Rpb24oKXtjYWxsYmFjayhvYmopO30pO31cbnJldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24ucmV2ZWFsPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciB4eT1SRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgZGl2cz1bWydyZ3JhcGhfcmV2ZWFsX2xlZnRfJytvYmouaWQseHlbMF0seHlbMV0sb2JqLmNhbnZhcy53aWR0aC8yLG9iai5jYW52YXMuaGVpZ2h0XSxbJ3JncmFwaF9yZXZlYWxfcmlnaHRfJytvYmouaWQsKHh5WzBdKyhvYmouY2FudmFzLndpZHRoLzIpKSx4eVsxXSwob2JqLmNhbnZhcy53aWR0aC8yKSxvYmouY2FudmFzLmhlaWdodF0sWydyZ3JhcGhfcmV2ZWFsX3RvcF8nK29iai5pZCx4eVswXSx4eVsxXSxvYmouY2FudmFzLndpZHRoLChvYmouY2FudmFzLmhlaWdodC8yKV0sWydyZ3JhcGhfcmV2ZWFsX2JvdHRvbV8nK29iai5pZCx4eVswXSwoeHlbMV0rKG9iai5jYW52YXMuaGVpZ2h0LzIpKSxvYmouY2FudmFzLndpZHRoLChvYmouY2FudmFzLmhlaWdodC8yKV1dO2Zvcih2YXIgaT0wLGxlbj1kaXZzLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciBkaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPWRpdnNbaV1bMF07ZGl2LnN0eWxlLndpZHRoPWRpdnNbaV1bM10rJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PWRpdnNbaV1bNF0rJ3B4JztkaXYuc3R5bGUubGVmdD1kaXZzW2ldWzFdKydweCc7ZGl2LnN0eWxlLnRvcD1kaXZzW2ldWzJdKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1vcHQmJnR5cGVvZiBvcHQuY29sb3I9PT0nc3RyaW5nJz9vcHQuY29sb3I6J3doaXRlJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7fVxuUkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2pRdWVyeSgnI3JncmFwaF9yZXZlYWxfbGVmdF8nK29iai5pZCkuYW5pbWF0ZSh7d2lkdGg6MH0sZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9yZXZlYWxfcmlnaHRfJytvYmouaWQpLmFuaW1hdGUoe2xlZnQ6Jys9Jysob2JqLmNhbnZhcy53aWR0aC8yKSx3aWR0aDowfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF90b3BfJytvYmouaWQpLmFuaW1hdGUoe2hlaWdodDowfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9ib3R0b21fJytvYmouaWQpLmFuaW1hdGUoe3RvcDonKz0nKyhvYmouY2FudmFzLmhlaWdodC8yKSxoZWlnaHQ6MH0sZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24oKVxue2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfdG9wX1wiK29iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfYm90dG9tX1wiK29iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfbGVmdF9cIitvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX3JpZ2h0X1wiK29iai5pZCkpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi5yZXZlYWxDaXJjdWxhcj1SRy5FZmZlY3RzLkNvbW1vbi5yZXZlYWxjaXJjdWxhcj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgY3VycmVudFJhZGl1cz0wXG52YXIgY2VudGVyeD1vYmouY2FudmFzLndpZHRoLzI7dmFyIGNlbnRlcnk9b2JqLmNhbnZhcy5oZWlnaHQvMjt2YXIgdGFyZ2V0UmFkaXVzPW1hLm1heChvYmouY2FudmFzLmhlaWdodCxvYmouY2FudmFzLndpZHRoKTt2YXIgc3RlcD10YXJnZXRSYWRpdXMvZnJhbWVzO3ZhciBjb2xvcj1vcHQuYmFja2dyb3VuZHx8b3B0LmNvbG9yfHxvcHQuYmFja2dyb3VuZENvbG9yfHwndHJhbnNwYXJlbnQnO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntSRy5jbGVhcihvYmouY2FudmFzLGNvbG9yKTtvYmouY29udGV4dC5zYXZlKCk7b2JqLmNvbnRleHQuYmVnaW5QYXRoKCk7b2JqLmNvbnRleHQuYXJjKGNlbnRlcngsY2VudGVyeSxjdXJyZW50UmFkaXVzLDAsUkcuVFdPUEksZmFsc2UpO29iai5jb250ZXh0LmNsaXAoKTtpZihvcHQuYmFja2dyb3VuZCl7UkcuY2xlYXIob2JqLmNhbnZhcyxvcHQuYmFja2dyb3VuZCk7fVxub2JqLmRyYXcoKTtvYmouY29udGV4dC5yZXN0b3JlKCk7aWYoY3VycmVudFJhZGl1czx0YXJnZXRSYWRpdXMpe2N1cnJlbnRSYWRpdXMrPXN0ZXA7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi5jb25jZWFsPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciB4eT1SRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3I9b3B0LmJhY2tncm91bmR8fG9wdC5jb2xvcnx8b3B0LmJhY2tncm91bmRDb2xvcnx8J3doaXRlJzt2YXIgZGl2cz1bWydyZ3JhcGhfY29uY2VhbF9sZWZ0Xycrb2JqLmlkLHh5WzBdLHh5WzFdLDAsb2JqLmNhbnZhcy5oZWlnaHRdLFsncmdyYXBoX2NvbmNlYWxfcmlnaHRfJytvYmouaWQsKHh5WzBdK29iai5jYW52YXMud2lkdGgpLHh5WzFdLDAsb2JqLmNhbnZhcy5oZWlnaHRdLFsncmdyYXBoX2NvbmNlYWxfdG9wXycrb2JqLmlkLHh5WzBdLHh5WzFdLG9iai5jYW52YXMud2lkdGgsMF0sWydyZ3JhcGhfY29uY2VhbF9ib3R0b21fJytvYmouaWQseHlbMF0sKHh5WzFdK29iai5jYW52YXMuaGVpZ2h0KSxvYmouY2FudmFzLndpZHRoLDBdXTtmb3IodmFyIGk9MCxsZW49ZGl2cy5sZW5ndGg7aTxsZW47KytpKXt2YXIgZGl2PWRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQ9ZGl2c1tpXVswXTtkaXYuc3R5bGUud2lkdGg9ZGl2c1tpXVszXSsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9ZGl2c1tpXVs0XSsncHgnO2Rpdi5zdHlsZS5sZWZ0PWRpdnNbaV1bMV0rJ3B4JztkaXYuc3R5bGUudG9wPWRpdnNbaV1bMl0rJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO2RvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7fVxualF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfbGVmdF8nK29iai5pZCkuYW5pbWF0ZSh7d2lkdGg6Jys9Jysob2JqLmNhbnZhcy53aWR0aC8yKX0sZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9jb25jZWFsX3JpZ2h0Xycrb2JqLmlkKS5hbmltYXRlKHtsZWZ0OictPScrKG9iai5jYW52YXMud2lkdGgvMiksd2lkdGg6KG9iai5jYW52YXMud2lkdGgvMil9LGR1cmF0aW9uKTtqUXVlcnkoJyNyZ3JhcGhfY29uY2VhbF90b3BfJytvYmouaWQpLmFuaW1hdGUoe2hlaWdodDonKz0nKyhvYmouY2FudmFzLmhlaWdodC8yKX0sZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9jb25jZWFsX2JvdHRvbV8nK29iai5pZCkuYW5pbWF0ZSh7dG9wOictPScrKG9iai5jYW52YXMuaGVpZ2h0LzIpLGhlaWdodDoob2JqLmNhbnZhcy5oZWlnaHQvMil9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF90b3BfXCIrb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2NvbmNlYWxfYm90dG9tX1wiK29iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9jb25jZWFsX2xlZnRfXCIrb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2NvbmNlYWxfcmlnaHRfXCIrb2JqLmlkKSk7UkcuY2xlYXIob2JqLmNhbnZhcyk7Y2FsbGJhY2sob2JqKTt9LGR1cmF0aW9uKTtyZXR1cm4gdGhpczt9O1JHLkVmZmVjdHMuQ29tbW9uLmhCbGluZHNPcGVuPVJHLkVmZmVjdHMuQ29tbW9uLmhibGluZHNPcGVuPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBjb2xvcj1vcHQuYmFja2dyb3VuZHx8b3B0LmNvbG9yfHxvcHQuYmFja2dyb3VuZENvbG9yfHwnd2hpdGUnO3ZhciB4eT1SRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIGhlaWdodD10aGlzLmNhbnZhcy5oZWlnaHQvNTtSRy5jbGVhcih0aGlzLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKHRoaXMuY2FudmFzKTtmb3IodmFyIGk9MDtpPDU7KytpKXt2YXIgZGl2PWRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQ9J3JncmFwaF9oYmxpbmRzXycraSsnXycrb2JqLmlkO2Rpdi5zdHlsZS53aWR0aD10aGlzLmNhbnZhcy53aWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9aGVpZ2h0KydweCc7ZGl2LnN0eWxlLmxlZnQ9eHlbMF0rJ3B4JztkaXYuc3R5bGUudG9wPSh4eVsxXSsodGhpcy5jYW52YXMuaGVpZ2h0KihpLzUpKSkrJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtqUXVlcnkoJyNyZ3JhcGhfaGJsaW5kc18nK2krJ18nK29iai5pZCkuYW5pbWF0ZSh7aGVpZ2h0OjB9LGR1cmF0aW9uKTt9XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18wXycrb2JqLmlkKSk7fSxkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMV8nK29iai5pZCkpO30sZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzJfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18zXycrb2JqLmlkKSk7fSxkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfNF8nK29iai5pZCkpO30sZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjayhvYmopO30sZHVyYXRpb24pO3JldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24uaEJsaW5kc0Nsb3NlPVJHLkVmZmVjdHMuQ29tbW9uLmhibGluZHNjbG9zZT1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDYwO3ZhciBkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgY29sb3I9b3B0LmJhY2tncm91bmR8fG9wdC5jb2xvcnx8b3B0LmJhY2tncm91bmRDb2xvcnx8J3doaXRlJzt2YXIgeHk9UkcuZ2V0Q2FudmFzWFkodGhpcy5jYW52YXMpO3ZhciBoZWlnaHQ9dGhpcy5jYW52YXMuaGVpZ2h0LzU7Zm9yKHZhciBpPTA7aTw1OysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfaGJsaW5kc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUud2lkdGg9dGhpcy5jYW52YXMud2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PTA7ZGl2LnN0eWxlLmxlZnQ9eHlbMF0rJ3B4JztkaXYuc3R5bGUudG9wPSh4eVsxXSsodGhpcy5jYW52YXMuaGVpZ2h0KihpLzUpKSkrJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO2RvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX2hibGluZHNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe2hlaWdodDpoZWlnaHQrJ3B4J30sZHVyYXRpb24pO31cbnNldFRpbWVvdXQoZnVuY3Rpb24oKXtSRy5jbGVhcihvYmouY2FudmFzKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18xXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzJfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfM18nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc180Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjayhvYmopO30sZHVyYXRpb24rMTAwKTt9O1JHLkVmZmVjdHMuQ29tbW9uLnZCbGluZHNPcGVuPVJHLkVmZmVjdHMuQ29tbW9uLnZibGluZHNvcGVuPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBjb2xvcj1vcHQuYmFja2dyb3VuZHx8b3B0LmNvbG9yfHxvcHQuYmFja2dyb3VuZENvbG9yfHwnd2hpdGUnO3ZhciB4eT1SRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIHdpZHRoPXRoaXMuY2FudmFzLndpZHRoLzEwO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtmb3IodmFyIGk9MDtpPDEwOysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdmJsaW5kc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUud2lkdGg9d2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PXRoaXMuY2FudmFzLmhlaWdodCsncHgnO2Rpdi5zdHlsZS5sZWZ0PSh4eVswXSsodGhpcy5jYW52YXMud2lkdGgqKGkvMTApKSkrJ3B4JztkaXYuc3R5bGUudG9wPSh4eVsxXSkrJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO2RvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX3ZibGluZHNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe3dpZHRoOjB9LGR1cmF0aW9uKTt9XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18wXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzFfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMl8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18zXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzRfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNV8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc182Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzdfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc185Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjayhvYmopO30sZHVyYXRpb24rMTAwKTtyZXR1cm4gdGhpczt9O1JHLkVmZmVjdHMuQ29tbW9uLnZibGluZHNjbG9zZT1SRy5FZmZlY3RzLkNvbW1vbi52QmxpbmRzQ2xvc2U9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIGNvbG9yPW9wdC5iYWNrZ3JvdW5kfHxvcHQuY29sb3J8fG9wdC5iYWNrZ3JvdW5kQ29sb3J8fCd3aGl0ZSc7dmFyIHh5PVJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGg9dGhpcy5jYW52YXMud2lkdGgvMTA7Zm9yKHZhciBpPTA7aTwxMDsrK2kpe3ZhciBkaXY9ZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZD0ncmdyYXBoX3ZibGluZHNfJytpKydfJytvYmouaWQ7ZGl2LnN0eWxlLndpZHRoPTA7ZGl2LnN0eWxlLmhlaWdodD10aGlzLmNhbnZhcy5oZWlnaHQrJ3B4JztkaXYuc3R5bGUubGVmdD0oeHlbMF0rKHRoaXMuY2FudmFzLndpZHRoKihpLzEwKSkpKydweCc7ZGl2LnN0eWxlLnRvcD0oeHlbMV0pKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1jb2xvcjtkb2MuYm9keS5hcHBlbmRDaGlsZChkaXYpO2pRdWVyeSgnI3JncmFwaF92YmxpbmRzXycraSsnXycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDp3aWR0aH0sZHVyYXRpb24pO31cbnNldFRpbWVvdXQoZnVuY3Rpb24oKXtSRy5jbGVhcihvYmouY2FudmFzKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzJfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfM18nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzVfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNl8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzhfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOV8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9LGR1cmF0aW9uKzEwMCk7cmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi5zbGlkZUluPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBjb2xvcj1vcHQuYmFja2dyb3VuZHx8b3B0LmNvbG9yfHxvcHQuYmFja2dyb3VuZENvbG9yfHwnd2hpdGUnO3ZhciB4eT1SRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIHdpZHRoPXRoaXMuY2FudmFzLndpZHRoLzEwO3ZhciBkaXY9UkcuRWZmZWN0cy53cmFwKG9iai5jYW52YXMpO3ZhciBmcm9tPW9wdC5mcm9tfHwnbGVmdCc7ZGl2LnN0eWxlLm92ZXJmbG93PSdoaWRkZW4nO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtjYW52YXMuc3R5bGUucG9zaXRpb249J3JlbGF0aXZlJztpZihmcm9tPT0nbGVmdCcpe29iai5jYW52YXMuc3R5bGUubGVmdD0oMC1kaXYub2Zmc2V0V2lkdGgpKydweCc7b2JqLmNhbnZhcy5zdHlsZS50b3A9MDt9ZWxzZSBpZihmcm9tPT0ndG9wJyl7b2JqLmNhbnZhcy5zdHlsZS5sZWZ0PTA7b2JqLmNhbnZhcy5zdHlsZS50b3A9KDAtZGl2Lm9mZnNldEhlaWdodCkrJ3B4Jzt9ZWxzZSBpZihmcm9tPT0nYm90dG9tJyl7b2JqLmNhbnZhcy5zdHlsZS5sZWZ0PTA7b2JqLmNhbnZhcy5zdHlsZS50b3A9ZGl2Lm9mZnNldEhlaWdodCsncHgnO31lbHNle29iai5jYW52YXMuc3R5bGUubGVmdD1kaXYub2Zmc2V0V2lkdGgrJ3B4JztvYmouY2FudmFzLnN0eWxlLnRvcD0wO31cbmpRdWVyeSgnIycrb2JqLmlkKS5hbmltYXRlKHtsZWZ0OjAsdG9wOjB9LGR1cmF0aW9uLGZ1bmN0aW9uKClcbntjYWxsYmFjayhvYmopO30pO3JldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24uc2xpZGVPdXQ9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIGNvbG9yPW9wdC5iYWNrZ3JvdW5kfHxvcHQuY29sb3J8fG9wdC5iYWNrZ3JvdW5kQ29sb3J8fCd3aGl0ZSc7dmFyIHh5PVJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGg9dGhpcy5jYW52YXMud2lkdGgvMTA7dmFyIGRpdj1SRy5FZmZlY3RzLndyYXAob2JqLmNhbnZhcyk7dmFyIHRvPW9wdC50b3x8J2xlZnQnO2Rpdi5zdHlsZS5vdmVyZmxvdz0naGlkZGVuJztvYmouY2FudmFzLnN0eWxlLnBvc2l0aW9uPSdyZWxhdGl2ZSc7b2JqLmNhbnZhcy5zdHlsZS5sZWZ0PTA7b2JqLmNhbnZhcy5zdHlsZS50b3A9MDtpZih0bz09J2xlZnQnKXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7bGVmdDooMC1vYmouY2FudmFzLndpZHRoKSsncHgnfSxkdXJhdGlvbixmdW5jdGlvbigpe2NhbGxiYWNrKG9iaik7fSk7fWVsc2UgaWYodG89PSd0b3AnKXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7bGVmdDowLHRvcDooMC1kaXYub2Zmc2V0SGVpZ2h0KSsncHgnfSxkdXJhdGlvbixmdW5jdGlvbigpe2NhbGxiYWNrKG9iaik7fSk7fWVsc2UgaWYodG89PSdib3R0b20nKXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7dG9wOigwK2Rpdi5vZmZzZXRIZWlnaHQpKydweCd9LGR1cmF0aW9uLGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9KTt9ZWxzZXtqUXVlcnkoJyMnK29iai5pZCkuYW5pbWF0ZSh7bGVmdDooMCtvYmouY2FudmFzLndpZHRoKSsncHgnfSxkdXJhdGlvbixmdW5jdGlvbigpe2NhbGxiYWNrKG9iaik7fSk7fVxucmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi5oc2Npc3NvcnNvcGVuPVJHLkVmZmVjdHMuQ29tbW9uLmhTY2lzc29yc09wZW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIGNvbG9yPW9wdC5iYWNrZ3JvdW5kfHxvcHQuY29sb3J8fG9wdC5iYWNrZ3JvdW5kQ29sb3J8fCd3aGl0ZSc7dmFyIHh5PVJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGg9dGhpcy5jYW52YXMud2lkdGgvMTA7dmFyIHRvPW9wdC50b3x8J2xlZnQnO3ZhciBoZWlnaHQ9b2JqLmNhbnZhcy5oZWlnaHQvNTtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Zm9yKHZhciBpPTA7aTw1OysraSl7dmFyIGRpdj1kb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfaHNjaXNzb3JzX1wiK2krJ18nK29iai5pZClcbmlmKCFkaXYpe3ZhciBkaXY9ZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZD0ncmdyYXBoX2hzY2lzc29yc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUud2lkdGg9b2JqLmNhbnZhcy53aWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9aGVpZ2h0KydweCc7ZGl2LnN0eWxlLmxlZnQ9eHlbMF0rJ3B4JztkaXYuc3R5bGUudG9wPSh4eVsxXSsob2JqLmNhbnZhcy5oZWlnaHQqKGkvNSkpKSsncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTt9XG5pZihpJTI9PTApe2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe2xlZnQ6eHlbMF0rb2JqLmNhbnZhcy53aWR0aCsncHgnLHdpZHRoOjB9LGR1cmF0aW9uKTt9ZWxzZXtqUXVlcnkoJyMnKydyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDowfSxkdXJhdGlvbik7fX1cbnNldFRpbWVvdXQoZnVuY3Rpb24oKVxue2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18wXycrb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaHNjaXNzb3JzXzFfJytvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oc2Npc3NvcnNfMl8nK29iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18zXycrb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaHNjaXNzb3JzXzRfJytvYmouaWQpKTtjYWxsYmFjayhvYmopO30sZHVyYXRpb24pO3JldHVybiB0aGlzO307UkcuRWZmZWN0cy5Db21tb24uaFNjaXNzb3JzQ2xvc2U9UkcuRWZmZWN0cy5Db21tb24uaHNjaXNzb3JzY2xvc2U9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIGNvbG9yPW9wdC5iYWNrZ3JvdW5kfHxvcHQuY29sb3J8fG9wdC5iYWNrZ3JvdW5kQ29sb3J8fCd3aGl0ZSc7dmFyIHh5PVJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgaGVpZ2h0PW9iai5jYW52YXMuaGVpZ2h0LzU7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2Zvcih2YXIgaT0wO2k8NTsrK2kpe3ZhciBkaXY9ZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZD0ncmdyYXBoX2hzY2lzc29yc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUud2lkdGg9MDtkaXYuc3R5bGUuaGVpZ2h0PWhlaWdodCsncHgnO2Rpdi5zdHlsZS5sZWZ0PShpJTI9PTA/eHlbMF0rb2JqLmNhbnZhcy53aWR0aDp4eVswXSkrJ3B4JztkaXYuc3R5bGUudG9wPSh4eVsxXSsob2JqLmNhbnZhcy5oZWlnaHQqKGkvNSkpKSsncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtpZihpJTI9PTApe2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe2xlZnQ6eHlbMF0rJ3B4Jyx3aWR0aDpvYmouY2FudmFzLndpZHRoKydweCd9LGR1cmF0aW9uKTt9ZWxzZXtqUXVlcnkoJyMnKydyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDpvYmouY2FudmFzLndpZHRoKydweCd9LGR1cmF0aW9uKTt9fVxuc2V0VGltZW91dChmdW5jdGlvbigpXG57UkdyYXBoLmNsZWFyKG9iai5jYW52YXMpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJyswKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJysxKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJysyKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJyszKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJys0KydfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi52U2Npc3NvcnNPcGVuPVJHLkVmZmVjdHMuQ29tbW9uLnZzY2lzc29yc29wZW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHw2MDt2YXIgZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMDt2YXIgZnJhbWU9MDt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIHh5PVJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3ZhciBjb2xvcj1vcHQuYmFja2dyb3VuZHx8b3B0LmNvbG9yfHxvcHQuYmFja2dyb3VuZENvbG9yfHwnd2hpdGUnO3ZhciB4eT1SRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIHdpZHRoPXRoaXMuY2FudmFzLndpZHRoLzEwO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtmb3IodmFyIGk9MDtpPDEwOysraSl7dmFyIGRpdj1kb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfdnNjaXNzb3JzX1wiK2krJ18nK29iai5pZCk7aWYoIWRpdil7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrb2JqLmlkO2Rpdi5zdHlsZS53aWR0aD13aWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9b2JqLmNhbnZhcy5oZWlnaHQrJ3B4JztkaXYuc3R5bGUubGVmdD14eVswXSsob2JqLmNhbnZhcy53aWR0aCooaS8xMCkpKydweCc7ZGl2LnN0eWxlLnRvcD14eVsxXSsncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTt9XG5pZihpJTI9PTApe2pRdWVyeSgnIycrJ3JncmFwaF92c2Npc3NvcnNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe3RvcDp4eVsxXStvYmouY2FudmFzLmhlaWdodCsncHgnLGhlaWdodDowfSxkdXJhdGlvbik7fWVsc2V7alF1ZXJ5KCcjJysncmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK29iai5pZCkuYW5pbWF0ZSh7aGVpZ2h0OjB9LGR1cmF0aW9uKTt9fVxuc2V0VGltZW91dChmdW5jdGlvbigpXG57ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzAnKydfJytvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92c2Npc3NvcnNfMScrJ18nK29iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18yJysnXycrb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzMnKydfJytvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92c2Npc3NvcnNfNCcrJ18nK29iai5pZCkpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5FZmZlY3RzLkNvbW1vbi52c2Npc3NvcnNjbG9zZT1SRy5FZmZlY3RzLkNvbW1vbi52U2Npc3NvcnNDbG9zZT1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDYwO3ZhciBkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgeHk9UkcuZ2V0Q2FudmFzWFkob2JqLmNhbnZhcyk7dmFyIGNvbG9yPW9wdC5iYWNrZ3JvdW5kfHxvcHQuY29sb3J8fG9wdC5iYWNrZ3JvdW5kQ29sb3J8fCd3aGl0ZSc7dmFyIHh5PVJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGg9dGhpcy5jYW52YXMud2lkdGgvMTA7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2Zvcih2YXIgaT0wO2k8MTA7KytpKXt2YXIgZGl2PWRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF92c2Npc3NvcnNfXCIraSsnXycrb2JqLmlkKVxuaWYoIWRpdil7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrb2JqLmlkO2Rpdi5zdHlsZS53aWR0aD13aWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9MDtkaXYuc3R5bGUubGVmdD14eVswXSsod2lkdGgqaSkrJ3B4JztkaXYuc3R5bGUudG9wPShpJTI9PTA/eHlbMV0rb2JqLmNhbnZhcy5oZWlnaHQ6eHlbMV0pKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1jb2xvcjtkb2MuYm9keS5hcHBlbmRDaGlsZChkaXYpO31cbmlmKGklMj09MCl7alF1ZXJ5KCcjJysncmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK29iai5pZCkuYW5pbWF0ZSh7dG9wOnh5WzFdKydweCcsaGVpZ2h0Om9iai5jYW52YXMuaGVpZ2h0KydweCd9LGR1cmF0aW9uKTt9ZWxzZXtqUXVlcnkoJyMnKydyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrb2JqLmlkKS5hbmltYXRlKHtoZWlnaHQ6b2JqLmNhbnZhcy5oZWlnaHQrJ3B4J30sZHVyYXRpb24pO319XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntSRy5jbGVhcihvYmouY2FudmFzKTtmb3IodmFyIGk9MDtpPDEwO2krKyl7alF1ZXJ5KCcjcmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK29iai5pZCkucmVtb3ZlKCk7fVxuY2FsbGJhY2sob2JqKTt9LGR1cmF0aW9uKTtyZXR1cm4gdGhpczt9O1JHLkVmZmVjdHMuQ29tbW9uLmFuaW1hdGU9ZnVuY3Rpb24obWFwKVxue3ZhciBvYmo9dGhpcztvYmouZHJhdygpO3ZhciB0b3RhbEZyYW1lcz0obWFwJiZtYXBbJ2ZyYW1lcyddKT9tYXBbJ2ZyYW1lcyddOjMwO3ZhciBjdXJyZW50RnJhbWU9bmV3IEFycmF5KCk7dmFyIG9yaWdpbmFsVmFsdWVzPW5ldyBBcnJheSgpO3ZhciBkaWZmcz1uZXcgQXJyYXkoKTt2YXIgc3RlcHM9bmV3IEFycmF5KCk7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXVxuZnVuY3Rpb24gaXRlcmF0b3IoKVxue3ZhciBpZD1bb2JqLmlkKydfJytvYmoudHlwZV07aWYoIWN1cnJlbnRGcmFtZVtpZF0pe2N1cnJlbnRGcmFtZVtpZF09dG90YWxGcmFtZXM7b3JpZ2luYWxWYWx1ZXNbaWRdPXt9O2RpZmZzW2lkXT17fTtzdGVwc1tpZF09e307fVxuZm9yKHZhciBpIGluIG1hcCl7aWYodHlwZW9mIG1hcFtpXT09PSdzdHJpbmcnfHx0eXBlb2YgbWFwW2ldPT09J251bWJlcicpe2lmKGN1cnJlbnRGcmFtZVtpZF09PXRvdGFsRnJhbWVzKXtvcmlnaW5hbFZhbHVlc1tpZF1baV09b2JqLmdldChpKTtkaWZmc1tpZF1baV09bWFwW2ldLW9yaWdpbmFsVmFsdWVzW2lkXVtpXTtzdGVwc1tpZF1baV09ZGlmZnNbaWRdW2ldL3RvdGFsRnJhbWVzO31cbm9iai5zZXQoaSxvYmouZ2V0KGkpK3N0ZXBzW2lkXVtpXSk7UkcuY2xlYXIob2JqLmNhbnZhcyk7b2JqLmRyYXcoKTt9fVxuaWYoLS1jdXJyZW50RnJhbWVbaWRdPjApe1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtpZih0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKXtjYWxsYmFjayhvYmopO319fVxuaXRlcmF0b3IoKTt9fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZWZmZWN0cy5qcyJdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///200\n");

/***/ }),
/* 201 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HTML = RGraph.HTML || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.drawKey = RG.DrawKey = function (obj, key, colors) {\n    if (!key) {\n      return;\n    }\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        keypos = prop['chart.key.position'],\n        textsize = prop['chart.text.size'],\n        key_non_null = [],\n        colors_non_null = [];co.lineWidth = 1;co.beginPath();if (typeof prop['chart.key.vpos'] == 'number') {\n      obj.Set('chart.key.position.y', prop['chart.key.vpos'] * prop['chart.gutter.top']);\n    }\n    for (var i = 0; i < key.length; ++i) {\n      if (key[i] != null) {\n        colors_non_null.push(colors[i]);key_non_null.push(key[i]);\n      }\n    }\n    key = key_non_null;colors = colors_non_null;function DrawKey_graph(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'];var text_italic = prop['chart.key.text.italic'] ? true : false;\n      var text_bold = prop['chart.key.text.bold'] ? true : false;\n      var text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'];var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var hpos = prop['chart.yaxispos'] == 'right' ? gutterLeft + 10 : ca.width - gutterRight - 10;var vpos = gutterTop + 10;var title = prop['chart.title'];var blob_size = text_size;var hmargin = 8;var vmargin = 4;var fillstyle = prop['chart.key.background'];var text_color = prop['chart.key.text.color'];var strokestyle = '#333';var height = 0;var width = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = text_size + 'pt ' + prop['chart.text.font'];for (i = 0; i < key.length; ++i) {\n        width = Math.max(width, co.measureText(key[i]).width);\n      }\n      width += 5;width += blob_size;width += 5;width += 5;width += 5;if (prop['chart.yaxispos'] == 'left' || obj.type === 'pie' && !prop['chart.yaxispos'] || obj.type === 'hbar' && !prop['chart.yaxispos'] || obj.type === 'hbar' && prop['chart.yaxispos'] === 'center' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' || obj.type === 'rscatter' && !prop['chart.yaxispos'] || obj.type === 'radar' && !prop['chart.yaxispos'] || obj.type === 'rose' && !prop['chart.yaxispos'] || obj.type === 'funnel' && !prop['chart.yaxispos'] || obj.type === 'vprogress' && !prop['chart.yaxispos'] || obj.type === 'hprogress' && !prop['chart.yaxispos']) {\n        hpos -= width;\n      }\n      if (typeof prop['chart.key.halign'] == 'string') {\n        if (prop['chart.key.halign'] == 'left') {\n          hpos = gutterLeft + 10;\n        } else if (prop['chart.key.halign'] == 'right') {\n          hpos = ca.width - gutterRight - width;\n        }\n      }\n      if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (prop['chart.key.shadow']) {\n        co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n      }\n      co.beginPath();co.fillStyle = prop['chart.key.background'];co.strokeStyle = 'black';if (typeof prop['chart.key.position.graph.boxed'] == 'undefined' || typeof prop['chart.key.position.graph.boxed'] == 'boolean' && prop['chart.key.position.graph.boxed']) {\n        if (arguments[3] != false) {\n          co.lineWidth = typeof prop['chart.key.linewidth'] == 'number' ? prop['chart.key.linewidth'] : 1;if (prop['chart.key.rounded'] == true) {\n            co.beginPath();co.strokeStyle = strokestyle;RG.strokedCurvyRect(co, Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key), 4);co.stroke();co.fill();RG.NoShadow(obj);\n          } else {\n            co.strokeRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));co.fillRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));\n          }\n        }\n      }\n      RG.NoShadow(obj);co.beginPath();if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = key.length - 1; i >= 0; i--) {\n        var j = Number(i) + 1;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.arc(hpos + 5 + blob_size / 2, vpos + 5 * j + text_size * j - text_size + blob_size / 2, blob_size / 2, 0, 6.26, 0);co.fill();\n        } else if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'triangle') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.lineTo(hpos + blob_size / 2 + 5, vpos + 5 * j + text_size * j - text_size);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.closePath();co.fillStyle = colors[i];co.fill();\n        } else {\n          co.fillStyle = colors[i];co.fillRect(hpos + 5, vpos + 5 * j + text_size * j - text_size, text_size, text_size + 1);\n        }\n        co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) == 'object' ? text_color[i] : text_color;ret = RG.Text2(obj, { 'font': text_font, 'size': text_size, 'bold': text_bold, 'italic': text_italic, 'x': hpos + blob_size + 5 + 5, 'y': vpos + 5 * j + text_size * j + 3, 'text': key[i], 'accessible': !obj.properties['chart.key.interactive'] });obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n      co.fill();\n    }\n    function DrawKey_gutter(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'],\n          text_bold = prop['chart.key.text.bold'],\n          text_italic = prop['chart.key.text.italic'],\n          text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'],\n          text_color = prop['chart.key.text.color'],\n          gutterLeft = obj.gutterLeft,\n          gutterRight = obj.gutterRight,\n          gutterTop = obj.gutterTop,\n          gutterBottom = obj.gutterBottom,\n          hpos = (ca.width - gutterLeft - gutterRight) / 2 + obj.gutterLeft,\n          vpos = gutterTop - text_size - 5,\n          title = prop['chart.title'],\n          blob_size = text_size,\n          hmargin = 8,\n          vmargin = 4,\n          fillstyle = prop['chart.key.background'],\n          strokestyle = '#999',\n          length = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = (obj.properties['chart.key.text.italic'] ? 'italic ' : '') + (obj.properties['chart.key.text.bold'] ? 'bold ' : '') + text_size + 'pt ' + text_font;for (i = 0; i < key.length; ++i) {\n        length += hmargin;length += blob_size;length += hmargin;length += co.measureText(key[i]).width;\n      }\n      length += hmargin;if (obj.type == 'pie') {\n        if (prop['chart.align'] == 'left') {\n          var hpos = obj.radius + gutterLeft;\n        } else if (prop['chart.align'] == 'right') {\n          var hpos = ca.width - obj.radius - gutterRight;\n        } else {\n          hpos = ca.width / 2;\n        }\n      }\n      hpos -= length / 2;if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (obj.Get('chart.key.position.gutter.boxed')) {\n        if (prop['chart.key.shadow']) {\n          co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n        }\n        co.beginPath();co.fillStyle = fillstyle;co.strokeStyle = strokestyle;if (prop['chart.key.rounded']) {\n          RG.strokedCurvyRect(co, hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        } else {\n          co.rect(hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        }\n        co.stroke();co.fill();RG.NoShadow(obj);\n      }\n      if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = 0, pos = hpos; i < key.length; ++i) {\n        pos += hmargin;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.lineTo(pos + blob_size, vpos + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.arc(pos + blob_size / 2, vpos + blob_size / 2, blob_size / 2, 0, 6.28, 0);co.fill();\n        } else if (blob_shape == 'triangle') {\n          co.fillStyle = colors[i];co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size);co.lineTo(pos + blob_size / 2, vpos);co.lineTo(pos + blob_size, vpos + blob_size);co.closePath();co.fill();\n        } else {\n          co.beginPath();co.fillStyle = colors[i];co.rect(pos, vpos, blob_size, blob_size);co.fill();\n        }\n        pos += blob_size;pos += hmargin;co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) === 'object' ? text_color[i] : text_color;var ret = RG.Text2(obj, { 'font': text_font, 'bold': text_bold, 'size': text_size, 'italic': text_italic, 'x': pos, 'y': vpos + text_size + 3, 'text': key[i], accessible: !obj.properties['chart.key.interactive'] });co.fill();pos += co.measureText(key[i]).width;obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n    }\n    if (keypos && keypos == 'gutter') {\n      DrawKey_gutter(obj, key, colors);\n    } else if (keypos && keypos == 'graph') {\n      DrawKey_graph(obj, key, colors);\n    } else {\n      alert('[COMMON] (' + obj.id + ') Unknown key position: ' + keypos);\n    }\n    if (prop['chart.key.interactive']) {\n      if (!RGraph.Drawing || !RGraph.Drawing.Rect) {\n        alert('[INTERACTIVE KEY] The drawing API Rect library does not appear to have been included (which the interactive key uses)');\n      }\n      if (!RGraph.InstallWindowMousedownListener) {\n        alert('[INTERACTIVE KEY] The dynamic library does not appear to have been included');\n      }\n      for (var i = 0, len = obj.coords.key.length, maxlen = 0; i < len; i += 1) {\n        maxlen = Math.max(maxlen, obj.coords.key[i][2]);\n      }\n      for (var i = 0, len = obj.coords.key.length; i < len; i += 1) {\n        (function (idx) {\n          var arr = obj.coords.key;var value = obj.coords.key[idx];var index = idx;var rect = new RGraph.Drawing.Rect(obj.id, value[0], value[1], prop['chart.key.position'] == 'gutter' ? value[2] : maxlen, value[3]).Set('fillstyle', 'rgba(0,0,0,0)').Draw();rect.onclick = function (e, shape) {\n            var co = rect.context;co.fillStyle = prop['chart.key.interactive.highlight.label'];co.fillRect(shape.x, shape.y, shape.width, shape.height);if (typeof obj.interactiveKeyHighlight == 'function') {\n              obj.Set('chart.key.interactive.index', idx);RG.FireCustomEvent(obj, 'onbeforeinteractivekey');obj.interactiveKeyHighlight(index);RG.FireCustomEvent(obj, 'onafterinteractivekey');\n            }\n          };\n          rect.onmousemove = function (e, shape) {\n            return true;\n          };\n        })(i);\n      }\n    }\n  };RG.getKeyLength = function (key) {\n    var length = 0;for (var i = 0, len = key.length; i < len; i += 1) {\n      if (key[i] != null) {\n        ++length;\n      }\n    }\n    return length;\n  };RGraph.HTML.key = RGraph.HTML.Key = function (id, prop) {\n    var div = doc.getElementById(id);var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n      var style = '';\n      for (i in prop.tableCss) {\n        if (typeof i === 'string') {\n          style = style + i + ': ' + prop.tableCss[i] + ';';\n        }\n      }\n      return style;\n    }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';for (var i = 0; i < prop.labels.length; i += 1) {\n      str += '<tr><td><div style=\"' + function () {\n        var style = '';for (var j in prop.blobCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.blobCss[j] + ';';\n          }\n        }\n        return style;\n      }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n        var style = '';for (var j in prop.labelCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.labelCss[j] + ';';\n          }\n        }\n        return style;\n      }() + '\" ' + function () {\n        var style = '';if (prop['labelCss_' + i]) {\n          for (var j in prop['labelCss_' + i]) {\n            style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n          }\n        }\n        return style ? 'style=\"' + style + '\"' : '';\n      }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n    }\n    div.innerHTML += str + '</table>';return doc.getElementById('rgraph_key');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmtleS5qcz8xNzM2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguSFRNTD1SR3JhcGguSFRNTHx8e307KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLmRyYXdLZXk9UkcuRHJhd0tleT1mdW5jdGlvbihvYmosa2V5LGNvbG9ycylcbntpZigha2V5KXtyZXR1cm47fVxudmFyIGNhPW9iai5jYW52YXMsY289b2JqLmNvbnRleHQscHJvcD1vYmoucHJvcGVydGllcyxrZXlwb3M9cHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uJ10sdGV4dHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sa2V5X25vbl9udWxsPVtdLGNvbG9yc19ub25fbnVsbD1bXTtjby5saW5lV2lkdGg9MTtjby5iZWdpblBhdGgoKTtpZih0eXBlb2YocHJvcFsnY2hhcnQua2V5LnZwb3MnXSk9PSdudW1iZXInKXtvYmouU2V0KCdjaGFydC5rZXkucG9zaXRpb24ueScscHJvcFsnY2hhcnQua2V5LnZwb3MnXSpwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pO31cbmZvcih2YXIgaT0wO2k8a2V5Lmxlbmd0aDsrK2kpe2lmKGtleVtpXSE9bnVsbCl7Y29sb3JzX25vbl9udWxsLnB1c2goY29sb3JzW2ldKTtrZXlfbm9uX251bGwucHVzaChrZXlbaV0pO319XG5rZXk9a2V5X25vbl9udWxsO2NvbG9ycz1jb2xvcnNfbm9uX251bGw7ZnVuY3Rpb24gRHJhd0tleV9ncmFwaChvYmosa2V5LGNvbG9ycylcbnt2YXIgdGV4dF9zaXplPXR5cGVvZihwcm9wWydjaGFydC5rZXkudGV4dC5zaXplJ10pPT0nbnVtYmVyJz9wcm9wWydjaGFydC5rZXkudGV4dC5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIHRleHRfaXRhbGljPXByb3BbJ2NoYXJ0LmtleS50ZXh0Lml0YWxpYyddP3RydWU6ZmFsc2VcbnZhciB0ZXh0X2JvbGQ9cHJvcFsnY2hhcnQua2V5LnRleHQuYm9sZCddP3RydWU6ZmFsc2VcbnZhciB0ZXh0X2ZvbnQ9cHJvcFsnY2hhcnQua2V5LnRleHQuZm9udCddfHxwcm9wWydjaGFydC5rZXkuZm9udCddfHxwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgZ3V0dGVyTGVmdD1vYmouZ3V0dGVyTGVmdDt2YXIgZ3V0dGVyUmlnaHQ9b2JqLmd1dHRlclJpZ2h0O3ZhciBndXR0ZXJUb3A9b2JqLmd1dHRlclRvcDt2YXIgZ3V0dGVyQm90dG9tPW9iai5ndXR0ZXJCb3R0b207dmFyIGhwb3M9cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jz9ndXR0ZXJMZWZ0KzEwOmNhLndpZHRoLWd1dHRlclJpZ2h0LTEwO3ZhciB2cG9zPWd1dHRlclRvcCsxMDt2YXIgdGl0bGU9cHJvcFsnY2hhcnQudGl0bGUnXTt2YXIgYmxvYl9zaXplPXRleHRfc2l6ZTt2YXIgaG1hcmdpbj04O3ZhciB2bWFyZ2luPTQ7dmFyIGZpbGxzdHlsZT1wcm9wWydjaGFydC5rZXkuYmFja2dyb3VuZCddO3ZhciB0ZXh0X2NvbG9yPXByb3BbJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJ107dmFyIHN0cm9rZXN0eWxlPScjMzMzJzt2YXIgaGVpZ2h0PTA7dmFyIHdpZHRoPTA7aWYoIW9iai5jb29yZHMpb2JqLmNvb3Jkcz17fTtvYmouY29vcmRzLmtleT1bXTtjby5mb250PXRleHRfc2l6ZSsncHQgJytwcm9wWydjaGFydC50ZXh0LmZvbnQnXTtmb3IoaT0wO2k8a2V5Lmxlbmd0aDsrK2kpe3dpZHRoPU1hdGgubWF4KHdpZHRoLGNvLm1lYXN1cmVUZXh0KGtleVtpXSkud2lkdGgpO31cbndpZHRoKz01O3dpZHRoKz1ibG9iX3NpemU7d2lkdGgrPTU7d2lkdGgrPTU7d2lkdGgrPTU7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnfHwob2JqLnR5cGU9PT0ncGllJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pfHwob2JqLnR5cGU9PT0naGJhcicmJiFwcm9wWydjaGFydC55YXhpc3BvcyddKXx8KG9iai50eXBlPT09J2hiYXInJiZwcm9wWydjaGFydC55YXhpc3BvcyddPT09J2NlbnRlcicpfHwob2JqLnR5cGU9PT0naGJhcicmJnByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0ncmlnaHQnKXx8KG9iai50eXBlPT09J3JzY2F0dGVyJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pfHwob2JqLnR5cGU9PT0ncmFkYXInJiYhcHJvcFsnY2hhcnQueWF4aXNwb3MnXSl8fChvYmoudHlwZT09PSdyb3NlJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pfHwob2JqLnR5cGU9PT0nZnVubmVsJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pfHwob2JqLnR5cGU9PT0ndnByb2dyZXNzJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pfHwob2JqLnR5cGU9PT0naHByb2dyZXNzJyYmIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10pKXtocG9zLT13aWR0aDt9XG5pZih0eXBlb2YocHJvcFsnY2hhcnQua2V5LmhhbGlnbiddKT09J3N0cmluZycpe2lmKHByb3BbJ2NoYXJ0LmtleS5oYWxpZ24nXT09J2xlZnQnKXtocG9zPWd1dHRlckxlZnQrMTA7fWVsc2UgaWYocHJvcFsnY2hhcnQua2V5LmhhbGlnbiddPT0ncmlnaHQnKXtocG9zPWNhLndpZHRoLWd1dHRlclJpZ2h0LXdpZHRoO319XG5pZih0eXBlb2YocHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uLngnXSk9PSdudW1iZXInKXtocG9zPXByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi54J107fVxuaWYodHlwZW9mKHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi55J10pPT0nbnVtYmVyJyl7dnBvcz1wcm9wWydjaGFydC5rZXkucG9zaXRpb24ueSddO31cbmlmKHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cnXSl7Y28uc2hhZG93Q29sb3I9cHJvcFsnY2hhcnQua2V5LnNoYWRvdy5jb2xvciddO2NvLnNoYWRvd0JsdXI9cHJvcFsnY2hhcnQua2V5LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZPXByb3BbJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSddO31cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5rZXkuYmFja2dyb3VuZCddO2NvLnN0cm9rZVN0eWxlPSdibGFjayc7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi5ncmFwaC5ib3hlZCddKT09J3VuZGVmaW5lZCd8fCh0eXBlb2YocHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uLmdyYXBoLmJveGVkJ10pPT0nYm9vbGVhbicmJnByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi5ncmFwaC5ib3hlZCddKSl7aWYoYXJndW1lbnRzWzNdIT1mYWxzZSl7Y28ubGluZVdpZHRoPXR5cGVvZihwcm9wWydjaGFydC5rZXkubGluZXdpZHRoJ10pPT0nbnVtYmVyJz9wcm9wWydjaGFydC5rZXkubGluZXdpZHRoJ106MTtpZihwcm9wWydjaGFydC5rZXkucm91bmRlZCddPT10cnVlKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1zdHJva2VzdHlsZTtSRy5zdHJva2VkQ3VydnlSZWN0KGNvLE1hdGgucm91bmQoaHBvcyksTWF0aC5yb3VuZCh2cG9zKSx3aWR0aC01LDUrKCh0ZXh0X3NpemUrNSkqUkcuZ2V0S2V5TGVuZ3RoKGtleSkpLDQpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtSRy5Ob1NoYWRvdyhvYmopO31lbHNle2NvLnN0cm9rZVJlY3QoTWF0aC5yb3VuZChocG9zKSxNYXRoLnJvdW5kKHZwb3MpLHdpZHRoLTUsNSsoKHRleHRfc2l6ZSs1KSpSRy5nZXRLZXlMZW5ndGgoa2V5KSkpO2NvLmZpbGxSZWN0KE1hdGgucm91bmQoaHBvcyksTWF0aC5yb3VuZCh2cG9zKSx3aWR0aC01LDUrKCh0ZXh0X3NpemUrNSkqUkcuZ2V0S2V5TGVuZ3RoKGtleSkpKTt9fX1cblJHLk5vU2hhZG93KG9iaik7Y28uYmVnaW5QYXRoKCk7aWYocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKXtjb2xvcnM9cHJvcFsnY2hhcnQua2V5LmNvbG9ycyddO31cbmZvcih2YXIgaT1rZXkubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBqPU51bWJlcihpKSsxO2lmKHR5cGVvZihwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXSk9PSdvYmplY3QnJiZ0eXBlb2YocHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ11baV0pPT0nc3RyaW5nJyl7dmFyIGJsb2Jfc2hhcGU9cHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ11baV07fWVsc2UgaWYodHlwZW9mKHByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddKT09J3N0cmluZycpe3ZhciBibG9iX3NoYXBlPXByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddO31lbHNle3ZhciBibG9iX3NoYXBlPSdzcXVhcmUnO31cbmlmKGJsb2Jfc2hhcGU9PSdjaXJjbGUnKXtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9Y29sb3JzW2ldO2NvLmFyYyhocG9zKzUrKGJsb2Jfc2l6ZS8yKSx2cG9zKyg1KmopKyh0ZXh0X3NpemUqaiktdGV4dF9zaXplKyhibG9iX3NpemUvMiksYmxvYl9zaXplLzIsMCw2LjI2LDApO2NvLmZpbGwoKTt9ZWxzZSBpZihibG9iX3NoYXBlPT0nbGluZScpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPWNvbG9yc1tpXTtjby5tb3ZlVG8oaHBvcys1LHZwb3MrKDUqaikrKHRleHRfc2l6ZSpqKS10ZXh0X3NpemUrKGJsb2Jfc2l6ZS8yKSk7Y28ubGluZVRvKGhwb3MrYmxvYl9zaXplKzUsdnBvcysoNSpqKSsodGV4dF9zaXplKmopLXRleHRfc2l6ZSsoYmxvYl9zaXplLzIpKTtjby5zdHJva2UoKTt9ZWxzZSBpZihibG9iX3NoYXBlPT0ndHJpYW5nbGUnKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1jb2xvcnNbaV07Y28ubW92ZVRvKGhwb3MrNSx2cG9zKyg1KmopKyh0ZXh0X3NpemUqaiktdGV4dF9zaXplK2Jsb2Jfc2l6ZSk7Y28ubGluZVRvKGhwb3MrKGJsb2Jfc2l6ZS8yKSs1LHZwb3MrKDUqaikrKHRleHRfc2l6ZSpqKS10ZXh0X3NpemUpO2NvLmxpbmVUbyhocG9zK2Jsb2Jfc2l6ZSs1LHZwb3MrKDUqaikrKHRleHRfc2l6ZSpqKS10ZXh0X3NpemUrYmxvYl9zaXplKTtjby5jbG9zZVBhdGgoKTtjby5maWxsU3R5bGU9Y29sb3JzW2ldO2NvLmZpbGwoKTt9ZWxzZXtjby5maWxsU3R5bGU9Y29sb3JzW2ldO2NvLmZpbGxSZWN0KGhwb3MrNSx2cG9zKyg1KmopKyh0ZXh0X3NpemUqaiktdGV4dF9zaXplLHRleHRfc2l6ZSx0ZXh0X3NpemUrMSk7fVxuY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXR5cGVvZiB0ZXh0X2NvbG9yPT0nb2JqZWN0Jz90ZXh0X2NvbG9yW2ldOnRleHRfY29sb3I7cmV0PVJHLlRleHQyKG9iaix7J2ZvbnQnOnRleHRfZm9udCwnc2l6ZSc6dGV4dF9zaXplLCdib2xkJzp0ZXh0X2JvbGQsJ2l0YWxpYyc6dGV4dF9pdGFsaWMsJ3gnOmhwb3MrYmxvYl9zaXplKzUrNSwneSc6dnBvcysoNSpqKSsodGV4dF9zaXplKmopKzMsJ3RleHQnOmtleVtpXSwnYWNjZXNzaWJsZSc6IW9iai5wcm9wZXJ0aWVzWydjaGFydC5rZXkuaW50ZXJhY3RpdmUnXX0pO29iai5jb29yZHMua2V5W2ldPVtyZXQueCxyZXQueSxyZXQud2lkdGgscmV0LmhlaWdodCxrZXlbaV0sY29sb3JzW2ldLG9ial07fVxuY28uZmlsbCgpO31cbmZ1bmN0aW9uIERyYXdLZXlfZ3V0dGVyKG9iaixrZXksY29sb3JzKVxue3ZhciB0ZXh0X3NpemU9dHlwZW9mKHByb3BbJ2NoYXJ0LmtleS50ZXh0LnNpemUnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmtleS50ZXh0LnNpemUnXTpwcm9wWydjaGFydC50ZXh0LnNpemUnXSx0ZXh0X2JvbGQ9cHJvcFsnY2hhcnQua2V5LnRleHQuYm9sZCddLHRleHRfaXRhbGljPXByb3BbJ2NoYXJ0LmtleS50ZXh0Lml0YWxpYyddLHRleHRfZm9udD1wcm9wWydjaGFydC5rZXkudGV4dC5mb250J118fHByb3BbJ2NoYXJ0LmtleS5mb250J118fHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHRleHRfY29sb3I9cHJvcFsnY2hhcnQua2V5LnRleHQuY29sb3InXSxndXR0ZXJMZWZ0PW9iai5ndXR0ZXJMZWZ0LGd1dHRlclJpZ2h0PW9iai5ndXR0ZXJSaWdodCxndXR0ZXJUb3A9b2JqLmd1dHRlclRvcCxndXR0ZXJCb3R0b209b2JqLmd1dHRlckJvdHRvbSxocG9zPSgoY2Eud2lkdGgtZ3V0dGVyTGVmdC1ndXR0ZXJSaWdodCkvMikrb2JqLmd1dHRlckxlZnQsdnBvcz1ndXR0ZXJUb3AtdGV4dF9zaXplLTUsdGl0bGU9cHJvcFsnY2hhcnQudGl0bGUnXSxibG9iX3NpemU9dGV4dF9zaXplLGhtYXJnaW49OCx2bWFyZ2luPTQsZmlsbHN0eWxlPXByb3BbJ2NoYXJ0LmtleS5iYWNrZ3JvdW5kJ10sc3Ryb2tlc3R5bGU9JyM5OTknLGxlbmd0aD0wO2lmKCFvYmouY29vcmRzKW9iai5jb29yZHM9e307b2JqLmNvb3Jkcy5rZXk9W107Y28uZm9udD0ob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmtleS50ZXh0Lml0YWxpYyddPydpdGFsaWMgJzonJykrKG9iai5wcm9wZXJ0aWVzWydjaGFydC5rZXkudGV4dC5ib2xkJ10/J2JvbGQgJzonJykrdGV4dF9zaXplKydwdCAnK3RleHRfZm9udDtmb3IoaT0wO2k8a2V5Lmxlbmd0aDsrK2kpe2xlbmd0aCs9aG1hcmdpbjtsZW5ndGgrPWJsb2Jfc2l6ZTtsZW5ndGgrPWhtYXJnaW47bGVuZ3RoKz1jby5tZWFzdXJlVGV4dChrZXlbaV0pLndpZHRoO31cbmxlbmd0aCs9aG1hcmdpbjtpZihvYmoudHlwZT09J3BpZScpe2lmKHByb3BbJ2NoYXJ0LmFsaWduJ109PSdsZWZ0Jyl7dmFyIGhwb3M9b2JqLnJhZGl1cytndXR0ZXJMZWZ0O31lbHNlIGlmKHByb3BbJ2NoYXJ0LmFsaWduJ109PSdyaWdodCcpe3ZhciBocG9zPWNhLndpZHRoLW9iai5yYWRpdXMtZ3V0dGVyUmlnaHQ7fWVsc2V7aHBvcz1jYS53aWR0aC8yO319XG5ocG9zLT0obGVuZ3RoLzIpO2lmKHR5cGVvZihwcm9wWydjaGFydC5rZXkucG9zaXRpb24ueCddKT09J251bWJlcicpe2hwb3M9cHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uLngnXTt9XG5pZih0eXBlb2YocHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uLnknXSk9PSdudW1iZXInKXt2cG9zPXByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi55J107fVxuaWYob2JqLkdldCgnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCcpKXtpZihwcm9wWydjaGFydC5rZXkuc2hhZG93J10pe2NvLnNoYWRvd0NvbG9yPXByb3BbJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LmtleS5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFg9cHJvcFsnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4J107Y28uc2hhZG93T2Zmc2V0WT1wcm9wWydjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknXTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9ZmlsbHN0eWxlO2NvLnN0cm9rZVN0eWxlPXN0cm9rZXN0eWxlO2lmKHByb3BbJ2NoYXJ0LmtleS5yb3VuZGVkJ10pe1JHLnN0cm9rZWRDdXJ2eVJlY3QoY28saHBvcyx2cG9zLXZtYXJnaW4sbGVuZ3RoLHRleHRfc2l6ZSt2bWFyZ2luK3ZtYXJnaW4pfWVsc2V7Y28ucmVjdChocG9zLHZwb3Mtdm1hcmdpbixsZW5ndGgsdGV4dF9zaXplK3ZtYXJnaW4rdm1hcmdpbik7fVxuY28uc3Ryb2tlKCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KG9iaik7fVxuaWYocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKXtjb2xvcnM9cHJvcFsnY2hhcnQua2V5LmNvbG9ycyddO31cbmZvcih2YXIgaT0wLHBvcz1ocG9zO2k8a2V5Lmxlbmd0aDsrK2kpe3Bvcys9aG1hcmdpbjtpZih0eXBlb2YocHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ10pPT0nb2JqZWN0JyYmdHlwZW9mKHByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddW2ldKT09J3N0cmluZycpe3ZhciBibG9iX3NoYXBlPXByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddW2ldO31lbHNlIGlmKHR5cGVvZihwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXSk9PSdzdHJpbmcnKXt2YXIgYmxvYl9zaGFwZT1wcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXTt9ZWxzZXt2YXIgYmxvYl9zaGFwZT0nc3F1YXJlJzt9XG5pZihibG9iX3NoYXBlPT0nbGluZScpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPWNvbG9yc1tpXTtjby5tb3ZlVG8ocG9zLHZwb3MrKGJsb2Jfc2l6ZS8yKSk7Y28ubGluZVRvKHBvcytibG9iX3NpemUsdnBvcysoYmxvYl9zaXplLzIpKTtjby5zdHJva2UoKTt9ZWxzZSBpZihibG9iX3NoYXBlPT0nY2lyY2xlJyl7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPWNvbG9yc1tpXTtjby5tb3ZlVG8ocG9zLHZwb3MrKGJsb2Jfc2l6ZS8yKSk7Y28uYXJjKHBvcysoYmxvYl9zaXplLzIpLHZwb3MrKGJsb2Jfc2l6ZS8yKSwoYmxvYl9zaXplLzIpLDAsNi4yOCwwKTtjby5maWxsKCk7fWVsc2UgaWYoYmxvYl9zaGFwZT09J3RyaWFuZ2xlJyl7Y28uZmlsbFN0eWxlPWNvbG9yc1tpXTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1jb2xvcnNbaV07Y28ubW92ZVRvKHBvcyx2cG9zK2Jsb2Jfc2l6ZSk7Y28ubGluZVRvKHBvcysoYmxvYl9zaXplLzIpLHZwb3MpO2NvLmxpbmVUbyhwb3MrYmxvYl9zaXplLHZwb3MrYmxvYl9zaXplKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7fWVsc2V7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPWNvbG9yc1tpXTtjby5yZWN0KHBvcyx2cG9zLGJsb2Jfc2l6ZSxibG9iX3NpemUpO2NvLmZpbGwoKTt9XG5wb3MrPWJsb2Jfc2l6ZTtwb3MrPWhtYXJnaW47Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPSh0eXBlb2YgdGV4dF9jb2xvcj09PSdvYmplY3QnKT90ZXh0X2NvbG9yW2ldOnRleHRfY29sb3I7dmFyIHJldD1SRy5UZXh0MihvYmoseydmb250Jzp0ZXh0X2ZvbnQsJ2JvbGQnOnRleHRfYm9sZCwnc2l6ZSc6dGV4dF9zaXplLCdpdGFsaWMnOnRleHRfaXRhbGljLCd4Jzpwb3MsJ3knOnZwb3MrdGV4dF9zaXplKzMsJ3RleHQnOmtleVtpXSxhY2Nlc3NpYmxlOiFvYmoucHJvcGVydGllc1snY2hhcnQua2V5LmludGVyYWN0aXZlJ119KTtjby5maWxsKCk7cG9zKz1jby5tZWFzdXJlVGV4dChrZXlbaV0pLndpZHRoO29iai5jb29yZHMua2V5W2ldPVtyZXQueCxyZXQueSxyZXQud2lkdGgscmV0LmhlaWdodCxrZXlbaV0sY29sb3JzW2ldLG9ial07fX1cbmlmKGtleXBvcyYma2V5cG9zPT0nZ3V0dGVyJyl7RHJhd0tleV9ndXR0ZXIob2JqLGtleSxjb2xvcnMpO31lbHNlIGlmKGtleXBvcyYma2V5cG9zPT0nZ3JhcGgnKXtEcmF3S2V5X2dyYXBoKG9iaixrZXksY29sb3JzKTt9ZWxzZXthbGVydCgnW0NPTU1PTl0gKCcrb2JqLmlkKycpIFVua25vd24ga2V5IHBvc2l0aW9uOiAnK2tleXBvcyk7fVxuaWYocHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlJ10pe2lmKCFSR3JhcGguRHJhd2luZ3x8IVJHcmFwaC5EcmF3aW5nLlJlY3Qpe2FsZXJ0KCdbSU5URVJBQ1RJVkUgS0VZXSBUaGUgZHJhd2luZyBBUEkgUmVjdCBsaWJyYXJ5IGRvZXMgbm90IGFwcGVhciB0byBoYXZlIGJlZW4gaW5jbHVkZWQgKHdoaWNoIHRoZSBpbnRlcmFjdGl2ZSBrZXkgdXNlcyknKTt9XG5pZighUkdyYXBoLkluc3RhbGxXaW5kb3dNb3VzZWRvd25MaXN0ZW5lcil7YWxlcnQoJ1tJTlRFUkFDVElWRSBLRVldIFRoZSBkeW5hbWljIGxpYnJhcnkgZG9lcyBub3QgYXBwZWFyIHRvIGhhdmUgYmVlbiBpbmNsdWRlZCcpO31cbmZvcih2YXIgaT0wLGxlbj1vYmouY29vcmRzLmtleS5sZW5ndGgsbWF4bGVuPTA7aTxsZW47aSs9MSl7bWF4bGVuPU1hdGgubWF4KG1heGxlbixvYmouY29vcmRzLmtleVtpXVsyXSk7fVxuZm9yKHZhciBpPTAsbGVuPW9iai5jb29yZHMua2V5Lmxlbmd0aDtpPGxlbjtpKz0xKXsoZnVuY3Rpb24oaWR4KVxue3ZhciBhcnI9b2JqLmNvb3Jkcy5rZXk7dmFyIHZhbHVlPW9iai5jb29yZHMua2V5W2lkeF07dmFyIGluZGV4PWlkeDt2YXIgcmVjdD1uZXcgUkdyYXBoLkRyYXdpbmcuUmVjdChvYmouaWQsdmFsdWVbMF0sdmFsdWVbMV0scHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uJ109PSdndXR0ZXInP3ZhbHVlWzJdOm1heGxlbix2YWx1ZVszXSkuU2V0KCdmaWxsc3R5bGUnLCdyZ2JhKDAsMCwwLDApJykuRHJhdygpO3JlY3Qub25jbGljaz1mdW5jdGlvbihlLHNoYXBlKVxue3ZhciBjbz1yZWN0LmNvbnRleHQ7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnXTtjby5maWxsUmVjdChzaGFwZS54LHNoYXBlLnksc2hhcGUud2lkdGgsc2hhcGUuaGVpZ2h0KTtpZih0eXBlb2Ygb2JqLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0PT0nZnVuY3Rpb24nKXtvYmouU2V0KCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaW5kZXgnLGlkeCk7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25iZWZvcmVpbnRlcmFjdGl2ZWtleScpO29iai5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodChpbmRleCk7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hZnRlcmludGVyYWN0aXZla2V5Jyk7fX1cbnJlY3Qub25tb3VzZW1vdmU9ZnVuY3Rpb24oZSxzaGFwZSlcbntyZXR1cm4gdHJ1ZTt9fSkoaSk7fX19O1JHLmdldEtleUxlbmd0aD1mdW5jdGlvbihrZXkpXG57dmFyIGxlbmd0aD0wO2Zvcih2YXIgaT0wLGxlbj1rZXkubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGtleVtpXSE9bnVsbCl7KytsZW5ndGg7fX1cbnJldHVybiBsZW5ndGg7fTtSR3JhcGguSFRNTC5rZXk9UkdyYXBoLkhUTUwuS2V5PWZ1bmN0aW9uKGlkLHByb3ApXG57dmFyIGRpdj1kb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBzdHI9Jzx0YWJsZSBib3JkZXI9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2VsbHBhZGRpbmc9XCIwXCIgaWQ9XCJyZ3JhcGhfa2V5XCIgc3R5bGU9XCJkaXNwbGF5OiBpbmxpbmU7JysoZnVuY3Rpb24oKVxue3ZhciBzdHlsZT0nJ1xuZm9yKGkgaW4gcHJvcC50YWJsZUNzcyl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7c3R5bGU9c3R5bGUraSsnOiAnK3Byb3AudGFibGVDc3NbaV0rJzsnO319XG5yZXR1cm4gc3R5bGU7fSkoKSsnXCIgJysocHJvcC50YWJsZUNsYXNzPydjbGFzcz1cIicrcHJvcC50YWJsZUNsYXNzKydcIic6JycpKyc+Jztmb3IodmFyIGk9MDtpPHByb3AubGFiZWxzLmxlbmd0aDtpKz0xKXtzdHIrPSc8dHI+PHRkPjxkaXYgc3R5bGU9XCInKyhmdW5jdGlvbigpXG57dmFyIHN0eWxlPScnO2Zvcih2YXIgaiBpbiBwcm9wLmJsb2JDc3Mpe2lmKHR5cGVvZiBqPT09J3N0cmluZycpe3N0eWxlPXN0eWxlK2orJzogJytwcm9wLmJsb2JDc3Nbal0rJzsnO319XG5yZXR1cm4gc3R5bGU7fSkoKSsnZGlzcGxheTogaW5saW5lLWJsb2NrOyBtYXJnaW4tcmlnaHQ6IDVweDsgbWFyZ2luLXRvcDogNHB4OyB3aWR0aDogMTVweDsgaGVpZ2h0OiAxNXB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAnK3Byb3AuY29sb3JzW2ldKydcIicrKHByb3AuYmxvYkNsYXNzPydjbGFzcz1cIicrcHJvcC5ibG9iQ2xhc3MrJ1wiJzonJykrJz4mbmJzcDs8L2Rpdj48dGQ+JysocHJvcC5saW5rcyYmcHJvcC5saW5rc1tpXT8nPGEgaHJlZj1cIicrcHJvcC5saW5rc1tpXSsnXCI+JzonJykrJzxzcGFuICcrKHByb3AubGFiZWxDbGFzcz8nY2xhc3M9XCInK3Byb3AubGFiZWxDbGFzcysnXCInOicnKSsnXCIgc3R5bGU9XCInKyhmdW5jdGlvbigpXG57dmFyIHN0eWxlPScnO2Zvcih2YXIgaiBpbiBwcm9wLmxhYmVsQ3NzKXtpZih0eXBlb2Ygaj09PSdzdHJpbmcnKXtzdHlsZT1zdHlsZStqKyc6ICcrcHJvcC5sYWJlbENzc1tqXSsnOyc7fX1cbnJldHVybiBzdHlsZTt9KSgpKydcIiAnKyhmdW5jdGlvbigpXG57dmFyIHN0eWxlPScnO2lmKHByb3BbJ2xhYmVsQ3NzXycraV0pe2Zvcih2YXIgaiBpbiBwcm9wWydsYWJlbENzc18nK2ldKXtzdHlsZT1zdHlsZStqKyc6ICcrcHJvcFsnbGFiZWxDc3NfJytpXVtqXSsnOyc7fX1cbnJldHVybiBzdHlsZT8nc3R5bGU9XCInK3N0eWxlKydcIic6Jyc7fSkoKSsnPicrcHJvcC5sYWJlbHNbaV0rJzwvc3Bhbj4nKyhwcm9wLmxpbmtzJiZwcm9wLmxpbmtzW2ldPyc8L2E+JzonJykrJzwvdGQ+PC90cj4nO31cbmRpdi5pbm5lckhUTUwrPShzdHIrJzwvdGFibGU+Jyk7cmV0dXJuIGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2tleScpO307fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24ua2V5LmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///201\n");

/***/ }),
/* 202 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      active = null;RGraph.allowResizing = RGraph.AllowResizing = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        pa2 = RG.path2;ca.resizing = ca.resizing || {};ca.resizing.placeHolders = ca.resizing.placeHolders || [];if (!ca.resizing.originalw) {\n      ca.resizing.originalw = ca.width;\n    }\n    if (!ca.resizing.originalh) {\n      ca.resizing.originalh = ca.height;\n    }\n    var resizeHandleSize = 15;if (!ca.resizing.__rgraph_original_width__ || !ca.resizing.__rgraph_original_height__ || !ca.resizing.__adjustX || !ca.resizing.__adjustY) {\n      ca.resizing.__rgraph_original_width__ = ca.width;ca.resizing.__rgraph_original_height__ = ca.height;ca.resizing.adjustX = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[0] == 'number' ? obj.Get('chart.resize.handle.adjust')[0] : 0;ca.resizing.adjustY = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[1] == 'number' ? obj.Get('chart.resize.handle.adjust')[1] : 0;ca.resizing.bgcolor = obj.get('chart.resize.handle.background') || 'rgba(0,0,0,0)';\n    }\n    pa2(co, 'b m % % r % % % % f %', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize, ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 2 * resizeHandleSize, resizeHandleSize, ca.resizing.bgcolor);pa2(co, 'b lw 1 m % % l % % m % % l % % s gray f transparent', ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height - resizeHandleSize + ca.resizing.adjustY, ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height + ca.resizing.adjustY, ca.width + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY), ca.width - resizeHandleSize + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY));pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 's', 'gray', 'f', 'white']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - 3 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 's', 'gray', 'f', 'gray']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 's', 'f']);if (obj.get('chart.resizable') && !ca.rgraphResizewrapper) {\n      ca.rgraphResizewrapper = $('<div id=\"rgraph_resize_container_' + ca.id + '\"></div>').css({ 'float': ca.style.cssFloat, position: 'relative' }).get(0);$(ca).wrap(ca.rgraphResizewrapper);ca.style.cssFloat = 'none';ca.style.top = 0;ca.style.left = 0;var window_onmousemove = function window_onmousemove(e) {\n        var ca = active,\n            obj = ca ? ca.__object__ : null;if (ca) {\n          e = RG.fixEventObject(e);if (ca.resizing.mousedown) {\n            var newWidth = ca.width + (e.pageX - ca.resizing.originalx);var newHeight = ca.height + (e.pageY - ca.resizing.originaly);if (newWidth > ca.resizing.originalw / 2 && (typeof obj.get('resizableMaxwidth') === 'number' ? newWidth < obj.get('resizableMaxwidth') : true)) {\n              ca.resizing.div.style.width = newWidth + 'px';\n            }\n            if (newHeight > ca.resizing.originalh / 2 && (typeof obj.get('resizableMaxheight') === 'number' ? newHeight < obj.get('resizableMaxheight') : true)) {\n              ca.resizing.div.style.height = newHeight + 'px';\n            }\n            RG.fireCustomEvent(ca.__object__, 'onresize');\n          }\n        }\n      };\n      if (typeof ca.rgraph_resize_window_mousemove_listener_installed != 'boolean') {\n        window.addEventListener('mousemove', window_onmousemove, false);ca.rgraph_resize_window_mousemove_listener_installed = true;\n      }\n      var MouseupFunc = function MouseupFunc(e) {\n        if (!ca.resizing || !ca.resizing.div || !ca.resizing.mousedown) {\n          return;\n        }\n        if (ca.resizing.div) {\n          var div = ca.resizing.div;var coords = RG.getCanvasXY(ca);var parentNode = ca.parentNode;if (ca.style.position != 'absolute') {\n            var placeHolderDIV = document.createElement('DIV');placeHolderDIV.style.width = ca.resizing.originalw + 'px';placeHolderDIV.style.height = ca.resizing.originalh + 'px';placeHolderDIV.style.display = 'inline-block';placeHolderDIV.style.position = ca.style.position;placeHolderDIV.style.left = ca.style.left;placeHolderDIV.style.top = ca.style.top;placeHolderDIV.style.cssFloat = ca.style.cssFloat;parentNode.insertBefore(placeHolderDIV, ca);\n          }\n          ca.style.backgroundColor = 'white';ca.style.position = 'absolute';ca.style.border = '1px dashed gray';ca.style.boxShadow = '2px 2px 5px #ddd';ca.style.left = 0;ca.style.top = 0;ca.width = parseInt(div.style.width);ca.height = parseInt(div.style.height);ca.getContext('2d').translate(0.5, 0.5);var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (typeof objects[i].reset === 'function') {\n              objects[i].reset();\n            }\n          }\n          RG.cache = [];RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');RG.redrawCanvas(ca);ca.resizing.mousedown = false;div.style.display = 'none';document.body.removeChild(div);\n        }\n        if (RG.Registry.Get('chart.zoomed.div') || RGraph.Registry.Get('chart.zoomed.img')) {\n          RG.Registry.Set('chart.zoomed.div', null);RG.Registry.Set('chart.zoomed.img', null);\n        }\n        RG.FireCustomEvent(ca.__object__, 'onresizeend');\n      };var window_onmouseup = MouseupFunc;if (typeof ca.rgraph_resize_window_mouseup_listener_installed != 'boolean') {\n        window.addEventListener('mouseup', window_onmouseup, false);ca.rgraph_resize_window_mouseup_listener_installed = true;\n      }\n      var canvas_onmousemove = function canvas_onmousemove(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var obj = e.target.__object__;var ca = e.target;var co = ca.getContext('2d');var cursor = ca.style.cursor;if (!ca.resizing.original_cursor) {\n          ca.resizing.original_cursor = cursor;\n        }\n        if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'move';\n        } else if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'pointer';\n        } else {\n          if (ca.resizing.original_cursor) {\n            ca.style.cursor = ca.resizing.original_cursor;ca.resizing.original_cursor = null;\n          } else {\n            ca.style.cursor = 'default';\n          }\n        }\n      };if (typeof ca.rgraph_resize_mousemove_listener_installed != 'boolean') {\n        ca.addEventListener('mousemove', canvas_onmousemove, false);ca.rgraph_resize_mousemove_listener_installed = true;\n      }\n      var canvas_onmouseout = function canvas_onmouseout(e) {\n        e.target.style.cursor = 'default';e.target.title = '';\n      };if (typeof ca.rgraph_resize_mouseout_listener_installed != 'boolean') {\n        ca.addEventListener('mouseout', canvas_onmouseout, false);ca.rgraph_resize_mouseout_listener_installed = true;\n      }\n      var canvas_onmousedown = function canvas_onmousedown(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(e.target);var ca = e.target;active = ca;if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          RG.fireCustomEvent(obj, 'onresizebegin');if (ca.resizing.original_css_border == null) {\n            ca.resizing.original_css_border = ca.style.border;\n          }\n          if (ca.resizing.original_css_shadow == null) {\n            ca.resizing.original_css_shadow = ca.style.boxShadow;\n          }\n          ca.resizing.mousedown = true;var div = document.createElement('DIV');div.style.position = 'absolute';div.style.left = canvasXY[0] + 'px';div.style.top = canvasXY[1] + 'px';div.style.width = ca.width + 'px';div.style.height = ca.height + 'px';div.style.border = '1px dotted black';div.style.backgroundColor = 'gray';div.style.opacity = 0.5;div.__canvas__ = e.target;document.body.appendChild(div);ca.resizing.div = div;ca.resizing.placeHolders.push(div);for (var i = 0; i < ca.resizing.placeHolders.length - 1; ++i) {\n            ca.resizing.placeHolders[i].style.display = 'none';\n          }\n          div.onmouseup = function (e) {\n            MouseupFunc(e);\n          };\n          ca.resizing.div.onmouseover = function (e) {\n            e = RG.fixEventObject(e);e.stopPropagation();\n          };\n          ca.resizing.originalx = e.pageX;ca.resizing.originaly = e.pageY;ca.resizing.originalCanvasX = RG.getCanvasXY(ca)[0];ca.resizing.originalCanvasY = RG.getCanvasXY(ca)[1];\n        }\n        if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height && ca.resizing.originalw && ca.resizing.originaly) {\n          RG.fireCustomEvent(ca.__object__, 'onresizebegin');ca.width = ca.resizing.originalw;ca.height = ca.resizing.originalh;if (ca.__link__ && ca.__link__.style.display === 'none') {\n            ca.__link__.style.display = 'inline';\n          }\n          if (typeof ca.parentNode.id === 'string' && ca.parentNode.id.substring(0, 24) === 'rgraph_resize_container_') {\n            ca.parentNode.style.width = ca.resizing.originalw + 'px';ca.parentNode.style.height = ca.resizing.originalh + 'px';\n          }\n          ca.style.border = ca.resizing.original_css_border;ca.style.boxShadow = ca.resizing.original_css_shadow;ca.style.left = parseInt(ca.style.left) + 'px';ca.style.top = parseInt(ca.style.top) + 'px';ca.getContext('2d').translate(0.5, 0.5);RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0; i < objects.length; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (objects[i].reset) {\n              objects[i].reset();\n            }\n            RG.redrawCanvas(objects[i].canvas);\n          }\n          RG.cache = [];if (ca.resizing.div) {\n            ca.resizing.div.style.width = ca.__original_width__ + 'px';ca.resizing.div.style.height = ca.__original_height__ + 'px';\n          }\n          RG.fireCustomEvent(ca.__object__, 'onresize');RG.fireCustomEvent(ca.__object__, 'onresizeend');\n        }\n      };if (typeof ca.rgraph_resize_mousedown_listener_installed != 'boolean') {\n        ca.addEventListener('mousedown', canvas_onmousedown, false);ca.rgraph_resize_mousedown_listener_installed = true;\n      }\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnJlc2l6aW5nLmpzPzljZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aCxhY3RpdmU9bnVsbDtSR3JhcGguYWxsb3dSZXNpemluZz1SR3JhcGguQWxsb3dSZXNpemluZz1mdW5jdGlvbihvYmopXG57dmFyIGNhPW9iai5jYW52YXMsY289b2JqLmNvbnRleHQscGEyPVJHLnBhdGgyO2NhLnJlc2l6aW5nPWNhLnJlc2l6aW5nfHx7fTtjYS5yZXNpemluZy5wbGFjZUhvbGRlcnM9Y2EucmVzaXppbmcucGxhY2VIb2xkZXJzfHxbXTtpZighY2EucmVzaXppbmcub3JpZ2luYWx3KXtjYS5yZXNpemluZy5vcmlnaW5hbHc9Y2Eud2lkdGg7fVxuaWYoIWNhLnJlc2l6aW5nLm9yaWdpbmFsaCl7Y2EucmVzaXppbmcub3JpZ2luYWxoPWNhLmhlaWdodDt9XG52YXIgcmVzaXplSGFuZGxlU2l6ZT0xNTtpZighY2EucmVzaXppbmcuX19yZ3JhcGhfb3JpZ2luYWxfd2lkdGhfX3x8IWNhLnJlc2l6aW5nLl9fcmdyYXBoX29yaWdpbmFsX2hlaWdodF9ffHwhY2EucmVzaXppbmcuX19hZGp1c3RYfHwhY2EucmVzaXppbmcuX19hZGp1c3RZKXtjYS5yZXNpemluZy5fX3JncmFwaF9vcmlnaW5hbF93aWR0aF9fPWNhLndpZHRoO2NhLnJlc2l6aW5nLl9fcmdyYXBoX29yaWdpbmFsX2hlaWdodF9fPWNhLmhlaWdodDtjYS5yZXNpemluZy5hZGp1c3RYPSh0eXBlb2Ygb2JqLmdldCgnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnKT09J29iamVjdCcmJnR5cGVvZiBvYmouZ2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCcpWzBdPT0nbnVtYmVyJz9vYmouR2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCcpWzBdOjApO2NhLnJlc2l6aW5nLmFkanVzdFk9KHR5cGVvZiBvYmouZ2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCcpPT0nb2JqZWN0JyYmdHlwZW9mIG9iai5nZXQoJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JylbMV09PSdudW1iZXInP29iai5HZXQoJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JylbMV06MCk7Y2EucmVzaXppbmcuYmdjb2xvcj1vYmouZ2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnKXx8J3JnYmEoMCwwLDAsMCknO31cbnBhMihjbywnYiBtICUgJSByICUgJSAlICUgZiAlJyxjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZSxjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZStjYS5yZXNpemluZy5hZGp1c3RZLDIqcmVzaXplSGFuZGxlU2l6ZSxyZXNpemVIYW5kbGVTaXplLGNhLnJlc2l6aW5nLmJnY29sb3IpO3BhMihjbywnYiBsdyAxIG0gJSAlIGwgJSAlIG0gJSAlIGwgJSAlIHMgZ3JheSBmIHRyYW5zcGFyZW50JyxtYS5yb3VuZChjYS53aWR0aC0ocmVzaXplSGFuZGxlU2l6ZS8yKStjYS5yZXNpemluZy5hZGp1c3RYKSxjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZStjYS5yZXNpemluZy5hZGp1c3RZLG1hLnJvdW5kKGNhLndpZHRoLShyZXNpemVIYW5kbGVTaXplLzIpK2NhLnJlc2l6aW5nLmFkanVzdFgpLGNhLmhlaWdodCtjYS5yZXNpemluZy5hZGp1c3RZLGNhLndpZHRoK2NhLnJlc2l6aW5nLmFkanVzdFgsbWEucm91bmQoY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpK2NhLnJlc2l6aW5nLmFkanVzdFkpLGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCxtYS5yb3VuZChjYS5oZWlnaHQtKHJlc2l6ZUhhbmRsZVNpemUvMikrY2EucmVzaXppbmcuYWRqdXN0WSkpO3BhMihjbyxbJ2InLCdtJyxjYS53aWR0aC0ocmVzaXplSGFuZGxlU2l6ZS8yKStjYS5yZXNpemluZy5hZGp1c3RYLGNhLmhlaWdodC1yZXNpemVIYW5kbGVTaXplK2NhLnJlc2l6aW5nLmFkanVzdFksJ2wnLGNhLndpZHRoLShyZXNpemVIYW5kbGVTaXplLzIpKzMrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZSszK2NhLnJlc2l6aW5nLmFkanVzdFksJ2wnLGNhLndpZHRoLShyZXNpemVIYW5kbGVTaXplLzIpLTMrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZSszK2NhLnJlc2l6aW5nLmFkanVzdFksJ2MnLCdmJywnZ3JheSddKTtwYTIoY28sWydiJywnbScsY2Eud2lkdGgtKHJlc2l6ZUhhbmRsZVNpemUvMikrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsY2Eud2lkdGgtKHJlc2l6ZUhhbmRsZVNpemUvMikrMytjYS5yZXNpemluZy5hZGp1c3RYLGNhLmhlaWdodC0zK2NhLnJlc2l6aW5nLmFkanVzdFksJ2wnLGNhLndpZHRoLShyZXNpemVIYW5kbGVTaXplLzIpLTMrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtMytjYS5yZXNpemluZy5hZGp1c3RZLCdjJywnZicsJ2dyYXknXSk7cGEyKGNvLFsnYicsJ20nLGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtKHJlc2l6ZUhhbmRsZVNpemUvMikrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsY2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZSszK2NhLnJlc2l6aW5nLmFkanVzdFgsY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpKzMrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsY2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZSszK2NhLnJlc2l6aW5nLmFkanVzdFgsY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpLTMrY2EucmVzaXppbmcuYWRqdXN0WSwnYycsJ2YnLCdncmF5J10pO3BhMihjbyxbJ2InLCdtJyxjYS53aWR0aCtjYS5yZXNpemluZy5hZGp1c3RYLGNhLmhlaWdodC0ocmVzaXplSGFuZGxlU2l6ZS8yKStjYS5yZXNpemluZy5hZGp1c3RZLCdsJyxjYS53aWR0aC0zK2NhLnJlc2l6aW5nLmFkanVzdFgsY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpKzMrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsY2Eud2lkdGgtMytjYS5yZXNpemluZy5hZGp1c3RYLGNhLmhlaWdodC0ocmVzaXplSGFuZGxlU2l6ZS8yKS0zK2NhLnJlc2l6aW5nLmFkanVzdFksJ2MnLCdmJywnZ3JheSddKTtwYTIoY28sWydiJywnbScsY2Eud2lkdGgrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtKHJlc2l6ZUhhbmRsZVNpemUvMikrY2EucmVzaXppbmcuYWRqdXN0WSwncicsY2Eud2lkdGgtKHJlc2l6ZUhhbmRsZVNpemUvMiktMitjYS5yZXNpemluZy5hZGp1c3RYLGNhLmhlaWdodC0ocmVzaXplSGFuZGxlU2l6ZS8yKS0yK2NhLnJlc2l6aW5nLmFkanVzdFksNCw0LCdyJyxjYS53aWR0aC0ocmVzaXplSGFuZGxlU2l6ZS8yKS0yK2NhLnJlc2l6aW5nLmFkanVzdFgsY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpLTIrY2EucmVzaXppbmcuYWRqdXN0WSw0LDQsJ3MnLCdncmF5JywnZicsJ3doaXRlJ10pO3BhMihjbyxbJ2InLCdtJyxtYS5yb3VuZChjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLTMrY2EucmVzaXppbmcuYWRqdXN0WCksY2EuaGVpZ2h0LXJlc2l6ZUhhbmRsZVNpemUvMitjYS5yZXNpemluZy5hZGp1c3RZLCdsJyxtYS5yb3VuZChjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCksY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpK2NhLnJlc2l6aW5nLmFkanVzdFksJ2wnLGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUtcmVzaXplSGFuZGxlU2l6ZSsyK2NhLnJlc2l6aW5nLmFkanVzdFgsY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpLTIrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsY2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZS1yZXNpemVIYW5kbGVTaXplKzIrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtKHJlc2l6ZUhhbmRsZVNpemUvMikrMitjYS5yZXNpemluZy5hZGp1c3RZLCdsJyxjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLXJlc2l6ZUhhbmRsZVNpemUrY2EucmVzaXppbmcuYWRqdXN0WCxjYS5oZWlnaHQtKHJlc2l6ZUhhbmRsZVNpemUvMikrY2EucmVzaXppbmcuYWRqdXN0WSwncycsJ2dyYXknLCdmJywnZ3JheSddKTtwYTIoY28sWydiJywnbScsbWEucm91bmQoY2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZS1yZXNpemVIYW5kbGVTaXplLTErY2EucmVzaXppbmcuYWRqdXN0WCksY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpLTMrY2EucmVzaXppbmcuYWRqdXN0WSwnbCcsbWEucm91bmQoY2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZS1yZXNpemVIYW5kbGVTaXplLTErY2EucmVzaXppbmcuYWRqdXN0WCksY2EuaGVpZ2h0LShyZXNpemVIYW5kbGVTaXplLzIpKzMrY2EucmVzaXppbmcuYWRqdXN0WSwncycsJ2YnXSk7aWYob2JqLmdldCgnY2hhcnQucmVzaXphYmxlJykmJiFjYS5yZ3JhcGhSZXNpemV3cmFwcGVyKXtjYS5yZ3JhcGhSZXNpemV3cmFwcGVyPSQoJzxkaXYgaWQ9XCJyZ3JhcGhfcmVzaXplX2NvbnRhaW5lcl8nK2NhLmlkKydcIj48L2Rpdj4nKS5jc3MoeydmbG9hdCc6Y2Euc3R5bGUuY3NzRmxvYXQscG9zaXRpb246J3JlbGF0aXZlJ30pLmdldCgwKTskKGNhKS53cmFwKGNhLnJncmFwaFJlc2l6ZXdyYXBwZXIpO2NhLnN0eWxlLmNzc0Zsb2F0PSdub25lJztjYS5zdHlsZS50b3A9MDtjYS5zdHlsZS5sZWZ0PTA7dmFyIHdpbmRvd19vbm1vdXNlbW92ZT1mdW5jdGlvbihlKVxue3ZhciBjYT1hY3RpdmUsb2JqPWNhP2NhLl9fb2JqZWN0X186bnVsbDtpZihjYSl7ZT1SRy5maXhFdmVudE9iamVjdChlKTtpZihjYS5yZXNpemluZy5tb3VzZWRvd24pe3ZhciBuZXdXaWR0aD1jYS53aWR0aCsoZS5wYWdlWC1jYS5yZXNpemluZy5vcmlnaW5hbHgpO3ZhciBuZXdIZWlnaHQ9Y2EuaGVpZ2h0KyhlLnBhZ2VZLWNhLnJlc2l6aW5nLm9yaWdpbmFseSk7aWYobmV3V2lkdGg+KGNhLnJlc2l6aW5nLm9yaWdpbmFsdy8yKSYmKHR5cGVvZiBvYmouZ2V0KCdyZXNpemFibGVNYXh3aWR0aCcpPT09J251bWJlcic/bmV3V2lkdGg8b2JqLmdldCgncmVzaXphYmxlTWF4d2lkdGgnKTp0cnVlKSl7Y2EucmVzaXppbmcuZGl2LnN0eWxlLndpZHRoPW5ld1dpZHRoKydweCc7fVxuaWYobmV3SGVpZ2h0PihjYS5yZXNpemluZy5vcmlnaW5hbGgvMikmJih0eXBlb2Ygb2JqLmdldCgncmVzaXphYmxlTWF4aGVpZ2h0Jyk9PT0nbnVtYmVyJz9uZXdIZWlnaHQ8b2JqLmdldCgncmVzaXphYmxlTWF4aGVpZ2h0Jyk6dHJ1ZSkpe2NhLnJlc2l6aW5nLmRpdi5zdHlsZS5oZWlnaHQ9bmV3SGVpZ2h0KydweCc7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KGNhLl9fb2JqZWN0X18sJ29ucmVzaXplJyk7fX19XG5pZih0eXBlb2YgY2EucmdyYXBoX3Jlc2l6ZV93aW5kb3dfbW91c2Vtb3ZlX2xpc3RlbmVyX2luc3RhbGxlZCE9J2Jvb2xlYW4nKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyx3aW5kb3dfb25tb3VzZW1vdmUsZmFsc2UpO2NhLnJncmFwaF9yZXNpemVfd2luZG93X21vdXNlbW92ZV9saXN0ZW5lcl9pbnN0YWxsZWQ9dHJ1ZTt9XG52YXIgTW91c2V1cEZ1bmM9ZnVuY3Rpb24oZSlcbntpZighY2EucmVzaXppbmd8fCFjYS5yZXNpemluZy5kaXZ8fCFjYS5yZXNpemluZy5tb3VzZWRvd24pe3JldHVybjt9XG5pZihjYS5yZXNpemluZy5kaXYpe3ZhciBkaXY9Y2EucmVzaXppbmcuZGl2O3ZhciBjb29yZHM9UkcuZ2V0Q2FudmFzWFkoY2EpO3ZhciBwYXJlbnROb2RlPWNhLnBhcmVudE5vZGU7aWYoY2Euc3R5bGUucG9zaXRpb24hPSdhYnNvbHV0ZScpe3ZhciBwbGFjZUhvbGRlckRJVj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtwbGFjZUhvbGRlckRJVi5zdHlsZS53aWR0aD1jYS5yZXNpemluZy5vcmlnaW5hbHcrJ3B4JztwbGFjZUhvbGRlckRJVi5zdHlsZS5oZWlnaHQ9Y2EucmVzaXppbmcub3JpZ2luYWxoKydweCc7cGxhY2VIb2xkZXJESVYuc3R5bGUuZGlzcGxheT0naW5saW5lLWJsb2NrJztwbGFjZUhvbGRlckRJVi5zdHlsZS5wb3NpdGlvbj1jYS5zdHlsZS5wb3NpdGlvbjtwbGFjZUhvbGRlckRJVi5zdHlsZS5sZWZ0PWNhLnN0eWxlLmxlZnQ7cGxhY2VIb2xkZXJESVYuc3R5bGUudG9wPWNhLnN0eWxlLnRvcDtwbGFjZUhvbGRlckRJVi5zdHlsZS5jc3NGbG9hdD1jYS5zdHlsZS5jc3NGbG9hdDtwYXJlbnROb2RlLmluc2VydEJlZm9yZShwbGFjZUhvbGRlckRJVixjYSk7fVxuY2Euc3R5bGUuYmFja2dyb3VuZENvbG9yPSd3aGl0ZSc7Y2Euc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztjYS5zdHlsZS5ib3JkZXI9JzFweCBkYXNoZWQgZ3JheSc7Y2Euc3R5bGUuYm94U2hhZG93PScycHggMnB4IDVweCAjZGRkJztjYS5zdHlsZS5sZWZ0PTA7Y2Euc3R5bGUudG9wPTA7Y2Eud2lkdGg9cGFyc2VJbnQoZGl2LnN0eWxlLndpZHRoKTtjYS5oZWlnaHQ9cGFyc2VJbnQoZGl2LnN0eWxlLmhlaWdodCk7Y2EuZ2V0Q29udGV4dCgnMmQnKS50cmFuc2xhdGUoMC41LDAuNSk7dmFyIG9iamVjdHM9UkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoY2EuaWQpO2Zvcih2YXIgaT0wLGxlbj1vYmplY3RzLmxlbmd0aDtpPGxlbjtpKz0xKXtSRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMob2JqZWN0c1tpXSk7aWYodHlwZW9mIG9iamVjdHNbaV0ucmVzZXQ9PT0nZnVuY3Rpb24nKXtvYmplY3RzW2ldLnJlc2V0KCk7fX1cblJHLmNhY2hlPVtdO1JHLmZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCdvbnJlc2l6ZWJlZm9yZWRyYXcnKTtSRy5yZWRyYXdDYW52YXMoY2EpO2NhLnJlc2l6aW5nLm1vdXNlZG93bj1mYWxzZTtkaXYuc3R5bGUuZGlzcGxheT0nbm9uZSc7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO31cbmlmKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuem9vbWVkLmRpdicpfHxSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC56b29tZWQuaW1nJykpe1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuem9vbWVkLmRpdicsbnVsbCk7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC56b29tZWQuaW1nJyxudWxsKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQoY2EuX19vYmplY3RfXywnb25yZXNpemVlbmQnKTt9O3ZhciB3aW5kb3dfb25tb3VzZXVwPU1vdXNldXBGdW5jO2lmKHR5cGVvZiBjYS5yZ3JhcGhfcmVzaXplX3dpbmRvd19tb3VzZXVwX2xpc3RlbmVyX2luc3RhbGxlZCE9J2Jvb2xlYW4nKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsd2luZG93X29ubW91c2V1cCxmYWxzZSk7Y2EucmdyYXBoX3Jlc2l6ZV93aW5kb3dfbW91c2V1cF9saXN0ZW5lcl9pbnN0YWxsZWQ9dHJ1ZTt9XG52YXIgY2FudmFzX29ubW91c2Vtb3ZlPWZ1bmN0aW9uKGUpXG57ZT1SRy5maXhFdmVudE9iamVjdChlKTt2YXIgY29vcmRzPVJHLmdldE1vdXNlWFkoZSk7dmFyIG9iaj1lLnRhcmdldC5fX29iamVjdF9fO3ZhciBjYT1lLnRhcmdldDt2YXIgY289Y2EuZ2V0Q29udGV4dCgnMmQnKTt2YXIgY3Vyc29yPWNhLnN0eWxlLmN1cnNvcjtpZighY2EucmVzaXppbmcub3JpZ2luYWxfY3Vyc29yKXtjYS5yZXNpemluZy5vcmlnaW5hbF9jdXJzb3I9Y3Vyc29yO31cbmlmKChjb29yZHNbMF0+KGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUpJiZjb29yZHNbMF08Y2Eud2lkdGgmJmNvb3Jkc1sxXT4oY2EuaGVpZ2h0LXJlc2l6ZUhhbmRsZVNpemUpJiZjb29yZHNbMV08Y2EuaGVpZ2h0KSl7Y2Euc3R5bGUuY3Vyc29yPSdtb3ZlJzt9ZWxzZSBpZihjb29yZHNbMF0+KGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUtcmVzaXplSGFuZGxlU2l6ZSkmJmNvb3Jkc1swXTxjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplJiZjb29yZHNbMV0+KGNhLmhlaWdodC1yZXNpemVIYW5kbGVTaXplKSYmY29vcmRzWzFdPGNhLmhlaWdodCl7Y2Euc3R5bGUuY3Vyc29yPSdwb2ludGVyJzt9ZWxzZXtpZihjYS5yZXNpemluZy5vcmlnaW5hbF9jdXJzb3Ipe2NhLnN0eWxlLmN1cnNvcj1jYS5yZXNpemluZy5vcmlnaW5hbF9jdXJzb3I7Y2EucmVzaXppbmcub3JpZ2luYWxfY3Vyc29yPW51bGw7fWVsc2V7Y2Euc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9fX07aWYodHlwZW9mIGNhLnJncmFwaF9yZXNpemVfbW91c2Vtb3ZlX2xpc3RlbmVyX2luc3RhbGxlZCE9J2Jvb2xlYW4nKXtjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGNhbnZhc19vbm1vdXNlbW92ZSxmYWxzZSk7Y2EucmdyYXBoX3Jlc2l6ZV9tb3VzZW1vdmVfbGlzdGVuZXJfaW5zdGFsbGVkPXRydWU7fVxudmFyIGNhbnZhc19vbm1vdXNlb3V0PWZ1bmN0aW9uKGUpXG57ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0JztlLnRhcmdldC50aXRsZT0nJzt9O2lmKHR5cGVvZiBjYS5yZ3JhcGhfcmVzaXplX21vdXNlb3V0X2xpc3RlbmVyX2luc3RhbGxlZCE9J2Jvb2xlYW4nKXtjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsY2FudmFzX29ubW91c2VvdXQsZmFsc2UpO2NhLnJncmFwaF9yZXNpemVfbW91c2VvdXRfbGlzdGVuZXJfaW5zdGFsbGVkPXRydWU7fVxudmFyIGNhbnZhc19vbm1vdXNlZG93bj1mdW5jdGlvbihlKVxue2U9UkcuZml4RXZlbnRPYmplY3QoZSk7dmFyIGNvb3Jkcz1SRy5nZXRNb3VzZVhZKGUpO3ZhciBjYW52YXNYWT1SRy5nZXRDYW52YXNYWShlLnRhcmdldCk7dmFyIGNhPWUudGFyZ2V0O2FjdGl2ZT1jYTtpZihjb29yZHNbMF0+KGNhLndpZHRoLXJlc2l6ZUhhbmRsZVNpemUpJiZjb29yZHNbMF08Y2Eud2lkdGgmJmNvb3Jkc1sxXT4oY2EuaGVpZ2h0LXJlc2l6ZUhhbmRsZVNpemUpJiZjb29yZHNbMV08Y2EuaGVpZ2h0KXtSRy5maXJlQ3VzdG9tRXZlbnQob2JqLCdvbnJlc2l6ZWJlZ2luJyk7aWYoY2EucmVzaXppbmcub3JpZ2luYWxfY3NzX2JvcmRlcj09bnVsbCl7Y2EucmVzaXppbmcub3JpZ2luYWxfY3NzX2JvcmRlcj1jYS5zdHlsZS5ib3JkZXI7fVxuaWYoY2EucmVzaXppbmcub3JpZ2luYWxfY3NzX3NoYWRvdz09bnVsbCl7Y2EucmVzaXppbmcub3JpZ2luYWxfY3NzX3NoYWRvdz1jYS5zdHlsZS5ib3hTaGFkb3c7fVxuY2EucmVzaXppbmcubW91c2Vkb3duPXRydWU7dmFyIGRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUubGVmdD1jYW52YXNYWVswXSsncHgnO2Rpdi5zdHlsZS50b3A9Y2FudmFzWFlbMV0rJ3B4JztkaXYuc3R5bGUud2lkdGg9Y2Eud2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PWNhLmhlaWdodCsncHgnO2Rpdi5zdHlsZS5ib3JkZXI9JzFweCBkb3R0ZWQgYmxhY2snO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J2dyYXknO2Rpdi5zdHlsZS5vcGFjaXR5PTAuNTtkaXYuX19jYW52YXNfXz1lLnRhcmdldDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7Y2EucmVzaXppbmcuZGl2PWRpdjtjYS5yZXNpemluZy5wbGFjZUhvbGRlcnMucHVzaChkaXYpO2Zvcih2YXIgaT0wO2k8KGNhLnJlc2l6aW5nLnBsYWNlSG9sZGVycy5sZW5ndGgtMSk7KytpKXtjYS5yZXNpemluZy5wbGFjZUhvbGRlcnNbaV0uc3R5bGUuZGlzcGxheT0nbm9uZSc7fVxuZGl2Lm9ubW91c2V1cD1mdW5jdGlvbihlKVxue01vdXNldXBGdW5jKGUpO31cbmNhLnJlc2l6aW5nLmRpdi5vbm1vdXNlb3Zlcj1mdW5jdGlvbihlKVxue2U9UkcuZml4RXZlbnRPYmplY3QoZSk7ZS5zdG9wUHJvcGFnYXRpb24oKTt9XG5jYS5yZXNpemluZy5vcmlnaW5hbHg9ZS5wYWdlWDtjYS5yZXNpemluZy5vcmlnaW5hbHk9ZS5wYWdlWTtjYS5yZXNpemluZy5vcmlnaW5hbENhbnZhc1g9UkcuZ2V0Q2FudmFzWFkoY2EpWzBdO2NhLnJlc2l6aW5nLm9yaWdpbmFsQ2FudmFzWT1SRy5nZXRDYW52YXNYWShjYSlbMV07fVxuaWYoY29vcmRzWzBdPihjYS53aWR0aC1yZXNpemVIYW5kbGVTaXplLXJlc2l6ZUhhbmRsZVNpemUpJiZjb29yZHNbMF08Y2Eud2lkdGgtcmVzaXplSGFuZGxlU2l6ZSYmY29vcmRzWzFdPihjYS5oZWlnaHQtcmVzaXplSGFuZGxlU2l6ZSkmJmNvb3Jkc1sxXTxjYS5oZWlnaHQmJmNhLnJlc2l6aW5nLm9yaWdpbmFsdyYmY2EucmVzaXppbmcub3JpZ2luYWx5KXtSRy5maXJlQ3VzdG9tRXZlbnQoY2EuX19vYmplY3RfXywnb25yZXNpemViZWdpbicpO2NhLndpZHRoPWNhLnJlc2l6aW5nLm9yaWdpbmFsdztjYS5oZWlnaHQ9Y2EucmVzaXppbmcub3JpZ2luYWxoO2lmKGNhLl9fbGlua19fJiZjYS5fX2xpbmtfXy5zdHlsZS5kaXNwbGF5PT09J25vbmUnKXtjYS5fX2xpbmtfXy5zdHlsZS5kaXNwbGF5PSdpbmxpbmUnO31cbmlmKHR5cGVvZiBjYS5wYXJlbnROb2RlLmlkPT09J3N0cmluZycmJmNhLnBhcmVudE5vZGUuaWQuc3Vic3RyaW5nKDAsMjQpPT09J3JncmFwaF9yZXNpemVfY29udGFpbmVyXycpe2NhLnBhcmVudE5vZGUuc3R5bGUud2lkdGg9Y2EucmVzaXppbmcub3JpZ2luYWx3KydweCc7Y2EucGFyZW50Tm9kZS5zdHlsZS5oZWlnaHQ9Y2EucmVzaXppbmcub3JpZ2luYWxoKydweCc7fVxuY2Euc3R5bGUuYm9yZGVyPWNhLnJlc2l6aW5nLm9yaWdpbmFsX2Nzc19ib3JkZXI7Y2Euc3R5bGUuYm94U2hhZG93PWNhLnJlc2l6aW5nLm9yaWdpbmFsX2Nzc19zaGFkb3c7Y2Euc3R5bGUubGVmdD0ocGFyc2VJbnQoY2Euc3R5bGUubGVmdCkpKydweCc7Y2Euc3R5bGUudG9wPShwYXJzZUludChjYS5zdHlsZS50b3ApKSsncHgnO2NhLmdldENvbnRleHQoJzJkJykudHJhbnNsYXRlKDAuNSwwLjUpO1JHLmZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCdvbnJlc2l6ZWJlZm9yZWRyYXcnKTt2YXIgb2JqZWN0cz1SRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlDYW52YXNJRChjYS5pZCk7Zm9yKHZhciBpPTA7aTxvYmplY3RzLmxlbmd0aDtpKz0xKXtSRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMob2JqZWN0c1tpXSk7aWYob2JqZWN0c1tpXS5yZXNldCl7b2JqZWN0c1tpXS5yZXNldCgpO31cblJHLnJlZHJhd0NhbnZhcyhvYmplY3RzW2ldLmNhbnZhcyk7fVxuUkcuY2FjaGU9W107aWYoY2EucmVzaXppbmcuZGl2KXtjYS5yZXNpemluZy5kaXYuc3R5bGUud2lkdGg9Y2EuX19vcmlnaW5hbF93aWR0aF9fKydweCc7Y2EucmVzaXppbmcuZGl2LnN0eWxlLmhlaWdodD1jYS5fX29yaWdpbmFsX2hlaWdodF9fKydweCc7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KGNhLl9fb2JqZWN0X18sJ29ucmVzaXplJyk7UkcuZmlyZUN1c3RvbUV2ZW50KGNhLl9fb2JqZWN0X18sJ29ucmVzaXplZW5kJyk7fX07aWYodHlwZW9mIGNhLnJncmFwaF9yZXNpemVfbW91c2Vkb3duX2xpc3RlbmVyX2luc3RhbGxlZCE9J2Jvb2xlYW4nKXtjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLGNhbnZhc19vbm1vdXNlZG93bixmYWxzZSk7Y2EucmdyYXBoX3Jlc2l6ZV9tb3VzZWRvd25fbGlzdGVuZXJfaW5zdGFsbGVkPXRydWU7fX19O30pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnJlc2l6aW5nLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///202\n");

/***/ }),
/* 203 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnNoZWV0cy5qcz83N2M2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57UkdyYXBoLlNoZWV0cz1mdW5jdGlvbihrZXkpXG57dmFyIHdvcmtzaGVldCxjYWxsYmFjayxsZXR0ZXJzPSdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7aWYoYXJndW1lbnRzLmxlbmd0aD09PTMpe3dvcmtzaGVldD1OdW1iZXIoYXJndW1lbnRzWzFdKTtjYWxsYmFjaz1hcmd1bWVudHNbMl07fWVsc2V7d29ya3NoZWV0PTE7Y2FsbGJhY2s9YXJndW1lbnRzWzFdO31cbnZhciB1cmw9J2h0dHBzOi8vc3ByZWFkc2hlZXRzLmdvb2dsZS5jb20vZmVlZHMvY2VsbHMvW0tFWV0vW1dPUktTSEVFVF0vcHVibGljL2Z1bGw/YWx0PWpzb24taW4tc2NyaXB0JmNhbGxiYWNrPV9fcmdyYXBoX0pTT05QQ2FsbGJhY2snLnJlcGxhY2UoL1xcW0tFWVxcXS8sa2V5KS5yZXBsYWNlKC9cXFtXT1JLU0hFRVRcXF0vLHdvcmtzaGVldCk7dGhpcy5sb2FkPWZ1bmN0aW9uKHVybCx1c2VyQ2FsbGJhY2spXG57dmFyIG9iaj10aGlzO19fcmdyYXBoX0pTT05QQ2FsbGJhY2s9ZnVuY3Rpb24oanNvbilcbntvYmouanNvbj1qc29uO3ZhciBncmlkPVtdLHJvdz0wLGNvbD0wO2Zvcih2YXIgaT0wO2k8anNvbi5mZWVkLmVudHJ5Lmxlbmd0aDsrK2kpe3Jvdz1qc29uLmZlZWQuZW50cnlbaV0uZ3MkY2VsbC5yb3ctMTtjb2w9anNvbi5mZWVkLmVudHJ5W2ldLmdzJGNlbGwuY29sLTE7aWYoIWdyaWRbcm93XSl7Z3JpZFtyb3ddPVtdO31cbmdyaWRbcm93XVtjb2xdPWpzb24uZmVlZC5lbnRyeVtpXS5jb250ZW50LiR0O31cbnZhciBtYXhjb2xzPTA7Zm9yKHZhciBpPTA7aTxncmlkLmxlbmd0aDsrK2kpe21heGNvbHM9Z3JpZFtpXT9NYXRoLm1heChtYXhjb2xzLGdyaWRbaV0ubGVuZ3RoKTptYXhjb2xzO31cbmZvcih2YXIgaT0wO2k8Z3JpZC5sZW5ndGg7KytpKXtpZih0eXBlb2YgZ3JpZFtpXT09PSd1bmRlZmluZWQnKXtncmlkW2ldPW5ldyBBcnJheShtYXhjb2xzKTt9XG5mb3IodmFyIGo9MDtqPG1heGNvbHM7aisrKXtpZih0eXBlb2YgZ3JpZFtpXVtqXT09PSd1bmRlZmluZWQnKXtncmlkW2ldW2pdPScnO31cbmlmKGdyaWRbaV1bal0ubWF0Y2goL15bMC05XSskLykpe2dyaWRbaV1bal09cGFyc2VJbnQoZ3JpZFtpXVtqXSk7fWVsc2UgaWYoZ3JpZFtpXVtqXS5tYXRjaCgvXlswLTkuXSskLykpe2dyaWRbaV1bal09cGFyc2VGbG9hdChncmlkW2ldW2pdKTt9fX1cbm9iai5kYXRhPWdyaWQ7dXNlckNhbGxiYWNrKG9iaik7fTt2YXIgc2NyaXB0Tm9kZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtzY3JpcHROb2RlLnNyYz11cmw7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHROb2RlKTt9O3RoaXMucm93PWZ1bmN0aW9uKGluZGV4LHN0YXJ0KVxue3ZhciBvcHQ9e30scm93O3N0YXJ0PXN0YXJ0fHwxO2lmKGFyZ3VtZW50cyYmdHlwZW9mIGFyZ3VtZW50c1syXT09PSdvYmplY3QnJiZ0eXBlb2YgYXJndW1lbnRzWzJdLnRyaW09PT0nYm9vbGVhbicpe29wdC50cmltPWFyZ3VtZW50c1syXS50cmltO31lbHNle29wdC50cmltPXRydWU7fVxucm93PXRoaXMuZGF0YVtpbmRleC0xXS5zbGljZShzdGFydC0xKTtpZihvcHQudHJpbSl7cm93PVJHcmFwaC5hcnJheVRyaW0ocm93KTt9XG5yZXR1cm4gcm93O307dGhpcy5jb2w9ZnVuY3Rpb24oaW5kZXgsc3RhcnQpXG57dmFyIG9wdD17fSxjb2w9W107c3RhcnQ9c3RhcnR8fDE7aWYoYXJndW1lbnRzJiZ0eXBlb2YgYXJndW1lbnRzWzJdPT09J29iamVjdCcmJnR5cGVvZiBhcmd1bWVudHNbMl0udHJpbT09PSdib29sZWFuJyl7b3B0LnRyaW09YXJndW1lbnRzWzJdLnRyaW07fWVsc2V7b3B0LnRyaW09dHJ1ZTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtjb2wucHVzaCh0aGlzLmRhdGFbaV1baW5kZXgtMV0pO31cbmlmKG9wdC50cmltKXtjb2w9UkdyYXBoLmFycmF5VHJpbShjb2wpO31cbmNvbD1jb2wuc2xpY2Uoc3RhcnQtMSk7cmV0dXJuIGNvbDt9O3RoaXMuZ2V0SW5kZXhPZkxldHRlcnM9ZnVuY3Rpb24obClcbnt2YXIgcGFydHM9bC5zcGxpdCgnJyk7aWYocGFydHMubGVuZ3RoPT09MSl7cmV0dXJuIGxldHRlcnMuaW5kZXhPZihsKSsxO31lbHNlIGlmKHBhcnRzLmxlbmd0aD09PTIpe3ZhciBpZHg9KChsZXR0ZXJzLmluZGV4T2YocGFydHNbMF0pKzEpKjI2KSsobGV0dGVycy5pbmRleE9mKHBhcnRzWzFdKSsxKTtyZXR1cm4gaWR4O319XG50aGlzLmdldD1mdW5jdGlvbihzdHIpXG57c3RyPXN0ci50b1VwcGVyQ2FzZSgpO2lmKHN0ci5tYXRjaCgvXlthLXpdKyQvaSkpe2lmKHN0ci5sZW5ndGg9PT0xKXt2YXIgaW5kZXg9bGV0dGVycy5pbmRleE9mKHN0cikrMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsMSxhcmd1bWVudHNbMV0pO31lbHNlIGlmKHN0ci5sZW5ndGg9PT0yKXt2YXIgaW5kZXg9KChsZXR0ZXJzLmluZGV4T2Yoc3RyWzBdKSsxKSoyNikrbGV0dGVycy5pbmRleE9mKHN0clsxXSkrMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsMSxhcmd1bWVudHNbMV0pO319XG5pZihzdHIubWF0Y2goL15bMC05XSskL2kpKXtyZXR1cm4gdGhpcy5yb3coc3RyLG51bGwsYXJndW1lbnRzWzFdKTt9XG5pZihzdHIubWF0Y2goL14oW2Etel17MSwyfSkoWzAtOV0rKSQvaSkpe3ZhciBsZXR0ZXI9UmVnRXhwLiQxLG51bWJlcj1SZWdFeHAuJDIsY29sPXRoaXMuZ2V0KGxldHRlcix7dHJpbTpmYWxzZX0pO3JldHVybiBjb2xbbnVtYmVyLTFdO31cbmlmKHN0ci5tYXRjaCgvXihbYS16XXsxLDJ9KShbMC05XSspOihbYS16XXsxLDJ9KShbMC05XSspJC9pKSl7dmFyIGxldHRlcjE9UmVnRXhwLiQxLG51bWJlcjE9UmVnRXhwLiQyLGxldHRlcjI9UmVnRXhwLiQzLG51bWJlcjI9UmVnRXhwLiQ0XG5pZihsZXR0ZXIxPT09bGV0dGVyMil7dmFyIGNlbGxzPVtdLGluZGV4PXRoaXMuZ2V0SW5kZXhPZkxldHRlcnMobGV0dGVyMSksY29sPXRoaXMuY29sKGluZGV4LG51bGwse3RyaW06ZmFsc2V9KTtmb3IodmFyIGk9KG51bWJlcjEtMSk7aTw9KG51bWJlcjItMSk7KytpKXtjZWxscy5wdXNoKGNvbFtpXSk7fX1lbHNlIGlmKG51bWJlcjE9PT1udW1iZXIyKXt2YXIgY2VsbHM9W10scm93PXRoaXMucm93KG51bWJlcjEsbnVsbCx7dHJpbTpmYWxzZX0pLGluZGV4MT10aGlzLmdldEluZGV4T2ZMZXR0ZXJzKGxldHRlcjEpLGluZGV4Mj10aGlzLmdldEluZGV4T2ZMZXR0ZXJzKGxldHRlcjIpXG5mb3IodmFyIGk9KGluZGV4MS0xKTtpPD0oaW5kZXgyLTEpOysraSl7Y2VsbHMucHVzaChyb3dbaV0pO319XG5pZihhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXS50cmltPT09ZmFsc2Upe31lbHNle2NlbGxzPVJHcmFwaC5hcnJheVRyaW0oY2VsbHMpO31cbnJldHVybiBjZWxsczt9fTt0aGlzLmxvYWQodXJsLGNhbGxiYWNrKTt9O30pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnNoZWV0cy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///203\n");

/***/ }),
/* 204 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.tooltips = {};RG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '10pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', opacity: 0 };RG.tooltip = RG.Tooltip = function (obj, text, x, y, idx, e) {\n    if (RG.trim(text).length === 0) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforetooltip');if (typeof obj.get('chart.tooltips.override') == 'function') {\n      return obj.get('chart.tooltips.override')(obj, text, x, y, idx);\n    }\n    var originalX = x;var originalY = y;text = RG.getTooltipTextFromDIV(text);var timers = RG.Registry.Get('chart.tooltip.timers');if (timers && timers.length) {\n      for (i = 0; i < timers.length; ++i) {\n        clearTimeout(timers[i]);\n      }\n    }\n    RG.Registry.Set('chart.tooltip.timers', []);if (obj.get('chart.contextmenu')) {\n      RG.hideContext();\n    }\n    var tooltipObj = document.createElement('DIV');tooltipObj.className = obj.get('chart.tooltips.css.class');for (var i in RGraph.tooltips.style) {\n      if (typeof i === 'string') {\n        tooltipObj.style[i] = RGraph.tooltips.style[i];\n      }\n    }\n    tooltipObj.innerHTML = text;tooltipObj.__text__ = text;tooltipObj.__canvas__ = obj.canvas;tooltipObj.id = '__rgraph_tooltip_' + obj.canvas.id + '_' + obj.uid + '_' + idx;tooltipObj.__event__ = obj.Get('chart.tooltips.event') || 'click';tooltipObj.__object__ = obj;if (typeof idx === 'number') {\n      tooltipObj.__index__ = idx;origIdx = idx;\n    }\n    if (obj.type === 'line' || obj.type === 'radar') {\n      for (var ds = 0; ds < obj.data.length; ++ds) {\n        if (idx >= obj.data[ds].length) {\n          idx -= obj.data[ds].length;\n        } else {\n          break;\n        }\n      }\n      tooltipObj.__dataset__ = ds;tooltipObj.__index2__ = idx;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth;var height = tooltipObj.offsetHeight;tooltipObj.style.width = width + 'px';var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(obj.canvas);tooltipObj.style.left = e.pageX - (parseFloat(tooltipObj.style.paddingLeft) + width / 2) + 'px';tooltipObj.style.top = e.pageY - height - 10 + 'px';if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.isFixed(obj.canvas)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = e.pageY - scrollTop - height - 10 + 'px';\n    }\n    if (obj.get('chart.tooltips.effect') === 'fade') {\n      for (var i = 1; i <= 10; ++i) {\n        (function (index) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = index / 10;\n          }, index * 25);\n        })(i);\n      }\n    } else {\n      tooltipObj.style.opacity = 1;\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };\n    RG.Registry.Set('chart.tooltip', tooltipObj);RG.fireCustomEvent(obj, 'ontooltip');\n  };RG.getTooltipTextFromDIV = function (text) {\n    var result = /^id:(.*)/.exec(text);if (result && result[1] && document.getElementById(result[1])) {\n      text = document.getElementById(result[1]).innerHTML;\n    } else if (result && result[1]) {\n      text = '';\n    }\n    return text;\n  };RG.getTooltipWidth = function (text, obj) {\n    var div = document.createElement('DIV');div.className = obj.Get('chart.tooltips.css.class');div.style.paddingLeft = RG.tooltips.padding;div.style.paddingRight = RG.tooltips.padding;div.style.fontFamily = RG.tooltips.font_face;div.style.fontSize = RG.tooltips.font_size;div.style.visibility = 'hidden';div.style.position = 'absolute';div.style.top = '300px';div.style.left = 0;div.style.display = 'inline';div.innerHTML = RG.getTooltipTextFromDIV(text);document.body.appendChild(div);return div.offsetWidth;\n  };RG.hideTooltip = RG.HideTooltip = function () {\n    var tooltip = RG.Registry.Get('chart.tooltip');var uid = arguments[0] && arguments[0].uid ? arguments[0].uid : null;if (tooltip && tooltip.parentNode && (!uid || uid == tooltip.__canvas__.uid)) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.Registry.Set('chart.tooltip', null);\n    }\n  };RG.preLoadTooltipImages = RG.PreLoadTooltipImages = function (obj) {\n    var tooltips = obj.Get('chart.tooltips');if (RG.hasTooltips(obj)) {\n      if (obj.type == 'rscatter') {\n        tooltips = [];for (var i = 0; i < obj.data.length; ++i) {\n          tooltips.push(obj.data[3]);\n        }\n      }\n      for (var i = 0; i < tooltips.length; ++i) {\n        var div = document.createElement('DIV');div.style.position = 'absolute';div.style.opacity = 0;div.style.top = '-100px';div.style.left = '-100px';div.innerHTML = tooltips[i];document.body.appendChild(div);var img_tags = div.getElementsByTagName('IMG');for (var j = 0; j < img_tags.length; ++j) {\n          if (img_tags && img_tags[i]) {\n            var img = document.createElement('IMG');img.style.position = 'absolute';img.style.opacity = 0;img.style.top = '-100px';img.style.left = '-100px';img.src = img_tags[i].src;\n            document.body.appendChild(img);setTimeout(function () {\n              document.body.removeChild(img);\n            }, 250);\n          }\n        }\n        document.body.removeChild(div);\n      }\n    }\n  };RG.tooltips_mousemove = RG.Tooltips_mousemove = function (obj, e) {\n    var shape = obj.getShape(e);var changeCursor_tooltips = false;\n    if (shape && typeof shape['index'] == 'number' && obj.Get('chart.tooltips')[shape['index']]) {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;if (obj.Get('chart.tooltips.event') == 'onmousemove') {\n          if (!RG.Registry.Get('chart.tooltip') || RG.Registry.Get('chart.tooltip').__object__.uid != obj.uid || RG.Registry.Get('chart.tooltip').__index__ != shape['index']) {\n            RG.hideTooltip();RG.Clear(obj.canvas);RG.redraw();RG.tooltip(obj, text, e.pageX, e.pageY, shape['index']);obj.Highlight(shape);\n          }\n        }\n      }\n    } else if (shape && typeof shape['index'] == 'number') {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;\n      }\n    }\n    return changeCursor_tooltips;\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnRvb2x0aXBzLmpzP2Y2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aDtSRy50b29sdGlwcz17fTtSRy50b29sdGlwcy5zdHlsZT17ZGlzcGxheTonaW5saW5lLWJsb2NrJyxwb3NpdGlvbjonYWJzb2x1dGUnLHBhZGRpbmc6JzZweCcsZm9udEZhbWlseTonQXJpYWwnLGZvbnRTaXplOicxMHB0Jyxmb250V2VpZ2h0Oidub3JtYWwnLHRleHRBbGlnbjonY2VudGVyJyxsZWZ0OjAsdG9wOjAsYmFja2dyb3VuZENvbG9yOidyZ2IoMjU1LDI1NSwyMzkpJyxjb2xvcjonYmxhY2snLHZpc2liaWxpdHk6J3Zpc2libGUnLHpJbmRleDozLGJvcmRlclJhZGl1czonNXB4Jyxib3hTaGFkb3c6J3JnYmEoOTYsOTYsOTYsMC41KSAwIDAgNXB4JyxvcGFjaXR5OjB9O1JHLnRvb2x0aXA9UkcuVG9vbHRpcD1mdW5jdGlvbihvYmosdGV4dCx4LHksaWR4LGUpXG57aWYoUkcudHJpbSh0ZXh0KS5sZW5ndGg9PT0wKXtyZXR1cm47fVxuUkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb25iZWZvcmV0b29sdGlwJyk7aWYodHlwZW9mKG9iai5nZXQoJ2NoYXJ0LnRvb2x0aXBzLm92ZXJyaWRlJykpPT0nZnVuY3Rpb24nKXtyZXR1cm4gb2JqLmdldCgnY2hhcnQudG9vbHRpcHMub3ZlcnJpZGUnKShvYmosdGV4dCx4LHksaWR4KTt9XG52YXIgb3JpZ2luYWxYPXg7dmFyIG9yaWdpbmFsWT15O3RleHQ9UkcuZ2V0VG9vbHRpcFRleHRGcm9tRElWKHRleHQpO3ZhciB0aW1lcnM9UkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwLnRpbWVycycpO2lmKHRpbWVycyYmdGltZXJzLmxlbmd0aCl7Zm9yKGk9MDtpPHRpbWVycy5sZW5ndGg7KytpKXtjbGVhclRpbWVvdXQodGltZXJzW2ldKTt9fVxuUkcuUmVnaXN0cnkuU2V0KCdjaGFydC50b29sdGlwLnRpbWVycycsW10pO2lmKG9iai5nZXQoJ2NoYXJ0LmNvbnRleHRtZW51Jykpe1JHLmhpZGVDb250ZXh0KCk7fVxudmFyIHRvb2x0aXBPYmo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7dG9vbHRpcE9iai5jbGFzc05hbWU9b2JqLmdldCgnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJyk7Zm9yKHZhciBpIGluIFJHcmFwaC50b29sdGlwcy5zdHlsZSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7dG9vbHRpcE9iai5zdHlsZVtpXT1SR3JhcGgudG9vbHRpcHMuc3R5bGVbaV07fX1cbnRvb2x0aXBPYmouaW5uZXJIVE1MPXRleHQ7dG9vbHRpcE9iai5fX3RleHRfXz10ZXh0O3Rvb2x0aXBPYmouX19jYW52YXNfXz1vYmouY2FudmFzO3Rvb2x0aXBPYmouaWQ9J19fcmdyYXBoX3Rvb2x0aXBfJytvYmouY2FudmFzLmlkKydfJytvYmoudWlkKydfJytpZHg7dG9vbHRpcE9iai5fX2V2ZW50X189b2JqLkdldCgnY2hhcnQudG9vbHRpcHMuZXZlbnQnKXx8J2NsaWNrJzt0b29sdGlwT2JqLl9fb2JqZWN0X189b2JqO2lmKHR5cGVvZiBpZHg9PT0nbnVtYmVyJyl7dG9vbHRpcE9iai5fX2luZGV4X189aWR4O29yaWdJZHg9aWR4O31cbmlmKG9iai50eXBlPT09J2xpbmUnfHxvYmoudHlwZT09PSdyYWRhcicpe2Zvcih2YXIgZHM9MDtkczxvYmouZGF0YS5sZW5ndGg7Kytkcyl7aWYoaWR4Pj1vYmouZGF0YVtkc10ubGVuZ3RoKXtpZHgtPW9iai5kYXRhW2RzXS5sZW5ndGg7fWVsc2V7YnJlYWs7fX1cbnRvb2x0aXBPYmouX19kYXRhc2V0X189ZHM7dG9vbHRpcE9iai5fX2luZGV4Ml9fPWlkeDt9XG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBPYmopO3ZhciB3aWR0aD10b29sdGlwT2JqLm9mZnNldFdpZHRoO3ZhciBoZWlnaHQ9dG9vbHRpcE9iai5vZmZzZXRIZWlnaHQ7dG9vbHRpcE9iai5zdHlsZS53aWR0aD13aWR0aCsncHgnO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIGNhbnZhc1hZPVJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3Rvb2x0aXBPYmouc3R5bGUubGVmdD1lLnBhZ2VYLShwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUucGFkZGluZ0xlZnQpKyh3aWR0aC8yKSkrJ3B4Jzt0b29sdGlwT2JqLnN0eWxlLnRvcD1lLnBhZ2VZLWhlaWdodC0xMCsncHgnO2lmKHBhcnNlRmxvYXQodG9vbHRpcE9iai5zdHlsZS5sZWZ0KTw9NSl7dG9vbHRpcE9iai5zdHlsZS5sZWZ0PSc1cHgnO31cbmlmKHBhcnNlRmxvYXQodG9vbHRpcE9iai5zdHlsZS5sZWZ0KStwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUud2lkdGgpPndpbmRvdy5pbm5lcldpZHRoKXt0b29sdGlwT2JqLnN0eWxlLmxlZnQ9JydcbnRvb2x0aXBPYmouc3R5bGUucmlnaHQ9JzVweCd9XG5pZihSRy5pc0ZpeGVkKG9iai5jYW52YXMpKXt2YXIgc2Nyb2xsVG9wPXdpbmRvdy5zY3JvbGxZfHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO3Rvb2x0aXBPYmouc3R5bGUucG9zaXRpb249J2ZpeGVkJzt0b29sdGlwT2JqLnN0eWxlLnRvcD1lLnBhZ2VZLXNjcm9sbFRvcC1oZWlnaHQtMTArJ3B4Jzt9XG5pZihvYmouZ2V0KCdjaGFydC50b29sdGlwcy5lZmZlY3QnKT09PSdmYWRlJyl7Zm9yKHZhciBpPTE7aTw9MTA7KytpKXsoZnVuY3Rpb24oaW5kZXgpXG57c2V0VGltZW91dChmdW5jdGlvbigpXG57dG9vbHRpcE9iai5zdHlsZS5vcGFjaXR5PWluZGV4LzEwO30saW5kZXgqMjUpO30pKGkpO319ZWxzZXt0b29sdGlwT2JqLnN0eWxlLm9wYWNpdHk9MTt9XG50b29sdGlwT2JqLm9ubW91c2Vkb3duPWZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCk7fVxudG9vbHRpcE9iai5vbm1vdXNldXA9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTt9XG50b29sdGlwT2JqLm9uY2xpY2s9ZnVuY3Rpb24oZSl7aWYoZS5idXR0b249PTApe2Uuc3RvcFByb3BhZ2F0aW9uKCk7fX1cblJHLlJlZ2lzdHJ5LlNldCgnY2hhcnQudG9vbHRpcCcsdG9vbHRpcE9iaik7UkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb250b29sdGlwJyk7fTtSRy5nZXRUb29sdGlwVGV4dEZyb21ESVY9ZnVuY3Rpb24odGV4dClcbnt2YXIgcmVzdWx0PS9eaWQ6KC4qKS8uZXhlYyh0ZXh0KTtpZihyZXN1bHQmJnJlc3VsdFsxXSYmZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVzdWx0WzFdKSl7dGV4dD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChyZXN1bHRbMV0pLmlubmVySFRNTDt9ZWxzZSBpZihyZXN1bHQmJnJlc3VsdFsxXSl7dGV4dD0nJzt9XG5yZXR1cm4gdGV4dDt9O1JHLmdldFRvb2x0aXBXaWR0aD1mdW5jdGlvbih0ZXh0LG9iailcbnt2YXIgZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5jbGFzc05hbWU9b2JqLkdldCgnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJyk7ZGl2LnN0eWxlLnBhZGRpbmdMZWZ0PVJHLnRvb2x0aXBzLnBhZGRpbmc7ZGl2LnN0eWxlLnBhZGRpbmdSaWdodD1SRy50b29sdGlwcy5wYWRkaW5nO2Rpdi5zdHlsZS5mb250RmFtaWx5PVJHLnRvb2x0aXBzLmZvbnRfZmFjZTtkaXYuc3R5bGUuZm9udFNpemU9UkcudG9vbHRpcHMuZm9udF9zaXplO2Rpdi5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS50b3A9JzMwMHB4JztkaXYuc3R5bGUubGVmdD0wO2Rpdi5zdHlsZS5kaXNwbGF5PSdpbmxpbmUnO2Rpdi5pbm5lckhUTUw9UkcuZ2V0VG9vbHRpcFRleHRGcm9tRElWKHRleHQpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtyZXR1cm4gZGl2Lm9mZnNldFdpZHRoO307UkcuaGlkZVRvb2x0aXA9UkcuSGlkZVRvb2x0aXA9ZnVuY3Rpb24oKVxue3ZhciB0b29sdGlwPVJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcCcpO3ZhciB1aWQ9YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0udWlkP2FyZ3VtZW50c1swXS51aWQ6bnVsbDtpZih0b29sdGlwJiZ0b29sdGlwLnBhcmVudE5vZGUmJighdWlkfHx1aWQ9PXRvb2x0aXAuX19jYW52YXNfXy51aWQpKXt0b29sdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9vbHRpcCk7dG9vbHRpcC5zdHlsZS5kaXNwbGF5PSdub25lJzt0b29sdGlwLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbic7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC50b29sdGlwJyxudWxsKTt9fTtSRy5wcmVMb2FkVG9vbHRpcEltYWdlcz1SRy5QcmVMb2FkVG9vbHRpcEltYWdlcz1mdW5jdGlvbihvYmopXG57dmFyIHRvb2x0aXBzPW9iai5HZXQoJ2NoYXJ0LnRvb2x0aXBzJyk7aWYoUkcuaGFzVG9vbHRpcHMob2JqKSl7aWYob2JqLnR5cGU9PSdyc2NhdHRlcicpe3Rvb2x0aXBzPVtdO2Zvcih2YXIgaT0wO2k8b2JqLmRhdGEubGVuZ3RoOysraSl7dG9vbHRpcHMucHVzaChvYmouZGF0YVszXSk7fX1cbmZvcih2YXIgaT0wO2k8dG9vbHRpcHMubGVuZ3RoOysraSl7dmFyIGRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUub3BhY2l0eT0wO2Rpdi5zdHlsZS50b3A9Jy0xMDBweCc7ZGl2LnN0eWxlLmxlZnQ9Jy0xMDBweCc7ZGl2LmlubmVySFRNTD10b29sdGlwc1tpXTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7dmFyIGltZ190YWdzPWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU1HJyk7Zm9yKHZhciBqPTA7ajxpbWdfdGFncy5sZW5ndGg7KytqKXtpZihpbWdfdGFncyYmaW1nX3RhZ3NbaV0pe3ZhciBpbWc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7aW1nLnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7aW1nLnN0eWxlLm9wYWNpdHk9MDtpbWcuc3R5bGUudG9wPSctMTAwcHgnO2ltZy5zdHlsZS5sZWZ0PSctMTAwcHgnO2ltZy5zcmM9aW1nX3RhZ3NbaV0uc3JjXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7c2V0VGltZW91dChmdW5jdGlvbigpe2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTt9LDI1MCk7fX1cbmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTt9fX07UkcudG9vbHRpcHNfbW91c2Vtb3ZlPVJHLlRvb2x0aXBzX21vdXNlbW92ZT1mdW5jdGlvbihvYmosZSlcbnt2YXIgc2hhcGU9b2JqLmdldFNoYXBlKGUpO3ZhciBjaGFuZ2VDdXJzb3JfdG9vbHRpcHM9ZmFsc2VcbmlmKHNoYXBlJiZ0eXBlb2Yoc2hhcGVbJ2luZGV4J10pPT0nbnVtYmVyJyYmb2JqLkdldCgnY2hhcnQudG9vbHRpcHMnKVtzaGFwZVsnaW5kZXgnXV0pe3ZhciB0ZXh0PVJHLnBhcnNlVG9vbHRpcFRleHQob2JqLkdldCgnY2hhcnQudG9vbHRpcHMnKSxzaGFwZVsnaW5kZXgnXSk7aWYodGV4dCl7Y2hhbmdlQ3Vyc29yX3Rvb2x0aXBzPXRydWU7aWYob2JqLkdldCgnY2hhcnQudG9vbHRpcHMuZXZlbnQnKT09J29ubW91c2Vtb3ZlJyl7aWYoIVJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcCcpfHxSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LnRvb2x0aXAnKS5fX29iamVjdF9fLnVpZCE9b2JqLnVpZHx8UkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwJykuX19pbmRleF9fIT1zaGFwZVsnaW5kZXgnXSl7UkcuaGlkZVRvb2x0aXAoKTtSRy5DbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXcoKTtSRy50b29sdGlwKG9iaix0ZXh0LGUucGFnZVgsZS5wYWdlWSxzaGFwZVsnaW5kZXgnXSk7b2JqLkhpZ2hsaWdodChzaGFwZSk7fX19fWVsc2UgaWYoc2hhcGUmJnR5cGVvZihzaGFwZVsnaW5kZXgnXSk9PSdudW1iZXInKXt2YXIgdGV4dD1SRy5wYXJzZVRvb2x0aXBUZXh0KG9iai5HZXQoJ2NoYXJ0LnRvb2x0aXBzJyksc2hhcGVbJ2luZGV4J10pO2lmKHRleHQpe2NoYW5nZUN1cnNvcl90b29sdGlwcz10cnVlfX1cbnJldHVybiBjaGFuZ2VDdXJzb3JfdG9vbHRpcHM7fTt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi50b29sdGlwcy5qcyJdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///204\n");

/***/ }),
/* 205 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.zoom = RG.Zoom = function (e) {\n    e = RGraph.fixEventObject(e);if (e && e.target && e.target.__canvas__) {\n      var canvas = e.target.__canvas__;\n    } else if (e && e.target && e.target.__object__) {\n      var canvas = e.target.__object__.canvas;e.stopPropagation();\n    }\n    if (!canvas) {\n      var registry_canvas = RGraph.Registry.get('chart.contextmenu').__canvas__;if (registry_canvas) {\n        var canvas = registry_canvas;\n      }\n    }\n    var obj = canvas.__object__;var context = obj.context;var dataurl = canvas.toDataURL();var tmp = canvas;var coords = RG.getCanvasXY(canvas);var factor = obj.Get('chart.zoom.factor') - 1;var x = coords[0];var y = coords[1];var img = document.createElement('img');img.className = 'RGraph_zoomed_canvas';img.style.border = '1px solid #ccc';img.style.width = canvas.width + 'px';img.style.height = canvas.height + 'px';img.style.position = 'absolute';img.style.left = x + 'px';img.style.top = y + 'px';img.style.backgroundColor = 'white';img.style.opacity = obj.Get('chart.zoom.fade.in') ? 0 : 1;img.style.zIndex = 99;img.src = dataurl;document.body.appendChild(img);RGraph.zoom_image = img;RGraph.zoom_image.obj = obj;img.onclick = function (e) {\n      e = RGraph.fixEventObject(e);e.stopPropagation();return false;\n    };\n    var width = parseInt(canvas.width);var height = parseInt(canvas.height);var frames = obj.Get('chart.zoom.frames');var delay = obj.Get('chart.zoom.delay');if (obj.Get('chart.zoom.hdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = x + canvas.width / 2 - newWidth / 2;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.hdir') == 'left') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = rightHandEdge - newWidth;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.vdir') == 'up') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.vdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height / 2 + newHeight / 2;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.height = '\" + String(height * factor * (i / frames) + height) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.fade.in')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.opacity = \" + Number(i / frames), i * (delay / 2));\n      }\n    }\n    if (obj.Get('chart.zoom.shadow')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.boxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.MozBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.WebkitBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);\n      }\n    }\n    var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.position = 'fixed';div.style.top = 0;div.style.left = 0;div.style.width = screen.width + 100 + 'px';div.style.height = screen.height + 100 + 'px';div.style.zIndex = 98;div.onclick = div.oncontextmenu = function (e) {\n      return RG.hideZoomedCanvas(e);\n    };\n    div.origHeight = div.style.height;document.body.appendChild(div);RG.zoom_background = div;for (var i = 1; i <= frames; ++i) {\n      setTimeout(\"RGraph.zoom_background.style.opacity = \" + Number(i / frames) * 0.8, i * (delay / 2));\n    }\n    RG.fireCustomEvent(obj, 'onzoom');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnpvb20uanM/MTc4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLnpvb209UkcuWm9vbT1mdW5jdGlvbihlKVxue2U9UkdyYXBoLmZpeEV2ZW50T2JqZWN0KGUpO2lmKGUmJmUudGFyZ2V0JiZlLnRhcmdldC5fX2NhbnZhc19fKXt2YXIgY2FudmFzPWUudGFyZ2V0Ll9fY2FudmFzX187fWVsc2UgaWYoZSYmZS50YXJnZXQmJmUudGFyZ2V0Ll9fb2JqZWN0X18pe3ZhciBjYW52YXM9ZS50YXJnZXQuX19vYmplY3RfXy5jYW52YXM7ZS5zdG9wUHJvcGFnYXRpb24oKTt9XG5pZighY2FudmFzKXt2YXIgcmVnaXN0cnlfY2FudmFzPVJHcmFwaC5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykuX19jYW52YXNfXztpZihyZWdpc3RyeV9jYW52YXMpe3ZhciBjYW52YXM9cmVnaXN0cnlfY2FudmFzO319XG52YXIgb2JqPWNhbnZhcy5fX29iamVjdF9fO3ZhciBjb250ZXh0PW9iai5jb250ZXh0O3ZhciBkYXRhdXJsPWNhbnZhcy50b0RhdGFVUkwoKTt2YXIgdG1wPWNhbnZhczt2YXIgY29vcmRzPVJHLmdldENhbnZhc1hZKGNhbnZhcyk7dmFyIGZhY3Rvcj1vYmouR2V0KCdjaGFydC56b29tLmZhY3RvcicpLTE7dmFyIHg9Y29vcmRzWzBdO3ZhciB5PWNvb3Jkc1sxXTt2YXIgaW1nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO2ltZy5jbGFzc05hbWU9J1JHcmFwaF96b29tZWRfY2FudmFzJztpbWcuc3R5bGUuYm9yZGVyPScxcHggc29saWQgI2NjYyc7aW1nLnN0eWxlLndpZHRoPWNhbnZhcy53aWR0aCsncHgnO2ltZy5zdHlsZS5oZWlnaHQ9Y2FudmFzLmhlaWdodCsncHgnO2ltZy5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2ltZy5zdHlsZS5sZWZ0PXgrJ3B4JztpbWcuc3R5bGUudG9wPXkrJ3B4JztpbWcuc3R5bGUuYmFja2dyb3VuZENvbG9yPSd3aGl0ZSc7aW1nLnN0eWxlLm9wYWNpdHk9b2JqLkdldCgnY2hhcnQuem9vbS5mYWRlLmluJyk/MDoxO2ltZy5zdHlsZS56SW5kZXg9OTk7aW1nLnNyYz1kYXRhdXJsO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtSR3JhcGguem9vbV9pbWFnZT1pbWc7UkdyYXBoLnpvb21faW1hZ2Uub2JqPW9iajtpbWcub25jbGljaz1mdW5jdGlvbihlKVxue2U9UkdyYXBoLmZpeEV2ZW50T2JqZWN0KGUpO2Uuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIGZhbHNlO31cbnZhciB3aWR0aD1wYXJzZUludChjYW52YXMud2lkdGgpO3ZhciBoZWlnaHQ9cGFyc2VJbnQoY2FudmFzLmhlaWdodCk7dmFyIGZyYW1lcz1vYmouR2V0KCdjaGFydC56b29tLmZyYW1lcycpO3ZhciBkZWxheT1vYmouR2V0KCdjaGFydC56b29tLmRlbGF5Jyk7aWYob2JqLkdldCgnY2hhcnQuem9vbS5oZGlyJyk9PSdjZW50ZXInKXtmb3IodmFyIGk9MTtpPD1mcmFtZXM7KytpKXt2YXIgbmV3V2lkdGg9d2lkdGgqZmFjdG9yKihpL2ZyYW1lcykrd2lkdGg7dmFyIHJpZ2h0SGFuZEVkZ2U9eCtjYW52YXMud2lkdGg7dmFyIG5ld0xlZnQ9KHgrKGNhbnZhcy53aWR0aC8yKSktKG5ld1dpZHRoLzIpO3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS53aWR0aCA9ICdcIitTdHJpbmcobmV3V2lkdGgpK1wicHgnOyBSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5sZWZ0ID0gJ1wiK25ld0xlZnQrXCJweCdcIixpKmRlbGF5KTt9fWVsc2UgaWYob2JqLkdldCgnY2hhcnQuem9vbS5oZGlyJyk9PSdsZWZ0Jyl7Zm9yKHZhciBpPTE7aTw9ZnJhbWVzOysraSl7dmFyIG5ld1dpZHRoPXdpZHRoKmZhY3RvciooaS9mcmFtZXMpK3dpZHRoO3ZhciByaWdodEhhbmRFZGdlPXgrY2FudmFzLndpZHRoO3ZhciBuZXdMZWZ0PXJpZ2h0SGFuZEVkZ2UtbmV3V2lkdGg7c2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLndpZHRoID0gJ1wiK1N0cmluZyhuZXdXaWR0aCkrXCJweCc7IFJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmxlZnQgPSAnXCIrbmV3TGVmdCtcInB4J1wiLGkqZGVsYXkpO319ZWxzZXtmb3IodmFyIGk9MTtpPD1mcmFtZXM7KytpKXt2YXIgbmV3V2lkdGg9d2lkdGgqZmFjdG9yKihpL2ZyYW1lcykrd2lkdGg7c2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLndpZHRoID0gJ1wiK1N0cmluZyhuZXdXaWR0aCkrXCJweCdcIixpKmRlbGF5KTt9fVxuaWYob2JqLkdldCgnY2hhcnQuem9vbS52ZGlyJyk9PSd1cCcpe2Zvcih2YXIgaT0xO2k8PWZyYW1lczsrK2kpe3ZhciBuZXdIZWlnaHQ9KGhlaWdodCpmYWN0b3IqKGkvZnJhbWVzKSkraGVpZ2h0O3ZhciBib3R0b21FZGdlPXkrY2FudmFzLmhlaWdodDt2YXIgbmV3VG9wPWJvdHRvbUVkZ2UtbmV3SGVpZ2h0O3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5oZWlnaHQgPSAnXCIrU3RyaW5nKG5ld0hlaWdodCkrXCJweCc7IFJHcmFwaC56b29tX2ltYWdlLnN0eWxlLnRvcCA9ICdcIituZXdUb3ArXCJweCdcIixpKmRlbGF5KTt9fWVsc2UgaWYob2JqLkdldCgnY2hhcnQuem9vbS52ZGlyJyk9PSdjZW50ZXInKXtmb3IodmFyIGk9MTtpPD1mcmFtZXM7KytpKXt2YXIgbmV3SGVpZ2h0PShoZWlnaHQqZmFjdG9yKihpL2ZyYW1lcykpK2hlaWdodDt2YXIgYm90dG9tRWRnZT0oeSsoY2FudmFzLmhlaWdodC8yKSkrKG5ld0hlaWdodC8yKTt2YXIgbmV3VG9wPWJvdHRvbUVkZ2UtbmV3SGVpZ2h0O3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5oZWlnaHQgPSAnXCIrU3RyaW5nKG5ld0hlaWdodCkrXCJweCc7IFJHcmFwaC56b29tX2ltYWdlLnN0eWxlLnRvcCA9ICdcIituZXdUb3ArXCJweCdcIixpKmRlbGF5KTt9fWVsc2V7Zm9yKHZhciBpPTE7aTw9ZnJhbWVzOysraSl7c2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmhlaWdodCA9ICdcIitTdHJpbmcoaGVpZ2h0KmZhY3RvciooaS9mcmFtZXMpK2hlaWdodCkrXCJweCdcIixpKmRlbGF5KTt9fVxuaWYob2JqLkdldCgnY2hhcnQuem9vbS5mYWRlLmluJykpe2Zvcih2YXIgaT0xO2k8PWZyYW1lczsrK2kpe3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5vcGFjaXR5ID0gXCIrTnVtYmVyKGkvZnJhbWVzKSxpKihkZWxheS8yKSk7fX1cbmlmKG9iai5HZXQoJ2NoYXJ0Lnpvb20uc2hhZG93Jykpe2Zvcih2YXIgaT0xO2k8PWZyYW1lczsrK2kpe3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5ib3hTaGFkb3cgPSAncmdiYSgxMjgsMTI4LDEyOCxcIitOdW1iZXIoaS9mcmFtZXMpLzIrXCIpIDAgMCAyNXB4J1wiLGkqZGVsYXkpO3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5Nb3pCb3hTaGFkb3cgPSAncmdiYSgxMjgsMTI4LDEyOCxcIitOdW1iZXIoaS9mcmFtZXMpLzIrXCIpIDAgMCAyNXB4J1wiLGkqZGVsYXkpO3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5XZWJraXRCb3hTaGFkb3cgPSAncmdiYSgxMjgsMTI4LDEyOCxcIitOdW1iZXIoaS9mcmFtZXMpLzIrXCIpIDAgMCAyNXB4J1wiLGkqZGVsYXkpO319XG52YXIgZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J3doaXRlJztkaXYuc3R5bGUub3BhY2l0eT0wO2Rpdi5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO2Rpdi5zdHlsZS50b3A9MDtkaXYuc3R5bGUubGVmdD0wO2Rpdi5zdHlsZS53aWR0aD0oc2NyZWVuLndpZHRoKzEwMCkrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PShzY3JlZW4uaGVpZ2h0KzEwMCkrJ3B4JztkaXYuc3R5bGUuekluZGV4PTk4O2Rpdi5vbmNsaWNrPWRpdi5vbmNvbnRleHRtZW51PWZ1bmN0aW9uKGUpXG57cmV0dXJuIFJHLmhpZGVab29tZWRDYW52YXMoZSk7fVxuZGl2Lm9yaWdIZWlnaHQ9ZGl2LnN0eWxlLmhlaWdodDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7Ukcuem9vbV9iYWNrZ3JvdW5kPWRpdjtmb3IodmFyIGk9MTtpPD1mcmFtZXM7KytpKXtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21fYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gXCIrKE51bWJlcihpL2ZyYW1lcykqMC44KSxpKihkZWxheS8yKSk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb256b29tJyk7fX0pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnpvb20uanMiXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///205\n");

/***/ }),
/* 206 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CornerGauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.min === 'number' && typeof conf.max === 'number' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'cornergauge';this.min = min;this.max = max;this.value = RGraph.stringsToNumbers(value);this.angles = {};this.angles.needle = [];this.centerpin = {};this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.strokestyle': 'black', 'chart.linewidth': 2, 'chart.title': '', 'chart.title.vpos': 0.5, 'chart.title.size': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.text.font': 'Arial', 'chart.text.color': '#666', 'chart.text.size': 10, 'chart.background.gradient.color1': '#ddd', 'chart.background.gradient.color2': 'white', 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.resizable': false, 'chart.chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.colors.ranges': null, 'chart.red.start': min + 0.9 * (this.max - min), 'chart.green.end': min + 0.7 * (this.max - min), 'chart.red.color': 'red', 'chart.yellow.color': 'yellow', 'chart.green.color': '#0f0', 'chart.value.text': true, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.value.text.boxed': true, 'chart.value.text.font': 'Arial', 'chart.value.text.size': 18, 'chart.value.text.bold': false, 'chart.value.text.decimals': 0, 'chart.centerpin.stroke': 'rgba(0,0,0,0)', 'chart.centerpin.fill': null, 'chart.centerpin.color': 'blue', 'chart.needle.colors': ['#ccc', '#D5604D', 'red', 'green', 'yellow'], 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph;var ca = this.canvas;var co = ca.getContext('2d');var prop = this.properties;var jq = jQuery;var pa = RG.Path;var win = window;var doc = document;var ma = Math;this.set = this.Set = function (name, value) {\n    if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    name = name.toLowerCase();if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (typeof this.gutterLeft == 'undefined') {\n      this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];\n    }\n    this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom);if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];this.centerx = ca.width / 2 - this.radius / 2 + Math.max(30, this.radius * 0.1);this.centery = ca.height / 2 + this.radius / 2 - this.radius * 0.1;this.coordsText = [];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawBackGround();this.DrawTickmarks();this.DrawColorBands();this.DrawLabel();this.DrawLabels();if (_typeof(this.value) === 'object') {\n      for (var i = 0, len = this.value.length; i < len; ++i) {\n        this.DrawNeedle(i, this.value[i], this.radius - 65);\n      }\n    } else {\n      this.DrawNeedle(0, this.value, this.radius - 65);\n    }\n    this.DrawCenterpin();var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;\n    prop['chart.title.y'] = this.centery + 20 - this.radius - 1.5 * size / 2;RGraph.DrawTitle(this, prop['chart.title'], this.guttertop, this.centerx + this.radius / 2, size);if (prop['chart.contextmenu']) {\n      RGraph.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RGraph.AllowResizing(this);\n    }\n    RGraph.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RGraph.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, false);co.stroke();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.stroke();RG.NoShadow(this);co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.stroke();RGraph.NoShadow(this);co.lineWidth = 0;co.fillStyle = RGraph.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius * 0.5, prop['chart.background.gradient.color1'], prop['chart.background.gradient.color2']);co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.lineTo(this.centerx - 20, this.centery + 20 - this.radius);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.beginPath();co.lineWidth = 1;co.strokeStyle = '#eee';for (var i = 0; i <= 5; ++i) {\n      var p1 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, 30);var p2 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, this.radius - 90);co.moveTo(p1[0], p1[1]);co.lineTo(p2[0], p2[1]);\n    }\n    co.stroke();\n  };this.drawNeedle = this.DrawNeedle = function (index, value, radius) {\n    var grad = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, 20, 'rgba(0,0,0,0)', prop['chart.needle.colors'][index]);\n    this.angles.needle[index] = (value - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.lineWidth = 1;\n    co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = grad;co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] - RG.HALFPI, this.angles.needle[index] - RG.HALFPI + 0.000001, false);co.arc(this.centerx, this.centery, radius - 30, this.angles.needle[index], this.angles.needle[index] + 0.000001, false);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] + RG.HALFPI, this.angles.needle[index] + RG.HALFPI + 0.000001, false);co.stroke();co.fill();\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (!prop['chart.centerpin.fill']) {\n      prop['chart.centerpin.fill'] = RG.RadialGradient(this, this.centerx + 5, this.centery - 5, 0, this.centerx + 5, this.centery - 5, 20, 'white', prop['chart.centerpin.color']);\n    }\n    co.strokeStyle = prop['chart.centerpin.stroke'];co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.lineWidth = 2;co.arc(this.centerx, this.centery, 15, 0, RGraph.TWOPI, false);co.stroke();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var numLabels = 6;co.fillStyle = prop['chart.text.color'];for (var i = 0; i < numLabels; ++i) {\n      co.beginPath();var num = Number(this.min + (this.max - this.min) * (i / (numLabels - 1))).toFixed(prop['chart.scale.decimals']);num = RG.number_format(this, num, prop['chart.units.pre'], prop['chart.units.post']);var angle = i * 18 / (180 / RG.PI);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx + ma.sin(angle) * (this.radius - 53), 'y': this.centery - ma.cos(angle) * (this.radius - 53), 'text': String(num), 'valign': 'top', 'halign': 'center', 'angle': 90 * (i / (numLabels - 1)), 'tag': 'scale' });co.fill();\n    }\n  };this.drawTickmarks = this.DrawTickmarks = function () {\n    var bigTicks = 5;var smallTicks = 25;for (var i = 0; i < smallTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (smallTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 44, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 46, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n    for (var i = 0; i < bigTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (bigTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 43, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 47, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n  };this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0, len = ranges.length; i < len; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), false);co.arc(this.centerx, this.centery, this.radius - 54 - 10 - prop['chart.text.size'] * 1.5, (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = RG.PI + RG.HALFPI;var greenEnd = greenStart + (RG.TWOPI - greenStart) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = (prop['chart.red.start'] - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = RGraph.TWOPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, redEnd, redStart, true);co.fill();\n  };this.drawLabel = this.DrawLabel = function () {\n    if (prop['chart.value.text']) {\n      co.strokeStyle = prop['chart.text.color'];co.fillStyle = prop['chart.text.color'];var value = typeof this.value == 'number' ? this.value.toFixed(prop['chart.value.text.decimals']) : this.value;if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n        for (var i = 0; i < value.length; ++i) {\n          value[i] = parseFloat(value[i]).toFixed(prop['chart.value.text.decimals']);\n        }\n        value = value.toString();\n      }\n      RG.Text2(this, { 'font': prop['chart.value.text.font'], 'size': prop['chart.value.text.size'], 'x': this.centerx + ma.cos(RG.PI / 180 * 45) * (this.radius / 3), 'y': this.centery - ma.sin(RG.PI / 180 * 45) * (this.radius / 3), 'text': prop['chart.value.text.units.pre'] + value + prop['chart.value.text.units.post'], 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.value.text.boxed'], 'boundingFill': 'white', 'bold': prop['chart.value.text.bold'], 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle > RG.TWOPI && angle < RG.PI + RG.HALFPI) {\n      return null;\n    }\n    var value = (angle - (RG.PI + RG.HALFPI)) / (RG.TWOPI - (RG.PI + RG.HALFPI)) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    if (mouseX > this.centerx && mouseY > this.centery) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - 5 && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + 5 && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.Clear(ca);RG.RedrawCanvas(ca);RG.FireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.HALFPI;\n    angle += RG.PI + RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    if (!RG.is_null(prop['chart.colors.ranges'])) {\n      for (var i = 0; i < prop['chart.colors.ranges'].length; ++i) {\n        prop['chart.colors.ranges'][i][2] = this.parseSingleColorForGradient(prop['chart.colors.ranges'][i][2]);\n      }\n    } else {\n      prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var radius_start = this.radius - 54 - prop['chart.text.size'];var radius_end = radius_start - 15;var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, radius_end);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    this[type] = func;return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0];var callback = arguments[1];var numFrames = 30;var frame = 0;var obj = this;if (typeof this.value === 'number') {\n      var origValue = Number(this.currentValue);if (this.currentValue === null) {\n        this.currentValue = this.min;origValue = this.min;\n      }\n      var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;var iterator = function iterator() {\n        frame++;obj.value = frame / numFrames * diff + origValue;\n        if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.Clear(obj.canvas);RGraph.RedrawCanvas(obj.canvas);if (frame < 30) {\n          RGraph.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];var step = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);step[i] = diff[i] / numFrames;\n      }\n      var max = this.max;var min = this.min;var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / numFrames * diff[i] + origValue[i];if (obj.value[i] > max) obj.value[i] = max;if (obj.value[i] < min) obj.value[i] = min;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n        }\n        if (frame < 30) {\n          RG.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };\n  RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29ybmVyZ2F1Z2UuanM/ZmJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkNvcm5lckdhdWdlPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYubWluPT09J251bWJlcicmJnR5cGVvZiBjb25mLm1heD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi52YWx1ZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgaWQ9Y29uZi5pZFxudmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbj1jb25mLm1pbjt2YXIgbWF4PWNvbmYubWF4O3ZhciB2YWx1ZT1jb25mLnZhbHVlO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmY7dmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbj1hcmd1bWVudHNbMV07dmFyIG1heD1hcmd1bWVudHNbMl07dmFyIHZhbHVlPWFyZ3VtZW50c1szXTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWNhbnZhczt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dD90aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIix7YWxwaGE6KHR5cGVvZiBpZD09PSdvYmplY3QnJiZpZC5hbHBoYT09PWZhbHNlKT9mYWxzZTp0cnVlfSk6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy50eXBlPSdjb3JuZXJnYXVnZSc7dGhpcy5taW49bWluO3RoaXMubWF4PW1heDt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmFuZ2xlcz17fTt0aGlzLmFuZ2xlcy5uZWVkbGU9W107dGhpcy5jZW50ZXJwaW49e307dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMuY3VycmVudFZhbHVlPW51bGw7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTtpZih0eXBlb2YodGhpcy52YWx1ZSk9PSdvYmplY3QnKXtmb3IodmFyIGk9MDtpPHRoaXMudmFsdWUubGVuZ3RoOysraSl7aWYodGhpcy52YWx1ZVtpXT50aGlzLm1heCl0aGlzLnZhbHVlW2ldPW1heDtpZih0aGlzLnZhbHVlW2ldPHRoaXMubWluKXRoaXMudmFsdWVbaV09bWluO319ZWxzZXtpZih0aGlzLnZhbHVlPnRoaXMubWF4KXRoaXMudmFsdWU9bWF4O2lmKHRoaXMudmFsdWU8dGhpcy5taW4pdGhpcy52YWx1ZT1taW47fVxudGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQucmFkaXVzJzpudWxsLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQuc3Ryb2tlc3R5bGUnOidibGFjaycsJ2NoYXJ0LmxpbmV3aWR0aCc6MiwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS52cG9zJzowLjUsJ2NoYXJ0LnRpdGxlLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRleHQuZm9udCc6J0FyaWFsJywnY2hhcnQudGV4dC5jb2xvcic6JyM2NjYnLCdjaGFydC50ZXh0LnNpemUnOjEwLCdjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50LmNvbG9yMSc6JyNkZGQnLCdjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50LmNvbG9yMic6J3doaXRlJywnY2hhcnQuc2hhZG93Jzp0cnVlLCdjaGFydC5zaGFkb3cuY29sb3InOidncmF5JywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjAsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzowLCdjaGFydC5zaGFkb3cuYmx1cic6MTUsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQuY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGFibGUnOmZhbHNlLCdjaGFydC5hbm5vdGF0ZS5jb2xvcic6J2JsYWNrJywnY2hhcnQuY29sb3JzLnJhbmdlcyc6bnVsbCwnY2hhcnQucmVkLnN0YXJ0JzptaW4rKDAuOSoodGhpcy5tYXgtbWluKSksJ2NoYXJ0LmdyZWVuLmVuZCc6bWluKygwLjcqKHRoaXMubWF4LW1pbikpLCdjaGFydC5yZWQuY29sb3InOidyZWQnLCdjaGFydC55ZWxsb3cuY29sb3InOid5ZWxsb3cnLCdjaGFydC5ncmVlbi5jb2xvcic6JyMwZjAnLCdjaGFydC52YWx1ZS50ZXh0Jzp0cnVlLCdjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucG9zdCc6JycsJ2NoYXJ0LnZhbHVlLnRleHQuYm94ZWQnOnRydWUsJ2NoYXJ0LnZhbHVlLnRleHQuZm9udCc6J0FyaWFsJywnY2hhcnQudmFsdWUudGV4dC5zaXplJzoxOCwnY2hhcnQudmFsdWUudGV4dC5ib2xkJzpmYWxzZSwnY2hhcnQudmFsdWUudGV4dC5kZWNpbWFscyc6MCwnY2hhcnQuY2VudGVycGluLnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5jZW50ZXJwaW4uZmlsbCc6bnVsbCwnY2hhcnQuY2VudGVycGluLmNvbG9yJzonYmx1ZScsJ2NoYXJ0Lm5lZWRsZS5jb2xvcnMnOlsnI2NjYycsJyNENTYwNEQnLCdyZWQnLCdncmVlbicsJ3llbGxvdyddLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlfVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoO3ZhciBjYT10aGlzLmNhbnZhczt2YXIgY289Y2EuZ2V0Q29udGV4dCgnMmQnKTt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7dmFyIGpxPWpRdWVyeTt2YXIgcGE9UkcuUGF0aDt2YXIgd2luPXdpbmRvdzt2YXIgZG9jPWRvY3VtZW50O3ZhciBtYT1NYXRoO3RoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUsdmFsdWUpXG57aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBhcmd1bWVudHNbMF09PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGFyZ3VtZW50c1swXSk7cmV0dXJuIHRoaXM7fVxubmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbnJldHVybiBwcm9wW25hbWVdO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7aWYodHlwZW9mIHRoaXMuZ3V0dGVyTGVmdD09J3VuZGVmaW5lZCcpe3RoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt9XG50aGlzLnJhZGl1cz1NYXRoLm1pbigoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pKTtpZih0eXBlb2YocHJvcFsnY2hhcnQucmFkaXVzJ10pPT0nbnVtYmVyJyl0aGlzLnJhZGl1cz1wcm9wWydjaGFydC5yYWRpdXMnXTt0aGlzLmNlbnRlcng9KGNhLndpZHRoLzIpLSh0aGlzLnJhZGl1cy8yKStNYXRoLm1heCgzMCx0aGlzLnJhZGl1cyowLjEpO3RoaXMuY2VudGVyeT0oY2EuaGVpZ2h0LzIpKyh0aGlzLnJhZGl1cy8yKS0odGhpcy5yYWRpdXMqMC4xKTt0aGlzLmNvb3Jkc1RleHQ9W107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXT09PSdudW1iZXInKXRoaXMuY2VudGVyeD1wcm9wWydjaGFydC5jZW50ZXJ4J107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXT09PSdudW1iZXInKXRoaXMuY2VudGVyeT1wcm9wWydjaGFydC5jZW50ZXJ5J107aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLkRyYXdCYWNrR3JvdW5kKCk7dGhpcy5EcmF3VGlja21hcmtzKCk7dGhpcy5EcmF3Q29sb3JCYW5kcygpO3RoaXMuRHJhd0xhYmVsKCk7dGhpcy5EcmF3TGFiZWxzKCk7aWYodHlwZW9mIHRoaXMudmFsdWU9PT0nb2JqZWN0Jyl7Zm9yKHZhciBpPTAsbGVuPXRoaXMudmFsdWUubGVuZ3RoO2k8bGVuOysraSl7dGhpcy5EcmF3TmVlZGxlKGksdGhpcy52YWx1ZVtpXSx0aGlzLnJhZGl1cy02NSk7fX1lbHNle3RoaXMuRHJhd05lZWRsZSgwLHRoaXMudmFsdWUsdGhpcy5yYWRpdXMtNjUpO31cbnRoaXMuRHJhd0NlbnRlcnBpbigpO3ZhciBzaXplPXByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMlxucHJvcFsnY2hhcnQudGl0bGUueSddPXRoaXMuY2VudGVyeSsyMC10aGlzLnJhZGl1cy0oKDEuNSpzaXplKS8yKTtSR3JhcGguRHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSx0aGlzLmd1dHRlcnRvcCx0aGlzLmNlbnRlcngrKHRoaXMucmFkaXVzLzIpLHNpemUpO2lmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHcmFwaC5TaG93Q29udGV4dCh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5yZXNpemFibGUnXSl7UkdyYXBoLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkdyYXBoLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkdyYXBoLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0JhY2tHcm91bmQ9dGhpcy5EcmF3QmFja0dyb3VuZD1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHcmFwaC5TZXRTaGFkb3codGhpcyxwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10scHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7fVxuY28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ10/cHJvcFsnY2hhcnQubGluZXdpZHRoJ106MC4wMDAxO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDMwLDAsUkdyYXBoLlRXT1BJLGZhbHNlKTtjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LTIwLHRoaXMuY2VudGVyeSsyMCk7Y28uYXJjKHRoaXMuY2VudGVyeC0yMCx0aGlzLmNlbnRlcnkrMjAsdGhpcy5yYWRpdXMsUkdyYXBoLlBJK1JHcmFwaC5IQUxGUEksUkdyYXBoLlRXT1BJLGZhbHNlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7UkcuTm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ10/cHJvcFsnY2hhcnQubGluZXdpZHRoJ106MC4wMDAxO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngtMjAsdGhpcy5jZW50ZXJ5KzIwKTtjby5hcmModGhpcy5jZW50ZXJ4LTIwLHRoaXMuY2VudGVyeSsyMCx0aGlzLnJhZGl1cyxSR3JhcGguUEkrUkdyYXBoLkhBTEZQSSxSR3JhcGguVFdPUEksZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO1JHcmFwaC5Ob1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGg9MDtjby5maWxsU3R5bGU9UkdyYXBoLlJhZGlhbEdyYWRpZW50KHRoaXMsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwwLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMqMC41LHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JhZGllbnQuY29sb3IxJ10scHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmFkaWVudC5jb2xvcjInXSk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDMwLDAsUkdyYXBoLlRXT1BJLDApO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LTIwLHRoaXMuY2VudGVyeSsyMCk7Y28ubGluZVRvKHRoaXMuY2VudGVyeC0yMCx0aGlzLmNlbnRlcnkrMjAtdGhpcy5yYWRpdXMpO2NvLmFyYyh0aGlzLmNlbnRlcngtMjAsdGhpcy5jZW50ZXJ5KzIwLHRoaXMucmFkaXVzLFJHcmFwaC5QSStSR3JhcGguSEFMRlBJLFJHcmFwaC5UV09QSSxmYWxzZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aD0xO2NvLnN0cm9rZVN0eWxlPScjZWVlJztmb3IodmFyIGk9MDtpPD01OysraSl7dmFyIHAxPVJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksKFJHcmFwaC5IQUxGUEkvNSppKStSR3JhcGguUEkrUkdyYXBoLkhBTEZQSSwzMCk7dmFyIHAyPVJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksKFJHcmFwaC5IQUxGUEkvNSppKStSR3JhcGguUEkrUkdyYXBoLkhBTEZQSSx0aGlzLnJhZGl1cy05MCk7Y28ubW92ZVRvKHAxWzBdLHAxWzFdKTtjby5saW5lVG8ocDJbMF0scDJbMV0pO31cbmNvLnN0cm9rZSgpO307dGhpcy5kcmF3TmVlZGxlPXRoaXMuRHJhd05lZWRsZT1mdW5jdGlvbihpbmRleCx2YWx1ZSxyYWRpdXMpXG57dmFyIGdyYWQ9UkcuUmFkaWFsR3JhZGllbnQodGhpcyx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDAsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwyMCwncmdiYSgwLDAsMCwwKScscHJvcFsnY2hhcnQubmVlZGxlLmNvbG9ycyddW2luZGV4XSlcbnRoaXMuYW5nbGVzLm5lZWRsZVtpbmRleF09KCgodmFsdWUtdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKlJHLkhBTEZQSSkrUkcuUEkrUkcuSEFMRlBJO2NvLmxpbmVXaWR0aD0xXG5jby5zdHJva2VTdHlsZT0ncmdiYSgwLDAsMCwwKSc7Y28uZmlsbFN0eWxlPWdyYWQ7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDEwLHRoaXMuYW5nbGVzLm5lZWRsZVtpbmRleF0tUkcuSEFMRlBJLHRoaXMuYW5nbGVzLm5lZWRsZVtpbmRleF0tUkcuSEFMRlBJKzAuMDAwMDAxLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxyYWRpdXMtMzAsdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSx0aGlzLmFuZ2xlcy5uZWVkbGVbaW5kZXhdKzAuMDAwMDAxLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwxMCx0aGlzLmFuZ2xlcy5uZWVkbGVbaW5kZXhdK1JHLkhBTEZQSSx0aGlzLmFuZ2xlcy5uZWVkbGVbaW5kZXhdK1JHLkhBTEZQSSswLjAwMDAwMSxmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO307dGhpcy5kcmF3Q2VudGVycGluPXRoaXMuRHJhd0NlbnRlcnBpbj1mdW5jdGlvbigpXG57aWYoIXByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ10pe3Byb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ109UkcuUmFkaWFsR3JhZGllbnQodGhpcyx0aGlzLmNlbnRlcngrNSx0aGlzLmNlbnRlcnktNSwwLHRoaXMuY2VudGVyeCs1LHRoaXMuY2VudGVyeS01LDIwLCd3aGl0ZScscHJvcFsnY2hhcnQuY2VudGVycGluLmNvbG9yJ10pfVxuY28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuY2VudGVycGluLnN0cm9rZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jZW50ZXJwaW4uZmlsbCddO2NvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aD0yO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDE1LDAsUkdyYXBoLlRXT1BJLGZhbHNlKTtjby5zdHJva2UoKTtjby5maWxsKCk7fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbnt2YXIgbnVtTGFiZWxzPTY7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IodmFyIGk9MDtpPG51bUxhYmVsczsrK2kpe2NvLmJlZ2luUGF0aCgpO3ZhciBudW09TnVtYmVyKHRoaXMubWluKygodGhpcy5tYXgtdGhpcy5taW4pKihpLyhudW1MYWJlbHMtMSkpKSkudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKTtudW09UkcubnVtYmVyX2Zvcm1hdCh0aGlzLG51bSxwcm9wWydjaGFydC51bml0cy5wcmUnXSxwcm9wWydjaGFydC51bml0cy5wb3N0J10pO3ZhciBhbmdsZT0oaSoxOCkvKDE4MC9SRy5QSSk7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwneCc6dGhpcy5jZW50ZXJ4K21hLnNpbihhbmdsZSkqKHRoaXMucmFkaXVzLTUzKSwneSc6dGhpcy5jZW50ZXJ5LW1hLmNvcyhhbmdsZSkqKHRoaXMucmFkaXVzLTUzKSwndGV4dCc6U3RyaW5nKG51bSksJ3ZhbGlnbic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsJ2FuZ2xlJzo5MCooaS8obnVtTGFiZWxzLTEpKSwndGFnJzonc2NhbGUnfSk7Y28uZmlsbCgpO319O3RoaXMuZHJhd1RpY2ttYXJrcz10aGlzLkRyYXdUaWNrbWFya3M9ZnVuY3Rpb24oKVxue3ZhciBiaWdUaWNrcz01O3ZhciBzbWFsbFRpY2tzPTI1O2Zvcih2YXIgaT0wO2k8c21hbGxUaWNrczsrK2kpe2NvLmJlZ2luUGF0aCgpO3ZhciBhbmdsZT0oUkcuSEFMRlBJLyhzbWFsbFRpY2tzLTEpKSppXG5jby5saW5lV2lkdGg9MTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy00NCxSRy5QSStSRy5IQUxGUEkrYW5nbGUsUkcuUEkrUkcuSEFMRlBJK2FuZ2xlKzAuMDAwMSxmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtNDYsUkcuUEkrUkcuSEFMRlBJK2FuZ2xlLFJHLlBJK1JHLkhBTEZQSSthbmdsZSswLjAwMDEsZmFsc2UpO2NvLnN0cm9rZSgpO31cbmZvcih2YXIgaT0wO2k8YmlnVGlja3M7KytpKXtjby5iZWdpblBhdGgoKTt2YXIgYW5nbGU9KFJHLkhBTEZQSS8oYmlnVGlja3MtMSkpKmlcbmNvLmxpbmVXaWR0aD0xO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTQzLFJHLlBJK1JHLkhBTEZQSSthbmdsZSxSRy5QSStSRy5IQUxGUEkrYW5nbGUrMC4wMDAxLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy00NyxSRy5QSStSRy5IQUxGUEkrYW5nbGUsUkcuUEkrUkcuSEFMRlBJK2FuZ2xlKzAuMDAwMSxmYWxzZSk7Y28uc3Ryb2tlKCk7fX07dGhpcy5EcmF3Q29sb3JCYW5kcz1mdW5jdGlvbigpXG57aWYoUkcuaXNfYXJyYXkocHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddKSl7dmFyIHJhbmdlcz1wcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ107Zm9yKHZhciBpPTAsbGVuPXJhbmdlcy5sZW5ndGg7aTxsZW47KytpKXtjby5maWxsU3R5bGU9cmFuZ2VzW2ldWzJdO2NvLmxpbmVXaWR0aD0wO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTU0LShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpLCgoKHJhbmdlc1tpXVswXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuSEFMRlBJKSsoUkcuUEkrUkcuSEFMRlBJKSwoKChyYW5nZXNbaV1bMV0tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKlJHLkhBTEZQSSkrKFJHLlBJK1JHLkhBTEZQSSksZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTU0LTEwLShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpLCgoKHJhbmdlc1tpXVsxXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuSEFMRlBJKSsoUkcuUEkrUkcuSEFMRlBJKSwoKChyYW5nZXNbaV1bMF0tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKlJHLkhBTEZQSSkrKFJHLlBJK1JHLkhBTEZQSSksdHJ1ZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO31cbnJldHVybjt9XG5jby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5ncmVlbi5jb2xvciddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5ncmVlbi5jb2xvciddO3ZhciBncmVlblN0YXJ0PVJHLlBJK1JHLkhBTEZQSTt2YXIgZ3JlZW5FbmQ9Z3JlZW5TdGFydCsoUkcuVFdPUEktZ3JlZW5TdGFydCkqKChwcm9wWydjaGFydC5ncmVlbi5lbmQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSlcbmNvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTU0LShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpLGdyZWVuU3RhcnQsZ3JlZW5FbmQsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTU0LShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpLTEwLGdyZWVuRW5kLGdyZWVuU3RhcnQsdHJ1ZSk7Y28uZmlsbCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC55ZWxsb3cuY29sb3InXTt2YXIgeWVsbG93U3RhcnQ9Z3JlZW5FbmQ7dmFyIHllbGxvd0VuZD0oKChwcm9wWydjaGFydC5yZWQuc3RhcnQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuSEFMRlBJKStSRy5QSStSRy5IQUxGUEk7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtNTQtKHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKjEuNSkseWVsbG93U3RhcnQseWVsbG93RW5kLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy01NC0ocHJvcFsnY2hhcnQudGV4dC5zaXplJ10qMS41KS0xMCx5ZWxsb3dFbmQseWVsbG93U3RhcnQsdHJ1ZSk7Y28uZmlsbCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnJlZC5jb2xvciddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5yZWQuY29sb3InXTt2YXIgcmVkU3RhcnQ9eWVsbG93RW5kO3ZhciByZWRFbmQ9UkdyYXBoLlRXT1BJO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTU0LShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpLHJlZFN0YXJ0LHJlZEVuZCxmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtNTQtKHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKjEuNSktMTAscmVkRW5kLHJlZFN0YXJ0LHRydWUpO2NvLmZpbGwoKTt9O3RoaXMuZHJhd0xhYmVsPXRoaXMuRHJhd0xhYmVsPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC52YWx1ZS50ZXh0J10pe2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciB2YWx1ZT10eXBlb2YodGhpcy52YWx1ZSk9PSdudW1iZXInP3RoaXMudmFsdWUudG9GaXhlZChwcm9wWydjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJ10pOnRoaXMudmFsdWU7aWYodHlwZW9mKHZhbHVlKT09J29iamVjdCcpe2Zvcih2YXIgaT0wO2k8dmFsdWUubGVuZ3RoOysraSl7dmFsdWVbaV09cGFyc2VGbG9hdCh2YWx1ZVtpXSkudG9GaXhlZChwcm9wWydjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJ10pO31cbnZhbHVlPXZhbHVlLnRvU3RyaW5nKCk7fVxuUkcuVGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC52YWx1ZS50ZXh0LnNpemUnXSwneCc6dGhpcy5jZW50ZXJ4KyhtYS5jb3MoKFJHLlBJLzE4MCkqNDUpKih0aGlzLnJhZGl1cy8zKSksJ3knOnRoaXMuY2VudGVyeS0obWEuc2luKChSRy5QSS8xODApKjQ1KSoodGhpcy5yYWRpdXMvMykpLCd0ZXh0Jzpwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnByZSddK3ZhbHVlK3Byb3BbJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucG9zdCddLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6cHJvcFsnY2hhcnQudmFsdWUudGV4dC5ib3hlZCddLCdib3VuZGluZ0ZpbGwnOid3aGl0ZScsJ2JvbGQnOnByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuYm9sZCddLCd0YWcnOid2YWx1ZS50ZXh0J30pO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSl7fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdO3ZhciBtb3VzZVk9bW91c2VYWVsxXTt2YXIgYW5nbGU9UkcuZ2V0QW5nbGVCeVhZKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbW91c2VYLG1vdXNlWSk7aWYoYW5nbGU+UkcuVFdPUEkmJmFuZ2xlPChSRy5QSStSRy5IQUxGUEkpKXtyZXR1cm4gbnVsbDt9XG52YXIgdmFsdWU9KChhbmdsZS0oUkcuUEkrUkcuSEFMRlBJKSkvKFJHLlRXT1BJLShSRy5QSStSRy5IQUxGUEkpKSkqKHRoaXMubWF4LXRoaXMubWluKTt2YWx1ZT12YWx1ZSt0aGlzLm1pbjtpZih2YWx1ZTx0aGlzLm1pbil7dmFsdWU9dGhpcy5taW59XG5pZih2YWx1ZT50aGlzLm1heCl7dmFsdWU9dGhpcy5tYXh9XG5pZihtb3VzZVg+dGhpcy5jZW50ZXJ4JiZtb3VzZVk+dGhpcy5jZW50ZXJ5KXt2YWx1ZT10aGlzLm1heDt9XG5yZXR1cm4gdmFsdWU7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SR3JhcGguZ2V0TW91c2VYWShlKTtpZihtb3VzZVhZWzBdPih0aGlzLmNlbnRlcngtNSkmJm1vdXNlWFlbMF08KHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cykmJm1vdXNlWFlbMV0+KHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cykmJm1vdXNlWFlbMV08KHRoaXMuY2VudGVyeSs1KSYmUkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbW91c2VYWVswXSxtb3VzZVhZWzFdKTw9dGhpcy5yYWRpdXMpe3JldHVybiB0aGlzO319O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZT10aGlzLkFkanVzdGluZ19tb3VzZW1vdmU9ZnVuY3Rpb24oZSlcbntpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykmJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkPT10aGlzLnVpZCl7dGhpcy52YWx1ZT10aGlzLmdldFZhbHVlKGUpO1JHLkNsZWFyKGNhKTtSRy5SZWRyYXdDYW52YXMoY2EpO1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmFkanVzdCcpO319O3RoaXMuZ2V0QW5nbGU9ZnVuY3Rpb24odmFsdWUpXG57aWYodmFsdWU8dGhpcy5taW58fHZhbHVlPnRoaXMubWF4KXtyZXR1cm4gbnVsbDt9XG52YXIgYW5nbGU9KCh2YWx1ZS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuSEFMRlBJXG5hbmdsZSs9KFJHLlBJK1JHLkhBTEZQSSk7cmV0dXJuIGFuZ2xlO307dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5ncmVlbi5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC55ZWxsb3cuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnJlZC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTt9XG5pZighUkcuaXNfbnVsbChwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pKXtmb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXS5sZW5ndGg7KytpKXtwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ11baV1bMl09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddW2ldWzJdKTt9fWVsc2V7cHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTtwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7cHJvcFsnY2hhcnQucmVkLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQucmVkLmNvbG9yJ10pO319O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciByYWRpdXNfc3RhcnQ9dGhpcy5yYWRpdXMtNTQtcHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIHJhZGl1c19lbmQ9cmFkaXVzX3N0YXJ0LTE1O3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkscmFkaXVzX3N0YXJ0LHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkscmFkaXVzX2VuZCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xLGxlbj1wYXJ0cy5sZW5ndGg7ajxsZW47KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbnRoaXNbdHlwZV09ZnVuYztyZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvcHQ9YXJndW1lbnRzWzBdO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV07dmFyIG51bUZyYW1lcz0zMDt2YXIgZnJhbWU9MDt2YXIgb2JqPXRoaXM7aWYodHlwZW9mIHRoaXMudmFsdWU9PT0nbnVtYmVyJyl7dmFyIG9yaWdWYWx1ZT1OdW1iZXIodGhpcy5jdXJyZW50VmFsdWUpO2lmKHRoaXMuY3VycmVudFZhbHVlPT09bnVsbCl7dGhpcy5jdXJyZW50VmFsdWU9dGhpcy5taW47b3JpZ1ZhbHVlPXRoaXMubWluO31cbnZhciBuZXdWYWx1ZT10aGlzLnZhbHVlO3ZhciBkaWZmPW5ld1ZhbHVlLW9yaWdWYWx1ZTt2YXIgc3RlcD0oZGlmZi9udW1GcmFtZXMpO3ZhciBmcmFtZT0wO3ZhciBpdGVyYXRvcj1mdW5jdGlvbigpXG57ZnJhbWUrKztvYmoudmFsdWU9KChmcmFtZS9udW1GcmFtZXMpKmRpZmYpK29yaWdWYWx1ZVxuaWYob2JqLnZhbHVlPm9iai5tYXgpb2JqLnZhbHVlPW9iai5tYXg7aWYob2JqLnZhbHVlPG9iai5taW4pb2JqLnZhbHVlPW9iai5taW47UkdyYXBoLkNsZWFyKG9iai5jYW52YXMpO1JHcmFwaC5SZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWU8MzApe1JHcmFwaC5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2UgaWYodHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJyl7Y2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO31lbHNle2lmKG9iai5jdXJyZW50VmFsdWU9PW51bGwpe29iai5jdXJyZW50VmFsdWU9W107Zm9yKHZhciBpPTAsbGVuPW9iai52YWx1ZS5sZW5ndGg7aTxsZW47KytpKXtvYmouY3VycmVudFZhbHVlW2ldPW9iai5taW47fVxub3JpZ1ZhbHVlPVJHLmFycmF5X2Nsb25lKG9iai5jdXJyZW50VmFsdWUpO31cbnZhciBvcmlnVmFsdWU9UkcuYXJyYXlfY2xvbmUob2JqLmN1cnJlbnRWYWx1ZSk7dmFyIG5ld1ZhbHVlPVJHLmFycmF5X2Nsb25lKG9iai52YWx1ZSk7dmFyIGRpZmY9W107dmFyIHN0ZXA9W107Zm9yKHZhciBpPTAsbGVuPW5ld1ZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe2RpZmZbaV09bmV3VmFsdWVbaV0tTnVtYmVyKG9iai5jdXJyZW50VmFsdWVbaV0pO3N0ZXBbaV09KGRpZmZbaV0vbnVtRnJhbWVzKTt9XG52YXIgbWF4PXRoaXMubWF4O3ZhciBtaW49dGhpcy5taW47dmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbntmcmFtZSsrO2Zvcih2YXIgaT0wLGxlbj1vYmoudmFsdWUubGVuZ3RoO2k8bGVuOysraSl7b2JqLnZhbHVlW2ldPSgoZnJhbWUvbnVtRnJhbWVzKSpkaWZmW2ldKStvcmlnVmFsdWVbaV07aWYob2JqLnZhbHVlW2ldPm1heClvYmoudmFsdWVbaV09bWF4O2lmKG9iai52YWx1ZVtpXTxtaW4pb2JqLnZhbHVlW2ldPW1pbjtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7fVxuaWYoZnJhbWU8MzApe1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZSBpZih0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKXtjYWxsYmFjayhvYmopO319O2l0ZXJhdG9yKCk7fVxucmV0dXJuIHRoaXM7fVxuUkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29ybmVyZ2F1Z2UuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///206\n");

/***/ }),
/* 207 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Background = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id);\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.type = 'drawing.background';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.linewidth': 1, 'chart.title': '', 'chart.title.size': null, 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.color': 'black', 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': 'black', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.yaxis.pos': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.BACKGROUND] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa = RG.Path,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RG.drawBackgroundImage(this);RG.Background.draw(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var tooltip = prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null;\n      return { 0: this, 1: 0, 2: tooltip, 'object': this, 'index': 0, 'tooltip': tooltip };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b r % % % % f % s %', prop['chart.gutter.left'], prop['chart.gutter.top'], ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'], prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, ca.height - this.gutterRight),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5iYWNrZ3JvdW5kLmpzP2I3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5CYWNrZ3JvdW5kPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO3RoaXMudHlwZT0nZHJhd2luZy5iYWNrZ3JvdW5kJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6JyNkZGQnLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQud2lkdGgnOjEsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnOjUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kYXNoZWQnOmZhbHNlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZG90dGVkJzpmYWxzZSwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZSc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5zdHJldGNoJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLngnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53JzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxpZ24nOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOm51bGwsJ2NoYXJ0Lmd1dHRlci5sZWZ0JzoyNSwnY2hhcnQuZ3V0dGVyLnJpZ2h0JzoyNSwnY2hhcnQuZ3V0dGVyLnRvcCc6MjUsJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOjI1LCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQubGluZXdpZHRoJzoxLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpdGxlLmhwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnZwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmNvbG9yJzonYmxhY2snLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMnOicnLCdjaGFydC50aXRsZS54YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS54YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy54JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy55JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5wb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzJzonJywnY2hhcnQudGl0bGUueWF4aXMuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUueWF4aXMuc2l6ZSc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0LnRpdGxlLnlheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnBvcyc6bnVsbCwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW0RSQVdJTkcuQkFDS0dST1VORF0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47fVxudGhpcy4kMD17fTtpZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYT1SRy5QYXRoLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cblJHLmRyYXdCYWNrZ3JvdW5kSW1hZ2UodGhpcyk7UkcuQmFja2dyb3VuZC5kcmF3KHRoaXMpO1JHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2lmKG1vdXNlWD49dGhpcy5ndXR0ZXJMZWZ0JiZtb3VzZVg8PShjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSYmbW91c2VZPj10aGlzLmd1dHRlclRvcCYmbW91c2VZPD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl7dmFyIHRvb2x0aXA9cHJvcFsnY2hhcnQudG9vbHRpcHMnXT9wcm9wWydjaGFydC50b29sdGlwcyddWzBdOm51bGxcbnJldHVybnswOnRoaXMsMTowLDI6dG9vbHRpcCwnb2JqZWN0Jzp0aGlzLCdpbmRleCc6MCwndG9vbHRpcCc6dG9vbHRpcH07fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZihwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSl7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7cGEyKGNvLCdiIHIgJSAlICUgJSBmICUgcyAlJyxwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSxjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ10tcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10scHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt9fX07dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO31cbnByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yKXtyZXR1cm4gY29sb3I7fVxuaWYodHlwZW9mIGNvbG9yPT09J3N0cmluZycmJmNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpLGdyYWQ9Y28uY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wLGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyUmlnaHQpLGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2Zvcih2YXIgaj0wO2o8cGFydHMubGVuZ3RoO2orPTEpe2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5iYWNrZ3JvdW5kLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///207\n");

/***/ }),
/* 208 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Circle = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.circle';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.linewidth': 2, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.CIRCLE] No canvas support');return;\n  }\n  this.coords = [[this.centerx, this.centery, this.radius]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, 'b lw %', prop['chart.linewidth']);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    pa2(co, 'b a % % % % % % f % s %', this.coords[0][0], this.coords[0][1], this.radius, 0, RG.TWOPI, false, prop['chart.fillstyle'], prop['chart.strokestyle']);RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b a % % % % % % f % s %', this.centerx, this.centery, this.radius + 0.5, 0, RG.TWOPI, false, prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5jaXJjbGUuanM/ODBlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkRyYXdpbmc9UkdyYXBoLkRyYXdpbmd8fHt9O1JHcmFwaC5EcmF3aW5nLkNpcmNsZT1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLng9PT0nbnVtYmVyJyYmdHlwZW9mIGNvbmYueT09PSdudW1iZXInJiZ0eXBlb2YgY29uZi5yYWRpdXM9PT0nbnVtYmVyJyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSx4PWNvbmYueCx5PWNvbmYueSxyYWRpdXM9Y29uZi5yYWRpdXMscGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkseD1hcmd1bWVudHNbMV0seT1hcmd1bWVudHNbMl0scmFkaXVzPWFyZ3VtZW50c1szXTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO3RoaXMuY2VudGVyeD14O3RoaXMuY2VudGVyeT15O3RoaXMucmFkaXVzPXJhZGl1czt0aGlzLnR5cGU9J2RyYXdpbmcuY2lyY2xlJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5zdHJva2VzdHlsZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5maWxsc3R5bGUnOidyZWQnLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6J2dyYXknLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MywnY2hhcnQuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0LnNoYWRvdy5ibHVyJzo1LCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzonYmxhY2snLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LmxpbmV3aWR0aCc6MiwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW0RSQVdJTkcuQ0lSQ0xFXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLmNvb3Jkcz1bW3RoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXNdXTt0aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoO2lmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG5wYTIoY28sJ2IgbHcgJScscHJvcFsnY2hhcnQubGluZXdpZHRoJ10pO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5zZXRTaGFkb3codGhpcyxwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10scHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7fVxucGEyKGNvLCdiIGEgJSAlICUgJSAlICUgZiAlIHMgJScsdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5yYWRpdXMsMCxSRy5UV09QSSxmYWxzZSxwcm9wWydjaGFydC5maWxsc3R5bGUnXSxwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTtSRy5ub1NoYWRvdyh0aGlzKTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbntpZih0aGlzLmdldFNoYXBlKGUpKXtyZXR1cm4gdGhpczt9fTt0aGlzLmdldFNoYXBlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTtpZihSRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pPD10aGlzLnJhZGl1cyl7cmV0dXJuezA6dGhpcywxOnRoaXMuY2VudGVyeCwyOnRoaXMuY2VudGVyeSwzOnRoaXMucmFkaXVzLDQ6bnVsbCw1OjAsJ29iamVjdCc6dGhpcywneCc6dGhpcy5jZW50ZXJ4LCd5Jzp0aGlzLmNlbnRlcnksJ3JhZGl1cyc6dGhpcy5yYWRpdXMsJ2luZGV4JzowLCd0b29sdGlwJzpwcm9wWydjaGFydC50b29sdGlwcyddP3Byb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF06bnVsbH07fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZihwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSl7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7cGEyKGNvLCdiIGEgJSAlICUgJSAlICUgZiAlIHMgJScsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyswLjUsMCxSRy5UV09QSSxmYWxzZSxwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7fX19O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5maWxsc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO31cbnByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcil7cmV0dXJuIGNvbG9yO31cbmlmKHR5cGVvZiBjb2xvcj09PSdzdHJpbmcnJiZjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDAsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyksZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Zm9yKHZhciBqPTA7ajxwYXJ0cy5sZW5ndGg7ais9MSl7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmNpcmNsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///208\n");

/***/ }),
/* 209 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Image = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.src === 'string' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        src = conf.src,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        src = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.alignmentProcessed = false;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.src = src;this.img = new Image();this.img.src = this.src;this.type = 'drawing.image';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.src': null, 'chart.width': null, 'chart.height': null, 'chart.halign': 'left', 'chart.valign': 'top', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.alpha': 1, 'chart.border': false, 'chart.border.color': 'black', 'chart.border.linewidth': 1, 'chart.border.radius': 0, 'chart.background.color': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.IMAGE] No canvas support');return;\n  }\n  this.coords = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');var obj = this;this.img.onload = function () {\n      if (!obj.colorsParsed) {\n        obj.parseColors();obj.colorsParsed = true;\n      }\n      obj.width = this.width;obj.height = this.height;if (!this.alignmentProcessed) {\n        var customWidthHeight = typeof obj.properties['chart.width'] == 'number' && typeof obj.properties['chart.width'] == 'number';if (obj.properties['chart.halign'] === 'center') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] / 2 : this.width / 2;\n        } else if (obj.properties['chart.halign'] == 'right') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] : this.width;\n        }\n        if (obj.properties['chart.valign'] === 'center') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] / 2 : this.height / 2;\n        } else if (obj.properties['chart.valign'] == 'bottom') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] : this.height;\n        }\n        this.alignmentProcessed = true;\n      }\n    };\n    if (this.img.complete || this.img.readyState === 4) {\n      this.img.onload();\n    }\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.alpha'];if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.border.linewidth'];var borderRadius = 0;if (this.width || this.height) {\n        borderRadius = ma.min(this.width / 2, this.height / 2);\n      }\n      if (prop['chart.width'] / 2 > borderRadius && prop['chart.height'] / 2 > borderRadius) {\n        borderRadius = ma.min(prop['chart.width'] / 2, prop['chart.height'] / 2);\n      }\n      if (prop['chart.border.radius'] < borderRadius) {\n        borderRadius = prop['chart.border.radius'];\n      }\n      co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);\n    }\n    if (borderRadius) {\n      co.save();this.drawBackgroundColor(borderRadius);co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.clip();\n    } else {\n      this.drawBackgroundColor(0);\n    }\n    RG.noShadow(this);if (typeof prop['chart.height'] === 'number' || typeof prop['chart.width'] === 'number') {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y), prop['chart.width'] || this.width, prop['chart.height'] || this.height);\n    } else {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y));\n    }\n    if (borderRadius) {\n      co.restore();\n    }\n    if (prop['chart.border']) {\n      RG.noShadow(this);co.stroke();\n    }\n    co.globalAlpha = oldAlpha;this.img.onload = function () {\n      RG.redrawCanvas(ca);obj.coords[0] = [ma.round(obj.x), ma.round(obj.y), typeof prop['chart.width'] === 'number' ? prop['chart.width'] : this.width, typeof prop['chart.height'] == 'number' ? prop['chart.height'] : this.height];\n    };\n    RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (this.coords && this.coords[0] && mouseXY[0] >= this.coords[0][0] && mouseXY[0] <= this.coords[0][0] + this.coords[0][2] && mouseXY[1] >= this.coords[0][1] && mouseXY[1] <= this.coords[0][1] + this.coords[0][3]) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.img.width, this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.roundedRect = function (x, y, width, height, radius) {\n    co.save();co.translate(x, y);co.moveTo(width / 2, 0);co.arcTo(width, 0, width, height, ma.min(height / 2, radius));co.arcTo(width, height, 0, height, ma.min(width / 2, radius));co.arcTo(0, height, 0, 0, ma.min(height / 2, radius));co.arcTo(0, 0, radius, 0, ma.min(width / 2, radius));co.lineTo(width / 2, 0);co.restore();\n  };this.drawBackgroundColor = function (borderRadius) {\n    co.beginPath();co.fillStyle = prop['chart.background.color'];this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.fill();\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5pbWFnZS5qcz8wMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguRHJhd2luZz1SR3JhcGguRHJhd2luZ3x8e307UkdyYXBoLkRyYXdpbmcuSW1hZ2U9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi54PT09J251bWJlcicmJnR5cGVvZiBjb25mLnk9PT0nbnVtYmVyJyYmdHlwZW9mIGNvbmYuc3JjPT09J3N0cmluZycmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkseD1jb25mLngseT1jb25mLnksc3JjPWNvbmYuc3JjLHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZixjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLHg9YXJndW1lbnRzWzFdLHk9YXJndW1lbnRzWzJdLHNyYz1hcmd1bWVudHNbM107fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy5hbGlnbm1lbnRQcm9jZXNzZWQ9ZmFsc2U7dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLng9eDt0aGlzLnk9eTt0aGlzLnNyYz1zcmM7dGhpcy5pbWc9bmV3IEltYWdlKCk7dGhpcy5pbWcuc3JjPXRoaXMuc3JjO3RoaXMudHlwZT0nZHJhd2luZy5pbWFnZSc7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMudWlkPVJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuc3JjJzpudWxsLCdjaGFydC53aWR0aCc6bnVsbCwnY2hhcnQuaGVpZ2h0JzpudWxsLCdjaGFydC5oYWxpZ24nOidsZWZ0JywnY2hhcnQudmFsaWduJzondG9wJywnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5zaGFkb3cnOmZhbHNlLCdjaGFydC5zaGFkb3cuY29sb3InOidncmF5JywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzozLCdjaGFydC5zaGFkb3cuYmx1cic6NSwnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQuYWxwaGEnOjEsJ2NoYXJ0LmJvcmRlcic6ZmFsc2UsJ2NoYXJ0LmJvcmRlci5jb2xvcic6J2JsYWNrJywnY2hhcnQuYm9yZGVyLmxpbmV3aWR0aCc6MSwnY2hhcnQuYm9yZGVyLnJhZGl1cyc6MCwnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5JTUFHRV0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47fVxudGhpcy5jb29yZHM9W107dGhpcy4kMD17fTtpZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt2YXIgb2JqPXRoaXM7dGhpcy5pbWcub25sb2FkPWZ1bmN0aW9uKClcbntpZighb2JqLmNvbG9yc1BhcnNlZCl7b2JqLnBhcnNlQ29sb3JzKCk7b2JqLmNvbG9yc1BhcnNlZD10cnVlO31cbm9iai53aWR0aD10aGlzLndpZHRoO29iai5oZWlnaHQ9dGhpcy5oZWlnaHQ7aWYoIXRoaXMuYWxpZ25tZW50UHJvY2Vzc2VkKXt2YXIgY3VzdG9tV2lkdGhIZWlnaHQ9KHR5cGVvZiBvYmoucHJvcGVydGllc1snY2hhcnQud2lkdGgnXT09J251bWJlcicmJnR5cGVvZiBvYmoucHJvcGVydGllc1snY2hhcnQud2lkdGgnXT09J251bWJlcicpO2lmKG9iai5wcm9wZXJ0aWVzWydjaGFydC5oYWxpZ24nXT09PSdjZW50ZXInKXtvYmoueC09Y3VzdG9tV2lkdGhIZWlnaHQ/KG9iai5wcm9wZXJ0aWVzWydjaGFydC53aWR0aCddLzIpOih0aGlzLndpZHRoLzIpO31lbHNlIGlmKG9iai5wcm9wZXJ0aWVzWydjaGFydC5oYWxpZ24nXT09J3JpZ2h0Jyl7b2JqLngtPWN1c3RvbVdpZHRoSGVpZ2h0P29iai5wcm9wZXJ0aWVzWydjaGFydC53aWR0aCddOnRoaXMud2lkdGg7fVxuaWYob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnZhbGlnbiddPT09J2NlbnRlcicpe29iai55LT1jdXN0b21XaWR0aEhlaWdodD8ob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmhlaWdodCddLzIpOih0aGlzLmhlaWdodC8yKTt9ZWxzZSBpZihvYmoucHJvcGVydGllc1snY2hhcnQudmFsaWduJ109PSdib3R0b20nKXtvYmoueS09Y3VzdG9tV2lkdGhIZWlnaHQ/b2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmhlaWdodCddOnRoaXMuaGVpZ2h0O31cbnRoaXMuYWxpZ25tZW50UHJvY2Vzc2VkPXRydWU7fX1cbmlmKHRoaXMuaW1nLmNvbXBsZXRlfHx0aGlzLmltZy5yZWFkeVN0YXRlPT09NCl7dGhpcy5pbWcub25sb2FkKCk7fVxuaWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLnNldFNoYWRvdyh0aGlzLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTt9XG52YXIgb2xkQWxwaGE9Y28uZ2xvYmFsQWxwaGE7Y28uZ2xvYmFsQWxwaGE9cHJvcFsnY2hhcnQuYWxwaGEnXTtpZihwcm9wWydjaGFydC5ib3JkZXInXSl7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yJ107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmJvcmRlci5saW5ld2lkdGgnXTt2YXIgYm9yZGVyUmFkaXVzPTA7aWYodGhpcy53aWR0aHx8dGhpcy5oZWlnaHQpe2JvcmRlclJhZGl1cz1tYS5taW4odGhpcy53aWR0aC8yLHRoaXMuaGVpZ2h0LzIpfVxuaWYoKHByb3BbJ2NoYXJ0LndpZHRoJ10vMik+Ym9yZGVyUmFkaXVzJiYocHJvcFsnY2hhcnQuaGVpZ2h0J10vMik+Ym9yZGVyUmFkaXVzKXtib3JkZXJSYWRpdXM9bWEubWluKChwcm9wWydjaGFydC53aWR0aCddLzIpLChwcm9wWydjaGFydC5oZWlnaHQnXS8yKSl9XG5pZihwcm9wWydjaGFydC5ib3JkZXIucmFkaXVzJ108Ym9yZGVyUmFkaXVzKXtib3JkZXJSYWRpdXM9cHJvcFsnY2hhcnQuYm9yZGVyLnJhZGl1cyddO31cbmNvLmJlZ2luUGF0aCgpO3RoaXMucm91bmRlZFJlY3QobWEucm91bmQodGhpcy54KS1tYS5yb3VuZChjby5saW5lV2lkdGgvMiksbWEucm91bmQodGhpcy55KS1tYS5yb3VuZChjby5saW5lV2lkdGgvMiksKHByb3BbJ2NoYXJ0LndpZHRoJ118fHRoaXMuaW1nLndpZHRoKStjby5saW5lV2lkdGgsKHByb3BbJ2NoYXJ0LmhlaWdodCddfHx0aGlzLmltZy5oZWlnaHQpK2NvLmxpbmVXaWR0aCxib3JkZXJSYWRpdXMpO31cbmlmKGJvcmRlclJhZGl1cyl7Y28uc2F2ZSgpO3RoaXMuZHJhd0JhY2tncm91bmRDb2xvcihib3JkZXJSYWRpdXMpO2NvLmJlZ2luUGF0aCgpO3RoaXMucm91bmRlZFJlY3QobWEucm91bmQodGhpcy54KS1tYS5yb3VuZChjby5saW5lV2lkdGgvMiksbWEucm91bmQodGhpcy55KS1tYS5yb3VuZChjby5saW5lV2lkdGgvMiksKHByb3BbJ2NoYXJ0LndpZHRoJ118fHRoaXMuaW1nLndpZHRoKStjby5saW5lV2lkdGgsKHByb3BbJ2NoYXJ0LmhlaWdodCddfHx0aGlzLmltZy5oZWlnaHQpK2NvLmxpbmVXaWR0aCxib3JkZXJSYWRpdXMpO2NvLmNsaXAoKTt9ZWxzZXt0aGlzLmRyYXdCYWNrZ3JvdW5kQ29sb3IoMCk7fVxuUkcubm9TaGFkb3codGhpcyk7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhlaWdodCddPT09J251bWJlcid8fHR5cGVvZiBwcm9wWydjaGFydC53aWR0aCddPT09J251bWJlcicpe2NvLmRyYXdJbWFnZSh0aGlzLmltZyxtYS5yb3VuZCh0aGlzLngpLG1hLnJvdW5kKHRoaXMueSkscHJvcFsnY2hhcnQud2lkdGgnXXx8dGhpcy53aWR0aCxwcm9wWydjaGFydC5oZWlnaHQnXXx8dGhpcy5oZWlnaHQpO31lbHNle2NvLmRyYXdJbWFnZSh0aGlzLmltZyxtYS5yb3VuZCh0aGlzLngpLG1hLnJvdW5kKHRoaXMueSkpO31cbmlmKGJvcmRlclJhZGl1cyl7Y28ucmVzdG9yZSgpO31cbmlmKHByb3BbJ2NoYXJ0LmJvcmRlciddKXtSRy5ub1NoYWRvdyh0aGlzKTtjby5zdHJva2UoKTt9XG5jby5nbG9iYWxBbHBoYT1vbGRBbHBoYTt0aGlzLmltZy5vbmxvYWQ9ZnVuY3Rpb24oKVxue1JHLnJlZHJhd0NhbnZhcyhjYSk7b2JqLmNvb3Jkc1swXT1bbWEucm91bmQob2JqLngpLG1hLnJvdW5kKG9iai55KSx0eXBlb2YgcHJvcFsnY2hhcnQud2lkdGgnXT09PSdudW1iZXInP3Byb3BbJ2NoYXJ0LndpZHRoJ106dGhpcy53aWR0aCx0eXBlb2YgcHJvcFsnY2hhcnQuaGVpZ2h0J109PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmhlaWdodCddOnRoaXMuaGVpZ2h0XTt9XG5SRy5ub1NoYWRvdyh0aGlzKTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2lmKHRoaXMuY29vcmRzJiZ0aGlzLmNvb3Jkc1swXSYmbW91c2VYWVswXT49dGhpcy5jb29yZHNbMF1bMF0mJm1vdXNlWFlbMF08PSh0aGlzLmNvb3Jkc1swXVswXSt0aGlzLmNvb3Jkc1swXVsyXSkmJm1vdXNlWFlbMV0+PXRoaXMuY29vcmRzWzBdWzFdJiZtb3VzZVhZWzFdPD0odGhpcy5jb29yZHNbMF1bMV0rdGhpcy5jb29yZHNbMF1bM10pKXtyZXR1cm57MDp0aGlzLDE6dGhpcy5jb29yZHNbMF1bMF0sMjp0aGlzLmNvb3Jkc1swXVsxXSwzOnRoaXMuY29vcmRzWzBdWzJdLDQ6dGhpcy5jb29yZHNbMF1bM10sNTowLCdvYmplY3QnOnRoaXMsJ3gnOnRoaXMuY29vcmRzWzBdWzBdLCd5Jzp0aGlzLmNvb3Jkc1swXVsxXSwnd2lkdGgnOnRoaXMuY29vcmRzWzBdWzJdLCdoZWlnaHQnOnRoaXMuY29vcmRzWzBdWzNdLCdpbmRleCc6MCwndG9vbHRpcCc6cHJvcFsnY2hhcnQudG9vbHRpcHMnXT9wcm9wWydjaGFydC50b29sdGlwcyddWzBdOm51bGx9O31cbnJldHVybiBudWxsO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle3BhMihjbyxbJ2InLCdyJyx0aGlzLmNvb3Jkc1swXVswXSx0aGlzLmNvb3Jkc1swXVsxXSx0aGlzLmNvb3Jkc1swXVsyXSx0aGlzLmNvb3Jkc1swXVszXSwnZicscHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSwncycscHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddXSk7fX19O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9XG5wcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3Ipe3JldHVybiBjb2xvcjt9XG5pZih0eXBlb2YgY29sb3I9PT0nc3RyaW5nJyYmY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6JyksZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLngsdGhpcy55LHRoaXMueCt0aGlzLmltZy53aWR0aCx0aGlzLnkpLGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLnJvdW5kZWRSZWN0PWZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQscmFkaXVzKVxue2NvLnNhdmUoKTtjby50cmFuc2xhdGUoeCx5KTtjby5tb3ZlVG8od2lkdGgvMiwwKTtjby5hcmNUbyh3aWR0aCwwLHdpZHRoLGhlaWdodCxtYS5taW4oaGVpZ2h0LzIscmFkaXVzKSk7Y28uYXJjVG8od2lkdGgsaGVpZ2h0LDAsaGVpZ2h0LG1hLm1pbih3aWR0aC8yLHJhZGl1cykpO2NvLmFyY1RvKDAsaGVpZ2h0LDAsMCxtYS5taW4oaGVpZ2h0LzIscmFkaXVzKSk7Y28uYXJjVG8oMCwwLHJhZGl1cywwLG1hLm1pbih3aWR0aC8yLHJhZGl1cykpO2NvLmxpbmVUbyh3aWR0aC8yLDApO2NvLnJlc3RvcmUoKTt9O3RoaXMuZHJhd0JhY2tncm91bmRDb2xvcj1mdW5jdGlvbihib3JkZXJSYWRpdXMpXG57Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTt0aGlzLnJvdW5kZWRSZWN0KG1hLnJvdW5kKHRoaXMueCktbWEucm91bmQoY28ubGluZVdpZHRoLzIpLG1hLnJvdW5kKHRoaXMueSktbWEucm91bmQoY28ubGluZVdpZHRoLzIpLChwcm9wWydjaGFydC53aWR0aCddfHx0aGlzLmltZy53aWR0aCkrY28ubGluZVdpZHRoLChwcm9wWydjaGFydC5oZWlnaHQnXXx8dGhpcy5pbWcuaGVpZ2h0KStjby5saW5lV2lkdGgsYm9yZGVyUmFkaXVzKTtjby5maWxsKCk7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmltYWdlLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///209\n");

/***/ }),
/* 210 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker1 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius == 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3],\n        text = arguments[4];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext(\"2d\");this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.text = text;this.type = 'drawing.marker1';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.linewidth': 2, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,0,0,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.align': 'center', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER1] No canvas support');return;\n  }\n  this.$0 = {};this.coords = [];this.coordsText = [];if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');var r = this.radius;if (prop['chart.align'] == 'left') {\n      this.markerCenterx = this.centerx - r - r - 3;this.markerCentery = this.centery - r - r - 3;\n    } else if (prop['chart.align'] == 'right') {\n      this.markerCenterx = this.centerx + r + r + 3;this.markerCentery = this.centery - r - r - 3;\n    } else {\n      this.markerCenterx = this.centerx;this.markerCentery = this.centery - r - r - 3;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];pa2(co, ['b', 'lw', prop['chart.linewidth']]);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.drawMarker();pa2(co, ['c', 's', prop['chart.strokestyle'], 'f', prop['chart.fillstyle']]);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] - 1, y: this.coords[0][1] - 1, text: this.text, valign: 'center', halign: 'center', tag: 'labels' });RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();this.drawMarker();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'radius': this.coords[0][2], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];this.drawMarker();co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.drawMarker = this.DrawMarker = function () {\n    var r = this.radius;if (prop['chart.align'] === 'left') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.TWOPI, false]);pa2(co, ['qc', x + r, y + r, x + r + r, y + r + r]);pa2(co, ['qc', x + r, y + r, x, y + r]);\n    } else if (prop['chart.align'] === 'right') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.PI, true]);pa2(co, ['qc', x - r, y + r, x - r - r, y + r + r]);pa2(co, ['qc', x - r, y + r, x, y + r]);\n    } else {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI / 2, RG.PI - RG.HALFPI / 2, true]);pa2(co, ['qc', x, y + r + r / 4, x, y + r + r - 2]);pa2(co, ['qc', x, y + r + r / 4, x + ma.cos(RG.HALFPI / 2) * r, y + ma.sin(RG.HALFPI / 2) * r]);\n    }\n    this.coords[0] = [x, y, r];\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.arrayClone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.markerCenterx, this.markerCentery, 0, this.markerCenterx, this.markerCentery, this.radius),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIxLmpzPzE2NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5NYXJrZXIxPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYueD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLnJhZGl1cz09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycmJnR5cGVvZiBjb25mLnRleHQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSx4PWNvbmYueCx5PWNvbmYueSxyYWRpdXM9Y29uZi5yYWRpdXMsdGV4dD1jb25mLnRleHQscGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkseD1hcmd1bWVudHNbMV0seT1hcmd1bWVudHNbMl0scmFkaXVzPWFyZ3VtZW50c1szXSx0ZXh0PWFyZ3VtZW50c1s0XTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWNhbnZhczt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO3RoaXMuY2VudGVyeD14O3RoaXMuY2VudGVyeT15O3RoaXMucmFkaXVzPXJhZGl1czt0aGlzLnRleHQ9dGV4dDt0aGlzLnR5cGU9J2RyYXdpbmcubWFya2VyMSc7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuc3Ryb2tlc3R5bGUnOidibGFjaycsJ2NoYXJ0LmZpbGxzdHlsZSc6J3doaXRlJywnY2hhcnQubGluZXdpZHRoJzoyLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5zaGFkb3cnOnRydWUsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6JyNhYWEnLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MCwnY2hhcnQuc2hhZG93Lm9mZnNldHknOjAsJ2NoYXJ0LnNoYWRvdy5ibHVyJzoxNSwnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDAsMCwwLjcpJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQuYWxpZ24nOidjZW50ZXInLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5NQVJLRVIxXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O3RoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzVGV4dD1bXTtpZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt2YXIgcj10aGlzLnJhZGl1cztpZihwcm9wWydjaGFydC5hbGlnbiddPT0nbGVmdCcpe3RoaXMubWFya2VyQ2VudGVyeD10aGlzLmNlbnRlcngtci1yLTM7dGhpcy5tYXJrZXJDZW50ZXJ5PXRoaXMuY2VudGVyeS1yLXItMzt9ZWxzZSBpZihwcm9wWydjaGFydC5hbGlnbiddPT0ncmlnaHQnKXt0aGlzLm1hcmtlckNlbnRlcng9dGhpcy5jZW50ZXJ4K3IrciszO3RoaXMubWFya2VyQ2VudGVyeT10aGlzLmNlbnRlcnktci1yLTM7fWVsc2V7dGhpcy5tYXJrZXJDZW50ZXJ4PXRoaXMuY2VudGVyeDt0aGlzLm1hcmtlckNlbnRlcnk9dGhpcy5jZW50ZXJ5LXItci0zO31cbmlmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5jb29yZHNUZXh0PVtdO3BhMihjbyxbJ2InLCdsdycscHJvcFsnY2hhcnQubGluZXdpZHRoJ11dKTtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31cbnRoaXMuZHJhd01hcmtlcigpO3BhMihjbyxbJ2MnLCdzJyxwcm9wWydjaGFydC5zdHJva2VzdHlsZSddLCdmJyxwcm9wWydjaGFydC5maWxsc3R5bGUnXV0pO1JHLm5vU2hhZG93KHRoaXMpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcudGV4dDIodGhpcyx7Zm9udDpwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxzaXplOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLHg6dGhpcy5jb29yZHNbMF1bMF0tMSx5OnRoaXMuY29vcmRzWzBdWzFdLTEsdGV4dDp0aGlzLnRleHQsdmFsaWduOidjZW50ZXInLGhhbGlnbjonY2VudGVyJyx0YWc6J2xhYmVscyd9KTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbntpZih0aGlzLmdldFNoYXBlKGUpKXtyZXR1cm4gdGhpczt9fTt0aGlzLmdldFNoYXBlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTtjby5iZWdpblBhdGgoKTt0aGlzLmRyYXdNYXJrZXIoKTtpZihjby5pc1BvaW50SW5QYXRoKG1vdXNlWFlbMF0sbW91c2VYWVsxXSkpe3JldHVybnswOnRoaXMsMTp0aGlzLmNvb3Jkc1swXVswXSwyOnRoaXMuY29vcmRzWzBdWzFdLDM6dGhpcy5jb29yZHNbMF1bMl0sNDowLCdvYmplY3QnOnRoaXMsJ3gnOnRoaXMuY29vcmRzWzBdWzBdLCd5Jzp0aGlzLmNvb3Jkc1swXVsxXSwncmFkaXVzJzp0aGlzLmNvb3Jkc1swXVsyXSwnaW5kZXgnOjAsJ3Rvb2x0aXAnOnByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10/cHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXTpudWxsfTt9XG5yZXR1cm4gbnVsbDt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKXtpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107dGhpcy5kcmF3TWFya2VyKCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO319fTt0aGlzLmRyYXdNYXJrZXI9dGhpcy5EcmF3TWFya2VyPWZ1bmN0aW9uKClcbnt2YXIgcj10aGlzLnJhZGl1cztpZihwcm9wWydjaGFydC5hbGlnbiddPT09J2xlZnQnKXt2YXIgeD10aGlzLm1hcmtlckNlbnRlcngseT10aGlzLm1hcmtlckNlbnRlcnk7cGEyKGNvLFsnYScseCx5LHIsUkcuSEFMRlBJLFJHLlRXT1BJLGZhbHNlXSk7cGEyKGNvLFsncWMnLHgrcix5K3IseCtyK3IseStyK3JdKTtwYTIoY28sWydxYycseCtyLHkrcix4LHkrcl0pO31lbHNlIGlmKHByb3BbJ2NoYXJ0LmFsaWduJ109PT0ncmlnaHQnKXt2YXIgeD10aGlzLm1hcmtlckNlbnRlcngseT10aGlzLm1hcmtlckNlbnRlcnk7cGEyKGNvLFsnYScseCx5LHIsUkcuSEFMRlBJLFJHLlBJLHRydWVdKTtwYTIoY28sWydxYycseC1yLHkrcix4LXItcix5K3Ircl0pO3BhMihjbyxbJ3FjJyx4LXIseStyLHgseStyXSk7fWVsc2V7dmFyIHg9dGhpcy5tYXJrZXJDZW50ZXJ4LHk9dGhpcy5tYXJrZXJDZW50ZXJ5O3BhMihjbyxbJ2EnLHgseSxyLFJHLkhBTEZQSS8yLFJHLlBJLShSRy5IQUxGUEkvMiksdHJ1ZV0pO3BhMihjbyxbJ3FjJyx4LHkrcisoci80KSx4LHkrcityLTJdKTtwYTIoY28sWydxYycseCx5K3IrKHIvNCkseCsobWEuY29zKFJHLkhBTEZQSS8yKSpyKSx5KyhtYS5zaW4oUkcuSEFMRlBJLzIpKnIpXSk7fVxudGhpcy5jb29yZHNbMF09W3gseSxyXTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5maWxsc3R5bGUnXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7fVxucHJvcFsnY2hhcnQuZmlsbHN0eWxlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pO3Byb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wWydjaGFydC50ZXh0LmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpLGdyYWQ9Y28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5tYXJrZXJDZW50ZXJ4LHRoaXMubWFya2VyQ2VudGVyeSwwLHRoaXMubWFya2VyQ2VudGVyeCx0aGlzLm1hcmtlckNlbnRlcnksdGhpcy5yYWRpdXMpLGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLm1hcmtlcjEuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///210\n");

/***/ }),
/* 211 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker2 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.text = text;this.type = 'drawing.marker2';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.voffset': 20, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER2] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.lineWidth = 1;RG.fireCustomEvent(this, 'onbeforedraw');this.metrics = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);if (this.x + this.metrics[0] >= ca.width) {\n      this.alignRight = true;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var x = this.alignRight ? this.x - this.metrics[0] - 6 : this.x,\n        y = this.y - 6 - prop['chart.voffset'] - this.metrics[1],\n        width = this.metrics[0] + 6,\n        height = this.metrics[1] + 6;this.coords[0] = [x, y, width, height];this.coordsText = [];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];co.strokeRect(x + (this.alignRight ? width : 0), y, 0, height + prop['chart.voffset'] - 6);co.strokeRect(x, y, width, height);co.fillRect(x, y, width, height);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: ma.round(this.x) - (this.alignRight ? this.metrics[0] + 3 : -3), y: this.y - 3 - prop['chart.voffset'], text: this.text, valign: 'bottom', halign: 'left', tag: 'labels' });this.coords[0].push([x, y, width, height]);RG.noShadow(this);co.textBaseline = 'alphabetic';RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.coords[0][0] && mouseX <= this.coords[0][0] + this.coords[0][2]) {\n      if (mouseY >= this.coords[0][1] && mouseY <= this.coords[0][1] + this.coords[0][3]) {\n        return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.metrics[0], this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIyLmpzP2VjZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5NYXJrZXIyPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYueD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycmJnR5cGVvZiBjb25mLnRleHQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSx4PWNvbmYueCx5PWNvbmYueSx0ZXh0PWNvbmYudGV4dCxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSx4PWFyZ3VtZW50c1sxXSx5PWFyZ3VtZW50c1syXSx0ZXh0PWFyZ3VtZW50c1szXTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG50aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLng9eDt0aGlzLnk9eTt0aGlzLnRleHQ9dGV4dDt0aGlzLnR5cGU9J2RyYXdpbmcubWFya2VyMic7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuc3Ryb2tlc3R5bGUnOidibGFjaycsJ2NoYXJ0LmZpbGxzdHlsZSc6J3doaXRlJywnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuc2hhZG93Jzp0cnVlLCdjaGFydC5zaGFkb3cuY29sb3InOidncmF5JywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzozLCdjaGFydC5zaGFkb3cuYmx1cic6NSwnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LnZvZmZzZXQnOjIwLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5NQVJLRVIyXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy4kMD17fTtpZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue2NvLmxpbmVXaWR0aD0xO1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLm1ldHJpY3M9UkcubWVhc3VyZVRleHQodGhpcy50ZXh0LHByb3BbJ2NoYXJ0LnRleHQuYm9sZCddLHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKTtpZih0aGlzLngrdGhpcy5tZXRyaWNzWzBdPj1jYS53aWR0aCl7dGhpcy5hbGlnblJpZ2h0PXRydWU7fVxuaWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG52YXIgeD10aGlzLmFsaWduUmlnaHQ/dGhpcy54LXRoaXMubWV0cmljc1swXS02OnRoaXMueCx5PXRoaXMueS02LXByb3BbJ2NoYXJ0LnZvZmZzZXQnXS10aGlzLm1ldHJpY3NbMV0sd2lkdGg9dGhpcy5tZXRyaWNzWzBdKzYsaGVpZ2h0PXRoaXMubWV0cmljc1sxXSs2O3RoaXMuY29vcmRzWzBdPVt4LHksd2lkdGgsaGVpZ2h0XTt0aGlzLmNvb3Jkc1RleHQ9W107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5zZXRTaGFkb3codGhpcyxwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10scHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7fVxuY28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ107Y28uc3Ryb2tlUmVjdCh4Kyh0aGlzLmFsaWduUmlnaHQ/d2lkdGg6MCkseSwwLGhlaWdodCtwcm9wWydjaGFydC52b2Zmc2V0J10tNik7Y28uc3Ryb2tlUmVjdCh4LHksd2lkdGgsaGVpZ2h0KTtjby5maWxsUmVjdCh4LHksd2lkdGgsaGVpZ2h0KTtSRy5ub1NoYWRvdyh0aGlzKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO1JHLnRleHQyKHRoaXMse2ZvbnQ6cHJvcFsnY2hhcnQudGV4dC5mb250J10sc2l6ZTpwcm9wWydjaGFydC50ZXh0LnNpemUnXSx4Om1hLnJvdW5kKHRoaXMueCktKHRoaXMuYWxpZ25SaWdodD90aGlzLm1ldHJpY3NbMF0rMzotMykseTp0aGlzLnktMy1wcm9wWydjaGFydC52b2Zmc2V0J10sdGV4dDp0aGlzLnRleHQsdmFsaWduOidib3R0b20nLGhhbGlnbjonbGVmdCcsdGFnOidsYWJlbHMnfSk7dGhpcy5jb29yZHNbMF0ucHVzaChbeCx5LHdpZHRoLGhlaWdodF0pO1JHLm5vU2hhZG93KHRoaXMpO2NvLnRleHRCYXNlbGluZT0nYWxwaGFiZXRpYyc7UkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57aWYodGhpcy5nZXRTaGFwZShlKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5nZXRTaGFwZT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSksbW91c2VYPW1vdXNlWFlbMF0sbW91c2VZPW1vdXNlWFlbMV07aWYobW91c2VYPj10aGlzLmNvb3Jkc1swXVswXSYmbW91c2VYPD0odGhpcy5jb29yZHNbMF1bMF0rdGhpcy5jb29yZHNbMF1bMl0pKXtpZihtb3VzZVk+PXRoaXMuY29vcmRzWzBdWzFdJiZtb3VzZVk8PSh0aGlzLmNvb3Jkc1swXVsxXSt0aGlzLmNvb3Jkc1swXVszXSkpe3JldHVybnswOnRoaXMsMTp0aGlzLmNvb3Jkc1swXVswXSwyOnRoaXMuY29vcmRzWzBdWzFdLDM6dGhpcy5jb29yZHNbMF1bMl0sNDp0aGlzLmNvb3Jkc1swXVszXSw1OjAsJ29iamVjdCc6dGhpcywneCc6dGhpcy5jb29yZHNbMF1bMF0sJ3knOnRoaXMuY29vcmRzWzBdWzFdLCd3aWR0aCc6dGhpcy5jb29yZHNbMF1bMl0sJ2hlaWdodCc6dGhpcy5jb29yZHNbMF1bM10sJ2luZGV4JzowLCd0b29sdGlwJzpwcm9wWydjaGFydC50b29sdGlwcyddP3Byb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF06bnVsbH07fX1cbnJldHVybiBudWxsO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle3BhMihjbyxbJ2InLCdyJyx0aGlzLmNvb3Jkc1swXVswXSx0aGlzLmNvb3Jkc1swXVsxXSx0aGlzLmNvb3Jkc1swXVsyXSx0aGlzLmNvb3Jkc1swXVszXSwnZicscHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSwncycscHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddXSk7fX19O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5maWxsc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50ZXh0LmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTt9XG5wcm9wWydjaGFydC5maWxsc3R5bGUnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3Ipe3JldHVybiBjb2xvcjt9XG5pZih0eXBlb2YgY29sb3I9PT0nc3RyaW5nJyYmY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6JyksZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLngsdGhpcy55LHRoaXMueCt0aGlzLm1ldHJpY3NbMF0sdGhpcy55KSxkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIyLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///211\n");

/***/ }),
/* 212 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker3 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.radius === 'number') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.actualRadius = 0;this.alpha = 1;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.marker3';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.fillstyle': 'rgba(255,255,255,1)', 'chart.delay': 50, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.fill': 'rgba(255,0,0,1.0)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER3] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.globalAlpha = this.alpha;pa2(co, ['b', 'a', this.centerx, this.centery, this.actualRadius, 0, 2 * Math.PI, false, 'a', this.centerx, this.centery, ma.max(this.actualRadius - 8, 0), 2 * Math.PI, 0, true, 'f', prop['chart.fillstyle']]);this.alpha = this.actualRadius ? 1 - this.actualRadius * 0.75 / this.radius : 1;co.globalAlpha = 1;if (this.actualRadius < this.radius) {\n      this.actualRadius += 2;\n    } else if (this.actualRadius >= this.radius) {\n      this.actualRadius = 0;this.alpha = 1;\n    }\n    if (!this.TIMER) {\n      var obj = this;setInterval(function () {\n        RG.redrawCanvas(ca);\n      }, prop['chart.delay']);this.TIMER = true;\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIzLmpzP2Q3ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5NYXJrZXIzPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYueD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycmJnR5cGVvZiBjb25mLnJhZGl1cz09PSdudW1iZXInKXt2YXIgaWQ9Y29uZi5pZCxjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLHg9Y29uZi54LHk9Y29uZi55LHJhZGl1cz1jb25mLnJhZGl1cyxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSx4PWFyZ3VtZW50c1sxXSx5PWFyZ3VtZW50c1syXSxyYWRpdXM9YXJndW1lbnRzWzNdO31cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcbnRoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO3RoaXMuYWN0dWFsUmFkaXVzPTA7dGhpcy5hbHBoYT0xO3RoaXMuY2VudGVyeD14O3RoaXMuY2VudGVyeT15O3RoaXMucmFkaXVzPXJhZGl1czt0aGlzLnR5cGU9J2RyYXdpbmcubWFya2VyMyc7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuZmlsbHN0eWxlJzoncmdiYSgyNTUsMjU1LDI1NSwxKScsJ2NoYXJ0LmRlbGF5Jzo1MCwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDAsMCwxLjApJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmlmKCF0aGlzLmNhbnZhcyl7YWxlcnQoJ1tEUkFXSU5HLk1BUktFUjNdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbnRoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzVGV4dD1bXTt0aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoO2lmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntjby5nbG9iYWxBbHBoYT10aGlzLmFscGhhO3BhMihjbyxbJ2InLCdhJyx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMuYWN0dWFsUmFkaXVzLDAsMipNYXRoLlBJLGZhbHNlLCdhJyx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG1hLm1heCh0aGlzLmFjdHVhbFJhZGl1cy04LDApLDIqTWF0aC5QSSwwLHRydWUsJ2YnLHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddXSk7dGhpcy5hbHBoYT10aGlzLmFjdHVhbFJhZGl1cz8xLSgodGhpcy5hY3R1YWxSYWRpdXMqMC43NSkvdGhpcy5yYWRpdXMpOjE7Y28uZ2xvYmFsQWxwaGE9MTtpZih0aGlzLmFjdHVhbFJhZGl1czx0aGlzLnJhZGl1cyl7dGhpcy5hY3R1YWxSYWRpdXMrPTI7fWVsc2UgaWYodGhpcy5hY3R1YWxSYWRpdXM+PXRoaXMucmFkaXVzKXt0aGlzLmFjdHVhbFJhZGl1cz0wO3RoaXMuYWxwaGE9MTt9XG5pZighdGhpcy5USU1FUil7dmFyIG9iaj10aGlzO3NldEludGVydmFsKGZ1bmN0aW9uKClcbntSRy5yZWRyYXdDYW52YXMoY2EpO30scHJvcFsnY2hhcnQuZGVsYXknXSk7dGhpcy5USU1FUj10cnVlO31cblJHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2lmKFJHLmdldEh5cExlbmd0aCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG1vdXNlWFlbMF0sbW91c2VYWVsxXSk8PXRoaXMucmFkaXVzKXtyZXR1cm57MDp0aGlzLDE6dGhpcy5jZW50ZXJ4LDI6dGhpcy5jZW50ZXJ5LDM6dGhpcy5yYWRpdXMsNDpudWxsLDU6MCwnb2JqZWN0Jzp0aGlzLCd4Jzp0aGlzLmNlbnRlcngsJ3knOnRoaXMuY2VudGVyeSwncmFkaXVzJzp0aGlzLnJhZGl1cywnaW5kZXgnOjAsJ3Rvb2x0aXAnOnByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10/cHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXTpudWxsfTt9XG5yZXR1cm4gbnVsbDt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKXtpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXtwYTIoY28sWydiJywncicsdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5jb29yZHNbMF1bMl0sdGhpcy5jb29yZHNbMF1bM10sJ2YnLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sJ3MnLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXV0pO319fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZmlsbHN0eWxlJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9XG5wcm9wWydjaGFydC5maWxsc3R5bGUnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yKXtyZXR1cm4gY29sb3I7fVxuaWYodHlwZW9mIGNvbG9yPT09J3N0cmluZycmJmNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpLGdyYWQ9Y28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwwLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMpLGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2Zvcih2YXIgaj0wO2o8cGFydHMubGVuZ3RoO2orPTEpe2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIzLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///212\n");

/***/ }),
/* 213 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Poly = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.coords) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        coords = conf.coords,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        coords = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.coords = coords;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.poly';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.linewidth': 1, 'chart.strokestyle': 'black', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.override': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.2)', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.POLY] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];var obj = this;pa2(co, ['b', 'fu', function (obj) {\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];co.shadowBlur = prop['chart.shadow.blur'];\n      }\n    }, 'fu', function (obj) {\n      co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];obj.drawPoly();\n    }, 'lw', prop['chart.linewidth'], 'f', prop['chart.fillstyle'], 'fu', function () {\n      RG.noShadow(obj);\n    }, 's', prop['chart.strokestyle']]);RG.noShadow(this);\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawPoly = this.DrawPoly = function () {\n    var coords = this.coords;pa2(co, ['b', 'm', coords[0][0], coords[0][1]]);for (var i = 1, len = coords.length; i < len; ++i) {\n      co.lineTo(coords[i][0], coords[i][1]);\n    }\n    pa2(co, ['lw', prop['chart.linewidth'], 'c', 'f', co.fillStyle, 's', co.strokeStyle]);\n  };this.getShape = function (e) {\n    var coords = this.coords,\n        mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = 'rgba(0,0,0,0)';this.drawPoly();if (co.isPointInPath(mouseX, mouseY)) {\n      return { 0: this, 1: this.coords, 2: 0, 'object': this, 'coords': this.coords, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    co.fillStyle = prop['chart.fillstyle'];if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'fu', function (obj) {\n          obj.DrawPoly();\n        }, 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    var func = this.parseSingleColorForGradient;prop['chart.fillstyle'] = func(prop['chart.fillstyle']);prop['chart.strokestyle'] = func(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = func(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = func(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5wb2x5LmpzPzc5YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5Qb2x5PWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuY29vcmRzPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkLGNvb3Jkcz1jb25mLmNvb3JkcyxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYsY29vcmRzPWFyZ3VtZW50c1sxXTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLmNvb3Jkcz1jb29yZHM7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy50eXBlPSdkcmF3aW5nLnBvbHknO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLnVpZD1SR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkPXRoaXMuY2FudmFzLnVpZD90aGlzLmNhbnZhcy51aWQ6UkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMucHJvcGVydGllcz17J2NoYXJ0LmxpbmV3aWR0aCc6MSwnY2hhcnQuc3Ryb2tlc3R5bGUnOidibGFjaycsJ2NoYXJ0LmZpbGxzdHlsZSc6J3JlZCcsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLm92ZXJyaWRlJzpudWxsLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5zaGFkb3cnOmZhbHNlLCdjaGFydC5zaGFkb3cuY29sb3InOidyZ2JhKDAsMCwwLDAuMiknLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MywnY2hhcnQuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0LnNoYWRvdy5ibHVyJzo1LCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5QT0xZXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoO2lmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmNvb3Jkc1RleHQ9W107dmFyIG9iaj10aGlzO3BhMihjbyxbJ2InLCdmdScsZnVuY3Rpb24ob2JqKXtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Y28uc2hhZG93Q29sb3I9cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFk9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtjby5zaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ107fX0sJ2Z1JyxmdW5jdGlvbihvYmopXG57Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ107b2JqLmRyYXdQb2x5KCk7fSwnbHcnLHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddLCdmJyxwcm9wWydjaGFydC5maWxsc3R5bGUnXSwnZnUnLGZ1bmN0aW9uKClcbntSRy5ub1NoYWRvdyhvYmopO30sJ3MnLHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ11dKTtSRy5ub1NoYWRvdyh0aGlzKVxuUkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57aWYodGhpcy5nZXRTaGFwZShlKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5kcmF3UG9seT10aGlzLkRyYXdQb2x5PWZ1bmN0aW9uKClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzO3BhMihjbyxbJ2InLCdtJyxjb29yZHNbMF1bMF0sY29vcmRzWzBdWzFdXSk7Zm9yKHZhciBpPTEsbGVuPWNvb3Jkcy5sZW5ndGg7aTxsZW47KytpKXtjby5saW5lVG8oY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSk7fVxucGEyKGNvLFsnbHcnLHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddLCdjJywnZicsY28uZmlsbFN0eWxlLCdzJyxjby5zdHJva2VTdHlsZV0pO307dGhpcy5nZXRTaGFwZT1mdW5jdGlvbihlKVxue3ZhciBjb29yZHM9dGhpcy5jb29yZHMsbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPSdyZ2JhKDAsMCwwLDApJztjby5maWxsU3R5bGU9J3JnYmEoMCwwLDAsMCknO3RoaXMuZHJhd1BvbHkoKTtpZihjby5pc1BvaW50SW5QYXRoKG1vdXNlWCxtb3VzZVkpKXtyZXR1cm57MDp0aGlzLDE6dGhpcy5jb29yZHMsMjowLCdvYmplY3QnOnRoaXMsJ2Nvb3Jkcyc6dGhpcy5jb29yZHMsJ2luZGV4JzowLCd0b29sdGlwJzpwcm9wWydjaGFydC50b29sdGlwcyddP3Byb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF06bnVsbH07fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ107aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle3BhMihjbyxbJ2InLCdmdScsZnVuY3Rpb24ob2JqKXtvYmouRHJhd1BvbHkoKTt9LCdmJyxwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddLCdzJyxwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ11dKTt9fX07dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7fVxudmFyIGZ1bmM9dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ7cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ109ZnVuYyhwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT1mdW5jKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1mdW5jKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1mdW5jKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3Ipe3JldHVybiBjb2xvcjt9XG5pZih0eXBlb2YgY29sb3I9PT0nc3RyaW5nJyYmY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6JyksZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLDAsY2Eud2lkdGgsMCksZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTEsbGVuPXBhcnRzLmxlbmd0aDtqPGxlbjsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5wb2x5LmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///213\n");

/***/ }),
/* 214 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Rect = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.width === 'number' && typeof conf.height === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        x = conf.x,\n        y = conf.y,\n        width = conf.width,\n        height = conf.height,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        x = arguments[1],\n        y = arguments[2],\n        width = arguments[3],\n        height = arguments[4];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.coordsText = [];this.firstDraw = true;this.type = 'drawing.rect';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.tooltips.valign': 'top', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.RECT] No canvas support');return;\n  }\n  this.coords = [[Math.round(x), Math.round(y), width, height]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, ['b']);if (prop['chart.shadow']) {\n      pa2(co, ['sc', prop['chart.shadow.color'], 'sx', prop['chart.shadow.offsetx'], 'sy', prop['chart.shadow.offsety'], 'sb', prop['chart.shadow.blur']]);\n    }\n    pa2(co, ['r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.fillstyle']]);RG.NoShadow(this);pa2(co, ['s', prop['chart.strokestyle']]);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var coords = this.coords[i];var left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5yZWN0LmpzPzFlZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5SZWN0PWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYueD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLndpZHRoPT09J251bWJlcicmJnR5cGVvZiBjb25mLmhlaWdodD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgaWQ9Y29uZi5pZCx4PWNvbmYueCx5PWNvbmYueSx3aWR0aD1jb25mLndpZHRoLGhlaWdodD1jb25mLmhlaWdodCxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYseD1hcmd1bWVudHNbMV0seT1hcmd1bWVudHNbMl0sd2lkdGg9YXJndW1lbnRzWzNdLGhlaWdodD1hcmd1bWVudHNbNF07fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy50eXBlPSdkcmF3aW5nLnJlY3QnO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLnVpZD1SR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkPXRoaXMuY2FudmFzLnVpZD90aGlzLmNhbnZhcy51aWQ6UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMucHJvcGVydGllcz17J2NoYXJ0LnN0cm9rZXN0eWxlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmZpbGxzdHlsZSc6J3JlZCcsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonZ3JheScsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzozLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MywnY2hhcnQuc2hhZG93LmJsdXInOjUsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidibGFjaycsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuY29vcmRzLnBhZ2UnOmZhbHNlLCdjaGFydC50b29sdGlwcy52YWxpZ24nOid0b3AnLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5SRUNUXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLmNvb3Jkcz1bW01hdGgucm91bmQoeCksTWF0aC5yb3VuZCh5KSx3aWR0aCxoZWlnaHRdXTt0aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoO2lmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7dGhpcy5jb29yZHNUZXh0PVtdO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxucGEyKGNvLFsnYiddKTtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7cGEyKGNvLFsnc2MnLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCdzeCcscHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwnc3knLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sJ3NiJyxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddXSk7fVxucGEyKGNvLFsncicsdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5jb29yZHNbMF1bMl0sdGhpcy5jb29yZHNbMF1bM10sJ2YnLHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddXSk7UkcuTm9TaGFkb3codGhpcyk7cGEyKGNvLFsncycscHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXV0pO1JHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSsrKXt2YXIgY29vcmRzPXRoaXMuY29vcmRzW2ldO3ZhciBsZWZ0PWNvb3Jkc1swXSx0b3A9Y29vcmRzWzFdLHdpZHRoPWNvb3Jkc1syXSxoZWlnaHQ9Y29vcmRzWzNdO2lmKG1vdXNlWD49bGVmdCYmbW91c2VYPD0obGVmdCt3aWR0aCkmJm1vdXNlWT49dG9wJiZtb3VzZVk8PSh0b3AraGVpZ2h0KSl7cmV0dXJuezA6dGhpcywxOmxlZnQsMjp0b3AsMzp3aWR0aCw0OmhlaWdodCw1OjAsJ29iamVjdCc6dGhpcywneCc6bGVmdCwneSc6dG9wLCd3aWR0aCc6d2lkdGgsJ2hlaWdodCc6aGVpZ2h0LCdpbmRleCc6MCwndG9vbHRpcCc6cHJvcFsnY2hhcnQudG9vbHRpcHMnXT9wcm9wWydjaGFydC50b29sdGlwcyddWzBdOm51bGx9O319XG5yZXR1cm4gbnVsbDt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle1JHLkhpZ2hsaWdodC5yZWN0KHRoaXMsc2hhcGUpO319O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5maWxsc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO31cbnByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcil7cmV0dXJuIGNvbG9yO31cbmlmKHR5cGVvZiBjb2xvcj09PSdzdHJpbmcnJiZjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKSxncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsMCxjYS53aWR0aCwwKSxkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MSxsZW49cGFydHMubGVuZ3RoO2o8bGVuOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnJlY3QuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///214\n");

/***/ }),
/* 215 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Text = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var y = conf.y;var text = String(conf.text);var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];var y = arguments[2];var text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.x = x;this.y = y;this.text = String(text);this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.text';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.size': 10, 'chart.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.bold': false, 'chart.angle': 0, 'chart.colors': ['black'], 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.stroke': '#ccc', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.bounding': false, 'chart.bounding.fill': 'rgba(255,255,255,0.7)', 'chart.bounding.stroke': '#777', 'chart.bounding.shadow': false, 'chart.bounding.shadow.color': '#ccc', 'chart.bounding.shadow.blur': 3, 'chart.bounding.shadow.offsetx': 3, 'chart.bounding.shadow.offsety': 3, 'chart.marker': false, 'chart.halign': 'left', 'chart.valign': 'bottom', 'chart.link': null, 'chart.link.target': '_self', 'chart.link.options': '', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)', 'chart.shadow': false, 'chart.shadow.color': '#ccc', 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3 };\n  if (!this.canvas) {\n    alert('[DRAWING.TEXT] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coords = [];this.coordsText = [];var dimensions = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);co.fillStyle = prop['chart.colors'][0];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var ret = RG.text2(this, { font: prop['chart.font'], size: prop['chart.size'], x: this.x, y: this.y, text: this.text, bold: prop['chart.bold'], angle: prop['chart.angle'], bounding: prop['chart.bounding'], 'bounding.fill': prop['chart.bounding.fill'], 'bounding.stroke': prop['chart.bounding.stroke'], 'bounding.shadow': prop['chart.bounding.shadow'], 'bounding.shadow.color': prop['chart.bounding.shadow.color'], 'bounding.shadow.blur': prop['chart.bounding.shadow.blur'], 'bounding.shadow.offsetx': prop['chart.bounding.shadow.offsetx'], 'bounding.shadow.offsety': prop['chart.bounding.shadow.offsety'], marker: prop['chart.marker'], halign: prop['chart.halign'], valign: prop['chart.valign'] });if (prop['chart.shadow']) {\n      RG.noShadow(this);\n    }\n    this.coords.push({ 0: ret.x, 'x': ret.x, 1: ret.y, 'y': ret.y, 2: ret.width, 'width': ret.width, 3: ret.height, 'height': ret.height });RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var prop = this.properties;var coords = this.coords;var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = coords[i].x;var top = coords[i].y;var width = coords[i].width;var height = coords[i].height;if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors'])[0];this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, 0, ca.width, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy50ZXh0LmpzP2MyNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5EcmF3aW5nPVJHcmFwaC5EcmF3aW5nfHx7fTtSR3JhcGguRHJhd2luZy5UZXh0PWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYueD09PSdudW1iZXInJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkXG52YXIgeD1jb25mLng7dmFyIHk9Y29uZi55O3ZhciB0ZXh0PVN0cmluZyhjb25mLnRleHQpO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmY7dmFyIHg9YXJndW1lbnRzWzFdO3ZhciB5PWFyZ3VtZW50c1syXTt2YXIgdGV4dD1hcmd1bWVudHNbM107fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMueD14O3RoaXMueT15O3RoaXMudGV4dD1TdHJpbmcodGV4dCk7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy50eXBlPSdkcmF3aW5nLnRleHQnO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLnVpZD1SR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkPXRoaXMuY2FudmFzLnVpZD90aGlzLmNhbnZhcy51aWQ6UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMucHJvcGVydGllcz17J2NoYXJ0LnNpemUnOjEwLCdjaGFydC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQuYm9sZCc6ZmFsc2UsJ2NoYXJ0LmFuZ2xlJzowLCdjaGFydC5jb2xvcnMnOlsnYmxhY2snXSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzonI2NjYycsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuY29vcmRzLnBhZ2UnOmZhbHNlLCdjaGFydC5ib3VuZGluZyc6ZmFsc2UsJ2NoYXJ0LmJvdW5kaW5nLmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5ib3VuZGluZy5zdHJva2UnOicjNzc3JywnY2hhcnQuYm91bmRpbmcuc2hhZG93JzpmYWxzZSwnY2hhcnQuYm91bmRpbmcuc2hhZG93LmNvbG9yJzonI2NjYycsJ2NoYXJ0LmJvdW5kaW5nLnNoYWRvdy5ibHVyJzozLCdjaGFydC5ib3VuZGluZy5zaGFkb3cub2Zmc2V0eCc6MywnY2hhcnQuYm91bmRpbmcuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0Lm1hcmtlcic6ZmFsc2UsJ2NoYXJ0LmhhbGlnbic6J2xlZnQnLCdjaGFydC52YWxpZ24nOidib3R0b20nLCdjaGFydC5saW5rJzpudWxsLCdjaGFydC5saW5rLnRhcmdldCc6J19zZWxmJywnY2hhcnQubGluay5vcHRpb25zJzonJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonI2NjYycsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzoyLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQuc2hhZG93LmJsdXInOjN9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRFJBV0lORy5URVhUXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3ZhciBkaW1lbnNpb25zPVJHLm1lYXN1cmVUZXh0KHRoaXMudGV4dCxwcm9wWydjaGFydC50ZXh0LmJvbGQnXSxwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxwcm9wWydjaGFydC50ZXh0LnNpemUnXSk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5zZXRTaGFkb3codGhpcyxwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10scHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7fVxudmFyIHJldD1SRy50ZXh0Mih0aGlzLHtmb250OnByb3BbJ2NoYXJ0LmZvbnQnXSxzaXplOnByb3BbJ2NoYXJ0LnNpemUnXSx4OnRoaXMueCx5OnRoaXMueSx0ZXh0OnRoaXMudGV4dCxib2xkOnByb3BbJ2NoYXJ0LmJvbGQnXSxhbmdsZTpwcm9wWydjaGFydC5hbmdsZSddLGJvdW5kaW5nOnByb3BbJ2NoYXJ0LmJvdW5kaW5nJ10sJ2JvdW5kaW5nLmZpbGwnOnByb3BbJ2NoYXJ0LmJvdW5kaW5nLmZpbGwnXSwnYm91bmRpbmcuc3Ryb2tlJzpwcm9wWydjaGFydC5ib3VuZGluZy5zdHJva2UnXSwnYm91bmRpbmcuc2hhZG93Jzpwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cnXSwnYm91bmRpbmcuc2hhZG93LmNvbG9yJzpwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cuY29sb3InXSwnYm91bmRpbmcuc2hhZG93LmJsdXInOnByb3BbJ2NoYXJ0LmJvdW5kaW5nLnNoYWRvdy5ibHVyJ10sJ2JvdW5kaW5nLnNoYWRvdy5vZmZzZXR4Jzpwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cub2Zmc2V0eCddLCdib3VuZGluZy5zaGFkb3cub2Zmc2V0eSc6cHJvcFsnY2hhcnQuYm91bmRpbmcuc2hhZG93Lm9mZnNldHknXSxtYXJrZXI6cHJvcFsnY2hhcnQubWFya2VyJ10saGFsaWduOnByb3BbJ2NoYXJ0LmhhbGlnbiddLHZhbGlnbjpwcm9wWydjaGFydC52YWxpZ24nXX0pO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5ub1NoYWRvdyh0aGlzKTt9XG50aGlzLmNvb3Jkcy5wdXNoKHswOnJldC54LCd4JzpyZXQueCwxOnJldC55LCd5JzpyZXQueSwyOnJldC53aWR0aCwnd2lkdGgnOnJldC53aWR0aCwzOnJldC5oZWlnaHQsJ2hlaWdodCc6cmV0LmhlaWdodH0pO1JHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7dmFyIGNvb3Jkcz10aGlzLmNvb3Jkczt2YXIgbW91c2VYWT1SR3JhcGguZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlWFlbMF07dmFyIG1vdXNlWT1tb3VzZVhZWzFdO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSsrKXt2YXIgbGVmdD1jb29yZHNbaV0ueDt2YXIgdG9wPWNvb3Jkc1tpXS55O3ZhciB3aWR0aD1jb29yZHNbaV0ud2lkdGg7dmFyIGhlaWdodD1jb29yZHNbaV0uaGVpZ2h0O2lmKG1vdXNlWD49bGVmdCYmbW91c2VYPD0obGVmdCt3aWR0aCkmJm1vdXNlWT49dG9wJiZtb3VzZVk8PSh0b3AraGVpZ2h0KSl7cmV0dXJuezA6dGhpcywxOmxlZnQsMjp0b3AsMzp3aWR0aCw0OmhlaWdodCw1OjAsJ29iamVjdCc6dGhpcywneCc6bGVmdCwneSc6dG9wLCd3aWR0aCc6d2lkdGgsJ2hlaWdodCc6aGVpZ2h0LCdpbmRleCc6MCwndG9vbHRpcCc6cHJvcFsnY2hhcnQudG9vbHRpcHMnXT9wcm9wWydjaGFydC50b29sdGlwcyddWzBdOm51bGx9O319XG5yZXR1cm4gbnVsbDt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle1JHLkhpZ2hsaWdodC5SZWN0KHRoaXMsc2hhcGUpO319O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSlbMF07dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7fVxucHJvcFsnY2hhcnQuY29sb3JzJ11bMF09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11bMF0pO3Byb3BbJ2NoYXJ0LmZpbGxzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcil7cmV0dXJuIGNvbG9yO31cbmlmKHR5cGVvZiBjb2xvcj09PSdzdHJpbmcnJiZjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLDAsY2Eud2lkdGgsMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkdyYXBoLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MSxsZW49cGFydHMubGVuZ3RoO2o8bGVuOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmRyYXdpbmcudGV4dC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///215\n");

/***/ }),
/* 216 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.XAxis = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var y = conf.y;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var y = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.y = y;this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.xaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.position': 'section', 'chart.colors': ['black'], 'chart.title.color': null, 'chart.text.color': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'bottom', 'chart.numlabels': 5, 'chart.scale.visible': true, 'chart.scale.formatter': null, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.invert': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.title': '', 'chart.numticks': null, 'chart.hmargin': 0, 'chart.linewidth': 1, 'chart.noendtick.left': false, 'chart.noendtick.right': false, 'chart.noxaxis': false, 'chart.max': null, 'chart.min': 0, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.XAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels' && !prop['chart.numxticks']) {\n      prop['chart.numxticks'] = value.length;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawXAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.y - (prop['chart.align'] == 'top' ? prop['chart.text.size'] * 1.5 + 5 : 0) && mouseY <= this.y + (prop['chart.align'] == 'top' ? 0 : prop['chart.text.size'] * 1.5 + 5)) {\n      var x = this.gutterLeft;var y = this.y;var w = ca.width - this.gutterLeft - this.gutterRight;var h = 15;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawXAxis = this.DrawXAxis = function () {\n    var gutterLeft = prop['chart.gutter.left'],\n        gutterRight = prop['chart.gutter.right'],\n        x = this.gutterLeft,\n        y = this.y,\n        min = +prop['chart.min'],\n        max = +prop['chart.max'],\n        labels = prop['chart.labels'],\n        labels_position = prop['chart.labels.position'],\n        color = prop['chart.colors'][0],\n        title_color = prop['chart.title.color'],\n        label_color = prop['chart.text.color'],\n        width = ca.width - this.gutterLeft - this.gutterRight,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        align = prop['chart.align'],\n        numlabels = prop['chart.numlabels'],\n        formatter = prop['chart.scale.formatter'],\n        decimals = Number(prop['chart.scale.decimals']),\n        invert = prop['chart.scale.invert'],\n        scale_visible = prop['chart.scale.visible'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        title = prop['chart.title'];\n    numticks = prop['chart.numticks'], hmargin = prop['chart.hmargin'], linewidth = prop['chart.linewidth'], noleftendtick = prop['chart.noendtick.left'], norightendtick = prop['chart.noendtick.right'], noxaxis = prop['chart.noxaxis'], xaxispos = prop['chart.xaxispos'], yaxispos = prop['chart.yaxispos'];\n    if (RG.is_null(numticks)) {\n      if (labels && labels.length) {\n        numticks = labels.length;\n      } else if (!labels && max != 0) {\n        numticks = 10;\n      } else {\n        numticks = numlabels;\n      }\n    }\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noxaxis) {\n      pa2(co, ['b', 'm', x, ma.round(y), 'l', x + width, ma.round(y), 's', co.strokeStyle]);co.beginPath();for (var i = noleftendtick ? 1 : 0; i <= numticks - (norightendtick ? 1 : 0); ++i) {\n        co.moveTo(ma.round(x + width / numticks * i), xaxispos == 'center' ? align == 'bottom' ? y - 3 : y + 3 : y);co.lineTo(ma.round(x + width / numticks * i), y + (align == 'bottom' ? 3 : -3));\n      }\n      co.stroke();\n    }\n    co.fillStyle = label_color;if (labels) {\n      numlabels = labels.length;var h = 0;var l = 0;var single_line = RG.MeasureText('Mg', false, font, size);for (var i = 0, len = labels.length; i < len; ++i) {\n        var dimensions = RG.MeasureText(labels[i], false, font, size);var h = ma.max(h, dimensions[1]);var l = ma.max(l, labels[i].split('\\r\\n').length);\n      }\n      for (var i = 0, len = labels.length; i < len; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': labels_position == 'edge' ? (width - hmargin - hmargin) / (labels.length - 1) * i + gutterLeft + hmargin : (width - hmargin - hmargin) / labels.length * i + width / labels.length / 2 + gutterLeft + hmargin, 'y': align == 'bottom' ? y + 3 : y - 3 - h + single_line[1], 'text': String(labels[i]), 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else if (scale_visible) {\n      if (max === null) {\n        alert('[DRAWING.XAXIS] If not specifying axis.labels you must specify axis.max!');\n      }\n      if (yaxispos == 'center') {\n        width /= 2;var additionalX = width;\n      } else {\n        var additionalX = 0;\n      }\n      for (var i = 0; i <= numlabels; ++i) {\n        if (i == 0 && !prop['chart.scale.zerostart']) {\n          continue;\n        }\n        var original = (max - min) / numlabels * i + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post));if (invert) {\n          var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft + additionalX;\n        } else {\n          var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin + additionalX;\n        }\n        RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + 3 : y - 3, 'text': text, 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (yaxispos == 'center') {\n        for (var i = 0; i < numlabels; ++i) {\n          var original = (max - min) / numlabels * (numlabels - i) + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.number_format(this, original.toFixed(decimals), units_pre, units_post));if (invert) {\n            var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft;\n          } else {\n            var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + size + 2 : y - size - 2, 'text': '-' + text, 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n      }\n    }\n    if (title) {\n      var dimensions = RG.MeasureText(title, false, font, size + 2);co.fillStyle = title_color;\n      RG.Text2(this, { 'font': font, 'size': size + 2, 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': align == 'bottom' ? y + dimensions[1] + 10 : y - dimensions[1] - 10, 'text': title, 'valign': 'center', 'halign': 'center', 'tag': 'title' });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy54YXhpcy5qcz84ZDIyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguRHJhd2luZz1SR3JhcGguRHJhd2luZ3x8e307UkdyYXBoLkRyYXdpbmcuWEF4aXM9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi55PT09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkXG52YXIgeT1jb25mLnk7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZjt2YXIgeT1hcmd1bWVudHNbMV07fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy55PXk7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy50eXBlPSdkcmF3aW5nLnhheGlzJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0LmxhYmVscyc6bnVsbCwnY2hhcnQubGFiZWxzLnBvc2l0aW9uJzonc2VjdGlvbicsJ2NoYXJ0LmNvbG9ycyc6WydibGFjayddLCdjaGFydC50aXRsZS5jb2xvcic6bnVsbCwnY2hhcnQudGV4dC5jb2xvcic6bnVsbCwnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmFsaWduJzonYm90dG9tJywnY2hhcnQubnVtbGFiZWxzJzo1LCdjaGFydC5zY2FsZS52aXNpYmxlJzp0cnVlLCdjaGFydC5zY2FsZS5mb3JtYXR0ZXInOm51bGwsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC5zY2FsZS5pbnZlcnQnOmZhbHNlLCdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOnRydWUsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0Lm51bXRpY2tzJzpudWxsLCdjaGFydC5obWFyZ2luJzowLCdjaGFydC5saW5ld2lkdGgnOjEsJ2NoYXJ0Lm5vZW5kdGljay5sZWZ0JzpmYWxzZSwnY2hhcnQubm9lbmR0aWNrLnJpZ2h0JzpmYWxzZSwnY2hhcnQubm94YXhpcyc6ZmFsc2UsJ2NoYXJ0Lm1heCc6bnVsbCwnY2hhcnQubWluJzowLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC54YXhpc3Bvcyc6J2JvdHRvbScsJ2NoYXJ0LnlheGlzcG9zJzonbGVmdCcsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmlmKCF0aGlzLmNhbnZhcyl7YWxlcnQoJ1tEUkFXSU5HLlhBWElTXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC5sYWJlbHMnJiYhcHJvcFsnY2hhcnQubnVteHRpY2tzJ10pe3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPXZhbHVlLmxlbmd0aDt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTtpZighcHJvcFsnY2hhcnQudGV4dC5jb2xvciddKXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTtpZighcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSlwcm9wWydjaGFydC50aXRsZS5jb2xvciddPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5EcmF3WEF4aXMoKTtSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbntpZih0aGlzLmdldFNoYXBlKGUpKXtyZXR1cm4gdGhpczt9fTt0aGlzLmdldFNoYXBlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlWFlbMF07dmFyIG1vdXNlWT1tb3VzZVhZWzFdO2lmKG1vdXNlWD49dGhpcy5ndXR0ZXJMZWZ0JiZtb3VzZVg8PShjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSYmbW91c2VZPj10aGlzLnktKHByb3BbJ2NoYXJ0LmFsaWduJ109PSd0b3AnPyhwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpKzU6MCkmJm1vdXNlWTw9KHRoaXMueSsocHJvcFsnY2hhcnQuYWxpZ24nXT09J3RvcCc/MDoocHJvcFsnY2hhcnQudGV4dC5zaXplJ10qMS41KSs1KSkpe3ZhciB4PXRoaXMuZ3V0dGVyTGVmdDt2YXIgeT10aGlzLnk7dmFyIHc9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQ7dmFyIGg9MTU7cmV0dXJuezA6dGhpcywxOngsMjp5LDM6dyw0OmgsNTowLCdvYmplY3QnOnRoaXMsJ3gnOngsJ3knOnksJ3dpZHRoJzp3LCdoZWlnaHQnOmgsJ2luZGV4JzowLCd0b29sdGlwJzpwcm9wWydjaGFydC50b29sdGlwcyddP3Byb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF06bnVsbH07fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO31cbnByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yKXtyZXR1cm4gY29sb3I7fVxuaWYodHlwZW9mIGNvbG9yPT09J3N0cmluZycmJmNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10sMCxjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwwKTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTEsbGVuPXBhcnRzLmxlbmd0aDtqPGxlbjsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLmRyYXdYQXhpcz10aGlzLkRyYXdYQXhpcz1mdW5jdGlvbigpXG57dmFyIGd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSxndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSx4PXRoaXMuZ3V0dGVyTGVmdCx5PXRoaXMueSxtaW49K3Byb3BbJ2NoYXJ0Lm1pbiddLG1heD0rcHJvcFsnY2hhcnQubWF4J10sbGFiZWxzPXByb3BbJ2NoYXJ0LmxhYmVscyddLGxhYmVsc19wb3NpdGlvbj1wcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSxjb2xvcj1wcm9wWydjaGFydC5jb2xvcnMnXVswXSx0aXRsZV9jb2xvcj1wcm9wWydjaGFydC50aXRsZS5jb2xvciddLGxhYmVsX2NvbG9yPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSx3aWR0aD1jYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCxmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sYWxpZ249cHJvcFsnY2hhcnQuYWxpZ24nXSxudW1sYWJlbHM9cHJvcFsnY2hhcnQubnVtbGFiZWxzJ10sZm9ybWF0dGVyPXByb3BbJ2NoYXJ0LnNjYWxlLmZvcm1hdHRlciddLGRlY2ltYWxzPU51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSxpbnZlcnQ9cHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10sc2NhbGVfdmlzaWJsZT1wcm9wWydjaGFydC5zY2FsZS52aXNpYmxlJ10sdW5pdHNfcHJlPXByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddLHRpdGxlPXByb3BbJ2NoYXJ0LnRpdGxlJ11cbm51bXRpY2tzPXByb3BbJ2NoYXJ0Lm51bXRpY2tzJ10saG1hcmdpbj1wcm9wWydjaGFydC5obWFyZ2luJ10sbGluZXdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddLG5vbGVmdGVuZHRpY2s9cHJvcFsnY2hhcnQubm9lbmR0aWNrLmxlZnQnXSxub3JpZ2h0ZW5kdGljaz1wcm9wWydjaGFydC5ub2VuZHRpY2sucmlnaHQnXSxub3hheGlzPXByb3BbJ2NoYXJ0Lm5veGF4aXMnXSx4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddLHlheGlzcG9zPXByb3BbJ2NoYXJ0LnlheGlzcG9zJ11cbmlmKFJHLmlzX251bGwobnVtdGlja3MpKXtpZihsYWJlbHMmJmxhYmVscy5sZW5ndGgpe251bXRpY2tzPWxhYmVscy5sZW5ndGg7fWVsc2UgaWYoIWxhYmVscyYmbWF4IT0wKXtudW10aWNrcz0xMDt9ZWxzZXtudW10aWNrcz1udW1sYWJlbHM7fX1cbmNvLmxpbmVXaWR0aD1saW5ld2lkdGgrMC4wMDE7Y28uc3Ryb2tlU3R5bGU9Y29sb3I7aWYoIW5veGF4aXMpe3BhMihjbyxbJ2InLCdtJyx4LG1hLnJvdW5kKHkpLCdsJyx4K3dpZHRoLG1hLnJvdW5kKHkpLCdzJyxjby5zdHJva2VTdHlsZV0pO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0obm9sZWZ0ZW5kdGljaz8xOjApO2k8PShudW10aWNrcy0obm9yaWdodGVuZHRpY2s/MTowKSk7KytpKXtjby5tb3ZlVG8obWEucm91bmQoeCsoKHdpZHRoL251bXRpY2tzKSppKSkseGF4aXNwb3M9PSdjZW50ZXInPyhhbGlnbj09J2JvdHRvbSc/eS0zOnkrMyk6eSk7Y28ubGluZVRvKG1hLnJvdW5kKHgrKCh3aWR0aC9udW10aWNrcykqaSkpLHkrKGFsaWduPT0nYm90dG9tJz8zOi0zKSk7fVxuY28uc3Ryb2tlKCk7fVxuY28uZmlsbFN0eWxlPWxhYmVsX2NvbG9yO2lmKGxhYmVscyl7bnVtbGFiZWxzPWxhYmVscy5sZW5ndGg7dmFyIGg9MDt2YXIgbD0wO3ZhciBzaW5nbGVfbGluZT1SRy5NZWFzdXJlVGV4dCgnTWcnLGZhbHNlLGZvbnQsc2l6ZSk7Zm9yKHZhciBpPTAsbGVuPWxhYmVscy5sZW5ndGg7aTxsZW47KytpKXt2YXIgZGltZW5zaW9ucz1SRy5NZWFzdXJlVGV4dChsYWJlbHNbaV0sZmFsc2UsZm9udCxzaXplKTt2YXIgaD1tYS5tYXgoaCxkaW1lbnNpb25zWzFdKTt2YXIgbD1tYS5tYXgobCxsYWJlbHNbaV0uc3BsaXQoJ1xcclxcbicpLmxlbmd0aCk7fVxuZm9yKHZhciBpPTAsbGVuPWxhYmVscy5sZW5ndGg7aTxsZW47KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6bGFiZWxzX3Bvc2l0aW9uPT0nZWRnZSc/KCgoKHdpZHRoLWhtYXJnaW4taG1hcmdpbikvKGxhYmVscy5sZW5ndGgtMSkpKmkpK2d1dHRlckxlZnQraG1hcmdpbik6KCgoKHdpZHRoLWhtYXJnaW4taG1hcmdpbikvbGFiZWxzLmxlbmd0aCkqaSkrKCh3aWR0aC9sYWJlbHMubGVuZ3RoKS8yKStndXR0ZXJMZWZ0K2htYXJnaW4pLCd5JzphbGlnbj09J2JvdHRvbSc/eSszOnktMy1oK3NpbmdsZV9saW5lWzFdLCd0ZXh0JzpTdHJpbmcobGFiZWxzW2ldKSwndmFsaWduJzphbGlnbj09J2JvdHRvbSc/J3RvcCc6J2JvdHRvbScsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J2xhYmVscyd9KTt9fWVsc2UgaWYoc2NhbGVfdmlzaWJsZSl7aWYobWF4PT09bnVsbCl7YWxlcnQoJ1tEUkFXSU5HLlhBWElTXSBJZiBub3Qgc3BlY2lmeWluZyBheGlzLmxhYmVscyB5b3UgbXVzdCBzcGVjaWZ5IGF4aXMubWF4IScpO31cbmlmKHlheGlzcG9zPT0nY2VudGVyJyl7d2lkdGgvPTI7dmFyIGFkZGl0aW9uYWxYPXdpZHRoO31lbHNle3ZhciBhZGRpdGlvbmFsWD0wO31cbmZvcih2YXIgaT0wO2k8PW51bWxhYmVsczsrK2kpe2lmKGk9PTAmJiFwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSl7Y29udGludWU7fVxudmFyIG9yaWdpbmFsPSgoKG1heC1taW4pL251bWxhYmVscykqaSkrbWluO3ZhciBobWFyZ2luPXByb3BbJ2NoYXJ0LmhtYXJnaW4nXTt2YXIgdGV4dD1TdHJpbmcodHlwZW9mKGZvcm1hdHRlcik9PSdmdW5jdGlvbic/Zm9ybWF0dGVyKHRoaXMsb3JpZ2luYWwpOlJHLm51bWJlckZvcm1hdCh0aGlzLG9yaWdpbmFsLnRvRml4ZWQob3JpZ2luYWw9PT0wPzA6ZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSk7aWYoaW52ZXJ0KXt2YXIgeD0oKHdpZHRoLWhtYXJnaW4tKCh3aWR0aC1obWFyZ2luLWhtYXJnaW4pL251bWxhYmVscykqaSkpK2d1dHRlckxlZnQrYWRkaXRpb25hbFg7fWVsc2V7dmFyIHg9KCgod2lkdGgtaG1hcmdpbi1obWFyZ2luKS9udW1sYWJlbHMpKmkpK2d1dHRlckxlZnQraG1hcmdpbithZGRpdGlvbmFsWDt9XG5SRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eCwneSc6YWxpZ249PSdib3R0b20nP3krMzp5LTMsJ3RleHQnOnRleHQsJ3ZhbGlnbic6YWxpZ249PSdib3R0b20nPyd0b3AnOidib3R0b20nLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9XG5pZih5YXhpc3Bvcz09J2NlbnRlcicpe2Zvcih2YXIgaT0wO2k8bnVtbGFiZWxzOysraSl7dmFyIG9yaWdpbmFsPSgoKG1heC1taW4pL251bWxhYmVscykqKG51bWxhYmVscy1pKSkrbWluO3ZhciBobWFyZ2luPXByb3BbJ2NoYXJ0LmhtYXJnaW4nXTt2YXIgdGV4dD1TdHJpbmcodHlwZW9mKGZvcm1hdHRlcik9PSdmdW5jdGlvbic/Zm9ybWF0dGVyKHRoaXMsb3JpZ2luYWwpOlJHLm51bWJlcl9mb3JtYXQodGhpcyxvcmlnaW5hbC50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCkpO2lmKGludmVydCl7dmFyIHg9KCh3aWR0aC1obWFyZ2luLSgod2lkdGgtaG1hcmdpbi1obWFyZ2luKS9udW1sYWJlbHMpKmkpKStndXR0ZXJMZWZ0O31lbHNle3ZhciB4PSgoKHdpZHRoLWhtYXJnaW4taG1hcmdpbikvbnVtbGFiZWxzKSppKStndXR0ZXJMZWZ0K2htYXJnaW47fVxuUkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOngsJ3knOmFsaWduPT0nYm90dG9tJz95K3NpemUrMjp5LXNpemUtMiwndGV4dCc6Jy0nK3RleHQsJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO319fVxuaWYodGl0bGUpe3ZhciBkaW1lbnNpb25zPVJHLk1lYXN1cmVUZXh0KHRpdGxlLGZhbHNlLGZvbnQsc2l6ZSsyKTtjby5maWxsU3R5bGU9dGl0bGVfY29sb3JcblJHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplKzIsJ3gnOihjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvMit0aGlzLmd1dHRlckxlZnQsJ3knOmFsaWduPT0nYm90dG9tJz95K2RpbWVuc2lvbnNbMV0rMTA6eS1kaW1lbnNpb25zWzFdLTEwLCd0ZXh0Jzp0aXRsZSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywndGFnJzondGl0bGUnfSk7fX07dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy54YXhpcy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///216\n");

/***/ }),
/* 217 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.YAxis = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext(\"2d\");this.canvas.__object__ = this;this.x = x;this.coords = [];this.coordsText = [];this.original_colors = [];this.maxLabelLength = 0;this.firstDraw = true;this.type = 'drawing.yaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = (_properties = { 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.min': 0, 'chart.max': null, 'chart.colors': ['black'], 'chart.title': '', 'chart.title.color': null, 'chart.numticks': 5, 'chart.numlabels': 5, 'chart.labels.specific': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': null, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'left', 'hart.scale.formatter': null, 'chart.scale.point': '.', 'chart.scale.decimals': 0 }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.invert', false), _defineProperty(_properties, 'chart.scale.zerostart', true), _defineProperty(_properties, 'chart.scale.visible', true), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.noendtick.top', false), _defineProperty(_properties, 'chart.noendtick.bottom', false), _defineProperty(_properties, 'chart.noyaxis', false), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.xaxispos', 'bottom'), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[DRAWING.YAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawYAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.x - (prop['chart.align'] == 'right' ? 0 : this.getWidth()) && mouseX <= this.x + (prop['chart.align'] == 'right' ? this.getWidth() : 0) && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var x = this.x;var y = this.gutterTop;var w = 15;;var h = ca.height - this.gutterTop - this.gutterBottom;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - this.gutterBottom);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawYAxis = this.DrawYAxis = function () {\n    for (i in prop) {\n      if (typeof i == 'string') {\n        var key = i.replace(/^chart\\./, 'axis.');prop[key] = prop[i];\n      }\n    }\n    var x = this.x,\n        y = this.gutterTop,\n        height = ca.height - this.gutterBottom - this.gutterTop,\n        min = +prop['chart.min'] ? +prop['chart.min'] : 0,\n        max = +prop['chart.max'],\n        title = prop['chart.title'] ? prop['chart.title'] : '',\n        color = prop['chart.colors'] ? prop['chart.colors'][0] : 'black',\n        title_color = prop['chart.title.color'] ? prop['chart.title.color'] : color,\n        label_color = prop['chart.text.color'] ? prop['chart.text.color'] : color,\n        numticks = typeof prop['chart.numticks'] == 'number' ? prop['chart.numticks'] : 10,\n        labels_specific = prop['chart.labels.specific'],\n        numlabels = prop['chart.numlabels'] ? prop['chart.numlabels'] : 5,\n        font = prop['chart.text.font'] ? prop['chart.text.font'] : 'Arial',\n        size = prop['chart.text.size'] ? prop['chart.text.size'] : 10;\n    align = typeof prop['chart.align'] == 'string' ? prop['chart.align'] : 'left', formatter = prop['chart.scale.formatter'], decimals = prop['chart.scale.decimals'], invert = prop['chart.scale.invert'], scale_visible = prop['chart.scale.visible'], units_pre = prop['chart.units.pre'], units_post = prop['chart.units.post'], linewidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 1, notopendtick = prop['chart.noendtick.top'], nobottomendtick = prop['chart.noendtick.bottom'], noyaxis = prop['chart.noyaxis'], xaxispos = prop['chart.xaxispos'];\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noyaxis) {\n      pa2(co, ['b', 'm', Math.round(x), y, 'l', Math.round(x), y + height, 's', color]);if (numticks) {\n        var gap = (xaxispos == 'center' ? height / 2 : height) / numticks;var halfheight = height / 2;co.beginPath();for (var i = notopendtick ? 1 : 0; i <= numticks - (nobottomendtick || xaxispos == 'center' ? 1 : 0); ++i) {\n          pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + gap * i), 'l', x, Math.round(y + gap * i)]);\n        }\n        if (xaxispos == 'center') {\n          for (var i = 1; i <= numticks; ++i) {\n            pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + halfheight + gap * i), 'l', x, Math.round(y + halfheight + gap * i)]);\n          }\n        }\n        co.stroke();\n      }\n    }\n    co.fillStyle = label_color;var text_len = 0;if (scale_visible) {\n      if (labels_specific && labels_specific.length) {\n        var text_len = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          text_len = ma.max(text_len, co.measureText(labels_specific[i]).width);\n        }\n        for (var i = 0, len = labels_specific.length; i < len; ++i) {\n          var gap = len - 1 > 0 ? height / (len - 1) : 0;if (xaxispos == 'center') {\n            gap /= 2;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': i * gap + this.gutterTop, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });this.maxLabelLength = ma.max(this.maxLabelLength, co.measureText(labels_specific[i]).width);\n        }\n        if (xaxispos == 'center') {\n          for (var i = labels_specific.length - 2; i >= 0; --i) {\n            RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - i * gap, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      } else {\n        for (var i = 0; i <= numlabels; ++i) {\n          var original = (max - min) * ((numlabels - i) / numlabels) + min;if (original == 0 && prop['chart.scale.zerostart'] == false) {\n            continue;\n          }\n          var text = RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post);var text = String(typeof formatter == 'function' ? formatter(this, original) : text);var text_len = ma.max(text_len, co.measureText(text).width);this.maxLabelLength = text_len;if (invert) {\n            var y = height - height / numlabels * i;\n          } else {\n            var y = height / numlabels * i;\n          }\n          if (prop['chart.xaxispos'] == 'center') {\n            y = y / 2;\n          }\n          text = text.replace(/^-,([0-9])/, '-$1');RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': y + this.gutterTop, 'text': text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });if (prop['chart.xaxispos'] == 'center' && i < numlabels) {\n            RG.Text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - y, 'text': '-' + text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (title) {\n      co.beginPath();co.fillStyle = title_color;if (labels_specific) {\n        var width = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          width = Math.max(width, co.measureText(labels_specific[i]).width);\n        }\n      } else {\n        var width = co.measureText(prop['chart.units.pre'] + prop['chart.max'].toFixed(prop['chart.scale.decimals']) + prop['chart.units.post']).width;\n      }\n      RG.text2(this, { font: font, size: size + 2, x: align == 'right' ? x + width + 8 : x - width - 8, y: height / 2 + this.gutterTop, text: title, valign: 'bottom', halign: 'center', angle: align == 'right' ? 90 : -90, accessible: false });co.stroke();\n    }\n  };this.getWidth = function () {\n    var width = this.maxLabelLength;if (prop['chart.title'] && prop['chart.title'].length) {\n      width += prop['chart.text.size'] * 1.5;\n    }\n    this.width = width;return width;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy55YXhpcy5qcz8zNzI0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguRHJhd2luZz1SR3JhcGguRHJhd2luZ3x8e307UkdyYXBoLkRyYXdpbmcuWUF4aXM9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi54PT09J251bWJlcicmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkXG52YXIgeD1jb25mLng7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZjt2YXIgeD1hcmd1bWVudHNbMV07fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLng9eDt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5tYXhMYWJlbExlbmd0aD0wO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy50eXBlPSdkcmF3aW5nLnlheGlzJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MzAsJ2NoYXJ0Lm1pbic6MCwnY2hhcnQubWF4JzpudWxsLCdjaGFydC5jb2xvcnMnOlsnYmxhY2snXSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5jb2xvcic6bnVsbCwnY2hhcnQubnVtdGlja3MnOjUsJ2NoYXJ0Lm51bWxhYmVscyc6NSwnY2hhcnQubGFiZWxzLnNwZWNpZmljJzpudWxsLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmNvbG9yJzpudWxsLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuYWxpZ24nOidsZWZ0JywnaGFydC5zY2FsZS5mb3JtYXR0ZXInOm51bGwsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5kZWNpbWFscyc6MCwnY2hhcnQuc2NhbGUucG9pbnQnOicuJywnY2hhcnQuc2NhbGUuaW52ZXJ0JzpmYWxzZSwnY2hhcnQuc2NhbGUuemVyb3N0YXJ0Jzp0cnVlLCdjaGFydC5zY2FsZS52aXNpYmxlJzp0cnVlLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQubGluZXdpZHRoJzoxLCdjaGFydC5ub2VuZHRpY2sudG9wJzpmYWxzZSwnY2hhcnQubm9lbmR0aWNrLmJvdHRvbSc6ZmFsc2UsJ2NoYXJ0Lm5veWF4aXMnOmZhbHNlLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQueGF4aXNwb3MnOidib3R0b20nLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmlmKCF0aGlzLmNhbnZhcyl7YWxlcnQoJ1tEUkFXSU5HLllBWElTXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jb29yZHNUZXh0PVtdO2lmKCFwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pcHJvcFsnY2hhcnQudGV4dC5jb2xvciddPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmKCFwcm9wWydjaGFydC50aXRsZS5jb2xvciddKXByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ109cHJvcFsnY2hhcnQuY29sb3JzJ11bMF07aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmRyYXdZQXhpcygpO1JHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue2lmKHRoaXMuZ2V0U2hhcGUoZSkpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVg9bW91c2VYWVswXTt2YXIgbW91c2VZPW1vdXNlWFlbMV07aWYobW91c2VYPj10aGlzLngtKHByb3BbJ2NoYXJ0LmFsaWduJ109PSdyaWdodCc/MDp0aGlzLmdldFdpZHRoKCkpJiZtb3VzZVg8PXRoaXMueCsocHJvcFsnY2hhcnQuYWxpZ24nXT09J3JpZ2h0Jz90aGlzLmdldFdpZHRoKCk6MCkmJm1vdXNlWT49dGhpcy5ndXR0ZXJUb3AmJm1vdXNlWTw9KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpe3ZhciB4PXRoaXMueDt2YXIgeT10aGlzLmd1dHRlclRvcDt2YXIgdz0xNTs7dmFyIGg9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tO3JldHVybnswOnRoaXMsMTp4LDI6eSwzOncsNDpoLDU6MCwnb2JqZWN0Jzp0aGlzLCd4Jzp4LCd5Jzp5LCd3aWR0aCc6dywnaGVpZ2h0JzpoLCdpbmRleCc6MCwndG9vbHRpcCc6cHJvcFsnY2hhcnQudG9vbHRpcHMnXT9wcm9wWydjaGFydC50b29sdGlwcyddWzBdOm51bGx9O31cbnJldHVybiBudWxsO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fX07dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt9XG5wcm9wWydjaGFydC5jb2xvcnMnXVswXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVswXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcil7cmV0dXJuIGNvbG9yO31cbmlmKHR5cGVvZiBjb2xvcj09PSdzdHJpbmcnJiZjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSwwLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMuZHJhd1lBeGlzPXRoaXMuRHJhd1lBeGlzPWZ1bmN0aW9uKClcbntmb3IoaSBpbiBwcm9wKXtpZih0eXBlb2YgaT09J3N0cmluZycpe3ZhciBrZXk9aS5yZXBsYWNlKC9eY2hhcnRcXC4vLCdheGlzLicpO3Byb3Bba2V5XT1wcm9wW2ldO319XG52YXIgeD10aGlzLngseT10aGlzLmd1dHRlclRvcCxoZWlnaHQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLXRoaXMuZ3V0dGVyVG9wLG1pbj0rcHJvcFsnY2hhcnQubWluJ10/K3Byb3BbJ2NoYXJ0Lm1pbiddOjAsbWF4PStwcm9wWydjaGFydC5tYXgnXSx0aXRsZT1wcm9wWydjaGFydC50aXRsZSddP3Byb3BbJ2NoYXJ0LnRpdGxlJ106JycsY29sb3I9cHJvcFsnY2hhcnQuY29sb3JzJ10/cHJvcFsnY2hhcnQuY29sb3JzJ11bMF06J2JsYWNrJyx0aXRsZV9jb2xvcj1wcm9wWydjaGFydC50aXRsZS5jb2xvciddP3Byb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ106Y29sb3IsbGFiZWxfY29sb3I9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddP3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXTpjb2xvcixudW10aWNrcz10eXBlb2YocHJvcFsnY2hhcnQubnVtdGlja3MnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0Lm51bXRpY2tzJ106MTAsbGFiZWxzX3NwZWNpZmljPXByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddLG51bWxhYmVscz1wcm9wWydjaGFydC5udW1sYWJlbHMnXT9wcm9wWydjaGFydC5udW1sYWJlbHMnXTo1LGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10/cHJvcFsnY2hhcnQudGV4dC5mb250J106J0FyaWFsJyxzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddP3Byb3BbJ2NoYXJ0LnRleHQuc2l6ZSddOjEwXG5hbGlnbj10eXBlb2YocHJvcFsnY2hhcnQuYWxpZ24nXSk9PSdzdHJpbmcnP3Byb3BbJ2NoYXJ0LmFsaWduJ106J2xlZnQnLGZvcm1hdHRlcj1wcm9wWydjaGFydC5zY2FsZS5mb3JtYXR0ZXInXSxkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLGludmVydD1wcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSxzY2FsZV92aXNpYmxlPXByb3BbJ2NoYXJ0LnNjYWxlLnZpc2libGUnXSx1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J10sbGluZXdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddP3Byb3BbJ2NoYXJ0LmxpbmV3aWR0aCddOjEsbm90b3BlbmR0aWNrPXByb3BbJ2NoYXJ0Lm5vZW5kdGljay50b3AnXSxub2JvdHRvbWVuZHRpY2s9cHJvcFsnY2hhcnQubm9lbmR0aWNrLmJvdHRvbSddLG5veWF4aXM9cHJvcFsnY2hhcnQubm95YXhpcyddLHhheGlzcG9zPXByb3BbJ2NoYXJ0LnhheGlzcG9zJ11cbmNvLmxpbmVXaWR0aD1saW5ld2lkdGgrMC4wMDE7Y28uc3Ryb2tlU3R5bGU9Y29sb3I7aWYoIW5veWF4aXMpe3BhMihjbyxbJ2InLCdtJyxNYXRoLnJvdW5kKHgpLHksJ2wnLE1hdGgucm91bmQoeCkseStoZWlnaHQsJ3MnLGNvbG9yXSk7aWYobnVtdGlja3Mpe3ZhciBnYXA9KHhheGlzcG9zPT0nY2VudGVyJz9oZWlnaHQvMjpoZWlnaHQpL251bXRpY2tzO3ZhciBoYWxmaGVpZ2h0PWhlaWdodC8yO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0obm90b3BlbmR0aWNrPzE6MCk7aTw9KG51bXRpY2tzLShub2JvdHRvbWVuZHRpY2t8fHhheGlzcG9zPT0nY2VudGVyJz8xOjApKTsrK2kpe3BhMihjbyxbJ20nLGFsaWduPT0ncmlnaHQnP3grMzp4LTMsTWF0aC5yb3VuZCh5KyhnYXAqaSkpLCdsJyx4LE1hdGgucm91bmQoeSsoZ2FwKmkpKV0pO31cbmlmKHhheGlzcG9zPT0nY2VudGVyJyl7Zm9yKHZhciBpPTE7aTw9bnVtdGlja3M7KytpKXtwYTIoY28sWydtJyxhbGlnbj09J3JpZ2h0Jz94KzM6eC0zLE1hdGgucm91bmQoeStoYWxmaGVpZ2h0KyhnYXAqaSkpLCdsJyx4LE1hdGgucm91bmQoeStoYWxmaGVpZ2h0KyhnYXAqaSkpXSk7fX1cbmNvLnN0cm9rZSgpO319XG5jby5maWxsU3R5bGU9bGFiZWxfY29sb3I7dmFyIHRleHRfbGVuPTA7aWYoc2NhbGVfdmlzaWJsZSl7aWYobGFiZWxzX3NwZWNpZmljJiZsYWJlbHNfc3BlY2lmaWMubGVuZ3RoKXt2YXIgdGV4dF9sZW49MDtmb3IodmFyIGk9MCxsZW49bGFiZWxzX3NwZWNpZmljLmxlbmd0aDtpPGxlbjtpKz0xKXt0ZXh0X2xlbj1tYS5tYXgodGV4dF9sZW4sY28ubWVhc3VyZVRleHQobGFiZWxzX3NwZWNpZmljW2ldKS53aWR0aCk7fVxuZm9yKHZhciBpPTAsbGVuPWxhYmVsc19zcGVjaWZpYy5sZW5ndGg7aTxsZW47KytpKXt2YXIgZ2FwPShsZW4tMSk+MD8oaGVpZ2h0LyhsZW4tMSkpOjA7aWYoeGF4aXNwb3M9PSdjZW50ZXInKXtnYXAvPTI7fVxuUkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOngtKGFsaWduPT0ncmlnaHQnPy01OjUpLCd5JzooaSpnYXApK3RoaXMuZ3V0dGVyVG9wLCd0ZXh0JzpsYWJlbHNfc3BlY2lmaWNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ249PSdyaWdodCc/J2xlZnQnOidyaWdodCcsJ3RhZyc6J3NjYWxlJ30pO3RoaXMubWF4TGFiZWxMZW5ndGg9bWEubWF4KHRoaXMubWF4TGFiZWxMZW5ndGgsY28ubWVhc3VyZVRleHQobGFiZWxzX3NwZWNpZmljW2ldKS53aWR0aCk7fVxuaWYoeGF4aXNwb3M9PSdjZW50ZXInKXtmb3IodmFyIGk9KGxhYmVsc19zcGVjaWZpYy5sZW5ndGgtMik7aT49MDstLWkpe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp4LShhbGlnbj09J3JpZ2h0Jz8tNTo1KSwneSc6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLShpKmdhcCksJ3RleHQnOmxhYmVsc19zcGVjaWZpY1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbj09J3JpZ2h0Jz8nbGVmdCc6J3JpZ2h0JywndGFnJzonc2NhbGUnfSk7fX19ZWxzZXtmb3IodmFyIGk9MDtpPD1udW1sYWJlbHM7KytpKXt2YXIgb3JpZ2luYWw9KChtYXgtbWluKSooKG51bWxhYmVscy1pKS9udW1sYWJlbHMpKSttaW47aWYob3JpZ2luYWw9PTAmJnByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddPT1mYWxzZSl7Y29udGludWU7fVxudmFyIHRleHQ9UkcubnVtYmVyRm9ybWF0KHRoaXMsb3JpZ2luYWwudG9GaXhlZChvcmlnaW5hbD09PTA/MDpkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpO3ZhciB0ZXh0PVN0cmluZyh0eXBlb2YoZm9ybWF0dGVyKT09J2Z1bmN0aW9uJz9mb3JtYXR0ZXIodGhpcyxvcmlnaW5hbCk6dGV4dCk7dmFyIHRleHRfbGVuPW1hLm1heCh0ZXh0X2xlbixjby5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCk7dGhpcy5tYXhMYWJlbExlbmd0aD10ZXh0X2xlbjtpZihpbnZlcnQpe3ZhciB5PWhlaWdodC0oKGhlaWdodC9udW1sYWJlbHMpKmkpO31lbHNle3ZhciB5PShoZWlnaHQvbnVtbGFiZWxzKSppO31cbmlmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXt5PXkvMjt9XG50ZXh0PXRleHQucmVwbGFjZSgvXi0sKFswLTldKS8sJy0kMScpO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp4LShhbGlnbj09J3JpZ2h0Jz8tNTo1KSwneSc6eSt0aGlzLmd1dHRlclRvcCwndGV4dCc6dGV4dCwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbj09J3JpZ2h0Jz8nbGVmdCc6J3JpZ2h0JywndGFnJzonc2NhbGUnfSk7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicmJmk8bnVtbGFiZWxzKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eC0oYWxpZ249PSdyaWdodCc/LTU6NSksJ3knOmNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS15LCd0ZXh0JzonLScrdGV4dCwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbj09J3JpZ2h0Jz8nbGVmdCc6J3JpZ2h0JywndGFnJzonc2NhbGUnfSk7fX19fVxuaWYodGl0bGUpe2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT10aXRsZV9jb2xvcjtpZihsYWJlbHNfc3BlY2lmaWMpe3ZhciB3aWR0aD0wO2Zvcih2YXIgaT0wLGxlbj1sYWJlbHNfc3BlY2lmaWMubGVuZ3RoO2k8bGVuO2krPTEpe3dpZHRoPU1hdGgubWF4KHdpZHRoLGNvLm1lYXN1cmVUZXh0KGxhYmVsc19zcGVjaWZpY1tpXSkud2lkdGgpO319ZWxzZXt2YXIgd2lkdGg9Y28ubWVhc3VyZVRleHQocHJvcFsnY2hhcnQudW5pdHMucHJlJ10rcHJvcFsnY2hhcnQubWF4J10udG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKStwcm9wWydjaGFydC51bml0cy5wb3N0J10pLndpZHRoO31cblJHLnRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUrMix4OmFsaWduPT0ncmlnaHQnP3grd2lkdGgrODp4LXdpZHRoLTgseTpoZWlnaHQvMit0aGlzLmd1dHRlclRvcCx0ZXh0OnRpdGxlLHZhbGlnbjonYm90dG9tJyxoYWxpZ246J2NlbnRlcicsYW5nbGU6YWxpZ249PSdyaWdodCc/OTA6LTkwLGFjY2Vzc2libGU6ZmFsc2V9KTtjby5zdHJva2UoKTt9fTt0aGlzLmdldFdpZHRoPWZ1bmN0aW9uKClcbnt2YXIgd2lkdGg9dGhpcy5tYXhMYWJlbExlbmd0aDtpZihwcm9wWydjaGFydC50aXRsZSddJiZwcm9wWydjaGFydC50aXRsZSddLmxlbmd0aCl7d2lkdGgrPShwcm9wWydjaGFydC50ZXh0LnNpemUnXSoxLjUpO31cbnRoaXMud2lkdGg9d2lkdGg7cmV0dXJuIHdpZHRoO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy55YXhpcy5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///217\n");

/***/ }),
/* 218 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Fuel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'fuel';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.angles = {};this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.colors': ['Gradient(white:red)'], 'chart.needle.color': 'red', 'chart.gutter.left': 5, 'chart.gutter.right': 5, 'chart.gutter.top': 5, 'chart.gutter.bottom': 5, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.icon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAfCAYAAAD0ma06AAAEGElEQVRIS7VXSyhtYRT+jnfe5FEMjAwUBiQGHikzRWIkkgy8YyDK+xnJK5JCeZSUGKBMiAyYkMxMJAMpSfJ+2/d8695/33NunSPnHqt2Z5+91/9/' + '/' + '/et9a/1b8Pn56dmMBhg/IWDgwNoNzc38PHxkXtN0+Tiexp9eH18fIDj1Bj63N/fw8vLS/wsmcHoqKmXT09PuL29RVFREU5OTvTJ6UIAgioQ+vLe09MTb29v8PX1RWBgICYnJ+XXIqDRWXN0dJT3nIDsWlpadP+lpSWZlD4KmL/8/' + '/7+Ls/S09N1/7y8PISHh+sK/QssDJWcHEyGCnB1dRUDAwPIzMzUx5GpAnZ1dcXy8jK2trbM5j06OsLc3JzISx8q4OzsLOOsAq6treHg4AAeHh4WJbq7u0Nzc7P+PiYmBnt7ezg9PcXExAQCAgLg5OSEx8dHuLu7Wwfc3t7G/v6+yEcjO8rIROGKaWdnZ+jr6zMDjI6OxvT0tDzr6uqS2KtksspwZ2cHjY2NuqSUhnHmilUCraysmElaWloKJpQCjI2NRX5+Pl5eXr6WlCv08/MTEMVOZDH+Zzw4CdlfX1/rDHt7ezE1NQXGkcYEKi4ulkVKYlpLGouBs/JiaGgIZL25uSlecXFxohAz/ccAz8/P4e/vj7q6Ojw8PMje5DNRy94MQ0JCUFtbK2wqKipE+sHBQbi4uPwMQ86ak5ODxMREVFdXIywsDCUlJRJDXnZlmJqaip6eHuTm5kqikGlycjIyMjL+ZrY9JSUgMzQiIgINDQ2ypaqqqkCZWXHsnjQEHB8fR0pKigAxabq7uyWOlJNxtLukTJDs7GxUVlZKDNl5oqKi8Pr6+jOAIyMjiI+Pl5JGQG4F1Qy+LN7f3fiUdGZmBsHBwRgbG8Pw8LD01ba2NmlX0rTtnTQLCwvSjEdHR3FxcSExLCwsRGRkpBR9vePzeMDyw3bT1NT0XXLiT4a7u7s4Pj4GGzd7K8GCgoKEsRR8I4Cm6hwHXV5eiv62GAE5npMTmFuBTCkzmzT7qs5Q9TlW/o6ODlvwhCHPM5SVPZIxYzNeXFxEa2srvL29YTC2GI3aMm3Zeq6urv4LMC0tDRsbG1K8k5KS9DgS0IwhKVFjSsJA22r9/f0oKCgQdvPz83JEmZ2dlcpD9maSshow0KZnlO8Csx9yK3BLKCMJPpf2xGMigdi9WXooaWdn53dxdP+amhrZh4eHh1hfX5cTW319vZyBnp+ffzNkBWBmhYaGysB/j322oCckJCArK0uGMlsJ5ubmBoPxRiMzFlomjr2MGdne3i5ANILRJEtJt6ysTG8h9gDl4am8vFwSUWron1O9LulXIOqk9pWftfdSS40yyj5Uh101wPRryuR7R1ZMX/U1pfy5IF40xcgUnGAc9wsGYxsFhy87kwAAAABJRU5ErkJggg=='), _defineProperty(_properties, 'chart.icon.redraw', true), _defineProperty(_properties, 'chart.background.image.stretch', false), _defineProperty(_properties, 'chart.background.image.x', null), _defineProperty(_properties, 'chart.background.image.y', null), _defineProperty(_properties, 'chart.labels.full', 'F'), _defineProperty(_properties, 'chart.labels.empty', 'E'), _defineProperty(_properties, 'chart.labels.count', 5), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.scale.visible', false), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - 20 - this.gutterBottom;\n    this.radius = ca.height - this.gutterTop - this.gutterBottom - 20;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.angles.start = RG.PI + RG.HALFPI - 0.5;this.angles.end = RG.PI + RG.HALFPI + 0.5;this.angles.needle = this.getAngle(this.value);this.DrawLabels();this.DrawChart();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawChart = this.DrawChart = function () {\n    this.DrawScale();if (!RG.ISOLD) {\n      this.DrawIcon();\n    }\n    this.DrawNeedle();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.scale.visible']) {\n      var radius = this.radius - 20;co.fillStyle = prop['chart.text.color'];var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx - Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.empty'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx + Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.full'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function () {\n    co.beginPath();co.lineWidth = 5;co.lineCap = 'round';co.strokeStyle = prop['chart.needle.color'];var angle = this.angles.needle;co.arc(this.centerx, this.centery, this.radius - 30, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);co.stroke();co.lineWidth = 1;var cx = this.centerx + 10;var cy = this.centery - 10;\n    var grad = co.createRadialGradient(cx, cy, 35, cx, cy, 0);grad.addColorStop(0, 'black');grad.addColorStop(1, '#eee');if (navigator.userAgent.indexOf('Firefox/6.0') > 0) {\n      grad = co.createLinearGradient(cx + 10, cy - 10, cx - 10, cy + 10);grad.addColorStop(1, '#666');grad.addColorStop(0.5, '#ccc');\n    }\n    co.beginPath();co.fillStyle = grad;co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 20, 0, RG.TWOPI, 0);co.fill();\n  };this.drawScale = this.DrawScale = function () {\n    var a, x, y;co.beginPath();co.strokeStyle = 'black';co.fillStyle = 'white';co.arc(this.centerx, this.centery, this.radius, this.angles.start, this.angles.end, false);co.arc(this.centerx, this.centery, this.radius - 10, this.angles.end, this.angles.start, true);co.closePath();co.stroke();co.fill();var start = this.angles.start;var end = this.angles.needle;co.beginPath();co.fillStyle = prop['chart.colors'][0];co.arc(this.centerx, this.centery, this.radius, start, end, false);co.arc(this.centerx, this.centery, this.radius - 10, end, start, true);co.closePath();co.fill();for (a = this.angles.start; a <= this.angles.end + 0.01; a += (this.angles.end - this.angles.start) / 5) {\n      co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10, a, a + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 15, a + 0.0001, a, true);co.stroke();\n    }\n    if (prop['chart.scale.visible']) {\n      co.fillStyle = prop['chart.text.color'];var numLabels = prop['chart.labels.count'];var decimals = prop['chart.scale.decimals'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var units_post = prop['chart.units.post'];var units_pre = prop['chart.units.pre'];for (var i = 0; i <= numLabels; ++i) {\n        a = (this.angles.end - this.angles.start) * (i / numLabels) + this.angles.start;y = this.centery - Math.sin(a - RG.PI) * (this.radius - 25);x = this.centerx - Math.cos(a - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': RG.number_format(this, (this.min + (this.max - this.min) * (i / numLabels)).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (angle >= this.angles.end) {\n      return this.max;\n    } else if (angle <= this.angles.start) {\n      return this.min;\n    }\n    var value = (angle - this.angles.start) / (this.angles.end - this.angles.start);value = value * (this.max - this.min);value = value + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var accuracy = 15;var leftMin = this.centerx - this.radius;var rightMax = this.centerx + this.radius;var topMin = this.centery - this.radius;var bottomMax = this.centery + this.radius;if (mouseXY[0] > leftMin && mouseXY[0] < rightMax && mouseXY[1] > topMin && mouseXY[1] < bottomMax) {\n      return this;\n    }\n  };this.drawIcon = this.DrawIcon = function () {\n    if (!RG.ISOLD) {\n      if (!this.__icon__ || !this.__icon__.__loaded__) {\n        var img = new Image();img.src = prop['chart.icon'];img.__object__ = this;this.__icon__ = img;img.onload = function (e) {\n          img.__loaded__ = true;var obj = img.__object__;co.drawImage(img, obj.centerx - img.width / 2, obj.centery - obj.radius + 35);obj.DrawNeedle();if (prop['chart.icon.redraw']) {\n            obj.Set('chart.icon.redraw', false);RG.Clear(obj.canvas);RG.RedrawCanvas(ca);\n          }\n        };\n      } else {\n        var img = this.__icon__;co.drawImage(img, this.centerx - img.width / 2, this.centery - this.radius + 35);\n      }\n    }\n    this.DrawNeedle();\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.angles.end - this.angles.start) + this.angles.start;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.needle.color'] = RG.array_clone(prop['chart.needle.color']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForLinearGradient(colors[i]);\n    }\n    props['chart.needle.color'] = this.parseSingleColorForRadialGradient(props['chart.needle.color']);\n  };this.reset = function () {};this.parseSingleColorForLinearGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForRadialGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var callback = arguments[1] || function () {};var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;var obj = this;var origValue = Number(this.currentValue);if (this.currentValue == null) {\n      this.currentValue = this.min;origValue = this.min;\n    }\n    var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;function iterator() {\n      frame++;obj.value = frame / numFrames * diff + origValue;\n      if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < numFrames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZnVlbC5qcz82ZDhkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguRnVlbD1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksbWluPWNvbmYubWluLG1heD1jb25mLm1heCx2YWx1ZT1jb25mLnZhbHVlLHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZixjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLG1pbj1hcmd1bWVudHNbMV0sbWF4PWFyZ3VtZW50c1syXSx2YWx1ZT1hcmd1bWVudHNbM107fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOih0eXBlb2YgaWQ9PT0nb2JqZWN0JyYmaWQuYWxwaGE9PT1mYWxzZSk/ZmFsc2U6dHJ1ZX0pOm51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudHlwZT0nZnVlbCc7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMubWluPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1pbik7dGhpcy5tYXg9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmFuZ2xlcz17fTt0aGlzLmN1cnJlbnRWYWx1ZT1udWxsO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7aWYoIXRoaXMuY2FudmFzKXthbGVydCgnW0ZVRUxdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbnRoaXMucHJvcGVydGllcz17J2NoYXJ0LmNvbG9ycyc6WydHcmFkaWVudCh3aGl0ZTpyZWQpJ10sJ2NoYXJ0Lm5lZWRsZS5jb2xvcic6J3JlZCcsJ2NoYXJ0Lmd1dHRlci5sZWZ0Jzo1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjUsJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOjUsJ2NoYXJ0LnRleHQuc2l6ZSc6MTIsJ2NoYXJ0LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LnRleHQuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6dHJ1ZSwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzondmlzaWJsZScsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzp0cnVlLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQuYW5ub3RhdGFibGUnOmZhbHNlLCdjaGFydC5hbm5vdGF0ZS5jb2xvcic6J2JsYWNrJywnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlLCdjaGFydC56b29tLmFjdGlvbic6J3pvb20nLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5pY29uJzonZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCd0FBQUFmQ0FZQUFBRDBtYTA2QUFBRUdFbEVRVlJJUzdWWFN5aHRZUlQram5mZTVGRU1qQXdVQmlRR0hpa3pSV0lra2d5OFl5REsreG5KSzVKQ2VaU1VHS0JNaUF5WWtNeE1KQU1wU2ZKKzIvZDg2OTUvMzNOdW5TUG5IcXQyWjUrOTEvOS8nKycvJysnL2V0OWEvMWI4UG41NmRtTUJoZy9JV0Rnd05vTnpjMzhQSHhrWHROMCtUaWV4cDllSDE4ZklEajFCajYzTi9mdzh2TFMvd3NtY0hvcUttWFQwOVB1TDI5UlZGUkVVNU9UdlRKNlVJQWdpb1ErdkxlMDlNVGIyOXY4UFgxUldCZ0lDWW5KK1hYSXFEUldYTjBkSlQzbklEc1dscGFkUCtscFNXWmxENEttTC84LycrJy83K0xzL1MwOU4xLzd5OFBJU0hoK3NLL1Fzc0RKV2NIRXlHQ25CMWRSVURBd1BJek16VXg1R3BBbloxZGNYeThqSzJ0cmJNNWowNk9zTGMzSnpJU3g4cTRPenNMT09zQXE2dHJlSGc0QUFlSGg0V0picTd1ME56YzdQK1BpWW1CbnQ3ZXpnOVBjWEV4QVFDQWdMZzVPU0V4OGRIdUx1N1d3ZmMzdDdHL3Y2K3lFY2pPOHJJUk9HS2FXZG5aK2pyNnpNRGpJNk94dlQwdER6cjZ1cVMyS3Rrc3Nwd1oyY0hqWTJOdXFTVWhuSG1pbFVDcmF5c21FbGFXbG9LSnBRQ2pJMk5SWDUrUGw1ZVhyNldsQ3YwOC9NVEVNVk9aREgrWnp3NENkbGZYMS9yREh0N2V6RTFOUVhHa2NZRUtpNHVsa1ZLWWxwTEdvdUJzL0ppYUdnSVpMMjV1U2xlY1hGeG9oQXovY2NBejgvUDRlL3ZqN3E2T2p3OFBNamU1RE5SeTk0TVEwSkNVRnRiSzJ3cUtpcEUrc0hCUWJpNHVQd01RODZhazVPRHhNUkVWRmRYSXl3c0RDVWxKUkpEWG5abG1KcWFpcDZlSHVUbTVrcWlrR2x5Y2pJeU1qTCtaclk5SlNVZ016UWlJZ0lORFEyeXBhcXFxa0NaV1hIc25qUUVIQjhmUjBwS2lnQXhhYnE3dXlXT2xKTnh0THVrVEpEczdHeFVWbFpLRE5sNW9xS2k4UHI2K2pPQUl5TWppSStQbDVKR1FHNEYxUXkrTE43ZjNmaVVkR1ptQnNIQndSZ2JHOFB3OExEMDFiYTJObWxYMHJUdG5UUUxDd3ZTakVkSFIzRnhjU0V4TEN3c1JHUmtwQlI5dmVQemVNRHl3M2JUMU5UMFhYTGlUNGE3dTdzNFBqNEdHemQ3SzhHQ2dvS0VzUlI4STRDbTZod0hYVjVlaXY2MkdBRTVucE1UbUZ1QlRDa3ptelQ3cXM1UTlUbFcvbzZPRGx2d2hDSFBNNVNWUFpJeFl6TmVYRnhFYTJzcnZMMjlZVEMyR0kzYU1tM1plcTZ1cnY0TE1DMHREUnNiRzFLOGs1S1M5RGdTMEl3aEtWRmpTc0pBMjJyOS9mMG9LQ2dRZHZQejgzSkVtWjJkbGNwRDltYVNzaG93MEtabmxPOENzeDl5SzNCTEtDTUpQcGYyeEdNaWdkaTlXWG9vYVdkbjUzZHhkUCthbWhyWmg0ZUhoMWhmWDVjVFczMTl2WnlCbnArZmZ6TmtCV0JtaFlhR3lzQi9qMzIyb0Nja0pDQXJLMHVHTWxzSjV1Ym1Cb1B4UmlNekZsb21qcjJNR2RuZTNpNUFOSUxSSkV0SnQ2eXNURzhoOWdEbDRhbTh2RndTVVdyb24xTzlMdWxYSU9xazlwV2Z0ZmRTUzQweXlqNVVoMTAxd1BScnl1UjdSMVpNWC9VMXBmeTVJRjQweGNnVW5HQWM5d3NHWXhzRmh5ODdrd0FBQUFCSlJVNUVya0pnZ2c9PScsJ2NoYXJ0Lmljb24ucmVkcmF3Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOmZhbHNlLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLngnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSc6bnVsbCwnY2hhcnQubGFiZWxzLmZ1bGwnOidGJywnY2hhcnQubGFiZWxzLmVtcHR5JzonRScsJ2NoYXJ0LmxhYmVscy5jb3VudCc6NSwnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQucmFkaXVzJzpudWxsLCdjaGFydC5zY2FsZS52aXNpYmxlJzpmYWxzZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZih0aGlzLnZhbHVlPnRoaXMubWF4KXRoaXMudmFsdWU9dGhpcy5tYXg7aWYodGhpcy52YWx1ZTx0aGlzLm1pbil0aGlzLnZhbHVlPXRoaXMubWluO2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PWNhLmhlaWdodC0yMC10aGlzLmd1dHRlckJvdHRvbVxudGhpcy5yYWRpdXM9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tLTIwO3RoaXMuY29vcmRzVGV4dD1bXTtpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeCddKT09J251bWJlcicpdGhpcy5jZW50ZXJ4PXByb3BbJ2NoYXJ0LmNlbnRlcngnXTtpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeSddKT09J251bWJlcicpdGhpcy5jZW50ZXJ5PXByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZih0eXBlb2YocHJvcFsnY2hhcnQucmFkaXVzJ10pPT0nbnVtYmVyJyl0aGlzLnJhZGl1cz1wcm9wWydjaGFydC5yYWRpdXMnXTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbnRoaXMuYW5nbGVzLnN0YXJ0PShSRy5QSStSRy5IQUxGUEkpLTAuNTt0aGlzLmFuZ2xlcy5lbmQ9KFJHLlBJK1JHLkhBTEZQSSkrMC41O3RoaXMuYW5nbGVzLm5lZWRsZT10aGlzLmdldEFuZ2xlKHRoaXMudmFsdWUpO3RoaXMuRHJhd0xhYmVscygpO3RoaXMuRHJhd0NoYXJ0KCk7aWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3Q2hhcnQ9dGhpcy5EcmF3Q2hhcnQ9ZnVuY3Rpb24oKVxue3RoaXMuRHJhd1NjYWxlKCk7aWYoIVJHLklTT0xEKXt0aGlzLkRyYXdJY29uKCk7fVxudGhpcy5EcmF3TmVlZGxlKCk7fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbntpZighcHJvcFsnY2hhcnQuc2NhbGUudmlzaWJsZSddKXt2YXIgcmFkaXVzPSh0aGlzLnJhZGl1cy0yMCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgeT10aGlzLmNlbnRlcnktTWF0aC5zaW4odGhpcy5hbmdsZXMuc3RhcnQtUkcuUEkpKih0aGlzLnJhZGl1cy0yNSk7dmFyIHg9dGhpcy5jZW50ZXJ4LU1hdGguY29zKHRoaXMuYW5nbGVzLnN0YXJ0LVJHLlBJKSoodGhpcy5yYWRpdXMtMjUpO1JHLlRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC50ZXh0LmZvbnQnXSwnc2l6ZSc6cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sJ3gnOngsJ3knOnksJ3RleHQnOnByb3BbJ2NoYXJ0LmxhYmVscy5lbXB0eSddLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMnfSk7dmFyIHk9dGhpcy5jZW50ZXJ5LU1hdGguc2luKHRoaXMuYW5nbGVzLnN0YXJ0LVJHLlBJKSoodGhpcy5yYWRpdXMtMjUpO3ZhciB4PXRoaXMuY2VudGVyeCtNYXRoLmNvcyh0aGlzLmFuZ2xlcy5zdGFydC1SRy5QSSkqKHRoaXMucmFkaXVzLTI1KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6cHJvcFsnY2hhcnQudGV4dC5mb250J10sJ3NpemUnOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCd4Jzp4LCd5Jzp5LCd0ZXh0Jzpwcm9wWydjaGFydC5sYWJlbHMuZnVsbCddLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMnfSk7fX07dGhpcy5kcmF3TmVlZGxlPXRoaXMuRHJhd05lZWRsZT1mdW5jdGlvbigpXG57Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPTU7Y28ubGluZUNhcD0ncm91bmQnO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddO3ZhciBhbmdsZT10aGlzLmFuZ2xlcy5uZWVkbGU7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtMzAsYW5nbGUsYW5nbGUrMC4wMDAxLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoPTE7dmFyIGN4PXRoaXMuY2VudGVyeCsxMDt2YXIgY3k9dGhpcy5jZW50ZXJ5LTEwXG52YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudChjeCxjeSwzNSxjeCxjeSwwKTtncmFkLmFkZENvbG9yU3RvcCgwLCdibGFjaycpO2dyYWQuYWRkQ29sb3JTdG9wKDEsJyNlZWUnKTtpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gvNi4wJyk+MCl7Z3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChjeCsxMCxjeS0xMCxjeC0xMCxjeSsxMCk7Z3JhZC5hZGRDb2xvclN0b3AoMSwnIzY2NicpO2dyYWQuYWRkQ29sb3JTdG9wKDAuNSwnI2NjYycpO31cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1ncmFkO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwyMCwwLFJHLlRXT1BJLDApO2NvLmZpbGwoKTt9O3RoaXMuZHJhd1NjYWxlPXRoaXMuRHJhd1NjYWxlPWZ1bmN0aW9uKClcbnt2YXIgYSx4LHk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztjby5maWxsU3R5bGU9J3doaXRlJztjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyx0aGlzLmFuZ2xlcy5zdGFydCx0aGlzLmFuZ2xlcy5lbmQsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTEwLHRoaXMuYW5nbGVzLmVuZCx0aGlzLmFuZ2xlcy5zdGFydCx0cnVlKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7dmFyIHN0YXJ0PXRoaXMuYW5nbGVzLnN0YXJ0O3ZhciBlbmQ9dGhpcy5hbmdsZXMubmVlZGxlO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyxzdGFydCxlbmQsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTEwLGVuZCxzdGFydCx0cnVlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Zm9yKGE9dGhpcy5hbmdsZXMuc3RhcnQ7YTw9dGhpcy5hbmdsZXMuZW5kKzAuMDE7YSs9KCh0aGlzLmFuZ2xlcy5lbmQtdGhpcy5hbmdsZXMuc3RhcnQpLzUpKXtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xMCxhLGErMC4wMDAxLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xNSxhKzAuMDAwMSxhLHRydWUpO2NvLnN0cm9rZSgpO31cbmlmKHByb3BbJ2NoYXJ0LnNjYWxlLnZpc2libGUnXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgbnVtTGFiZWxzPXByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO3ZhciBkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciBzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB1bml0c19wb3N0PXByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXTt2YXIgdW5pdHNfcHJlPXByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO2Zvcih2YXIgaT0wO2k8PW51bUxhYmVsczsrK2kpe2E9KCh0aGlzLmFuZ2xlcy5lbmQtdGhpcy5hbmdsZXMuc3RhcnQpKihpL251bUxhYmVscykpK3RoaXMuYW5nbGVzLnN0YXJ0O3k9dGhpcy5jZW50ZXJ5LU1hdGguc2luKGEtUkcuUEkpKih0aGlzLnJhZGl1cy0yNSk7eD10aGlzLmNlbnRlcngtTWF0aC5jb3MoYS1SRy5QSSkqKHRoaXMucmFkaXVzLTI1KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eCwneSc6eSwndGV4dCc6UkcubnVtYmVyX2Zvcm1hdCh0aGlzLCh0aGlzLm1pbisoKHRoaXMubWF4LXRoaXMubWluKSooaS9udW1MYWJlbHMpKSkudG9GaXhlZChkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9fX07dGhpcy5nZXRTaGFwZT1mdW5jdGlvbihlKXt9O3RoaXMuZ2V0VmFsdWU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBhbmdsZT1SRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pO2lmKGFuZ2xlPj10aGlzLmFuZ2xlcy5lbmQpe3JldHVybiB0aGlzLm1heDt9ZWxzZSBpZihhbmdsZTw9dGhpcy5hbmdsZXMuc3RhcnQpe3JldHVybiB0aGlzLm1pbjt9XG52YXIgdmFsdWU9KGFuZ2xlLXRoaXMuYW5nbGVzLnN0YXJ0KS8odGhpcy5hbmdsZXMuZW5kLXRoaXMuYW5nbGVzLnN0YXJ0KTt2YWx1ZT12YWx1ZSoodGhpcy5tYXgtdGhpcy5taW4pO3ZhbHVlPXZhbHVlK3RoaXMubWluO3JldHVybiB2YWx1ZTt9O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIGFuZ2xlPVJHLmdldEFuZ2xlQnlYWSh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG1vdXNlWFlbMF0sbW91c2VYWVsxXSk7dmFyIGFjY3VyYWN5PTE1O3ZhciBsZWZ0TWluPXRoaXMuY2VudGVyeC10aGlzLnJhZGl1czt2YXIgcmlnaHRNYXg9dGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzO3ZhciB0b3BNaW49dGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzO3ZhciBib3R0b21NYXg9dGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzO2lmKG1vdXNlWFlbMF0+bGVmdE1pbiYmbW91c2VYWVswXTxyaWdodE1heCYmbW91c2VYWVsxXT50b3BNaW4mJm1vdXNlWFlbMV08Ym90dG9tTWF4KXtyZXR1cm4gdGhpczt9fTt0aGlzLmRyYXdJY29uPXRoaXMuRHJhd0ljb249ZnVuY3Rpb24oKVxue2lmKCFSRy5JU09MRCl7aWYoIXRoaXMuX19pY29uX198fCF0aGlzLl9faWNvbl9fLl9fbG9hZGVkX18pe3ZhciBpbWc9bmV3IEltYWdlKCk7aW1nLnNyYz1wcm9wWydjaGFydC5pY29uJ107aW1nLl9fb2JqZWN0X189dGhpczt0aGlzLl9faWNvbl9fPWltZztpbWcub25sb2FkPWZ1bmN0aW9uKGUpXG57aW1nLl9fbG9hZGVkX189dHJ1ZTt2YXIgb2JqPWltZy5fX29iamVjdF9fO2NvLmRyYXdJbWFnZShpbWcsb2JqLmNlbnRlcngtKGltZy53aWR0aC8yKSxvYmouY2VudGVyeS1vYmoucmFkaXVzKzM1KTtvYmouRHJhd05lZWRsZSgpO2lmKHByb3BbJ2NoYXJ0Lmljb24ucmVkcmF3J10pe29iai5TZXQoJ2NoYXJ0Lmljb24ucmVkcmF3JyxmYWxzZSk7UkcuQ2xlYXIob2JqLmNhbnZhcyk7UkcuUmVkcmF3Q2FudmFzKGNhKTt9fX1lbHNle3ZhciBpbWc9dGhpcy5fX2ljb25fXztjby5kcmF3SW1hZ2UoaW1nLHRoaXMuY2VudGVyeC0oaW1nLndpZHRoLzIpLHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cyszNSk7fX1cbnRoaXMuRHJhd05lZWRsZSgpO307dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt0aGlzLnZhbHVlPXRoaXMuZ2V0VmFsdWUoZSk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt9fTt0aGlzLmdldEFuZ2xlPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPHRoaXMubWlufHx2YWx1ZT50aGlzLm1heCl7cmV0dXJuIG51bGw7fVxudmFyIGFuZ2xlPSgoKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoodGhpcy5hbmdsZXMuZW5kLXRoaXMuYW5nbGVzLnN0YXJ0KSkrdGhpcy5hbmdsZXMuc3RhcnQ7cmV0dXJuIGFuZ2xlO307dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQubmVlZGxlLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ10pO31cbnZhciBwcm9wcz10aGlzLnByb3BlcnRpZXM7dmFyIGNvbG9ycz1wcm9wc1snY2hhcnQuY29sb3JzJ107Zm9yKHZhciBpPTA7aTxjb2xvcnMubGVuZ3RoOysraSl7Y29sb3JzW2ldPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckxpbmVhckdyYWRpZW50KGNvbG9yc1tpXSk7fVxucHJvcHNbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvclJhZGlhbEdyYWRpZW50KHByb3BzWydjaGFydC5uZWVkbGUuY29sb3InXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckxpbmVhckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvclJhZGlhbEdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mIGNvbG9yIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMCx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTE7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMuZ3Jvdz1mdW5jdGlvbigpXG57dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgbnVtRnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBvYmo9dGhpczt2YXIgb3JpZ1ZhbHVlPU51bWJlcih0aGlzLmN1cnJlbnRWYWx1ZSk7aWYodGhpcy5jdXJyZW50VmFsdWU9PW51bGwpe3RoaXMuY3VycmVudFZhbHVlPXRoaXMubWluO29yaWdWYWx1ZT10aGlzLm1pbjt9XG52YXIgbmV3VmFsdWU9dGhpcy52YWx1ZTt2YXIgZGlmZj1uZXdWYWx1ZS1vcmlnVmFsdWU7dmFyIHN0ZXA9KGRpZmYvbnVtRnJhbWVzKTt2YXIgZnJhbWU9MDtmdW5jdGlvbiBpdGVyYXRvcigpXG57ZnJhbWUrKztvYmoudmFsdWU9KChmcmFtZS9udW1GcmFtZXMpKmRpZmYpK29yaWdWYWx1ZVxuaWYob2JqLnZhbHVlPm9iai5tYXgpb2JqLnZhbHVlPW9iai5tYXg7aWYob2JqLnZhbHVlPG9iai5taW4pb2JqLnZhbHVlPW9iai5taW47UkdyYXBoLmNsZWFyKG9iai5jYW52YXMpO1JHcmFwaC5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWU8bnVtRnJhbWVzKXtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmZ1ZWwuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///218\n");

/***/ }),
/* 219 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Funnel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'funnel';this.coords = [];this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUNNEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': null, 'chart.labels.sticks': false, 'chart.labels.x': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['Gradient(white:red)', 'Gradient(white:green)', 'Gradient(white:gray)', 'Gradient(white:blue)', 'Gradient(white:black)', 'Gradient(white:gray)', 'Gradient(white:pink)', 'Gradient(white:blue)', 'Gradient(white:yellow)', 'Gradient(white:green)', 'Gradient(white:red)'], 'chart.text.size': 12, 'chart.text.boxed': true, 'chart.text.halign': 'left', 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips.highlight': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var i = 0; i < data.length; ++i) {\n    data[i] = parseFloat(data[i]);\n  }\n  this.data = data;for (var i = 0; i < data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.DrawFunnel();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawLabels();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawFunnel = this.DrawFunnel = function () {\n    var width = ca.width - this.gutterLeft - this.gutterRight;var height = ca.height - this.gutterTop - this.gutterBottom;var total = RG.array_max(this.data);var accheight = this.gutterTop;if (prop['chart.shadow']) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (i = 0, len = this.data.length; i < len; ++i) {\n      var firstvalue = this.data[0];var firstwidth = firstvalue / total * width;var curvalue = this.data[i];var curwidth = curvalue / total * width;var curheight = height / this.data.length;var halfCurWidth = curwidth / 2;var nextvalue = this.data[i + 1];var nextwidth = this.data[i + 1] ? nextvalue / total * width : null;var halfNextWidth = nextwidth / 2;var center = this.gutterLeft + firstwidth / 2;var x1 = center - halfCurWidth;var y1 = accheight;var x2 = center + halfCurWidth;var y2 = accheight;var x3 = center + halfNextWidth;var y3 = accheight + curheight;var x4 = center - halfNextWidth;var y4 = accheight + curheight;if (nextwidth && i < this.data.length - 1) {\n        co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.moveTo(x1, y1);co.lineTo(x2, y2);co.lineTo(x3, y3);co.lineTo(x4, y4);co.closePath();this.coords.push([x1, y1, x2, y2, x3, y3, x4, y4]);\n      }\n      if (!prop['chart.shadow']) {\n        co.stroke();\n      }\n      co.fill();accheight += curheight;\n    }\n    if (prop['chart.shadow']) {\n      RG.NoShadow(this);for (i = 0; i < this.coords.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.beginPath();co.moveTo(this.coords[i][0], this.coords[i][1]);co.lineTo(this.coords[i][2], this.coords[i][3]);co.lineTo(this.coords[i][4], this.coords[i][5]);co.lineTo(this.coords[i][6], this.coords[i][7]);co.closePath();co.stroke();co.fill();\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var color = prop['chart.text.color'];var labels = prop['chart.labels'];var halign = prop['chart.text.halign'] == 'left' ? 'left' : 'center';var bgcolor = prop['chart.text.boxed'] ? 'white' : null;if (typeof prop['chart.labels.x'] == 'number') {\n        var x = prop['chart.labels.x'];\n      } else {\n        var x = halign == 'left' ? this.gutterLeft - 15 : (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;\n      }\n      for (var j = 0; j < this.coords.length; ++j) {\n        co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;RG.NoShadow(this);var label = labels[j];RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j][1], 'text': label, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(label).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, ma.round(this.coords[j][1]));co.lineTo(this.coords[j][0] - 10, ma.round(this.coords[j][1]));co.stroke();\n        }\n      }\n      var lastLabel = labels[j];if (lastLabel) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j - 1][5], 'text': lastLabel, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(lastLabel).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, Math.round(this.coords[j - 1][7]));co.lineTo(this.coords[j - 1][6] - 10, Math.round(this.coords[j - 1][7]));co.stroke();\n        }\n      }\n    }\n  };this.getShape = this.getSegment = function (e) {\n    var coords = this.coords;var mouseCoords = RG.getMouseXY(e);var x = mouseCoords[0];var y = mouseCoords[1];for (i = 0, len = coords.length; i < len; ++i) {\n      var segment = coords[i];\n      co.beginPath();co.moveTo(segment[0], segment[1]);co.lineTo(segment[2], segment[3]);co.lineTo(segment[4], segment[5]);co.lineTo(segment[6], segment[7]);co.lineTo(segment[8], segment[9]);if (co.isPointInPath(x, y)) {\n        var tooltip = RGraph.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: coords, 2: i, 'object': this, 'coords': segment, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      var coords = shape['coords'];pa2(co, 'b m % % l % % l % % l % % c s % f %', coords[0], coords[1], coords[2], coords[3], coords[4], coords[5], coords[6], coords[7], prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForHorizontalGradient(colors[i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForHorizontalGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForVerticalGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForHorizontalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForVerticalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - prop['chart.gutter.bottom']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];if (coords && coords.length == 8) {\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.beginPath();co.moveTo(coords[0], coords[1]);co.lineTo(coords[2], coords[3]);co.lineTo(coords[4], coords[5]);co.lineTo(coords[6], coords[7]);co.closePath();co.fill();co.stroke();co.lineWidth = pre_linewidth;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZnVubmVsLmpzPzc0ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5GdW5uZWw9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5kYXRhPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkXG52YXIgY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgZGF0YT1jb25mLmRhdGE7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZjt2YXIgY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgZGF0YT1hcmd1bWVudHNbMV07fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOih0eXBlb2YgaWQ9PT0nb2JqZWN0JyYmaWQuYWxwaGE9PT1mYWxzZSk/ZmFsc2U6dHJ1ZX0pOm51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudHlwZT0nZnVubmVsJzt0aGlzLmNvb3Jkcz1bXTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTtpZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbRlVOTkVMXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLnByb3BlcnRpZXM9eydjaGFydC5zdHJva2VzdHlsZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQubGFiZWxzJzpudWxsLCdjaGFydC5sYWJlbHMuc3RpY2tzJzpmYWxzZSwnY2hhcnQubGFiZWxzLngnOm51bGwsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmNvbG9ycyc6WydHcmFkaWVudCh3aGl0ZTpyZWQpJywnR3JhZGllbnQod2hpdGU6Z3JlZW4pJywnR3JhZGllbnQod2hpdGU6Z3JheSknLCdHcmFkaWVudCh3aGl0ZTpibHVlKScsJ0dyYWRpZW50KHdoaXRlOmJsYWNrKScsJ0dyYWRpZW50KHdoaXRlOmdyYXkpJywnR3JhZGllbnQod2hpdGU6cGluayknLCdHcmFkaWVudCh3aGl0ZTpibHVlKScsJ0dyYWRpZW50KHdoaXRlOnllbGxvdyknLCdHcmFkaWVudCh3aGl0ZTpncmVlbiknLCdHcmFkaWVudCh3aGl0ZTpyZWQpJ10sJ2NoYXJ0LnRleHQuc2l6ZSc6MTIsJ2NoYXJ0LnRleHQuYm94ZWQnOnRydWUsJ2NoYXJ0LnRleHQuaGFsaWduJzonbGVmdCcsJ2NoYXJ0LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LnRleHQuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6dHJ1ZSwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzondmlzaWJsZScsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzp0cnVlLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonIzY2NicsJ2NoYXJ0LnNoYWRvdy5ibHVyJzozLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MywnY2hhcnQuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LmhhbGlnbic6J3JpZ2h0JywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzonc3F1YXJlJywnY2hhcnQua2V5LnJvdW5kZWQnOnRydWUsJ2NoYXJ0LmtleS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmtleS5jb2xvcnMnOm51bGwsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6ZmFsc2UsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzonYmxhY2snLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmhkaXInOidyaWdodCcsJ2NoYXJ0Lnpvb20udmRpcic6J2Rvd24nLCdjaGFydC56b29tLmZyYW1lcyc6MjUsJ2NoYXJ0Lnpvb20uZGVsYXknOjE2LjY2NiwnY2hhcnQuem9vbS5zaGFkb3cnOnRydWUsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQuem9vbS5hY3Rpb24nOid6b29tJywnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5mb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoOysraSl7ZGF0YVtpXT1wYXJzZUZsb2F0KGRhdGFbaV0pO31cbnRoaXMuZGF0YT1kYXRhO2Zvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7KytpKXt0aGlzWyckJytpXT17fTt9XG5pZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbnRoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107UkcuRHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSx0aGlzLmd1dHRlclRvcCxudWxsLHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMik7dGhpcy5EcmF3RnVubmVsKCk7aWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxudGhpcy5EcmF3TGFiZWxzKCk7aWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3RnVubmVsPXRoaXMuRHJhd0Z1bm5lbD1mdW5jdGlvbigpXG57dmFyIHdpZHRoPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0O3ZhciBoZWlnaHQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tO3ZhciB0b3RhbD1SRy5hcnJheV9tYXgodGhpcy5kYXRhKTt2YXIgYWNjaGVpZ2h0PXRoaXMuZ3V0dGVyVG9wO2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtjby5zaGFkb3dDb2xvcj1wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFk9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTt9XG5mb3IoaT0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuOysraSl7dmFyIGZpcnN0dmFsdWU9dGhpcy5kYXRhWzBdO3ZhciBmaXJzdHdpZHRoPShmaXJzdHZhbHVlL3RvdGFsKSp3aWR0aDt2YXIgY3VydmFsdWU9dGhpcy5kYXRhW2ldO3ZhciBjdXJ3aWR0aD0oY3VydmFsdWUvdG90YWwpKndpZHRoO3ZhciBjdXJoZWlnaHQ9aGVpZ2h0L3RoaXMuZGF0YS5sZW5ndGg7dmFyIGhhbGZDdXJXaWR0aD0oY3Vyd2lkdGgvMik7dmFyIG5leHR2YWx1ZT10aGlzLmRhdGFbaSsxXTt2YXIgbmV4dHdpZHRoPXRoaXMuZGF0YVtpKzFdPyhuZXh0dmFsdWUvdG90YWwpKndpZHRoOm51bGw7dmFyIGhhbGZOZXh0V2lkdGg9KG5leHR3aWR0aC8yKTt2YXIgY2VudGVyPXRoaXMuZ3V0dGVyTGVmdCsoZmlyc3R3aWR0aC8yKTt2YXIgeDE9Y2VudGVyLWhhbGZDdXJXaWR0aDt2YXIgeTE9YWNjaGVpZ2h0O3ZhciB4Mj1jZW50ZXIraGFsZkN1cldpZHRoO3ZhciB5Mj1hY2NoZWlnaHQ7dmFyIHgzPWNlbnRlcitoYWxmTmV4dFdpZHRoO3ZhciB5Mz1hY2NoZWlnaHQrY3VyaGVpZ2h0O3ZhciB4ND1jZW50ZXItaGFsZk5leHRXaWR0aDt2YXIgeTQ9YWNjaGVpZ2h0K2N1cmhlaWdodDtpZihuZXh0d2lkdGgmJmk8dGhpcy5kYXRhLmxlbmd0aC0xKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTtjby5tb3ZlVG8oeDEseTEpO2NvLmxpbmVUbyh4Mix5Mik7Y28ubGluZVRvKHgzLHkzKTtjby5saW5lVG8oeDQseTQpO2NvLmNsb3NlUGF0aCgpO3RoaXMuY29vcmRzLnB1c2goW3gxLHkxLHgyLHkyLHgzLHkzLHg0LHk0XSk7fVxuaWYoIXByb3BbJ2NoYXJ0LnNoYWRvdyddKXtjby5zdHJva2UoKTt9XG5jby5maWxsKCk7YWNjaGVpZ2h0Kz1jdXJoZWlnaHQ7fVxuaWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLk5vU2hhZG93KHRoaXMpO2ZvcihpPTA7aTx0aGlzLmNvb3Jkcy5sZW5ndGg7KytpKXtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jb29yZHNbaV1bMF0sdGhpcy5jb29yZHNbaV1bMV0pO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVsyXSx0aGlzLmNvb3Jkc1tpXVszXSk7Y28ubGluZVRvKHRoaXMuY29vcmRzW2ldWzRdLHRoaXMuY29vcmRzW2ldWzVdKTtjby5saW5lVG8odGhpcy5jb29yZHNbaV1bNl0sdGhpcy5jb29yZHNbaV1bN10pO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9fVxuaWYocHJvcFsnY2hhcnQua2V5J10mJnByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCl7UkcuRHJhd0tleSh0aGlzLHByb3BbJ2NoYXJ0LmtleSddLHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt9fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5sYWJlbHMnXSYmcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoPjApe3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciBzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciBjb2xvcj1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXTt2YXIgaGFsaWduPXByb3BbJ2NoYXJ0LnRleHQuaGFsaWduJ109PSdsZWZ0Jz8nbGVmdCc6J2NlbnRlcic7dmFyIGJnY29sb3I9cHJvcFsnY2hhcnQudGV4dC5ib3hlZCddPyd3aGl0ZSc6bnVsbDtpZih0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLngnXT09J251bWJlcicpe3ZhciB4PXByb3BbJ2NoYXJ0LmxhYmVscy54J107fWVsc2V7dmFyIHg9aGFsaWduPT0nbGVmdCc/KHRoaXMuZ3V0dGVyTGVmdC0xNSk6KChjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvMikrdGhpcy5ndXR0ZXJMZWZ0O31cbmZvcih2YXIgaj0wO2o8dGhpcy5jb29yZHMubGVuZ3RoOysrail7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztjby5maWxsU3R5bGU9Y29sb3I7UkcuTm9TaGFkb3codGhpcyk7dmFyIGxhYmVsPWxhYmVsc1tqXTtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eCwneSc6dGhpcy5jb29yZHNbal1bMV0sJ3RleHQnOmxhYmVsLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmhhbGlnbiwnYm91bmRpbmcnOnByb3BbJ2NoYXJ0LnRleHQuYm94ZWQnXSwnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd0YWcnOidsYWJlbHMnfSk7aWYocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddKXtjby5mb250PXNpemUrJ3B0ICcrZm9udDt2YXIgbGFiZWxXaWR0aD1jby5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9J2dyYXknO2NvLm1vdmVUbyh4K2xhYmVsV2lkdGgrMTAsbWEucm91bmQodGhpcy5jb29yZHNbal1bMV0pKTtjby5saW5lVG8odGhpcy5jb29yZHNbal1bMF0tMTAsbWEucm91bmQodGhpcy5jb29yZHNbal1bMV0pKTtjby5zdHJva2UoKTt9fVxudmFyIGxhc3RMYWJlbD1sYWJlbHNbal07aWYobGFzdExhYmVsKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eCwneSc6dGhpcy5jb29yZHNbai0xXVs1XSwndGV4dCc6bGFzdExhYmVsLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmhhbGlnbiwnYm91bmRpbmcnOnByb3BbJ2NoYXJ0LnRleHQuYm94ZWQnXSwnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd0YWcnOidsYWJlbHMnfSk7aWYocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddKXtjby5mb250PXNpemUrJ3B0ICcrZm9udDt2YXIgbGFiZWxXaWR0aD1jby5tZWFzdXJlVGV4dChsYXN0TGFiZWwpLndpZHRoO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPSdncmF5Jztjby5tb3ZlVG8oeCtsYWJlbFdpZHRoKzEwLE1hdGgucm91bmQodGhpcy5jb29yZHNbai0xXVs3XSkpO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tqLTFdWzZdLTEwLE1hdGgucm91bmQodGhpcy5jb29yZHNbai0xXVs3XSkpO2NvLnN0cm9rZSgpO319fX07dGhpcy5nZXRTaGFwZT10aGlzLmdldFNlZ21lbnQ9ZnVuY3Rpb24oZSlcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzO3ZhciBtb3VzZUNvb3Jkcz1SRy5nZXRNb3VzZVhZKGUpO3ZhciB4PW1vdXNlQ29vcmRzWzBdO3ZhciB5PW1vdXNlQ29vcmRzWzFdO2ZvcihpPTAsbGVuPWNvb3Jkcy5sZW5ndGg7aTxsZW47KytpKXt2YXIgc2VnbWVudD1jb29yZHNbaV1cbmNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzZWdtZW50WzBdLHNlZ21lbnRbMV0pO2NvLmxpbmVUbyhzZWdtZW50WzJdLHNlZ21lbnRbM10pO2NvLmxpbmVUbyhzZWdtZW50WzRdLHNlZ21lbnRbNV0pO2NvLmxpbmVUbyhzZWdtZW50WzZdLHNlZ21lbnRbN10pO2NvLmxpbmVUbyhzZWdtZW50WzhdLHNlZ21lbnRbOV0pO2lmKGNvLmlzUG9pbnRJblBhdGgoeCx5KSl7dmFyIHRvb2x0aXA9UkdyYXBoLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTtyZXR1cm57MDp0aGlzLDE6Y29vcmRzLDI6aSwnb2JqZWN0Jzp0aGlzLCdjb29yZHMnOnNlZ21lbnQsJ2luZGV4JzppLCd0b29sdGlwJzp0b29sdGlwfTt9fVxucmV0dXJuIG51bGw7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZihwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSl7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7cmV0dXJuO31cbnZhciBjb29yZHM9c2hhcGVbJ2Nvb3JkcyddO3BhMihjbywnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBjIHMgJSBmICUnLGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzJdLGNvb3Jkc1szXSxjb29yZHNbNF0sY29vcmRzWzVdLGNvb3Jkc1s2XSxjb29yZHNbN10scHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO319O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHcmFwaC5nZXRNb3VzZVhZKGUpO2lmKG1vdXNlWFlbMF0+cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSYmbW91c2VYWVswXTwoY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pJiZtb3VzZVhZWzFdPnByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSYmbW91c2VYWVsxXTwoY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpe3JldHVybiB0aGlzO319O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmtleS5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt9XG52YXIgY29sb3JzPXByb3BbJ2NoYXJ0LmNvbG9ycyddO2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JIb3Jpem9udGFsR3JhZGllbnQoY29sb3JzW2ldKTt9XG52YXIga2V5Q29sb3JzPXByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXTtpZihrZXlDb2xvcnMpe2Zvcih2YXIgaT0wO2k8a2V5Q29sb3JzLmxlbmd0aDsrK2kpe2tleUNvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JIb3Jpem9udGFsR3JhZGllbnQoa2V5Q29sb3JzW2ldKTt9fVxucHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JWZXJ0aWNhbEdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JIb3Jpem9udGFsR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckhvcml6b250YWxHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9ySG9yaXpvbnRhbEdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkdyYXBoLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JWZXJ0aWNhbEdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSwwLGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pO3ZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHcmFwaC50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTE7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodD1mdW5jdGlvbihpbmRleClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzW2luZGV4XTtpZihjb29yZHMmJmNvb3Jkcy5sZW5ndGg9PTgpe3ZhciBwcmVfbGluZXdpZHRoPWNvLmxpbmVXaWR0aDtjby5saW5lV2lkdGg9Mjtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oY29vcmRzWzBdLGNvb3Jkc1sxXSk7Y28ubGluZVRvKGNvb3Jkc1syXSxjb29yZHNbM10pO2NvLmxpbmVUbyhjb29yZHNbNF0sY29vcmRzWzVdKTtjby5saW5lVG8oY29vcmRzWzZdLGNvb3Jkc1s3XSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aD1wcmVfbGluZXdpZHRoO319O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmZ1bm5lbC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///219\n");

/***/ }),
/* 220 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gantt = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gantt';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.data = data;this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 7, 'chart.background.grid.autofit.numvlines': null, 'chart.vbars': [], 'chart.hbars': [], 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.gutter.left': 75, 'chart.gutter.right': 25, 'chart.gutter.top': 35, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.align': 'bottom', 'chart.labels.inbar': null, 'chart.labels.inbar.color': 'black', 'chart.labels.inbar.bgcolor': null, 'chart.labels.inbar.align': 'left', 'chart.labels.inbar.size': 10, 'chart.labels.inbar.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.inbar.above': false, 'chart.labels.percent': true, 'chart.vmargin': 2, 'chart.title': '', 'chart.title.background': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.color': null, 'chart.title.yaxis.position': 'right', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.bold': true, 'chart.title.xaxis.color': null }, _defineProperty(_properties, 'chart.title.x', null), _defineProperty(_properties, 'chart.title.y', null), _defineProperty(_properties, 'chart.title.halign', null), _defineProperty(_properties, 'chart.title.valign', null), _defineProperty(_properties, 'chart.borders', true), _defineProperty(_properties, 'chart.defaultcolor', 'white'), _defineProperty(_properties, 'chart.coords', []), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.xmax', 0), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!data) {\n    alert('[GANTT] The Gantt chart event data is now supplied as the second argument to the constructor - please update your code');\n  } else {\n    for (var i = 0, idx = 0; i < data.length; ++i) {\n      if (typeof data[i][0] === 'string') data[i][0] = parseFloat(data[i][0]);if (typeof data[i][1] === 'string') data[i][1] = parseFloat(data[i][1]);if (typeof data[i][2] === 'string') data[i][2] = parseFloat(data[i][2]);if (typeof data[i][7] === 'string') data[i][7] = parseFloat(data[i][7]);\n    }\n  }\n  for (var i = 0, idx = 0; i < data.length; ++i) {\n    if (RGraph.isArray(this.data[i][0])) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        this['$' + idx++] = {};\n      }\n    } else {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    if (name == 'chart.events') {\n      alert('[GANTT] The chart.events property is deprecated - supply the events data as an argument to the constructor instead');this.data = value;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.graphArea = ca.width - this.gutterLeft - this.gutterRight;this.graphHeight = ca.height - this.gutterTop - this.gutterBottom;this.numEvents = this.data.length;\n    this.barHeight = this.graphHeight / this.numEvents;this.halfBarHeight = this.barHeight / 2;RG.background.Draw(this);this.drawLabels();this.DrawEvents();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];var labelsColor = prop['chart.labels.color'] || prop['chart.text.color'];var labelSpace = this.graphArea / labels.length;var x = this.gutterLeft + labelSpace / 2;var y = this.gutterTop - prop['chart.text.size'] / 2 - 5;var font = prop['chart.text.font'];var size = prop['chart.text.size'];co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';\n    if (prop['chart.labels.align'] == 'bottom') {\n      y = ca.height - this.gutterBottom + size + 2;\n    }\n    for (i = 0; i < labels.length; ++i) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': x + i * labelSpace, 'y': y, 'text': String(labels[i]), 'halign': 'center', 'valign': 'center', 'tag': 'labels.horizontal' });\n    }\n    for (var i = 0, len = this.data.length; i < len; ++i) {\n      var ev = this.data[i];var x = this.gutterLeft;var y = this.gutterTop + this.halfBarHeight + i * this.barHeight;co.fillStyle = labelsColor || prop['chart.text.color'];RG.text2(this, { 'font': font, 'size': size, 'x': x - 5, 'y': y, 'text': RG.isArray(ev[0]) ? ev[0][3] ? String(ev[0][3]) : '' : typeof ev[3] == 'string' ? ev[3] : '', 'halign': 'right', 'valign': 'center', 'tag': 'labels.vertical' });\n    }\n  };this.drawEvents = this.DrawEvents = function () {\n    var events = this.data;this.coords = [];if (prop['chart.vbars']) {\n      for (i = 0, len = prop['chart.vbars'].length; i < len; ++i) {\n        if (prop['chart.vbars'][i][0] + prop['chart.vbars'][i][1] > prop['chart.xmax']) {\n          prop['chart.vbars'][i][1] = 364 - prop['chart.vbars'][i][0];\n        }\n        var barX = this.gutterLeft + (prop['chart.vbars'][i][0] - prop['chart.xmin']) / (prop['chart.xmax'] - prop['chart.xmin']) * this.graphArea;var barY = this.gutterTop;var width = this.graphArea / (prop['chart.xmax'] - prop['chart.xmin']) * prop['chart.vbars'][i][1];var height = ca.height - this.gutterTop - this.gutterBottom;if (barX + width > ca.width - this.gutterRight) {\n          width = ca.width - this.gutterRight - barX;\n        }\n        co.fillStyle = prop['chart.vbars'][i][2];co.fillRect(barX, barY, width, height);\n      }\n    }\n    if (prop['chart.hbars']) {\n      for (i = 0, len = prop['chart.hbars'].length; i < len; ++i) {\n        if (prop['chart.hbars'][i]) {\n          var barX = this.gutterLeft,\n              barY = (ca.height - this.gutterTop - this.gutterBottom) / this.data.length * i + this.gutterTop,\n              width = this.graphArea,\n              height = this.barHeight;\n          co.fillStyle = prop['chart.hbars'][i];co.fillRect(barX, barY, width, height);\n        }\n      }\n    }\n    var sequentialIndex = 0;for (i = 0; i < events.length; ++i) {\n      if (typeof events[i][0] == 'number') {\n        this.DrawSingleEvent(events[i], i, sequentialIndex++);\n      } else {\n        for (var j = 0; j < events[i].length; ++j) {\n          var subindex = j;this.DrawSingleEvent(events[i][j], i, sequentialIndex++, subindex);\n        }\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    e = RG.fixEventObject(e);var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);var ret = { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: this.coords[i][4].index, subindex: this.coords[i][4] && typeof this.coords[i][4].subindex === 'number' ? this.coords[i][4].subindex : null, sequentialIndex: this.coords[i][5], tooltip: tooltip };return ret;\n      }\n    }\n  };this.drawSingleEvent = this.DrawSingleEvent = function (ev, index, sequentialIndex) {\n    ev.index = index;if (typeof arguments[3] === 'number') {\n      ev.subindex = arguments[3];\n    }\n    var min = prop['chart.xmin'];co.beginPath();co.strokeStyle = 'black';co.fillStyle = ev[4] ? ev[4] : prop['chart.defaultcolor'];var barStartX = this.gutterLeft + (ev[0] - min) / (prop['chart.xmax'] - min) * this.graphArea;var barStartY = this.gutterTop + index * this.barHeight;var barWidth = ev[1] / (prop['chart.xmax'] - min) * this.graphArea;if (barStartX + barWidth > ca.width - this.gutterRight) {\n      barWidth = ca.width - this.gutterRight - barStartX;\n    }\n    this.coords.push([barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin'], ev, sequentialIndex]);if (prop['chart.borders'] || ev[6]) {\n      co.strokeStyle = typeof ev[6] == 'string' ? ev[6] : 'black';co.lineWidth = typeof ev[7] == 'number' ? ev[7] : 1;co.beginPath();co.strokeRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);\n    }\n    co.beginPath();co.fillRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);co.fill();var complete = ev[2] / 100 * barWidth;if (typeof ev[2] == 'number') {\n      co.beginPath();co.fillStyle = ev[5] ? ev[5] : '#0c0';co.fillRect(barStartX, barStartY + prop['chart.vmargin'], ev[2] / 100 * barWidth, this.barHeight - 2 * prop['chart.vmargin']);if (prop['chart.labels.percent']) {\n        co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': barStartX + barWidth + 5, 'y': barStartY + this.halfBarHeight, 'text': String(ev[2]) + '%', 'valign': 'center', 'tag': 'labels.complete' });\n      }\n    }\n    if (prop['chart.labels.inbar'] && prop['chart.labels.inbar'][sequentialIndex]) {\n      var label = String(prop['chart.labels.inbar'][sequentialIndex]);var halign = prop['chart.labels.inbar.align'] == 'left' ? 'left' : 'center';halign = prop['chart.labels.inbar.align'] == 'right' ? 'right' : halign;if (halign == 'right') {\n        var x = barStartX + barWidth - 5;\n      } else if (halign == 'center') {\n        var x = barStartX + barWidth / 2;\n      } else {\n        var x = barStartX + 5;\n      }\n      if (prop['chart.labels.inbar.above']) {\n        x = barStartX + barWidth + 5;halign = 'left';\n      }\n      co.fillStyle = prop['chart.labels.inbar.color'];RG.text2(this, { 'font': prop['chart.labels.inbar.font'], 'size': prop['chart.labels.inbar.size'], 'x': x, 'y': barStartY + this.halfBarHeight, 'text': label, 'valign': 'center', 'halign': halign, 'bounding': typeof prop['chart.labels.inbar.bgcolor'] == 'string', 'boundingFill': typeof prop['chart.labels.inbar.bgcolor'] == 'string' ? prop['chart.labels.inbar.bgcolor'] : null, 'tag': 'labels.inbar' });\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var bar = RG.Registry.get('chart.adjusting.gantt');if (bar) {\n        var mouseXY = RG.getMouseXY(e),\n            obj = RG.Registry.get('chart.adjusting.gantt')['object'],\n            index = bar['index'],\n            subindex = bar['subindex'],\n            diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'],\n            eventStart = RG.Registry.get('chart.adjusting.gantt')['event_start'],\n            duration = RG.Registry.get('chart.adjusting.gantt')['event_duration'],\n            event = typeof subindex === 'number' ? obj.data[index][subindex] : obj.data[index];\n        if (bar['mode'] == 'move') {\n          diff = ma.round(diff);if (RG.isNull(subindex)) {\n            event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              obj.data[index][0] = 0;\n            } else if (eventStart + diff + obj.data[index][1] > prop['chart.xmax']) {\n              obj.data[index][0] = prop['chart.xmax'] - obj.data[index][1];\n            }\n          } else {\n            var index = RG.Registry.get('chart.adjusting.gantt').index;var subindex = RG.Registry.get('chart.adjusting.gantt').subindex;var event = this.data[index][subindex];event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              event[0] = 0;\n            } else if (eventStart + diff + event[1] > prop['chart.xmax']) {\n              event[0] = prop['chart.xmax'] - event[1];\n            }\n          }\n        } else if (bar['mode'] == 'resize') {\n          if (mouseXY[0] > ca.width - obj.gutterRight) {\n            mouseXY[0] = ca.width - obj.gutterRight;\n          }\n          var diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'];diff = ma.round(diff);if (RG.isNull(subindex)) {\n            obj.data[index][1] = duration + diff;if (obj.data[index][1] < 0) {\n              obj.data[index][1] = 1;\n            }\n          } else {\n            obj.data[index][subindex][1] = duration + diff;if (obj.data[index][subindex][1] < 0) {\n              obj.data[index][subindex][1] = 1;\n            }\n          }\n        }\n        RG.resetColorsToOriginalValues(this);RG.redrawCanvas(ca);RG.fireCustomEvent(obj, 'onadjust');\n      }\n    }\n  };this.getXCoord = function (value) {\n    var min = prop['chart.xmin'];var max = prop['chart.xmax'];var graphArea = ca.width - this.gutterLeft - this.gutterRight;if (value > max || value < min) {\n      return null;\n    }\n    var x = (value - min) / (max - min) * graphArea + this.gutterLeft;return x;\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseXY = arg;\n    } else {\n      var mouseXY = RGraph.getMouseXY(arg);\n    }\n    var mouseX = mouseXY[0];var mouseY = mouseXY[1];var value = (mouseX - this.gutterLeft) / (ca.width - this.gutterLeft - this.gutterRight);value *= prop['chart.xmax'] - prop['chart.xmin'];if (value < prop['chart.xmin'] || value > prop['chart.xmax']) {\n      value = null;\n    }\n    return value;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.arrayClone(this.data);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i) {\n      if (_typeof(this.data[i][0]) == 'object' && typeof this.data[i][0][0] === 'number') {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1, sequentialIndex += 1) {\n          this.data[i][j][4] = this.parseSingleColorForGradient(this.data[i][j][4], { start: this.data[i][j][0], duration: this.data[i][j][1] });this.data[i][j][5] = this.parseSingleColorForGradient(this.data[i][j][5], { start: this.data[i][j][0], duration: this.data[i][j][1] });\n        }\n      } else {\n        if (typeof this.data[i][4] == 'string') this.data[i][4] = this.parseSingleColorForGradient(this.data[i][4], { start: this.data[i][0], duration: this.data[i][1] });if (typeof this.data[i][5] == 'string') this.data[i][5] = this.parseSingleColorForGradient(this.data[i][5], { start: this.data[i][0], duration: this.data[i][1] });++sequentialIndex;\n      }\n    }\n    prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var opts = arguments[1] || {};if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var value = opts.start + opts.duration > prop['chart.xmax'] ? prop['chart.xmax'] : opts.start + opts.duration;var grad = co.createLinearGradient(typeof opts.start === 'number' ? this.getXCoord(opts.start) : this.gutterLeft, 0, typeof opts.start === 'number' ? this.getXCoord(value) : ca.width - this.gutterRight, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] ? arguments[1] : function () {};var canvas = obj.canvas;var context = obj.context;var numFrames = opt.frames || 30;var frame = 0;var original_events = RG.arrayClone(obj.data);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= numFrames) {\n        for (var i = 0, len = obj.data.length; i < len; ++i) {\n          if (_typeof(obj.data[i][0]) === 'object') {\n            for (var j = 0; j < obj.data[i].length; ++j) {\n              obj.data[i][j][1] = frame / numFrames * original_events[i][j][1];\n            }\n          } else {\n            obj.data[i][1] = frame / numFrames * original_events[i][1];\n          }\n        }\n        obj.reset();frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0; i < this.original_colors['data'].length; ++i) {\n      if (this.original_colors['data'][i][4]) {\n        this.data[i][4] = RG.arrayClone(this.original_colors['data'][i][4]);\n      }\n      if (this.original_colors['data'][i][5]) {\n        this.data[i][5] = RG.arrayClone(this.original_colors['data'][i][5]);\n      }\n      if (_typeof(this.original_colors['data'][i][0]) === 'object' && typeof this.original_colors['data'][i][0][0] === 'number') {\n        for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n          this.data[i][j][4] = RG.arrayClone(this.original_colors['data'][i][j][4]);this.data[i][j][5] = RG.arrayClone(this.original_colors['data'][i][j][5]);\n        }\n      }\n    }\n  };this.reset = function () {\n    this.resetColorsToOriginalValues();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.coords = [];\n  };this.sequentialIndex2Grouped = function () {\n    alert('[RGRAPH] Please post in the forum if you see this alert');\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    } else if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.sequentialIndex]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZ2FudHQuanM/ZDY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkdhbnR0PWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuZGF0YT09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgaWQ9Y29uZi5pZFxudmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGE9Y29uZi5kYXRhO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmY7dmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGE9YXJndW1lbnRzWzFdO31cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9Y2FudmFzO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0P3RoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLHthbHBoYToodHlwZW9mIGlkPT09J29iamVjdCcmJmlkLmFscGhhPT09ZmFsc2UpP2ZhbHNlOnRydWV9KTpudWxsO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLnR5cGU9J2dhbnR0Jzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmRhdGE9ZGF0YTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCc6MSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzonI2RkZCcsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbic6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzo3LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOm51bGwsJ2NoYXJ0LnZiYXJzJzpbXSwnY2hhcnQuaGJhcnMnOltdLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuZ3V0dGVyLmxlZnQnOjc1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzozNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LmxhYmVscyc6W10sJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmFsaWduJzonYm90dG9tJywnY2hhcnQubGFiZWxzLmluYmFyJzpudWxsLCdjaGFydC5sYWJlbHMuaW5iYXIuY29sb3InOidibGFjaycsJ2NoYXJ0LmxhYmVscy5pbmJhci5iZ2NvbG9yJzpudWxsLCdjaGFydC5sYWJlbHMuaW5iYXIuYWxpZ24nOidsZWZ0JywnY2hhcnQubGFiZWxzLmluYmFyLnNpemUnOjEwLCdjaGFydC5sYWJlbHMuaW5iYXIuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LmxhYmVscy5pbmJhci5hYm92ZSc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5wZXJjZW50Jzp0cnVlLCdjaGFydC52bWFyZ2luJzoyLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzJzonJywnY2hhcnQudGl0bGUueWF4aXMuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUueWF4aXMucG9zJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMucG9zaXRpb24nOidyaWdodCcsJ2NoYXJ0LnRpdGxlLnlheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzpudWxsLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQuYm9yZGVycyc6dHJ1ZSwnY2hhcnQuZGVmYXVsdGNvbG9yJzond2hpdGUnLCdjaGFydC5jb29yZHMnOltdLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQueG1pbic6MCwnY2hhcnQueG1heCc6MCwnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuYWRqdXN0YWJsZS5vbmx5JzpudWxsLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmlmKCFkYXRhKXthbGVydCgnW0dBTlRUXSBUaGUgR2FudHQgY2hhcnQgZXZlbnQgZGF0YSBpcyBub3cgc3VwcGxpZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IgLSBwbGVhc2UgdXBkYXRlIHlvdXIgY29kZScpO31lbHNle2Zvcih2YXIgaT0wLGlkeD0wO2k8ZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YgZGF0YVtpXVswXT09PSdzdHJpbmcnKWRhdGFbaV1bMF09cGFyc2VGbG9hdChkYXRhW2ldWzBdKTtpZih0eXBlb2YgZGF0YVtpXVsxXT09PSdzdHJpbmcnKWRhdGFbaV1bMV09cGFyc2VGbG9hdChkYXRhW2ldWzFdKTtpZih0eXBlb2YgZGF0YVtpXVsyXT09PSdzdHJpbmcnKWRhdGFbaV1bMl09cGFyc2VGbG9hdChkYXRhW2ldWzJdKTtpZih0eXBlb2YgZGF0YVtpXVs3XT09PSdzdHJpbmcnKWRhdGFbaV1bN109cGFyc2VGbG9hdChkYXRhW2ldWzddKTt9fVxuZm9yKHZhciBpPTAsaWR4PTA7aTxkYXRhLmxlbmd0aDsrK2kpe2lmKFJHcmFwaC5pc0FycmF5KHRoaXMuZGF0YVtpXVswXSkpe2Zvcih2YXIgaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2ope3RoaXNbJyQnKyhpZHgrKyldPXt9O319ZWxzZXt0aGlzWyckJysoaWR4KyspXT17fTt9fVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0Lm1hcmdpbicpe25hbWU9J2NoYXJ0LnZtYXJnaW4nfVxuaWYobmFtZT09J2NoYXJ0LmV2ZW50cycpe2FsZXJ0KCdbR0FOVFRdIFRoZSBjaGFydC5ldmVudHMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCAtIHN1cHBseSB0aGUgZXZlbnRzIGRhdGEgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQnKTt0aGlzLmRhdGE9dmFsdWU7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC5tYXJnaW4nKXtuYW1lPSdjaGFydC52bWFyZ2luJ31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY29vcmRzVGV4dD1bXTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbnRoaXMuZ3JhcGhBcmVhPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tO3RoaXMubnVtRXZlbnRzPXRoaXMuZGF0YS5sZW5ndGhcbnRoaXMuYmFySGVpZ2h0PXRoaXMuZ3JhcGhIZWlnaHQvdGhpcy5udW1FdmVudHM7dGhpcy5oYWxmQmFySGVpZ2h0PXRoaXMuYmFySGVpZ2h0LzI7UkcuYmFja2dyb3VuZC5EcmF3KHRoaXMpO3RoaXMuZHJhd0xhYmVscygpO3RoaXMuRHJhd0V2ZW50cygpO2lmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0xhYmVscz10aGlzLkRyYXdMYWJlbHM9ZnVuY3Rpb24oKVxue3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ107dmFyIGxhYmVsc0NvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGxhYmVsU3BhY2U9KHRoaXMuZ3JhcGhBcmVhKS9sYWJlbHMubGVuZ3RoO3ZhciB4PXRoaXMuZ3V0dGVyTGVmdCsobGFiZWxTcGFjZS8yKTt2YXIgeT10aGlzLmd1dHRlclRvcC0ocHJvcFsnY2hhcnQudGV4dC5zaXplJ10vMiktNTt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2NvLnN0cm9rZVN0eWxlPSdibGFjaydcbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5hbGlnbiddPT0nYm90dG9tJyl7eT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rc2l6ZSsyO31cbmZvcihpPTA7aTxsYWJlbHMubGVuZ3RoOysraSl7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOngrKGkqbGFiZWxTcGFjZSksJ3knOnksJ3RleHQnOlN0cmluZyhsYWJlbHNbaV0pLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMuaG9yaXpvbnRhbCd9KTt9XG5mb3IodmFyIGk9MCxsZW49dGhpcy5kYXRhLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciBldj10aGlzLmRhdGFbaV07dmFyIHg9dGhpcy5ndXR0ZXJMZWZ0O3ZhciB5PXRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZkJhckhlaWdodCsoaSp0aGlzLmJhckhlaWdodCk7Y28uZmlsbFN0eWxlPWxhYmVsc0NvbG9yfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOngtNSwneSc6eSwndGV4dCc6UkcuaXNBcnJheShldlswXSk/KGV2WzBdWzNdP1N0cmluZyhldlswXVszXSk6JycpOih0eXBlb2YgZXZbM109PSdzdHJpbmcnP2V2WzNdOicnKSwnaGFsaWduJzoncmlnaHQnLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMudmVydGljYWwnfSk7fX07dGhpcy5kcmF3RXZlbnRzPXRoaXMuRHJhd0V2ZW50cz1mdW5jdGlvbigpXG57dmFyIGV2ZW50cz10aGlzLmRhdGE7dGhpcy5jb29yZHM9W107aWYocHJvcFsnY2hhcnQudmJhcnMnXSl7Zm9yKGk9MCxsZW49cHJvcFsnY2hhcnQudmJhcnMnXS5sZW5ndGg7aTxsZW47KytpKXtpZihwcm9wWydjaGFydC52YmFycyddW2ldWzBdK3Byb3BbJ2NoYXJ0LnZiYXJzJ11baV1bMV0+cHJvcFsnY2hhcnQueG1heCddKXtwcm9wWydjaGFydC52YmFycyddW2ldWzFdPTM2NC1wcm9wWydjaGFydC52YmFycyddW2ldWzBdO31cbnZhciBiYXJYPXRoaXMuZ3V0dGVyTGVmdCsoKChwcm9wWydjaGFydC52YmFycyddW2ldWzBdLXByb3BbJ2NoYXJ0LnhtaW4nXSkvKHByb3BbJ2NoYXJ0LnhtYXgnXS1wcm9wWydjaGFydC54bWluJ10pKSp0aGlzLmdyYXBoQXJlYSk7dmFyIGJhclk9dGhpcy5ndXR0ZXJUb3A7dmFyIHdpZHRoPSh0aGlzLmdyYXBoQXJlYS8ocHJvcFsnY2hhcnQueG1heCddLXByb3BbJ2NoYXJ0LnhtaW4nXSkpKnByb3BbJ2NoYXJ0LnZiYXJzJ11baV1bMV07dmFyIGhlaWdodD1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b207aWYoKGJhclgrd2lkdGgpPihjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSl7d2lkdGg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC1iYXJYO31cbmNvLmZpbGxTdHlsZT1wcm9wWydjaGFydC52YmFycyddW2ldWzJdO2NvLmZpbGxSZWN0KGJhclgsYmFyWSx3aWR0aCxoZWlnaHQpO319XG5pZihwcm9wWydjaGFydC5oYmFycyddKXtmb3IoaT0wLGxlbj1wcm9wWydjaGFydC5oYmFycyddLmxlbmd0aDtpPGxlbjsrK2kpe2lmKHByb3BbJ2NoYXJ0LmhiYXJzJ11baV0pe3ZhciBiYXJYPXRoaXMuZ3V0dGVyTGVmdCxiYXJZPSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS90aGlzLmRhdGEubGVuZ3RoKSppK3RoaXMuZ3V0dGVyVG9wLHdpZHRoPXRoaXMuZ3JhcGhBcmVhLGhlaWdodD10aGlzLmJhckhlaWdodFxuY28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmhiYXJzJ11baV07Y28uZmlsbFJlY3QoYmFyWCxiYXJZLHdpZHRoLGhlaWdodCk7fX19XG52YXIgc2VxdWVudGlhbEluZGV4PTA7Zm9yKGk9MDtpPGV2ZW50cy5sZW5ndGg7KytpKXtpZih0eXBlb2YoZXZlbnRzW2ldWzBdKT09J251bWJlcicpe3RoaXMuRHJhd1NpbmdsZUV2ZW50KGV2ZW50c1tpXSxpLHNlcXVlbnRpYWxJbmRleCsrKTt9ZWxzZXtmb3IodmFyIGo9MDtqPGV2ZW50c1tpXS5sZW5ndGg7KytqKXt2YXIgc3ViaW5kZXg9ajt0aGlzLkRyYXdTaW5nbGVFdmVudChldmVudHNbaV1bal0saSxzZXF1ZW50aWFsSW5kZXgrKyxzdWJpbmRleCk7fX19fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0QmFyPWZ1bmN0aW9uKGUpXG57ZT1SRy5maXhFdmVudE9iamVjdChlKTt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSsrKXt2YXIgbGVmdD10aGlzLmNvb3Jkc1tpXVswXSx0b3A9dGhpcy5jb29yZHNbaV1bMV0sd2lkdGg9dGhpcy5jb29yZHNbaV1bMl0saGVpZ2h0PXRoaXMuY29vcmRzW2ldWzNdO2lmKG1vdXNlWD49bGVmdCYmbW91c2VYPD0obGVmdCt3aWR0aCkmJm1vdXNlWT49dG9wJiZtb3VzZVk8PSh0b3AraGVpZ2h0KSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO3ZhciByZXQ9ezA6dGhpcyxvYmplY3Q6dGhpcywxOmxlZnQseDpsZWZ0LDI6dG9wLHk6dG9wLDM6d2lkdGgsd2lkdGg6d2lkdGgsNDpoZWlnaHQsaGVpZ2h0OmhlaWdodCw1OmksaW5kZXg6dGhpcy5jb29yZHNbaV1bNF0uaW5kZXgsc3ViaW5kZXg6KHRoaXMuY29vcmRzW2ldWzRdJiZ0eXBlb2YgdGhpcy5jb29yZHNbaV1bNF0uc3ViaW5kZXg9PT0nbnVtYmVyJz90aGlzLmNvb3Jkc1tpXVs0XS5zdWJpbmRleDpudWxsKSxzZXF1ZW50aWFsSW5kZXg6dGhpcy5jb29yZHNbaV1bNV0sdG9vbHRpcDp0b29sdGlwfTtyZXR1cm4gcmV0O319fTt0aGlzLmRyYXdTaW5nbGVFdmVudD10aGlzLkRyYXdTaW5nbGVFdmVudD1mdW5jdGlvbihldixpbmRleCxzZXF1ZW50aWFsSW5kZXgpXG57ZXYuaW5kZXg9aW5kZXg7aWYodHlwZW9mIGFyZ3VtZW50c1szXT09PSdudW1iZXInKXtldi5zdWJpbmRleD1hcmd1bWVudHNbM119XG52YXIgbWluPXByb3BbJ2NoYXJ0LnhtaW4nXTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT0nYmxhY2snO2NvLmZpbGxTdHlsZT1ldls0XT9ldls0XTpwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXTt2YXIgYmFyU3RhcnRYPXRoaXMuZ3V0dGVyTGVmdCsoKChldlswXS1taW4pLyhwcm9wWydjaGFydC54bWF4J10tbWluKSkqdGhpcy5ncmFwaEFyZWEpO3ZhciBiYXJTdGFydFk9dGhpcy5ndXR0ZXJUb3ArKGluZGV4KnRoaXMuYmFySGVpZ2h0KTt2YXIgYmFyV2lkdGg9KGV2WzFdLyhwcm9wWydjaGFydC54bWF4J10tbWluKSkqdGhpcy5ncmFwaEFyZWE7aWYoKGJhclN0YXJ0WCtiYXJXaWR0aCk+KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpKXtiYXJXaWR0aD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LWJhclN0YXJ0WDt9XG50aGlzLmNvb3Jkcy5wdXNoKFtiYXJTdGFydFgsYmFyU3RhcnRZK3Byb3BbJ2NoYXJ0LnZtYXJnaW4nXSxiYXJXaWR0aCx0aGlzLmJhckhlaWdodC0oMipwcm9wWydjaGFydC52bWFyZ2luJ10pLGV2LHNlcXVlbnRpYWxJbmRleCxdKTtpZihwcm9wWydjaGFydC5ib3JkZXJzJ118fGV2WzZdKXtjby5zdHJva2VTdHlsZT10eXBlb2YoZXZbNl0pPT0nc3RyaW5nJz9ldls2XTonYmxhY2snO2NvLmxpbmVXaWR0aD0odHlwZW9mKGV2WzddKT09J251bWJlcic/ZXZbN106MSk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlUmVjdChiYXJTdGFydFgsYmFyU3RhcnRZK3Byb3BbJ2NoYXJ0LnZtYXJnaW4nXSxiYXJXaWR0aCx0aGlzLmJhckhlaWdodC0oMipwcm9wWydjaGFydC52bWFyZ2luJ10pKTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsUmVjdChiYXJTdGFydFgsYmFyU3RhcnRZK3Byb3BbJ2NoYXJ0LnZtYXJnaW4nXSxiYXJXaWR0aCx0aGlzLmJhckhlaWdodC0oMipwcm9wWydjaGFydC52bWFyZ2luJ10pKTtjby5maWxsKCk7dmFyIGNvbXBsZXRlPShldlsyXS8xMDApKmJhcldpZHRoO2lmKHR5cGVvZihldlsyXSk9PSdudW1iZXInKXtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9ZXZbNV0/ZXZbNV06JyMwYzAnO2NvLmZpbGxSZWN0KGJhclN0YXJ0WCxiYXJTdGFydFkrcHJvcFsnY2hhcnQudm1hcmdpbiddLChldlsyXS8xMDApKmJhcldpZHRoLHRoaXMuYmFySGVpZ2h0LSgyKnByb3BbJ2NoYXJ0LnZtYXJnaW4nXSkpO2lmKHByb3BbJ2NoYXJ0LmxhYmVscy5wZXJjZW50J10pe2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcuVGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwneCc6YmFyU3RhcnRYK2JhcldpZHRoKzUsJ3knOmJhclN0YXJ0WSt0aGlzLmhhbGZCYXJIZWlnaHQsJ3RleHQnOlN0cmluZyhldlsyXSkrJyUnLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMuY29tcGxldGUnfSk7fX1cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhciddJiZwcm9wWydjaGFydC5sYWJlbHMuaW5iYXInXVtzZXF1ZW50aWFsSW5kZXhdKXt2YXIgbGFiZWw9U3RyaW5nKHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhciddW3NlcXVlbnRpYWxJbmRleF0pO3ZhciBoYWxpZ249cHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmFsaWduJ109PSdsZWZ0Jz8nbGVmdCc6J2NlbnRlcic7aGFsaWduPXByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5hbGlnbiddPT0ncmlnaHQnPydyaWdodCc6aGFsaWduO2lmKGhhbGlnbj09J3JpZ2h0Jyl7dmFyIHg9KGJhclN0YXJ0WCtiYXJXaWR0aCktNTt9ZWxzZSBpZihoYWxpZ249PSdjZW50ZXInKXt2YXIgeD1iYXJTdGFydFgrKGJhcldpZHRoLzIpO31lbHNle3ZhciB4PWJhclN0YXJ0WCs1O31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5hYm92ZSddKXt4PWJhclN0YXJ0WCtiYXJXaWR0aCs1O2hhbGlnbj0nbGVmdCc7fVxuY28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5jb2xvciddO1JHLnRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC5sYWJlbHMuaW5iYXIuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC5sYWJlbHMuaW5iYXIuc2l6ZSddLCd4Jzp4LCd5JzpiYXJTdGFydFkrdGhpcy5oYWxmQmFySGVpZ2h0LCd0ZXh0JzpsYWJlbCwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzpoYWxpZ24sJ2JvdW5kaW5nJzp0eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmJnY29sb3InXSk9PSdzdHJpbmcnLCdib3VuZGluZ0ZpbGwnOnR5cGVvZihwcm9wWydjaGFydC5sYWJlbHMuaW5iYXIuYmdjb2xvciddKT09J3N0cmluZyc/cHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmJnY29sb3InXTpudWxsLCd0YWcnOidsYWJlbHMuaW5iYXInfSk7fX07dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7UkcuSGlnaGxpZ2h0LlJlY3QodGhpcyxzaGFwZSk7fX07dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTtpZihtb3VzZVhZWzBdPnRoaXMuZ3V0dGVyTGVmdCYmbW91c2VYWVswXTwoY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJm1vdXNlWFlbMV0+dGhpcy5ndXR0ZXJUb3AmJm1vdXNlWFlbMV08KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpe3JldHVybiB0aGlzO319O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZT10aGlzLkFkanVzdGluZ19tb3VzZW1vdmU9ZnVuY3Rpb24oZSlcbntpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJlJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuYWRqdXN0aW5nJykmJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkPT10aGlzLnVpZCl7dmFyIGJhcj1SRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpO2lmKGJhcil7dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxvYmo9UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKVsnb2JqZWN0J10saW5kZXg9YmFyWydpbmRleCddLHN1YmluZGV4PWJhclsnc3ViaW5kZXgnXSxkaWZmPSgobW91c2VYWVswXS1SRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpWydtb3VzZXgnXSkvKGNhLndpZHRoLW9iai5ndXR0ZXJMZWZ0LW9iai5ndXR0ZXJSaWdodCkpKnByb3BbJ2NoYXJ0LnhtYXgnXSxldmVudFN0YXJ0PVJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuYWRqdXN0aW5nLmdhbnR0JylbJ2V2ZW50X3N0YXJ0J10sZHVyYXRpb249UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKVsnZXZlbnRfZHVyYXRpb24nXSxldmVudD10eXBlb2Ygc3ViaW5kZXg9PT0nbnVtYmVyJz9vYmouZGF0YVtpbmRleF1bc3ViaW5kZXhdOm9iai5kYXRhW2luZGV4XVxuaWYoYmFyWydtb2RlJ109PSdtb3ZlJyl7ZGlmZj1tYS5yb3VuZChkaWZmKTtpZihSRy5pc051bGwoc3ViaW5kZXgpKXtldmVudFswXT1ldmVudFN0YXJ0K2RpZmY7aWYoZXZlbnRTdGFydCtkaWZmPDApe29iai5kYXRhW2luZGV4XVswXT0wO31lbHNlIGlmKChldmVudFN0YXJ0K2RpZmYrb2JqLmRhdGFbaW5kZXhdWzFdKT5wcm9wWydjaGFydC54bWF4J10pe29iai5kYXRhW2luZGV4XVswXT1wcm9wWydjaGFydC54bWF4J10tb2JqLmRhdGFbaW5kZXhdWzFdO319ZWxzZXt2YXIgaW5kZXg9UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKS5pbmRleDt2YXIgc3ViaW5kZXg9UkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKS5zdWJpbmRleDt2YXIgZXZlbnQ9dGhpcy5kYXRhW2luZGV4XVtzdWJpbmRleF07ZXZlbnRbMF09ZXZlbnRTdGFydCtkaWZmO2lmKChldmVudFN0YXJ0K2RpZmYpPDApe2V2ZW50WzBdPTA7fWVsc2UgaWYoKGV2ZW50U3RhcnQrZGlmZitldmVudFsxXSk+cHJvcFsnY2hhcnQueG1heCddKXtldmVudFswXT1wcm9wWydjaGFydC54bWF4J10tZXZlbnRbMV07fX19ZWxzZSBpZihiYXJbJ21vZGUnXT09J3Jlc2l6ZScpe2lmKG1vdXNlWFlbMF0+KGNhLndpZHRoLW9iai5ndXR0ZXJSaWdodCkpe21vdXNlWFlbMF09Y2Eud2lkdGgtb2JqLmd1dHRlclJpZ2h0O31cbnZhciBkaWZmPSgobW91c2VYWVswXS1SRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpWydtb3VzZXgnXSkvKGNhLndpZHRoLW9iai5ndXR0ZXJMZWZ0LW9iai5ndXR0ZXJSaWdodCkpKnByb3BbJ2NoYXJ0LnhtYXgnXTtkaWZmPW1hLnJvdW5kKGRpZmYpO2lmKFJHLmlzTnVsbChzdWJpbmRleCkpe29iai5kYXRhW2luZGV4XVsxXT1kdXJhdGlvbitkaWZmO2lmKG9iai5kYXRhW2luZGV4XVsxXTwwKXtvYmouZGF0YVtpbmRleF1bMV09MTt9fWVsc2V7b2JqLmRhdGFbaW5kZXhdW3N1YmluZGV4XVsxXT1kdXJhdGlvbitkaWZmO2lmKG9iai5kYXRhW2luZGV4XVtzdWJpbmRleF1bMV08MCl7b2JqLmRhdGFbaW5kZXhdW3N1YmluZGV4XVsxXT0xO319fVxuUkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHRoaXMpO1JHLnJlZHJhd0NhbnZhcyhjYSk7UkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwnb25hZGp1c3QnKTt9fX07dGhpcy5nZXRYQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57dmFyIG1pbj1wcm9wWydjaGFydC54bWluJ107dmFyIG1heD1wcm9wWydjaGFydC54bWF4J107dmFyIGdyYXBoQXJlYT1jYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodDtpZih2YWx1ZT5tYXh8fHZhbHVlPG1pbil7cmV0dXJuIG51bGw7fVxudmFyIHg9KCgodmFsdWUtbWluKS8obWF4LW1pbikpKmdyYXBoQXJlYSkrdGhpcy5ndXR0ZXJMZWZ0O3JldHVybiB4O307dGhpcy5nZXRWYWx1ZT1mdW5jdGlvbihhcmcpXG57aWYoYXJnLmxlbmd0aD09Mil7dmFyIG1vdXNlWFk9YXJnO31lbHNle3ZhciBtb3VzZVhZPVJHcmFwaC5nZXRNb3VzZVhZKGFyZyk7fVxudmFyIG1vdXNlWD1tb3VzZVhZWzBdO3ZhciBtb3VzZVk9bW91c2VYWVsxXTt2YXIgdmFsdWU9KG1vdXNlWC10aGlzLmd1dHRlckxlZnQpLyhjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCk7dmFsdWUqPShwcm9wWydjaGFydC54bWF4J10tcHJvcFsnY2hhcnQueG1pbiddKTtpZih2YWx1ZTxwcm9wWydjaGFydC54bWluJ118fHZhbHVlPnByb3BbJ2NoYXJ0LnhtYXgnXSl7dmFsdWU9bnVsbDt9XG5yZXR1cm4gdmFsdWU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddPVJHLmFycmF5Q2xvbmUodGhpcy5kYXRhKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5kZWZhdWx0Y29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO31cbmZvcih2YXIgaT0wLHNlcXVlbnRpYWxJbmRleD0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLmRhdGFbaV1bMF09PSdvYmplY3QnJiZ0eXBlb2YgdGhpcy5kYXRhW2ldWzBdWzBdPT09J251bWJlcicpe2Zvcih2YXIgaj0wLGxlbj10aGlzLmRhdGFbaV0ubGVuZ3RoO2o8bGVuO2orPTEsc2VxdWVudGlhbEluZGV4Kz0xKXt0aGlzLmRhdGFbaV1bal1bNF09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldW2pdWzRdLHtzdGFydDp0aGlzLmRhdGFbaV1bal1bMF0sZHVyYXRpb246dGhpcy5kYXRhW2ldW2pdWzFdfSk7dGhpcy5kYXRhW2ldW2pdWzVdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHRoaXMuZGF0YVtpXVtqXVs1XSx7c3RhcnQ6dGhpcy5kYXRhW2ldW2pdWzBdLGR1cmF0aW9uOnRoaXMuZGF0YVtpXVtqXVsxXX0pO319ZWxzZXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldWzRdPT0nc3RyaW5nJyl0aGlzLmRhdGFbaV1bNF09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldWzRdLHtzdGFydDp0aGlzLmRhdGFbaV1bMF0sZHVyYXRpb246dGhpcy5kYXRhW2ldWzFdfSk7aWYodHlwZW9mIHRoaXMuZGF0YVtpXVs1XT09J3N0cmluZycpdGhpcy5kYXRhW2ldWzVdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHRoaXMuZGF0YVtpXVs1XSx7c3RhcnQ6dGhpcy5kYXRhW2ldWzBdLGR1cmF0aW9uOnRoaXMuZGF0YVtpXVsxXX0pOysrc2VxdWVudGlhbEluZGV4O319XG5wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmRlZmF1bHRjb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmRlZmF1bHRjb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbnt2YXIgb3B0cz1hcmd1bWVudHNbMV18fHt9O2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgdmFsdWU9KG9wdHMuc3RhcnQrb3B0cy5kdXJhdGlvbik+cHJvcFsnY2hhcnQueG1heCddP3Byb3BbJ2NoYXJ0LnhtYXgnXToob3B0cy5zdGFydCtvcHRzLmR1cmF0aW9uKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0eXBlb2Ygb3B0cy5zdGFydD09PSdudW1iZXInP3RoaXMuZ2V0WENvb3JkKG9wdHMuc3RhcnQpOnRoaXMuZ3V0dGVyTGVmdCwwLHR5cGVvZiBvcHRzLnN0YXJ0PT09J251bWJlcic/dGhpcy5nZXRYQ29vcmQodmFsdWUpOmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZnVuY3Rpb24oKXt9O3ZhciBjYW52YXM9b2JqLmNhbnZhczt2YXIgY29udGV4dD1vYmouY29udGV4dDt2YXIgbnVtRnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBvcmlnaW5hbF9ldmVudHM9UkcuYXJyYXlDbG9uZShvYmouZGF0YSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZihmcmFtZTw9bnVtRnJhbWVzKXtmb3IodmFyIGk9MCxsZW49b2JqLmRhdGEubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mIG9iai5kYXRhW2ldWzBdPT09J29iamVjdCcpe2Zvcih2YXIgaj0wO2o8b2JqLmRhdGFbaV0ubGVuZ3RoOysrail7b2JqLmRhdGFbaV1bal1bMV09KGZyYW1lL251bUZyYW1lcykqb3JpZ2luYWxfZXZlbnRzW2ldW2pdWzFdO319ZWxzZXtvYmouZGF0YVtpXVsxXT0oZnJhbWUvbnVtRnJhbWVzKSpvcmlnaW5hbF9ldmVudHNbaV1bMV07fX1cbm9iai5yZXNldCgpO2ZyYW1lKys7UkdyYXBoLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXM9ZnVuY3Rpb24oKVxue2Zvcih2YXIgaT0wO2k8dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXS5sZW5ndGg7KytpKXtpZih0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzRdKXt0aGlzLmRhdGFbaV1bNF09UkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzRdKTt9XG5pZih0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzVdKXt0aGlzLmRhdGFbaV1bNV09UkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzVdKTt9XG5pZih0eXBlb2YgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVswXT09PSdvYmplY3QnJiZ0eXBlb2YgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVswXVswXT09PSdudW1iZXInKXtmb3IodmFyIGo9MCxsZW4yPXRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV0ubGVuZ3RoO2o8bGVuMjsrK2ope3RoaXMuZGF0YVtpXVtqXVs0XT1SRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bal1bNF0pO3RoaXMuZGF0YVtpXVtqXVs1XT1SRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bal1bNV0pO319fX07dGhpcy5yZXNldD1mdW5jdGlvbigpXG57dGhpcy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLmNvb3Jkcz1bXTt9O3RoaXMuc2VxdWVudGlhbEluZGV4Mkdyb3VwZWQ9ZnVuY3Rpb24oKXthbGVydCgnW1JHUkFQSF0gUGxlYXNlIHBvc3QgaW4gdGhlIGZvcnVtIGlmIHlvdSBzZWUgdGhpcyBhbGVydCcpO307dGhpcy5pc0FkanVzdGFibGU9ZnVuY3Rpb24oc2hhcGUpXG57aWYoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSl7cmV0dXJuIHRydWU7fWVsc2UgaWYoUkcuaXNBcnJheShwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkmJnByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddW3NoYXBlLnNlcXVlbnRpYWxJbmRleF0pe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmdhbnR0LmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///220\n");

/***/ }),
/* 221 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gauge';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.angles.start': null, 'chart.angles.end': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 15, 'chart.border.width': 10, 'chart.title.top': '', 'chart.title.top.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.top.size': 14, 'chart.title.top.color': '#333', 'chart.title.top.bold': false, 'chart.title.top.pos': null, 'chart.title.bottom': '', 'chart.title.bottom.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.bottom.size': 14, 'chart.title.bottom.color': '#333', 'chart.title.bottom.bold': false, 'chart.title.bottom.pos': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': '#666', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.background.color': 'white', 'chart.background.gradient': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.value.text': false, 'chart.value.text.y.pos': 0.5, 'chart.value.text.units.pre': null, 'chart.value.text.units.post': null, 'chart.value.text.color': 'black', 'chart.value.text.bounding': true, 'chart.value.text.bounding.fill': 'white', 'chart.value.text.bounding.stroke': 'black', 'chart.red.start': 0.9 * this.max, 'chart.red.color': '#DC3912', 'chart.red.width': 10, 'chart.yellow.color': '#FF9900', 'chart.yellow.width': 10, 'chart.green.end': 0.7 * this.max, 'chart.green.color': 'rgba(0,0,0,0)', 'chart.green.width': 10, 'chart.colors.ranges': null, 'chart.needle.size': null, 'chart.needle.tail': false, 'chart.needle.colors': ['#D5604D', 'red', 'green', 'yellow'], 'chart.needle.type': 'triangle', 'chart.needle.width': 7, 'chart.border.outer': '#ccc', 'chart.border.inner': '#f1f1f1', 'chart.border.outline': 'black', 'chart.centerpin.color': 'blue', 'chart.centerpin.radius': null, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.tickmarks.small': 25, 'chart.tickmarks.small.color': 'black', 'chart.tickmarks.medium': 0, 'chart.tickmarks.medium.color': 'black', 'chart.tickmarks.big': 5, 'chart.tickmarks.big.color': 'black', 'chart.labels.count': 5, 'chart.labels.centered': false, 'chart.labels.offset.radius': 0, 'chart.labels.offset.angle': 0, 'chart.labels.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.border.gradient': false, 'chart.adjustable': false, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.title') name = 'chart.title.top';if (name == 'chart.title.font') name = 'chart.title.top.font';if (name == 'chart.title.size') name = 'chart.title.top.size';if (name == 'chart.title.color') name = 'chart.title.top.color';if (name == 'chart.title.bold') name = 'chart.title.top.bold';if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2);this.startAngle = prop['chart.angles.start'] ? prop['chart.angles.start'] : RG.HALFPI / 3 + RG.HALFPI;this.endAngle = prop['chart.angles.end'] ? prop['chart.angles.end'] : RG.TWOPI + RG.HALFPI - RG.HALFPI / 3;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.centerpinRadius = 0.16 * this.radius;if (typeof prop['chart.centerpin.radius'] == 'number') {\n      this.centerpinRadius = prop['chart.centerpin.radius'];\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawBackGround();this.DrawGradient();this.DrawColorBands();this.DrawSmallTickmarks();this.DrawMediumTickmarks();this.DrawBigTickmarks();this.DrawLabels();this.DrawTopTitle();this.DrawBottomTitle();if (_typeof(this.value) == 'object') {\n      for (var i = 0; i < this.value.length; ++i) {\n        this.DrawNeedle(this.value[i], prop['chart.needle.colors'][i], i);\n      }\n    } else {\n      this.DrawNeedle(this.value, prop['chart.needle.colors'][0], 0);\n    }\n    this.DrawCenterpin();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);var grad = co.createRadialGradient(this.centerx + 50, this.centery - 50, 0, this.centerx + 50, this.centery - 50, 150);grad.addColorStop(0, '#eee');grad.addColorStop(1, 'white');var borderWidth = prop['chart.border.width'];co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.outer'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.inner'];co.arc(this.centerx, this.centery, this.radius - borderWidth, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();if (prop['chart.background.gradient']) {\n      co.beginPath();co.fillStyle = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius, 'rgba(255,255,255,0.6)', 'rgba(255,255,255,0.1)');co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.border.outline'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.stroke();\n  };this.drawSmallTickmarks = this.DrawSmallTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.small'];co.lineWidth = 1;for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 5, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawMediumTickmarks = this.DrawMediumTickmarks = function () {\n    if (prop['chart.tickmarks.medium']) {\n      var numTicks = prop['chart.tickmarks.medium'];co.lineWidth = 3;co.lineCap = 'round';co.strokeStyle = prop['chart.tickmarks.medium.color'];for (var i = 0; i <= numTicks; ++i) {\n        co.beginPath();var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle + (this.endAngle - this.startAngle) / (2 * numTicks);if (a > this.startAngle && a < this.endAngle) {\n          co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 6, a, a + 0.00001, 0);\n        }\n        co.stroke();\n      }\n    }\n  };this.drawBigTickmarks = this.DrawBigTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.big'];co.lineWidth = 3;co.lineCap = 'round';for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 10, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    var offset = 6;var grad = co.createRadialGradient(this.centerx + offset, this.centery - offset, 0, this.centerx + offset, this.centery - offset, 25);grad.addColorStop(0, '#ddf');grad.addColorStop(1, prop['chart.centerpin.color']);co.beginPath();co.fillStyle = grad;co.arc(this.centerx, this.centery, this.centerpinRadius, 0, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        num = prop['chart.labels.specific'] ? prop['chart.labels.specific'].length - 1 : prop['chart.labels.count'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'],\n        offseta = prop['chart.labels.offset.angle'];\n    co.beginPath();if (num) {\n      for (var i = 0; i <= num; ++i) {\n        var hyp = this.radius - 25 - prop['chart.border.width'] - prop['chart.labels.offset.radius'];var a = (this.endAngle - this.startAngle) / num;\n        a = this.startAngle + i * a;a -= RG.HALFPI;a += offseta;var x = this.centerx - ma.sin(a) * hyp;var y = this.centery + ma.cos(a) * hyp;var hAlign = x > this.centerx ? 'right' : 'left';var vAlign = y > this.centery ? 'bottom' : 'top';if (a == RG.HALFPI) {\n          vAlign = 'center';\n        } else if (a == RG.PI) {\n          hAlign = 'center';\n        } else if (a == RG.HALFPI + RG.PI) {\n          vAlign = 'center';\n        }\n        if (prop['chart.labels.centered']) {\n          hAlign = 'center';vAlign = 'center';\n        }\n        var value = (this.max - this.min) * (i / num) + this.min;RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': prop['chart.labels.specific'] ? prop['chart.labels.specific'][i] : RG.numberFormat(this, value.toFixed(value === 0 ? 0 : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), 'halign': hAlign, 'valign': vAlign, 'tag': prop['chart.labels.specific'] ? 'labels.specific' : 'labels' });\n      }\n    }\n    co.fill();if (prop['chart.value.text']) {\n      var x = this.centerx;var y = this.centery + prop['chart.value.text.y.pos'] * this.radius;var units_pre = typeof prop['chart.value.text.units.pre'] == 'string' ? prop['chart.value.text.units.pre'] : prop['chart.units.pre'];var units_post = typeof prop['chart.value.text.units.post'] == 'string' ? prop['chart.value.text.units.post'] : prop['chart.units.post'];var color = prop['chart.value.text.color'];var bounding = prop['chart.value.text.bounding'];var boundingFill = prop['chart.value.text.bounding.fill'];var boundingStroke = prop['chart.value.text.bounding.stroke'];co.fillStyle = color;RG.text2(this, { 'font': font, 'size': size + 2, 'x': x, 'y': y, 'text': RG.numberFormat(this, this.value.toFixed(prop['chart.value.text.decimals']), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'bounding': bounding, 'bounding.fill': boundingFill, 'bounding.stroke': boundingStroke, 'tag': 'value.text' });\n    }\n  };this.drawTopTitle = this.DrawTopTitle = function () {\n    var x = this.centerx;var y = this.centery - 25;if (typeof prop['chart.title.top.pos'] == 'number') {\n      y = this.centery - this.radius * prop['chart.title.top.pos'];\n    }\n    if (prop['chart.title.top']) {\n      co.fillStyle = prop['chart.title.top.color'];RG.Text2(this, { 'font': prop['chart.title.top.font'], 'size': prop['chart.title.top.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.top']), 'halign': 'center', 'valign': 'bottom', 'bold': prop['chart.title.top.bold'], 'tag': 'title.top' });\n    }\n  };this.drawBottomTitle = this.DrawBottomTitle = function () {\n    var x = this.centerx;var y = this.centery + this.centerpinRadius + 10;if (typeof prop['chart.title.bottom.pos'] == 'number') {\n      y = this.centery + this.radius * prop['chart.title.bottom.pos'];\n    }\n    if (prop['chart.title.bottom']) {\n      co.fillStyle = prop['chart.title.bottom.color'];RG.Text2(this, { 'font': prop['chart.title.bottom.font'], 'size': prop['chart.title.bottom.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.bottom']), 'halign': 'center', 'valign': 'top', 'bold': prop['chart.title.bottom.bold'], 'tag': 'title.bottom' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color, index) {\n    var type = prop['chart.needle.type'];co.lineWidth = 0.5;co.strokeStyle = 'gray';co.fillStyle = color;var angle = (this.endAngle - this.startAngle) * ((value - this.min) / (this.max - this.min));angle += this.startAngle;if (_typeof(prop['chart.needle.size']) == 'object' && prop['chart.needle.size'] && typeof prop['chart.needle.size'][index] == 'number') {\n      var size = prop['chart.needle.size'][index];\n    } else if (typeof prop['chart.needle.size'] == 'number') {\n      var size = prop['chart.needle.size'];\n    } else {\n      var size = this.radius - 25 - prop['chart.border.width'];\n    }\n    if (type == 'line') {\n      co.beginPath();co.lineWidth = prop['chart.needle.width'];co.strokeStyle = color;co.arc(this.centerx, this.centery, size, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.lineTo(this.centerx, this.centery);co.stroke();\n    } else {\n      co.beginPath();co.arc(this.centerx, this.centery, size, angle, angle + 0.00001, false);co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle + RG.HALFPI, angle + 0.00001 + RG.HALFPI, false);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle - RG.HALFPI, angle - 0.00001 - RG.HALFPI, false);co.stroke();co.fill();this.angle = angle;\n    }\n  };this.drawColorBands = this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, false);co.arc(this.centerx, this.centery, this.radius - 20 - prop['chart.border.width'], (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = this.startAngle;var greenEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.green.width']) - prop['chart.border.width'], greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.red.start'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.yellow.width']) - prop['chart.border.width'], yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = this.startAngle + (this.endAngle - this.startAngle) * ((this.max - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.red.width']) - prop['chart.border.width'], redEnd, redStart, true);co.fill();\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle >= 0 && angle <= RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - this.startAngle) / (this.endAngle - this.startAngle) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.drawGradient = this.DrawGradient = function () {\n    if (prop['chart.border.gradient']) {\n      co.beginPath();var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius - 15);grad.addColorStop(0, 'gray');grad.addColorStop(1, 'white');co.fillStyle = grad;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);\n      co.arc(this.centerx, this.centery, this.radius - 15, RG.TWOPI, 0, true);\n      co.fill();\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.border.inner'] = RG.array_clone(prop['chart.border.inner']);this.original_colors['chart.border.outer'] = RG.array_clone(prop['chart.border.outer']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.needle.colors'] = RG.array_clone(prop['chart.needle.colors']);\n    }\n    prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.border.inner'] = this.parseSingleColorForGradient(prop['chart.border.inner']);prop['chart.border.outer'] = this.parseSingleColorForGradient(prop['chart.border.outer']);if (prop['chart.colors.ranges']) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2], this.radius - 30);\n      }\n    }\n    if (prop['chart.needle.colors']) {\n      var colors = prop['chart.needle.colors'];for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var radiusStart = arguments[1] || 0;if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, radiusStart, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames || 30;var frame = 0;if (typeof obj.value === 'number') {\n      var origValue = Number(obj.currentValue);if (obj.currentValue == null) {\n        obj.currentValue = obj.min;origValue = obj.min;\n      }\n      var newValue = obj.value;var diff = newValue - origValue;var iterator = function iterator() {\n        obj.value = frame / frames * diff + origValue;if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);\n      }\n      var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / frames * diff[i] + origValue[i];if (obj.value[i] > obj.max) obj.value[i] = obj.max;if (obj.value[i] < obj.min) obj.value[i] = obj.min;\n        }\n        RG.redrawCanvas(obj.canvas);if (frame < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZ2F1Z2UuanM/NzQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkdhdWdlPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWRcbnZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW49Y29uZi5taW47dmFyIG1heD1jb25mLm1heDt2YXIgdmFsdWU9Y29uZi52YWx1ZTt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mO3ZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW49YXJndW1lbnRzWzFdO3ZhciBtYXg9YXJndW1lbnRzWzJdO3ZhciB2YWx1ZT1hcmd1bWVudHNbM107fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOih0eXBlb2YgaWQ9PT0nb2JqZWN0JyYmaWQuYWxwaGE9PT1mYWxzZSk/ZmFsc2U6dHJ1ZX0pOm51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudHlwZT0nZ2F1Z2UnO3RoaXMubWluPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1pbik7dGhpcy5tYXg9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy5jdXJyZW50VmFsdWU9bnVsbDt0aGlzLnVpZD1SR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkPXRoaXMuY2FudmFzLnVpZD90aGlzLmNhbnZhcy51aWQ6UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMuY29vcmRzVGV4dD1bXTt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO2lmKHR5cGVvZih0aGlzLnZhbHVlKT09J29iamVjdCcpe2Zvcih2YXIgaT0wO2k8dGhpcy52YWx1ZS5sZW5ndGg7KytpKXtpZih0aGlzLnZhbHVlW2ldPnRoaXMubWF4KXRoaXMudmFsdWVbaV09bWF4O2lmKHRoaXMudmFsdWVbaV08dGhpcy5taW4pdGhpcy52YWx1ZVtpXT1taW47fX1lbHNle2lmKHRoaXMudmFsdWU+dGhpcy5tYXgpdGhpcy52YWx1ZT1tYXg7aWYodGhpcy52YWx1ZTx0aGlzLm1pbil0aGlzLnZhbHVlPW1pbjt9XG50aGlzLnByb3BlcnRpZXM9eydjaGFydC5hbmdsZXMuc3RhcnQnOm51bGwsJ2NoYXJ0LmFuZ2xlcy5lbmQnOm51bGwsJ2NoYXJ0LmNlbnRlcngnOm51bGwsJ2NoYXJ0LmNlbnRlcnknOm51bGwsJ2NoYXJ0LnJhZGl1cyc6bnVsbCwnY2hhcnQuZ3V0dGVyLmxlZnQnOjE1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjE1LCdjaGFydC5ndXR0ZXIudG9wJzoxNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MTUsJ2NoYXJ0LmJvcmRlci53aWR0aCc6MTAsJ2NoYXJ0LnRpdGxlLnRvcCc6JycsJ2NoYXJ0LnRpdGxlLnRvcC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGl0bGUudG9wLnNpemUnOjE0LCdjaGFydC50aXRsZS50b3AuY29sb3InOicjMzMzJywnY2hhcnQudGl0bGUudG9wLmJvbGQnOmZhbHNlLCdjaGFydC50aXRsZS50b3AucG9zJzpudWxsLCdjaGFydC50aXRsZS5ib3R0b20nOicnLCdjaGFydC50aXRsZS5ib3R0b20uZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRpdGxlLmJvdHRvbS5zaXplJzoxNCwnY2hhcnQudGl0bGUuYm90dG9tLmNvbG9yJzonIzMzMycsJ2NoYXJ0LnRpdGxlLmJvdHRvbS5ib2xkJzpmYWxzZSwnY2hhcnQudGl0bGUuYm90dG9tLnBvcyc6bnVsbCwnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5jb2xvcic6JyM2NjYnLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6J3doaXRlJywnY2hhcnQuYmFja2dyb3VuZC5ncmFkaWVudCc6ZmFsc2UsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQudmFsdWUudGV4dCc6ZmFsc2UsJ2NoYXJ0LnZhbHVlLnRleHQueS5wb3MnOjAuNSwnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnOm51bGwsJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucG9zdCc6bnVsbCwnY2hhcnQudmFsdWUudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZyc6dHJ1ZSwnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZy5maWxsJzond2hpdGUnLCdjaGFydC52YWx1ZS50ZXh0LmJvdW5kaW5nLnN0cm9rZSc6J2JsYWNrJywnY2hhcnQucmVkLnN0YXJ0JzowLjkqdGhpcy5tYXgsJ2NoYXJ0LnJlZC5jb2xvcic6JyNEQzM5MTInLCdjaGFydC5yZWQud2lkdGgnOjEwLCdjaGFydC55ZWxsb3cuY29sb3InOicjRkY5OTAwJywnY2hhcnQueWVsbG93LndpZHRoJzoxMCwnY2hhcnQuZ3JlZW4uZW5kJzowLjcqdGhpcy5tYXgsJ2NoYXJ0LmdyZWVuLmNvbG9yJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmdyZWVuLndpZHRoJzoxMCwnY2hhcnQuY29sb3JzLnJhbmdlcyc6bnVsbCwnY2hhcnQubmVlZGxlLnNpemUnOm51bGwsJ2NoYXJ0Lm5lZWRsZS50YWlsJzpmYWxzZSwnY2hhcnQubmVlZGxlLmNvbG9ycyc6WycjRDU2MDREJywncmVkJywnZ3JlZW4nLCd5ZWxsb3cnXSwnY2hhcnQubmVlZGxlLnR5cGUnOid0cmlhbmdsZScsJ2NoYXJ0Lm5lZWRsZS53aWR0aCc6NywnY2hhcnQuYm9yZGVyLm91dGVyJzonI2NjYycsJ2NoYXJ0LmJvcmRlci5pbm5lcic6JyNmMWYxZjEnLCdjaGFydC5ib3JkZXIub3V0bGluZSc6J2JsYWNrJywnY2hhcnQuY2VudGVycGluLmNvbG9yJzonYmx1ZScsJ2NoYXJ0LmNlbnRlcnBpbi5yYWRpdXMnOm51bGwsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQuem9vbS5hY3Rpb24nOid6b29tJywnY2hhcnQudGlja21hcmtzLnNtYWxsJzoyNSwnY2hhcnQudGlja21hcmtzLnNtYWxsLmNvbG9yJzonYmxhY2snLCdjaGFydC50aWNrbWFya3MubWVkaXVtJzowLCdjaGFydC50aWNrbWFya3MubWVkaXVtLmNvbG9yJzonYmxhY2snLCdjaGFydC50aWNrbWFya3MuYmlnJzo1LCdjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJzonYmxhY2snLCdjaGFydC5sYWJlbHMuY291bnQnOjUsJ2NoYXJ0LmxhYmVscy5jZW50ZXJlZCc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5vZmZzZXQucmFkaXVzJzowLCdjaGFydC5sYWJlbHMub2Zmc2V0LmFuZ2xlJzowLCdjaGFydC5sYWJlbHMuc3BlY2lmaWMnOm51bGwsJ2NoYXJ0LmxhYmVscy5vZmZzZXR4JzowLCdjaGFydC5sYWJlbHMub2Zmc2V0eSc6MCwnY2hhcnQuYm9yZGVyLmdyYWRpZW50JzpmYWxzZSwnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LnNoYWRvdyc6dHJ1ZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonZ3JheScsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzowLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MCwnY2hhcnQuc2hhZG93LmJsdXInOjE1LCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZihuYW1lPT0nY2hhcnQudGl0bGUnKW5hbWU9J2NoYXJ0LnRpdGxlLnRvcCc7aWYobmFtZT09J2NoYXJ0LnRpdGxlLmZvbnQnKW5hbWU9J2NoYXJ0LnRpdGxlLnRvcC5mb250JztpZihuYW1lPT0nY2hhcnQudGl0bGUuc2l6ZScpbmFtZT0nY2hhcnQudGl0bGUudG9wLnNpemUnO2lmKG5hbWU9PSdjaGFydC50aXRsZS5jb2xvcicpbmFtZT0nY2hhcnQudGl0bGUudG9wLmNvbG9yJztpZihuYW1lPT0nY2hhcnQudGl0bGUuYm9sZCcpbmFtZT0nY2hhcnQudGl0bGUudG9wLmJvbGQnO2lmKG5hbWU9PSdjaGFydC5uZWVkbGUuY29sb3InKXtuYW1lPSdjaGFydC5uZWVkbGUuY29sb3JzJzt9XG5pZihuYW1lPT0nY2hhcnQubGFiZWxzLm9mZnNldCcpe25hbWU9J2NoYXJ0LmxhYmVscy5vZmZzZXQucmFkaXVzJzt9XG5wcm9wW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0Lm5lZWRsZS5jb2xvcicpe25hbWU9J2NoYXJ0Lm5lZWRsZS5jb2xvcnMnO31cbmlmKG5hbWU9PSdjaGFydC5sYWJlbHMub2Zmc2V0Jyl7bmFtZT0nY2hhcnQubGFiZWxzLm9mZnNldC5yYWRpdXMnO31cbnJldHVybiBwcm9wW25hbWVdO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKSt0aGlzLmd1dHRlclRvcDt0aGlzLnJhZGl1cz1NYXRoLm1pbigoKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSwoKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikpO3RoaXMuc3RhcnRBbmdsZT1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXT9wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTooUkcuSEFMRlBJLzMpK1JHLkhBTEZQSTt0aGlzLmVuZEFuZ2xlPXByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXT9wcm9wWydjaGFydC5hbmdsZXMuZW5kJ106UkcuVFdPUEkrUkcuSEFMRlBJLShSRy5IQUxGUEkvMyk7dGhpcy5jb29yZHNUZXh0PVtdO2lmKHR5cGVvZihwcm9wWydjaGFydC5jZW50ZXJ4J10pPT0nbnVtYmVyJyl0aGlzLmNlbnRlcng9cHJvcFsnY2hhcnQuY2VudGVyeCddO2lmKHR5cGVvZihwcm9wWydjaGFydC5jZW50ZXJ5J10pPT0nbnVtYmVyJyl0aGlzLmNlbnRlcnk9cHJvcFsnY2hhcnQuY2VudGVyeSddO2lmKHR5cGVvZihwcm9wWydjaGFydC5yYWRpdXMnXSk9PSdudW1iZXInKXRoaXMucmFkaXVzPXByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5jZW50ZXJwaW5SYWRpdXM9MC4xNip0aGlzLnJhZGl1cztpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVycGluLnJhZGl1cyddKT09J251bWJlcicpe3RoaXMuY2VudGVycGluUmFkaXVzPXByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5yYWRpdXMnXTt9XG5pZihwcm9wWydjaGFydC5jb250ZXh0bWVudSddKXtSRy5TaG93Q29udGV4dCh0aGlzKTt9XG50aGlzLkRyYXdCYWNrR3JvdW5kKCk7dGhpcy5EcmF3R3JhZGllbnQoKTt0aGlzLkRyYXdDb2xvckJhbmRzKCk7dGhpcy5EcmF3U21hbGxUaWNrbWFya3MoKTt0aGlzLkRyYXdNZWRpdW1UaWNrbWFya3MoKTt0aGlzLkRyYXdCaWdUaWNrbWFya3MoKTt0aGlzLkRyYXdMYWJlbHMoKTt0aGlzLkRyYXdUb3BUaXRsZSgpO3RoaXMuRHJhd0JvdHRvbVRpdGxlKCk7aWYodHlwZW9mKHRoaXMudmFsdWUpPT0nb2JqZWN0Jyl7Zm9yKHZhciBpPTA7aTx0aGlzLnZhbHVlLmxlbmd0aDsrK2kpe3RoaXMuRHJhd05lZWRsZSh0aGlzLnZhbHVlW2ldLHByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvcnMnXVtpXSxpKTt9fWVsc2V7dGhpcy5EcmF3TmVlZGxlKHRoaXMudmFsdWUscHJvcFsnY2hhcnQubmVlZGxlLmNvbG9ycyddWzBdLDApO31cbnRoaXMuRHJhd0NlbnRlcnBpbigpO2lmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0JhY2tHcm91bmQ9dGhpcy5EcmF3QmFja0dyb3VuZD1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLlNldFNoYWRvdyh0aGlzLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsUkcuVFdPUEksMCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KHRoaXMpO3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCs1MCx0aGlzLmNlbnRlcnktNTAsMCx0aGlzLmNlbnRlcngrNTAsdGhpcy5jZW50ZXJ5LTUwLDE1MCk7Z3JhZC5hZGRDb2xvclN0b3AoMCwnI2VlZScpO2dyYWQuYWRkQ29sb3JTdG9wKDEsJ3doaXRlJyk7dmFyIGJvcmRlcldpZHRoPXByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsMCxSRy5UV09QSSwwKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmJvcmRlci5vdXRlciddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsUkcuVFdPUEksMCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy1ib3JkZXJXaWR0aCwwLFJHLlRXT1BJLDApO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLWJvcmRlcldpZHRoLTQsMCxSRy5UV09QSSwwKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy1ib3JkZXJXaWR0aC00LDAsUkcuVFdPUEksMCk7Y28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JhZGllbnQnXSl7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPVJHLlJhZGlhbEdyYWRpZW50KHRoaXMsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwwLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsJ3JnYmEoMjU1LDI1NSwyNTUsMC42KScsJ3JnYmEoMjU1LDI1NSwyNTUsMC4xKScpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLWJvcmRlcldpZHRoLTQsMCxSRy5UV09QSSwwKTtjby5maWxsKCk7fVxuY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYm9yZGVyLm91dGxpbmUnXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cywwLFJHLlRXT1BJLDApO2NvLnN0cm9rZSgpO307dGhpcy5kcmF3U21hbGxUaWNrbWFya3M9dGhpcy5EcmF3U21hbGxUaWNrbWFya3M9ZnVuY3Rpb24oKVxue3ZhciBudW1UaWNrcz1wcm9wWydjaGFydC50aWNrbWFya3Muc21hbGwnXTtjby5saW5lV2lkdGg9MTtmb3IodmFyIGk9MDtpPD1udW1UaWNrczsrK2kpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbC5jb2xvciddO3ZhciBhPSgoKHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKS9udW1UaWNrcykqaSkrdGhpcy5zdGFydEFuZ2xlO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddLTEwLGEsYSswLjAwMDAxLDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddLTEwLTUsYSxhKzAuMDAwMDEsMCk7Y28uc3Ryb2tlKCk7fX07dGhpcy5kcmF3TWVkaXVtVGlja21hcmtzPXRoaXMuRHJhd01lZGl1bVRpY2ttYXJrcz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQudGlja21hcmtzLm1lZGl1bSddKXt2YXIgbnVtVGlja3M9cHJvcFsnY2hhcnQudGlja21hcmtzLm1lZGl1bSddO2NvLmxpbmVXaWR0aD0zO2NvLmxpbmVDYXA9J3JvdW5kJztjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC50aWNrbWFya3MubWVkaXVtLmNvbG9yJ107Zm9yKHZhciBpPTA7aTw9bnVtVGlja3M7KytpKXtjby5iZWdpblBhdGgoKTt2YXIgYT0oKCh0aGlzLmVuZEFuZ2xlLXRoaXMuc3RhcnRBbmdsZSkvbnVtVGlja3MpKmkpK3RoaXMuc3RhcnRBbmdsZSsoKCh0aGlzLmVuZEFuZ2xlLXRoaXMuc3RhcnRBbmdsZSkvKDIqbnVtVGlja3MpKSk7aWYoYT50aGlzLnN0YXJ0QW5nbGUmJmE8dGhpcy5lbmRBbmdsZSl7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10tMTAsYSxhKzAuMDAwMDEsMCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10tMTAtNixhLGErMC4wMDAwMSwwKTt9XG5jby5zdHJva2UoKTt9fX07dGhpcy5kcmF3QmlnVGlja21hcmtzPXRoaXMuRHJhd0JpZ1RpY2ttYXJrcz1mdW5jdGlvbigpXG57dmFyIG51bVRpY2tzPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcnXTtjby5saW5lV2lkdGg9Mztjby5saW5lQ2FwPSdyb3VuZCc7Zm9yKHZhciBpPTA7aTw9bnVtVGlja3M7KytpKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJ107dmFyIGE9KCgodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpL251bVRpY2tzKSppKSt0aGlzLnN0YXJ0QW5nbGU7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10tMTAsYSxhKzAuMDAwMDEsMCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10tMTAtMTAsYSxhKzAuMDAwMDEsMCk7Y28uc3Ryb2tlKCk7fX07dGhpcy5kcmF3Q2VudGVycGluPXRoaXMuRHJhd0NlbnRlcnBpbj1mdW5jdGlvbigpXG57dmFyIG9mZnNldD02O3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCtvZmZzZXQsdGhpcy5jZW50ZXJ5LW9mZnNldCwwLHRoaXMuY2VudGVyeCtvZmZzZXQsdGhpcy5jZW50ZXJ5LW9mZnNldCwyNSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwnI2RkZicpO2dyYWQuYWRkQ29sb3JTdG9wKDEscHJvcFsnY2hhcnQuY2VudGVycGluLmNvbG9yJ10pO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1ncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMuY2VudGVycGluUmFkaXVzLDAsUkcuVFdPUEksMCk7Y28uZmlsbCgpO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSxzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLG51bT1wcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMnXT8ocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoLTEpOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLG9mZnNldHg9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J10sb2Zmc2V0YT1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0LmFuZ2xlJ11cbmNvLmJlZ2luUGF0aCgpO2lmKG51bSl7Zm9yKHZhciBpPTA7aTw9bnVtOysraSl7dmFyIGh5cD0odGhpcy5yYWRpdXMtMjUtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10pLXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQucmFkaXVzJ107dmFyIGE9KHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKS9udW1cbmE9dGhpcy5zdGFydEFuZ2xlKyhpKmEpO2EtPVJHLkhBTEZQSTthKz1vZmZzZXRhO3ZhciB4PXRoaXMuY2VudGVyeC0obWEuc2luKGEpKmh5cCk7dmFyIHk9dGhpcy5jZW50ZXJ5KyhtYS5jb3MoYSkqaHlwKTt2YXIgaEFsaWduPXg+dGhpcy5jZW50ZXJ4PydyaWdodCc6J2xlZnQnO3ZhciB2QWxpZ249eT50aGlzLmNlbnRlcnk/J2JvdHRvbSc6J3RvcCc7aWYoYT09UkcuSEFMRlBJKXt2QWxpZ249J2NlbnRlcic7fWVsc2UgaWYoYT09UkcuUEkpe2hBbGlnbj0nY2VudGVyJzt9ZWxzZSBpZihhPT0oUkcuSEFMRlBJK1JHLlBJKSl7dkFsaWduPSdjZW50ZXInO31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5jZW50ZXJlZCddKXtoQWxpZ249J2NlbnRlcic7dkFsaWduPSdjZW50ZXInO31cbnZhciB2YWx1ZT0oKCh0aGlzLm1heC10aGlzLm1pbikqKGkvbnVtKSkrdGhpcy5taW4pO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp4K29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndGV4dCc6cHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10/cHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ11baV06UkcubnVtYmVyRm9ybWF0KHRoaXMsdmFsdWUudG9GaXhlZCh2YWx1ZT09PTA/MDpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSxwcm9wWydjaGFydC51bml0cy5wcmUnXSxwcm9wWydjaGFydC51bml0cy5wb3N0J10pLCdoYWxpZ24nOmhBbGlnbiwndmFsaWduJzp2QWxpZ24sJ3RhZyc6cHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10/J2xhYmVscy5zcGVjaWZpYyc6J2xhYmVscyd9KTt9fVxuY28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQnXSl7dmFyIHg9dGhpcy5jZW50ZXJ4O3ZhciB5PXRoaXMuY2VudGVyeSsocHJvcFsnY2hhcnQudmFsdWUudGV4dC55LnBvcyddKnRoaXMucmFkaXVzKTt2YXIgdW5pdHNfcHJlPXR5cGVvZihwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnByZSddKT09J3N0cmluZyc/cHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnXTpwcm9wWydjaGFydC51bml0cy5wcmUnXTt2YXIgdW5pdHNfcG9zdD10eXBlb2YocHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wb3N0J10pPT0nc3RyaW5nJz9wcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnBvc3QnXTpwcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGNvbG9yPXByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuY29sb3InXTt2YXIgYm91bmRpbmc9cHJvcFsnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZyddO3ZhciBib3VuZGluZ0ZpbGw9cHJvcFsnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZy5maWxsJ107dmFyIGJvdW5kaW5nU3Ryb2tlPXByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuYm91bmRpbmcuc3Ryb2tlJ107Y28uZmlsbFN0eWxlPWNvbG9yO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplKzIsJ3gnOngsJ3knOnksJ3RleHQnOlJHLm51bWJlckZvcm1hdCh0aGlzLHRoaXMudmFsdWUudG9GaXhlZChwcm9wWydjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJ10pLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZy5maWxsJzpib3VuZGluZ0ZpbGwsJ2JvdW5kaW5nLnN0cm9rZSc6Ym91bmRpbmdTdHJva2UsJ3RhZyc6J3ZhbHVlLnRleHQnfSk7fX07dGhpcy5kcmF3VG9wVGl0bGU9dGhpcy5EcmF3VG9wVGl0bGU9ZnVuY3Rpb24oKVxue3ZhciB4PXRoaXMuY2VudGVyeDt2YXIgeT10aGlzLmNlbnRlcnktMjU7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5wb3MnXSk9PSdudW1iZXInKXt5PXRoaXMuY2VudGVyeS0odGhpcy5yYWRpdXMqcHJvcFsnY2hhcnQudGl0bGUudG9wLnBvcyddKTt9XG5pZihwcm9wWydjaGFydC50aXRsZS50b3AnXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5jb2xvciddO1JHLlRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC50aXRsZS50b3AuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50aXRsZS50b3Auc2l6ZSddLCd4Jzp4LCd5Jzp5LCd0ZXh0JzpTdHJpbmcocHJvcFsnY2hhcnQudGl0bGUudG9wJ10pLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidib3R0b20nLCdib2xkJzpwcm9wWydjaGFydC50aXRsZS50b3AuYm9sZCddLCd0YWcnOid0aXRsZS50b3AnfSk7fX07dGhpcy5kcmF3Qm90dG9tVGl0bGU9dGhpcy5EcmF3Qm90dG9tVGl0bGU9ZnVuY3Rpb24oKVxue3ZhciB4PXRoaXMuY2VudGVyeDt2YXIgeT10aGlzLmNlbnRlcnkrdGhpcy5jZW50ZXJwaW5SYWRpdXMrMTA7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnRpdGxlLmJvdHRvbS5wb3MnXSk9PSdudW1iZXInKXt5PXRoaXMuY2VudGVyeSsodGhpcy5yYWRpdXMqcHJvcFsnY2hhcnQudGl0bGUuYm90dG9tLnBvcyddKTt9XG5pZihwcm9wWydjaGFydC50aXRsZS5ib3R0b20nXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRpdGxlLmJvdHRvbS5jb2xvciddO1JHLlRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC50aXRsZS5ib3R0b20uZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50aXRsZS5ib3R0b20uc2l6ZSddLCd4Jzp4LCd5Jzp5LCd0ZXh0JzpTdHJpbmcocHJvcFsnY2hhcnQudGl0bGUuYm90dG9tJ10pLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOid0b3AnLCdib2xkJzpwcm9wWydjaGFydC50aXRsZS5ib3R0b20uYm9sZCddLCd0YWcnOid0aXRsZS5ib3R0b20nfSk7fX07dGhpcy5kcmF3TmVlZGxlPXRoaXMuRHJhd05lZWRsZT1mdW5jdGlvbih2YWx1ZSxjb2xvcixpbmRleClcbnt2YXIgdHlwZT1wcm9wWydjaGFydC5uZWVkbGUudHlwZSddO2NvLmxpbmVXaWR0aD0wLjU7Y28uc3Ryb2tlU3R5bGU9J2dyYXknO2NvLmZpbGxTdHlsZT1jb2xvcjt2YXIgYW5nbGU9KHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKSooKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKTthbmdsZSs9dGhpcy5zdGFydEFuZ2xlO2lmKHR5cGVvZihwcm9wWydjaGFydC5uZWVkbGUuc2l6ZSddKT09J29iamVjdCcmJnByb3BbJ2NoYXJ0Lm5lZWRsZS5zaXplJ10mJnR5cGVvZihwcm9wWydjaGFydC5uZWVkbGUuc2l6ZSddW2luZGV4XSk9PSdudW1iZXInKXt2YXIgc2l6ZT1wcm9wWydjaGFydC5uZWVkbGUuc2l6ZSddW2luZGV4XTt9ZWxzZSBpZih0eXBlb2YocHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXSk9PSdudW1iZXInKXt2YXIgc2l6ZT1wcm9wWydjaGFydC5uZWVkbGUuc2l6ZSddO31lbHNle3ZhciBzaXplPXRoaXMucmFkaXVzLTI1LXByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddO31cbmlmKHR5cGU9PSdsaW5lJyl7Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0Lm5lZWRsZS53aWR0aCddO2NvLnN0cm9rZVN0eWxlPWNvbG9yO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHNpemUsYW5nbGUsYW5nbGUrMC4wMDAxLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7aWYocHJvcFsnY2hhcnQubmVlZGxlLnRhaWwnXSl7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMqMC4yLGFuZ2xlK1JHLlBJLGFuZ2xlKzAuMDAwMDErUkcuUEksZmFsc2UpO31cbmNvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTt9ZWxzZXtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxzaXplLGFuZ2xlLGFuZ2xlKzAuMDAwMDEsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMuY2VudGVycGluUmFkaXVzKjAuNSxhbmdsZStSRy5IQUxGUEksYW5nbGUrMC4wMDAwMStSRy5IQUxGUEksZmFsc2UpO2lmKHByb3BbJ2NoYXJ0Lm5lZWRsZS50YWlsJ10pe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKjAuMixhbmdsZStSRy5QSSxhbmdsZSswLjAwMDAxK1JHLlBJLGZhbHNlKTt9XG5jby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLmNlbnRlcnBpblJhZGl1cyowLjUsYW5nbGUtUkcuSEFMRlBJLGFuZ2xlLTAuMDAwMDEtUkcuSEFMRlBJLGZhbHNlKTtjby5zdHJva2UoKTtjby5maWxsKCk7dGhpcy5hbmdsZT1hbmdsZTt9fTt0aGlzLmRyYXdDb2xvckJhbmRzPXRoaXMuRHJhd0NvbG9yQmFuZHM9ZnVuY3Rpb24oKVxue2lmKFJHLmlzX2FycmF5KHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXSkpe3ZhciByYW5nZXM9cHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDsrK2kpe2NvLmZpbGxTdHlsZT1yYW5nZXNbaV1bMl07Y28ubGluZVdpZHRoPTA7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtMTAtcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10sKCgocmFuZ2VzW2ldWzBdLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKSt0aGlzLnN0YXJ0QW5nbGUsKCgocmFuZ2VzW2ldWzFdLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKSt0aGlzLnN0YXJ0QW5nbGUsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTIwLXByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddLCgoKHJhbmdlc1tpXVsxXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKSkrdGhpcy5zdGFydEFuZ2xlLCgoKHJhbmdlc1tpXVswXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKSkrdGhpcy5zdGFydEFuZ2xlLHRydWUpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTt9XG5yZXR1cm47fVxuY28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXTt2YXIgZ3JlZW5TdGFydD10aGlzLnN0YXJ0QW5nbGU7dmFyIGdyZWVuRW5kPXRoaXMuc3RhcnRBbmdsZSsodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKigocHJvcFsnY2hhcnQuZ3JlZW4uZW5kJ10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpXG5jby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xMC1wcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSxncmVlblN0YXJ0LGdyZWVuRW5kLGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0oMTArcHJvcFsnY2hhcnQuZ3JlZW4ud2lkdGgnXSktcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10sZ3JlZW5FbmQsZ3JlZW5TdGFydCx0cnVlKTtjby5maWxsKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO3ZhciB5ZWxsb3dTdGFydD1ncmVlbkVuZDt2YXIgeWVsbG93RW5kPXRoaXMuc3RhcnRBbmdsZSsodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKigocHJvcFsnY2hhcnQucmVkLnN0YXJ0J10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpXG5jby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xMC1wcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSx5ZWxsb3dTdGFydCx5ZWxsb3dFbmQsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLSgxMCtwcm9wWydjaGFydC55ZWxsb3cud2lkdGgnXSktcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10seWVsbG93RW5kLHllbGxvd1N0YXJ0LHRydWUpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5yZWQuY29sb3InXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQucmVkLmNvbG9yJ107dmFyIHJlZFN0YXJ0PXllbGxvd0VuZDt2YXIgcmVkRW5kPXRoaXMuc3RhcnRBbmdsZSsodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKigodGhpcy5tYXgtdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpXG5jby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xMC1wcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSxyZWRTdGFydCxyZWRFbmQsZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLSgxMCtwcm9wWydjaGFydC5yZWQud2lkdGgnXSktcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10scmVkRW5kLHJlZFN0YXJ0LHRydWUpO2NvLmZpbGwoKTt9O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSl7fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlWFlbMF07dmFyIG1vdXNlWT1tb3VzZVhZWzFdO3ZhciBhbmdsZT1SRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVgsbW91c2VZKTtpZihhbmdsZT49MCYmYW5nbGU8PVJHLkhBTEZQSSl7YW5nbGUrPVJHLlRXT1BJO31cbnZhciB2YWx1ZT0oKGFuZ2xlLXRoaXMuc3RhcnRBbmdsZSkvKHRoaXMuZW5kQW5nbGUtdGhpcy5zdGFydEFuZ2xlKSkqKHRoaXMubWF4LXRoaXMubWluKTt2YWx1ZT12YWx1ZSt0aGlzLm1pbjtpZih2YWx1ZTx0aGlzLm1pbil7dmFsdWU9dGhpcy5taW59XG5pZih2YWx1ZT50aGlzLm1heCl7dmFsdWU9dGhpcy5tYXh9XG5yZXR1cm4gdmFsdWU7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SR3JhcGguZ2V0TW91c2VYWShlKTtpZihtb3VzZVhZWzBdPih0aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzBdPCh0aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzFdPih0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzFdPCh0aGlzLmNlbnRlcnkrdGhpcy5yYWRpdXMpJiZSRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pPD10aGlzLnJhZGl1cyl7cmV0dXJuIHRoaXM7fX07dGhpcy5kcmF3R3JhZGllbnQ9dGhpcy5EcmF3R3JhZGllbnQ9ZnVuY3Rpb24oKVxue2lmKHByb3BbJ2NoYXJ0LmJvcmRlci5ncmFkaWVudCddKXtjby5iZWdpblBhdGgoKTt2YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtMTUpO2dyYWQuYWRkQ29sb3JTdG9wKDAsJ2dyYXknKTtncmFkLmFkZENvbG9yU3RvcCgxLCd3aGl0ZScpO2NvLmZpbGxTdHlsZT1ncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsUkcuVFdPUEksZmFsc2UpXG5jby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0xNSxSRy5UV09QSSwwLHRydWUpXG5jby5maWxsKCk7fX07dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt0aGlzLnZhbHVlPXRoaXMuZ2V0VmFsdWUoZSk7UkcucmVkcmF3Q2FudmFzKHRoaXMuY2FudmFzKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt9fTt0aGlzLmdldEFuZ2xlPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTx0aGlzLm1pbil7cmV0dXJuIG51bGw7fVxudmFyIGFuZ2xlPSgoKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoodGhpcy5lbmRBbmdsZS10aGlzLnN0YXJ0QW5nbGUpKSt0aGlzLnN0YXJ0QW5nbGU7cmV0dXJuIGFuZ2xlO307dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5yZWQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5yZWQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnllbGxvdy5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZ3JlZW4uY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYm9yZGVyLmlubmVyJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5ib3JkZXIub3V0ZXInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ib3JkZXIub3V0ZXInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5uZWVkbGUuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQubmVlZGxlLmNvbG9ycyddKTt9XG5wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTtwcm9wWydjaGFydC5yZWQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5yZWQuY29sb3InXSk7cHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXSk7cHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pO3Byb3BbJ2NoYXJ0LmJvcmRlci5vdXRlciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJvcmRlci5vdXRlciddKTtpZihwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pe3ZhciByYW5nZXM9cHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDsrK2kpe3Jhbmdlc1tpXVsyXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChyYW5nZXNbaV1bMl0sdGhpcy5yYWRpdXMtMzApO319XG5pZihwcm9wWydjaGFydC5uZWVkbGUuY29sb3JzJ10pe3ZhciBjb2xvcnM9cHJvcFsnY2hhcnQubmVlZGxlLmNvbG9ycyddO2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO319fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue3ZhciByYWRpdXNTdGFydD1hcmd1bWVudHNbMV18fDA7aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkscmFkaXVzU3RhcnQsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZnVuY3Rpb24oKXt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7aWYodHlwZW9mIG9iai52YWx1ZT09PSdudW1iZXInKXt2YXIgb3JpZ1ZhbHVlPU51bWJlcihvYmouY3VycmVudFZhbHVlKTtpZihvYmouY3VycmVudFZhbHVlPT1udWxsKXtvYmouY3VycmVudFZhbHVlPW9iai5taW47b3JpZ1ZhbHVlPW9iai5taW47fVxudmFyIG5ld1ZhbHVlPW9iai52YWx1ZTt2YXIgZGlmZj1uZXdWYWx1ZS1vcmlnVmFsdWU7dmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbntvYmoudmFsdWU9KChmcmFtZS9mcmFtZXMpKmRpZmYpK29yaWdWYWx1ZTtpZihvYmoudmFsdWU+b2JqLm1heClvYmoudmFsdWU9b2JqLm1heDtpZihvYmoudmFsdWU8b2JqLm1pbilvYmoudmFsdWU9b2JqLm1pbjtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWUrKzxmcmFtZXMpe1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjayhvYmopO319O2l0ZXJhdG9yKCk7fWVsc2V7aWYob2JqLmN1cnJlbnRWYWx1ZT09bnVsbCl7b2JqLmN1cnJlbnRWYWx1ZT1bXTtmb3IodmFyIGk9MDtpPG9iai52YWx1ZS5sZW5ndGg7KytpKXtvYmouY3VycmVudFZhbHVlW2ldPW9iai5taW47fVxub3JpZ1ZhbHVlPVJHLmFycmF5X2Nsb25lKG9iai5jdXJyZW50VmFsdWUpO31cbnZhciBvcmlnVmFsdWU9UkcuYXJyYXlfY2xvbmUob2JqLmN1cnJlbnRWYWx1ZSk7dmFyIG5ld1ZhbHVlPVJHLmFycmF5X2Nsb25lKG9iai52YWx1ZSk7dmFyIGRpZmY9W107Zm9yKHZhciBpPTAsbGVuPW5ld1ZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe2RpZmZbaV09bmV3VmFsdWVbaV0tTnVtYmVyKG9iai5jdXJyZW50VmFsdWVbaV0pO31cbnZhciBpdGVyYXRvcj1mdW5jdGlvbigpXG57ZnJhbWUrKztmb3IodmFyIGk9MCxsZW49b2JqLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe29iai52YWx1ZVtpXT0oKGZyYW1lL2ZyYW1lcykqZGlmZltpXSkrb3JpZ1ZhbHVlW2ldO2lmKG9iai52YWx1ZVtpXT5vYmoubWF4KW9iai52YWx1ZVtpXT1vYmoubWF4O2lmKG9iai52YWx1ZVtpXTxvYmoubWluKW9iai52YWx1ZVtpXT1vYmoubWluO31cblJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZihmcmFtZTxmcmFtZXMpe1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjayhvYmopO319O2l0ZXJhdG9yKCk7fVxucmV0dXJuIHRoaXM7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmdhdWdlLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///221\n");

/***/ }),
/* 222 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HBar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.data = data;this.type = 'hbar';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coords2 = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.max = 0;this.stackedOrGrouped = false;this.properties = (_properties = { 'chart.gutter.left': 75, 'chart.gutter.left.autosize': false, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': null, 'chart.background.grid.autofit.numvlines': 5, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.color': null, 'chart.linewidth': 1, 'chart.title': '', 'chart.title.background': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': 0.8, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.color': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.colors': ['red', 'blue', 'green', 'pink', 'yellow', 'cyan', 'navy', 'gray', 'black'], 'chart.colors.sequential': false, 'chart.xlabels.specific': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.specific': null, 'chart.labels.above.color': null, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.font': null, 'chart.labels.above.size': null, 'chart.labels.above.bold': false, 'chart.labels.above.italic': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xlabels.offsetx': 0, 'chart.xlabels.offsety': 0, 'chart.xlabels': true, 'chart.xlabels.count': 5, 'chart.contextmenu': null, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.units.pre': '', 'chart.units.post': '', 'chart.units.ingraph': false, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.xmin': 0, 'chart.xmax': 0, 'chart.axis.color': 'black', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.vmargin': 2, 'chart.vmargin.grouped': 2, 'chart.grouping': 'grouped', 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.style': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.decimals': null, 'chart.scale.zerostart': true, 'chart.noredraw': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.noaxes': false, 'chart.noxtickmarks': false, 'chart.noytickmarks': false, 'chart.numyticks': data.length, 'chart.numxticks': 10, 'chart.variant': 'hbar', 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.yaxispos': 'left' }, _defineProperty(_properties, 'chart.variant', 'hbar'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _properties);\n  if (!this.canvas) {\n    alert('[HBAR] No canvas support');return;\n  }\n  for (i = 0, len = this.data.length; i < len; ++i) {\n    if (_typeof(this.data[i]) == 'object' && !RGraph.isNull(this.data[i])) {\n      this.stackedOrGrouped = true;for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    } else if (typeof this.data[i] == 'string') {\n      this.data[i] = parseFloat(this.data[i]) || 0;\n    } else if (typeof this.data[i] === 'undefined') {\n      this.data[i] = null;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0, len = linear_data.length; i < len; ++i) {\n    this['$' + i] = {};\n  }\n  this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (prop['chart.adjustable'] && prop['chart.grouping'] === 'stacked') {\n      alert('[RGRAPH] The HBar does not support stacked charts with adjusting');\n    }\n    if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n      if (prop['chart.gutter.bottom'] === 25) {\n        this.set('gutterBottom', 80);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.gutter.left.autosize']) {\n      var len = 0;var labels = prop['chart.labels'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];for (var i = 0; i < labels.length; i += 1) {\n        var length = RG.measureText(labels[i], false, font, size)[0] || 0;\n        len = ma.max(len, length);\n      }\n      prop['chart.gutter.left'] = len + 10;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;if (prop['chart.xmin'] > 0 && prop['chart.grouping'] == 'stacked') {\n      alert('[HBAR] Using chart.xmin is not supported with stacked charts, resetting chart.xmin to zero');this.Set('chart.xmin', 0);\n    }\n    this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.graphheight = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;this.halfway = ma.round(this.graphwidth / 2 + this.gutterLeft);\n    RG.Background.draw(this);this.drawbars();this.drawAxes();this.drawLabels();if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    var halfway = this.halfway;\n    co.beginPath();co.lineWidth = prop['chart.axis.linewidth'] ? prop['chart.axis.linewidth'] + 0.001 : 1.001;co.strokeStyle = prop['chart.axis.color'];if (prop['chart.noyaxis'] == false && prop['chart.noaxes'] == false) {\n      if (prop['chart.yaxispos'] == 'center') {\n        co.moveTo(halfway, this.gutterTop);co.lineTo(halfway, ca.height - this.gutterBottom);\n      } else if (prop['chart.yaxispos'] == 'right') {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.noaxes'] == false) {\n      co.moveTo(this.gutterLeft + 0.001, ca.height - this.gutterBottom + 0.001);co.lineTo(ca.width - this.gutterRight + 0.001, ca.height - this.gutterBottom + 0.001);\n    }\n    if (prop['chart.noytickmarks'] == false && prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0 && prop['chart.noaxes'] == false) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / (prop['chart.numyticks'] > 0 ? prop['chart.numyticks'] : this.data.length);for (y = this.gutterTop; y < ca.height - this.gutterBottom - 1; y += yTickGap) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] == true) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n    }\n    if (prop['chart.noxtickmarks'] == false && prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0 && prop['chart.noaxes'] == false) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];yStart = ca.height - this.gutterBottom;yEnd = ca.height - this.gutterBottom + 3;var i = prop['chart.numxticks'];\n      while (i--) {\n        var x = ca.width - this.gutterRight - i * xTickGap;if (prop['chart.yaxispos'] === 'right') {\n          x -= xTickGap;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.yaxispos'] === 'center') {\n        var i = 5;while (i--) {\n          var x = this.gutterLeft + xTickGap * i;co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] == true) {\n        co.moveTo(this.gutterLeft, ma.round(yStart));co.lineTo(this.gutterLeft, ma.round(yEnd));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        text_size = prop['chart.text.size'],\n        font = prop['chart.text.font'],\n        offsetx = prop['chart.xlabels.offsetx'],\n        offsety = prop['chart.xlabels.offsety'];\n    if (prop['chart.units.ingraph']) {\n      units_pre = '';units_post = '';\n    }\n    if (prop['chart.xlabels']) {\n      if (RG.isArray(prop['chart.xlabels.specific'])) {\n        if (prop['chart.yaxispos'] == 'center') {\n          var halfGraphWidth = this.graphwidth / 2;var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / 2 / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + halfGraphWidth + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsetx, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = labels.length - 1; i > 0; i -= 1) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * (labels.length - i - 1) + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { font: font, size: text_size, x: this.gutterLeft + interval * i + offsetx, y: ca.height - this.gutterBottom + offsety, text: labels[i], valign: 'top', halign: 'center', tag: 'scale' });\n          }\n        }\n      } else {\n        var gap = 7;co.beginPath();co.fillStyle = prop['chart.text.color'];if (prop['chart.yaxispos'] == 'center') {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 - this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + this.graphwidth / 2 + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + i * (this.graphwidth / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[len - 1 - i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth * ((i + 1) / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.xmin'] > 0 || prop['chart.noyaxis'] == true || prop['chart.scale.zerostart'] || prop['chart.noaxes']) {\n          var x = prop['chart.yaxispos'] == 'center' ? this.gutterLeft + this.graphwidth / 2 : this.gutterLeft;if (prop['chart.yaxispos'] === 'right') {\n            var x = ca.width - this.gutterRight;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': RG.numberFormat(this, prop['chart.xmin'].toFixed(prop['chart.xmin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n        co.fill();co.stroke();\n      }\n    }\n    if (_typeof(prop['chart.labels']) == 'object') {\n      var xOffset = prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right' ? 15 : 5,\n          font = prop['chart.text.font'],\n          color = prop['chart.labels.color'] || prop['chart.text.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.fillStyle = color;var barHeight = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;\n      if (prop['chart.yaxispos'] === 'right') {\n        var x = ca.width - this.gutterRight + xOffset;var halign = 'left';\n      } else {\n        var x = this.gutterLeft - xOffset;var halign = 'right';\n      }\n      var i = 0;for (y = this.gutterTop + yTickGap / 2; y <= ca.height - this.gutterBottom; y += yTickGap) {\n        RG.text2(this, { 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.labels'][i++]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n      }\n    }\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0;if (prop['chart.xmax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.xmax'], 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'], 'strict': true });this.max = this.scale2.max;\n    } else {\n      var grouping = prop['chart.grouping'];for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = grouping == 'grouped' ? Number(RG.array_max(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(ma.abs(this.data[i]));\n        }\n        this.max = ma.max(Math.abs(this.max), Math.abs(value));\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    if (prop['chart.scale.decimals'] == null && Number(this.max) == 1) {\n      this.Set('chart.scale.decimals', 1);\n    }\n    var colorIdx = 0;this.numbars = RG.arrayLinearize(this.data).length;if (prop['chart.adjustable'] && !prop['chart.xmax']) {\n      this.set('chart.xmax', this.scale2.max);\n    }\n    if (prop['chart.variant'] === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var graphwidth = ca.width - this.gutterLeft - this.gutterRight;var halfwidth = graphwidth / 2;for (i = len = this.data.length - 1; i >= 0; --i) {\n      var width = ma.abs(this.data[i] / this.max * graphwidth);var height = this.graphheight / this.data.length;var orig_height = height;var x = this.gutterLeft;var y = this.gutterTop + i * height;var vmargin = prop['chart.vmargin'];if (prop['chart.yaxispos'] === 'right') {\n        x = ca.width - this.gutterRight - ma.abs(width);\n      }\n      if (width < 0) {\n        x -= width;width = ma.abs(width);\n      }\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      co.beginPath();if (typeof this.data[i] == 'number' || RG.isNull(this.data[i])) {\n        var barHeight = height - 2 * vmargin,\n            barWidth = (this.data[i] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * this.graphwidth,\n            barX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n          barWidth /= 2;barX += halfwidth;if (this.data[i] < 0) {\n            barWidth = (ma.abs(this.data[i]) - prop['chart.xmin']) / (this.max - prop['chart.xmin']);barWidth = barWidth * (this.graphwidth / 2);barX = this.graphwidth / 2 + this.gutterLeft - barWidth;\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          barWidth = ma.abs(barWidth);barX = ca.width - this.gutterRight - barWidth;\n        }\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n          if (prop['chart.colors'][this.numbars - colorIdx]) {\n            co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n          } else {\n            co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n          }\n        }\n        co.strokeRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);co.fillRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);this.coords.push([barX, y + vmargin, barWidth, height - 2 * vmargin, co.fillStyle, this.data[i], true]);if (prop['chart.variant'] === '3d' && typeof this.data[i] == 'number') {\n          var prevStrokeStyle = co.strokeStyle,\n              prevFillStyle = co.fillStyle;RG.noShadow(this);var barX = barX,\n              barY = y + vmargin,\n              barW = barWidth,\n              barH = height - 2 * vmargin,\n              offsetX = prop['chart.variant.threed.offsetx'],\n              offsetY = prop['chart.variant.threed.offsety'],\n              value = this.data[i];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX - (prop['chart.yaxispos'] == 'left' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW + offsetX - (prop['chart.yaxispos'] == 'center' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n            pa2(co, ['b', 'fs', prevFillStyle, 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (prop['chart.yaxispos'] == 'center') {\n          alert('[HBAR] You can\\'t have a stacked chart with the Y axis in the center, change it to grouped');\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var x = ca.width - this.gutterRight;\n        }\n        var barHeight = height - 2 * vmargin;if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = 0; j < this.data[i].length; ++j) {\n          if (prop['chart.shadow'] && prop['chart.variant'] === '3d') {\n            co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n          }\n          if (!RG.isNull(this.data[i][j])) this.data[i][j] = ma.abs(this.data[i][j]);var last = j === this.data[i].length - 1;co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var width = this.data[i][j] / this.max * this.graphwidth;var totalWidth = RG.arraySum(this.data[i]) / this.max * this.graphwidth;if (prop['chart.yaxispos'] === 'right') {\n            x -= width;\n          }\n          co.strokeRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);co.fillRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);this.coords.push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);this.coords2[i].push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = x,\n                barY = y + vmargin,\n                barW = width,\n                barH = height - 2 * vmargin,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];if (!RG.isNull(value)) {\n              pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);\n            }\n            if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (prop['chart.yaxispos'] !== 'right') {\n            x += width;\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var vmarginGrouped = prop['chart.vmargin.grouped'];var individualBarHeight = (height - 2 * vmargin - (this.data[i].length - 1) * vmarginGrouped) / this.data[i].length;\n        if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = this.data[i].length - 1; j >= 0; --j) {\n          if (prop['chart.shadow']) {\n            RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n          }\n          co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var startY = this.gutterTop + height * i + individualBarHeight * j + vmargin + vmarginGrouped * j;var width = (this.data[i][j] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * (ca.width - this.gutterLeft - this.gutterRight);var startX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n            width /= 2;startX += halfwidth;\n          } else if (prop['chart.yaxispos'] == 'right') {\n            width = ma.abs(width);startX = ca.width - this.gutterRight - ma.abs(width);;\n          }\n          if (width < 0) {\n            startX += width;width *= -1;\n          }\n          co.strokeRect(startX, startY, width, individualBarHeight);co.fillRect(startX, startY, width, individualBarHeight);this.coords.push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);this.coords2[i].push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = startX,\n                barY = startY,\n                barW = width,\n                barH = individualBarHeight,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX - (value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n        }\n        startY += vmargin;\n      }\n      co.closePath();\n    }\n    co.stroke();co.fill();if (prop['chart,yaxispos'] === 'right') {\n      pa2(co, 'cr % % % %', ca.width - this.gutterRight + prop['chart.variant.threed.offsetx'], '0', this.gutterRight, ca.height);\n    }\n    if (prop['chart.yaxispos'] === 'right' && prop['chart.variant'] === '3d') {\n      RG.draw3DYAxis(this);\n    }\n    RG.noShadow(this);this.coords = RG.arrayReverse(this.coords);if (prop['chart.grouping'] === 'grouped') {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        this.coords2[i] = RG.arrayReverse(this.coords2[i]);\n      }\n    }\n    this.redrawBars();\n  };this.redrawBars = this.RedrawBars = function () {\n    if (prop['chart.noredraw']) {\n      return;\n    }\n    var coords = this.coords;var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'];RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle'];for (var i = 0; i < coords.length; ++i) {\n      if (prop['chart.shadow']) {\n        pa2(co, 'b lw % r % % % % s % f %', prop['chart.linewidth'], coords[i][0], coords[i][1], coords[i][2], coords[i][3], prop['chart.strokestyle'], coords[i][4]);\n      }\n      var halign = 'left';if (prop['chart.labels.above'] && coords[i][6]) {\n        var border = coords[i][0] + coords[i][2] + 7 + co.measureText(prop['chart.labels.above.units.pre'] + this.coords[i][5] + prop['chart.labels.above.units.post']).width > ca.width ? true : false,\n            text = RG.numberFormat(this, this.coords[i][5].toFixed(prop['chart.labels.above.decimals']), prop['chart.labels.above.units.pre'], prop['chart.labels.above.units.post']);RG.noShadow(this);if (_typeof(prop['chart.labels.above.specific']) === 'object' && prop['chart.labels.above.specific'] && prop['chart.labels.above.specific'][i]) {\n          text = prop['chart.labels.above.specific'][i];\n        }\n        var x = coords[i][0] + coords[i][2] + 5;var y = coords[i][1] + coords[i][3] / 2;if (prop['chart.yaxispos'] === 'right') {\n          x = coords[i][0] - 5;halign = 'right';\n        } else if (prop['chart.yaxispos'] === 'center' && this.data_arr[i] < 0) {\n          x = coords[i][0] - 5;halign = 'right';\n        }\n        RG.text2(this, { font: typeof prop['chart.labels.above.font'] === 'string' ? prop['chart.labels.above.font'] : font, size: typeof prop['chart.labels.above.size'] === 'number' ? prop['chart.labels.above.size'] : size, color: typeof prop['chart.labels.above.color'] === 'string' ? prop['chart.labels.above.color'] : color, x: x, y: y, bold: prop['chart.labels.above.bold'], italic: prop['chart.labels.above.italic'], text: text, valign: 'center', halign: halign, tag: 'labels.above' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e);for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3],\n          idx = i;pa2(co, ['b', 'r', left, top, width, height]);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: left, 'x': left, 2: top, 'y': top, 3: width, 'width': width, 4: height, 'height': height, 5: idx, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.yaxispos'] == 'center') {\n      var value = (mouseX - this.gutterLeft) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value = value - this.max;\n      if (prop['chart.xmin'] > 0) {\n        value = (mouseX - this.gutterLeft - this.graphwidth / 2) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value += prop['chart.xmin'];if (mouseX < this.gutterLeft + this.graphwidth / 2) {\n          value -= 2 * prop['chart.xmin'];\n        }\n      }\n    } else if (prop['chart.yaxispos'] == 'right') {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value = this.scale2.max - value;\n    } else {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value += prop['chart.xmin'];\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= this.gutterLeft && mouseXY[0] <= ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (prop['chart.yaxispos'] == 'center') {\n      if (value > this.max || value < -1 * this.max) {\n        return null;\n      }\n      var width = (ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2;var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width + width;coord = prop['chart.gutter.left'] + coord;\n    } else {\n      if (value > this.max || value < 0) {\n        return null;\n      }\n      var width = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width;coord = prop['chart.gutter.left'] + coord;\n    }\n    return coord;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.labels.colors'] = RG.array_clone(prop['chart.labels.colors']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.labels.colors'] = this.parseSingleColorForGradient(prop['chart.labels.colors']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.yaxispos'] === 'right') {\n        parts = RG.arrayReverse(parts);\n      }\n      var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var obj = this;this.coords2.forEach(function (value, idx, arr) {\n      var shape = obj.coords2[idx][index];\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillRect(shape[0], shape[1], shape[2], shape[3]);co.strokeRect(shape[0], shape[1], shape[2], shape[3]);co.lineWidth = pre_linewidth;\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.getShapeByY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = obj.coords[i][0],\n          top = obj.coords[i][1],\n          width = obj.coords[i][2],\n          height = obj.coords[i][3];if (mouseY >= top && mouseY <= top + height) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, object: obj, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e)),\n          shape = RG.Registry.get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.is_null(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.grow = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);obj.original_data = RG.arrayClone(obj.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    function iterator() {\n      for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        var easingFactor = RG.Effects.getEasingMultiplier(frames, frame);if (_typeof(obj.data[j]) === 'object' && obj.data[j]) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            obj.data[j][k] = RG.isNull(obj.data[j][k]) ? null : obj.original_data[j][k] * easingFactor;\n          }\n        } else {\n          obj.data[j] = RG.isNull(obj.data[j]) ? null : obj.original_data[j] * easingFactor;\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    this.original_data = RG.arrayClone(this.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    if (RG.isArray(opt.data)) {\n      var xmax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            xmax = ma.max(xmax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseFloat(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseFloat(RegExp.$2);\n          }\n          xmax = ma.max(xmax, opt.data[i]);\n        } else {\n          xmax = ma.max(xmax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });if (typeof this.get('chart.xmax') === 'null') {\n        this.set('chart.xmax', scale.max);\n      }\n    }\n    this.set('labelsAbove', false);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          xmax = ma.max(xmax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(group)));\n        } else {\n          xmax = ma.max(xmax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    if (typeof opt.xmax === 'number') {\n      obj.set('xmax', opt.xmax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(obj.data),\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('xmax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redrawCanvas(obj.canvas);\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguaGJhci5qcz8yMjIyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguSEJhcj1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWRcbnZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBkYXRhPWNvbmYuZGF0YTt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mO3ZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBkYXRhPWFyZ3VtZW50c1sxXTt9XG50aGlzLmlkPWlkO3RoaXMuY2FudmFzPWNhbnZhczt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dD90aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIix7YWxwaGE6KHR5cGVvZiBpZD09PSdvYmplY3QnJiZpZC5hbHBoYT09PWZhbHNlKT9mYWxzZTp0cnVlfSk6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy5kYXRhPWRhdGE7dGhpcy50eXBlPSdoYmFyJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3JkczI9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5tYXg9MDt0aGlzLnN0YWNrZWRPckdyb3VwZWQ9ZmFsc2U7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuZ3V0dGVyLmxlZnQnOjc1LCdjaGFydC5ndXR0ZXIubGVmdC5hdXRvc2l6ZSc6ZmFsc2UsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOicjZGRkJywnY2hhcnQuYmFja2dyb3VuZC5ncmlkLndpZHRoJzoxLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnOjI1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudnNpemUnOjI1LCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYm9yZGVyJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdCc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQuYWxpZ24nOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJzo1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGFzaGVkJzpmYWxzZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRvdHRlZCc6ZmFsc2UsJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOm51bGwsJ2NoYXJ0LmxpbmV3aWR0aCc6MSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC50aXRsZS54YXhpcyc6JycsJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzJzonJywnY2hhcnQudGl0bGUueWF4aXMuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUueWF4aXMuc2l6ZSc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMuY29sb3InOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLnBvcyc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMucG9zJzowLjgsJ2NoYXJ0LnRpdGxlLnlheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzpudWxsLCdjaGFydC50aXRsZS5ocG9zJzpudWxsLCdjaGFydC50aXRsZS52cG9zJzpudWxsLCdjaGFydC50aXRsZS5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS5mb250JzpudWxsLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmNvbG9ycyc6WydyZWQnLCdibHVlJywnZ3JlZW4nLCdwaW5rJywneWVsbG93JywnY3lhbicsJ25hdnknLCdncmF5JywnYmxhY2snXSwnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnOmZhbHNlLCdjaGFydC54bGFiZWxzLnNwZWNpZmljJzpudWxsLCdjaGFydC5sYWJlbHMnOltdLCdjaGFydC5sYWJlbHMuYm9sZCc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmFib3ZlJzpmYWxzZSwnY2hhcnQubGFiZWxzLmFib3ZlLmRlY2ltYWxzJzowLCdjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSc6JycsJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wb3N0JzonJywnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZS5zaXplJzpudWxsLCdjaGFydC5sYWJlbHMuYWJvdmUuYm9sZCc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5hYm92ZS5pdGFsaWMnOmZhbHNlLCdjaGFydC5sYWJlbHMub2Zmc2V0eCc6MCwnY2hhcnQubGFiZWxzLm9mZnNldHknOjAsJ2NoYXJ0LnhsYWJlbHMub2Zmc2V0eCc6MCwnY2hhcnQueGxhYmVscy5vZmZzZXR5JzowLCdjaGFydC54bGFiZWxzJzp0cnVlLCdjaGFydC54bGFiZWxzLmNvdW50Jzo1LCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQua2V5JzpudWxsLCdjaGFydC5rZXkuYmFja2dyb3VuZCc6J3doaXRlJywnY2hhcnQua2V5LnBvc2l0aW9uJzonZ3JhcGgnLCdjaGFydC5rZXkuaGFsaWduJzoncmlnaHQnLCdjaGFydC5rZXkuc2hhZG93JzpmYWxzZSwnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6JyM2NjYnLCdjaGFydC5rZXkuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCc6MiwnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzoyLCdjaGFydC5rZXkucG9zaXRpb24uZ3V0dGVyLmJveGVkJzpmYWxzZSwnY2hhcnQua2V5LnBvc2l0aW9uLngnOm51bGwsJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzpudWxsLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkucm91bmRlZCc6dHJ1ZSwnY2hhcnQua2V5LmxpbmV3aWR0aCc6MSwnY2hhcnQua2V5LmNvbG9ycyc6bnVsbCwnY2hhcnQua2V5LmludGVyYWN0aXZlJzpmYWxzZSwnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOidibGFjaycsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOidyZ2JhKDI1NSwwLDAsMC4yKScsJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQudW5pdHMuaW5ncmFwaCc6ZmFsc2UsJ2NoYXJ0LnN0cm9rZXN0eWxlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LnhtaW4nOjAsJ2NoYXJ0LnhtYXgnOjAsJ2NoYXJ0LmF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6JyM2NjYnLCdjaGFydC5zaGFkb3cuYmx1cic6MywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzozLCdjaGFydC52bWFyZ2luJzoyLCdjaGFydC52bWFyZ2luLmdyb3VwZWQnOjIsJ2NoYXJ0Lmdyb3VwaW5nJzonZ3JvdXBlZCcsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuc3R5bGUnOm51bGwsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC5zY2FsZS5kZWNpbWFscyc6bnVsbCwnY2hhcnQuc2NhbGUuemVyb3N0YXJ0Jzp0cnVlLCdjaGFydC5ub3JlZHJhdyc6ZmFsc2UsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQubm94YXhpcyc6ZmFsc2UsJ2NoYXJ0Lm5veWF4aXMnOmZhbHNlLCdjaGFydC5ub2F4ZXMnOmZhbHNlLCdjaGFydC5ub3h0aWNrbWFya3MnOmZhbHNlLCdjaGFydC5ub3l0aWNrbWFya3MnOmZhbHNlLCdjaGFydC5udW15dGlja3MnOmRhdGEubGVuZ3RoLCdjaGFydC5udW14dGlja3MnOjEwLCdjaGFydC52YXJpYW50JzonaGJhcicsJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJzowLjEsJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnOjEwLCdjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5Jzo1LCdjaGFydC52YXJpYW50LnRocmVlZC54YXhpcyc6dHJ1ZSwnY2hhcnQudmFyaWFudC50aHJlZWQueWF4aXMnOnRydWUsJ2NoYXJ0LnlheGlzcG9zJzonbGVmdCcsJ2NoYXJ0LnZhcmlhbnQnOidoYmFyJywnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuYWRqdXN0YWJsZS5vbmx5JzpudWxsfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW0hCQVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbmZvcihpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTxsZW47KytpKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldPT0nb2JqZWN0JyYmIVJHcmFwaC5pc051bGwodGhpcy5kYXRhW2ldKSl7dGhpcy5zdGFja2VkT3JHcm91cGVkPXRydWU7Zm9yKHZhciBqPTAsbGVuMj10aGlzLmRhdGFbaV0ubGVuZ3RoO2o8bGVuMjsrK2ope2lmKHR5cGVvZiB0aGlzLmRhdGFbaV1bal09PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldW2pdPXBhcnNlRmxvYXQodGhpcy5kYXRhW2ldW2pdKTt9fX1lbHNlIGlmKHR5cGVvZiB0aGlzLmRhdGFbaV09PSdzdHJpbmcnKXt0aGlzLmRhdGFbaV09cGFyc2VGbG9hdCh0aGlzLmRhdGFbaV0pfHwwO31lbHNlIGlmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0ndW5kZWZpbmVkJyl7dGhpcy5kYXRhW2ldPW51bGw7fX1cbnZhciBsaW5lYXJfZGF0YT1SR3JhcGguYXJyYXlMaW5lYXJpemUoZGF0YSk7Zm9yKHZhciBpPTAsbGVuPWxpbmVhcl9kYXRhLmxlbmd0aDtpPGxlbjsrK2kpe3RoaXNbJyQnK2ldPXt9O31cbnRoaXMuZGF0YV9hcnI9UkdyYXBoLmFycmF5TGluZWFyaXplKHRoaXMuZGF0YSk7aWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0LmxhYmVscy5hYm92ZWJhcicpe25hbWU9J2NoYXJ0LmxhYmVscy5hYm92ZSc7fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC5sYWJlbHMuYWJvdmViYXInKXtuYW1lPSdjaGFydC5sYWJlbHMuYWJvdmUnO31cbnJldHVybiBwcm9wW25hbWVdO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdzdGFja2VkJyl7YWxlcnQoJ1tSR1JBUEhdIFRoZSBIQmFyIGRvZXMgbm90IHN1cHBvcnQgc3RhY2tlZCBjaGFydHMgd2l0aCBhZGp1c3RpbmcnKTt9XG5pZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtpZihwcm9wWydjaGFydC50ZXh0LmFjY2Vzc2libGUnXSl7fWVsc2V7Y28uc2V0VHJhbnNmb3JtKDEscHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSwwLDEsMC41LDAuNSk7fVxuaWYocHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddPT09MjUpe3RoaXMuc2V0KCdndXR0ZXJCb3R0b20nLDgwKTt9fVxuaWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG5pZihwcm9wWydjaGFydC5ndXR0ZXIubGVmdC5hdXRvc2l6ZSddKXt2YXIgbGVuPTA7dmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXTt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7aSs9MSl7dmFyIGxlbmd0aD1SRy5tZWFzdXJlVGV4dChsYWJlbHNbaV0sZmFsc2UsZm9udCxzaXplKVswXXx8MFxubGVuPW1hLm1heChsZW4sbGVuZ3RoKTt9XG5wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddPWxlbisxMDt9XG50aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO3RoaXMuY29vcmRzVGV4dD1bXTt0aGlzLm1heD0wO2lmKHByb3BbJ2NoYXJ0LnhtaW4nXT4wJiZwcm9wWydjaGFydC5ncm91cGluZyddPT0nc3RhY2tlZCcpe2FsZXJ0KCdbSEJBUl0gVXNpbmcgY2hhcnQueG1pbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGggc3RhY2tlZCBjaGFydHMsIHJlc2V0dGluZyBjaGFydC54bWluIHRvIHplcm8nKTt0aGlzLlNldCgnY2hhcnQueG1pbicsMCk7fVxudGhpcy5ncmFwaHdpZHRoPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhoZWlnaHQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tO3RoaXMuaGFsZmdyYXBoYXJlYT10aGlzLmdyYXBoYXJlYS8yO3RoaXMuaGFsZlRleHRIZWlnaHQ9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10vMjt0aGlzLmhhbGZ3YXk9bWEucm91bmQoKHRoaXMuZ3JhcGh3aWR0aC8yKSt0aGlzLmd1dHRlckxlZnQpXG5SRy5CYWNrZ3JvdW5kLmRyYXcodGhpcyk7dGhpcy5kcmF3YmFycygpO3RoaXMuZHJhd0F4ZXMoKTt0aGlzLmRyYXdMYWJlbHMoKTtpZihwcm9wWydjaGFydC5rZXknXSYmcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoKXtSRy5EcmF3S2V5KHRoaXMscHJvcFsnY2hhcnQua2V5J10scHJvcFsnY2hhcnQuY29sb3JzJ10pO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cblJHLkRyYXdJbkdyYXBoTGFiZWxzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0F4ZXM9dGhpcy5EcmF3QXhlcz1mdW5jdGlvbigpXG57dmFyIGhhbGZ3YXk9dGhpcy5oYWxmd2F5XG5jby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXT9wcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddKzAuMDAxOjEuMDAxO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXTtpZihwcm9wWydjaGFydC5ub3lheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5ub2F4ZXMnXT09ZmFsc2Upe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdjZW50ZXInKXtjby5tb3ZlVG8oaGFsZndheSx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGhhbGZ3YXksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTt9ZWxzZSBpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnKXtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTt9ZWxzZXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7fX1cbmlmKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXT09ZmFsc2UmJnByb3BbJ2NoYXJ0Lm5vYXhlcyddPT1mYWxzZSl7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCswLjAwMSxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rMC4wMDEpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzAuMDAxLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSswLjAwMSk7fVxuaWYocHJvcFsnY2hhcnQubm95dGlja21hcmtzJ109PWZhbHNlJiZwcm9wWydjaGFydC5ub3lheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW15dGlja3MnXT4wJiZwcm9wWydjaGFydC5ub2F4ZXMnXT09ZmFsc2Upe3ZhciB5VGlja0dhcD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8ocHJvcFsnY2hhcnQubnVteXRpY2tzJ10+MD9wcm9wWydjaGFydC5udW15dGlja3MnXTp0aGlzLmRhdGEubGVuZ3RoKTtmb3IoeT10aGlzLmd1dHRlclRvcDt5PChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20tMSk7eSs9eVRpY2tHYXApe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdjZW50ZXInKXtjby5tb3ZlVG8oaGFsZndheSszLG1hLnJvdW5kKHkpKTtjby5saW5lVG8oaGFsZndheS0zLG1hLnJvdW5kKHkpKTt9ZWxzZSBpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnKXtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCxtYS5yb3VuZCh5KSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrMyxtYS5yb3VuZCh5KSk7fWVsc2V7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCxtYS5yb3VuZCh5KSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdC0zLG1hLnJvdW5kKHkpKTt9fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddPT10cnVlKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nY2VudGVyJyl7Y28ubW92ZVRvKGhhbGZ3YXkrMyxtYS5yb3VuZCh5KSk7Y28ubGluZVRvKGhhbGZ3YXktMyxtYS5yb3VuZCh5KSk7fWVsc2UgaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jyl7Y28ubW92ZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsbWEucm91bmQoeSkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzMsbWEucm91bmQoeSkpO31lbHNle2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQtMyxtYS5yb3VuZCh5KSk7fX19XG5pZihwcm9wWydjaGFydC5ub3h0aWNrbWFya3MnXT09ZmFsc2UmJnByb3BbJ2NoYXJ0Lm5veGF4aXMnXT09ZmFsc2UmJnByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPjAmJnByb3BbJ2NoYXJ0Lm5vYXhlcyddPT1mYWxzZSl7eFRpY2tHYXA9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS9wcm9wWydjaGFydC5udW14dGlja3MnXTt5U3RhcnQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tO3lFbmQ9KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkrMzt2YXIgaT1wcm9wWydjaGFydC5udW14dGlja3MnXVxud2hpbGUoaS0tKXt2YXIgeD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LShpKnhUaWNrR2FwKTtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT09J3JpZ2h0Jyl7eC09eFRpY2tHYXA7fVxuY28ubW92ZVRvKG1hLnJvdW5kKHgpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHlFbmQpO31cbmlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0nY2VudGVyJyl7dmFyIGk9NTt3aGlsZShpLS0pe3ZhciB4PXRoaXMuZ3V0dGVyTGVmdCsoeFRpY2tHYXAqaSk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHlFbmQpO319XG5pZihwcm9wWydjaGFydC5ub3lheGlzJ109PXRydWUpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoeVN0YXJ0KSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCxtYS5yb3VuZCh5RW5kKSk7fX1cbmNvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aD0xO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXSx1bml0c19wb3N0PXByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSx0ZXh0X3NpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSxvZmZzZXR4PXByb3BbJ2NoYXJ0LnhsYWJlbHMub2Zmc2V0eCddLG9mZnNldHk9cHJvcFsnY2hhcnQueGxhYmVscy5vZmZzZXR5J11cbmlmKHByb3BbJ2NoYXJ0LnVuaXRzLmluZ3JhcGgnXSl7dW5pdHNfcHJlPScnO3VuaXRzX3Bvc3Q9Jyc7fVxuaWYocHJvcFsnY2hhcnQueGxhYmVscyddKXtpZihSRy5pc0FycmF5KHByb3BbJ2NoYXJ0LnhsYWJlbHMuc3BlY2lmaWMnXSkpe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdjZW50ZXInKXt2YXIgaGFsZkdyYXBoV2lkdGg9dGhpcy5ncmFwaHdpZHRoLzI7dmFyIGxhYmVscz1wcm9wWydjaGFydC54bGFiZWxzLnNwZWNpZmljJ107dmFyIGludGVydmFsPSh0aGlzLmdyYXBod2lkdGgvMikvKGxhYmVscy5sZW5ndGgtMSk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7aSs9MSl7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6dGhpcy5ndXR0ZXJMZWZ0K2hhbGZHcmFwaFdpZHRoKyhpbnRlcnZhbCppKStvZmZzZXR4LCd5JzpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rb2Zmc2V0eCwndGV4dCc6bGFiZWxzW2ldLCd2YWxpZ24nOid0b3AnLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9XG5mb3IodmFyIGk9KGxhYmVscy5sZW5ndGgtMSk7aT4wO2ktPTEpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnRoaXMuZ3V0dGVyTGVmdCsoaW50ZXJ2YWwqKGxhYmVscy5sZW5ndGgtaS0xKSkrb2Zmc2V0eCwneSc6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHksJ3RleHQnOmxhYmVsc1tpXSwndmFsaWduJzondG9wJywnaGFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7fX1lbHNlIGlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdyaWdodCcpe3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQueGxhYmVscy5zcGVjaWZpYyddO3ZhciBpbnRlcnZhbD10aGlzLmdyYXBod2lkdGgvKGxhYmVscy5sZW5ndGgtMSk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7aSs9MSl7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6dGhpcy5ndXR0ZXJMZWZ0KyhpbnRlcnZhbCppKStvZmZzZXR4LCd5JzpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rb2Zmc2V0eSwndGV4dCc6bGFiZWxzW2xhYmVscy5sZW5ndGgtaS0xXSwndmFsaWduJzondG9wJywnaGFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7fX1lbHNle3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQueGxhYmVscy5zcGVjaWZpYyddO3ZhciBpbnRlcnZhbD10aGlzLmdyYXBod2lkdGgvKGxhYmVscy5sZW5ndGgtMSk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7aSs9MSl7UkcudGV4dDIodGhpcyx7Zm9udDpmb250LHNpemU6dGV4dF9zaXplLHg6dGhpcy5ndXR0ZXJMZWZ0KyhpbnRlcnZhbCppKStvZmZzZXR4LHk6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHksdGV4dDpsYWJlbHNbaV0sdmFsaWduOid0b3AnLGhhbGlnbjonY2VudGVyJyx0YWc6J3NjYWxlJ30pO319fWVsc2V7dmFyIGdhcD03O2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2NlbnRlcicpe2Zvcih2YXIgaT0wO2k8dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsrK2kpe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnRoaXMuZ3V0dGVyTGVmdCsodGhpcy5ncmFwaHdpZHRoLzIpLSgodGhpcy5ncmFwaHdpZHRoLzIpKigoaSsxKS90aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSkrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmVGV4dEhlaWdodCt0aGlzLmdyYXBoaGVpZ2h0K2dhcCtvZmZzZXR5LCd0ZXh0JzonLScrdGhpcy5zY2FsZTIubGFiZWxzW2ldLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrKCh0aGlzLmdyYXBod2lkdGgvMikqKChpKzEpL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpKSsodGhpcy5ncmFwaHdpZHRoLzIpK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZlRleHRIZWlnaHQrdGhpcy5ncmFwaGhlaWdodCtnYXArb2Zmc2V0eSwndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW2ldLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9fWVsc2UgaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jyl7Zm9yKHZhciBpPTAsbGVuPXRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7aTxsZW47KytpKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrKGkqKHRoaXMuZ3JhcGh3aWR0aC9sZW4pKStvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZUZXh0SGVpZ2h0K3RoaXMuZ3JhcGhoZWlnaHQrZ2FwK29mZnNldHksJ3RleHQnOictJyt0aGlzLnNjYWxlMi5sYWJlbHNbbGVuLTEtaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO319ZWxzZXtmb3IodmFyIGk9MCxsZW49dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDtpPGxlbjsrK2kpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnRoaXMuZ3V0dGVyTGVmdCsodGhpcy5ncmFwaHdpZHRoKigoaSsxKS9sZW4pKStvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZUZXh0SGVpZ2h0K3RoaXMuZ3JhcGhoZWlnaHQrZ2FwK29mZnNldHksJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7fX1cbmlmKHByb3BbJ2NoYXJ0LnhtaW4nXT4wfHxwcm9wWydjaGFydC5ub3lheGlzJ109PXRydWV8fHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddfHxwcm9wWydjaGFydC5ub2F4ZXMnXSl7dmFyIHg9cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2NlbnRlcic/dGhpcy5ndXR0ZXJMZWZ0Kyh0aGlzLmdyYXBod2lkdGgvMik6dGhpcy5ndXR0ZXJMZWZ0O2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0ncmlnaHQnKXt2YXIgeD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0O31cblJHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOngrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmVGV4dEhlaWdodCt0aGlzLmdyYXBoaGVpZ2h0K2dhcCtvZmZzZXR5LCd0ZXh0JzpSRy5udW1iZXJGb3JtYXQodGhpcyxwcm9wWydjaGFydC54bWluJ10udG9GaXhlZChwcm9wWydjaGFydC54bWluJ109PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidzY2FsZSd9KTt9XG5jby5maWxsKCk7Y28uc3Ryb2tlKCk7fX1cbmlmKHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMnXT09J29iamVjdCcpe3ZhciB4T2Zmc2V0PXByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcmJnByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0ncmlnaHQnPzE1OjUsZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSxjb2xvcj1wcm9wWydjaGFydC5sYWJlbHMuY29sb3InXXx8cHJvcFsnY2hhcnQudGV4dC5jb2xvciddLGJvbGQ9cHJvcFsnY2hhcnQubGFiZWxzLmJvbGQnXSxvZmZzZXR4PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddXG5jby5maWxsU3R5bGU9Y29sb3I7dmFyIGJhckhlaWdodD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS9wcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg7eVRpY2tHYXA9KGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoXG5pZihwcm9wWydjaGFydC55YXhpc3BvcyddPT09J3JpZ2h0Jyl7dmFyIHg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCt4T2Zmc2V0O3ZhciBoYWxpZ249J2xlZnQnfWVsc2V7dmFyIHg9dGhpcy5ndXR0ZXJMZWZ0LXhPZmZzZXQ7dmFyIGhhbGlnbj0ncmlnaHQnfVxudmFyIGk9MDtmb3IoeT10aGlzLmd1dHRlclRvcCsoeVRpY2tHYXAvMik7eTw9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tO3krPXlUaWNrR2FwKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sJ2JvbGQnOmJvbGQsJ3gnOngrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzpTdHJpbmcocHJvcFsnY2hhcnQubGFiZWxzJ11baSsrXSksJ2hhbGlnbic6aGFsaWduLCd2YWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMnfSk7fX19O3RoaXMuZHJhd2JhcnM9dGhpcy5EcmF3YmFycz1mdW5jdGlvbigpXG57Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO3ZhciBwcmV2WD0wLHByZXZZPTA7aWYocHJvcFsnY2hhcnQueG1heCddKXt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6cHJvcFsnY2hhcnQueG1heCddLCdtaW4nOnByb3BbJ2NoYXJ0LnhtaW4nXSwnc2NhbGUuZGVjaW1hbHMnOk51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLnRob3VzYW5kJzpwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCdzY2FsZS5yb3VuZCc6cHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwndW5pdHMucHJlJzpwcm9wWydjaGFydC51bml0cy5wcmUnXSwndW5pdHMucG9zdCc6cHJvcFsnY2hhcnQudW5pdHMucG9zdCddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC54bGFiZWxzLmNvdW50J10sJ3N0cmljdCc6dHJ1ZX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt9ZWxzZXt2YXIgZ3JvdXBpbmc9cHJvcFsnY2hhcnQuZ3JvdXBpbmcnXTtmb3IoaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZih0aGlzLmRhdGFbaV0pPT0nb2JqZWN0Jyl7dmFyIHZhbHVlPWdyb3VwaW5nPT0nZ3JvdXBlZCc/TnVtYmVyKFJHLmFycmF5X21heCh0aGlzLmRhdGFbaV0sdHJ1ZSkpOk51bWJlcihSRy5hcnJheV9zdW0odGhpcy5kYXRhW2ldKSk7fWVsc2V7dmFyIHZhbHVlPU51bWJlcihtYS5hYnModGhpcy5kYXRhW2ldKSk7fVxudGhpcy5tYXg9bWEubWF4KE1hdGguYWJzKHRoaXMubWF4KSxNYXRoLmFicyh2YWx1ZSkpO31cbnRoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp0aGlzLm1heCwnbWluJzpwcm9wWydjaGFydC54bWluJ10sJ3NjYWxlLmRlY2ltYWxzJzpOdW1iZXIocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksJ3NjYWxlLnBvaW50Jzpwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwneWxhYmVscy5jb3VudCc6cHJvcFsnY2hhcnQueGxhYmVscy5jb3VudCddfSk7dGhpcy5tYXg9dGhpcy5zY2FsZTIubWF4O3RoaXMubWluPXRoaXMuc2NhbGUyLm1pbjt9XG5pZihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddPT1udWxsJiZOdW1iZXIodGhpcy5tYXgpPT0xKXt0aGlzLlNldCgnY2hhcnQuc2NhbGUuZGVjaW1hbHMnLDEpO31cbnZhciBjb2xvcklkeD0wO3RoaXMubnVtYmFycz1SRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLmxlbmd0aDtpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJiFwcm9wWydjaGFydC54bWF4J10pe3RoaXMuc2V0KCdjaGFydC54bWF4Jyx0aGlzLnNjYWxlMi5tYXgpO31cbmlmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcpe1JHLmRyYXczREF4ZXModGhpcyk7fVxudmFyIGdyYXBod2lkdGg9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KTt2YXIgaGFsZndpZHRoPWdyYXBod2lkdGgvMjtmb3IoaT0obGVuPXRoaXMuZGF0YS5sZW5ndGgtMSk7aT49MDstLWkpe3ZhciB3aWR0aD1tYS5hYnMoKHRoaXMuZGF0YVtpXS90aGlzLm1heCkqZ3JhcGh3aWR0aCk7dmFyIGhlaWdodD10aGlzLmdyYXBoaGVpZ2h0L3RoaXMuZGF0YS5sZW5ndGg7dmFyIG9yaWdfaGVpZ2h0PWhlaWdodDt2YXIgeD10aGlzLmd1dHRlckxlZnQ7dmFyIHk9dGhpcy5ndXR0ZXJUb3ArKGkqaGVpZ2h0KTt2YXIgdm1hcmdpbj1wcm9wWydjaGFydC52bWFyZ2luJ107aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdyaWdodCcpe3g9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC1tYS5hYnMod2lkdGgpO31cbmlmKHdpZHRoPDApe3gtPXdpZHRoO3dpZHRoPW1hLmFicyh3aWR0aCk7fVxuaWYocHJvcFsnY2hhcnQuc2hhZG93J10pe2NvLnNoYWRvd0NvbG9yPXByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddO2NvLnNoYWRvd0JsdXI9cHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYPXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J107Y28uc2hhZG93T2Zmc2V0WT1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO31cbmNvLmJlZ2luUGF0aCgpO2lmKHR5cGVvZiB0aGlzLmRhdGFbaV09PSdudW1iZXInfHxSRy5pc051bGwodGhpcy5kYXRhW2ldKSl7dmFyIGJhckhlaWdodD1oZWlnaHQtKDIqdm1hcmdpbiksYmFyV2lkdGg9KCh0aGlzLmRhdGFbaV0tcHJvcFsnY2hhcnQueG1pbiddKS8odGhpcy5tYXgtcHJvcFsnY2hhcnQueG1pbiddKSkqdGhpcy5ncmFwaHdpZHRoLGJhclg9dGhpcy5ndXR0ZXJMZWZ0O2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdjZW50ZXInKXtiYXJXaWR0aC89MjtiYXJYKz1oYWxmd2lkdGg7aWYodGhpcy5kYXRhW2ldPDApe2JhcldpZHRoPShtYS5hYnModGhpcy5kYXRhW2ldKS1wcm9wWydjaGFydC54bWluJ10pLyh0aGlzLm1heC1wcm9wWydjaGFydC54bWluJ10pO2JhcldpZHRoPWJhcldpZHRoKih0aGlzLmdyYXBod2lkdGgvMik7YmFyWD0oKHRoaXMuZ3JhcGh3aWR0aC8yKSt0aGlzLmd1dHRlckxlZnQpLWJhcldpZHRoO319ZWxzZSBpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnKXtiYXJXaWR0aD1tYS5hYnMoYmFyV2lkdGgpO2Jhclg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC1iYXJXaWR0aDt9XG5jby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTsrK2NvbG9ySWR4O2lmKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10mJnR5cGVvZiBjb2xvcklkeD09PSdudW1iZXInKXtpZihwcm9wWydjaGFydC5jb2xvcnMnXVt0aGlzLm51bWJhcnMtY29sb3JJZHhdKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzLWNvbG9ySWR4XTt9ZWxzZXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bcHJvcFsnY2hhcnQuY29sb3JzJ10ubGVuZ3RoLTFdO319XG5jby5zdHJva2VSZWN0KGJhclgsdGhpcy5ndXR0ZXJUb3ArKGkqaGVpZ2h0KStwcm9wWydjaGFydC52bWFyZ2luJ10sYmFyV2lkdGgsYmFySGVpZ2h0KTtjby5maWxsUmVjdChiYXJYLHRoaXMuZ3V0dGVyVG9wKyhpKmhlaWdodCkrcHJvcFsnY2hhcnQudm1hcmdpbiddLGJhcldpZHRoLGJhckhlaWdodCk7dGhpcy5jb29yZHMucHVzaChbYmFyWCx5K3ZtYXJnaW4sYmFyV2lkdGgsaGVpZ2h0LSgyKnZtYXJnaW4pLGNvLmZpbGxTdHlsZSx0aGlzLmRhdGFbaV0sdHJ1ZV0pO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09PSczZCcmJnR5cGVvZiB0aGlzLmRhdGFbaV09PSdudW1iZXInKXt2YXIgcHJldlN0cm9rZVN0eWxlPWNvLnN0cm9rZVN0eWxlLHByZXZGaWxsU3R5bGU9Y28uZmlsbFN0eWxlO1JHLm5vU2hhZG93KHRoaXMpO3ZhciBiYXJYPWJhclgsYmFyWT15K3ZtYXJnaW4sYmFyVz1iYXJXaWR0aCxiYXJIPWhlaWdodC0oMip2bWFyZ2luKSxvZmZzZXRYPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxvZmZzZXRZPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSx2YWx1ZT10aGlzLmRhdGFbaV07cGEyKGNvLFsnYicsJ20nLGJhclgsYmFyWSwnbCcsYmFyWCtvZmZzZXRYLShwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcmJnZhbHVlPDA/b2Zmc2V0WDowKSxiYXJZLW9mZnNldFksJ2wnLGJhclgrYmFyVytvZmZzZXRYLShwcm9wWydjaGFydC55YXhpc3BvcyddPT0nY2VudGVyJyYmdmFsdWU8MD9vZmZzZXRYOjApLGJhclktb2Zmc2V0WSwnbCcsYmFyWCtiYXJXLGJhclksJ2MnLCdzJyxjby5zdHJva2VTdHlsZSwnZicsY28uZmlsbFN0eWxlLCdmJywncmdiYSgyNTUsMjU1LDI1NSwwLjYpJ10pO2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10hPT0ncmlnaHQnJiYhKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0nY2VudGVyJyYmdmFsdWU8MCkmJnZhbHVlPj0wJiYhUkcuaXNOdWxsKHZhbHVlKSl7cGEyKGNvLFsnYicsJ2ZzJyxwcmV2RmlsbFN0eWxlLCdtJyxiYXJYK2JhclcsYmFyWSwnbCcsYmFyWCtiYXJXK29mZnNldFgsYmFyWS1vZmZzZXRZLCdsJyxiYXJYK2Jhclcrb2Zmc2V0WCxiYXJZLW9mZnNldFkrYmFySCwnbCcsYmFyWCtiYXJXLGJhclkrYmFySCwnYycsJ3MnLGNvLnN0cm9rZVN0eWxlLCdmJyxwcmV2RmlsbFN0eWxlLCdmJywncmdiYSgwLDAsMCwwLjI1KSddKTt9fX1lbHNlIGlmKHR5cGVvZih0aGlzLmRhdGFbaV0pPT0nb2JqZWN0JyYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09J3N0YWNrZWQnKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nY2VudGVyJyl7YWxlcnQoJ1tIQkFSXSBZb3UgY2FuXFwndCBoYXZlIGEgc3RhY2tlZCBjaGFydCB3aXRoIHRoZSBZIGF4aXMgaW4gdGhlIGNlbnRlciwgY2hhbmdlIGl0IHRvIGdyb3VwZWQnKTt9ZWxzZSBpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnKXt2YXIgeD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0fVxudmFyIGJhckhlaWdodD1oZWlnaHQtKDIqdm1hcmdpbik7aWYodHlwZW9mIHRoaXMuY29vcmRzMltpXT09J3VuZGVmaW5lZCcpe3RoaXMuY29vcmRzMltpXT1bXTt9XG5mb3Ioaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2ope2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddJiZwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtjby5zaGFkb3dDb2xvcj1wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyPXByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFk9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTt9XG5pZighUkcuaXNOdWxsKHRoaXMuZGF0YVtpXVtqXSkpdGhpcy5kYXRhW2ldW2pdPW1hLmFicyh0aGlzLmRhdGFbaV1bal0pO3ZhciBsYXN0PShqPT09KHRoaXMuZGF0YVtpXS5sZW5ndGgtMSkpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Kytjb2xvcklkeDtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddJiZ0eXBlb2YgY29sb3JJZHg9PT0nbnVtYmVyJyl7aWYocHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzLWNvbG9ySWR4XSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW3RoaXMubnVtYmFycy1jb2xvcklkeF07fWVsc2V7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW3Byb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aC0xXTt9fWVsc2UgaWYocHJvcFsnY2hhcnQuY29sb3JzJ11bal0pe2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtqXTt9XG52YXIgd2lkdGg9KCgodGhpcy5kYXRhW2ldW2pdKS8odGhpcy5tYXgpKSkqdGhpcy5ncmFwaHdpZHRoO3ZhciB0b3RhbFdpZHRoPShSRy5hcnJheVN1bSh0aGlzLmRhdGFbaV0pL3RoaXMubWF4KSp0aGlzLmdyYXBod2lkdGg7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdyaWdodCcpe3gtPXdpZHRoO31cbmNvLnN0cm9rZVJlY3QoeCx0aGlzLmd1dHRlclRvcCtwcm9wWydjaGFydC52bWFyZ2luJ10rKHRoaXMuZ3JhcGhoZWlnaHQvdGhpcy5kYXRhLmxlbmd0aCkqaSx3aWR0aCxoZWlnaHQtKDIqdm1hcmdpbikpO2NvLmZpbGxSZWN0KHgsdGhpcy5ndXR0ZXJUb3ArcHJvcFsnY2hhcnQudm1hcmdpbiddKyh0aGlzLmdyYXBoaGVpZ2h0L3RoaXMuZGF0YS5sZW5ndGgpKmksd2lkdGgsaGVpZ2h0LSgyKnZtYXJnaW4pKTt0aGlzLmNvb3Jkcy5wdXNoKFt4LHkrdm1hcmdpbix3aWR0aCxoZWlnaHQtKDIqdm1hcmdpbiksY28uZmlsbFN0eWxlLFJHLmFycmF5X3N1bSh0aGlzLmRhdGFbaV0pLGo9PSh0aGlzLmRhdGFbaV0ubGVuZ3RoLTEpXSk7dGhpcy5jb29yZHMyW2ldLnB1c2goW3gseSt2bWFyZ2luLHdpZHRoLGhlaWdodC0oMip2bWFyZ2luKSxjby5maWxsU3R5bGUsUkcuYXJyYXlfc3VtKHRoaXMuZGF0YVtpXSksaj09KHRoaXMuZGF0YVtpXS5sZW5ndGgtMSldKTtpZihwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtSRy5ub1NoYWRvdyh0aGlzKTt2YXIgcHJldlN0cm9rZVN0eWxlPWNvLnN0cm9rZVN0eWxlLHByZXZGaWxsU3R5bGU9Y28uZmlsbFN0eWxlO3ZhciBiYXJYPXgsYmFyWT15K3ZtYXJnaW4sYmFyVz13aWR0aCxiYXJIPWhlaWdodC0oMip2bWFyZ2luKSxvZmZzZXRYPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxvZmZzZXRZPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSx2YWx1ZT10aGlzLmRhdGFbaV1bal07aWYoIVJHLmlzTnVsbCh2YWx1ZSkpe3BhMihjbyxbJ2InLCdtJyxiYXJYLGJhclksJ2wnLGJhclgrb2Zmc2V0WCxiYXJZLW9mZnNldFksJ2wnLGJhclgrYmFyVytvZmZzZXRYLGJhclktb2Zmc2V0WSwnbCcsYmFyWCtiYXJXLGJhclksJ2MnLCdzJyxjby5zdHJva2VTdHlsZSwnZicsY28uZmlsbFN0eWxlLCdmJywncmdiYSgyNTUsMjU1LDI1NSwwLjYpJ10pO31cbmlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10hPT0ncmlnaHQnJiYhKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0nY2VudGVyJyYmdmFsdWU8MCkmJiFSRy5pc051bGwodmFsdWUpKXtwYTIoY28sWydmcycscHJldkZpbGxTdHlsZSwnYicsJ20nLGJhclgrYmFyVyxiYXJZLCdsJyxiYXJYK2Jhclcrb2Zmc2V0WCxiYXJZLW9mZnNldFksJ2wnLGJhclgrYmFyVytvZmZzZXRYLGJhclktb2Zmc2V0WStiYXJILCdsJyxiYXJYK2JhclcsYmFyWStiYXJILCdjJywncycsY28uc3Ryb2tlU3R5bGUsJ2YnLHByZXZGaWxsU3R5bGUsJ2YnLCdyZ2JhKDAsMCwwLDAuMjUpJ10pO31cbmNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByZXZTdHJva2VTdHlsZTtjby5maWxsU3R5bGU9cHJldkZpbGxTdHlsZTt9XG5pZihwcm9wWydjaGFydC55YXhpc3BvcyddIT09J3JpZ2h0Jyl7eCs9d2lkdGg7fX19ZWxzZSBpZih0eXBlb2YodGhpcy5kYXRhW2ldKT09J29iamVjdCcmJnByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ109PSdncm91cGVkJyl7dmFyIHZtYXJnaW5Hcm91cGVkPXByb3BbJ2NoYXJ0LnZtYXJnaW4uZ3JvdXBlZCddO3ZhciBpbmRpdmlkdWFsQmFySGVpZ2h0PSgoaGVpZ2h0LSgyKnZtYXJnaW4pLSgodGhpcy5kYXRhW2ldLmxlbmd0aC0xKSp2bWFyZ2luR3JvdXBlZCkpL3RoaXMuZGF0YVtpXS5sZW5ndGgpXG5pZih0eXBlb2YgdGhpcy5jb29yZHMyW2ldPT0ndW5kZWZpbmVkJyl7dGhpcy5jb29yZHMyW2ldPVtdO31cbmZvcihqPSh0aGlzLmRhdGFbaV0ubGVuZ3RoLTEpO2o+PTA7LS1qKXtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31cbmNvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Kytjb2xvcklkeDtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddJiZ0eXBlb2YgY29sb3JJZHg9PT0nbnVtYmVyJyl7aWYocHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzLWNvbG9ySWR4XSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW3RoaXMubnVtYmFycy1jb2xvcklkeF07fWVsc2V7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW3Byb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aC0xXTt9fWVsc2UgaWYocHJvcFsnY2hhcnQuY29sb3JzJ11bal0pe2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtqXTt9XG52YXIgc3RhcnRZPXRoaXMuZ3V0dGVyVG9wKyhoZWlnaHQqaSkrKGluZGl2aWR1YWxCYXJIZWlnaHQqaikrdm1hcmdpbisodm1hcmdpbkdyb3VwZWQqaik7dmFyIHdpZHRoPSgodGhpcy5kYXRhW2ldW2pdLXByb3BbJ2NoYXJ0LnhtaW4nXSkvKHRoaXMubWF4LXByb3BbJ2NoYXJ0LnhtaW4nXSkpKihjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCk7dmFyIHN0YXJ0WD10aGlzLmd1dHRlckxlZnQ7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2NlbnRlcicpe3dpZHRoLz0yO3N0YXJ0WCs9aGFsZndpZHRoO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdyaWdodCcpe3dpZHRoPW1hLmFicyh3aWR0aCk7c3RhcnRYPWNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQtbWEuYWJzKHdpZHRoKTs7fVxuaWYod2lkdGg8MCl7c3RhcnRYKz13aWR0aDt3aWR0aCo9LTE7fVxuY28uc3Ryb2tlUmVjdChzdGFydFgsc3RhcnRZLHdpZHRoLGluZGl2aWR1YWxCYXJIZWlnaHQpO2NvLmZpbGxSZWN0KHN0YXJ0WCxzdGFydFksd2lkdGgsaW5kaXZpZHVhbEJhckhlaWdodCk7dGhpcy5jb29yZHMucHVzaChbc3RhcnRYLHN0YXJ0WSx3aWR0aCxpbmRpdmlkdWFsQmFySGVpZ2h0LGNvLmZpbGxTdHlsZSx0aGlzLmRhdGFbaV1bal0sdHJ1ZV0pO3RoaXMuY29vcmRzMltpXS5wdXNoKFtzdGFydFgsc3RhcnRZLHdpZHRoLGluZGl2aWR1YWxCYXJIZWlnaHQsY28uZmlsbFN0eWxlLHRoaXMuZGF0YVtpXVtqXSx0cnVlXSk7aWYocHJvcFsnY2hhcnQudmFyaWFudCddPT09JzNkJyl7Ukcubm9TaGFkb3codGhpcyk7dmFyIHByZXZTdHJva2VTdHlsZT1jby5zdHJva2VTdHlsZSxwcmV2RmlsbFN0eWxlPWNvLmZpbGxTdHlsZTt2YXIgYmFyWD1zdGFydFgsYmFyWT1zdGFydFksYmFyVz13aWR0aCxiYXJIPWluZGl2aWR1YWxCYXJIZWlnaHQsb2Zmc2V0WD1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sb2Zmc2V0WT1wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10sdmFsdWU9dGhpcy5kYXRhW2ldW2pdO3BhMihjbyxbJ2InLCdtJyxiYXJYLGJhclksJ2wnLGJhclgrb2Zmc2V0WCxiYXJZLW9mZnNldFksJ2wnLGJhclgrYmFyVytvZmZzZXRYLSh2YWx1ZTwwP29mZnNldFg6MCksYmFyWS1vZmZzZXRZLCdsJyxiYXJYK2JhclcsYmFyWSwnYycsJ3MnLGNvLnN0cm9rZVN0eWxlLCdmJyxjby5maWxsU3R5bGUsJ2YnLCdyZ2JhKDI1NSwyNTUsMjU1LDAuNiknXSk7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXSE9PSdyaWdodCcmJiEocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdjZW50ZXInJiZ2YWx1ZTwwKSYmdmFsdWU+PTAmJiFSRy5pc051bGwodmFsdWUpKXtwYTIoY28sWydmcycscHJldkZpbGxTdHlsZSwnYicsJ20nLGJhclgrYmFyVyxiYXJZLCdsJyxiYXJYK2Jhclcrb2Zmc2V0WCxiYXJZLW9mZnNldFksJ2wnLGJhclgrYmFyVytvZmZzZXRYLGJhclktb2Zmc2V0WStiYXJILCdsJyxiYXJYK2JhclcsYmFyWStiYXJILCdjJywncycsY28uc3Ryb2tlU3R5bGUsJ2YnLHByZXZGaWxsU3R5bGUsJ2YnLCdyZ2JhKDAsMCwwLDAuMjUpJ10pO31cbmNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByZXZTdHJva2VTdHlsZTtjby5maWxsU3R5bGU9cHJldkZpbGxTdHlsZTt9fVxuc3RhcnRZKz12bWFyZ2luO31cbmNvLmNsb3NlUGF0aCgpO31cbmNvLnN0cm9rZSgpO2NvLmZpbGwoKTtpZihwcm9wWydjaGFydCx5YXhpc3BvcyddPT09J3JpZ2h0Jyl7cGEyKGNvLCdjciAlICUgJSAlJyxjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0K3Byb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSwnMCcsdGhpcy5ndXR0ZXJSaWdodCxjYS5oZWlnaHQpO31cbmlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0ncmlnaHQnJiZwcm9wWydjaGFydC52YXJpYW50J109PT0nM2QnKXtSRy5kcmF3M0RZQXhpcyh0aGlzKTt9XG5SRy5ub1NoYWRvdyh0aGlzKTt0aGlzLmNvb3Jkcz1SRy5hcnJheVJldmVyc2UodGhpcy5jb29yZHMpO2lmKHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ109PT0nZ3JvdXBlZCcpe2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMyLmxlbmd0aDsrK2kpe3RoaXMuY29vcmRzMltpXT1SRy5hcnJheVJldmVyc2UodGhpcy5jb29yZHMyW2ldKTt9fVxudGhpcy5yZWRyYXdCYXJzKCk7fTt0aGlzLnJlZHJhd0JhcnM9dGhpcy5SZWRyYXdCYXJzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5ub3JlZHJhdyddKXtyZXR1cm47fVxudmFyIGNvb3Jkcz10aGlzLmNvb3Jkczt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSxzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLGNvbG9yPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtSRy5ub1NoYWRvdyh0aGlzKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2Zvcih2YXIgaT0wO2k8Y29vcmRzLmxlbmd0aDsrK2kpe2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtwYTIoY28sJ2IgbHcgJSByICUgJSAlICUgcyAlIGYgJScscHJvcFsnY2hhcnQubGluZXdpZHRoJ10sY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSxjb29yZHNbaV1bMl0sY29vcmRzW2ldWzNdLHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10sY29vcmRzW2ldWzRdKTt9XG52YXIgaGFsaWduPSdsZWZ0JztpZihwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUnXSYmY29vcmRzW2ldWzZdKXt2YXIgYm9yZGVyPShjb29yZHNbaV1bMF0rY29vcmRzW2ldWzJdKzcrY28ubWVhc3VyZVRleHQocHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSddK3RoaXMuY29vcmRzW2ldWzVdK3Byb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wb3N0J10pLndpZHRoKT5jYS53aWR0aD90cnVlOmZhbHNlLHRleHQ9UkcubnVtYmVyRm9ybWF0KHRoaXMsKHRoaXMuY29vcmRzW2ldWzVdKS50b0ZpeGVkKHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5kZWNpbWFscyddKSxwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucHJlJ10scHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnXSk7Ukcubm9TaGFkb3codGhpcyk7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zcGVjaWZpYyddPT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zcGVjaWZpYyddJiZwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXVtpXSl7dGV4dD1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXVtpXTt9XG52YXIgeD1jb29yZHNbaV1bMF0rY29vcmRzW2ldWzJdKzU7dmFyIHk9Y29vcmRzW2ldWzFdKyhjb29yZHNbaV1bM10vMik7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdyaWdodCcpe3g9Y29vcmRzW2ldWzBdLTU7aGFsaWduPSdyaWdodCc7fWVsc2UgaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdjZW50ZXInJiZ0aGlzLmRhdGFfYXJyW2ldPDApe3g9Y29vcmRzW2ldWzBdLTU7aGFsaWduPSdyaWdodCc7fVxuUkcudGV4dDIodGhpcyx7Zm9udDp0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnXT09PSdzdHJpbmcnP3Byb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5mb250J106Zm9udCxzaXplOnR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSddPT09J251bWJlcic/cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnXTpzaXplLGNvbG9yOnR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuY29sb3InXT09PSdzdHJpbmcnP3Byb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvciddOmNvbG9yLHg6eCx5OnksYm9sZDpwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuYm9sZCddLGl0YWxpYzpwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuaXRhbGljJ10sdGV4dDp0ZXh0LHZhbGlnbjonY2VudGVyJyxoYWxpZ246aGFsaWduLHRhZzonbGFiZWxzLmFib3ZlJ30pO319fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0QmFyPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTtmb3IodmFyIGk9MCxsZW49dGhpcy5jb29yZHMubGVuZ3RoO2k8bGVuO2krKyl7dmFyIG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdLGxlZnQ9dGhpcy5jb29yZHNbaV1bMF0sdG9wPXRoaXMuY29vcmRzW2ldWzFdLHdpZHRoPXRoaXMuY29vcmRzW2ldWzJdLGhlaWdodD10aGlzLmNvb3Jkc1tpXVszXSxpZHg9aTtwYTIoY28sWydiJywncicsbGVmdCx0b3Asd2lkdGgsaGVpZ2h0XSk7aWYoY28uaXNQb2ludEluUGF0aChtb3VzZVgsbW91c2VZKSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO3JldHVybnswOnRoaXMsJ29iamVjdCc6dGhpcywxOmxlZnQsJ3gnOmxlZnQsMjp0b3AsJ3knOnRvcCwzOndpZHRoLCd3aWR0aCc6d2lkdGgsNDpoZWlnaHQsJ2hlaWdodCc6aGVpZ2h0LDU6aWR4LCdpbmRleCc6aWR4LCd0b29sdGlwJzp0b29sdGlwfTt9fX07dGhpcy5nZXRWYWx1ZT1mdW5jdGlvbihhcmcpXG57aWYoYXJnLmxlbmd0aD09Mil7dmFyIG1vdXNlWD1hcmdbMF07dmFyIG1vdXNlWT1hcmdbMV07fWVsc2V7dmFyIG1vdXNlQ29vcmRzPVJHLmdldE1vdXNlWFkoYXJnKTt2YXIgbW91c2VYPW1vdXNlQ29vcmRzWzBdO3ZhciBtb3VzZVk9bW91c2VDb29yZHNbMV07fVxuaWYobW91c2VZPHRoaXMuZ3V0dGVyVG9wfHxtb3VzZVk+KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSl8fG1vdXNlWDx0aGlzLmd1dHRlckxlZnR8fG1vdXNlWD4oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkpe3JldHVybiBudWxsO31cbmlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdjZW50ZXInKXt2YXIgdmFsdWU9KChtb3VzZVgtdGhpcy5ndXR0ZXJMZWZ0KS8odGhpcy5ncmFwaHdpZHRoLzIpKSoodGhpcy5tYXgtcHJvcFsnY2hhcnQueG1pbiddKTt2YWx1ZT12YWx1ZS10aGlzLm1heFxuaWYocHJvcFsnY2hhcnQueG1pbiddPjApe3ZhbHVlPSgobW91c2VYLXRoaXMuZ3V0dGVyTGVmdC0odGhpcy5ncmFwaHdpZHRoLzIpKS8odGhpcy5ncmFwaHdpZHRoLzIpKSoodGhpcy5tYXgtcHJvcFsnY2hhcnQueG1pbiddKTt2YWx1ZSs9cHJvcFsnY2hhcnQueG1pbiddO2lmKG1vdXNlWDwodGhpcy5ndXR0ZXJMZWZ0Kyh0aGlzLmdyYXBod2lkdGgvMikpKXt2YWx1ZS09KDIqcHJvcFsnY2hhcnQueG1pbiddKTt9fX1lbHNlIGlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdyaWdodCcpe3ZhciB2YWx1ZT0oKG1vdXNlWC10aGlzLmd1dHRlckxlZnQpL3RoaXMuZ3JhcGh3aWR0aCkqKHRoaXMuc2NhbGUyLm1heC1wcm9wWydjaGFydC54bWluJ10pO3ZhbHVlPXRoaXMuc2NhbGUyLm1heC12YWx1ZTt9ZWxzZXt2YXIgdmFsdWU9KChtb3VzZVgtdGhpcy5ndXR0ZXJMZWZ0KS90aGlzLmdyYXBod2lkdGgpKih0aGlzLnNjYWxlMi5tYXgtcHJvcFsnY2hhcnQueG1pbiddKTt2YWx1ZSs9cHJvcFsnY2hhcnQueG1pbiddO31cbnJldHVybiB2YWx1ZTt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle1JHLkhpZ2hsaWdodC5SZWN0KHRoaXMsc2hhcGUpO319O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7aWYocHJvcFsnY2hhcnQudmFyaWFudCddPT09JzNkJyl7dmFyIGFkanVzdG1lbnQ9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSptb3VzZVhZWzBdO21vdXNlWFlbMV0tPWFkanVzdG1lbnQ7fVxuaWYobW91c2VYWVswXT49dGhpcy5ndXR0ZXJMZWZ0JiZtb3VzZVhZWzBdPD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJm1vdXNlWFlbMV0+PXRoaXMuZ3V0dGVyVG9wJiZtb3VzZVhZWzFdPD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5nZXRYQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2NlbnRlcicpe2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTwoLTEqdGhpcy5tYXgpKXtyZXR1cm4gbnVsbDt9XG52YXIgd2lkdGg9KGNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10tcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pLzI7dmFyIGNvb3JkPSgoKHZhbHVlLXByb3BbJ2NoYXJ0LnhtaW4nXSkvKHRoaXMubWF4LXByb3BbJ2NoYXJ0LnhtaW4nXSkpKndpZHRoKSt3aWR0aDtjb29yZD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddK2Nvb3JkO31lbHNle2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTwwKXtyZXR1cm4gbnVsbDt9XG52YXIgd2lkdGg9Y2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXS1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt2YXIgY29vcmQ9KCh2YWx1ZS1wcm9wWydjaGFydC54bWluJ10pLyh0aGlzLm1heC1wcm9wWydjaGFydC54bWluJ10pKSp3aWR0aDtjb29yZD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddK2Nvb3JkO31cbnJldHVybiBjb29yZDt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5sYWJlbHMuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYXhpcy5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO31cbnZhciBjb2xvcnM9cHJvcFsnY2hhcnQuY29sb3JzJ107Zm9yKHZhciBpPTA7aTxjb2xvcnMubGVuZ3RoOysraSl7Y29sb3JzW2ldPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7fVxucHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTtwcm9wWydjaGFydC50ZXh0LmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmF4aXMuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5heGlzLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT09J3JpZ2h0Jyl7cGFydHM9UkcuYXJyYXlSZXZlcnNlKHBhcnRzKTt9XG52YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQ9ZnVuY3Rpb24oaW5kZXgpXG57dmFyIG9iaj10aGlzO3RoaXMuY29vcmRzMi5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLGlkeCxhcnIpXG57dmFyIHNoYXBlPW9iai5jb29yZHMyW2lkeF1baW5kZXhdXG52YXIgcHJlX2xpbmV3aWR0aD1jby5saW5lV2lkdGg7Y28ubGluZVdpZHRoPTI7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCddO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJ107Y28uZmlsbFJlY3Qoc2hhcGVbMF0sc2hhcGVbMV0sc2hhcGVbMl0sc2hhcGVbM10pO2NvLnN0cm9rZVJlY3Qoc2hhcGVbMF0sc2hhcGVbMV0sc2hhcGVbMl0sc2hhcGVbM10pO2NvLmxpbmVXaWR0aD1wcmVfbGluZXdpZHRoO30pO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMuZ2V0U2hhcGVCeVk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBvYmo9YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzO2Zvcih2YXIgaT0wLGxlbj1vYmouY29vcmRzLmxlbmd0aDtpPGxlbjtpKyspe2lmKG9iai5jb29yZHNbaV0ubGVuZ3RoPT0wKXtjb250aW51ZTt9XG52YXIgbW91c2VYPW1vdXNlWFlbMF0sbW91c2VZPW1vdXNlWFlbMV0sbGVmdD1vYmouY29vcmRzW2ldWzBdLHRvcD1vYmouY29vcmRzW2ldWzFdLHdpZHRoPW9iai5jb29yZHNbaV1bMl0saGVpZ2h0PW9iai5jb29yZHNbaV1bM107aWYobW91c2VZPj10b3AmJm1vdXNlWTw9KHRvcCtoZWlnaHQpKXtpZihwcm9wWydjaGFydC50b29sdGlwcyddKXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0P1JHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTpwcm9wWydjaGFydC50b29sdGlwcyddW2ldO31cbnJldHVybnswOm9iaixvYmplY3Q6b2JqLDE6bGVmdCx4OmxlZnQsMjp0b3AseTp0b3AsMzp3aWR0aCx3aWR0aDp3aWR0aCw0OmhlaWdodCxoZWlnaHQ6aGVpZ2h0LDU6aSxpbmRleDppLHRvb2x0aXA6dG9vbHRpcH07fX1cbnJldHVybiBudWxsO307dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt2YXIgdmFsdWU9TnVtYmVyKHRoaXMuZ2V0VmFsdWUoZSkpLHNoYXBlPVJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyk7aWYoc2hhcGUpe1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyxzaGFwZSk7aWYodGhpcy5zdGFja2VkT3JHcm91cGVkJiZwcm9wWydjaGFydC5ncm91cGluZyddPT0nZ3JvdXBlZCcpe3ZhciBpbmRleGVzPVJHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzaGFwZVsnaW5kZXgnXSx0aGlzLmRhdGEpO2lmKHR5cGVvZiB0aGlzLmRhdGFbaW5kZXhlc1swXV09PSdudW1iZXInKXt0aGlzLmRhdGFbaW5kZXhlc1swXV09TnVtYmVyKHZhbHVlKTt9ZWxzZSBpZighUkcuaXNfbnVsbCh0aGlzLmRhdGFbaW5kZXhlc1swXV0pKXt0aGlzLmRhdGFbaW5kZXhlc1swXV1baW5kZXhlc1sxXV09TnVtYmVyKHZhbHVlKTt9fWVsc2UgaWYodHlwZW9mIHRoaXMuZGF0YVtzaGFwZVsnaW5kZXgnXV09PSdudW1iZXInKXt0aGlzLmRhdGFbc2hhcGVbJ2luZGV4J11dPU51bWJlcih2YWx1ZSk7fVxuUkcucmVkcmF3Q2FudmFzKGUudGFyZ2V0KTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt9fX07dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDMwLGZyYW1lPTAsY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe30sbGFiZWxzQWJvdmU9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlJ107dGhpcy5zZXQoJ2xhYmVsc0Fib3ZlJyxmYWxzZSk7b2JqLm9yaWdpbmFsX2RhdGE9UkcuYXJyYXlDbG9uZShvYmouZGF0YSk7aWYocHJvcFsnY2hhcnQueG1heCddPT0wKXt2YXIgeG1heD0wO2Zvcih2YXIgaT0wO2k8b2JqLmRhdGEubGVuZ3RoOysraSl7aWYoUkcuaXNBcnJheShvYmouZGF0YVtpXSkmJnByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ109PSdzdGFja2VkJyl7eG1heD1tYS5tYXgoeG1heCxSRy5hcnJheVN1bShvYmouZGF0YVtpXSkpO31lbHNlIGlmKFJHLmlzQXJyYXkob2JqLmRhdGFbaV0pJiZwcm9wWydjaGFydC5ncm91cGluZyddPT0nZ3JvdXBlZCcpe3htYXg9bWEubWF4KHhtYXgsUkcuYXJyYXlNYXgob2JqLmRhdGFbaV0pKTt9ZWxzZXt4bWF4PW1hLm1heCh4bWF4LG1hLmFicyhSRy5hcnJheU1heChvYmouZGF0YVtpXSkpKTt9fVxudmFyIHNjYWxlMj1SRy5nZXRTY2FsZTIob2JqLHsnbWF4Jzp4bWF4fSk7b2JqLlNldCgnY2hhcnQueG1heCcsc2NhbGUyLm1heCk7fVxuZnVuY3Rpb24gaXRlcmF0b3IoKVxue2Zvcih2YXIgaj0wLGxlbj1vYmoub3JpZ2luYWxfZGF0YS5sZW5ndGg7ajxsZW47KytqKXt2YXIgZWFzaW5nRmFjdG9yPVJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsZnJhbWUpO2lmKHR5cGVvZiBvYmouZGF0YVtqXT09PSdvYmplY3QnJiZvYmouZGF0YVtqXSl7Zm9yKHZhciBrPTAsbGVuMj1vYmouZGF0YVtqXS5sZW5ndGg7azxsZW4yOysrayl7b2JqLmRhdGFbal1ba109UkcuaXNOdWxsKG9iai5kYXRhW2pdW2tdKT9udWxsOm9iai5vcmlnaW5hbF9kYXRhW2pdW2tdKmVhc2luZ0ZhY3Rvcjt9fWVsc2V7b2JqLmRhdGFbal09UkcuaXNOdWxsKG9iai5kYXRhW2pdKT9udWxsOm9iai5vcmlnaW5hbF9kYXRhW2pdKmVhc2luZ0ZhY3Rvcjt9fVxuUkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lPGZyYW1lcyl7ZnJhbWUrPTE7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2lmKGxhYmVsc0Fib3ZlKXtvYmouc2V0KCdsYWJlbHNBYm92ZScsdHJ1ZSk7UkcucmVkcmF3KCk7fVxuY2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O3RoaXMuZ3Jvdz1mdW5jdGlvbigpXG57dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHwzMCxmcmFtZT0wLGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9LG9iaj10aGlzLGxhYmVsc0Fib3ZlPXRoaXMuZ2V0KCdsYWJlbHNBYm92ZScpXG50aGlzLm9yaWdpbmFsX2RhdGE9UkcuYXJyYXlDbG9uZSh0aGlzLmRhdGEpO2lmKHByb3BbJ2NoYXJ0LnhtYXgnXT09MCl7dmFyIHhtYXg9MDtmb3IodmFyIGk9MDtpPG9iai5kYXRhLmxlbmd0aDsrK2kpe2lmKFJHLmlzQXJyYXkob2JqLmRhdGFbaV0pJiZwcm9wWydjaGFydC5ncm91cGluZyddPT0nc3RhY2tlZCcpe3htYXg9bWEubWF4KHhtYXgsUkcuYXJyYXlTdW0ob2JqLmRhdGFbaV0pKTt9ZWxzZSBpZihSRy5pc0FycmF5KG9iai5kYXRhW2ldKSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09J2dyb3VwZWQnKXt4bWF4PW1hLm1heCh4bWF4LFJHLmFycmF5TWF4KG9iai5kYXRhW2ldKSk7fWVsc2V7eG1heD1tYS5tYXgoeG1heCxtYS5hYnMoUkcuYXJyYXlNYXgob2JqLmRhdGFbaV0pKSk7fX1cbnZhciBzY2FsZTI9UkcuZ2V0U2NhbGUyKG9iaix7J21heCc6eG1heH0pO29iai5TZXQoJ2NoYXJ0LnhtYXgnLHNjYWxlMi5tYXgpO31cbmlmKFJHLmlzQXJyYXkob3B0LmRhdGEpKXt2YXIgeG1heD0wO2Zvcih2YXIgaT0wO2k8b3B0LmRhdGEubGVuZ3RoOysraSl7aWYodHlwZW9mIG9wdC5kYXRhW2ldPT09J29iamVjdCcpe2Zvcih2YXIgaj0wO2o8b3B0LmRhdGFbaV0ubGVuZ3RoOysrail7aWYodHlwZW9mIG9wdC5kYXRhW2ldW2pdPT09J3N0cmluZycmJm9wdC5kYXRhW2ldW2pdLm1hdGNoKC8oXFwrfFxcLSkoWzAtOV0rKS8pKXtpZihSZWdFeHAuJDE9PT0nKycpe29wdC5kYXRhW2ldW2pdPXRoaXMub3JpZ2luYWxfZGF0YVtpXVtqXStwYXJzZUludChSZWdFeHAuJDIpO31lbHNle29wdC5kYXRhW2ldW2pdPXRoaXMub3JpZ2luYWxfZGF0YVtpXVtqXS1wYXJzZUludChSZWdFeHAuJDIpO319XG54bWF4PW1hLm1heCh4bWF4LG9wdC5kYXRhW2ldW2pdKTt9fWVsc2UgaWYodHlwZW9mIG9wdC5kYXRhW2ldPT09J3N0cmluZycmJm9wdC5kYXRhW2ldLm1hdGNoKC8oXFwrfFxcLSkoWzAtOV0rKS8pKXtpZihSZWdFeHAuJDE9PT0nKycpe29wdC5kYXRhW2ldPXRoaXMub3JpZ2luYWxfZGF0YVtpXStwYXJzZUZsb2F0KFJlZ0V4cC4kMik7fWVsc2V7b3B0LmRhdGFbaV09dGhpcy5vcmlnaW5hbF9kYXRhW2ldLXBhcnNlRmxvYXQoUmVnRXhwLiQyKTt9XG54bWF4PW1hLm1heCh4bWF4LG9wdC5kYXRhW2ldKTt9ZWxzZXt4bWF4PW1hLm1heCh4bWF4LG9wdC5kYXRhW2ldKTt9fVxudmFyIHNjYWxlPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp4bWF4fSk7aWYodHlwZW9mIHRoaXMuZ2V0KCdjaGFydC54bWF4Jyk9PT0nbnVsbCcpe3RoaXMuc2V0KCdjaGFydC54bWF4JyxzY2FsZS5tYXgpO319XG50aGlzLnNldCgnbGFiZWxzQWJvdmUnLGZhbHNlKTtpZihSRy5pc051bGwocHJvcFsnY2hhcnQueG1heCddKSl7dmFyIHhtYXg9MDtmb3IodmFyIGk9MDtpPG9iai5kYXRhLmxlbmd0aDsrK2kpe2lmKFJHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdzdGFja2VkJyl7eG1heD1tYS5tYXgoeG1heCxtYS5hYnMoUkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSkpO31lbHNlIGlmKFJHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXT09PSdncm91cGVkJyl7Zm9yKHZhciBqPTAsZ3JvdXA9W107ajx0aGlzLmRhdGFbaV0ubGVuZ3RoO2orKyl7Z3JvdXAucHVzaChtYS5hYnModGhpcy5kYXRhW2ldW2pdKSk7fVxueG1heD1tYS5tYXgoeG1heCxtYS5hYnMoUkcuYXJyYXlNYXgoZ3JvdXApKSk7fWVsc2V7eG1heD1tYS5tYXgoeG1heCxtYS5hYnModGhpcy5kYXRhW2ldKSk7fX1cbnZhciBzY2FsZT1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6eG1heH0pO3RoaXMuU2V0KCdjaGFydC54bWF4JyxzY2FsZS5tYXgpO31cbmlmKHR5cGVvZiBvcHQueG1heD09PSdudW1iZXInKXtvYmouc2V0KCd4bWF4JyxvcHQueG1heCk7fVxudmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbnt2YXIgZWFzaW5nTXVsdGlwbGllcj1SRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLGZyYW1lKTtmb3IodmFyIGo9MCxsZW49b2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoO2o8bGVuOysrail7aWYodHlwZW9mIG9iai5kYXRhW2pdPT09J29iamVjdCcmJiFSRy5pc051bGwob2JqLmRhdGFbal0pKXtmb3IodmFyIGs9MCxsZW4yPW9iai5kYXRhW2pdLmxlbmd0aDtrPGxlbjI7KytrKXtpZihvYmouZmlyc3REcmF3fHwhb3B0LmRhdGEpe29iai5kYXRhW2pdW2tdPWVhc2luZ011bHRpcGxpZXIqb2JqLm9yaWdpbmFsX2RhdGFbal1ba107fWVsc2UgaWYob3B0LmRhdGEmJm9wdC5kYXRhLmxlbmd0aD09PW9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCl7dmFyIGRpZmY9b3B0LmRhdGFbal1ba10tb2JqLm9yaWdpbmFsX2RhdGFbal1ba107b2JqLmRhdGFbal1ba109KGVhc2luZ011bHRpcGxpZXIqZGlmZikrb2JqLm9yaWdpbmFsX2RhdGFbal1ba107fX19ZWxzZXtpZihvYmouZmlyc3REcmF3fHwhb3B0LmRhdGEpe29iai5kYXRhW2pdPWVhc2luZ011bHRpcGxpZXIqb2JqLm9yaWdpbmFsX2RhdGFbal07fWVsc2UgaWYob3B0LmRhdGEmJm9wdC5kYXRhLmxlbmd0aD09PW9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCl7dmFyIGRpZmY9b3B0LmRhdGFbal0tb2JqLm9yaWdpbmFsX2RhdGFbal07b2JqLmRhdGFbal09KGVhc2luZ011bHRpcGxpZXIqZGlmZikrb2JqLm9yaWdpbmFsX2RhdGFbal07fX19XG5SRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWU8ZnJhbWVzKXtmcmFtZSs9MTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7aWYoUkcuaXNBcnJheShvcHQuZGF0YSkpe3ZhciBsaW5lYXJfZGF0YT1SRy5hcnJheUxpbmVhcml6ZShkYXRhKTtmb3IodmFyIGk9MDtpPGxpbmVhcl9kYXRhLmxlbmd0aDsrK2kpe2lmKCFvYmpbJyQnK2ldKXtvYmpbJyQnK2ldPXt9O319fVxub2JqLmRhdGE9ZGF0YTtvYmoub3JpZ2luYWxfZGF0YT1SRy5hcnJheUNsb25lKGRhdGEpO2lmKGxhYmVsc0Fib3ZlKXtvYmouc2V0KCdsYWJlbHNBYm92ZScsdHJ1ZSk7UkcucmVkcmF3KCk7fVxuY2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy53YXZlPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e307b3B0LmZyYW1lcz1vcHQuZnJhbWVzfHw2MDtvcHQuc3RhcnRGcmFtZXM9W107b3B0LmNvdW50ZXJzPVtdO3ZhciBmcmFtZXNwZXJiYXI9b3B0LmZyYW1lcy8zLGZyYW1lPS0xLGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9LG9yaWdpbmFsPVJHLmFycmF5Q2xvbmUob2JqLmRhdGEpLGxhYmVsc0Fib3ZlPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddO3RoaXMuc2V0KCdsYWJlbHNBYm92ZScsZmFsc2UpO2Zvcih2YXIgaT0wLGxlbj1vYmouZGF0YS5sZW5ndGg7aTxsZW47aSs9MSl7b3B0LnN0YXJ0RnJhbWVzW2ldPSgob3B0LmZyYW1lcy8yKS8ob2JqLmRhdGEubGVuZ3RoLTEpKSppO2lmKHR5cGVvZiBvYmouZGF0YVtpXT09PSdvYmplY3QnJiZvYmouZGF0YVtpXSl7b3B0LmNvdW50ZXJzW2ldPVtdO2Zvcih2YXIgaj0wO2o8b2JqLmRhdGFbaV0ubGVuZ3RoO2orKyl7b3B0LmNvdW50ZXJzW2ldW2pdPTA7fX1lbHNle29wdC5jb3VudGVyc1tpXT0wO319XG5vYmouZHJhdygpO29iai5TZXQoJ3htYXgnLG9iai5zY2FsZTIubWF4KTtSRy5jbGVhcihvYmouY2FudmFzKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57KytmcmFtZTtmb3IodmFyIGk9MCxsZW49b2JqLmRhdGEubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGZyYW1lPm9wdC5zdGFydEZyYW1lc1tpXSl7aWYodHlwZW9mIG9iai5kYXRhW2ldPT09J251bWJlcicpe29iai5kYXRhW2ldPW1hLm1pbihtYS5hYnMob3JpZ2luYWxbaV0pLG1hLmFicyhvcmlnaW5hbFtpXSooKG9wdC5jb3VudGVyc1tpXSsrKS9mcmFtZXNwZXJiYXIpKSk7aWYob3JpZ2luYWxbaV08MCl7b2JqLmRhdGFbaV0qPS0xO319ZWxzZSBpZighUkcuaXNOdWxsKG9iai5kYXRhW2ldKSl7Zm9yKHZhciBqPTAsbGVuMj1vYmouZGF0YVtpXS5sZW5ndGg7ajxsZW4yO2orPTEpe29iai5kYXRhW2ldW2pdPW1hLm1pbihtYS5hYnMob3JpZ2luYWxbaV1bal0pLG1hLmFicyhvcmlnaW5hbFtpXVtqXSooKG9wdC5jb3VudGVyc1tpXVtqXSsrKS9mcmFtZXNwZXJiYXIpKSk7aWYob3JpZ2luYWxbaV1bal08MCl7b2JqLmRhdGFbaV1bal0qPS0xO319fX1lbHNle29iai5kYXRhW2ldPXR5cGVvZiBvYmouZGF0YVtpXT09PSdvYmplY3QnJiZvYmouZGF0YVtpXT9SRy5hcnJheVBhZChbXSxvYmouZGF0YVtpXS5sZW5ndGgsMCk6KFJHLmlzTnVsbChvYmouZGF0YVtpXSk/bnVsbDowKTt9fVxuaWYoZnJhbWU+PW9wdC5mcmFtZXMpe2lmKGxhYmVsc0Fib3ZlKXtvYmouc2V0KCdsYWJlbHNBYm92ZScsdHJ1ZSk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO31cbmNhbGxiYWNrKG9iaik7fWVsc2V7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O3RoaXMuaXNBZGp1c3RhYmxlPWZ1bmN0aW9uKHNoYXBlKVxue2lmKFJHLmlzTnVsbChwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkpe3JldHVybiB0cnVlO31cbmlmKFJHLmlzQXJyYXkocHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J10pJiZwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXVtzaGFwZS5pbmRleF0pe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmhiYXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///222\n");

/***/ }),
/* 223 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HProgress = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.type = 'hprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.tickmarks.zerostart': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.background': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.labels.specific': null, 'chart.labels.count': 10, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'gutter', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null }, _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'black'), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.labels.position', 'bottom'), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.border.inner', true), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[HPROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.array_linearize(value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.strokestyle') {\n      this.Set('chart.strokestyle.inner', value);this.Set('chart.strokestyle.outer', value);return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitle();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.fillStyle = prop['chart.colors'][0];co.strokeStyle = prop['chart.strokestyle.outer'];var margin = prop['chart.margin'];var barWidth = ma.min(this.width, (RG.array_sum(this.value) - this.min) / (this.max - this.min) * this.width);if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var x = this.gutterLeft; x < ca.width - this.gutterRight; x += spacing) {\n        co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), this.gutterTop + 2);co.moveTo(Math.round(x), ca.height - this.gutterBottom);co.lineTo(Math.round(x), ca.height - this.gutterBottom - 2);\n      }\n      co.stroke();\n    }\n    if (typeof this.value === 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, fill: prop['chart.colors'][0] });this.coords.push([this.gutterLeft, this.gutterTop + margin, barWidth, this.height - margin - margin]);\n    } else if (_typeof(this.value) === 'object') {\n      co.beginPath();var startPoint = this.gutterLeft;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentLength = this.value[i] / RG.arraySum(this.value) * barWidth;if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i], stroke: prop['chart.strokestyle.inner'] });\n        }\n        this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i] });this.coords.push([startPoint, this.gutterTop + margin, segmentLength, this.height - margin - margin]);startPoint += segmentLength;\n      }\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft + barWidth;var y = this.gutterTop;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y - 3);co.lineTo(x + 2, y - 7);co.lineTo(x - 2, y - 7);co.closePath();co.stroke();co.fill();co.beginPath();co.moveTo(x, y + this.height + 4);co.lineTo(x + 2, y + this.height + 9);co.lineTo(x - 2, y + this.height + 9);co.closePath();co.stroke();co.fill();\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'] + 2, 'x': this.gutterLeft + barWidth + 5, 'y': this.gutterTop + this.height / 2, 'text': String(prop['chart.units.pre'] + this.value + prop['chart.units.post']), 'valign': 'bottom', 'halign': 'left', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n    pa2(co, 'b');\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();this.tickInterval = this.width / prop['chart.numticks'];var start = prop['chart.tickmarks.zerostart'] ? 0 : this.tickInterval;if (prop['chart.labels.position'] == 'top') {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop);co.lineTo(Math.round(i), this.gutterTop - 4);\n        }\n      } else {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop + this.height);co.lineTo(Math.round(i), this.gutterTop + this.height + 4);\n        }\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var xPoints = [],\n        yPoints = [],\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'];for (i = 0, len = this.scale2.labels.length; i < len; i++) {\n      if (prop['chart.labels.position'] == 'top') {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.gutterTop - 6;var valign = 'bottom';\n      } else {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.height + this.gutterTop + 4;var valign = 'top';\n      }\n      RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': this.scale2.labels[i], 'valign': valign, 'halign': 'center', 'tag': 'scale' });\n    }\n    if (prop['chart.tickmarks.zerostart']) {\n      if (prop['chart.labels.position'] == 'top') {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': this.gutterTop - 6 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'bottom', 'halign': 'center', 'tag': 'scale' });\n      } else {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': ca.height - this.gutterBottom + 5 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, height: h, width: w });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], idx);return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: idx, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var value = (mouseXY[0] - this.gutterLeft) / this.width;value *= this.max - this.min;value += this.min;if (mouseXY[0] < this.gutterLeft) {\n      value = this.min;\n    }\n    if (mouseXY[0] > ca.width - this.gutterRight) {\n      value = this.max;\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    var last = shape.index === this.coords.length - 1;if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value == 'number') {\n        this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          valign = prop['chart.labels.position'] == 'top' ? 'bottom' : 'top',\n          step = this.width / (labels.length - 1),\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { font: font, size: size, x: this.gutterLeft + step * i + offsetx, y: prop['chart.labels.position'] == 'top' ? this.gutterTop - 7 + offsety : ca.height - this.gutterBottom + 7 + offsety, text: labels[i], valign: valign, halign: 'center', tag: 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getXCoord = function (value) {\n    var min = this.min;if (value < min || value > this.max) {\n      return null;\n    }\n    var barWidth = ca.width - this.gutterLeft - this.gutterRight;var coord = (value - min) / (this.max - min) * barWidth;coord = this.gutterLeft + coord;return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, len = 0; i < this.coords.length; ++i) {\n      len += this.coords[i][2];\n    }co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[0][1], len, this.coords[0][3]);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[0][1], width: len, height: this.coords[0][3] });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 51, y: this.coords[0][1] - 1, width: len + 52, height: this.coords[0][3] + 2 });co.stroke();co.restore();co.restore();\n  };this.drawTitle = this.DrawTitle = function () {\n    if (prop['chart.title'].length) {\n      var x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;var text = prop['chart.title'];var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;var font = prop['chart.title.font'] ? prop['chart.title.font'] : prop['chart.text.font'];if (prop['chart.labels.position'] == 'top') {\n        y = ca.height - this.gutterBottom + 5;x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;valign = 'top';\n      } else {\n        x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;y = this.gutterTop - 5;valign = 'bottom';\n      }\n      RG.Text2(this, { 'font': font, 'size': size, 'x': typeof prop['chart.title.x'] == 'number' ? prop['chart.title.x'] : x, 'y': typeof prop['chart.title.y'] == 'number' ? prop['chart.title.y'] : y, 'text': text, 'valign': prop['chart.title.valign'] ? prop['chart.title.valign'] : valign, 'halign': prop['chart.title.halign'] ? prop['chart.title.halign'] : 'center', 'bold': prop['chart.title.bold'], 'bounding': prop['chart.title.background'] ? true : false, 'boundingFill': prop['chart.title.background'], 'tag': 'title' });\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RG.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0, len = initial_value.length; i < len; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguaHByb2dyZXNzLmpzPzRmNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5IUHJvZ3Jlc3M9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi52YWx1ZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgaWQ9Y29uZi5pZCxjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLG1pbj1jb25mLm1pbixtYXg9Y29uZi5tYXgsdmFsdWU9Y29uZi52YWx1ZSxwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmYsY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxtaW49YXJndW1lbnRzWzFdLG1heD1hcmd1bWVudHNbMl0sdmFsdWU9YXJndW1lbnRzWzNdO31cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9Y2FudmFzO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm1pbj1SR3JhcGguc3RyaW5nc1RvTnVtYmVycyhtaW4pO3RoaXMubWF4PVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1heCk7dGhpcy52YWx1ZT1SR3JhcGguc3RyaW5nc1RvTnVtYmVycyh2YWx1ZSk7dGhpcy50eXBlPSdocHJvZ3Jlc3MnO3RoaXMuY29vcmRzPVtdO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLmN1cnJlbnRWYWx1ZT1udWxsO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuY29sb3JzJzpbJ0dyYWRpZW50KHdoaXRlOiMwYzApJywnR3JhZGllbnQod2hpdGU6cmVkKScsJ0dyYWRpZW50KHdoaXRlOmdyZWVuKScsJ3llbGxvdycsJ3BpbmsnLCdjeWFuJywnYmxhY2snLCd3aGl0ZScsJ2dyYXknXSwnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInOicjOTk5JywnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInOicjOTk5JywnY2hhcnQudGlja21hcmtzJzp0cnVlLCdjaGFydC50aWNrbWFya3MuY29sb3InOicjOTk5JywnY2hhcnQudGlja21hcmtzLmlubmVyJzpmYWxzZSwnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCc6dHJ1ZSwnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0Lm51bXRpY2tzJzoxMCwnY2hhcnQubnVtdGlja3MuaW5uZXInOjUwLCdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzonR3JhZGllbnQoI2NjYzojZWVlOiNlZmVmZWYpJywnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzoncmdiYSgwLDAsMCwwLjUpJywnY2hhcnQuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzozLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MywnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC50aXRsZS5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS5mb250JzpudWxsLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmNvbnRleHRtZW51JzpudWxsLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0LmFycm93cyc6ZmFsc2UsJ2NoYXJ0Lm1hcmdpbic6MCwnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOlswLDBdLCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyc6bnVsbCwnY2hhcnQubGFiZWxzLmNvdW50JzoxMCwnY2hhcnQubGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzowLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2d1dHRlcicsJ2NoYXJ0LmtleS5oYWxpZ24nOidyaWdodCcsJ2NoYXJ0LmtleS5zaGFkb3cnOmZhbHNlLCdjaGFydC5rZXkuc2hhZG93LmNvbG9yJzonIzY2NicsJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6MywnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4JzoyLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknOjIsJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOmZhbHNlLCdjaGFydC5rZXkucG9zaXRpb24ueCc6bnVsbCwnY2hhcnQua2V5LnBvc2l0aW9uLnknOm51bGwsJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6J3NxdWFyZScsJ2NoYXJ0LmtleS5yb3VuZGVkJzp0cnVlLCdjaGFydC5rZXkubGluZXdpZHRoJzoxLCdjaGFydC5rZXkuY29sb3JzJzpudWxsLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUnOmZhbHNlLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSc6J2JsYWNrJywnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5sYWJlbCc6J3JnYmEoMjU1LDAsMCwwLjIpJywnY2hhcnQua2V5LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbic6J2JvdHRvbScsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuYm9yZGVyLmlubmVyJzp0cnVlLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbSFBST0dSRVNTXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG52YXIgbGluZWFyX2RhdGE9UkdyYXBoLmFycmF5X2xpbmVhcml6ZSh2YWx1ZSk7Zm9yKHZhciBpPTA7aTxsaW5lYXJfZGF0YS5sZW5ndGg7KytpKXt0aGlzWyckJytpXT17fTt9XG5pZighdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKXt0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXz10cnVlO31cbnZhciBSRz1SR3JhcGgsY2E9dGhpcy5jYW52YXMsY289Y2EuZ2V0Q29udGV4dCgnMmQnKSxwcm9wPXRoaXMucHJvcGVydGllcyxwYTI9UkcucGF0aDIsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQsbWE9TWF0aFxuaWYoUkcuRWZmZWN0cyYmdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO31cbnRoaXMuc2V0PXRoaXMuU2V0PWZ1bmN0aW9uKG5hbWUpXG57dmFyIHZhbHVlPXR5cGVvZiBhcmd1bWVudHNbMV09PT0ndW5kZWZpbmVkJz9udWxsOmFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLG5hbWUpO3JldHVybiB0aGlzO31cbmlmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZihuYW1lPT0nY2hhcnQuc3Ryb2tlc3R5bGUnKXt0aGlzLlNldCgnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInLHZhbHVlKTt0aGlzLlNldCgnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInLHZhbHVlKTtyZXR1cm47fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmN1cnJlbnRWYWx1ZT10aGlzLnZhbHVlO3RoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLndpZHRoPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0O3RoaXMuaGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5kcmF3YmFyKCk7dGhpcy5EcmF3VGlja01hcmtzKCk7dGhpcy5EcmF3TGFiZWxzKCk7dGhpcy5EcmF3VGl0bGUoKTtpZihwcm9wWydjaGFydC5iZXZlbCddKXt0aGlzLkRyYXdCZXZlbCgpO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LmtleSddJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpe1JHLkRyYXdLZXkodGhpcyxwcm9wWydjaGFydC5rZXknXSxwcm9wWydjaGFydC5jb2xvcnMnXSk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3YmFyPXRoaXMuRHJhd2Jhcj1mdW5jdGlvbigpXG57dGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOnRoaXMubWF4LCdtaW4nOnRoaXMubWluLCdzdHJpY3QnOnRydWUsJ3NjYWxlLnRob3VzYW5kJzpwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUuZGVjaW1hbHMnOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLCdzY2FsZS5yb3VuZCc6cHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwndW5pdHMucHJlJzpwcm9wWydjaGFydC51bml0cy5wcmUnXSwndW5pdHMucG9zdCc6cHJvcFsnY2hhcnQudW5pdHMucG9zdCddfSk7aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLlNldFNoYWRvdyh0aGlzLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTt9XG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ107Y28uc3Ryb2tlUmVjdCh0aGlzLmd1dHRlckxlZnQsdGhpcy5ndXR0ZXJUb3AsdGhpcy53aWR0aCx0aGlzLmhlaWdodCk7Y28uZmlsbFJlY3QodGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO1JHLm5vU2hhZG93KHRoaXMpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddO3ZhciBtYXJnaW49cHJvcFsnY2hhcnQubWFyZ2luJ107dmFyIGJhcldpZHRoPW1hLm1pbih0aGlzLndpZHRoLCgoUkcuYXJyYXlfc3VtKHRoaXMudmFsdWUpLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSp0aGlzLndpZHRoKTtpZihwcm9wWydjaGFydC50aWNrbWFya3MuaW5uZXInXSl7dmFyIHNwYWNpbmc9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS9wcm9wWydjaGFydC5udW10aWNrcy5pbm5lciddO2NvLmxpbmVXaWR0aD0xO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ107Y28uYmVnaW5QYXRoKCk7Zm9yKHZhciB4PXRoaXMuZ3V0dGVyTGVmdDt4PGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQ7eCs9c3BhY2luZyl7Y28ubW92ZVRvKE1hdGgucm91bmQoeCksdGhpcy5ndXR0ZXJUb3ApO2NvLmxpbmVUbyhNYXRoLnJvdW5kKHgpLHRoaXMuZ3V0dGVyVG9wKzIpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHgpLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKE1hdGgucm91bmQoeCksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLTIpO31cbmNvLnN0cm9rZSgpO31cbmlmKHR5cGVvZiB0aGlzLnZhbHVlPT09J251bWJlcicpe2lmKHByb3BbJ2NoYXJ0LmJvcmRlci5pbm5lciddKXt0aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5ndXR0ZXJMZWZ0LHk6dGhpcy5ndXR0ZXJUb3ArbWFyZ2luLHdpZHRoOmJhcldpZHRoLGhlaWdodDp0aGlzLmhlaWdodC1tYXJnaW4tbWFyZ2luLHN0cm9rZTpwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddfSk7fVxudGhpcy5kcmF3Q3VydmVkQmFyKHt4OnRoaXMuZ3V0dGVyTGVmdCx5OnRoaXMuZ3V0dGVyVG9wK21hcmdpbix3aWR0aDpiYXJXaWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHQtbWFyZ2luLW1hcmdpbixmaWxsOnByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdfSk7dGhpcy5jb29yZHMucHVzaChbdGhpcy5ndXR0ZXJMZWZ0LHRoaXMuZ3V0dGVyVG9wK21hcmdpbixiYXJXaWR0aCx0aGlzLmhlaWdodC1tYXJnaW4tbWFyZ2luXSk7fWVsc2UgaWYodHlwZW9mIHRoaXMudmFsdWU9PT0nb2JqZWN0Jyl7Y28uYmVnaW5QYXRoKCk7dmFyIHN0YXJ0UG9pbnQ9dGhpcy5ndXR0ZXJMZWZ0O2Zvcih2YXIgaT0wLGxlbj10aGlzLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciBzZWdtZW50TGVuZ3RoPSh0aGlzLnZhbHVlW2ldL1JHLmFycmF5U3VtKHRoaXMudmFsdWUpKSpiYXJXaWR0aDtpZihwcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXSl7dGhpcy5kcmF3Q3VydmVkQmFyKHt4OnN0YXJ0UG9pbnQseTp0aGlzLmd1dHRlclRvcCttYXJnaW4sd2lkdGg6c2VnbWVudExlbmd0aCxoZWlnaHQ6dGhpcy5oZWlnaHQtbWFyZ2luLW1hcmdpbixmaWxsOnByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldLHN0cm9rZTpwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddfSk7fVxudGhpcy5kcmF3Q3VydmVkQmFyKHt4OnN0YXJ0UG9pbnQseTp0aGlzLmd1dHRlclRvcCttYXJnaW4sd2lkdGg6c2VnbWVudExlbmd0aCxoZWlnaHQ6dGhpcy5oZWlnaHQtbWFyZ2luLW1hcmdpbixmaWxsOnByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldfSk7dGhpcy5jb29yZHMucHVzaChbc3RhcnRQb2ludCx0aGlzLmd1dHRlclRvcCttYXJnaW4sc2VnbWVudExlbmd0aCx0aGlzLmhlaWdodC1tYXJnaW4tbWFyZ2luXSk7c3RhcnRQb2ludCs9c2VnbWVudExlbmd0aDt9fVxuaWYocHJvcFsnY2hhcnQuYXJyb3dzJ10pe3ZhciB4PXRoaXMuZ3V0dGVyTGVmdCtiYXJXaWR0aDt2YXIgeT10aGlzLmd1dHRlclRvcDtjby5saW5lV2lkdGg9MTtjby5maWxsU3R5bGU9J2JsYWNrJztjby5zdHJva2VTdHlsZT0nYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LHktMyk7Y28ubGluZVRvKHgrMix5LTcpO2NvLmxpbmVUbyh4LTIseS03KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgseSt0aGlzLmhlaWdodCs0KTtjby5saW5lVG8oeCsyLHkrdGhpcy5oZWlnaHQrOSk7Y28ubGluZVRvKHgtMix5K3RoaXMuaGVpZ2h0KzkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKX1cbmlmKHByb3BbJ2NoYXJ0LmxhYmVsLmlubmVyJ10pe2NvLmZpbGxTdHlsZT0nYmxhY2snO1JHLlRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC50ZXh0LmZvbnQnXSwnc2l6ZSc6cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMiwneCc6dGhpcy5ndXR0ZXJMZWZ0K2JhcldpZHRoKzUsJ3knOnRoaXMuZ3V0dGVyVG9wKyh0aGlzLmhlaWdodC8yKSwndGV4dCc6U3RyaW5nKHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddK3RoaXMudmFsdWUrcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKSwndmFsaWduJzonYm90dG9tJywnaGFsaWduJzonbGVmdCcsJ2JvdW5kaW5nJzp0cnVlLCdib3VuZGluZ0ZpbGwnOid3aGl0ZScsJ3RhZyc6J2xhYmVsLmlubmVyJ30pO31cbnBhMihjbywnYicpO307dGhpcy5kcmF3VGlja01hcmtzPXRoaXMuRHJhd1RpY2tNYXJrcz1mdW5jdGlvbigpXG57Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ107aWYocHJvcFsnY2hhcnQudGlja21hcmtzJ10pe2NvLmJlZ2luUGF0aCgpO3RoaXMudGlja0ludGVydmFsPXRoaXMud2lkdGgvcHJvcFsnY2hhcnQubnVtdGlja3MnXTt2YXIgc3RhcnQ9cHJvcFsnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCddPzA6dGhpcy50aWNrSW50ZXJ2YWw7aWYocHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSd0b3AnKXtmb3IodmFyIGk9dGhpcy5ndXR0ZXJMZWZ0K3N0YXJ0O2k8PSh0aGlzLndpZHRoK3RoaXMuZ3V0dGVyTGVmdCswLjEpO2krPXRoaXMudGlja0ludGVydmFsKXtjby5tb3ZlVG8oTWF0aC5yb3VuZChpKSx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKE1hdGgucm91bmQoaSksdGhpcy5ndXR0ZXJUb3AtNCk7fX1lbHNle2Zvcih2YXIgaT10aGlzLmd1dHRlckxlZnQrc3RhcnQ7aTw9KHRoaXMud2lkdGgrdGhpcy5ndXR0ZXJMZWZ0KzAuMSk7aSs9dGhpcy50aWNrSW50ZXJ2YWwpe2NvLm1vdmVUbyhNYXRoLnJvdW5kKGkpLHRoaXMuZ3V0dGVyVG9wK3RoaXMuaGVpZ2h0KTtjby5saW5lVG8oTWF0aC5yb3VuZChpKSx0aGlzLmd1dHRlclRvcCt0aGlzLmhlaWdodCs0KTt9fVxuY28uc3Ryb2tlKCk7fX07dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57aWYoIVJHLmlzX251bGwocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10pKXtyZXR1cm4gdGhpcy5EcmF3U3BlY2lmaWNMYWJlbHMoKTt9XG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciB4UG9pbnRzPVtdLHlQb2ludHM9W10sZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSxzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLG9mZnNldHg9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J107Zm9yKGk9MCxsZW49dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDtpPGxlbjtpKyspe2lmKHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddPT0ndG9wJyl7dmFyIHg9dGhpcy53aWR0aCooaS90aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSt0aGlzLmd1dHRlckxlZnQrKHRoaXMud2lkdGgvdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCk7dmFyIHk9dGhpcy5ndXR0ZXJUb3AtNjt2YXIgdmFsaWduPSdib3R0b20nO31lbHNle3ZhciB4PXRoaXMud2lkdGgqKGkvdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkrdGhpcy5ndXR0ZXJMZWZ0Kyh0aGlzLndpZHRoL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpO3ZhciB5PXRoaXMuaGVpZ2h0K3RoaXMuZ3V0dGVyVG9wKzQ7dmFyIHZhbGlnbj0ndG9wJzt9XG5SRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eCtvZmZzZXR4LCd5Jzp5K29mZnNldHksJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzp2YWxpZ24sJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO31cbmlmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy56ZXJvc3RhcnQnXSl7aWYocHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSd0b3AnKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6dGhpcy5ndXR0ZXJMZWZ0K29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wLTYrb2Zmc2V0eSwndGV4dCc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10rTnVtYmVyKHRoaXMubWluKS50b0ZpeGVkKHRoaXMubWluPjA/cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTowKStwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3ZhbGlnbic6J2JvdHRvbScsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO31lbHNle1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrb2Zmc2V0eCwneSc6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzUrb2Zmc2V0eSwndGV4dCc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10rTnVtYmVyKHRoaXMubWluKS50b0ZpeGVkKHRoaXMubWluPjA/cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTowKStwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3ZhbGlnbic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsJ3RhZyc6J3NjYWxlJ30pO319fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0QmFyPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTtmb3IodmFyIGk9MCxsZW49dGhpcy5jb29yZHMubGVuZ3RoO2k8bGVuO2krKyl7dmFyIHg9dGhpcy5jb29yZHNbaV1bMF0seT10aGlzLmNvb3Jkc1tpXVsxXSx3PXRoaXMuY29vcmRzW2ldWzJdLGg9dGhpcy5jb29yZHNbaV1bM10saWR4PWk7Y28uYmVnaW5QYXRoKCk7dGhpcy5kcmF3Q3VydmVkQmFyKHt4OngseTp5LGhlaWdodDpoLHdpZHRoOnd9KTtpZihjby5pc1BvaW50SW5QYXRoKG1vdXNlWCxtb3VzZVkpKXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10saWR4KTtyZXR1cm57MDp0aGlzLDE6eCwyOnksMzp3LDQ6aCw1OmlkeCwnb2JqZWN0Jzp0aGlzLCd4Jzp4LCd5Jzp5LCd3aWR0aCc6dywnaGVpZ2h0JzpoLCdpbmRleCc6aWR4LCd0b29sdGlwJzp0b29sdGlwfX19fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTt2YXIgdmFsdWU9KG1vdXNlWFlbMF0tdGhpcy5ndXR0ZXJMZWZ0KS90aGlzLndpZHRoO3ZhbHVlKj10aGlzLm1heC10aGlzLm1pbjt2YWx1ZSs9dGhpcy5taW47aWYobW91c2VYWVswXTx0aGlzLmd1dHRlckxlZnQpe3ZhbHVlPXRoaXMubWluO31cbmlmKG1vdXNlWFlbMF0+KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpKXt2YWx1ZT10aGlzLm1heH1cbnJldHVybiB2YWx1ZTt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue3ZhciBsYXN0PXNoYXBlLmluZGV4PT09dGhpcy5jb29yZHMubGVuZ3RoLTE7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7dGhpcy5kcmF3Q3VydmVkQmFyKHt4OnNoYXBlLngseTpzaGFwZS55LHdpZHRoOnNoYXBlLndpZHRoLGhlaWdodDpzaGFwZS5oZWlnaHQsc3Ryb2tlOnByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSxmaWxsOnByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ119KTt9fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2lmKG1vdXNlWFlbMF0+dGhpcy5ndXR0ZXJMZWZ0JiZtb3VzZVhZWzBdPChjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSYmbW91c2VYWVsxXT50aGlzLmd1dHRlclRvcCYmbW91c2VYWVsxXTwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciB2YWx1ZT10aGlzLmdldFZhbHVlKGUpO2lmKHR5cGVvZih2YWx1ZSk9PSdudW1iZXInKXt0aGlzLnZhbHVlPU51bWJlcih2YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKTtSRy5yZWRyYXdDYW52YXMoY2EpO1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmFkanVzdCcpO319fTt0aGlzLmRyYXdTcGVjaWZpY0xhYmVscz10aGlzLkRyYXdTcGVjaWZpY0xhYmVscz1mdW5jdGlvbigpXG57dmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMnXTtpZihsYWJlbHMpe3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sdmFsaWduPShwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXT09J3RvcCc/J2JvdHRvbSc6J3RvcCcpLHN0ZXA9dGhpcy53aWR0aC8obGFiZWxzLmxlbmd0aC0xKSxvZmZzZXR4PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddXG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2Zvcih2YXIgaT0wO2k8bGFiZWxzLmxlbmd0aDsrK2kpe1JHLlRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUseDp0aGlzLmd1dHRlckxlZnQrKHN0ZXAqaSkrb2Zmc2V0eCx5OnByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddPT0ndG9wJz90aGlzLmd1dHRlclRvcC03K29mZnNldHk6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzcrb2Zmc2V0eSx0ZXh0OmxhYmVsc1tpXSx2YWxpZ246dmFsaWduLGhhbGlnbjonY2VudGVyJyx0YWc6J2xhYmVscy5zcGVjaWZpYyd9KTt9XG5jby5maWxsKCk7fX07dGhpcy5nZXRYQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57dmFyIG1pbj10aGlzLm1pbjtpZih2YWx1ZTxtaW58fHZhbHVlPnRoaXMubWF4KXtyZXR1cm4gbnVsbDt9XG52YXIgYmFyV2lkdGg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQ7dmFyIGNvb3JkPSgodmFsdWUtbWluKS8odGhpcy5tYXgtbWluKSkqYmFyV2lkdGg7Y29vcmQ9dGhpcy5ndXR0ZXJMZWZ0K2Nvb3JkO3JldHVybiBjb29yZDt9O3RoaXMub3ZlckNoYXJ0QXJlYT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHcmFwaC5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVg9bW91c2VYWVswXTt2YXIgbW91c2VZPW1vdXNlWFlbMV07aWYobW91c2VYPj10aGlzLmd1dHRlckxlZnQmJm1vdXNlWDw9KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpJiZtb3VzZVk+PXRoaXMuZ3V0dGVyVG9wJiZtb3VzZVk8PShjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKXtyZXR1cm4gdHJ1ZTt9XG5yZXR1cm4gZmFsc2U7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50aWNrbWFya3MuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuY29sb3InXSk7fVxudmFyIGNvbG9ycz1wcm9wWydjaGFydC5jb2xvcnMnXTtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTt9XG5wcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMuZHJhd0JldmVsPXRoaXMuRHJhd0JldmVsPWZ1bmN0aW9uKClcbntmb3IodmFyIGk9MCxsZW49MDtpPHRoaXMuY29vcmRzLmxlbmd0aDsrK2kpbGVuKz10aGlzLmNvb3Jkc1tpXVsyXTtjby5zYXZlKCk7Y28uYmVnaW5QYXRoKCk7Y28ucmVjdCh0aGlzLmNvb3Jkc1swXVswXSx0aGlzLmNvb3Jkc1swXVsxXSxsZW4sdGhpcy5jb29yZHNbMF1bM10pO2NvLmNsaXAoKTtjby5zYXZlKCk7Y28uYmVnaW5QYXRoKCk7dGhpcy5kcmF3Q3VydmVkQmFyKHt4OnRoaXMuY29vcmRzWzBdWzBdLHk6dGhpcy5jb29yZHNbMF1bMV0sd2lkdGg6bGVuLGhlaWdodDp0aGlzLmNvb3Jkc1swXVszXX0pO2NvLmNsaXAoKTtjby5iZWdpblBhdGgoKTtjby5zaGFkb3dDb2xvcj0nYmxhY2snO2NvLnNoYWRvd09mZnNldFg9MDtjby5zaGFkb3dPZmZzZXRZPTA7Y28uc2hhZG93Qmx1cj0xNTtjby5saW5lV2lkdGg9Mjt0aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5jb29yZHNbMF1bMF0tNTEseTp0aGlzLmNvb3Jkc1swXVsxXS0xLHdpZHRoOmxlbis1MixoZWlnaHQ6dGhpcy5jb29yZHNbMF1bM10rMn0pO2NvLnN0cm9rZSgpO2NvLnJlc3RvcmUoKTtjby5yZXN0b3JlKCk7fTt0aGlzLmRyYXdUaXRsZT10aGlzLkRyYXdUaXRsZT1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQudGl0bGUnXS5sZW5ndGgpe3ZhciB4PSgoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzIpK3RoaXMuZ3V0dGVyTGVmdDt2YXIgdGV4dD1wcm9wWydjaGFydC50aXRsZSddO3ZhciBzaXplPXByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMjt2YXIgZm9udD1wcm9wWydjaGFydC50aXRsZS5mb250J10/cHJvcFsnY2hhcnQudGl0bGUuZm9udCddOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddO2lmKHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddPT0ndG9wJyl7eT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rNTt4PSgoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzIpK3RoaXMuZ3V0dGVyTGVmdDt2YWxpZ249J3RvcCc7fWVsc2V7eD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7eT10aGlzLmd1dHRlclRvcC01O3ZhbGlnbj0nYm90dG9tJzt9XG5SRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6dHlwZW9mKHByb3BbJ2NoYXJ0LnRpdGxlLngnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0LnRpdGxlLngnXTp4LCd5Jzp0eXBlb2YocHJvcFsnY2hhcnQudGl0bGUueSddKT09J251bWJlcic/cHJvcFsnY2hhcnQudGl0bGUueSddOnksJ3RleHQnOnRleHQsJ3ZhbGlnbic6cHJvcFsnY2hhcnQudGl0bGUudmFsaWduJ10/cHJvcFsnY2hhcnQudGl0bGUudmFsaWduJ106dmFsaWduLCdoYWxpZ24nOnByb3BbJ2NoYXJ0LnRpdGxlLmhhbGlnbiddP3Byb3BbJ2NoYXJ0LnRpdGxlLmhhbGlnbiddOidjZW50ZXInLCdib2xkJzpwcm9wWydjaGFydC50aXRsZS5ib2xkJ10sJ2JvdW5kaW5nJzpwcm9wWydjaGFydC50aXRsZS5iYWNrZ3JvdW5kJ10/dHJ1ZTpmYWxzZSwnYm91bmRpbmdGaWxsJzpwcm9wWydjaGFydC50aXRsZS5iYWNrZ3JvdW5kJ10sJ3RhZyc6J3RpdGxlJ30pO319O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQ9ZnVuY3Rpb24oaW5kZXgpXG57dmFyIGNvb3Jkcz10aGlzLmNvb3Jkc1tpbmRleF07Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5saW5lV2lkdGg9Mjtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28ucmVjdChjb29yZHNbMF0sY29vcmRzWzFdLGNvb3Jkc1syXSxjb29yZHNbM10pO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGg9MTt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZHJhd0N1cnZlZEJhcj1mdW5jdGlvbihvcHQpXG57cGEyKGNvLCdiIHIgJSAlICUgJScsb3B0Lngsb3B0Lnksb3B0LndpZHRoLG9wdC5oZWlnaHQpO2lmKG9wdC5zdHJva2Upe2NvLnN0cm9rZVN0eWxlPW9wdC5zdHJva2U7Y28uc3Ryb2tlKCk7fVxuaWYob3B0LmZpbGwpe2NvLmZpbGxTdHlsZT1vcHQuZmlsbDtjby5maWxsKCk7fX1cbnRoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgY2FudmFzPW9iai5jYW52YXM7dmFyIGNvbnRleHQ9b2JqLmNvbnRleHQ7dmFyIGluaXRpYWxfdmFsdWU9b2JqLmN1cnJlbnRWYWx1ZTt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIG51bUZyYW1lcz1vcHQuZnJhbWVzfHwzMDt2YXIgZnJhbWU9MFxudmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O2lmKHR5cGVvZiBvYmoudmFsdWU9PT0nb2JqZWN0Jyl7aWYoUkcuaXNfbnVsbChvYmouY3VycmVudFZhbHVlKSl7b2JqLmN1cnJlbnRWYWx1ZT1bXTtmb3IodmFyIGk9MCxsZW49b2JqLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe29iai5jdXJyZW50VmFsdWVbaV09MDt9fVxudmFyIGRpZmY9W107dmFyIGluY3JlbWVudD1bXTtmb3IodmFyIGk9MCxsZW49b2JqLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe2RpZmZbaV09b2JqLnZhbHVlW2ldLU51bWJlcihvYmouY3VycmVudFZhbHVlW2ldKTtpbmNyZW1lbnRbaV09ZGlmZltpXS9udW1GcmFtZXM7fVxuaWYoaW5pdGlhbF92YWx1ZT09bnVsbCl7aW5pdGlhbF92YWx1ZT1bXTtmb3IodmFyIGk9MCxsZW49b2JqLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe2luaXRpYWxfdmFsdWVbaV09MDt9fX1lbHNle3ZhciBkaWZmPW9iai52YWx1ZS1OdW1iZXIob2JqLmN1cnJlbnRWYWx1ZSk7dmFyIGluY3JlbWVudD1kaWZmL251bUZyYW1lczt9XG5mdW5jdGlvbiBpdGVyYXRvcigpXG57ZnJhbWUrKztpZihmcmFtZTw9bnVtRnJhbWVzKXtpZih0eXBlb2Ygb2JqLnZhbHVlPT0nb2JqZWN0Jyl7b2JqLnZhbHVlPVtdO2Zvcih2YXIgaT0wLGxlbj1pbml0aWFsX3ZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe29iai52YWx1ZVtpXT1pbml0aWFsX3ZhbHVlW2ldKyhpbmNyZW1lbnRbaV0qZnJhbWUpO319ZWxzZXtvYmoudmFsdWU9aW5pdGlhbF92YWx1ZSsoaW5jcmVtZW50KmZyYW1lKTt9XG5SR3JhcGguY2xlYXIob2JqLmNhbnZhcyk7UkdyYXBoLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKCk7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmhwcm9ncmVzcy5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///223\n");

/***/ }),
/* 224 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Line = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'line';this.max = 0;this.coords = [];this.coords2 = [];this.coords.key = [];this.coordsText = [];this.coordsSpline = [];this.coordsAxes = { xaxis: [], yaxis: [] };this.hasnegativevalues = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': 1, 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.hbars': null, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'white', 'chart.labels.above.font': null, 'chart.labels.above.border': true, 'chart.labels.above.offsety': 5, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xtickgap': 20, 'chart.smallxticks': 3, 'chart.largexticks': 5, 'chart.ytickgap': 20, 'chart.smallyticks': 3, 'chart.largeyticks': 5, 'chart.numyticks': 10, 'chart.linewidth': 2.01, 'chart.colors': ['red', '#0f0', '#00f', '#f0f', '#ff0', '#0ff', 'green', 'pink', 'blue', 'black'], 'chart.hmargin': 0, 'chart.tickmarks.dot.stroke': 'white', 'chart.tickmarks.dot.fill': null, 'chart.tickmarks.dot.linewidth': 3, 'chart.tickmarks': 'endcircle', 'chart.tickmarks.linewidth': null, 'chart.tickmarks.image': null, 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 3, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.tickdirection': -1, 'chart.yaxispoints': 5, 'chart.fillstyle': null, 'chart.xaxispos': 'bottom', 'chart.xaxispos.value': 0, 'chart.yaxispos': 'left', 'chart.xticks': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3, 'chart.shadow.color': 'rgba(128,128,128,0.5)', 'chart.tooltips': null, 'chart.tooltips.hotspot.xonly': false, 'chart.tooltips.hotspot.size': 5, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.highlight.style': null, 'chart.highlight.stroke': 'gray', 'chart.highlight.fill': 'white', 'chart.stepped': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': null, 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.scale.invert': false, 'chart.xlabels.inside': false, 'chart.xlabels.inside.color': 'rgba(255,255,255,0.5)', 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.noxaxis': false, 'chart.noendxtick': false, 'chart.noendytick': false, 'chart.units.post': '', 'chart.units.pre': '', 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.axesontop': false, 'chart.filled': false, 'chart.filled.range': false, 'chart.filled.range.threshold': null, 'chart.filled.range.threshold.colors': ['red', 'green'], 'chart.filled.accumulative': true, 'chart.variant': null, 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.numxticks': data && typeof data[0] == 'number' ? data.length - 1 : _typeof(data[0]) === 'object' && data[0] && typeof data[0][0] === 'number' ? data[0].length - 1 : 20 }, _defineProperty(_properties, 'chart.numyticks', 10), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.backdrop', false), _defineProperty(_properties, 'chart.backdrop.size', 30), _defineProperty(_properties, 'chart.backdrop.alpha', 0.2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.noredraw', false), _defineProperty(_properties, 'chart.outofbounds', false), _defineProperty(_properties, 'chart.outofbounds.clip', false), _defineProperty(_properties, 'chart.chromefix', true), _defineProperty(_properties, 'chart.animation.factor', 1), _defineProperty(_properties, 'chart.animation.unfold.x', false), _defineProperty(_properties, 'chart.animation.unfold.y', true), _defineProperty(_properties, 'chart.animation.unfold.initial', 2), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.curvy', false), _defineProperty(_properties, 'chart.line.visible', []), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.errorbars', false), _defineProperty(_properties, 'chart.errorbars.color', 'black'), _defineProperty(_properties, 'chart.errorbars.capped', true), _defineProperty(_properties, 'chart.errorbars.capped.width', 12), _defineProperty(_properties, 'chart.errorbars.linewidth', 1), _defineProperty(_properties, 'chart.combinedchart.effect', null), _defineProperty(_properties, 'chart.combinedchart.effect.options', null), _defineProperty(_properties, 'chart.combinedchart.effect.callback', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.dotted', false), _defineProperty(_properties, 'chart.dashed', false), _properties);\n  for (var i = 1; i < arguments.length; ++i) {\n    if (typeof arguments[i] == 'null' || !arguments[i]) {\n      arguments[i] = [];\n    }\n  }\n  this.original_data = [];if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && conf.data) {\n    if (typeof conf.data[0] === 'number' || RGraph.isNull(conf.data[0])) {\n      this.original_data[0] = RGraph.arrayClone(conf.data);\n    } else {\n      for (var i = 0; i < conf.data.length; ++i) {\n        this.original_data[i] = RGraph.arrayClone(conf.data[i]);\n      }\n    }\n  } else {\n    for (var i = 1; i < arguments.length; ++i) {\n      if (arguments[1] && _typeof(arguments[1]) == 'object' && arguments[1][0] && _typeof(arguments[1][0]) == 'object' && arguments[1][0].length) {\n        var tmp = [];for (var i = 0; i < arguments[1].length; ++i) {\n          tmp[i] = RGraph.array_clone(arguments[1][i]);\n        }\n        for (var j = 0; j < tmp.length; ++j) {\n          this.original_data[j] = RGraph.array_clone(tmp[j]);\n        }\n      } else {\n        this.original_data[i - 1] = RGraph.array_clone(arguments[i]);\n      }\n    }\n  }\n  if (!this.canvas) {\n    alert('[LINE] Fatal error: no canvas support');return;\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    for (var j = 0; j < this.original_data[i].length; ++j) {\n      if (typeof this.original_data[i][j] === 'string') {\n        this.original_data[i][j] = parseFloat(this.original_data[i][j]);\n      }\n    }\n  }\n  this.data_arr = RGraph.arrayLinearize(this.original_data);for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.tooltips' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value) {\n      var tooltips = [];for (var i = 1; i < arguments.length; i++) {\n        if (_typeof(arguments[i]) == 'object' && arguments[i][0]) {\n          for (var j = 0; j < arguments[i].length; j++) {\n            tooltips.push(arguments[i][j]);\n          }\n        } else if (typeof arguments[i] == 'function') {\n          tooltips = arguments[i];\n        } else {\n          tooltips.push(arguments[i]);\n        }\n      }\n      value = tooltips;\n    }\n    if (name == 'chart.linewidth' && navigator.userAgent.match(/Chrome/)) {\n      if (value == 1) {\n        value = 1.01;\n      } else if (RGraph.is_array(value)) {\n        for (var i = 0; i < value.length; ++i) {\n          if (typeof value[i] == 'number' && value[i] == 1) {\n            value[i] = 1.01;\n          }\n        }\n      }\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[LINE] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.xticks') {\n      name = 'chart.numxticks';\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    if (name == 'chart.ylabels.invert') {\n      name = 'chart.scale.invert';\n    }\n    this.properties[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.data = RG.array_clone(this.original_data);this.max = 0;if (prop['chart.filled'] && !prop['chart.filled.range'] && this.data.length > 1 && prop['chart.filled.accumulative']) {\n      var accumulation = [];for (var set = 0; set < this.data.length; ++set) {\n        for (var point = 0; point < this.data[set].length; ++point) {\n          this.data[set][point] = Number(accumulation[point] ? accumulation[point] : 0) + this.data[set][point];accumulation[point] = this.data[set][point];\n        }\n      }\n    }\n    if (prop['chart.ymax']) {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;if (!prop['chart.outofbounds']) {\n        for (dataset = 0; dataset < this.data.length; ++dataset) {\n          if (RGraph.isArray(this.data[dataset])) {\n            for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n              this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n            }\n          }\n        }\n      }\n    } else {\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;for (dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n          this.max = Math.max(this.max, this.data[dataset][datapoint] ? Math.abs(parseFloat(this.data[dataset][datapoint])) : 0);if (!prop['chart.outofbounds']) {\n            this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.coords = [];this.coordsText = [];this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;if (prop['chart.variant'] == '3d') {\n      RG.Draw3DAxes(this);\n    }\n    RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.axesontop'] == false) {\n      this.DrawAxes();\n    }\n    co.save();\n    co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();for (var i = 0, j = 0, len = this.data.length; i < len; i++, j++) {\n      co.beginPath();if (!prop['chart.filled']) {\n        this.SetShadow(i);\n      }\n      if (prop['chart.fillstyle']) {\n        if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'][j]) {\n          var fill = prop['chart.fillstyle'][j];\n        } else if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'].toString().indexOf('Gradient') > 0) {\n          var fill = prop['chart.fillstyle'];\n        } else if (typeof prop['chart.fillstyle'] == 'string') {\n          var fill = prop['chart.fillstyle'];\n        }\n      } else if (prop['chart.filled']) {\n        var fill = prop['chart.colors'][j];\n      } else {\n        var fill = null;\n      }\n      if (prop['chart.tickmarks'] && _typeof(prop['chart.tickmarks']) == 'object') {\n        var tickmarks = prop['chart.tickmarks'][i];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'string') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'function') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else {\n        var tickmarks = null;\n      }\n      if (prop['chart.outofbounds.clip']) {\n        pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n      this.drawLine(this.data[i], prop['chart.colors'][j], fill, this.getLineWidth(j), tickmarks, i);if (prop['chart.outofbounds.clip']) {\n        co.restore();\n      }\n      co.stroke();\n    }\n    if (prop['chart.outofbounds.clip']) {\n      pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n    }\n    if (prop['chart.filled'] && prop['chart.filled.accumulative'] && !prop['chart.curvy']) {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        co.beginPath();co.lineWidth = this.GetLineWidth(i);co.strokeStyle = !this.hidden(i) ? prop['chart.colors'][i] : 'rgba(0,0,0,0)';for (var j = 0, len = this.coords2[i].length; j < len; ++j) {\n          if (j == 0 || this.coords2[i][j][1] == null || this.coords2[i][j - 1] && this.coords2[i][j - 1][1] == null) {\n            co.moveTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          } else {\n            if (prop['chart.stepped']) {\n              co.lineTo(this.coords2[i][j][0], this.coords2[i][j - 1][1]);\n            }\n            co.lineTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          }\n        }\n        co.stroke();\n      }\n      if (prop['chart.tickmarks']) {\n        co.beginPath();co.fillStyle = 'white';for (var i = 0, len = this.coords2.length; i < len; ++i) {\n          co.beginPath();co.strokeStyle = prop['chart.colors'][i];for (var j = 0; j < this.coords2[i].length; ++j) {\n            if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n              var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], co.strokeStyle, false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n            }\n          }\n        }\n        co.stroke();co.fill();\n      }\n    } else if (prop['chart.filled'] && prop['chart.filled.accumulative'] && prop['chart.curvy']) {\n      for (var i = 0; i < this.coordsSpline.length; i += 1) {\n        co.beginPath();co.strokeStyle = prop['chart.colors'][i];co.lineWidth = this.GetLineWidth(i);for (var j = 0, len = this.coordsSpline[i].length; j < len; j += 1) {\n          var point = this.coordsSpline[i][j];j == 0 ? co.moveTo(point[0], point[1]) : co.lineTo(point[0], point[1]);\n        }\n        co.stroke();\n      }\n      for (var i = 0, len = this.coords2.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.coords2[i].length; j < len2; ++j) {\n          if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n            var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' && !RGraph.is_null(prop['chart.tickmarks']) ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];co.strokeStyle = prop['chart.colors'][i];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], prop['chart.colors'][i], false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n          }\n        }\n      }\n    }\n    if (prop['chart.outofbounds.clip']) {\n      co.restore();\n    }\n    co.restore();co.beginPath();if (prop['chart.axesontop']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();this.DrawRange();if (prop['chart.key'] && prop['chart.key'].length && RG.DrawKey) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.drawAboveLabels();\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.filled'] && prop['chart.filled.range'] && this.data.length == 2) {\n      co.beginPath();var len = this.coords.length / 2;co.lineWidth = prop['chart.linewidth'];co.strokeStyle = this.hidden(0) ? 'rgba(0,0,0,0)' : prop['chart.colors'][0];for (var i = 0; i < len; ++i) {\n        if (!RG.isNull(this.coords[i][1])) {\n          if (i == 0) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.beginPath();if (prop['chart.colors'][1]) {\n        co.strokeStyle = this.hidden(1) ? 'rgba(0,0,0,0)' : prop['chart.colors'][1];\n      }\n      for (var i = this.coords.length - 1; i >= len; --i) {\n        if (!RG.is_null(this.coords[i][1])) {\n          if (i == this.coords.length - 1) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();\n    } else if (prop['chart.filled'] && prop['chart.filled.range']) {\n      alert('[LINE] You must have only two sets of data for a filled range chart');\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    RG.noShadow(this);co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.lineCap = 'square';co.lineJoin = 'miter';co.strokeStyle = prop['chart.axis.color'];coords = { xaxis: {}, yaxis: {} };co.beginPath();if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        coords.xaxis = [this.gutterLeft, ma.round(this.grapharea / 2 + this.gutterTop), ca.width - this.gutterRight, ma.round(this.grapharea / 2 + this.gutterTop)];\n      } else if (prop['chart.xaxispos'] === 'top') {\n        coords.xaxis = [this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, this.gutterTop];\n      } else {\n        var y = ma.round(this.getYCoord(prop['chart.ymin'] != 0 ? prop['chart.ymin'] : 0));if (prop['chart.scale.invert'] && prop['chart.ymin'] === 0) {\n          y = this.getYCoord(this.scale2.max);\n        } else if (prop['chart.scale.invert'] || prop['chart.ymin'] < 0) {\n          y = this.getYCoord(0);\n        }\n        coords.xaxis = [this.gutterLeft, y, ca.width - this.gutterRight, y];\n      }\n      co.moveTo(coords.xaxis[0], coords.xaxis[1]);co.lineTo(coords.xaxis[2], coords.xaxis[3]);this.coordsAxes = coords;\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      var xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (!xTickInterval || xTickInterval <= 0) {\n        xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / (prop['chart.labels'] && prop['chart.labels'].length ? prop['chart.labels'].length - 1 : 10);\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' ? xTickInterval : 0); x <= ca.width - this.gutterRight + 1; x += xTickInterval) {\n        if (prop['chart.yaxispos'] == 'right' && x >= ca.width - this.gutterRight - 1) {\n          break;\n        }\n        if (prop['chart.noendxtick']) {\n          if (prop['chart.yaxispos'] == 'left' && x >= ca.width - this.gutterRight - 1) {\n            break;\n          } else if (prop['chart.yaxispos'] == 'right' && x == this.gutterLeft) {\n            continue;\n          }\n        }\n        var yStart = prop['chart.xaxispos'] === 'center' ? this.gutterTop + this.grapharea / 2 - 3 : ca.height - this.gutterBottom;var yEnd = prop['chart.xaxispos'] === 'center' ? yStart + 6 : ca.height - this.gutterBottom - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);if (prop['chart.ymin'] >= 0 && prop['chart.xaxispos'] === 'bottom') {\n          var yStart = this.getYCoord(prop['chart.ymin']) - (prop['chart.ymin'] >= 0 ? 0 : 3),\n              yEnd = this.getYCoord(prop['chart.ymin']) + 3;if (prop['chart.scale.invert']) {\n            yStart = ca.height - prop['chart.gutter.bottom'];yEnd = yStart + 3;\n          }\n        } else if (prop['chart.xaxispos'] == 'center') {\n          var yStart = Math.round(this.gutterTop + this.grapharea / 2) - 3,\n              yEnd = yStart + 6;\n        } else if (prop['chart.xaxispos'] == 'bottom') {\n          var yStart = this.getYCoord(0) - (prop['chart.ymin'] !== 0 ? 3 : 0),\n              yEnd = this.getYCoord(0) - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);yEnd += 0;\n        } else if (prop['chart.xaxispos'] == 'top') {\n          yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n    } else if (prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0) {\n      if (!prop['chart.noendytick']) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        } else {\n          co.moveTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    var numyticks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && numyticks > 0) {\n      var counter = 0,\n          adjustment = 0;if (prop['chart.yaxispos'] == 'right') {\n        adjustment = ca.width - this.gutterLeft - this.gutterRight;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < this.grapharea / 2 + this.gutterTop; y += interval) {\n          if (y < this.grapharea / 2 + this.gutterTop) {\n            co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n          }\n        }\n        for (y = this.gutterTop + this.halfgrapharea + interval; y <= this.grapharea + this.gutterTop; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop + interval; y <= this.grapharea + this.gutterBottom; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n        if (prop['chart.noxaxis'] && prop['chart.noendytick'] == false) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, this.gutterTop);co.lineTo(lineto, this.gutterTop);\n        }\n      } else {\n        var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < ca.height - this.gutterBottom && counter < numyticks; y += (ca.height - this.gutterTop - this.gutterBottom) / numyticks) {\n          if (ma.round(y) !== ma.round(this.coordsAxes.xaxis[1])) {\n            co.moveTo(this.gutterLeft + adjustment, ma.round(y));co.lineTo(lineto, ma.round(y));\n          }\n          var counter = counter + 1;\n        }\n        if (prop['chart.ymin'] < 0) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight, ma.round(y));co.lineTo(lineto, ma.round(y));\n        }\n      }\n    } else if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop : ca.height - this.gutterBottom);co.lineTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop - prop['chart.smallxticks'] : ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      }\n    }\n    co.stroke();co.beginPath();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.strokeStyle = 'black';co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;RG.NoShadow(this);var font = prop['chart.text.font'];var text_size = prop['chart.text.size'];var decimals = prop['chart.scale.decimals'];var context = co;var canvas = ca;var ymin = prop['chart.ymin'];if (prop['chart.ylabels'] && prop['chart.ylabels.specific'] == null) {\n      var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var numYLabels = this.scale2.labels.length;var bounding = false;var bgcolor = prop['chart.ylabels.inside'] ? prop['chart.ylabels.inside.color'] : null;var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true && align == 'left') {\n        xpos -= 10;align = 'right';bounding = true;\n      } else if (prop['chart.ylabels.inside'] == true && align == 'right') {\n        xpos += 10;align = 'left';bounding = true;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var half = this.grapharea / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half - (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n        }\n        for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n        }\n        if (prop['chart.noxaxis'] == true || ymin != 0 || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + offsety, 'text': prop['chart.units.pre'] + ymin.toFixed(ymin === 0 ? 0 : decimals) + prop['chart.units.post'], 'bounding': bounding, 'boundingFill': bgcolor, 'valign': 'center', 'halign': align, 'tag': 'scale' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var half = this.grapharea / 2;if (prop['chart.scale.invert']) {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / numYLabels * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.invert'] || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? ca.height - this.gutterBottom + offsety : this.gutterTop + offsety, 'text': (prop['chart.ymin'] != 0 ? '-' : '') + RG.numberFormat(this, prop['chart.ymin'].toFixed(ymin === 0 ? 0 : decimals), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      } else {\n        if (prop['chart.scale.invert']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': RG.numberFormat(this, this.min.toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 && !prop['chart.scale.invert'] || prop['chart.scale.zerostart'] || prop['chart.noxaxis']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? this.gutterTop + offsety : ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      }\n      if (prop['chart.noxaxis'] == true && prop['chart.ymin'] == null && prop['chart.xaxispos'] != 'center' && prop['chart.noendytick'] == false) {\n        RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + offsety : ca.height - this.gutterBottom, 'text': prop['chart.units.pre'] + Number(0).toFixed(prop['chart.scale.decimals']) + prop['chart.units.post'] + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n      }\n    } else if (prop['chart.ylabels'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var gap = this.grapharea / prop['chart.ylabels.specific'].length;var halign = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var bounding = false;var bgcolor = null;var ymin = prop['chart.ymin'] != null && prop['chart.ymin'];if (prop['chart.yaxispos'] == 'left') {\n        var x = this.gutterLeft - 5;if (prop['chart.ylabels.inside']) {\n          x += 10;halign = 'left';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      } else if (prop['chart.yaxispos'] == 'right') {\n        var x = ca.width - this.gutterRight + 5;if (prop['chart.ylabels.inside']) {\n          x -= 10;halign = 'right';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      }\n      var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.xaxispos'] == 'center') {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / ((prop['chart.ylabels.specific'].length - 1) * 2) * i;if (ymin && ymin > 0) {\n            var y = this.grapharea / 2 / (prop['chart.ylabels.specific'].length - (ymin ? 1 : 0)) * i;y += this.gutterTop;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / 2 + this.gutterTop + this.grapharea / ((reversed_labels.length - 1) * 2) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': i == 0 ? '' : String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / (reversed_labels.length - 1) * i;y = y + this.gutterTop;RG.Text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / (prop['chart.ylabels.specific'].length - 1) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      }\n    }\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var yOffset = 5,\n          bordered = false,\n          bgcolor = null;\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var angle = 0,\n          valign = 'top',\n          halign = 'center',\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.xlabels.inside']) {\n        yOffset = -5;bordered = true;bgcolor = prop['chart.xlabels.inside.color'];valign = 'bottom';\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        valign = 'bottom';yOffset += 2;\n      }\n      if (typeof prop['chart.text.angle'] == 'number' && prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yOffset = 10;if (prop['chart.xaxispos'] == 'top') {\n          yOffset = 10;\n        }\n      }\n      var numLabels = prop['chart.labels'].length,\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];for (i = 0; i < numLabels; ++i) {\n        if (prop['chart.labels'][i]) {\n          var labelX = (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) / (numLabels - 1) * i;labelX += this.gutterLeft + prop['chart.hmargin'];if (this.data.length === 0 || !this.data[0] || prop['chart.labels'].length != this.data[0].length) {\n            labelX = this.gutterLeft + prop['chart.hmargin'] + (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) * (i / (prop['chart.labels'].length - 1));\n          }\n          if (!labelX) {\n            labelX = this.gutterLeft + prop['chart.hmargin'];\n          }\n          if (prop['chart.xaxispos'] == 'top' && prop['chart.text.angle'] > 0) {\n            halign = 'left';\n          }\n          if (prop['chart.text.angle'] != 0) {\n            halign = 'right';\n          }\n          RG.Text2(this, { 'font': font, 'size': text_size, 'bold': bold, 'x': labelX + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop - yOffset - (prop['chart.xlabels.inside'] ? -22 : 0) + offsety : ca.height - this.gutterBottom + yOffset + offsety, 'text': String(prop['chart.labels'][i]), 'valign': valign, 'halign': halign, 'bounding': bordered, 'boundingFill': bgcolor, 'angle': angle, 'tag': 'labels' });\n        }\n      }\n    }\n    co.stroke();co.fill();\n  };\n  this.drawLine = this.DrawLine = function (lineData, color, fill, linewidth, tickmarks, index) {\n    if (prop['chart.animation.unfold.y'] && prop['chart.animation.factor'] != 1) {\n      for (var i = 0; i < lineData.length; ++i) {\n        lineData[i] *= prop['chart.animation.factor'];\n      }\n    }\n    var penUp = false;var yPos = null;var xPos = 0;co.lineWidth = 1;var lineCoords = [];if (index > 0) {\n      var prevLineCoords = this.coords2[index - 1];\n    }\n    var xInterval = (ca.width - 2 * prop['chart.hmargin'] - this.gutterLeft - this.gutterRight) / (lineData.length - 1);for (i = 0, len = lineData.length; i < len; i += 1) {\n      var data_point = lineData[i];var yPos = this.getYCoord(data_point);if (lineData[i] == null || prop['chart.xaxispos'] == 'bottom' && lineData[i] < this.min && !prop['chart.outofbounds'] || prop['chart.xaxispos'] == 'center' && lineData[i] < -1 * this.max && !prop['chart.outofbounds'] || (lineData[i] < this.min && prop['chart.xaxispos'] !== 'center' || lineData[i] > this.max) && !prop['chart.outofbounds']) {\n        yPos = null;\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';if (i > 0) {\n        xPos = xPos + xInterval;\n      } else {\n        xPos = prop['chart.hmargin'] + this.gutterLeft;\n      }\n      if (prop['chart.animation.unfold.x']) {\n        xPos *= prop['chart.animation.factor'];if (xPos < prop['chart.gutter.left']) {\n          xPos = prop['chart.gutter.left'];\n        }\n      }\n      this.coords.push([xPos, yPos]);lineCoords.push([xPos, yPos]);\n    }\n    co.stroke();this.coords2[index] = lineCoords;if (RG.ISOLD && prop['chart.shadow']) {\n      this.DrawIEShadow(lineCoords, co.shadowColor);\n    }\n    co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';if (fill) {\n      co.fillStyle = fill;\n    }\n    var isStepped = prop['chart.stepped'];var isFilled = prop['chart.filled'];if (prop['chart.xaxispos'] == 'top') {\n      var xAxisPos = this.gutterTop;\n    } else if (prop['chart.xaxispos'] == 'center') {\n      var xAxisPos = this.gutterTop + this.grapharea / 2;\n    } else if (prop['chart.xaxispos'] == 'bottom') {\n      var xAxisPos = this.getYCoord(prop['chart.ymin']);\n    }\n    for (var i = 0, len = lineCoords.length; i < len; i += 1) {\n      xPos = lineCoords[i][0];yPos = lineCoords[i][1];var set = index;var prevY = lineCoords[i - 1] ? lineCoords[i - 1][1] : null;var isLast = i + 1 == lineCoords.length;if (!prop['chart.outofbounds'] && (prevY < this.gutterTop || prevY > ca.height - this.gutterBottom)) {\n        penUp = true;\n      }\n      if (i == 0 || penUp || !yPos || !prevY || prevY < this.gutterTop) {\n        if (prop['chart.filled'] && !prop['chart.filled.range']) {\n          if (!prop['chart.outofbounds'] || prevY === null || yPos === null) {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (prop['chart.xaxispos'] == 'top') {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (isStepped && i > 0) {\n            co.lineTo(xPos, lineCoords[i - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        } else {\n          if (RG.ISOLD && yPos == null) {} else {\n            co.moveTo(xPos + 1, yPos);\n          }\n        }\n        if (yPos == null) {\n          penUp = true;\n        } else {\n          penUp = false;\n        }\n      } else {\n        if (isStepped) {\n          co.lineTo(xPos, lineCoords[i - 1][1]);\n        }\n        if (yPos >= this.gutterTop && yPos <= ca.height - this.gutterBottom || prop['chart.outofbounds']) {\n          if (isLast && prop['chart.filled'] && !prop['chart.filled.range'] && prop['chart.yaxispos'] == 'right') {\n            xPos -= 1;\n          }\n          if (!isStepped || !isLast) {\n            co.lineTo(xPos, yPos);if (isFilled && lineCoords[i + 1] && lineCoords[i + 1][1] == null) {\n              co.lineTo(xPos, xAxisPos);\n            }\n          } else if (isStepped && isLast) {\n            co.lineTo(xPos, yPos);\n          }\n          penUp = false;\n        } else {\n          penUp = true;\n        }\n      }\n    }\n    if (prop['chart.filled'] && !prop['chart.filled.range'] && !prop['chart.curvy']) {\n      var fillStyle = prop['chart.fillstyle'];if (index > 0 && prop['chart.filled.accumulative']) {\n        co.lineTo(xPos, prevLineCoords ? prevLineCoords[i - 1][1] : ca.height - this.gutterBottom - 1 + (prop['chart.xaxispos'] == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 : 0));for (var k = i - 1; k >= 0; --k) {\n          co.lineTo(k == 0 ? prevLineCoords[k][0] + 1 : prevLineCoords[k][0], prevLineCoords[k][1]);\n        }\n      } else {\n        if (prop['chart.xaxispos'] == 'top') {\n          co.lineTo(xPos, prop['chart.gutter.top'] + 1);co.lineTo(lineCoords[0][0], prop['chart.gutter.top'] + 1);\n        } else if (typeof lineCoords[i - 1][1] == 'number') {\n          var yPosition = this.getYCoord(0);co.lineTo(xPos, yPosition);co.lineTo(lineCoords[0][0], yPosition);\n        }\n      }\n      co.fillStyle = !this.hidden(index) ? fill : 'rgba(0,0,0,0)';co.fill();co.beginPath();\n    }\n    co.stroke();if (prop['chart.backdrop']) {\n      this.DrawBackdrop(lineCoords, color);\n    }\n    co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();if (typeof prop['chart.errorbars'] !== 'null') {\n      this.drawErrorbars();\n    }\n    this.SetShadow(index);this.redrawLine(lineCoords, color, linewidth, index);co.stroke();RG.NoShadow(this);for (var i = 0; i < lineCoords.length; ++i) {\n      i = Number(i);co.strokeStyle = color;if (isStepped && i == lineCoords.length - 1) {\n        co.beginPath();\n      }\n      if (tickmarks != 'endcircle' && tickmarks != 'endsquare' && tickmarks != 'filledendsquare' && tickmarks != 'endtick' && tickmarks != 'endtriangle' && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == 0 && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == lineCoords.length - 1) {\n        var prevX = i <= 0 ? null : lineCoords[i - 1][0];var prevY = i <= 0 ? null : lineCoords[i - 1][1];this.DrawTick(lineData, lineCoords[i][0], lineCoords[i][1], color, false, prevX, prevY, tickmarks, i, index);\n      }\n    }\n    co.restore();co.beginPath();co.arc(ca.width + 50000, ca.height + 50000, 2, 0, 6.38, 1);\n  };this.drawTick = this.DrawTick = function (lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index, dataset) {\n    if (this.hidden(dataset)) {\n      return;\n    } else if (RG.is_null(yPos)) {\n      return false;\n    } else if (yPos > ca.height - this.gutterBottom && !prop['chart.outofbounds']) {\n      return;\n    } else if (yPos < this.gutterTop && !prop['chart.outofbounds']) {\n      return;\n    }\n    co.beginPath();var offset = 0;co.lineWidth = prop['chart.tickmarks.linewidth'] ? prop['chart.tickmarks.linewidth'] : prop['chart.linewidth'];co.strokeStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle') {\n      if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle' && (index == 0 || index == lineData.length - 1)) {\n        co.beginPath();co.arc(xPos + offset, yPos + offset, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false);if (tickmarks == 'filledcircle') {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n        } else {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';\n        }\n        co.stroke();co.fill();\n      }\n    } else if (tickmarks == 'halftick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'tick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'endtick' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'cross') {\n      co.beginPath();var ticksize = prop['chart.ticksize'];co.moveTo(xPos - ticksize, yPos - ticksize);co.lineTo(xPos + ticksize, yPos + ticksize);co.moveTo(xPos + ticksize, yPos - ticksize);co.lineTo(xPos - ticksize, yPos + ticksize);co.stroke();\n    } else if (tickmarks == 'triangle' || tickmarks == 'filledtriangle' || tickmarks == 'endtriangle' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();if (tickmarks == 'filledtriangle') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n      } else {\n        co.fillStyle = 'white';\n      }\n      co.moveTo(ma.round(xPos - prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.lineTo(ma.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(ma.round(xPos + prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'borderedcircle' || tickmarks == 'dot') {\n      co.lineWidth = prop['chart.tickmarks.dot.linewidth'] || 0.00000001;pa2(co, ['b', 'a', xPos, yPos, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false, 'c', 'f', prop['chart.tickmarks.dot.fill'] || color, 's', prop['chart.tickmarks.dot.stroke'] || color]);\n    } else if (tickmarks == 'square' || tickmarks == 'filledsquare' || tickmarks == 'endsquare' && (index == 0 || index == lineData.length - 1) || tickmarks == 'filledendsquare' && (index == 0 || index == lineData.length - 1)) {\n      co.fillStyle = 'white';co.strokeStyle = co.strokeStyle;co.beginPath();co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);if (tickmarks == 'filledsquare' || tickmarks == 'filledendsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);\n      } else if (tickmarks == 'square' || tickmarks == 'endsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';co.rect(Math.round(xPos - prop['chart.ticksize'] + 1), Math.round(yPos - prop['chart.ticksize'] + 1), prop['chart.ticksize'] * 2 - 2, prop['chart.ticksize'] * 2 - 2);\n      }\n      co.stroke();co.fill();\n    } else if (tickmarks == 'filledarrow') {\n      var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5, a + 0.5, false);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'arrow') {\n      var orig_linewidth = co.lineWidth;var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);co.lineWidth;if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5 - (doc.all ? 0.1 : 0.01), a - 0.4, false);co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a + 0.5 + (doc.all ? 0.1 : 0.01), a + 0.5, true);co.stroke();co.fill();co.lineWidth = orig_linewidth;\n    } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n      var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n        img.src = tickmarks.substr(6);\n      } else {\n        img.src = tickmarks;\n      }\n      img.onload = function () {\n        if (prop['chart.tickmarks.image.halign'] === 'center') xPos -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') xPos -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yPos -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yPos -= this.height;xPos += prop['chart.tickmarks.image.offsetx'];yPos += prop['chart.tickmarks.image.offsety'];co.drawImage(this, xPos, yPos);\n      };\n    } else if (typeof tickmarks == 'function') {\n      tickmarks(this, lineData, lineData[index], index, xPos, yPos, color, prevX, prevY);\n    }\n  };this.drawRange = this.DrawRange = function () {\n    if (prop['chart.filled.range'] && prop['chart.filled']) {\n      if (RG.isNull(prop['chart.filled.range.threshold'])) {\n        prop['chart.filled.range.threshold'] = this.ymin;\n        prop['chart.filled.range.threshold.colors'] = [prop['chart.fillstyle'], prop['chart.fillstyle']];\n      }\n      for (var idx = 0; idx < 2; ++idx) {\n        var threshold_colors = prop['chart.filled.range.threshold.colors'];var y = this.getYCoord(prop['chart.filled.range.threshold']);\n        co.save();if (idx == 0) {\n          co.beginPath();co.rect(0, 0, ca.width, y);co.clip();\n        } else {\n          co.beginPath();co.rect(0, y, ca.width, ca.height);co.clip();\n        }\n        co.beginPath();co.fillStyle = idx == 1 ? prop['chart.filled.range.threshold.colors'][1] : prop['chart.filled.range.threshold.colors'][0];co.lineWidth = !this.hidden(idx) ? 1 : 0;var len = this.coords.length / 2;for (var i = 0; i < len; ++i) {\n          if (!RG.is_null(this.coords[i][1])) {\n            if (i == 0) {\n              co.moveTo(this.coords[i][0], this.coords[i][1]);\n            } else {\n              co.lineTo(this.coords[i][0], this.coords[i][1]);\n            }\n          }\n        }\n        for (var i = this.coords.length - 1; i >= len; --i) {\n          if (RG.is_null(this.coords[i][1])) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n        co.fill();co.restore();\n      }\n    }\n  };this.redrawLine = this.RedrawLine = function (coords, color, linewidth, index) {\n    if (prop['chart.noredraw'] || prop['chart.filled.range']) {\n      return;\n    }\n    co.strokeStyle = (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color && color.toString().indexOf('CanvasGradient') == -1 ? color[0] : color;co.lineWidth = linewidth;if (prop['chart.dashed']) {\n      co.setLineDash([2, 6]);\n    } else if (prop['chart.dotted']) {\n      co.setLineDash([1, 5]);\n    }\n    if (this.hidden(index)) {\n      co.strokeStyle = 'rgba(0,0,0,0)';\n    }\n    if (!RG.ISOLD && (prop['chart.curvy'] || prop['chart.spline'])) {\n      this.DrawCurvyLine(coords, this.hidden(index) ? 'rgba(0,0,0,0)' : color, linewidth, index);return;\n    }\n    co.beginPath();var len = coords.length;var width = ca.width;\n    var height = ca.height;var penUp = false;for (var i = 0; i < len; ++i) {\n      var xPos = coords[i][0];var yPos = coords[i][1];if (i > 0) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];\n      }\n      if ((i == 0 && coords[i] || yPos < this.gutterTop || prevY < this.gutterTop || yPos > height - this.gutterBottom || i > 0 && prevX > width - this.gutterRight || i > 0 && prevY > height - this.gutterBottom || prevY == null || penUp == true) && (!prop['chart.outofbounds'] || yPos == null || prevY == null)) {\n        if (RG.ISOLD && yPos == null) {} else {\n          co.moveTo(coords[i][0], coords[i][1]);\n        }\n        penUp = false;\n      } else {\n        if (prop['chart.stepped'] && i > 0) {\n          co.lineTo(coords[i][0], coords[i - 1][1]);\n        }\n        co.lineTo(coords[i][0], coords[i][1]);penUp = false;\n      }\n    }\n    if (prop['chart.colors.alternate'] && (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color[0] && color[1]) {\n      for (var i = 1; i < len; ++i) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];if (prevY != null && coords[i][1] != null) {\n          co.beginPath();co.strokeStyle = color[coords[i][1] < prevY ? 0 : 1];co.lineWidth = prop['chart.linewidth'];co.moveTo(prevX, prevY);co.lineTo(coords[i][0], coords[i][1]);co.stroke();\n        }\n      }\n    }\n    if (prop['chart.dashed'] || prop['chart.dotted']) {\n      co.setLineDash([1, 0]);\n    }\n  };this.drawIEShadow = this.DrawIEShadow = function (coords, color) {\n    var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.strokeStyle = color;co.beginPath();for (var i = 0; i < coords.length; ++i) {\n      var isNull = RG.isNull(coords[i][1]);var prevIsNull = RG.isNull(coords[i - 1]) || RG.isNull(coords[i - 1][1]);if (i == 0 || isNull || prevIsNull) {\n        if (!isNull) {\n          co.moveTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n        }\n      } else {\n        co.lineTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n      }\n    }\n    co.stroke();\n  };this.drawBackdrop = this.DrawBackdrop = function (coords, color) {\n    var size = prop['chart.backdrop.size'];co.lineWidth = size;co.globalAlpha = prop['chart.backdrop.alpha'];co.strokeStyle = color;var yCoords = [];co.beginPath();if (prop['chart.curvy'] && !RG.ISOLD) {\n      for (var i = 0; i < coords.length; ++i) {\n        yCoords.push(coords[i][1]);\n      }\n      this.DrawSpline(co, yCoords, color, null);\n    } else {\n      co.moveTo(coords[0][0], coords[0][1]);for (var j = 1; j < coords.length; ++j) {\n        co.lineTo(coords[j][0], coords[j][1]);\n      }\n    }\n    co.stroke();co.globalAlpha = 1;RG.NoShadow(this);\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[LINE] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var obj = this,\n        RG = RGraph,\n        ca = canvas = e.target,\n        co = context = this.context,\n        prop = this.properties;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (arguments[1]) {\n      obj = arguments[1];\n    }\n    for (var i = 0; i < obj.coords.length; ++i) {\n      var x = obj.coords[i][0];var y = obj.coords[i][1];if (mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size'] && mouseY <= y + prop['chart.tooltips.hotspot.size'] && mouseY >= y - prop['chart.tooltips.hotspot.size']) {\n        if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);\n        }\n        var dataset = 0;var idx = i;while (idx + 1 > this.data[dataset].length) {\n          idx -= this.data[dataset].length;dataset++;\n        }\n        return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip, 'dataset': dataset, 'index_adjusted': idx };\n      } else if (prop['chart.tooltips.hotspot.xonly'] == true && mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size']) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'],\n        font = prop['chart.labels.above.font'] || prop['chart.text.font'],\n        units_pre = prop['chart.labels.above.units.pre'],\n        units_post = prop['chart.labels.above.units.post'],\n        decimals = prop['chart.labels.above.decimals'],\n        color = prop['chart.labels.above.color'] || prop['chart.text.color'],\n        bgcolor = prop['chart.labels.above.background'] || 'white',\n        border = typeof prop['chart.labels.above.border'] === 'boolean' || typeof prop['chart.labels.above.border'] === 'number' ? prop['chart.labels.above.border'] : true,\n        offsety = prop['chart.labels.above.offsety'] + size,\n        specific = prop['chart.labels.above.specific'];co.beginPath();for (var i = 0, len = this.coords.length; i < len; i += 1) {\n      var coords = this.coords[i];RG.text2(this, { color: color, 'font': font, 'size': size, 'x': coords[0], 'y': coords[1] - offsety, 'text': specific && specific[i] ? specific[i] : specific ? null : RG.numberFormat(this, typeof decimals === 'number' ? this.data_arr[i].toFixed(decimals) : this.data_arr[i], units_pre, units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': bgcolor, 'boundingStroke': border ? 'black' : 'rgba(0,0,0,0)', 'tag': 'labels.above' });\n    }\n  };this.drawCurvyLine = this.DrawCurvyLine = function (coords, color, linewidth, index) {\n    var yCoords = [];for (var i = 0; i < coords.length; ++i) {\n      yCoords.push(coords[i][1]);\n    }\n    if (prop['chart.filled']) {\n      co.beginPath();var xaxisY = this.getYCoord(prop['chart.ymin']);co.moveTo(coords[0][0], xaxisY);this.drawSpline(co, yCoords, color, index);if (prop['chart.filled.accumulative'] && index > 0) {\n        for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; i -= 1) {\n          co.lineTo(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]);\n        }\n      } else {\n        co.lineTo(coords[coords.length - 1][0], xaxisY);\n      }\n      co.fill();\n    }\n    co.beginPath();this.DrawSpline(co, yCoords, color, index);co.stroke();\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;var xaxispos = prop['chart.xaxispos'];if (mouseY < prop['chart.gutter.top']) {\n      return xaxispos == 'bottom' || xaxispos == 'center' ? this.max : this.min;\n    } else if (mouseY > ca.height - prop['chart.gutter.bottom']) {\n      return xaxispos == 'bottom' ? this.min : this.max;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (obj.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value *= 2;value > 0 ? value += this.min : value -= this.min;return value;\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value = Math.abs(obj.max - value) * -1;return value;\n    } else {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);\n      value += obj.min;return value;\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] === 'halo') {\n        var obj = shape.object,\n            color = prop['chart.colors'][shape.dataset];RG.path2(obj.context, 'b a % % 13 0 6.2830 false f rgba(255,255,255,0.75)', shape.x, shape.y);RG.path2(obj.context, 'ga 0.15 b a % % 13 0 6.2830 false f % ga 1', shape.x, shape.y, color);RG.path2(obj.context, 'b a % % 7 0 6.2830 false f white', shape.x, shape.y);RG.path2(obj.context, 'b a % % 5 0 6.2830 false f %', shape.x, shape.y, color);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] - 5 && mouseXY[0] < ca.width - prop['chart.gutter.right'] + 5 && mouseXY[1] > prop['chart.gutter.top'] - 5 && mouseXY[1] < ca.height - prop['chart.gutter.bottom'] + 5) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);this.original_data[shape['dataset']][shape['index_adjusted']] = Number(value);RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var y;var xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.min) / (this.max - this.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if ((value < this.min || value > this.max) && prop['chart.outofbounds'] == false) {\n        return null;\n      }\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.drawSpline = this.DrawSpline = function (context, coords, color, index) {\n    this.coordsSpline[index] = [];var xCoords = [];var gutterLeft = prop['chart.gutter.left'];var gutterRight = prop['chart.gutter.right'];var hmargin = prop['chart.hmargin'];var interval = (ca.width - (gutterLeft + gutterRight) - 2 * hmargin) / (coords.length - 1);co.strokeStyle = color;for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n        coords[i] = Number(coords[i][1]);\n      }\n    }\n    var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n      P.push(coords[i]);\n    }\n    P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n      for (var t = 0; t < 10; ++t) {\n        var yCoord = Spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);co.lineTo(xCoords[xCoords.length - 1], yCoord);if (typeof index == 'number') {\n          this.coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n        }\n      }\n    }\n    co.lineTo((j - 1) * interval + gutterLeft + hmargin, P[j]);if (typeof index == 'number') {\n      this.coordsSpline[index].push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n    }\n    function Spline(t, P0, P1, P2, P3) {\n      return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.fillstyle'] = RGraph.array_clone(prop['chart.fillstyle']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.annotate.color'] = prop['chart.annotate.color'];this.original_colors['chart.title.color'] = prop['chart.title.color'];this.original_colors['chart.title.yaxis.color'] = prop['chart.title.yaxis.color'];this.original_colors['chart.key.background'] = prop['chart.key.background'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      if (_typeof(prop['chart.colors'][i]) == 'object' && prop['chart.colors'][i][0] && prop['chart.colors'][i][1]) {\n        prop['chart.colors'][i][0] = this.parseSingleColorForGradient(prop['chart.colors'][i][0]);prop['chart.colors'][i][1] = this.parseSingleColorForGradient(prop['chart.colors'][i][1]);\n      } else {\n        prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n      }\n    }\n    if (prop['chart.fillstyle']) {\n      if (typeof prop['chart.fillstyle'] == 'string') {\n        prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle'], 'vertical');\n      } else {\n        for (var i = 0; i < prop['chart.fillstyle'].length; ++i) {\n          prop['chart.fillstyle'][i] = this.parseSingleColorForGradient(prop['chart.fillstyle'][i], 'vertical');\n        }\n      }\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    var properties = ['chart.background.barcolor1', 'chart.background.barcolor2', 'chart.background.grid.color', 'chart.background.color', 'chart.text.color', 'chart.crosshairs.color', 'chart.annotate.color', 'chart.title.color', 'chart.title.yaxis.color', 'chart.key.background', 'chart.axis.color', 'chart.highlight.fill'];for (var i = 0; i < properties.length; ++i) {\n      prop[properties[i]] = this.parseSingleColorForGradient(prop[properties[i]]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    var dir = typeof arguments[1] == 'string' ? arguments[1] : 'vertical';if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (dir == 'horizontal') {\n        var grad = co.createLinearGradient(0, 0, ca.width, 0);\n      } else {\n        var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);\n      }\n      var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.setShadow = this.SetShadow = function (i) {\n    if (prop['chart.shadow']) {\n      var shadowColor = prop['chart.shadow.color'];if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object' && shadowColor[i - 1]) {\n        co.shadowColor = shadowColor[i];\n      } else if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object') {\n        co.shadowColor = shadowColor[0];\n      } else if (typeof shadowColor == 'string') {\n        co.shadowColor = shadowColor;\n      }\n      co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();if (prop['chart.curvy']) {\n        this.DrawSpline(co, coords, prop['chart.key.interactive.highlight.chart'], null);\n      } else {\n        for (var i = 0, len = coords.length; i < len; i += 1) {\n          if (i == 0 || RG.is_null(coords[i][1]) || _typeof(coords[i - 1][1]) != undefined && RG.is_null(coords[i - 1][1])) {\n            co.moveTo(coords[i][0], coords[i][1]);\n          } else {\n            co.lineTo(coords[i][0], coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.drawErrorbars = function () {\n    co.save();RG.noShadow(this);var coords = this.coords,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0.001;halfwidth = 0.0005;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      var halfwidth = prop['chart.errorbars.capped.width'] / 2 || 5,\n          color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      } else {\n        co.lineWidth = 1;\n      }\n      if (typeof errorbars === 'number' || typeof errorbars[i] === 'number') {\n        if (typeof errorbars === 'number') {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars),\n              negativeLength = positiveLength;\n        } else {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i]),\n              negativeLength = positiveLength;\n        }\n        if (positiveLength || negativeLength) {\n          pa2(co, 'lj miter lc square b m % % l % % m % % l % % l % % m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, coords[i][0], coords[i][1] + negativeLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, coords[i][1] - positiveLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] + halfwidth, coords[i][1] - positiveLength, color);pa2(co, 'lj miter lc square b m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][0]),\n            negativeLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][1]);if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : halfwidth;if (_typeof(errorbars[i]) === 'object' && typeof errorbars[i][3] === 'number') {\n          co.lineWidth = errorbars[i][3];\n        } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n          co.lineWidth = prop['chart.errorbars.linewidth'];\n        } else {\n          co.lineWidth = 1;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'lc square b  m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0], ma.round(coords[i][1] - positiveLength), coords[i][0] + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] + negativeLength, coords[i][0] - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0], ma.round(coords[i][1] + negativeLength), coords[i][0] + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n    }\n    co.restore();\n  };this.hide = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = false;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = false;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = false;\n      }\n    }\n    RG.redraw();return this;\n  };this.show = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = true;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = true;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = true;\n      }\n    }\n    RG.redraw();return this;\n  };this.hidden = function (index) {\n    return !prop['chart.line.visible'][index];\n  };this.unfold = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var initial = prop['chart.animation.unfold.initial'];prop['chart.animation.factor'] = prop['chart.animation.unfold.initial'];function iterator() {\n      prop['chart.animation.factor'] = (1 - initial) * (frame / frames) + initial;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = this.trace2 = function () {\n    var obj = this;var callback = arguments[2];var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.Set('animation.trace.clip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.foldtocenter = this.foldToCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var center_value = obj.scale2.max / 2;obj.Set('chart.ymax', obj.scale2.max);var original_data = RG.array_clone(obj.original_data);function iterator() {\n      for (var i = 0, len = obj.data.length; i < len; ++i) {\n        if (obj.data[i].length) {\n          for (var j = 0, len2 = obj.data[i].length; j < len2; ++j) {\n            var dataset = obj.original_data[i];if (dataset[j] > center_value) {\n              dataset[j] = original_data[i][j] - (original_data[i][j] - center_value) * (frame / frames);\n            } else {\n              dataset[j] = original_data[i][j] + (center_value - original_data[i][j]) / frames * frame;\n            }\n          }\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n      if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.unfoldFromCenterTrace = this.unfoldFromCenterTrace2 = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        data = RG.arrayClone(obj.original_data),\n        callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var unfoldCallback = function unfoldCallback() {\n      obj.original_data = data;obj.unfoldFromCenter({ frames: frames / 2 }, callback);\n    };var half = obj.Get('chart.xaxispos') == 'center' ? obj.min : (obj.max - obj.min) / 2 + obj.min;obj.Set('chart.ymax', obj.max);for (var i = 0, len = obj.original_data.length; i < len; ++i) {\n      for (var j = 0; j < obj.original_data[i].length; ++j) {\n        obj.original_data[i][j] = obj.Get('chart.filled') && obj.Get('chart.filled.accumulative') && i > 0 ? 0 : half;\n      }\n    }\n    RG.clear(obj.canvas);obj.trace2({ frames: frames / 2 }, unfoldCallback);return obj;\n  };this.unfoldFromCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.Draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var center_value = obj.Get('chart.xaxispos') === 'center' ? prop['chart.ymin'] : (obj.max - obj.min) / 2 + obj.min;var original_data = RG.array_clone(obj.original_data);var steps = null;obj.Set('chart.ymax', max);if (!steps) {\n      steps = [];for (var dataset = 0, len = original_data.length; dataset < len; ++dataset) {\n        steps[dataset] = [];\n        for (var i = 0, len2 = original_data[dataset].length; i < len2; ++i) {\n          if (prop['chart.filled'] && prop['chart.filled.accumulative'] && dataset > 0) {\n            steps[dataset][i] = original_data[dataset][i] / frames;obj.original_data[dataset][i] = center_value;\n          } else {\n            steps[dataset][i] = (original_data[dataset][i] - center_value) / frames;obj.original_data[dataset][i] = center_value;\n          }\n        }\n      }\n    }\n    function unfoldFromCenter() {\n      for (var dataset = 0; dataset < original_data.length; ++dataset) {\n        for (var i = 0; i < original_data[dataset].length; ++i) {\n          obj.original_data[dataset][i] += steps[dataset][i];\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (--frames > 0) {\n        RG.Effects.updateCanvas(unfoldFromCenter);\n      } else {\n        obj.original_data = RG.array_clone(original_data);RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    unfoldFromCenter();return this;\n  };RG.att(ca);this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    prop['chart.line.visible'][i] = true;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubGluZS5qcz9mYjE0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguTGluZT1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWQ7dmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGE9Y29uZi5kYXRhO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGlkPWNvbmY7dmFyIGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGE9YXJndW1lbnRzWzFdO31cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9Y2FudmFzO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLnR5cGU9J2xpbmUnO3RoaXMubWF4PTA7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO3RoaXMuY29vcmRzLmtleT1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5jb29yZHNTcGxpbmU9W107dGhpcy5jb29yZHNBeGVzPXt4YXhpczpbXSx5YXhpczpbXX07dGhpcy5oYXNuZWdhdGl2ZXZhbHVlcz1mYWxzZTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO3RoaXMucHJvcGVydGllcz17J2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCc6MSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLndpZHRoJzoxLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnOjI1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudnNpemUnOjI1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOicjZGRkJywnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmJvcmRlcic6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0LmFsaWduJzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnOjUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRhc2hlZCc6ZmFsc2UsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kb3R0ZWQnOmZhbHNlLCdjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS55JzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLncnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuaCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5hbGlnbic6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzJzpudWxsLCdjaGFydC5sYWJlbHMuYm9sZCc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmluZ3JhcGgnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZSc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5hYm92ZS5zaXplJzo4LCdjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnOm51bGwsJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLmFib3ZlLmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmxhYmVscy5hYm92ZS5mb250JzpudWxsLCdjaGFydC5sYWJlbHMuYWJvdmUuYm9yZGVyJzp0cnVlLCdjaGFydC5sYWJlbHMuYWJvdmUub2Zmc2V0eSc6NSwnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSc6JycsJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wb3N0JzonJywnY2hhcnQubGFiZWxzLmFib3ZlLnNwZWNpZmljJzpudWxsLCdjaGFydC5sYWJlbHMub2Zmc2V0eCc6MCwnY2hhcnQubGFiZWxzLm9mZnNldHknOjAsJ2NoYXJ0Lnh0aWNrZ2FwJzoyMCwnY2hhcnQuc21hbGx4dGlja3MnOjMsJ2NoYXJ0LmxhcmdleHRpY2tzJzo1LCdjaGFydC55dGlja2dhcCc6MjAsJ2NoYXJ0LnNtYWxseXRpY2tzJzozLCdjaGFydC5sYXJnZXl0aWNrcyc6NSwnY2hhcnQubnVteXRpY2tzJzoxMCwnY2hhcnQubGluZXdpZHRoJzoyLjAxLCdjaGFydC5jb2xvcnMnOlsncmVkJywnIzBmMCcsJyMwMGYnLCcjZjBmJywnI2ZmMCcsJyMwZmYnLCdncmVlbicsJ3BpbmsnLCdibHVlJywnYmxhY2snXSwnY2hhcnQuaG1hcmdpbic6MCwnY2hhcnQudGlja21hcmtzLmRvdC5zdHJva2UnOid3aGl0ZScsJ2NoYXJ0LnRpY2ttYXJrcy5kb3QuZmlsbCc6bnVsbCwnY2hhcnQudGlja21hcmtzLmRvdC5saW5ld2lkdGgnOjMsJ2NoYXJ0LnRpY2ttYXJrcyc6J2VuZGNpcmNsZScsJ2NoYXJ0LnRpY2ttYXJrcy5saW5ld2lkdGgnOm51bGwsJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZSc6bnVsbCwnY2hhcnQudGlja21hcmtzLmltYWdlLmhhbGlnbic6J2NlbnRlcicsJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS52YWxpZ24nOidjZW50ZXInLCdjaGFydC50aWNrbWFya3MuaW1hZ2Uub2Zmc2V0eCc6MCwnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHknOjAsJ2NoYXJ0LnRpY2tzaXplJzozLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzozMCwnY2hhcnQudGlja2RpcmVjdGlvbic6LTEsJ2NoYXJ0LnlheGlzcG9pbnRzJzo1LCdjaGFydC5maWxsc3R5bGUnOm51bGwsJ2NoYXJ0LnhheGlzcG9zJzonYm90dG9tJywnY2hhcnQueGF4aXNwb3MudmFsdWUnOjAsJ2NoYXJ0LnlheGlzcG9zJzonbGVmdCcsJ2NoYXJ0Lnh0aWNrcyc6bnVsbCwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5hbmdsZSc6MCwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LnltaW4nOjAsJ2NoYXJ0LnltYXgnOm51bGwsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMnOicnLCdjaGFydC50aXRsZS54YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS54YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMnOicnLCdjaGFydC50aXRsZS55YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS55YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMucG9zJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5wb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLnknOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmhhbGlnbic6bnVsbCwnY2hhcnQudGl0bGUudmFsaWduJzpudWxsLCdjaGFydC5zaGFkb3cnOnRydWUsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzoyLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6J3JnYmEoMTI4LDEyOCwxMjgsMC41KScsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5ob3RzcG90Lnhvbmx5JzpmYWxzZSwnY2hhcnQudG9vbHRpcHMuaG90c3BvdC5zaXplJzo1LCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29ubW91c2Vtb3ZlJywnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6ZmFsc2UsJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSc6bnVsbCwnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J2dyYXknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3doaXRlJywnY2hhcnQuc3RlcHBlZCc6ZmFsc2UsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LmhhbGlnbic6bnVsbCwnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzonc3F1YXJlJywnY2hhcnQua2V5LnJvdW5kZWQnOnRydWUsJ2NoYXJ0LmtleS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmtleS5jb2xvcnMnOm51bGwsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6ZmFsc2UsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzoncmdiYSgyNTUsMCwwLDAuMyknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LnlsYWJlbHMnOnRydWUsJ2NoYXJ0LnlsYWJlbHMuY291bnQnOjUsJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJzpmYWxzZSwnY2hhcnQueWxhYmVscy5vZmZzZXR4JzowLCdjaGFydC55bGFiZWxzLm9mZnNldHknOjAsJ2NoYXJ0LnNjYWxlLmludmVydCc6ZmFsc2UsJ2NoYXJ0LnhsYWJlbHMuaW5zaWRlJzpmYWxzZSwnY2hhcnQueGxhYmVscy5pbnNpZGUuY29sb3InOidyZ2JhKDI1NSwyNTUsMjU1LDAuNSknLCdjaGFydC5ub2F4ZXMnOmZhbHNlLCdjaGFydC5ub3lheGlzJzpmYWxzZSwnY2hhcnQubm94YXhpcyc6ZmFsc2UsJ2NoYXJ0Lm5vZW5keHRpY2snOmZhbHNlLCdjaGFydC5ub2VuZHl0aWNrJzpmYWxzZSwnY2hhcnQudW5pdHMucG9zdCc6JycsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCc6dHJ1ZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOm51bGwsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LmNyb3NzaGFpcnMnOmZhbHNlLCdjaGFydC5jcm9zc2hhaXJzLmNvbG9yJzonIzMzMycsJ2NoYXJ0LmNyb3NzaGFpcnMuaGxpbmUnOnRydWUsJ2NoYXJ0LmNyb3NzaGFpcnMudmxpbmUnOnRydWUsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0LmF4ZXNvbnRvcCc6ZmFsc2UsJ2NoYXJ0LmZpbGxlZCc6ZmFsc2UsJ2NoYXJ0LmZpbGxlZC5yYW5nZSc6ZmFsc2UsJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQnOm51bGwsJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQuY29sb3JzJzpbJ3JlZCcsJ2dyZWVuJ10sJ2NoYXJ0LmZpbGxlZC5hY2N1bXVsYXRpdmUnOnRydWUsJ2NoYXJ0LnZhcmlhbnQnOm51bGwsJ2NoYXJ0LmF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0LmF4aXMubGluZXdpZHRoJzoxLCdjaGFydC5udW14dGlja3MnOihkYXRhJiZ0eXBlb2YoZGF0YVswXSk9PSdudW1iZXInP2RhdGEubGVuZ3RoLTE6KHR5cGVvZiBkYXRhWzBdPT09J29iamVjdCcmJmRhdGFbMF0mJnR5cGVvZiBkYXRhWzBdWzBdPT09J251bWJlcic/ZGF0YVswXS5sZW5ndGgtMToyMCkpLCdjaGFydC5udW15dGlja3MnOjEwLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlLCdjaGFydC56b29tLmFjdGlvbic6J3pvb20nLCdjaGFydC5iYWNrZHJvcCc6ZmFsc2UsJ2NoYXJ0LmJhY2tkcm9wLnNpemUnOjMwLCdjaGFydC5iYWNrZHJvcC5hbHBoYSc6MC4yLCdjaGFydC5yZXNpemFibGUnOmZhbHNlLCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCc6WzAsMF0sJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFkanVzdGFibGUub25seSc6bnVsbCwnY2hhcnQubm9yZWRyYXcnOmZhbHNlLCdjaGFydC5vdXRvZmJvdW5kcyc6ZmFsc2UsJ2NoYXJ0Lm91dG9mYm91bmRzLmNsaXAnOmZhbHNlLCdjaGFydC5jaHJvbWVmaXgnOnRydWUsJ2NoYXJ0LmFuaW1hdGlvbi5mYWN0b3InOjEsJ2NoYXJ0LmFuaW1hdGlvbi51bmZvbGQueCc6ZmFsc2UsJ2NoYXJ0LmFuaW1hdGlvbi51bmZvbGQueSc6dHJ1ZSwnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC5pbml0aWFsJzoyLCdjaGFydC5hbmltYXRpb24udHJhY2UuY2xpcCc6MSwnY2hhcnQuY3VydnknOmZhbHNlLCdjaGFydC5saW5lLnZpc2libGUnOltdLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmVycm9yYmFycyc6ZmFsc2UsJ2NoYXJ0LmVycm9yYmFycy5jb2xvcic6J2JsYWNrJywnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZCc6dHJ1ZSwnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZC53aWR0aCc6MTIsJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnOjEsJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0JzpudWxsLCdjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdC5vcHRpb25zJzpudWxsLCdjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdC5jYWxsYmFjayc6bnVsbCwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5kb3R0ZWQnOmZhbHNlLCdjaGFydC5kYXNoZWQnOmZhbHNlfVxuZm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoOysraSl7aWYodHlwZW9mKGFyZ3VtZW50c1tpXSk9PSdudWxsJ3x8IWFyZ3VtZW50c1tpXSl7YXJndW1lbnRzW2ldPVtdO319XG50aGlzLm9yaWdpbmFsX2RhdGE9W107aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmY29uZi5kYXRhKXtpZih0eXBlb2YgY29uZi5kYXRhWzBdPT09J251bWJlcid8fFJHcmFwaC5pc051bGwoY29uZi5kYXRhWzBdKSl7dGhpcy5vcmlnaW5hbF9kYXRhWzBdPVJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YSk7fWVsc2V7Zm9yKHZhciBpPTA7aTxjb25mLmRhdGEubGVuZ3RoOysraSl7dGhpcy5vcmlnaW5hbF9kYXRhW2ldPVJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YVtpXSk7fX19ZWxzZXtmb3IodmFyIGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXtpZihhcmd1bWVudHNbMV0mJnR5cGVvZihhcmd1bWVudHNbMV0pPT0nb2JqZWN0JyYmYXJndW1lbnRzWzFdWzBdJiZ0eXBlb2YoYXJndW1lbnRzWzFdWzBdKT09J29iamVjdCcmJmFyZ3VtZW50c1sxXVswXS5sZW5ndGgpe3ZhciB0bXA9W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHNbMV0ubGVuZ3RoOysraSl7dG1wW2ldPVJHcmFwaC5hcnJheV9jbG9uZShhcmd1bWVudHNbMV1baV0pO31cbmZvcih2YXIgaj0wO2o8dG1wLmxlbmd0aDsrK2ope3RoaXMub3JpZ2luYWxfZGF0YVtqXT1SR3JhcGguYXJyYXlfY2xvbmUodG1wW2pdKTt9fWVsc2V7dGhpcy5vcmlnaW5hbF9kYXRhW2ktMV09UkdyYXBoLmFycmF5X2Nsb25lKGFyZ3VtZW50c1tpXSk7fX19XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbTElORV0gRmF0YWwgZXJyb3I6IG5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbmZvcih2YXIgaT0wO2k8dGhpcy5vcmlnaW5hbF9kYXRhLmxlbmd0aDsrK2kpe2Zvcih2YXIgaj0wO2o8dGhpcy5vcmlnaW5hbF9kYXRhW2ldLmxlbmd0aDsrK2ope2lmKHR5cGVvZiB0aGlzLm9yaWdpbmFsX2RhdGFbaV1bal09PT0nc3RyaW5nJyl7dGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdPXBhcnNlRmxvYXQodGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdKTt9fX1cbnRoaXMuZGF0YV9hcnI9UkdyYXBoLmFycmF5TGluZWFyaXplKHRoaXMub3JpZ2luYWxfZGF0YSk7Zm9yKHZhciBpPTA7aTx0aGlzLmRhdGFfYXJyLmxlbmd0aDsrK2kpe3RoaXNbJyQnK2ldPXt9O31cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC50b29sdGlwcycmJnR5cGVvZiB2YWx1ZT09J29iamVjdCcmJnZhbHVlKXt2YXIgdG9vbHRpcHM9W107Zm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7aWYodHlwZW9mKGFyZ3VtZW50c1tpXSk9PSdvYmplY3QnJiZhcmd1bWVudHNbaV1bMF0pe2Zvcih2YXIgaj0wO2o8YXJndW1lbnRzW2ldLmxlbmd0aDtqKyspe3Rvb2x0aXBzLnB1c2goYXJndW1lbnRzW2ldW2pdKTt9fWVsc2UgaWYodHlwZW9mKGFyZ3VtZW50c1tpXSk9PSdmdW5jdGlvbicpe3Rvb2x0aXBzPWFyZ3VtZW50c1tpXTt9ZWxzZXt0b29sdGlwcy5wdXNoKGFyZ3VtZW50c1tpXSk7fX1cbnZhbHVlPXRvb2x0aXBzO31cbmlmKG5hbWU9PSdjaGFydC5saW5ld2lkdGgnJiZuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWUvKSl7aWYodmFsdWU9PTEpe3ZhbHVlPTEuMDE7fWVsc2UgaWYoUkdyYXBoLmlzX2FycmF5KHZhbHVlKSl7Zm9yKHZhciBpPTA7aTx2YWx1ZS5sZW5ndGg7KytpKXtpZih0eXBlb2YodmFsdWVbaV0pPT0nbnVtYmVyJyYmdmFsdWVbaV09PTEpe3ZhbHVlW2ldPTEuMDE7fX19fVxuaWYobmFtZT09J2NoYXJ0LnhheGlzcG9zJyl7aWYodmFsdWUhPSdib3R0b20nJiZ2YWx1ZSE9J2NlbnRlcicmJnZhbHVlIT0ndG9wJyl7YWxlcnQoJ1tMSU5FXSAoJyt0aGlzLmlkKycpIGNoYXJ0LnhheGlzcG9zIHNob3VsZCBiZSB0b3AsIGNlbnRlciBvciBib3R0b20uIFRyaWVkIHRvIHNldCBpdCB0bzogJyt2YWx1ZSsnIENoYW5naW5nIGl0IHRvIGNlbnRlcicpO3ZhbHVlPSdjZW50ZXInO319XG5pZihuYW1lPT0nY2hhcnQueHRpY2tzJyl7bmFtZT0nY2hhcnQubnVteHRpY2tzJzt9XG5pZihuYW1lPT0nY2hhcnQuc3BsaW5lJyl7bmFtZT0nY2hhcnQuY3VydnknO31cbmlmKG5hbWU9PSdjaGFydC55bGFiZWxzLmludmVydCcpe25hbWU9J2NoYXJ0LnNjYWxlLmludmVydCc7fVxudGhpcy5wcm9wZXJ0aWVzW25hbWVdPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0LnNwbGluZScpe25hbWU9J2NoYXJ0LmN1cnZ5Jzt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue2lmKHR5cGVvZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlJ10pPT0nc3RyaW5nJyl7UkcuRHJhd0JhY2tncm91bmRJbWFnZSh0aGlzKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5kYXRhPVJHLmFycmF5X2Nsb25lKHRoaXMub3JpZ2luYWxfZGF0YSk7dGhpcy5tYXg9MDtpZihwcm9wWydjaGFydC5maWxsZWQnXSYmIXByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddJiZ0aGlzLmRhdGEubGVuZ3RoPjEmJnByb3BbJ2NoYXJ0LmZpbGxlZC5hY2N1bXVsYXRpdmUnXSl7dmFyIGFjY3VtdWxhdGlvbj1bXTtmb3IodmFyIHNldD0wO3NldDx0aGlzLmRhdGEubGVuZ3RoOysrc2V0KXtmb3IodmFyIHBvaW50PTA7cG9pbnQ8dGhpcy5kYXRhW3NldF0ubGVuZ3RoOysrcG9pbnQpe3RoaXMuZGF0YVtzZXRdW3BvaW50XT1OdW1iZXIoYWNjdW11bGF0aW9uW3BvaW50XT9hY2N1bXVsYXRpb25bcG9pbnRdOjApK3RoaXMuZGF0YVtzZXRdW3BvaW50XTthY2N1bXVsYXRpb25bcG9pbnRdPXRoaXMuZGF0YVtzZXRdW3BvaW50XTt9fX1cbmlmKHByb3BbJ2NoYXJ0LnltYXgnXSl7dGhpcy5tYXg9cHJvcFsnY2hhcnQueW1heCddO3RoaXMubWluPXByb3BbJ2NoYXJ0LnltaW4nXT9wcm9wWydjaGFydC55bWluJ106MDt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6dGhpcy5tYXgsJ21pbic6cHJvcFsnY2hhcnQueW1pbiddLCdzdHJpY3QnOnRydWUsJ3NjYWxlLnRob3VzYW5kJzpwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUuZGVjaW1hbHMnOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heD90aGlzLnNjYWxlMi5tYXg6MDtpZighcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSl7Zm9yKGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuZGF0YS5sZW5ndGg7KytkYXRhc2V0KXtpZihSR3JhcGguaXNBcnJheSh0aGlzLmRhdGFbZGF0YXNldF0pKXtmb3IodmFyIGRhdGFwb2ludD0wO2RhdGFwb2ludDx0aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoO2RhdGFwb2ludCsrKXt0aGlzLmhhc25lZ2F0aXZldmFsdWVzPSh0aGlzLmRhdGFbZGF0YXNldF1bZGF0YXBvaW50XTwwKXx8dGhpcy5oYXNuZWdhdGl2ZXZhbHVlczt9fX19fWVsc2V7dGhpcy5taW49cHJvcFsnY2hhcnQueW1pbiddP3Byb3BbJ2NoYXJ0LnltaW4nXTowO2ZvcihkYXRhc2V0PTA7ZGF0YXNldDx0aGlzLmRhdGEubGVuZ3RoOysrZGF0YXNldCl7Zm9yKHZhciBkYXRhcG9pbnQ9MDtkYXRhcG9pbnQ8dGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDtkYXRhcG9pbnQrKyl7dGhpcy5tYXg9TWF0aC5tYXgodGhpcy5tYXgsdGhpcy5kYXRhW2RhdGFzZXRdW2RhdGFwb2ludF0/TWF0aC5hYnMocGFyc2VGbG9hdCh0aGlzLmRhdGFbZGF0YXNldF1bZGF0YXBvaW50XSkpOjApO2lmKCFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddKXt0aGlzLmhhc25lZ2F0aXZldmFsdWVzPSh0aGlzLmRhdGFbZGF0YXNldF1bZGF0YXBvaW50XTwwKXx8dGhpcy5oYXNuZWdhdGl2ZXZhbHVlczt9fX1cbnRoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp0aGlzLm1heCwnbWluJzpwcm9wWydjaGFydC55bWluJ10sJ3NjYWxlLnRob3VzYW5kJzpwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUuZGVjaW1hbHMnOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heD90aGlzLnNjYWxlMi5tYXg6MDt9XG5pZihwcm9wWydjaGFydC5jb250ZXh0bWVudSddKXtSRy5TaG93Q29udGV4dCh0aGlzKTt9XG50aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5ncmFwaGFyZWE9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tO3RoaXMuaGFsZmdyYXBoYXJlYT10aGlzLmdyYXBoYXJlYS8yO3RoaXMuaGFsZlRleHRIZWlnaHQ9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10vMjtpZihwcm9wWydjaGFydC52YXJpYW50J109PSczZCcpe1JHLkRyYXczREF4ZXModGhpcyk7fVxuUkcuYmFja2dyb3VuZC5EcmF3KHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXSYmcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5oYmFycyddLmxlbmd0aD4wKXtSRy5EcmF3QmFycyh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5heGVzb250b3AnXT09ZmFsc2Upe3RoaXMuRHJhd0F4ZXMoKTt9XG5jby5zYXZlKClcbmNvLmJlZ2luUGF0aCgpO2NvLnJlY3QoMCwwLGNhLndpZHRoKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJ10sY2EuaGVpZ2h0KTtjby5jbGlwKCk7Zm9yKHZhciBpPTAsaj0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuO2krKyxqKyspe2NvLmJlZ2luUGF0aCgpO2lmKCFwcm9wWydjaGFydC5maWxsZWQnXSl7dGhpcy5TZXRTaGFkb3coaSk7fVxuaWYocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pe2lmKHR5cGVvZihwcm9wWydjaGFydC5maWxsc3R5bGUnXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC5maWxsc3R5bGUnXVtqXSl7dmFyIGZpbGw9cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ11bal07fWVsc2UgaWYodHlwZW9mKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddLnRvU3RyaW5nKCkuaW5kZXhPZignR3JhZGllbnQnKT4wKXt2YXIgZmlsbD1wcm9wWydjaGFydC5maWxsc3R5bGUnXTt9ZWxzZSBpZih0eXBlb2YocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pPT0nc3RyaW5nJyl7dmFyIGZpbGw9cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ107fX1lbHNlIGlmKHByb3BbJ2NoYXJ0LmZpbGxlZCddKXt2YXIgZmlsbD1wcm9wWydjaGFydC5jb2xvcnMnXVtqXTt9ZWxzZXt2YXIgZmlsbD1udWxsO31cbmlmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddJiZ0eXBlb2YocHJvcFsnY2hhcnQudGlja21hcmtzJ10pPT0nb2JqZWN0Jyl7dmFyIHRpY2ttYXJrcz1wcm9wWydjaGFydC50aWNrbWFya3MnXVtpXTt9ZWxzZSBpZihwcm9wWydjaGFydC50aWNrbWFya3MnXSYmdHlwZW9mKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKT09J3N0cmluZycpe3ZhciB0aWNrbWFya3M9cHJvcFsnY2hhcnQudGlja21hcmtzJ107fWVsc2UgaWYocHJvcFsnY2hhcnQudGlja21hcmtzJ10mJnR5cGVvZihwcm9wWydjaGFydC50aWNrbWFya3MnXSk9PSdmdW5jdGlvbicpe3ZhciB0aWNrbWFya3M9cHJvcFsnY2hhcnQudGlja21hcmtzJ107fWVsc2V7dmFyIHRpY2ttYXJrcz1udWxsO31cbmlmKHByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzLmNsaXAnXSl7cGEyKGNvLCdzYSBiIHIgJSAlICUgJSBjbCBiJywwLHRoaXMuZ3V0dGVyVG9wLGNhLndpZHRoLGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSk7fVxudGhpcy5kcmF3TGluZSh0aGlzLmRhdGFbaV0scHJvcFsnY2hhcnQuY29sb3JzJ11bal0sZmlsbCx0aGlzLmdldExpbmVXaWR0aChqKSx0aWNrbWFya3MsaSk7aWYocHJvcFsnY2hhcnQub3V0b2Zib3VuZHMuY2xpcCddKXtjby5yZXN0b3JlKCk7fVxuY28uc3Ryb2tlKCk7fVxuaWYocHJvcFsnY2hhcnQub3V0b2Zib3VuZHMuY2xpcCddKXtwYTIoY28sJ3NhIGIgciAlICUgJSAlIGNsIGInLDAsdGhpcy5ndXR0ZXJUb3AsY2Eud2lkdGgsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKTt9XG5pZihwcm9wWydjaGFydC5maWxsZWQnXSYmcHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddJiYhcHJvcFsnY2hhcnQuY3VydnknXSl7Zm9yKHZhciBpPTA7aTx0aGlzLmNvb3JkczIubGVuZ3RoOysraSl7Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPXRoaXMuR2V0TGluZVdpZHRoKGkpO2NvLnN0cm9rZVN0eWxlPSF0aGlzLmhpZGRlbihpKT9wcm9wWydjaGFydC5jb2xvcnMnXVtpXToncmdiYSgwLDAsMCwwKSc7Zm9yKHZhciBqPTAsbGVuPXRoaXMuY29vcmRzMltpXS5sZW5ndGg7ajxsZW47KytqKXtpZihqPT0wfHx0aGlzLmNvb3JkczJbaV1bal1bMV09PW51bGx8fCh0aGlzLmNvb3JkczJbaV1bai0xXSYmdGhpcy5jb29yZHMyW2ldW2otMV1bMV09PW51bGwpKXtjby5tb3ZlVG8odGhpcy5jb29yZHMyW2ldW2pdWzBdLHRoaXMuY29vcmRzMltpXVtqXVsxXSk7fWVsc2V7aWYocHJvcFsnY2hhcnQuc3RlcHBlZCddKXtjby5saW5lVG8odGhpcy5jb29yZHMyW2ldW2pdWzBdLHRoaXMuY29vcmRzMltpXVtqLTFdWzFdKTt9XG5jby5saW5lVG8odGhpcy5jb29yZHMyW2ldW2pdWzBdLHRoaXMuY29vcmRzMltpXVtqXVsxXSk7fX1cbmNvLnN0cm9rZSgpO31cbmlmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKXtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9J3doaXRlJztmb3IodmFyIGk9MCxsZW49dGhpcy5jb29yZHMyLmxlbmd0aDtpPGxlbjsrK2kpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO2Zvcih2YXIgaj0wO2o8dGhpcy5jb29yZHMyW2ldLmxlbmd0aDsrK2ope2lmKHR5cGVvZih0aGlzLmNvb3JkczJbaV1bal0pPT0nb2JqZWN0JyYmdHlwZW9mKHRoaXMuY29vcmRzMltpXVtqXVswXSk9PSdudW1iZXInJiZ0eXBlb2YodGhpcy5jb29yZHMyW2ldW2pdWzFdKT09J251bWJlcicpe3ZhciB0aWNrbWFya3M9dHlwZW9mKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKT09J29iamVjdCc/cHJvcFsnY2hhcnQudGlja21hcmtzJ11baV06cHJvcFsnY2hhcnQudGlja21hcmtzJ107dGhpcy5EcmF3VGljayh0aGlzLmNvb3JkczJbaV0sdGhpcy5jb29yZHMyW2ldW2pdWzBdLHRoaXMuY29vcmRzMltpXVtqXVsxXSxjby5zdHJva2VTdHlsZSxmYWxzZSxqPT0wPzA6dGhpcy5jb29yZHMyW2ldW2otMV1bMF0saj09MD8wOnRoaXMuY29vcmRzMltpXVtqLTFdWzFdLHRpY2ttYXJrcyxqLGkpO319fVxuY28uc3Ryb2tlKCk7Y28uZmlsbCgpO319ZWxzZSBpZihwcm9wWydjaGFydC5maWxsZWQnXSYmcHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddJiZwcm9wWydjaGFydC5jdXJ2eSddKXtmb3IodmFyIGk9MDtpPHRoaXMuY29vcmRzU3BsaW5lLmxlbmd0aDtpKz0xKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTtjby5saW5lV2lkdGg9dGhpcy5HZXRMaW5lV2lkdGgoaSk7Zm9yKHZhciBqPTAsbGVuPXRoaXMuY29vcmRzU3BsaW5lW2ldLmxlbmd0aDtqPGxlbjtqKz0xKXt2YXIgcG9pbnQ9dGhpcy5jb29yZHNTcGxpbmVbaV1bal07aj09MD9jby5tb3ZlVG8ocG9pbnRbMF0scG9pbnRbMV0pOmNvLmxpbmVUbyhwb2ludFswXSxwb2ludFsxXSk7fVxuY28uc3Ryb2tlKCk7fVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuY29vcmRzMi5sZW5ndGg7aTxsZW47aSs9MSl7Zm9yKHZhciBqPTAsbGVuMj10aGlzLmNvb3JkczJbaV0ubGVuZ3RoO2o8bGVuMjsrK2ope2lmKHR5cGVvZih0aGlzLmNvb3JkczJbaV1bal0pPT0nb2JqZWN0JyYmdHlwZW9mKHRoaXMuY29vcmRzMltpXVtqXVswXSk9PSdudW1iZXInJiZ0eXBlb2YodGhpcy5jb29yZHMyW2ldW2pdWzFdKT09J251bWJlcicpe3ZhciB0aWNrbWFya3M9dHlwZW9mIHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddPT0nb2JqZWN0JyYmIVJHcmFwaC5pc19udWxsKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKT9wcm9wWydjaGFydC50aWNrbWFya3MnXVtpXTpwcm9wWydjaGFydC50aWNrbWFya3MnXTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTt0aGlzLkRyYXdUaWNrKHRoaXMuY29vcmRzMltpXSx0aGlzLmNvb3JkczJbaV1bal1bMF0sdGhpcy5jb29yZHMyW2ldW2pdWzFdLHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldLGZhbHNlLGo9PTA/MDp0aGlzLmNvb3JkczJbaV1bai0xXVswXSxqPT0wPzA6dGhpcy5jb29yZHMyW2ldW2otMV1bMV0sdGlja21hcmtzLGosaSk7fX19fVxuaWYocHJvcFsnY2hhcnQub3V0b2Zib3VuZHMuY2xpcCddKXtjby5yZXN0b3JlKCk7fVxuY28ucmVzdG9yZSgpO2NvLmJlZ2luUGF0aCgpO2lmKHByb3BbJ2NoYXJ0LmF4ZXNvbnRvcCddKXt0aGlzLkRyYXdBeGVzKCk7fVxudGhpcy5EcmF3TGFiZWxzKCk7dGhpcy5EcmF3UmFuZ2UoKTtpZihwcm9wWydjaGFydC5rZXknXSYmcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoJiZSRy5EcmF3S2V5KXtSRy5EcmF3S2V5KHRoaXMscHJvcFsnY2hhcnQua2V5J10scHJvcFsnY2hhcnQuY29sb3JzJ10pO31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddKXt0aGlzLmRyYXdBYm92ZUxhYmVscygpO31cblJHLkRyYXdJbkdyYXBoTGFiZWxzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmZpbGxlZCddJiZwcm9wWydjaGFydC5maWxsZWQucmFuZ2UnXSYmdGhpcy5kYXRhLmxlbmd0aD09Mil7Y28uYmVnaW5QYXRoKCk7dmFyIGxlbj10aGlzLmNvb3Jkcy5sZW5ndGgvMjtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGU9dGhpcy5oaWRkZW4oMCk/J3JnYmEoMCwwLDAsMCknOnByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7aWYoIVJHLmlzTnVsbCh0aGlzLmNvb3Jkc1tpXVsxXSkpe2lmKGk9PTApe2NvLm1vdmVUbyh0aGlzLmNvb3Jkc1tpXVswXSx0aGlzLmNvb3Jkc1tpXVsxXSk7fWVsc2V7Y28ubGluZVRvKHRoaXMuY29vcmRzW2ldWzBdLHRoaXMuY29vcmRzW2ldWzFdKTt9fX1cbmNvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2lmKHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdKXtjby5zdHJva2VTdHlsZT10aGlzLmhpZGRlbigxKT8ncmdiYSgwLDAsMCwwKSc6cHJvcFsnY2hhcnQuY29sb3JzJ11bMV07fVxuZm9yKHZhciBpPXRoaXMuY29vcmRzLmxlbmd0aC0xO2k+PWxlbjstLWkpe2lmKCFSRy5pc19udWxsKHRoaXMuY29vcmRzW2ldWzFdKSl7aWYoaT09KHRoaXMuY29vcmRzLmxlbmd0aC0xKSl7Y28ubW92ZVRvKHRoaXMuY29vcmRzW2ldWzBdLHRoaXMuY29vcmRzW2ldWzFdKTt9ZWxzZXtjby5saW5lVG8odGhpcy5jb29yZHNbaV1bMF0sdGhpcy5jb29yZHNbaV1bMV0pO319fVxuY28uc3Ryb2tlKCk7fWVsc2UgaWYocHJvcFsnY2hhcnQuZmlsbGVkJ10mJnByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddKXthbGVydCgnW0xJTkVdIFlvdSBtdXN0IGhhdmUgb25seSB0d28gc2V0cyBvZiBkYXRhIGZvciBhIGZpbGxlZCByYW5nZSBjaGFydCcpO31cbmlmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0F4ZXM9dGhpcy5EcmF3QXhlcz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQubm9heGVzJ10pe3JldHVybjt9XG5SRy5ub1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSswLjAwMTtjby5saW5lQ2FwPSdzcXVhcmUnO2NvLmxpbmVKb2luPSdtaXRlcic7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO2Nvb3Jkcz17eGF4aXM6e30seWF4aXM6e319O2NvLmJlZ2luUGF0aCgpO2lmKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXT09ZmFsc2Upe2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXtjb29yZHMueGF4aXM9W3RoaXMuZ3V0dGVyTGVmdCxtYS5yb3VuZCgodGhpcy5ncmFwaGFyZWEvMikrdGhpcy5ndXR0ZXJUb3ApLGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsbWEucm91bmQoKHRoaXMuZ3JhcGhhcmVhLzIpK3RoaXMuZ3V0dGVyVG9wKV07fWVsc2UgaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09PSd0b3AnKXtjb29yZHMueGF4aXM9W3RoaXMuZ3V0dGVyTGVmdCx0aGlzLmd1dHRlclRvcCxjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LHRoaXMuZ3V0dGVyVG9wXTt9ZWxzZXt2YXIgeT1tYS5yb3VuZCh0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10hPTA/cHJvcFsnY2hhcnQueW1pbiddOjApKTtpZihwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSYmcHJvcFsnY2hhcnQueW1pbiddPT09MCl7eT10aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlMi5tYXgpO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddfHxwcm9wWydjaGFydC55bWluJ108MCl7eT10aGlzLmdldFlDb29yZCgwKTt9XG5jb29yZHMueGF4aXM9W3RoaXMuZ3V0dGVyTGVmdCx5LGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQseV07fVxuY28ubW92ZVRvKGNvb3Jkcy54YXhpc1swXSxjb29yZHMueGF4aXNbMV0pO2NvLmxpbmVUbyhjb29yZHMueGF4aXNbMl0sY29vcmRzLnhheGlzWzNdKTt0aGlzLmNvb3Jkc0F4ZXM9Y29vcmRzO31cbmlmKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXT09ZmFsc2Upe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jyl7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pO31lbHNle2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pO319XG5pZihwcm9wWydjaGFydC5ub3hheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW14dGlja3MnXT4wKXt2YXIgeFRpY2tJbnRlcnZhbD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO2lmKCF4VGlja0ludGVydmFsfHx4VGlja0ludGVydmFsPD0wKXt4VGlja0ludGVydmFsPShjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvKHByb3BbJ2NoYXJ0LmxhYmVscyddJiZwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg/cHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoLTE6MTApO31cbmZvcih4PXRoaXMuZ3V0dGVyTGVmdCsocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3hUaWNrSW50ZXJ2YWw6MCk7eDw9KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrMSk7eCs9eFRpY2tJbnRlcnZhbCl7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0JyYmeD49KGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQtMSkpe2JyZWFrO31cbmlmKHByb3BbJ2NoYXJ0Lm5vZW5keHRpY2snXSl7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnJiZ4Pj0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC0xKSl7YnJlYWs7fWVsc2UgaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0JyYmeD09dGhpcy5ndXR0ZXJMZWZ0KXtjb250aW51ZTt9fVxudmFyIHlTdGFydD1wcm9wWydjaGFydC54YXhpc3BvcyddPT09J2NlbnRlcic/KHRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8yKSktMzpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b207dmFyIHlFbmQ9cHJvcFsnY2hhcnQueGF4aXNwb3MnXT09PSdjZW50ZXInP3lTdGFydCs2OmNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS0oeCU2MD09MD9wcm9wWydjaGFydC5sYXJnZXh0aWNrcyddKnByb3BbJ2NoYXJ0LnRpY2tkaXJlY3Rpb24nXTpwcm9wWydjaGFydC5zbWFsbHh0aWNrcyddKnByb3BbJ2NoYXJ0LnRpY2tkaXJlY3Rpb24nXSk7aWYocHJvcFsnY2hhcnQueW1pbiddPj0wJiZwcm9wWydjaGFydC54YXhpc3BvcyddPT09J2JvdHRvbScpe3ZhciB5U3RhcnQ9dGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKS0ocHJvcFsnY2hhcnQueW1pbiddPj0wPzA6MykseUVuZD10aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pKzM7aWYocHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10pe3lTdGFydD1jYS5oZWlnaHQtcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3lFbmQ9eVN0YXJ0KzM7fX1lbHNlIGlmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXt2YXIgeVN0YXJ0PU1hdGgucm91bmQoKHRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8yKSkpLTMseUVuZD15U3RhcnQrNjt9ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nYm90dG9tJyl7dmFyIHlTdGFydD10aGlzLmdldFlDb29yZCgwKS0ocHJvcFsnY2hhcnQueW1pbiddIT09MD8zOjApLHlFbmQ9dGhpcy5nZXRZQ29vcmQoMCktKHglNjA9PTA/cHJvcFsnY2hhcnQubGFyZ2V4dGlja3MnXSpwcm9wWydjaGFydC50aWNrZGlyZWN0aW9uJ106cHJvcFsnY2hhcnQuc21hbGx4dGlja3MnXSpwcm9wWydjaGFydC50aWNrZGlyZWN0aW9uJ10pO3lFbmQrPTA7fWVsc2UgaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3lTdGFydD10aGlzLmd1dHRlclRvcC0zO3lFbmQ9dGhpcy5ndXR0ZXJUb3A7fVxuY28ubW92ZVRvKG1hLnJvdW5kKHgpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHlFbmQpO319ZWxzZSBpZihwcm9wWydjaGFydC5ub3lheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW15dGlja3MnXT4wKXtpZighcHJvcFsnY2hhcnQubm9lbmR5dGljayddKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LXByb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ10sTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTt9ZWxzZXtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCxNYXRoLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0K3Byb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ10sTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTt9fX1cbnZhciBudW15dGlja3M9cHJvcFsnY2hhcnQubnVteXRpY2tzJ107aWYocHJvcFsnY2hhcnQubm95YXhpcyddPT1mYWxzZSYmbnVteXRpY2tzPjApe3ZhciBjb3VudGVyPTAsYWRqdXN0bWVudD0wO2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdyaWdodCcpe2FkanVzdG1lbnQ9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KTt9XG5pZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7dmFyIGludGVydmFsPSh0aGlzLmdyYXBoYXJlYS9udW15dGlja3MpO3ZhciBsaW5ldG89KHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQ6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCtwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddKTtmb3IoeT10aGlzLmd1dHRlclRvcDt5PCh0aGlzLmdyYXBoYXJlYS8yKSt0aGlzLmd1dHRlclRvcDt5Kz1pbnRlcnZhbCl7aWYoeTwodGhpcy5ncmFwaGFyZWEvMikrdGhpcy5ndXR0ZXJUb3Ape2NvLm1vdmVUbygocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdC1wcm9wWydjaGFydC5zbWFsbHl0aWNrcyddOmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpLE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyhsaW5ldG8sTWF0aC5yb3VuZCh5KSk7fX1cbmZvcih5PXRoaXMuZ3V0dGVyVG9wKyh0aGlzLmhhbGZncmFwaGFyZWEpK2ludGVydmFsO3k8PXRoaXMuZ3JhcGhhcmVhK3RoaXMuZ3V0dGVyVG9wO3krPWludGVydmFsKXtjby5tb3ZlVG8oKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQtcHJvcFsnY2hhcnQuc21hbGx5dGlja3MnXTpjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSxNYXRoLnJvdW5kKHkpKTtjby5saW5lVG8obGluZXRvLE1hdGgucm91bmQoeSkpO319ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJyl7dmFyIGludGVydmFsPSh0aGlzLmdyYXBoYXJlYS9udW15dGlja3MpO3ZhciBsaW5ldG89KHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQ6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCtwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddKTtmb3IoeT10aGlzLmd1dHRlclRvcCtpbnRlcnZhbDt5PD10aGlzLmdyYXBoYXJlYSt0aGlzLmd1dHRlckJvdHRvbTt5Kz1pbnRlcnZhbCl7Y28ubW92ZVRvKChwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/dGhpcy5ndXR0ZXJMZWZ0LXByb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ106Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCksTWF0aC5yb3VuZCh5KSk7Y28ubGluZVRvKGxpbmV0byxNYXRoLnJvdW5kKHkpKTt9XG5pZihwcm9wWydjaGFydC5ub3hheGlzJ10mJnByb3BbJ2NoYXJ0Lm5vZW5keXRpY2snXT09ZmFsc2Upe2NvLm1vdmVUbygocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdC1wcm9wWydjaGFydC5zbWFsbHl0aWNrcyddOmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpLHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8obGluZXRvLHRoaXMuZ3V0dGVyVG9wKTt9fWVsc2V7dmFyIGxpbmV0bz0ocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdC1wcm9wWydjaGFydC5zbWFsbHl0aWNrcyddOmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrcHJvcFsnY2hhcnQuc21hbGx5dGlja3MnXSk7Zm9yKHk9dGhpcy5ndXR0ZXJUb3A7eTwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSYmY291bnRlcjxudW15dGlja3M7eSs9KChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pL251bXl0aWNrcykpe2lmKG1hLnJvdW5kKHkpIT09bWEucm91bmQodGhpcy5jb29yZHNBeGVzLnhheGlzWzFdKSl7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCthZGp1c3RtZW50LG1hLnJvdW5kKHkpKTtjby5saW5lVG8obGluZXRvLG1hLnJvdW5kKHkpKTt9XG52YXIgY291bnRlcj1jb3VudGVyKzE7fVxuaWYocHJvcFsnY2hhcnQueW1pbiddPDApe2NvLm1vdmVUbygocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdDpjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSxtYS5yb3VuZCh5KSk7Y28ubGluZVRvKGxpbmV0byxtYS5yb3VuZCh5KSk7fX19ZWxzZSBpZihwcm9wWydjaGFydC5ub3hheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW14dGlja3MnXT4wKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQscHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCc/dGhpcy5ndXR0ZXJUb3A6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSd0b3AnP3RoaXMuZ3V0dGVyVG9wLXByb3BbJ2NoYXJ0LnNtYWxseHRpY2tzJ106Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK3Byb3BbJ2NoYXJ0LnNtYWxseHRpY2tzJ10pO31lbHNle2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK3Byb3BbJ2NoYXJ0LnNtYWxseHRpY2tzJ10pO319XG5jby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTt9O3RoaXMuZHJhd0xhYmVscz10aGlzLkRyYXdMYWJlbHM9ZnVuY3Rpb24oKVxue2NvLnN0cm9rZVN0eWxlPSdibGFjayc7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5saW5lV2lkdGg9MTtSRy5Ob1NoYWRvdyh0aGlzKTt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgdGV4dF9zaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciBkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO3ZhciBjb250ZXh0PWNvO3ZhciBjYW52YXM9Y2E7dmFyIHltaW49cHJvcFsnY2hhcnQueW1pbiddO2lmKHByb3BbJ2NoYXJ0LnlsYWJlbHMnXSYmcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddPT1udWxsKXt2YXIgdW5pdHNfcHJlPXByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0PXByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXTt2YXIgeHBvcz1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/dGhpcy5ndXR0ZXJMZWZ0LTU6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs1O3ZhciBhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7dmFyIG51bVlMYWJlbHM9dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDt2YXIgYm91bmRpbmc9ZmFsc2U7dmFyIGJnY29sb3I9cHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXT9wcm9wWydjaGFydC55bGFiZWxzLmluc2lkZS5jb2xvciddOm51bGw7dmFyIG9mZnNldHg9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J107dmFyIG9mZnNldHk9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR5J107aWYocHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXT09dHJ1ZSYmYWxpZ249PSdsZWZ0Jyl7eHBvcy09MTA7YWxpZ249J3JpZ2h0Jztib3VuZGluZz10cnVlO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ109PXRydWUmJmFsaWduPT0ncmlnaHQnKXt4cG9zKz0xMDthbGlnbj0nbGVmdCc7Ym91bmRpbmc9dHJ1ZTt9XG5pZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7dmFyIGhhbGY9dGhpcy5ncmFwaGFyZWEvMjtmb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK2hhbGYtKCgoaSsxKS9udW1ZTGFiZWxzKSpoYWxmKStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW2ldLCd0YWcnOidzY2FsZSd9KTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK2hhbGYrKCgoaSsxKS9udW1ZTGFiZWxzKSpoYWxmKStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGV4dCc6Jy0nK3RoaXMuc2NhbGUyLmxhYmVsc1tpXSwndGFnJzonc2NhbGUnfSk7fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddPT10cnVlfHx5bWluIT0wfHxwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSl7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eHBvcytvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCtoYWxmK29mZnNldHksJ3RleHQnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddK3ltaW4udG9GaXhlZCh5bWluPT09MD8wOmRlY2ltYWxzKStwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ2JvdW5kaW5nJzpib3VuZGluZywnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCd0YWcnOidzY2FsZSd9KTt9fWVsc2UgaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3ZhciBoYWxmPXRoaXMuZ3JhcGhhcmVhLzI7aWYocHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10pe2Zvcih2YXIgaT0wO2k8dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsrK2kpe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArKChpL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpKnRoaXMuZ3JhcGhhcmVhKStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGV4dCc6Jy0nK3RoaXMuc2NhbGUyLmxhYmVsc1t0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoLShpKzEpXSwndGFnJzonc2NhbGUnfSk7fX1lbHNle2Zvcih2YXIgaT0wO2k8dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsrK2kpe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArKCgoaSsxKS9udW1ZTGFiZWxzKSp0aGlzLmdyYXBoYXJlYSkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZ0ZpbGwnOmJnY29sb3IsJ3RleHQnOictJyt0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3RhZyc6J3NjYWxlJ30pO319XG5pZigocHJvcFsnY2hhcnQueW1pbiddIT0wfHxwcm9wWydjaGFydC5ub3hheGlzJ10pfHxwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXXx8cHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pe1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6cHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10/Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHk6dGhpcy5ndXR0ZXJUb3Arb2Zmc2V0eSwndGV4dCc6KHByb3BbJ2NoYXJ0LnltaW4nXSE9MD8nLSc6JycpK1JHLm51bWJlckZvcm1hdCh0aGlzLHByb3BbJ2NoYXJ0LnltaW4nXS50b0ZpeGVkKHltaW49PT0wPzA6ZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZ0ZpbGwnOmJnY29sb3IsJ3RhZyc6J3NjYWxlJ30pO319ZWxzZXtpZihwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSl7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eHBvcytvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCtvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGV4dCc6UkcubnVtYmVyRm9ybWF0KHRoaXMsdGhpcy5taW4udG9GaXhlZChwcm9wWydjaGFydC55bWluJ109PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCd0YWcnOidzY2FsZSd9KTtmb3IodmFyIGk9MCxsZW49dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDtpPGxlbjsrK2kpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhwb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArKCgoaSsxKS90aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSp0aGlzLmdyYXBoYXJlYSkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZ0ZpbGwnOmJnY29sb3IsJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndGFnJzonc2NhbGUnfSk7fX1lbHNle2Zvcih2YXIgaT0wLGxlbj10aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoO2k8bGVuOysraSl7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eHBvcytvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCsoKGkvdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkqdGhpcy5ncmFwaGFyZWEpK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3VuZGluZywnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aC0oaSsxKV0sJ3RhZyc6J3NjYWxlJ30pO319XG5pZigocHJvcFsnY2hhcnQueW1pbiddIT0wJiYhcHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J118fHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKXx8cHJvcFsnY2hhcnQubm94YXhpcyddKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddP3RoaXMuZ3V0dGVyVG9wK29mZnNldHk6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHksJ3RleHQnOlJHLm51bWJlckZvcm1hdCh0aGlzLHByb3BbJ2NoYXJ0LnltaW4nXS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnltaW4nXT09PTA/MDpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3VuZGluZywnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd0YWcnOidzY2FsZSd9KTt9fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddPT10cnVlJiZwcm9wWydjaGFydC55bWluJ109PW51bGwmJnByb3BbJ2NoYXJ0LnhheGlzcG9zJ10hPSdjZW50ZXInJiZwcm9wWydjaGFydC5ub2VuZHl0aWNrJ109PWZhbHNlKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4cG9zK29mZnNldHgsJ3knOnByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSd0b3AnP3RoaXMuZ3V0dGVyVG9wK29mZnNldHk6KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSksJ3RleHQnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddK051bWJlcigwKS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pK3Byb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGFnJzonc2NhbGUnfSk7fX1lbHNlIGlmKHByb3BbJ2NoYXJ0LnlsYWJlbHMnXSYmdHlwZW9mKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk9PSdvYmplY3QnKXt2YXIgZ2FwPXRoaXMuZ3JhcGhhcmVhL3Byb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGg7dmFyIGhhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7dmFyIGJvdW5kaW5nPWZhbHNlO3ZhciBiZ2NvbG9yPW51bGw7dmFyIHltaW49cHJvcFsnY2hhcnQueW1pbiddIT1udWxsJiZwcm9wWydjaGFydC55bWluJ107aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnKXt2YXIgeD10aGlzLmd1dHRlckxlZnQtNTtpZihwcm9wWydjaGFydC55bGFiZWxzLmluc2lkZSddKXt4Kz0xMDtoYWxpZ249J2xlZnQnO2JvdW5kaW5nPXRydWU7Ymdjb2xvcj0ncmdiYSgyNTUsMjU1LDI1NSwwLjUpJzt9fWVsc2UgaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jyl7dmFyIHg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs1O2lmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10pe3gtPTEwO2hhbGlnbj0ncmlnaHQnO2JvdW5kaW5nPXRydWU7Ymdjb2xvcj0ncmdiYSgyNTUsMjU1LDI1NSwwLjUpJzt9fVxudmFyIG9mZnNldHg9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J107dmFyIG9mZnNldHk9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR5J107aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aDsrK2kpe3ZhciB5PXRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8oKChwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoLTEpKSoyKSppKTtpZih5bWluJiZ5bWluPjApe3ZhciB5PSgodGhpcy5ncmFwaGFyZWEvMikvKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGgtKHltaW4/MTowKSkpKmk7eSs9dGhpcy5ndXR0ZXJUb3A7fVxuUkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eCtvZmZzZXR4LCd5Jzp5K29mZnNldHksJ3RleHQnOlN0cmluZyhwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11baV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmhhbGlnbiwnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZ0ZpbGwnOmJnY29sb3IsJ3RhZyc6J3lsYWJlbHMuc3BlY2lmaWMnfSk7fVxudmFyIHJldmVyc2VkX2xhYmVscz1SRy5hcnJheV9yZXZlcnNlKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk7Zm9yKHZhciBpPTA7aTxyZXZlcnNlZF9sYWJlbHMubGVuZ3RoOysraSl7dmFyIHk9KHRoaXMuZ3JhcGhhcmVhLzIpK3RoaXMuZ3V0dGVyVG9wKygodGhpcy5ncmFwaGFyZWEvKChyZXZlcnNlZF9sYWJlbHMubGVuZ3RoLTEpKjIpKSppKTtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4K29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndGV4dCc6aT09MD8nJzpTdHJpbmcocmV2ZXJzZWRfbGFiZWxzW2ldKSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzpoYWxpZ24sJ2JvdW5kaW5nJzpib3VuZGluZywnYm91bmRpbmdGaWxsJzpiZ2NvbG9yLCd0YWcnOid5bGFiZWxzLnNwZWNpZmljJ30pO319ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJyl7dmFyIHJldmVyc2VkX2xhYmVscz1SRy5hcnJheV9yZXZlcnNlKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk7Zm9yKHZhciBpPTA7aTxyZXZlcnNlZF9sYWJlbHMubGVuZ3RoOysraSl7dmFyIHk9KHRoaXMuZ3JhcGhhcmVhLyhyZXZlcnNlZF9sYWJlbHMubGVuZ3RoLTEpKSppO3k9eSt0aGlzLmd1dHRlclRvcDtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4K29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndGV4dCc6U3RyaW5nKHJldmVyc2VkX2xhYmVsc1tpXSksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6aGFsaWduLCdib3VuZGluZyc6Ym91bmRpbmcsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwndGFnJzoneWxhYmVscy5zcGVjaWZpYyd9KTt9fWVsc2V7Zm9yKHZhciBpPTA7aTxwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoOysraSl7dmFyIHk9dGhpcy5ndXR0ZXJUb3ArKCh0aGlzLmdyYXBoYXJlYS8ocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aC0xKSkqaSk7UkcudGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eCtvZmZzZXR4LCd5Jzp5K29mZnNldHksJ3RleHQnOlN0cmluZyhwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11baV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmhhbGlnbiwnYm91bmRpbmcnOmJvdW5kaW5nLCdib3VuZGluZ0ZpbGwnOmJnY29sb3IsJ3RhZyc6J3lsYWJlbHMuc3BlY2lmaWMnfSk7fX19XG5pZihwcm9wWydjaGFydC5sYWJlbHMnXSYmcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoPjApe3ZhciB5T2Zmc2V0PTUsYm9yZGVyZWQ9ZmFsc2UsYmdjb2xvcj1udWxsXG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ118fHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgYW5nbGU9MCx2YWxpZ249J3RvcCcsaGFsaWduPSdjZW50ZXInLGJvbGQ9cHJvcFsnY2hhcnQubGFiZWxzLmJvbGQnXVxuaWYocHJvcFsnY2hhcnQueGxhYmVscy5pbnNpZGUnXSl7eU9mZnNldD0tNTtib3JkZXJlZD10cnVlO2JnY29sb3I9cHJvcFsnY2hhcnQueGxhYmVscy5pbnNpZGUuY29sb3InXTt2YWxpZ249J2JvdHRvbSc7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3ZhbGlnbj0nYm90dG9tJzt5T2Zmc2V0Kz0yO31cbmlmKHR5cGVvZihwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ10pPT0nbnVtYmVyJyYmcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddPjApe2FuZ2xlPS0xKnByb3BbJ2NoYXJ0LnRleHQuYW5nbGUnXTt2YWxpZ249J2NlbnRlcic7aGFsaWduPSdyaWdodCc7eU9mZnNldD0xMDtpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJyl7eU9mZnNldD0xMDt9fVxudmFyIG51bUxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgsb2Zmc2V0eD1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddLG9mZnNldHk9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHknXTtmb3IoaT0wO2k8bnVtTGFiZWxzOysraSl7aWYocHJvcFsnY2hhcnQubGFiZWxzJ11baV0pe3ZhciBsYWJlbFg9KChjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodC0oMipwcm9wWydjaGFydC5obWFyZ2luJ10pKS8obnVtTGFiZWxzLTEpKSppO2xhYmVsWCs9dGhpcy5ndXR0ZXJMZWZ0K3Byb3BbJ2NoYXJ0LmhtYXJnaW4nXTtpZih0aGlzLmRhdGEubGVuZ3RoPT09MHx8IXRoaXMuZGF0YVswXXx8cHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoIT10aGlzLmRhdGFbMF0ubGVuZ3RoKXtsYWJlbFg9dGhpcy5ndXR0ZXJMZWZ0K3Byb3BbJ2NoYXJ0LmhtYXJnaW4nXSsoKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0LSgyKnByb3BbJ2NoYXJ0LmhtYXJnaW4nXSkpKihpLyhwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgtMSkpKTt9XG5pZighbGFiZWxYKXtsYWJlbFg9dGhpcy5ndXR0ZXJMZWZ0K3Byb3BbJ2NoYXJ0LmhtYXJnaW4nXTt9XG5pZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJyYmcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddPjApe2hhbGlnbj0nbGVmdCc7fVxuaWYocHJvcFsnY2hhcnQudGV4dC5hbmdsZSddIT0wKXtoYWxpZ249J3JpZ2h0Jzt9XG5SRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCdib2xkJzpib2xkLCd4JzpsYWJlbFgrb2Zmc2V0eCwneSc6KHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSd0b3AnKT90aGlzLmd1dHRlclRvcC15T2Zmc2V0LShwcm9wWydjaGFydC54bGFiZWxzLmluc2lkZSddPy0yMjowKStvZmZzZXR5OihjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pK3lPZmZzZXQrb2Zmc2V0eSwndGV4dCc6U3RyaW5nKHByb3BbJ2NoYXJ0LmxhYmVscyddW2ldKSwndmFsaWduJzp2YWxpZ24sJ2hhbGlnbic6aGFsaWduLCdib3VuZGluZyc6Ym9yZGVyZWQsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwnYW5nbGUnOmFuZ2xlLCd0YWcnOidsYWJlbHMnfSk7fX19XG5jby5zdHJva2UoKTtjby5maWxsKCk7fVxudGhpcy5kcmF3TGluZT10aGlzLkRyYXdMaW5lPWZ1bmN0aW9uKGxpbmVEYXRhLGNvbG9yLGZpbGwsbGluZXdpZHRoLHRpY2ttYXJrcyxpbmRleClcbntpZihwcm9wWydjaGFydC5hbmltYXRpb24udW5mb2xkLnknXSYmcHJvcFsnY2hhcnQuYW5pbWF0aW9uLmZhY3RvciddIT0xKXtmb3IodmFyIGk9MDtpPGxpbmVEYXRhLmxlbmd0aDsrK2kpe2xpbmVEYXRhW2ldKj1wcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ107fX1cbnZhciBwZW5VcD1mYWxzZTt2YXIgeVBvcz1udWxsO3ZhciB4UG9zPTA7Y28ubGluZVdpZHRoPTE7dmFyIGxpbmVDb29yZHM9W107aWYoaW5kZXg+MCl7dmFyIHByZXZMaW5lQ29vcmRzPXRoaXMuY29vcmRzMltpbmRleC0xXTt9XG52YXIgeEludGVydmFsPShjYS53aWR0aC0oMipwcm9wWydjaGFydC5obWFyZ2luJ10pLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8obGluZURhdGEubGVuZ3RoLTEpO2ZvcihpPTAsbGVuPWxpbmVEYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgZGF0YV9wb2ludD1saW5lRGF0YVtpXTt2YXIgeVBvcz10aGlzLmdldFlDb29yZChkYXRhX3BvaW50KTtpZihsaW5lRGF0YVtpXT09bnVsbHx8KHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdib3R0b20nJiZsaW5lRGF0YVtpXTx0aGlzLm1pbiYmIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10pfHwocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicmJmxpbmVEYXRhW2ldPCgtMSp0aGlzLm1heCkmJiFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddKXx8KCgobGluZURhdGFbaV08dGhpcy5taW4mJnByb3BbJ2NoYXJ0LnhheGlzcG9zJ10hPT0nY2VudGVyJyl8fGxpbmVEYXRhW2ldPnRoaXMubWF4KSYmIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10pKXt5UG9zPW51bGw7fVxuY28ubGluZUNhcD0ncm91bmQnO2NvLmxpbmVKb2luPSdyb3VuZCc7aWYoaT4wKXt4UG9zPXhQb3MreEludGVydmFsO31lbHNle3hQb3M9cHJvcFsnY2hhcnQuaG1hcmdpbiddK3RoaXMuZ3V0dGVyTGVmdDt9XG5pZihwcm9wWydjaGFydC5hbmltYXRpb24udW5mb2xkLngnXSl7eFBvcyo9cHJvcFsnY2hhcnQuYW5pbWF0aW9uLmZhY3RvciddO2lmKHhQb3M8cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSl7eFBvcz1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO319XG50aGlzLmNvb3Jkcy5wdXNoKFt4UG9zLHlQb3NdKTtsaW5lQ29vcmRzLnB1c2goW3hQb3MseVBvc10pO31cbmNvLnN0cm9rZSgpO3RoaXMuY29vcmRzMltpbmRleF09bGluZUNvb3JkcztpZihSRy5JU09MRCYmcHJvcFsnY2hhcnQuc2hhZG93J10pe3RoaXMuRHJhd0lFU2hhZG93KGxpbmVDb29yZHMsY28uc2hhZG93Q29sb3IpO31cbmNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPSdyZ2JhKDAsMCwwLDApJztpZihmaWxsKXtjby5maWxsU3R5bGU9ZmlsbDt9XG52YXIgaXNTdGVwcGVkPXByb3BbJ2NoYXJ0LnN0ZXBwZWQnXTt2YXIgaXNGaWxsZWQ9cHJvcFsnY2hhcnQuZmlsbGVkJ107aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe3ZhciB4QXhpc1Bvcz10aGlzLmd1dHRlclRvcDt9ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7dmFyIHhBeGlzUG9zPXRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8yKTt9ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nYm90dG9tJyl7dmFyIHhBeGlzUG9zPXRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LnltaW4nXSl9XG5mb3IodmFyIGk9MCxsZW49bGluZUNvb3Jkcy5sZW5ndGg7aTxsZW47aSs9MSl7eFBvcz1saW5lQ29vcmRzW2ldWzBdO3lQb3M9bGluZUNvb3Jkc1tpXVsxXTt2YXIgc2V0PWluZGV4O3ZhciBwcmV2WT0obGluZUNvb3Jkc1tpLTFdP2xpbmVDb29yZHNbaS0xXVsxXTpudWxsKTt2YXIgaXNMYXN0PShpKzEpPT1saW5lQ29vcmRzLmxlbmd0aDtpZighcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSYmKHByZXZZPHRoaXMuZ3V0dGVyVG9wfHxwcmV2WT4oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSkpe3BlblVwPXRydWU7fVxuaWYoaT09MHx8cGVuVXB8fCF5UG9zfHwhcHJldll8fHByZXZZPHRoaXMuZ3V0dGVyVG9wKXtpZihwcm9wWydjaGFydC5maWxsZWQnXSYmIXByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddKXtpZighcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXXx8cHJldlk9PT1udWxsfHx5UG9zPT09bnVsbCl7Y28ubW92ZVRvKHhQb3MrMSx4QXhpc1Bvcyk7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe2NvLm1vdmVUbyh4UG9zKzEseEF4aXNQb3MpO31cbmlmKGlzU3RlcHBlZCYmaT4wKXtjby5saW5lVG8oeFBvcyxsaW5lQ29vcmRzW2ktMV1bMV0pO31cbmNvLmxpbmVUbyh4UG9zLHlQb3MpO31lbHNle2lmKFJHLklTT0xEJiZ5UG9zPT1udWxsKXt9ZWxzZXtjby5tb3ZlVG8oeFBvcysxLHlQb3MpO319XG5pZih5UG9zPT1udWxsKXtwZW5VcD10cnVlO31lbHNle3BlblVwPWZhbHNlO319ZWxzZXtpZihpc1N0ZXBwZWQpe2NvLmxpbmVUbyh4UG9zLGxpbmVDb29yZHNbaS0xXVsxXSk7fVxuaWYoKHlQb3M+PXRoaXMuZ3V0dGVyVG9wJiZ5UG9zPD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl8fHByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10pe2lmKGlzTGFzdCYmcHJvcFsnY2hhcnQuZmlsbGVkJ10mJiFwcm9wWydjaGFydC5maWxsZWQucmFuZ2UnXSYmcHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jyl7eFBvcy09MTt9XG5pZighaXNTdGVwcGVkfHwhaXNMYXN0KXtjby5saW5lVG8oeFBvcyx5UG9zKTtpZihpc0ZpbGxlZCYmbGluZUNvb3Jkc1tpKzFdJiZsaW5lQ29vcmRzW2krMV1bMV09PW51bGwpe2NvLmxpbmVUbyh4UG9zLHhBeGlzUG9zKTt9fWVsc2UgaWYoaXNTdGVwcGVkJiZpc0xhc3Qpe2NvLmxpbmVUbyh4UG9zLHlQb3MpO31cbnBlblVwPWZhbHNlO31lbHNle3BlblVwPXRydWU7fX19XG5pZihwcm9wWydjaGFydC5maWxsZWQnXSYmIXByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddJiYhcHJvcFsnY2hhcnQuY3VydnknXSl7dmFyIGZpbGxTdHlsZT1wcm9wWydjaGFydC5maWxsc3R5bGUnXTtpZihpbmRleD4wJiZwcm9wWydjaGFydC5maWxsZWQuYWNjdW11bGF0aXZlJ10pe2NvLmxpbmVUbyh4UG9zLHByZXZMaW5lQ29vcmRzP3ByZXZMaW5lQ29vcmRzW2ktMV1bMV06KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS0xKyhwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJz8oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yOjApKSk7Zm9yKHZhciBrPShpLTEpO2s+PTA7LS1rKXtjby5saW5lVG8oaz09MD9wcmV2TGluZUNvb3Jkc1trXVswXSsxOnByZXZMaW5lQ29vcmRzW2tdWzBdLHByZXZMaW5lQ29vcmRzW2tdWzFdKTt9fWVsc2V7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J3RvcCcpe2NvLmxpbmVUbyh4UG9zLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSsxKTtjby5saW5lVG8obGluZUNvb3Jkc1swXVswXSxwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10rMSk7fWVsc2UgaWYodHlwZW9mKGxpbmVDb29yZHNbaS0xXVsxXSk9PSdudW1iZXInKXt2YXIgeVBvc2l0aW9uPXRoaXMuZ2V0WUNvb3JkKDApO2NvLmxpbmVUbyh4UG9zLHlQb3NpdGlvbik7Y28ubGluZVRvKGxpbmVDb29yZHNbMF1bMF0seVBvc2l0aW9uKTt9fVxuY28uZmlsbFN0eWxlPSF0aGlzLmhpZGRlbihpbmRleCk/ZmlsbDoncmdiYSgwLDAsMCwwKSc7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO31cbmNvLnN0cm9rZSgpO2lmKHByb3BbJ2NoYXJ0LmJhY2tkcm9wJ10pe3RoaXMuRHJhd0JhY2tkcm9wKGxpbmVDb29yZHMsY29sb3IpO31cbmNvLnNhdmUoKTtjby5iZWdpblBhdGgoKTtjby5yZWN0KDAsMCxjYS53aWR0aCpwcm9wWydjaGFydC5hbmltYXRpb24udHJhY2UuY2xpcCddLGNhLmhlaWdodCk7Y28uY2xpcCgpO2lmKHR5cGVvZiBwcm9wWydjaGFydC5lcnJvcmJhcnMnXSE9PSdudWxsJyl7dGhpcy5kcmF3RXJyb3JiYXJzKCk7fVxudGhpcy5TZXRTaGFkb3coaW5kZXgpO3RoaXMucmVkcmF3TGluZShsaW5lQ29vcmRzLGNvbG9yLGxpbmV3aWR0aCxpbmRleCk7Y28uc3Ryb2tlKCk7UkcuTm9TaGFkb3codGhpcyk7Zm9yKHZhciBpPTA7aTxsaW5lQ29vcmRzLmxlbmd0aDsrK2kpe2k9TnVtYmVyKGkpO2NvLnN0cm9rZVN0eWxlPWNvbG9yO2lmKGlzU3RlcHBlZCYmaT09KGxpbmVDb29yZHMubGVuZ3RoLTEpKXtjby5iZWdpblBhdGgoKTt9XG5pZigodGlja21hcmtzIT0nZW5kY2lyY2xlJyYmdGlja21hcmtzIT0nZW5kc3F1YXJlJyYmdGlja21hcmtzIT0nZmlsbGVkZW5kc3F1YXJlJyYmdGlja21hcmtzIT0nZW5kdGljaycmJnRpY2ttYXJrcyE9J2VuZHRyaWFuZ2xlJyYmdGlja21hcmtzIT0nYXJyb3cnJiZ0aWNrbWFya3MhPSdmaWxsZWRhcnJvdycpfHwoaT09MCYmdGlja21hcmtzIT0nYXJyb3cnJiZ0aWNrbWFya3MhPSdmaWxsZWRhcnJvdycpfHxpPT0obGluZUNvb3Jkcy5sZW5ndGgtMSkpe3ZhciBwcmV2WD0oaTw9MD9udWxsOmxpbmVDb29yZHNbaS0xXVswXSk7dmFyIHByZXZZPShpPD0wP251bGw6bGluZUNvb3Jkc1tpLTFdWzFdKTt0aGlzLkRyYXdUaWNrKGxpbmVEYXRhLGxpbmVDb29yZHNbaV1bMF0sbGluZUNvb3Jkc1tpXVsxXSxjb2xvcixmYWxzZSxwcmV2WCxwcmV2WSx0aWNrbWFya3MsaSxpbmRleCk7fX1cbmNvLnJlc3RvcmUoKTtjby5iZWdpblBhdGgoKTtjby5hcmMoY2Eud2lkdGgrNTAwMDAsY2EuaGVpZ2h0KzUwMDAwLDIsMCw2LjM4LDEpO307dGhpcy5kcmF3VGljaz10aGlzLkRyYXdUaWNrPWZ1bmN0aW9uKGxpbmVEYXRhLHhQb3MseVBvcyxjb2xvcixpc1NoYWRvdyxwcmV2WCxwcmV2WSx0aWNrbWFya3MsaW5kZXgsZGF0YXNldClcbntpZih0aGlzLmhpZGRlbihkYXRhc2V0KSl7cmV0dXJuO31lbHNlIGlmKFJHLmlzX251bGwoeVBvcykpe3JldHVybiBmYWxzZTt9ZWxzZSBpZigoeVBvcz4oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSkmJiFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddKXtyZXR1cm47fWVsc2UgaWYoKHlQb3M8dGhpcy5ndXR0ZXJUb3ApJiYhcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSl7cmV0dXJuO31cbmNvLmJlZ2luUGF0aCgpO3ZhciBvZmZzZXQ9MDtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQudGlja21hcmtzLmxpbmV3aWR0aCddP3Byb3BbJ2NoYXJ0LnRpY2ttYXJrcy5saW5ld2lkdGgnXTpwcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5zdHJva2VTdHlsZT1pc1NoYWRvdz9wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTpjby5zdHJva2VTdHlsZTtjby5maWxsU3R5bGU9aXNTaGFkb3c/cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ106Y28uc3Ryb2tlU3R5bGU7aWYodGlja21hcmtzPT0nY2lyY2xlJ3x8dGlja21hcmtzPT0nZmlsbGVkY2lyY2xlJ3x8dGlja21hcmtzPT0nZW5kY2lyY2xlJyl7aWYodGlja21hcmtzPT0nY2lyY2xlJ3x8dGlja21hcmtzPT0nZmlsbGVkY2lyY2xlJ3x8KHRpY2ttYXJrcz09J2VuZGNpcmNsZScmJihpbmRleD09MHx8aW5kZXg9PShsaW5lRGF0YS5sZW5ndGgtMSkpKSl7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHhQb3Mrb2Zmc2V0LHlQb3Mrb2Zmc2V0LHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10sMCwzNjAvKDE4MC9SRy5QSSksZmFsc2UpO2lmKHRpY2ttYXJrcz09J2ZpbGxlZGNpcmNsZScpe2NvLmZpbGxTdHlsZT1pc1NoYWRvdz9wcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTpjby5zdHJva2VTdHlsZTt9ZWxzZXtjby5maWxsU3R5bGU9aXNTaGFkb3c/cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ106J3doaXRlJzt9XG5jby5zdHJva2UoKTtjby5maWxsKCk7fX1lbHNlIGlmKHRpY2ttYXJrcz09J2hhbGZ0aWNrJyl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcykseVBvcyk7Y28ubGluZVRvKE1hdGgucm91bmQoeFBvcykseVBvcytwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5zdHJva2UoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSd0aWNrJyl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcykseVBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4UG9zKSx5UG9zK3Byb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLnN0cm9rZSgpO31lbHNlIGlmKHRpY2ttYXJrcz09J2VuZHRpY2snJiYoaW5kZXg9PTB8fGluZGV4PT0obGluZURhdGEubGVuZ3RoLTEpKSl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcykseVBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4UG9zKSx5UG9zK3Byb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLnN0cm9rZSgpO31lbHNlIGlmKHRpY2ttYXJrcz09J2Nyb3NzJyl7Y28uYmVnaW5QYXRoKCk7dmFyIHRpY2tzaXplPXByb3BbJ2NoYXJ0LnRpY2tzaXplJ107Y28ubW92ZVRvKHhQb3MtdGlja3NpemUseVBvcy10aWNrc2l6ZSk7Y28ubGluZVRvKHhQb3MrdGlja3NpemUseVBvcyt0aWNrc2l6ZSk7Y28ubW92ZVRvKHhQb3MrdGlja3NpemUseVBvcy10aWNrc2l6ZSk7Y28ubGluZVRvKHhQb3MtdGlja3NpemUseVBvcyt0aWNrc2l6ZSk7Y28uc3Ryb2tlKCk7fWVsc2UgaWYodGlja21hcmtzPT0ndHJpYW5nbGUnfHx0aWNrbWFya3M9PSdmaWxsZWR0cmlhbmdsZSd8fCh0aWNrbWFya3M9PSdlbmR0cmlhbmdsZScmJihpbmRleD09MHx8aW5kZXg9PShsaW5lRGF0YS5sZW5ndGgtMSkpKSl7Y28uYmVnaW5QYXRoKCk7aWYodGlja21hcmtzPT0nZmlsbGVkdHJpYW5nbGUnKXtjby5maWxsU3R5bGU9aXNTaGFkb3c/cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ106Y28uc3Ryb2tlU3R5bGU7fWVsc2V7Y28uZmlsbFN0eWxlPSd3aGl0ZSc7fVxuY28ubW92ZVRvKG1hLnJvdW5kKHhQb3MtcHJvcFsnY2hhcnQudGlja3NpemUnXSkseVBvcytwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8obWEucm91bmQoeFBvcykseVBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8obWEucm91bmQoeFBvcytwcm9wWydjaGFydC50aWNrc2l6ZSddKSx5UG9zK3Byb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdib3JkZXJlZGNpcmNsZSd8fHRpY2ttYXJrcz09J2RvdCcpe2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC50aWNrbWFya3MuZG90LmxpbmV3aWR0aCddfHwwLjAwMDAwMDAxO3BhMihjbyxbJ2InLCdhJyx4UG9zLHlQb3MscHJvcFsnY2hhcnQudGlja3NpemUnXSwwLDM2MC8oMTgwL1JHLlBJKSxmYWxzZSwnYycsJ2YnLHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5kb3QuZmlsbCddfHxjb2xvciwncycscHJvcFsnY2hhcnQudGlja21hcmtzLmRvdC5zdHJva2UnXXx8Y29sb3JdKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdzcXVhcmUnfHx0aWNrbWFya3M9PSdmaWxsZWRzcXVhcmUnfHwodGlja21hcmtzPT0nZW5kc3F1YXJlJyYmKGluZGV4PT0wfHxpbmRleD09KGxpbmVEYXRhLmxlbmd0aC0xKSkpfHwodGlja21hcmtzPT0nZmlsbGVkZW5kc3F1YXJlJyYmKGluZGV4PT0wfHxpbmRleD09KGxpbmVEYXRhLmxlbmd0aC0xKSkpKXtjby5maWxsU3R5bGU9J3doaXRlJztjby5zdHJva2VTdHlsZT1jby5zdHJva2VTdHlsZTtjby5iZWdpblBhdGgoKTtjby5yZWN0KE1hdGgucm91bmQoeFBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKSxNYXRoLnJvdW5kKHlQb3MtcHJvcFsnY2hhcnQudGlja3NpemUnXSkscHJvcFsnY2hhcnQudGlja3NpemUnXSoyLHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10qMik7aWYodGlja21hcmtzPT0nZmlsbGVkc3F1YXJlJ3x8dGlja21hcmtzPT0nZmlsbGVkZW5kc3F1YXJlJyl7Y28uZmlsbFN0eWxlPWlzU2hhZG93P3Byb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddOmNvLnN0cm9rZVN0eWxlO2NvLnJlY3QoTWF0aC5yb3VuZCh4UG9zLXByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pLE1hdGgucm91bmQoeVBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKSxwcm9wWydjaGFydC50aWNrc2l6ZSddKjIscHJvcFsnY2hhcnQudGlja3NpemUnXSoyKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdzcXVhcmUnfHx0aWNrbWFya3M9PSdlbmRzcXVhcmUnKXtjby5maWxsU3R5bGU9aXNTaGFkb3c/cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ106J3doaXRlJztjby5yZWN0KE1hdGgucm91bmQoKHhQb3MtcHJvcFsnY2hhcnQudGlja3NpemUnXSkrMSksTWF0aC5yb3VuZCgoeVBvcy1wcm9wWydjaGFydC50aWNrc2l6ZSddKSsxKSwocHJvcFsnY2hhcnQudGlja3NpemUnXSoyKS0yLChwcm9wWydjaGFydC50aWNrc2l6ZSddKjIpLTIpO31cbmNvLnN0cm9rZSgpO2NvLmZpbGwoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdmaWxsZWRhcnJvdycpe3ZhciB4PU1hdGguYWJzKHhQb3MtcHJldlgpO3ZhciB5PU1hdGguYWJzKHlQb3MtcHJldlkpO2lmKHlQb3M8cHJldlkpe3ZhciBhPU1hdGguYXRhbih4L3kpKzEuNTc7fWVsc2V7dmFyIGE9TWF0aC5hdGFuKHkveCkrMy4xNDt9XG5jby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpKTtjby5hcmMoTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpLDcsYS0wLjUsYSswLjUsZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdhcnJvdycpe3ZhciBvcmlnX2xpbmV3aWR0aD1jby5saW5lV2lkdGg7dmFyIHg9TWF0aC5hYnMoeFBvcy1wcmV2WCk7dmFyIHk9TWF0aC5hYnMoeVBvcy1wcmV2WSk7Y28ubGluZVdpZHRoO2lmKHlQb3M8cHJldlkpe3ZhciBhPU1hdGguYXRhbih4L3kpKzEuNTc7fWVsc2V7dmFyIGE9TWF0aC5hdGFuKHkveCkrMy4xNDt9XG5jby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpKTtjby5hcmMoTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpLDcsYS0wLjUtKGRvYy5hbGw/MC4xOjAuMDEpLGEtMC40LGZhbHNlKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpKTtjby5hcmMoTWF0aC5yb3VuZCh4UG9zKSxNYXRoLnJvdW5kKHlQb3MpLDcsYSswLjUrKGRvYy5hbGw/MC4xOjAuMDEpLGErMC41LHRydWUpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5saW5lV2lkdGg9b3JpZ19saW5ld2lkdGg7fWVsc2UgaWYodHlwZW9mIHRpY2ttYXJrcz09PSdzdHJpbmcnJiYodGlja21hcmtzLnN1YnN0cigwLDYpPT09J2ltYWdlOid8fHRpY2ttYXJrcy5zdWJzdHIoMCw1KT09PSdkYXRhOid8fHRpY2ttYXJrcy5zdWJzdHIoMCwxKT09PScvJ3x8dGlja21hcmtzLnN1YnN0cigwLDMpPT09Jy4uLyd8fHRpY2ttYXJrcy5zdWJzdHIoMCw3KT09PSdpbWFnZXMvJykpe3ZhciBpbWc9bmV3IEltYWdlKCk7aWYodGlja21hcmtzLnN1YnN0cigwLDYpPT09J2ltYWdlOicpe2ltZy5zcmM9dGlja21hcmtzLnN1YnN0cig2KTt9ZWxzZXtpbWcuc3JjPXRpY2ttYXJrczt9XG5pbWcub25sb2FkPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UuaGFsaWduJ109PT0nY2VudGVyJyl4UG9zLT0odGhpcy53aWR0aC8yKTtpZihwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UuaGFsaWduJ109PT0ncmlnaHQnKXhQb3MtPXRoaXMud2lkdGg7aWYocHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbiddPT09J2NlbnRlcicpeVBvcy09KHRoaXMuaGVpZ2h0LzIpO2lmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS52YWxpZ24nXT09PSdib3R0b20nKXlQb3MtPXRoaXMuaGVpZ2h0O3hQb3MrPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR4J107eVBvcys9cHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHknXTtjby5kcmF3SW1hZ2UodGhpcyx4UG9zLHlQb3MpO307fWVsc2UgaWYodHlwZW9mKHRpY2ttYXJrcyk9PSdmdW5jdGlvbicpe3RpY2ttYXJrcyh0aGlzLGxpbmVEYXRhLGxpbmVEYXRhW2luZGV4XSxpbmRleCx4UG9zLHlQb3MsY29sb3IscHJldlgscHJldlkpO319O3RoaXMuZHJhd1JhbmdlPXRoaXMuRHJhd1JhbmdlPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5maWxsZWQucmFuZ2UnXSYmcHJvcFsnY2hhcnQuZmlsbGVkJ10pe2lmKFJHLmlzTnVsbChwcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkJ10pKXtwcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkJ109dGhpcy55bWluXG5wcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkLmNvbG9ycyddPVtwcm9wWydjaGFydC5maWxsc3R5bGUnXSxwcm9wWydjaGFydC5maWxsc3R5bGUnXV19XG5mb3IodmFyIGlkeD0wO2lkeDwyOysraWR4KXt2YXIgdGhyZXNob2xkX2NvbG9ycz1wcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkLmNvbG9ycyddO3ZhciB5PXRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQnXSlcbmNvLnNhdmUoKTtpZihpZHg9PTApe2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoMCwwLGNhLndpZHRoLHkpO2NvLmNsaXAoKTt9ZWxzZXtjby5iZWdpblBhdGgoKTtjby5yZWN0KDAseSxjYS53aWR0aCxjYS5oZWlnaHQpO2NvLmNsaXAoKTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9KGlkeD09MT9wcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkLmNvbG9ycyddWzFdOnByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQuY29sb3JzJ11bMF0pO2NvLmxpbmVXaWR0aD0hdGhpcy5oaWRkZW4oaWR4KT8xOjA7dmFyIGxlbj0odGhpcy5jb29yZHMubGVuZ3RoLzIpO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7aWYoIVJHLmlzX251bGwodGhpcy5jb29yZHNbaV1bMV0pKXtpZihpPT0wKXtjby5tb3ZlVG8odGhpcy5jb29yZHNbaV1bMF0sdGhpcy5jb29yZHNbaV1bMV0pfWVsc2V7Y28ubGluZVRvKHRoaXMuY29vcmRzW2ldWzBdLHRoaXMuY29vcmRzW2ldWzFdKX19fVxuZm9yKHZhciBpPXRoaXMuY29vcmRzLmxlbmd0aC0xO2k+PWxlbjstLWkpe2lmKFJHLmlzX251bGwodGhpcy5jb29yZHNbaV1bMV0pKXtjby5tb3ZlVG8odGhpcy5jb29yZHNbaV1bMF0sdGhpcy5jb29yZHNbaV1bMV0pfWVsc2V7Y28ubGluZVRvKHRoaXMuY29vcmRzW2ldWzBdLHRoaXMuY29vcmRzW2ldWzFdKX19XG5jby5maWxsKCk7Y28ucmVzdG9yZSgpO319fTt0aGlzLnJlZHJhd0xpbmU9dGhpcy5SZWRyYXdMaW5lPWZ1bmN0aW9uKGNvb3Jkcyxjb2xvcixsaW5ld2lkdGgsaW5kZXgpXG57aWYocHJvcFsnY2hhcnQubm9yZWRyYXcnXXx8cHJvcFsnY2hhcnQuZmlsbGVkLnJhbmdlJ10pe3JldHVybjt9XG5jby5zdHJva2VTdHlsZT0odHlwZW9mKGNvbG9yKT09J29iamVjdCcmJmNvbG9yJiZjb2xvci50b1N0cmluZygpLmluZGV4T2YoJ0NhbnZhc0dyYWRpZW50Jyk9PS0xP2NvbG9yWzBdOmNvbG9yKTtjby5saW5lV2lkdGg9bGluZXdpZHRoO2lmKHByb3BbJ2NoYXJ0LmRhc2hlZCddKXtjby5zZXRMaW5lRGFzaChbMiw2XSl9ZWxzZSBpZihwcm9wWydjaGFydC5kb3R0ZWQnXSl7Y28uc2V0TGluZURhc2goWzEsNV0pfVxuaWYodGhpcy5oaWRkZW4oaW5kZXgpKXtjby5zdHJva2VTdHlsZT0ncmdiYSgwLDAsMCwwKSc7fVxuaWYoIVJHLklTT0xEJiYocHJvcFsnY2hhcnQuY3VydnknXXx8cHJvcFsnY2hhcnQuc3BsaW5lJ10pKXt0aGlzLkRyYXdDdXJ2eUxpbmUoY29vcmRzLHRoaXMuaGlkZGVuKGluZGV4KT8ncmdiYSgwLDAsMCwwKSc6Y29sb3IsbGluZXdpZHRoLGluZGV4KTtyZXR1cm47fVxuY28uYmVnaW5QYXRoKCk7dmFyIGxlbj1jb29yZHMubGVuZ3RoO3ZhciB3aWR0aD1jYS53aWR0aFxudmFyIGhlaWdodD1jYS5oZWlnaHQ7dmFyIHBlblVwPWZhbHNlO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7dmFyIHhQb3M9Y29vcmRzW2ldWzBdO3ZhciB5UG9zPWNvb3Jkc1tpXVsxXTtpZihpPjApe3ZhciBwcmV2WD1jb29yZHNbaS0xXVswXTt2YXIgcHJldlk9Y29vcmRzW2ktMV1bMV07fVxuaWYoKChpPT0wJiZjb29yZHNbaV0pfHwoeVBvczx0aGlzLmd1dHRlclRvcCl8fChwcmV2WTx0aGlzLmd1dHRlclRvcCl8fCh5UG9zPihoZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKXx8KGk+MCYmcHJldlg+KHdpZHRoLXRoaXMuZ3V0dGVyUmlnaHQpKXx8KGk+MCYmcHJldlk+KGhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpfHxwcmV2WT09bnVsbHx8cGVuVXA9PXRydWUpJiYoIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ118fHlQb3M9PW51bGx8fHByZXZZPT1udWxsKSl7aWYoUkcuSVNPTEQmJnlQb3M9PW51bGwpe31lbHNle2NvLm1vdmVUbyhjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdKTt9XG5wZW5VcD1mYWxzZTt9ZWxzZXtpZihwcm9wWydjaGFydC5zdGVwcGVkJ10mJmk+MCl7Y28ubGluZVRvKGNvb3Jkc1tpXVswXSxjb29yZHNbaS0xXVsxXSk7fVxuY28ubGluZVRvKGNvb3Jkc1tpXVswXSxjb29yZHNbaV1bMV0pO3BlblVwPWZhbHNlO319XG5pZihwcm9wWydjaGFydC5jb2xvcnMuYWx0ZXJuYXRlJ10mJnR5cGVvZihjb2xvcik9PSdvYmplY3QnJiZjb2xvclswXSYmY29sb3JbMV0pe2Zvcih2YXIgaT0xO2k8bGVuOysraSl7dmFyIHByZXZYPWNvb3Jkc1tpLTFdWzBdO3ZhciBwcmV2WT1jb29yZHNbaS0xXVsxXTtpZihwcmV2WSE9bnVsbCYmY29vcmRzW2ldWzFdIT1udWxsKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1jb2xvcltjb29yZHNbaV1bMV08cHJldlk/MDoxXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28ubW92ZVRvKHByZXZYLHByZXZZKTtjby5saW5lVG8oY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSk7Y28uc3Ryb2tlKCk7fX19XG5pZihwcm9wWydjaGFydC5kYXNoZWQnXXx8cHJvcFsnY2hhcnQuZG90dGVkJ10pe2NvLnNldExpbmVEYXNoKFsxLDBdKTt9fTt0aGlzLmRyYXdJRVNoYWRvdz10aGlzLkRyYXdJRVNoYWRvdz1mdW5jdGlvbihjb29yZHMsY29sb3IpXG57dmFyIG9mZnNldHg9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTt2YXIgb2Zmc2V0eT1wcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5zdHJva2VTdHlsZT1jb2xvcjtjby5iZWdpblBhdGgoKTtmb3IodmFyIGk9MDtpPGNvb3Jkcy5sZW5ndGg7KytpKXt2YXIgaXNOdWxsPVJHLmlzTnVsbChjb29yZHNbaV1bMV0pO3ZhciBwcmV2SXNOdWxsPVJHLmlzTnVsbChjb29yZHNbaS0xXSl8fFJHLmlzTnVsbChjb29yZHNbaS0xXVsxXSk7aWYoaT09MHx8aXNOdWxsfHxwcmV2SXNOdWxsKXtpZighaXNOdWxsKXtjby5tb3ZlVG8oY29vcmRzW2ldWzBdK29mZnNldHgsY29vcmRzW2ldWzFdK29mZnNldHkpO319ZWxzZXtjby5saW5lVG8oY29vcmRzW2ldWzBdK29mZnNldHgsY29vcmRzW2ldWzFdK29mZnNldHkpO319XG5jby5zdHJva2UoKTt9O3RoaXMuZHJhd0JhY2tkcm9wPXRoaXMuRHJhd0JhY2tkcm9wPWZ1bmN0aW9uKGNvb3Jkcyxjb2xvcilcbnt2YXIgc2l6ZT1wcm9wWydjaGFydC5iYWNrZHJvcC5zaXplJ107Y28ubGluZVdpZHRoPXNpemU7Y28uZ2xvYmFsQWxwaGE9cHJvcFsnY2hhcnQuYmFja2Ryb3AuYWxwaGEnXTtjby5zdHJva2VTdHlsZT1jb2xvcjt2YXIgeUNvb3Jkcz1bXTtjby5iZWdpblBhdGgoKTtpZihwcm9wWydjaGFydC5jdXJ2eSddJiYhUkcuSVNPTEQpe2Zvcih2YXIgaT0wO2k8Y29vcmRzLmxlbmd0aDsrK2kpe3lDb29yZHMucHVzaChjb29yZHNbaV1bMV0pfVxudGhpcy5EcmF3U3BsaW5lKGNvLHlDb29yZHMsY29sb3IsbnVsbCk7fWVsc2V7Y28ubW92ZVRvKGNvb3Jkc1swXVswXSxjb29yZHNbMF1bMV0pO2Zvcih2YXIgaj0xO2o8Y29vcmRzLmxlbmd0aDsrK2ope2NvLmxpbmVUbyhjb29yZHNbal1bMF0sY29vcmRzW2pdWzFdKTt9fVxuY28uc3Ryb2tlKCk7Y28uZ2xvYmFsQWxwaGE9MTtSRy5Ob1NoYWRvdyh0aGlzKTt9O3RoaXMuZ2V0TGluZVdpZHRoPXRoaXMuR2V0TGluZVdpZHRoPWZ1bmN0aW9uKGkpXG57dmFyIGxpbmV3aWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtpZih0eXBlb2YobGluZXdpZHRoKT09J251bWJlcicpe3JldHVybiBsaW5ld2lkdGg7fWVsc2UgaWYodHlwZW9mKGxpbmV3aWR0aCk9PSdvYmplY3QnKXtpZihsaW5ld2lkdGhbaV0pe3JldHVybiBsaW5ld2lkdGhbaV07fWVsc2V7cmV0dXJuIGxpbmV3aWR0aFswXTt9XG5hbGVydCgnW0xJTkVdIEVycm9yISBjaGFydC5saW5ld2lkdGggc2hvdWxkIGJlIGEgc2luZ2xlIG51bWJlciBvciBhbiBhcnJheSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzJyk7fX07dGhpcy5nZXRTaGFwZT10aGlzLmdldFBvaW50PWZ1bmN0aW9uKGUpXG57dmFyIG9iaj10aGlzLFJHPVJHcmFwaCxjYT1jYW52YXM9ZS50YXJnZXQsY289Y29udGV4dD10aGlzLmNvbnRleHQscHJvcD10aGlzLnByb3BlcnRpZXM7dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTtpZihhcmd1bWVudHNbMV0pe29iaj1hcmd1bWVudHNbMV07fVxuZm9yKHZhciBpPTA7aTxvYmouY29vcmRzLmxlbmd0aDsrK2kpe3ZhciB4PW9iai5jb29yZHNbaV1bMF07dmFyIHk9b2JqLmNvb3Jkc1tpXVsxXTtpZihtb3VzZVg8PSh4K3Byb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3Quc2l6ZSddKSYmbW91c2VYPj0oeC1wcm9wWydjaGFydC50b29sdGlwcy5ob3RzcG90LnNpemUnXSkmJm1vdXNlWTw9KHkrcHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC5zaXplJ10pJiZtb3VzZVk+PSh5LXByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3Quc2l6ZSddKSl7aWYoUkcucGFyc2VUb29sdGlwVGV4dCl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO31cbnZhciBkYXRhc2V0PTA7dmFyIGlkeD1pO3doaWxlKChpZHgrMSk+dGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aCl7aWR4LT10aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoO2RhdGFzZXQrKzt9XG5yZXR1cm57MDpvYmosMTp4LDI6eSwzOmksJ29iamVjdCc6b2JqLCd4Jzp4LCd5Jzp5LCdpbmRleCc6aSwndG9vbHRpcCc6dG9vbHRpcCwnZGF0YXNldCc6ZGF0YXNldCwnaW5kZXhfYWRqdXN0ZWQnOmlkeH07fWVsc2UgaWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC54b25seSddPT10cnVlJiZtb3VzZVg8PSh4K3Byb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3Quc2l6ZSddKSYmbW91c2VYPj0oeC1wcm9wWydjaGFydC50b29sdGlwcy5ob3RzcG90LnNpemUnXSkpe3ZhciB0b29sdGlwPVJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSxpKTtyZXR1cm57MDpvYmosMTp4LDI6eSwzOmksJ29iamVjdCc6b2JqLCd4Jzp4LCd5Jzp5LCdpbmRleCc6aSwndG9vbHRpcCc6dG9vbHRpcH07fX19O3RoaXMuZHJhd0Fib3ZlTGFiZWxzPXRoaXMuRHJhd0Fib3ZlTGFiZWxzPWZ1bmN0aW9uKClcbnt2YXIgc2l6ZT1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSddLGZvbnQ9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnXXx8cHJvcFsnY2hhcnQudGV4dC5mb250J10sdW5pdHNfcHJlPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wcmUnXSx1bml0c19wb3N0PXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wb3N0J10sZGVjaW1hbHM9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmRlY2ltYWxzJ10sY29sb3I9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmNvbG9yJ118fHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSxiZ2NvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5iYWNrZ3JvdW5kJ118fCd3aGl0ZScsYm9yZGVyPSgodHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5ib3JkZXInXT09PSdib29sZWFuJ3x8dHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5ib3JkZXInXT09PSdudW1iZXInKT9wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuYm9yZGVyJ106dHJ1ZSksb2Zmc2V0eT1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUub2Zmc2V0eSddK3NpemUsc3BlY2lmaWM9cHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnNwZWNpZmljJ107Y28uYmVnaW5QYXRoKCk7Zm9yKHZhciBpPTAsbGVuPXRoaXMuY29vcmRzLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgY29vcmRzPXRoaXMuY29vcmRzW2ldO1JHLnRleHQyKHRoaXMse2NvbG9yOmNvbG9yLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzpjb29yZHNbMF0sJ3knOmNvb3Jkc1sxXS1vZmZzZXR5LCd0ZXh0Jzooc3BlY2lmaWMmJnNwZWNpZmljW2ldKT9zcGVjaWZpY1tpXTooc3BlY2lmaWM/bnVsbDpSRy5udW1iZXJGb3JtYXQodGhpcyx0eXBlb2YgZGVjaW1hbHM9PT0nbnVtYmVyJz90aGlzLmRhdGFfYXJyW2ldLnRvRml4ZWQoZGVjaW1hbHMpOnRoaXMuZGF0YV9hcnJbaV0sdW5pdHNfcHJlLHVuaXRzX3Bvc3QpKSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nRmlsbCc6Ymdjb2xvciwnYm91bmRpbmdTdHJva2UnOmJvcmRlcj8nYmxhY2snOidyZ2JhKDAsMCwwLDApJywndGFnJzonbGFiZWxzLmFib3ZlJ30pO319O3RoaXMuZHJhd0N1cnZ5TGluZT10aGlzLkRyYXdDdXJ2eUxpbmU9ZnVuY3Rpb24oY29vcmRzLGNvbG9yLGxpbmV3aWR0aCxpbmRleClcbnt2YXIgeUNvb3Jkcz1bXTtmb3IodmFyIGk9MDtpPGNvb3Jkcy5sZW5ndGg7KytpKXt5Q29vcmRzLnB1c2goY29vcmRzW2ldWzFdKTt9XG5pZihwcm9wWydjaGFydC5maWxsZWQnXSl7Y28uYmVnaW5QYXRoKCk7dmFyIHhheGlzWT10aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pO2NvLm1vdmVUbyhjb29yZHNbMF1bMF0seGF4aXNZKTt0aGlzLmRyYXdTcGxpbmUoY28seUNvb3Jkcyxjb2xvcixpbmRleCk7aWYocHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddJiZpbmRleD4wKXtmb3IodmFyIGk9KHRoaXMuY29vcmRzU3BsaW5lW2luZGV4LTFdLmxlbmd0aC0xKTtpPj0wO2ktPTEpe2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1NwbGluZVtpbmRleC0xXVtpXVswXSx0aGlzLmNvb3Jkc1NwbGluZVtpbmRleC0xXVtpXVsxXSk7fX1lbHNle2NvLmxpbmVUbyhjb29yZHNbY29vcmRzLmxlbmd0aC0xXVswXSx4YXhpc1kpO31cbmNvLmZpbGwoKTt9XG5jby5iZWdpblBhdGgoKTt0aGlzLkRyYXdTcGxpbmUoY28seUNvb3Jkcyxjb2xvcixpbmRleCk7Y28uc3Ryb2tlKCk7fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGFyZylcbntpZihhcmcubGVuZ3RoPT0yKXt2YXIgbW91c2VYPWFyZ1swXTt2YXIgbW91c2VZPWFyZ1sxXTt9ZWxzZXt2YXIgbW91c2VDb29yZHM9UkcuZ2V0TW91c2VYWShhcmcpO3ZhciBtb3VzZVg9bW91c2VDb29yZHNbMF07dmFyIG1vdXNlWT1tb3VzZUNvb3Jkc1sxXTt9XG52YXIgb2JqPXRoaXM7dmFyIHhheGlzcG9zPXByb3BbJ2NoYXJ0LnhheGlzcG9zJ107aWYobW91c2VZPHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSl7cmV0dXJuIHhheGlzcG9zPT0nYm90dG9tJ3x8eGF4aXNwb3M9PSdjZW50ZXInP3RoaXMubWF4OnRoaXMubWluO31lbHNlIGlmKG1vdXNlWT4oY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpe3JldHVybiB4YXhpc3Bvcz09J2JvdHRvbSc/dGhpcy5taW46dGhpcy5tYXg7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe3ZhciB2YWx1ZT0oKChvYmouZ3JhcGhhcmVhLzIpLShtb3VzZVktcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKSkvb2JqLmdyYXBoYXJlYSkqKG9iai5tYXgtb2JqLm1pbik7dmFsdWUqPTI7dmFsdWU+MD92YWx1ZSs9dGhpcy5taW46dmFsdWUtPXRoaXMubWluO3JldHVybiB2YWx1ZTt9ZWxzZSBpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0ndG9wJyl7dmFyIHZhbHVlPSgob2JqLmdyYXBoYXJlYS0obW91c2VZLXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpL29iai5ncmFwaGFyZWEpKihvYmoubWF4LW9iai5taW4pO3ZhbHVlPU1hdGguYWJzKG9iai5tYXgtdmFsdWUpKiAtMTtyZXR1cm4gdmFsdWU7fWVsc2V7dmFyIHZhbHVlPSgob2JqLmdyYXBoYXJlYS0obW91c2VZLXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpL29iai5ncmFwaGFyZWEpKihvYmoubWF4LW9iai5taW4pXG52YWx1ZSs9b2JqLm1pbjtyZXR1cm4gdmFsdWU7fX07dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNlIGlmKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2hhbG8nKXt2YXIgb2JqPXNoYXBlLm9iamVjdCxjb2xvcj1wcm9wWydjaGFydC5jb2xvcnMnXVtzaGFwZS5kYXRhc2V0XTtSRy5wYXRoMihvYmouY29udGV4dCwnYiBhICUgJSAxMyAwIDYuMjgzMCBmYWxzZSBmIHJnYmEoMjU1LDI1NSwyNTUsMC43NSknLHNoYXBlLngsc2hhcGUueSk7UkcucGF0aDIob2JqLmNvbnRleHQsJ2dhIDAuMTUgYiBhICUgJSAxMyAwIDYuMjgzMCBmYWxzZSBmICUgZ2EgMScsc2hhcGUueCxzaGFwZS55LGNvbG9yKTtSRy5wYXRoMihvYmouY29udGV4dCwnYiBhICUgJSA3IDAgNi4yODMwIGZhbHNlIGYgd2hpdGUnLHNoYXBlLngsc2hhcGUueSk7UkcucGF0aDIob2JqLmNvbnRleHQsJ2IgYSAlICUgNSAwIDYuMjgzMCBmYWxzZSBmICUnLHNoYXBlLngsc2hhcGUueSxjb2xvcik7fWVsc2V7UkcuSGlnaGxpZ2h0LlBvaW50KHRoaXMsc2hhcGUpO319fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2lmKChtb3VzZVhZWzBdPnByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10tNSkmJm1vdXNlWFlbMF08KGNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddKzUpJiZtb3VzZVhZWzFdPihwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10tNSkmJm1vdXNlWFlbMV08KGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10rNSkpe3JldHVybiB0aGlzO319O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZT10aGlzLkFkanVzdGluZ19tb3VzZW1vdmU9ZnVuY3Rpb24oZSlcbntpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykmJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkPT10aGlzLnVpZCl7dmFyIHZhbHVlPU51bWJlcih0aGlzLmdldFZhbHVlKGUpKTt2YXIgc2hhcGU9UkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnKTtpZihzaGFwZSl7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnLHNoYXBlKTt0aGlzLm9yaWdpbmFsX2RhdGFbc2hhcGVbJ2RhdGFzZXQnXV1bc2hhcGVbJ2luZGV4X2FkanVzdGVkJ11dPU51bWJlcih2YWx1ZSk7UkcucmVkcmF3Q2FudmFzKGUudGFyZ2V0KTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt9fX07dGhpcy5nZXRZQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57aWYodHlwZW9mKHZhbHVlKSE9J251bWJlcicpe3JldHVybiBudWxsO31cbnZhciB5O3ZhciB4YXhpc3Bvcz1wcm9wWydjaGFydC54YXhpc3BvcyddO2lmKHhheGlzcG9zPT0ndG9wJyl7eT0oKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSp0aGlzLmdyYXBoYXJlYTtpZihwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSl7eT10aGlzLmdyYXBoYXJlYS15O31cbnk9eSt0aGlzLmd1dHRlclRvcH1lbHNlIGlmKHhheGlzcG9zPT0nY2VudGVyJyl7eT0oKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoodGhpcy5ncmFwaGFyZWEvMik7eT0odGhpcy5ncmFwaGFyZWEvMikteTt5Kz10aGlzLmd1dHRlclRvcDt9ZWxzZXtpZigodmFsdWU8dGhpcy5taW58fHZhbHVlPnRoaXMubWF4KSYmcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXT09ZmFsc2Upe3JldHVybiBudWxsO31cbnk9KCh2YWx1ZS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqdGhpcy5ncmFwaGFyZWE7aWYocHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10pe3k9dGhpcy5ncmFwaGFyZWEteTt9XG55PWNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS15O31cbnJldHVybiB5O307dGhpcy5kcmF3U3BsaW5lPXRoaXMuRHJhd1NwbGluZT1mdW5jdGlvbihjb250ZXh0LGNvb3Jkcyxjb2xvcixpbmRleClcbnt0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF09W107dmFyIHhDb29yZHM9W107dmFyIGd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt2YXIgZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dmFyIGhtYXJnaW49cHJvcFsnY2hhcnQuaG1hcmdpbiddO3ZhciBpbnRlcnZhbD0oY2Eud2lkdGgtKGd1dHRlckxlZnQrZ3V0dGVyUmlnaHQpLSgyKmhtYXJnaW4pKS8oY29vcmRzLmxlbmd0aC0xKTtjby5zdHJva2VTdHlsZT1jb2xvcjtmb3IodmFyIGk9MCxsZW49Y29vcmRzLmxlbmd0aDtpPGxlbjtpKz0xKXtpZih0eXBlb2YgY29vcmRzW2ldPT0nb2JqZWN0JyYmY29vcmRzW2ldJiZjb29yZHNbaV0ubGVuZ3RoPT0yKXtjb29yZHNbaV09TnVtYmVyKGNvb3Jkc1tpXVsxXSk7fX1cbnZhciBQPVtjb29yZHNbMF1dO2Zvcih2YXIgaT0wO2k8Y29vcmRzLmxlbmd0aDsrK2kpe1AucHVzaChjb29yZHNbaV0pO31cblAucHVzaChjb29yZHNbY29vcmRzLmxlbmd0aC0xXSsoY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV0tY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl0pKTtmb3IodmFyIGo9MTtqPFAubGVuZ3RoLTI7KytqKXtmb3IodmFyIHQ9MDt0PDEwOysrdCl7dmFyIHlDb29yZD1TcGxpbmUodC8xMCxQW2otMV0sUFtqXSxQW2orMV0sUFtqKzJdKTt4Q29vcmRzLnB1c2goKChqLTEpKmludGVydmFsKSsodCooaW50ZXJ2YWwvMTApKStndXR0ZXJMZWZ0K2htYXJnaW4pO2NvLmxpbmVUbyh4Q29vcmRzW3hDb29yZHMubGVuZ3RoLTFdLHlDb29yZCk7aWYodHlwZW9mIGluZGV4PT0nbnVtYmVyJyl7dGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLnB1c2goW3hDb29yZHNbeENvb3Jkcy5sZW5ndGgtMV0seUNvb3JkXSk7fX19XG5jby5saW5lVG8oKChqLTEpKmludGVydmFsKStndXR0ZXJMZWZ0K2htYXJnaW4sUFtqXSk7aWYodHlwZW9mIGluZGV4PT0nbnVtYmVyJyl7dGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLnB1c2goWygoai0xKSppbnRlcnZhbCkrZ3V0dGVyTGVmdCtobWFyZ2luLFBbal1dKTt9XG5mdW5jdGlvbiBTcGxpbmUodCxQMCxQMSxQMixQMylcbntyZXR1cm4gMC41KigoMipQMSkrXG4oKDAtUDApK1AyKSp0K1xuKCgyKlAwLSg1KlAxKSsoNCpQMiktUDMpKih0KnQpK1xuKCgwLVAwKSsoMypQMSktKDMqUDIpK1AzKSoodCp0KnQpKSk7fX07dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddPVJHcmFwaC5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddPVJHcmFwaC5hcnJheV9jbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmtleS5jb2xvcnMnXT1SR3JhcGguYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50ZXh0LmNvbG9yJ109cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ109cHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5hbm5vdGF0ZS5jb2xvciddPXByb3BbJ2NoYXJ0LmFubm90YXRlLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRpdGxlLmNvbG9yJ109cHJvcFsnY2hhcnQudGl0bGUuY29sb3InXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGl0bGUueWF4aXMuY29sb3InXT1wcm9wWydjaGFydC50aXRsZS55YXhpcy5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuYmFja2dyb3VuZCddPXByb3BbJ2NoYXJ0LmtleS5iYWNrZ3JvdW5kJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmF4aXMuY29sb3InXT1wcm9wWydjaGFydC5heGlzLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTt9XG5mb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aDsrK2kpe2lmKHR5cGVvZihwcm9wWydjaGFydC5jb2xvcnMnXVtpXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC5jb2xvcnMnXVtpXVswXSYmcHJvcFsnY2hhcnQuY29sb3JzJ11baV1bMV0pe3Byb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzBdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzBdKTtwcm9wWydjaGFydC5jb2xvcnMnXVtpXVsxXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVtpXVsxXSk7fWVsc2V7cHJvcFsnY2hhcnQuY29sb3JzJ11baV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11baV0pO319XG5pZihwcm9wWydjaGFydC5maWxsc3R5bGUnXSl7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKT09J3N0cmluZycpe3Byb3BbJ2NoYXJ0LmZpbGxzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddLCd2ZXJ0aWNhbCcpO31lbHNle2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10ubGVuZ3RoOysraSl7cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ11baV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ11baV0sJ3ZlcnRpY2FsJyk7fX19XG5pZighUkcuaXNfbnVsbChwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pKXtmb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXS5sZW5ndGg7KytpKXtwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddW2ldKTt9fVxudmFyIHByb3BlcnRpZXM9WydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMScsJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJywnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJywnY2hhcnQuYmFja2dyb3VuZC5jb2xvcicsJ2NoYXJ0LnRleHQuY29sb3InLCdjaGFydC5jcm9zc2hhaXJzLmNvbG9yJywnY2hhcnQuYW5ub3RhdGUuY29sb3InLCdjaGFydC50aXRsZS5jb2xvcicsJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJywnY2hhcnQua2V5LmJhY2tncm91bmQnLCdjaGFydC5heGlzLmNvbG9yJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTtmb3IodmFyIGk9MDtpPHByb3BlcnRpZXMubGVuZ3RoOysraSl7cHJvcFtwcm9wZXJ0aWVzW2ldXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wW3Byb3BlcnRpZXNbaV1dKTt9fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG52YXIgZGlyPXR5cGVvZihhcmd1bWVudHNbMV0pPT0nc3RyaW5nJz9hcmd1bWVudHNbMV06J3ZlcnRpY2FsJztpZih0eXBlb2YgY29sb3I9PT0nc3RyaW5nJyYmY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6Jyk7aWYoZGlyPT0naG9yaXpvbnRhbCcpe3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsMCxjYS53aWR0aCwwKTt9ZWxzZXt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sMCxwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pO31cbnZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLnNldFNoYWRvdz10aGlzLlNldFNoYWRvdz1mdW5jdGlvbihpKVxue2lmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXt2YXIgc2hhZG93Q29sb3I9cHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107aWYodHlwZW9mKHNoYWRvd0NvbG9yKT09J29iamVjdCcmJnNoYWRvd0NvbG9yW2ktMV0pe2NvLnNoYWRvd0NvbG9yPXNoYWRvd0NvbG9yW2ldO31lbHNlIGlmKHR5cGVvZihzaGFkb3dDb2xvcik9PSdvYmplY3QnKXtjby5zaGFkb3dDb2xvcj1zaGFkb3dDb2xvclswXTt9ZWxzZSBpZih0eXBlb2Yoc2hhZG93Q29sb3IpPT0nc3RyaW5nJyl7Y28uc2hhZG93Q29sb3I9c2hhZG93Q29sb3I7fVxuY28uc2hhZG93Qmx1cj1wcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFg9cHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZPXByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107fX07dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodD1mdW5jdGlvbihpbmRleClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzMltpbmRleF07aWYoY29vcmRzKXt2YXIgcHJlX2xpbmV3aWR0aD1jby5saW5lV2lkdGg7dmFyIHByZV9saW5lY2FwPWNvLmxpbmVDYXA7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddKzEwO2NvLmxpbmVDYXA9J3JvdW5kJztjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmJlZ2luUGF0aCgpO2lmKHByb3BbJ2NoYXJ0LmN1cnZ5J10pe3RoaXMuRHJhd1NwbGluZShjbyxjb29yZHMscHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydCddLG51bGwpO31lbHNle2Zvcih2YXIgaT0wLGxlbj1jb29yZHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGk9PTB8fFJHLmlzX251bGwoY29vcmRzW2ldWzFdKXx8KHR5cGVvZiBjb29yZHNbaS0xXVsxXSE9dW5kZWZpbmVkJiZSRy5pc19udWxsKGNvb3Jkc1tpLTFdWzFdKSkpe2NvLm1vdmVUbyhjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdKTt9ZWxzZXtjby5saW5lVG8oY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSk7fX19XG5jby5zdHJva2UoKTtjby5saW5lV2lkdGg9cHJlX2xpbmV3aWR0aDtjby5saW5lQ2FwPXByZV9saW5lY2FwO319O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmRyYXdFcnJvcmJhcnM9ZnVuY3Rpb24oKVxue2NvLnNhdmUoKTtSRy5ub1NoYWRvdyh0aGlzKTt2YXIgY29vcmRzPXRoaXMuY29vcmRzLHg9MCxlcnJvcmJhcnM9cHJvcFsnY2hhcnQuZXJyb3JiYXJzJ10sbGVuZ3RoPTA7aWYoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSl7cHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZC53aWR0aCddPTAuMDAxO2hhbGZ3aWR0aD0wLjAwMDU7fVxuY28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtmb3IodmFyIGk9MDtpPGNvb3Jkcy5sZW5ndGg7KytpKXt2YXIgaGFsZndpZHRoPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQud2lkdGgnXS8yfHw1LGNvbG9yPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jb2xvciddfHwnYmxhY2snO2lmKGVycm9yYmFyc1tpXSYmdHlwZW9mIGVycm9yYmFyc1tpXVszXT09PSdudW1iZXInKXtjby5saW5lV2lkdGg9ZXJyb3JiYXJzW2ldWzNdO31lbHNlIGlmKHR5cGVvZiBwcm9wWydjaGFydC5lcnJvcmJhcnMubGluZXdpZHRoJ109PT0nbnVtYmVyJyl7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTt9ZWxzZXtjby5saW5lV2lkdGg9MTt9XG5pZih0eXBlb2YgZXJyb3JiYXJzPT09J251bWJlcid8fHR5cGVvZiBlcnJvcmJhcnNbaV09PT0nbnVtYmVyJyl7aWYodHlwZW9mIGVycm9yYmFycz09PSdudW1iZXInKXt2YXIgcG9zaXRpdmVMZW5ndGg9dGhpcy5nZXRZQ29vcmQodGhpcy5taW4pLXRoaXMuZ2V0WUNvb3JkKHRoaXMubWluK2Vycm9yYmFycyksbmVnYXRpdmVMZW5ndGg9cG9zaXRpdmVMZW5ndGg7fWVsc2V7dmFyIHBvc2l0aXZlTGVuZ3RoPXRoaXMuZ2V0WUNvb3JkKHRoaXMubWluKS10aGlzLmdldFlDb29yZCh0aGlzLm1pbitlcnJvcmJhcnNbaV0pLG5lZ2F0aXZlTGVuZ3RoPXBvc2l0aXZlTGVuZ3RoO31cbmlmKHBvc2l0aXZlTGVuZ3RofHxuZWdhdGl2ZUxlbmd0aCl7cGEyKGNvLCdsaiBtaXRlciBsYyBzcXVhcmUgYiBtICUgJSBsICUgJSBtICUgJSBsICUgJSBsICUgJSBtICUgJSBsICUgJSBzICUnLGNvb3Jkc1tpXVswXS1oYWxmd2lkdGgsY29vcmRzW2ldWzFdK25lZ2F0aXZlTGVuZ3RoLGNvb3Jkc1tpXVswXStoYWxmd2lkdGgsY29vcmRzW2ldWzFdK25lZ2F0aXZlTGVuZ3RoLGNvb3Jkc1tpXVswXSxjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgsY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXS1wb3NpdGl2ZUxlbmd0aCxjb29yZHNbaV1bMF0taGFsZndpZHRoLGNvb3Jkc1tpXVsxXS1wb3NpdGl2ZUxlbmd0aCxjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoLGNvb3Jkc1tpXVswXStoYWxmd2lkdGgsY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoLGNvbG9yKTtwYTIoY28sJ2xqIG1pdGVyIGxjIHNxdWFyZSBiIG0gJSAlIGwgJSAlIHMgJScsY29vcmRzW2ldWzBdLWhhbGZ3aWR0aCxjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgsY29vcmRzW2ldWzBdK2hhbGZ3aWR0aCxjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgsY29sb3IpO319ZWxzZSBpZih0eXBlb2YgZXJyb3JiYXJzW2ldPT09J29iamVjdCcmJiFSRy5pc051bGwoZXJyb3JiYXJzW2ldKSl7dmFyIHBvc2l0aXZlTGVuZ3RoPXRoaXMuZ2V0WUNvb3JkKHRoaXMubWluKS10aGlzLmdldFlDb29yZCh0aGlzLm1pbitlcnJvcmJhcnNbaV1bMF0pLG5lZ2F0aXZlTGVuZ3RoPXRoaXMuZ2V0WUNvb3JkKHRoaXMubWluKS10aGlzLmdldFlDb29yZCh0aGlzLm1pbitlcnJvcmJhcnNbaV1bMV0pO2lmKHR5cGVvZiBlcnJvcmJhcnNbaV1bMl09PT0nc3RyaW5nJyl7Y29sb3I9ZXJyb3JiYXJzW2ldWzJdO31cbmhhbGZ3aWR0aD10eXBlb2YgZXJyb3JiYXJzW2ldWzRdPT09J251bWJlcic/ZXJyb3JiYXJzW2ldWzRdLzI6aGFsZndpZHRoO2lmKHR5cGVvZiBlcnJvcmJhcnNbaV09PT0nb2JqZWN0JyYmdHlwZW9mIGVycm9yYmFyc1tpXVszXT09PSdudW1iZXInKXtjby5saW5lV2lkdGg9ZXJyb3JiYXJzW2ldWzNdO31lbHNlIGlmKHR5cGVvZiBwcm9wWydjaGFydC5lcnJvcmJhcnMubGluZXdpZHRoJ109PT0nbnVtYmVyJyl7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTt9ZWxzZXtjby5saW5lV2lkdGg9MTt9XG5pZighUkcuaXNOdWxsKGVycm9yYmFyc1tpXVswXSkpe3BhMihjbywnbGMgc3F1YXJlIGIgIG0gJSAlIGwgJSAlIGwgJSAlIG0gJSAlIGwgJSAlIHMgJScsY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSxjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoLGNvb3Jkc1tpXVswXS1oYWxmd2lkdGgsbWEucm91bmQoY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoKSxjb29yZHNbaV1bMF0sbWEucm91bmQoY29vcmRzW2ldWzFdLXBvc2l0aXZlTGVuZ3RoKSxjb29yZHNbaV1bMF0raGFsZndpZHRoLG1hLnJvdW5kKGNvb3Jkc1tpXVsxXS1wb3NpdGl2ZUxlbmd0aCksY29sb3IpO31cbmlmKHR5cGVvZiBlcnJvcmJhcnNbaV1bMV09PT0nbnVtYmVyJyl7dmFyIG5lZ2F0aXZlTGVuZ3RoPW1hLmFicyh0aGlzLmdldFlDb29yZChlcnJvcmJhcnNbaV1bMV0pLXRoaXMuZ2V0WUNvb3JkKDApKTtwYTIoY28sJ2IgbSAlICUgbCAlICUgbCAlICUgbSAlICUgbCAlICUgcyAlJyxjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdLGNvb3Jkc1tpXVswXSxjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgsY29vcmRzW2ldWzBdLWhhbGZ3aWR0aCxtYS5yb3VuZChjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgpLGNvb3Jkc1tpXVswXSxtYS5yb3VuZChjb29yZHNbaV1bMV0rbmVnYXRpdmVMZW5ndGgpLGNvb3Jkc1tpXVswXStoYWxmd2lkdGgsbWEucm91bmQoY29vcmRzW2ldWzFdK25lZ2F0aXZlTGVuZ3RoKSxjb2xvcik7fX19XG5jby5yZXN0b3JlKCk7fTt0aGlzLmhpZGU9ZnVuY3Rpb24oKVxue2lmKHR5cGVvZiBhcmd1bWVudHNbMF09PT0nbnVtYmVyJyl7cHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11bYXJndW1lbnRzWzBdXT1mYWxzZTt9ZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzWzBdPT09J29iamVjdCcpe2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzWzBdLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2FyZ3VtZW50c1swXVtpXV09ZmFsc2U7fX1lbHNle2Zvcih2YXIgaT0wO2k8dGhpcy5vcmlnaW5hbF9kYXRhLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2ldPWZhbHNlO319XG5SRy5yZWRyYXcoKTtyZXR1cm4gdGhpczt9O3RoaXMuc2hvdz1mdW5jdGlvbigpXG57aWYodHlwZW9mIGFyZ3VtZW50c1swXT09PSdudW1iZXInKXtwcm9wWydjaGFydC5saW5lLnZpc2libGUnXVthcmd1bWVudHNbMF1dPXRydWU7fWVsc2UgaWYodHlwZW9mIGFyZ3VtZW50c1swXT09PSdvYmplY3QnKXtmb3IodmFyIGk9MDtpPGFyZ3VtZW50c1swXS5sZW5ndGg7KytpKXtwcm9wWydjaGFydC5saW5lLnZpc2libGUnXVthcmd1bWVudHNbMF1baV1dPXRydWU7fX1lbHNle2Zvcih2YXIgaT0wO2k8dGhpcy5vcmlnaW5hbF9kYXRhLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2ldPXRydWU7fX1cblJHLnJlZHJhdygpO3JldHVybiB0aGlzO307dGhpcy5oaWRkZW49ZnVuY3Rpb24oaW5kZXgpXG57cmV0dXJuIXByb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2luZGV4XTt9O3RoaXMudW5mb2xkPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lcz9vcHQuZnJhbWVzOjMwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmZ1bmN0aW9uKCl7fTt2YXIgaW5pdGlhbD1wcm9wWydjaGFydC5hbmltYXRpb24udW5mb2xkLmluaXRpYWwnXTtwcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ109cHJvcFsnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC5pbml0aWFsJ107ZnVuY3Rpb24gaXRlcmF0b3IoKVxue3Byb3BbJ2NoYXJ0LmFuaW1hdGlvbi5mYWN0b3InXT0oKDEtaW5pdGlhbCkqKGZyYW1lL2ZyYW1lcykpK2luaXRpYWw7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lPGZyYW1lcyl7ZnJhbWUrKztSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O3RoaXMudHJhY2U9dGhpcy50cmFjZTI9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzJdO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtvYmouU2V0KCdhbmltYXRpb24udHJhY2UuY2xpcCcsMCk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZihmcmFtZSsrPGZyYW1lcyl7b2JqLlNldCgnYW5pbWF0aW9uLnRyYWNlLmNsaXAnLGZyYW1lL2ZyYW1lcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmZvbGR0b2NlbnRlcj10aGlzLmZvbGRUb0NlbnRlcj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgY2VudGVyX3ZhbHVlPW9iai5zY2FsZTIubWF4LzI7b2JqLlNldCgnY2hhcnQueW1heCcsb2JqLnNjYWxlMi5tYXgpO3ZhciBvcmlnaW5hbF9kYXRhPVJHLmFycmF5X2Nsb25lKG9iai5vcmlnaW5hbF9kYXRhKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjsrK2kpe2lmKG9iai5kYXRhW2ldLmxlbmd0aCl7Zm9yKHZhciBqPTAsbGVuMj1vYmouZGF0YVtpXS5sZW5ndGg7ajxsZW4yOysrail7dmFyIGRhdGFzZXQ9b2JqLm9yaWdpbmFsX2RhdGFbaV07aWYoZGF0YXNldFtqXT5jZW50ZXJfdmFsdWUpe2RhdGFzZXRbal09b3JpZ2luYWxfZGF0YVtpXVtqXS0oKG9yaWdpbmFsX2RhdGFbaV1bal0tY2VudGVyX3ZhbHVlKSooZnJhbWUvZnJhbWVzKSk7fWVsc2V7ZGF0YXNldFtqXT1vcmlnaW5hbF9kYXRhW2ldW2pdKygoKGNlbnRlcl92YWx1ZS1vcmlnaW5hbF9kYXRhW2ldW2pdKS9mcmFtZXMpKmZyYW1lKTt9fX19XG5SRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcylcbmlmKGZyYW1lKys8ZnJhbWVzKXtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O3RoaXMudW5mb2xkRnJvbUNlbnRlclRyYWNlPXRoaXMudW5mb2xkRnJvbUNlbnRlclRyYWNlMj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHwzMCxmcmFtZT0wLGRhdGE9UkcuYXJyYXlDbG9uZShvYmoub3JpZ2luYWxfZGF0YSksY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307b2JqLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nO29iai5kcmF3KCk7dmFyIG1heD1vYmouc2NhbGUyLm1heDtSRy5jbGVhcihvYmouY2FudmFzKTtvYmouY2FudmFzLnN0eWxlLnZpc2liaWxpdHk9J3Zpc2libGUnO3ZhciB1bmZvbGRDYWxsYmFjaz1mdW5jdGlvbigpXG57b2JqLm9yaWdpbmFsX2RhdGE9ZGF0YTtvYmoudW5mb2xkRnJvbUNlbnRlcih7ZnJhbWVzOmZyYW1lcy8yfSxjYWxsYmFjayk7fTt2YXIgaGFsZj1vYmouR2V0KCdjaGFydC54YXhpc3BvcycpPT0nY2VudGVyJz9vYmoubWluOigob2JqLm1heC1vYmoubWluKS8yKStvYmoubWluO29iai5TZXQoJ2NoYXJ0LnltYXgnLG9iai5tYXgpO2Zvcih2YXIgaT0wLGxlbj1vYmoub3JpZ2luYWxfZGF0YS5sZW5ndGg7aTxsZW47KytpKXtmb3IodmFyIGo9MDtqPG9iai5vcmlnaW5hbF9kYXRhW2ldLmxlbmd0aDsrK2ope29iai5vcmlnaW5hbF9kYXRhW2ldW2pdPShvYmouR2V0KCdjaGFydC5maWxsZWQnKSYmb2JqLkdldCgnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZScpJiZpPjApPzA6aGFsZjt9fVxuUkcuY2xlYXIob2JqLmNhbnZhcyk7b2JqLnRyYWNlMih7ZnJhbWVzOmZyYW1lcy8yfSx1bmZvbGRDYWxsYmFjayk7cmV0dXJuIG9iajt9O3RoaXMudW5mb2xkRnJvbUNlbnRlcj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBmcmFtZT0wO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtvYmouY2FudmFzLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbic7b2JqLkRyYXcoKTt2YXIgbWF4PW9iai5zY2FsZTIubWF4O1JHLmNsZWFyKG9iai5jYW52YXMpO29iai5jYW52YXMuc3R5bGUudmlzaWJpbGl0eT0ndmlzaWJsZSc7dmFyIGNlbnRlcl92YWx1ZT1vYmouR2V0KCdjaGFydC54YXhpc3BvcycpPT09J2NlbnRlcic/cHJvcFsnY2hhcnQueW1pbiddOigob2JqLm1heC1vYmoubWluKS8yKStvYmoubWluO3ZhciBvcmlnaW5hbF9kYXRhPVJHLmFycmF5X2Nsb25lKG9iai5vcmlnaW5hbF9kYXRhKTt2YXIgc3RlcHM9bnVsbDtvYmouU2V0KCdjaGFydC55bWF4JyxtYXgpO2lmKCFzdGVwcyl7c3RlcHM9W107Zm9yKHZhciBkYXRhc2V0PTAsbGVuPW9yaWdpbmFsX2RhdGEubGVuZ3RoO2RhdGFzZXQ8bGVuOysrZGF0YXNldCl7c3RlcHNbZGF0YXNldF09W11cbmZvcih2YXIgaT0wLGxlbjI9b3JpZ2luYWxfZGF0YVtkYXRhc2V0XS5sZW5ndGg7aTxsZW4yOysraSl7aWYocHJvcFsnY2hhcnQuZmlsbGVkJ10mJnByb3BbJ2NoYXJ0LmZpbGxlZC5hY2N1bXVsYXRpdmUnXSYmZGF0YXNldD4wKXtzdGVwc1tkYXRhc2V0XVtpXT1vcmlnaW5hbF9kYXRhW2RhdGFzZXRdW2ldL2ZyYW1lcztvYmoub3JpZ2luYWxfZGF0YVtkYXRhc2V0XVtpXT1jZW50ZXJfdmFsdWU7fWVsc2V7c3RlcHNbZGF0YXNldF1baV09KG9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV0tY2VudGVyX3ZhbHVlKS9mcmFtZXM7b2JqLm9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV09Y2VudGVyX3ZhbHVlO319fX1cbmZ1bmN0aW9uIHVuZm9sZEZyb21DZW50ZXIoKVxue2Zvcih2YXIgZGF0YXNldD0wO2RhdGFzZXQ8b3JpZ2luYWxfZGF0YS5sZW5ndGg7KytkYXRhc2V0KXtmb3IodmFyIGk9MDtpPG9yaWdpbmFsX2RhdGFbZGF0YXNldF0ubGVuZ3RoOysraSl7b2JqLm9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV0rPXN0ZXBzW2RhdGFzZXRdW2ldO319XG5SRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoLS1mcmFtZXM+MCl7UkcuRWZmZWN0cy51cGRhdGVDYW52YXModW5mb2xkRnJvbUNlbnRlcik7fWVsc2V7b2JqLm9yaWdpbmFsX2RhdGE9UkcuYXJyYXlfY2xvbmUob3JpZ2luYWxfZGF0YSk7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7fX1cbnVuZm9sZEZyb21DZW50ZXIoKTtyZXR1cm4gdGhpczt9O1JHLmF0dChjYSk7dGhpcy5pc0FkanVzdGFibGU9ZnVuY3Rpb24oc2hhcGUpXG57aWYoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSl7cmV0dXJuIHRydWU7fVxuaWYoUkcuaXNBcnJheShwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkmJnByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddW3NoYXBlLmluZGV4XSl7cmV0dXJuIHRydWU7fVxucmV0dXJuIGZhbHNlO307UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fVxuZm9yKHZhciBpPTA7aTx0aGlzLm9yaWdpbmFsX2RhdGEubGVuZ3RoOysraSl7cHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11baV09dHJ1ZTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5saW5lLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///224\n");

/***/ }),
/* 225 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Meter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'meter';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.centerx = null;this.centery = null;this.radius = null;this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.image.url': null, 'chart.background.image.offsetx': 0, 'chart.background.image.offsety': 0, 'chart.background.image.stretch': true, 'chart.background.color': 'white', 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 20, 'chart.linewidth': 1, 'chart.linewidth.segments': 0, 'chart.strokestyle': null, 'chart.border': true, 'chart.border.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.valign': 'center', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.value.text.decimals': 0, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.green.start': (this.max - this.min) * 0.35 + this.min, 'chart.green.end': this.max, 'chart.green.color': '#207A20', 'chart.yellow.start': (this.max - this.min) * 0.1 + this.min, 'chart.yellow.end': (this.max - this.min) * 0.35 + this.min, 'chart.yellow.color': '#D0AC41', 'chart.red.start': this.min, 'chart.red.end': (this.max - this.min) * 0.1 + this.min, 'chart.red.color': '#9E1E1E', 'chart.colors.ranges': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.contextmenu': null, 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.tickmarks.small.num': 100, 'chart.tickmarks.big.num': 10, 'chart.tickmarks.small.color': '#bbb', 'chart.tickmarks.big.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.labels': true, 'chart.labels.count': 10, 'chart.labels.specific': null, 'chart.segment.radius.start': 0, 'chart.needle.radius': null, 'chart.needle.tail': false, 'chart.needle.head': true, 'chart.needle.color': 'black', 'chart.needle.image.url': null, 'chart.needle.image.offsetx': 0, 'chart.needle.image.offsety': 0, 'chart.adjustable': false, 'chart.angles.start': RGraph.PI, 'chart.angles.end': RGraph.TWOPI, 'chart.centerpin.stroke': 'black', 'chart.centerpin.fill': 'white', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[METER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, ca.height - this.gutterTop - this.gutterBottom);this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawBackground();this.drawLabels();this.drawNeedle();this.drawReadout();RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (typeof prop['chart.background.image.url'] === 'string' && !this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];var img = new Image();this.__background_image__ = img;img.src = prop['chart.background.image.url'];img.onload = function () {\n        if (prop['chart.background.image.stretch']) {\n          co.drawImage(this, x, y, ca.width, ca.height);\n        } else {\n          co.drawImage(this, x, y);\n        }\n        RG.redraw();\n      };\n    } else if (this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];if (prop['chart.background.image.stretch']) {\n        co.drawImage(this.__background_image__, x, y, ca.width, ca.height);\n      } else {\n        co.drawImage(this.__background_image__, x, y);\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.fill();RG.NoShadow(this);if (prop['chart.shadow']) {\n      co.beginPath();var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);\n    }\n    if (prop['chart.tickmarks.small.num']) {\n      for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += RG.PI / prop['chart.tickmarks.small.num']) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.stroke();\n      }\n      co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - 4, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();\n    }\n    if (prop['chart.tickmarks.big.num']) {\n      var colors = ['white', 'white', prop['chart.tickmarks.big.color']];for (var j = 0; j < colors.length; ++j) {\n        for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += (prop['chart.angles.end'] - prop['chart.angles.start']) / prop['chart.tickmarks.big.num']) {\n          co.beginPath();co.strokeStyle = colors[j];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.0001, 0);co.stroke();\n        }\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius - 7, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();var ranges = prop['chart.colors.ranges'];if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : ranges[i][2];co.fillStyle = ranges[i][2];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n          co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n        } else {\n          co.lineTo(this.centerx, this.centery);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n      co.beginPath();\n    } else {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - this.properties['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.lineWidth = 1;\n    }\n    if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.linewidth'];co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawNeedle = this.DrawNeedle = function () {\n    var a = (this.value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];if (typeof prop['chart.needle.image.url'] === 'string' && !this.__needle_image__) {\n      var img = new Image();this.__needle_image__ = img;img.src = prop['chart.needle.image.url'];img.onload = function () {\n        co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();RG.redraw();\n      };\n    } else if (this.__needle_image__) {\n      co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this.__needle_image__, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();\n    }\n    var needleRadius = typeof prop['chart.needle.radius'] == 'number' ? prop['chart.needle.radius'] : this.radius * 0.7;co.fillStyle = 'black';co.lineWidth = this.radius >= 200 ? 7 : 3;co.lineCap = 'round';co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];co.arc(this.centerx, this.centery, needleRadius, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();if (prop['chart.needle.head']) {\n      co.fillStyle = prop['chart.needle.color'];co.beginPath();co.lineWidth = 1;co.arc(this.centerx, this.centery, needleRadius + 15, a, a + 0.001, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a + 0.087, a + 0.087999, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a - 0.087, a - 0.087999, 1);co.fill();\n    }\n    if (prop['chart.needle.tail']) {\n      co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];var a = (this.value - this.min) / (this.max - this.min) * (this.properties['chart.angles.end'] - this.properties['chart.angles.start']) + this.properties['chart.angles.start'] + RG.PI;co.arc(this.centerx, this.centery, 25, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();\n    }\n    var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.beginPath();co.fillStyle = prop['chart.centerpin.stroke'];co.arc(this.centerx, this.centery, r, 0 + 0.001, RG.TWOPI, 0);co.fill();co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.arc(this.centerx, this.centery, r - 2, 0 + 0.001, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.labels']) {\n      return;\n    }\n    var radius = this.radius,\n        text_size = prop['chart.text.size'],\n        text_font = prop['chart.text.font'],\n        units_post = prop['chart.units.post'],\n        units_pre = prop['chart.units.pre'],\n        centerx = this.centerx,\n        centery = this.centery,\n        min = this.min,\n        max = this.max,\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        specific = prop['chart.labels.specific'];\n    if (specific) {\n      for (var i = 0; i < specific.length; ++i) {\n        var angle = this.getAngle(specific[i][1]),\n            angle_degrees = angle * (180 / RG.PI),\n            text = specific[i][0].toString(),\n            coords = RG.getRadiusEndPoint(this.centerx, this.centery, angle, this.radius * 0.925);\n        RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': text, 'halign': 'center', 'valign': 'center', 'angle': angle_degrees + 90, 'bounding': false, 'tag': 'labels-specific', color: 'black' });\n      }\n      return;\n    }\n    co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;co.beginPath();for (var i = 0; i <= numLabels; ++i) {\n      var angle = (prop['chart.angles.end'] - prop['chart.angles.start']) * (i / numLabels) + prop['chart.angles.start'];var coords = RG.getRadiusEndPoint(centerx, centery, angle + ((i == 0 || i == numLabels) && prop['chart.border'] ? i == 0 ? 0.05 : -0.05 : 0), this.radius * 0.925 - (prop['chart.text.valign'] === 'bottom' ? 15 : 0));var angleStart = prop['chart.angles.start'],\n          angleEnd = prop['chart.angles.end'],\n          angleRange = angleEnd - angleStart,\n          angleStart_degrees = angleStart * (180 / RG.PI),\n          angleEnd_degrees = angleEnd * (180 / RG.PI),\n          angleRange_degrees = angleRange * (180 / RG.PI);\n      valign = prop['chart.text.valign'];if (prop['chart.border']) {\n        if (i == 0) {\n          halign = 'left';\n        } else if (i == numLabels) {\n          halign = 'right';\n        } else {\n          halign = 'center';\n        }\n      } else {\n        halign = 'center';\n      }\n      var value = (this.max - this.min) * (i / numLabels) + this.min;RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': RG.numberFormat(this, value.toFixed(value === 0 ? 0 : decimals), units_pre, units_post), 'halign': halign, 'valign': valign, 'angle': angleRange_degrees * (1 / numLabels) * i + angleStart_degrees - 270, 'bounding': false, 'boundingFill': i == 0 || i == numLabels ? 'white' : null, 'tag': 'scale' });\n    }\n  };this.drawReadout = this.DrawReadout = function () {\n    if (prop['chart.value.text']) {\n      co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx, 'y': this.centery - prop['chart.text.size'] - 15, 'text': prop['chart.value.text.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.text.units.post'], 'halign': 'center', 'valign': 'bottom', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });co.stroke();co.fill();\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (radius > this.radius) {\n      return null;\n    }\n    if (angle < RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = Math.max(value, this.min);value = Math.min(value, this.max);return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(this.canvas);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);var ranges = prop['chart.colors.ranges'];if (ranges && ranges.length) {\n      for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, prop['chart.segment.radius.start'], this.centerx, this.centery, this.radius * 0.85);var diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;obj.currentValue = obj.currentValue || obj.min;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var diff = obj.value - obj.currentValue;var step = diff / frames;var callback = arguments[1] || function () {};var initial = obj.currentValue;function iterator() {\n      obj.value = initial + frame++ * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubWV0ZXIuanM/YWY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLk1ldGVyPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYudmFsdWUhPT0ndW5kZWZpbmVkJyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIGlkPWNvbmYuaWRcbnZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW49Y29uZi5taW47dmFyIG1heD1jb25mLm1heDt2YXIgdmFsdWU9Y29uZi52YWx1ZTt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mO3ZhciBjYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW49YXJndW1lbnRzWzFdO3ZhciBtYXg9YXJndW1lbnRzWzJdO3ZhciB2YWx1ZT1hcmd1bWVudHNbM107fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOih0eXBlb2YgaWQ9PT0nb2JqZWN0JyYmaWQuYWxwaGE9PT1mYWxzZSk/ZmFsc2U6dHJ1ZX0pOm51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudHlwZT0nbWV0ZXInO3RoaXMubWluPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1pbik7dGhpcy5tYXg9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmNlbnRlcng9bnVsbDt0aGlzLmNlbnRlcnk9bnVsbDt0aGlzLnJhZGl1cz1udWxsO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLmN1cnJlbnRWYWx1ZT1udWxsO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS51cmwnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uub2Zmc2V0eCc6MCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5vZmZzZXR5JzowLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOid3aGl0ZScsJ2NoYXJ0Lmd1dHRlci5sZWZ0JzoxNSwnY2hhcnQuZ3V0dGVyLnJpZ2h0JzoxNSwnY2hhcnQuZ3V0dGVyLnRvcCc6MTUsJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOjIwLCdjaGFydC5saW5ld2lkdGgnOjEsJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyc6MCwnY2hhcnQuc3Ryb2tlc3R5bGUnOm51bGwsJ2NoYXJ0LmJvcmRlcic6dHJ1ZSwnY2hhcnQuYm9yZGVyLmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LnZhbGlnbic6J2NlbnRlcicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6ZmFsc2UsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQudmFsdWUudGV4dC5kZWNpbWFscyc6MCwnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnOicnLCdjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnBvc3QnOicnLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpdGxlLmhwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnZwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLmNvbG9yJzonYmxhY2snLCdjaGFydC50aXRsZS5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS5mb250JzpudWxsLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQuZ3JlZW4uc3RhcnQnOigodGhpcy5tYXgtdGhpcy5taW4pKjAuMzUpK3RoaXMubWluLCdjaGFydC5ncmVlbi5lbmQnOnRoaXMubWF4LCdjaGFydC5ncmVlbi5jb2xvcic6JyMyMDdBMjAnLCdjaGFydC55ZWxsb3cuc3RhcnQnOigodGhpcy5tYXgtdGhpcy5taW4pKjAuMSkrdGhpcy5taW4sJ2NoYXJ0LnllbGxvdy5lbmQnOigodGhpcy5tYXgtdGhpcy5taW4pKjAuMzUpK3RoaXMubWluLCdjaGFydC55ZWxsb3cuY29sb3InOicjRDBBQzQxJywnY2hhcnQucmVkLnN0YXJ0Jzp0aGlzLm1pbiwnY2hhcnQucmVkLmVuZCc6KCh0aGlzLm1heC10aGlzLm1pbikqMC4xKSt0aGlzLm1pbiwnY2hhcnQucmVkLmNvbG9yJzonIzlFMUUxRScsJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnOm51bGwsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmhkaXInOidyaWdodCcsJ2NoYXJ0Lnpvb20udmRpcic6J2Rvd24nLCdjaGFydC56b29tLmZyYW1lcyc6MjUsJ2NoYXJ0Lnpvb20uZGVsYXknOjE2LjY2NiwnY2hhcnQuem9vbS5zaGFkb3cnOnRydWUsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQuem9vbS5hY3Rpb24nOid6b29tJywnY2hhcnQuYW5ub3RhdGFibGUnOmZhbHNlLCdjaGFydC5hbm5vdGF0ZS5jb2xvcic6J2JsYWNrJywnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzoncmdiYSgwLDAsMCwwLjUpJywnY2hhcnQuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzozLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MywnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOlswLDBdLCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbC5udW0nOjEwMCwnY2hhcnQudGlja21hcmtzLmJpZy5udW0nOjEwLCdjaGFydC50aWNrbWFya3Muc21hbGwuY29sb3InOicjYmJiJywnY2hhcnQudGlja21hcmtzLmJpZy5jb2xvcic6J2JsYWNrJywnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LnJhZGl1cyc6bnVsbCwnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQubGFiZWxzJzp0cnVlLCdjaGFydC5sYWJlbHMuY291bnQnOjEwLCdjaGFydC5sYWJlbHMuc3BlY2lmaWMnOm51bGwsJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0JzowLCdjaGFydC5uZWVkbGUucmFkaXVzJzpudWxsLCdjaGFydC5uZWVkbGUudGFpbCc6ZmFsc2UsJ2NoYXJ0Lm5lZWRsZS5oZWFkJzp0cnVlLCdjaGFydC5uZWVkbGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lm5lZWRsZS5pbWFnZS51cmwnOm51bGwsJ2NoYXJ0Lm5lZWRsZS5pbWFnZS5vZmZzZXR4JzowLCdjaGFydC5uZWVkbGUuaW1hZ2Uub2Zmc2V0eSc6MCwnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFuZ2xlcy5zdGFydCc6UkdyYXBoLlBJLCdjaGFydC5hbmdsZXMuZW5kJzpSR3JhcGguVFdPUEksJ2NoYXJ0LmNlbnRlcnBpbi5zdHJva2UnOidibGFjaycsJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJzond2hpdGUnLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbTUVURVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9YXJndW1lbnRzWzFdfHxudWxsO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC52YWx1ZScpe3RoaXMudmFsdWU9dmFsdWU7cmV0dXJuO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZihuYW1lPT0nY2hhcnQudmFsdWUnKXtyZXR1cm4gdGhpcy52YWx1ZTt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTtpZih0aGlzLnZhbHVlPnRoaXMubWF4KXRoaXMudmFsdWU9dGhpcy5tYXg7aWYodGhpcy52YWx1ZTx0aGlzLm1pbil0aGlzLnZhbHVlPXRoaXMubWluO3RoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PWNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbTt0aGlzLnJhZGl1cz1NYXRoLm1pbigoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzIsKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkpO3RoaXMuY29vcmRzVGV4dD1bXTtpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeCddKT09J251bWJlcicpdGhpcy5jZW50ZXJ4PXByb3BbJ2NoYXJ0LmNlbnRlcngnXTtpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeSddKT09J251bWJlcicpdGhpcy5jZW50ZXJ5PXByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZih0eXBlb2YocHJvcFsnY2hhcnQucmFkaXVzJ10pPT0nbnVtYmVyJyl0aGlzLnJhZGl1cz1wcm9wWydjaGFydC5yYWRpdXMnXTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbnRoaXMuZHJhd0JhY2tncm91bmQoKTt0aGlzLmRyYXdMYWJlbHMoKTt0aGlzLmRyYXdOZWVkbGUoKTt0aGlzLmRyYXdSZWFkb3V0KCk7UkcuRHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSx0aGlzLmd1dHRlclRvcCxudWxsLHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMik7aWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZD10aGlzLkRyYXdCYWNrZ3JvdW5kPWZ1bmN0aW9uKClcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS51cmwnXT09PSdzdHJpbmcnJiYhdGhpcy5fX2JhY2tncm91bmRfaW1hZ2VfXyl7dmFyIHg9MCtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLm9mZnNldHgnXTt2YXIgeT0wK3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uub2Zmc2V0eSddO3ZhciBpbWc9bmV3IEltYWdlKCk7dGhpcy5fX2JhY2tncm91bmRfaW1hZ2VfXz1pbWc7aW1nLnNyYz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnVybCddO2ltZy5vbmxvYWQ9ZnVuY3Rpb24oKVxue2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCddKXtjby5kcmF3SW1hZ2UodGhpcyx4LHksY2Eud2lkdGgsY2EuaGVpZ2h0KTt9ZWxzZXtjby5kcmF3SW1hZ2UodGhpcyx4LHkpO31cblJHLnJlZHJhdygpO319ZWxzZSBpZih0aGlzLl9fYmFja2dyb3VuZF9pbWFnZV9fKXt2YXIgeD0wK3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uub2Zmc2V0eCddO3ZhciB5PTArcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5vZmZzZXR5J107aWYocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5zdHJldGNoJ10pe2NvLmRyYXdJbWFnZSh0aGlzLl9fYmFja2dyb3VuZF9pbWFnZV9fLHgseSxjYS53aWR0aCxjYS5oZWlnaHQpO31lbHNle2NvLmRyYXdJbWFnZSh0aGlzLl9fYmFja2dyb3VuZF9pbWFnZV9fLHgseSk7fX1cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLlNldFNoYWRvdyh0aGlzLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTt9XG5jby5tb3ZlVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10scHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLGZhbHNlKTtjby5maWxsKCk7UkcuTm9TaGFkb3codGhpcyk7aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe2NvLmJlZ2luUGF0aCgpO3ZhciByPSh0aGlzLnJhZGl1cyowLjA2KT40MD80MDoodGhpcy5yYWRpdXMqMC4wNik7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksciwwLFJHLlRXT1BJLDApO2NvLmZpbGwoKTtSRy5Ob1NoYWRvdyh0aGlzKTt9XG5pZihwcm9wWydjaGFydC50aWNrbWFya3Muc21hbGwubnVtJ10pe2Zvcih2YXIgaT0wO2k8KHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSk7aSs9KFJHLlBJL3Byb3BbJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbC5udW0nXSkpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbC5jb2xvciddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddK2kscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10raSswLjAwMDAxLDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTUscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10raSxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXStpKzAuMDAwMDEsMCk7Y28uc3Ryb2tlKCk7fVxuY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy00LHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSxmYWxzZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO31cbmlmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcubnVtJ10pe3ZhciBjb2xvcnM9Wyd3aGl0ZScsJ3doaXRlJyxwcm9wWydjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJ11dO2Zvcih2YXIgaj0wO2o8Y29sb3JzLmxlbmd0aDsrK2ope2Zvcih2YXIgaT0wO2k8KHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSk7aSs9KChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pL3Byb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcubnVtJ10pKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1jb2xvcnNbal07Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10raSxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXStpKzAuMDAxLDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTUscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10raSxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXStpKzAuMDAwMSwwKTtjby5zdHJva2UoKTt9fX1cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28ubW92ZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTcscHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10scHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLGZhbHNlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7dmFyIHJhbmdlcz1wcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ107aWYoUkcuaXNfYXJyYXkocHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddKSl7dmFyIHJhbmdlcz1wcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ107Zm9yKHZhciBpPTA7aTxyYW5nZXMubGVuZ3RoOysraSl7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT9wcm9wWydjaGFydC5zdHJva2VzdHlsZSddOnJhbmdlc1tpXVsyXTtjby5maWxsU3R5bGU9cmFuZ2VzW2ldWzJdO2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGguc2VnbWVudHMnXTtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyowLjg1LCgoKHJhbmdlc1tpXVswXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCgoKHJhbmdlc1tpXVsxXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLGZhbHNlKTtpZihwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddPjApe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10sKCgocmFuZ2VzW2ldWzFdLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sKCgocmFuZ2VzW2ldWzBdLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO31cbmNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9XG5jby5iZWdpblBhdGgoKTt9ZWxzZXtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT9wcm9wWydjaGFydC5zdHJva2VzdHlsZSddOnByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyddO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKjAuODUsKCgocHJvcFsnY2hhcnQuZ3JlZW4uc3RhcnQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS10aGlzLnByb3BlcnRpZXNbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sKCgocHJvcFsnY2hhcnQuZ3JlZW4uZW5kJ10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKStwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxmYWxzZSk7aWYocHJvcFsnY2hhcnQuc2VnbWVudC5yYWRpdXMuc3RhcnQnXT4wKXtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddLCgoKHByb3BbJ2NoYXJ0LmdyZWVuLmVuZCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sKCgocHJvcFsnY2hhcnQuZ3JlZW4uc3RhcnQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLHRydWUpO31lbHNle2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTt9XG5jby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT9wcm9wWydjaGFydC5zdHJva2VzdHlsZSddOnByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC55ZWxsb3cuY29sb3InXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoLnNlZ21lbnRzJ107Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMqMC44NSwoKChwcm9wWydjaGFydC55ZWxsb3cuc3RhcnQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCgoKHByb3BbJ2NoYXJ0LnllbGxvdy5lbmQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLGZhbHNlKTtpZihwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddPjApe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10sKCgocHJvcFsnY2hhcnQueWVsbG93LmVuZCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sKCgocHJvcFsnY2hhcnQueWVsbG93LnN0YXJ0J10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKStwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSx0cnVlKTt9ZWxzZXtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7fVxuY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10/cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTpwcm9wWydjaGFydC5yZWQuY29sb3InXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQucmVkLmNvbG9yJ107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyddO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKjAuODUsKCgocHJvcFsnY2hhcnQucmVkLnN0YXJ0J10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKStwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSwoKChwcm9wWydjaGFydC5yZWQuZW5kJ10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKStwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxmYWxzZSk7aWYocHJvcFsnY2hhcnQuc2VnbWVudC5yYWRpdXMuc3RhcnQnXT4wKXtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddLCgoKHByb3BbJ2NoYXJ0LnJlZC5lbmQnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCgoKHByb3BbJ2NoYXJ0LnJlZC5zdGFydCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkrcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO31cbmNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5saW5lV2lkdGg9MTt9XG5pZihwcm9wWydjaGFydC5ib3JkZXInXSl7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yJ107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10sZmFsc2UpO2NvLmNsb3NlUGF0aCgpO31cbmNvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aD0xO307dGhpcy5kcmF3TmVlZGxlPXRoaXMuRHJhd05lZWRsZT1mdW5jdGlvbigpXG57dmFyIGE9KCgodGhpcy52YWx1ZS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddO2lmKHR5cGVvZiBwcm9wWydjaGFydC5uZWVkbGUuaW1hZ2UudXJsJ109PT0nc3RyaW5nJyYmIXRoaXMuX19uZWVkbGVfaW1hZ2VfXyl7dmFyIGltZz1uZXcgSW1hZ2UoKTt0aGlzLl9fbmVlZGxlX2ltYWdlX189aW1nO2ltZy5zcmM9cHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLnVybCddO2ltZy5vbmxvYWQ9ZnVuY3Rpb24oKVxue2NvLnNhdmUoKTtSRy5yb3RhdGVDYW52YXMoY2EsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxhKTtjby5kcmF3SW1hZ2UodGhpcyx0aGlzLmNlbnRlcngrcHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLm9mZnNldHgnXSx0aGlzLmNlbnRlcnkrcHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLm9mZnNldHknXSk7Y28ucmVzdG9yZSgpO1JHLnJlZHJhdygpO319ZWxzZSBpZih0aGlzLl9fbmVlZGxlX2ltYWdlX18pe2NvLnNhdmUoKTtSRy5yb3RhdGVDYW52YXMoY2EsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxhKTtjby5kcmF3SW1hZ2UodGhpcy5fX25lZWRsZV9pbWFnZV9fLHRoaXMuY2VudGVyeCtwcm9wWydjaGFydC5uZWVkbGUuaW1hZ2Uub2Zmc2V0eCddLHRoaXMuY2VudGVyeStwcm9wWydjaGFydC5uZWVkbGUuaW1hZ2Uub2Zmc2V0eSddKTtjby5yZXN0b3JlKCk7fVxudmFyIG5lZWRsZVJhZGl1cz10eXBlb2YocHJvcFsnY2hhcnQubmVlZGxlLnJhZGl1cyddKT09J251bWJlcic/cHJvcFsnY2hhcnQubmVlZGxlLnJhZGl1cyddOnRoaXMucmFkaXVzKjAuNztjby5maWxsU3R5bGU9J2JsYWNrJztjby5saW5lV2lkdGg9dGhpcy5yYWRpdXM+PTIwMD83OjM7Y28ubGluZUNhcD0ncm91bmQnO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddO2lmKHR5cGVvZihwcm9wWydjaGFydC5uZWVkbGUubGluZXdpZHRoJ10pPT0nbnVtYmVyJyljby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubmVlZGxlLmxpbmV3aWR0aCddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG5lZWRsZVJhZGl1cyxhLGErMC4wMDEsZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTtpZihwcm9wWydjaGFydC5uZWVkbGUuaGVhZCddKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPTE7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbmVlZGxlUmFkaXVzKzE1LGEsYSswLjAwMSwwKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxuZWVkbGVSYWRpdXMtMTUsYSswLjA4NyxhKzAuMDg3OTk5LDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG5lZWRsZVJhZGl1cy0xNSxhLTAuMDg3LGEtMC4wODc5OTksMSk7Y28uZmlsbCgpO31cbmlmKHByb3BbJ2NoYXJ0Lm5lZWRsZS50YWlsJ10pe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddO2lmKHR5cGVvZihwcm9wWydjaGFydC5uZWVkbGUubGluZXdpZHRoJ10pPT0nbnVtYmVyJyljby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubmVlZGxlLmxpbmV3aWR0aCddO3ZhciBhPSgodGhpcy52YWx1ZS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSoodGhpcy5wcm9wZXJ0aWVzWydjaGFydC5hbmdsZXMuZW5kJ10tdGhpcy5wcm9wZXJ0aWVzWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpK3RoaXMucHJvcGVydGllc1snY2hhcnQuYW5nbGVzLnN0YXJ0J10rUkcuUEk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMjUsYSxhKzAuMDAxLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uc3Ryb2tlKCk7fVxudmFyIHI9KHRoaXMucmFkaXVzKjAuMDYpPjQwPzQwOih0aGlzLnJhZGl1cyowLjA2KTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY2VudGVycGluLnN0cm9rZSddO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHIsMCswLjAwMSxSRy5UV09QSSwwKTtjby5maWxsKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ107Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksci0yLDArMC4wMDEsUkcuVFdPUEksMCk7Y28uZmlsbCgpO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57aWYoIXByb3BbJ2NoYXJ0LmxhYmVscyddKXtyZXR1cm47fVxudmFyIHJhZGl1cz10aGlzLnJhZGl1cyx0ZXh0X3NpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sdGV4dF9mb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddLHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXSxjZW50ZXJ4PXRoaXMuY2VudGVyeCxjZW50ZXJ5PXRoaXMuY2VudGVyeSxtaW49dGhpcy5taW4sbWF4PXRoaXMubWF4LGRlY2ltYWxzPXByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sbnVtTGFiZWxzPXByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLHNwZWNpZmljPXByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddXG5pZihzcGVjaWZpYyl7Zm9yKHZhciBpPTA7aTxzcGVjaWZpYy5sZW5ndGg7KytpKXt2YXIgYW5nbGU9dGhpcy5nZXRBbmdsZShzcGVjaWZpY1tpXVsxXSksYW5nbGVfZGVncmVlcz1hbmdsZSooMTgwL1JHLlBJKSx0ZXh0PXNwZWNpZmljW2ldWzBdLnRvU3RyaW5nKCksY29vcmRzPVJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksYW5nbGUsdGhpcy5yYWRpdXMqMC45MjUpXG5SRy50ZXh0Mih0aGlzLHsnZm9udCc6dGV4dF9mb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOmNvb3Jkc1swXSwneSc6Y29vcmRzWzFdLCd0ZXh0Jzp0ZXh0LCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCdhbmdsZSc6YW5nbGVfZGVncmVlcys5MCwnYm91bmRpbmcnOmZhbHNlLCd0YWcnOidsYWJlbHMtc3BlY2lmaWMnLGNvbG9yOidibGFjayd9KTt9XG5yZXR1cm47fVxuY28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5saW5lV2lkdGg9MTtjby5iZWdpblBhdGgoKTtmb3IodmFyIGk9MDtpPD1udW1MYWJlbHM7KytpKXt2YXIgYW5nbGU9KChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKihpL251bUxhYmVscykpK3Byb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddO3ZhciBjb29yZHM9UkcuZ2V0UmFkaXVzRW5kUG9pbnQoY2VudGVyeCxjZW50ZXJ5LGFuZ2xlKygoKGk9PTB8fGk9PW51bUxhYmVscykmJnByb3BbJ2NoYXJ0LmJvcmRlciddKT8oaT09MD8wLjA1Oi0wLjA1KTowKSwodGhpcy5yYWRpdXMqMC45MjUpLShwcm9wWydjaGFydC50ZXh0LnZhbGlnbiddPT09J2JvdHRvbSc/MTU6MCkpO3ZhciBhbmdsZVN0YXJ0PXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLGFuZ2xlRW5kPXByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSxhbmdsZVJhbmdlPWFuZ2xlRW5kLWFuZ2xlU3RhcnQsYW5nbGVTdGFydF9kZWdyZWVzPWFuZ2xlU3RhcnQqKDE4MC9SRy5QSSksYW5nbGVFbmRfZGVncmVlcz1hbmdsZUVuZCooMTgwL1JHLlBJKSxhbmdsZVJhbmdlX2RlZ3JlZXM9YW5nbGVSYW5nZSooMTgwL1JHLlBJKVxudmFsaWduPXByb3BbJ2NoYXJ0LnRleHQudmFsaWduJ107aWYocHJvcFsnY2hhcnQuYm9yZGVyJ10pe2lmKGk9PTApe2hhbGlnbj0nbGVmdCc7fWVsc2UgaWYoaT09bnVtTGFiZWxzKXtoYWxpZ249J3JpZ2h0Jzt9ZWxzZXtoYWxpZ249J2NlbnRlcid9fWVsc2V7aGFsaWduPSdjZW50ZXInO31cbnZhciB2YWx1ZT0oKHRoaXMubWF4LXRoaXMubWluKSooaS9udW1MYWJlbHMpKSt0aGlzLm1pbjtSRy50ZXh0Mih0aGlzLHsnZm9udCc6dGV4dF9mb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOmNvb3Jkc1swXSwneSc6Y29vcmRzWzFdLCd0ZXh0JzpSRy5udW1iZXJGb3JtYXQodGhpcywodmFsdWUpLnRvRml4ZWQodmFsdWU9PT0wPzA6ZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzpoYWxpZ24sJ3ZhbGlnbic6dmFsaWduLCdhbmdsZSc6KChhbmdsZVJhbmdlX2RlZ3JlZXMqKDEvbnVtTGFiZWxzKSppKSthbmdsZVN0YXJ0X2RlZ3JlZXMpLTI3MCwnYm91bmRpbmcnOmZhbHNlLCdib3VuZGluZ0ZpbGwnOihpPT0wfHxpPT1udW1MYWJlbHMpPyd3aGl0ZSc6bnVsbCwndGFnJzonc2NhbGUnfSk7fX07dGhpcy5kcmF3UmVhZG91dD10aGlzLkRyYXdSZWFkb3V0PWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC52YWx1ZS50ZXh0J10pe2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcuVGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwneCc6dGhpcy5jZW50ZXJ4LCd5Jzp0aGlzLmNlbnRlcnktcHJvcFsnY2hhcnQudGV4dC5zaXplJ10tMTUsJ3RleHQnOnByb3BbJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucHJlJ10rKHRoaXMudmFsdWUpLnRvRml4ZWQocHJvcFsnY2hhcnQudmFsdWUudGV4dC5kZWNpbWFscyddKStwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnBvc3QnXSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonYm90dG9tJywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nRmlsbCc6J3doaXRlJywndGFnJzondmFsdWUudGV4dCd9KTtjby5zdHJva2UoKTtjby5maWxsKCk7fX07dGhpcy5nZXRTaGFwZT1mdW5jdGlvbihlKXt9O3RoaXMuZ2V0VmFsdWU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBhbmdsZT1SRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pO3ZhciByYWRpdXM9UkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbW91c2VYWVswXSxtb3VzZVhZWzFdKTtpZihyYWRpdXM+dGhpcy5yYWRpdXMpe3JldHVybiBudWxsO31cbmlmKGFuZ2xlPFJHLkhBTEZQSSl7YW5nbGUrPVJHLlRXT1BJO31cbnZhciB2YWx1ZT0oKChhbmdsZS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkvKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXS1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkpKih0aGlzLm1heC10aGlzLm1pbikpK3RoaXMubWluO3ZhbHVlPU1hdGgubWF4KHZhbHVlLHRoaXMubWluKTt2YWx1ZT1NYXRoLm1pbih2YWx1ZSx0aGlzLm1heCk7cmV0dXJuIHZhbHVlO307dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIHJhZGl1cz1SRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pO2lmKG1vdXNlWFlbMF0+KHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cykmJm1vdXNlWFlbMF08KHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cykmJm1vdXNlWFlbMV0+KHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cykmJm1vdXNlWFlbMV08KHRoaXMuY2VudGVyeSt0aGlzLnJhZGl1cykmJnJhZGl1czw9dGhpcy5yYWRpdXMpe3JldHVybiB0aGlzO319O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZT10aGlzLkFkanVzdGluZ19tb3VzZW1vdmU9ZnVuY3Rpb24oZSlcbntpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykmJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkPT10aGlzLnVpZCl7dGhpcy52YWx1ZT10aGlzLmdldFZhbHVlKGUpO1JHLmNsZWFyKHRoaXMuY2FudmFzKTtSRy5yZWRyYXdDYW52YXModGhpcy5jYW52YXMpO1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmFkanVzdCcpO319O3RoaXMuZ2V0QW5nbGU9ZnVuY3Rpb24odmFsdWUpXG57aWYodmFsdWU+dGhpcy5tYXh8fHZhbHVlPHRoaXMubWluKXtyZXR1cm4gbnVsbDt9XG52YXIgYW5nbGU9KCgodmFsdWUtdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10tcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pKStwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTtyZXR1cm4gYW5nbGU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZ3JlZW4uY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQueWVsbG93LmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5yZWQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5yZWQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO31cbnByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXSk7cHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnJlZC5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTt2YXIgcmFuZ2VzPXByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXTtpZihyYW5nZXMmJnJhbmdlcy5sZW5ndGgpe2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDsrK2kpe3Jhbmdlc1tpXVsyXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChyYW5nZXNbaV1bMl0pO319fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10sdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyowLjg1KTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Zm9yKHZhciBqPTA7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMuZ3Jvdz1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO29iai5jdXJyZW50VmFsdWU9b2JqLmN1cnJlbnRWYWx1ZXx8b2JqLm1pbjt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzfHwzMDt2YXIgZnJhbWU9MDt2YXIgZGlmZj1vYmoudmFsdWUtb2JqLmN1cnJlbnRWYWx1ZTt2YXIgc3RlcD1kaWZmL2ZyYW1lczt2YXIgY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe307dmFyIGluaXRpYWw9b2JqLmN1cnJlbnRWYWx1ZTtmdW5jdGlvbiBpdGVyYXRvcigpXG57b2JqLnZhbHVlPWluaXRpYWwrKGZyYW1lKysgKnN0ZXApO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZihmcmFtZTw9ZnJhbWVzKXtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O1JHLmF0dChjYSk7UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubWV0ZXIuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///225\n");

/***/ }),
/* 226 */
/***/ (function(module, exports) {

eval("\nModalDialog = { dialog: null, background: null, offset: 50, events: [], Show: function Show(id, width) {\n    ModalDialog.id = id;ModalDialog.width = width;ModalDialog.ShowBackground();ModalDialog.ShowDialog();window.onresize = ModalDialog.Resize;document.body.addEventListener('keydown', function (e) {\n      if (e.keyCode === 27) {\n        ModalDialog.hide();\n      }\n    }, false);ModalDialog.Resize();if (typeof ModalDialog.onmodaldialog == 'function') {\n      ModalDialog.onmodaldialog();\n    }\n    ModalDialog.FireCustomEvent('onmodaldialog');\n  }, ShowBackground: function ShowBackground() {\n    ModalDialog.background = document.createElement('DIV');ModalDialog.background.className = 'ModalDialog_background';ModalDialog.background.style.position = 'fixed';ModalDialog.background.style.top = 0;ModalDialog.background.style.left = 0;ModalDialog.background.style.width = screen.width + 100 + 'px';ModalDialog.background.style.height = screen.height + 100 + 'px';ModalDialog.background.style.backgroundColor = 'rgb(204,204,204)';ModalDialog.background.style.opacity = 0;ModalDialog.background.style.zIndex = 3276;ModalDialog.background.style.filter = \"Alpha(opacity=50)\";document.body.appendChild(ModalDialog.background);ModalDialog.background.style.visibility = 'visible';\n  }, ShowDialog: function ShowDialog() {\n    if (!ModalDialog.dialog || true) {\n      ModalDialog.dialog = document.createElement('DIV');ModalDialog.dialog.id = 'ModalDialog_dialog';ModalDialog.dialog.className = 'ModalDialog_dialog';var borderRadius = '15px';ModalDialog.dialog.style.borderRadius = borderRadius;ModalDialog.dialog.style.MozBorderRadius = borderRadius;ModalDialog.dialog.style.WebkitBorderRadius = borderRadius;ModalDialog.dialog.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';ModalDialog.dialog.style.position = 'fixed';ModalDialog.dialog.style.backgroundColor = 'white';ModalDialog.dialog.style.width = parseInt(ModalDialog.width) + 'px';ModalDialog.dialog.style.border = '2px solid #999';ModalDialog.dialog.style.zIndex = 32767;ModalDialog.dialog.style.padding = '5px';ModalDialog.dialog.style.paddingTop = '25px';ModalDialog.dialog.style.opacity = 0;if (document.all) {\n        ModalDialog.dialog.style.zIndex = 32767;\n      }\n      if (navigator.userAgent.indexOf('Opera') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('MSIE') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('Safari') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      }\n      document.body.appendChild(ModalDialog.dialog);var bar = document.createElement('DIV');bar.className = 'ModalDialog_topbar';bar.style.top = 0;bar.style.left = 0;bar.style.width = '100%';bar.style.height = '20px';bar.style.backgroundColor = '#bbb';bar.style.borderBottom = '2px solid #999';bar.style.position = 'absolute';var borderRadius = '11px';bar.style.WebkitBorderTopLeftRadius = borderRadius;bar.style.WebkitBorderTopRightRadius = borderRadius;bar.style.MozBorderRadiusTopleft = borderRadius;bar.style.MozBorderRadiusTopright = borderRadius;bar.style.borderTopRightRadius = borderRadius;bar.style.borderTopLeftRadius = borderRadius;ModalDialog.dialog.appendChild(bar);var content = document.createElement('DIV');content.style.width = '100%';content.style.height = '100%';ModalDialog.dialog.appendChild(content);if (ModalDialog.id.toLowerCase().substring(0, 7) == 'string:') {\n        content.innerHTML = ModalDialog.id.substring(7);\n      } else {\n        content.innerHTML = document.getElementById(ModalDialog.id).innerHTML;\n      }\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';ModalDialog.dialog.style.top = '30%';\n    }\n    ModalDialog.dialog.style.visibility = 'visible';setTimeout('ModalDialog.dialog.style.opacity = 0.2', 50);setTimeout('ModalDialog.dialog.style.opacity = 0.4', 100);setTimeout('ModalDialog.dialog.style.opacity = 0.6', 150);setTimeout('ModalDialog.dialog.style.opacity = 0.8', 200);setTimeout('ModalDialog.dialog.style.opacity = 1', 250);setTimeout('ModalDialog.background.style.opacity = 0.1', 50);setTimeout('ModalDialog.background.style.opacity = 0.2', 100);setTimeout('ModalDialog.background.style.opacity = 0.3', 150);setTimeout('ModalDialog.background.style.opacity = 0.4', 200);setTimeout('ModalDialog.background.style.opacity = 0.5', 250);\n  }, Close: function Close() {\n    if (ModalDialog.dialog) {\n      if (document.getElementById(ModalDialog.dialog.id)) {\n        document.body.removeChild(ModalDialog.dialog);\n      }\n      ModalDialog.dialog.style.visibility = 'hidden';ModalDialog.dialog.style.opacity = 0;\n    }\n    if (ModalDialog.background) {\n      ModalDialog.background.style.visibility = 'hidden';ModalDialog.background.style.opacity = 0;if (document.getElementById(ModalDialog.background.id)) {\n        document.body.removeChild(ModalDialog.background);\n      }\n    }\n  }, Resize: function Resize() {\n    if (ModalDialog.dialog) {\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';\n    }\n    ModalDialog.background.style.width = '2500px';ModalDialog.background.style.height = '2500px';\n  }, AddCustomEventListener: function AddCustomEventListener(name, func) {\n    if (typeof ModalDialog.events == 'undefined') {\n      ModalDialog.events = [];\n    }\n    ModalDialog.events.push([name, func]);\n  }, FireCustomEvent: function FireCustomEvent(name) {\n    for (var i = 0; i < ModalDialog.events.length; ++i) {\n      if (typeof ModalDialog.events[i][0] == 'string' && ModalDialog.events[i][0] == name && typeof ModalDialog.events[i][1] == 'function') {\n        ModalDialog.events[i][1]();\n      }\n    }\n  }, isIE8: function isIE8() {\n    return document.all && navigator.userAgent.indexOf('MSIE 8') > 0;\n  } };ModalDialog.show = ModalDialog.Show;ModalDialog.draw = ModalDialog.Show;ModalDialog.Hide = ModalDialog.Close;ModalDialog.hide = ModalDialog.Close;ModalDialog.close = ModalDialog.Close;for (i in ModalDialog) {\n  if (typeof ModalDialog[i] === 'function') {\n    ModalDialog[i.toLowerCase()] = ModalDialog[i];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubW9kYWxkaWFsb2cuanM/YjE1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbk1vZGFsRGlhbG9nPXtkaWFsb2c6bnVsbCxiYWNrZ3JvdW5kOm51bGwsb2Zmc2V0OjUwLGV2ZW50czpbXSxTaG93OmZ1bmN0aW9uKGlkLHdpZHRoKVxue01vZGFsRGlhbG9nLmlkPWlkO01vZGFsRGlhbG9nLndpZHRoPXdpZHRoO01vZGFsRGlhbG9nLlNob3dCYWNrZ3JvdW5kKCk7TW9kYWxEaWFsb2cuU2hvd0RpYWxvZygpO3dpbmRvdy5vbnJlc2l6ZT1Nb2RhbERpYWxvZy5SZXNpemU7ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxmdW5jdGlvbihlKVxue2lmKGUua2V5Q29kZT09PTI3KXtNb2RhbERpYWxvZy5oaWRlKCk7fX0sZmFsc2UpO01vZGFsRGlhbG9nLlJlc2l6ZSgpO2lmKHR5cGVvZihNb2RhbERpYWxvZy5vbm1vZGFsZGlhbG9nKT09J2Z1bmN0aW9uJyl7TW9kYWxEaWFsb2cub25tb2RhbGRpYWxvZygpO31cbk1vZGFsRGlhbG9nLkZpcmVDdXN0b21FdmVudCgnb25tb2RhbGRpYWxvZycpO30sU2hvd0JhY2tncm91bmQ6ZnVuY3Rpb24oKVxue01vZGFsRGlhbG9nLmJhY2tncm91bmQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7TW9kYWxEaWFsb2cuYmFja2dyb3VuZC5jbGFzc05hbWU9J01vZGFsRGlhbG9nX2JhY2tncm91bmQnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUucG9zaXRpb249J2ZpeGVkJztNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLnRvcD0wO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUubGVmdD0wO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUud2lkdGg9KHNjcmVlbi53aWR0aCsxMDApKydweCc7TW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQ9KHNjcmVlbi5oZWlnaHQrMTAwKSsncHgnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yPSdyZ2IoMjA0LDIwNCwyMDQpJztNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHk9MDtNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLnpJbmRleD0zMjc2O01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUuZmlsdGVyPVwiQWxwaGEob3BhY2l0eT01MClcIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKE1vZGFsRGlhbG9nLmJhY2tncm91bmQpO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUudmlzaWJpbGl0eT0ndmlzaWJsZSc7fSxTaG93RGlhbG9nOmZ1bmN0aW9uKClcbntpZighTW9kYWxEaWFsb2cuZGlhbG9nfHx0cnVlKXtNb2RhbERpYWxvZy5kaWFsb2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7TW9kYWxEaWFsb2cuZGlhbG9nLmlkPSdNb2RhbERpYWxvZ19kaWFsb2cnO01vZGFsRGlhbG9nLmRpYWxvZy5jbGFzc05hbWU9J01vZGFsRGlhbG9nX2RpYWxvZyc7dmFyIGJvcmRlclJhZGl1cz0nMTVweCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmJvcmRlclJhZGl1cz1ib3JkZXJSYWRpdXM7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLk1vekJvcmRlclJhZGl1cz1ib3JkZXJSYWRpdXM7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLldlYmtpdEJvcmRlclJhZGl1cz1ib3JkZXJSYWRpdXM7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmJveFNoYWRvdz0nM3B4IDNweCAzcHggcmdiYSg5Niw5Niw5NiwwLjUpJztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUuTW96Qm94U2hhZG93PSczcHggM3B4IDNweCByZ2JhKDk2LDk2LDk2LDAuNSknO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5XZWJraXRCb3hTaGFkb3c9J3JnYmEoOTYsOTYsOTYsMC41KSAzcHggM3B4IDNweCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnBvc2l0aW9uPSdmaXhlZCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmJhY2tncm91bmRDb2xvcj0nd2hpdGUnO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS53aWR0aD1wYXJzZUludChNb2RhbERpYWxvZy53aWR0aCkrJ3B4JztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUuYm9yZGVyPScycHggc29saWQgIzk5OSc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnpJbmRleD0zMjc2NztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUucGFkZGluZz0nNXB4JztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUucGFkZGluZ1RvcD0nMjVweCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHk9MDtpZihkb2N1bWVudC5hbGwpe01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS56SW5kZXg9MzI3Njc7fVxuaWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPcGVyYScpIT0tMSl7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnBhZGRpbmdUb3A9JzI1cHgnO31lbHNlIGlmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpIT0tMSl7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnBhZGRpbmdUb3A9JzI1cHgnO31lbHNlIGlmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykhPS0xKXtNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUucGFkZGluZ1RvcD0nMjVweCc7fVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChNb2RhbERpYWxvZy5kaWFsb2cpO3ZhciBiYXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7YmFyLmNsYXNzTmFtZT0nTW9kYWxEaWFsb2dfdG9wYmFyJztiYXIuc3R5bGUudG9wPTA7YmFyLnN0eWxlLmxlZnQ9MDtiYXIuc3R5bGUud2lkdGg9JzEwMCUnO2Jhci5zdHlsZS5oZWlnaHQ9JzIwcHgnO2Jhci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9JyNiYmInO2Jhci5zdHlsZS5ib3JkZXJCb3R0b209JzJweCBzb2xpZCAjOTk5JztiYXIuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJzt2YXIgYm9yZGVyUmFkaXVzPScxMXB4JztiYXIuc3R5bGUuV2Via2l0Qm9yZGVyVG9wTGVmdFJhZGl1cz1ib3JkZXJSYWRpdXM7YmFyLnN0eWxlLldlYmtpdEJvcmRlclRvcFJpZ2h0UmFkaXVzPWJvcmRlclJhZGl1cztiYXIuc3R5bGUuTW96Qm9yZGVyUmFkaXVzVG9wbGVmdD1ib3JkZXJSYWRpdXM7YmFyLnN0eWxlLk1vekJvcmRlclJhZGl1c1RvcHJpZ2h0PWJvcmRlclJhZGl1cztiYXIuc3R5bGUuYm9yZGVyVG9wUmlnaHRSYWRpdXM9Ym9yZGVyUmFkaXVzO2Jhci5zdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzPWJvcmRlclJhZGl1cztNb2RhbERpYWxvZy5kaWFsb2cuYXBwZW5kQ2hpbGQoYmFyKTt2YXIgY29udGVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtjb250ZW50LnN0eWxlLndpZHRoPScxMDAlJztjb250ZW50LnN0eWxlLmhlaWdodD0nMTAwJSc7TW9kYWxEaWFsb2cuZGlhbG9nLmFwcGVuZENoaWxkKGNvbnRlbnQpO2lmKE1vZGFsRGlhbG9nLmlkLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsNyk9PSdzdHJpbmc6Jyl7Y29udGVudC5pbm5lckhUTUw9TW9kYWxEaWFsb2cuaWQuc3Vic3RyaW5nKDcpO31lbHNle2NvbnRlbnQuaW5uZXJIVE1MPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1vZGFsRGlhbG9nLmlkKS5pbm5lckhUTUw7fVxuTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmxlZnQ9KGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgvMiktKE1vZGFsRGlhbG9nLmRpYWxvZy5vZmZzZXRXaWR0aC8yKSsncHgnO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS50b3A9JzMwJSc7fVxuTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnZpc2liaWxpdHk9J3Zpc2libGUnO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMC4yJyw1MCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSAwLjQnLDEwMCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSAwLjYnLDE1MCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSAwLjgnLDIwMCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSAxJywyNTApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDAuMScsNTApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDAuMicsMTAwKTtzZXRUaW1lb3V0KCdNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSAwLjMnLDE1MCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gMC40JywyMDApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDAuNScsMjUwKTt9LENsb3NlOmZ1bmN0aW9uKClcbntpZihNb2RhbERpYWxvZy5kaWFsb2cpe2lmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1vZGFsRGlhbG9nLmRpYWxvZy5pZCkpe2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoTW9kYWxEaWFsb2cuZGlhbG9nKTt9XG5Nb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUub3BhY2l0eT0wO31cbmlmKE1vZGFsRGlhbG9nLmJhY2tncm91bmQpe01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJztNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHk9MDtpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLmlkKSl7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChNb2RhbERpYWxvZy5iYWNrZ3JvdW5kKTt9fX0sUmVzaXplOmZ1bmN0aW9uKClcbntpZihNb2RhbERpYWxvZy5kaWFsb2cpe01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5sZWZ0PShkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoLzIpLShNb2RhbERpYWxvZy5kaWFsb2cub2Zmc2V0V2lkdGgvMikrJ3B4Jzt9XG5Nb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLndpZHRoPScyNTAwcHgnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0PScyNTAwcHgnO30sQWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihuYW1lLGZ1bmMpXG57aWYodHlwZW9mKE1vZGFsRGlhbG9nLmV2ZW50cyk9PSd1bmRlZmluZWQnKXtNb2RhbERpYWxvZy5ldmVudHM9W107fVxuTW9kYWxEaWFsb2cuZXZlbnRzLnB1c2goW25hbWUsZnVuY10pO30sRmlyZUN1c3RvbUV2ZW50OmZ1bmN0aW9uKG5hbWUpXG57Zm9yKHZhciBpPTA7aTxNb2RhbERpYWxvZy5ldmVudHMubGVuZ3RoOysraSl7aWYodHlwZW9mKE1vZGFsRGlhbG9nLmV2ZW50c1tpXVswXSk9PSdzdHJpbmcnJiZNb2RhbERpYWxvZy5ldmVudHNbaV1bMF09PW5hbWUmJnR5cGVvZihNb2RhbERpYWxvZy5ldmVudHNbaV1bMV0pPT0nZnVuY3Rpb24nKXtNb2RhbERpYWxvZy5ldmVudHNbaV1bMV0oKTt9fX0saXNJRTg6ZnVuY3Rpb24oKVxue3JldHVybiBkb2N1bWVudC5hbGwmJihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgOCcpPjApO319O01vZGFsRGlhbG9nLnNob3c9TW9kYWxEaWFsb2cuU2hvdztNb2RhbERpYWxvZy5kcmF3PU1vZGFsRGlhbG9nLlNob3c7TW9kYWxEaWFsb2cuSGlkZT1Nb2RhbERpYWxvZy5DbG9zZTtNb2RhbERpYWxvZy5oaWRlPU1vZGFsRGlhbG9nLkNsb3NlO01vZGFsRGlhbG9nLmNsb3NlPU1vZGFsRGlhbG9nLkNsb3NlO2ZvcihpIGluIE1vZGFsRGlhbG9nKXtpZih0eXBlb2YgTW9kYWxEaWFsb2dbaV09PT0nZnVuY3Rpb24nKXtNb2RhbERpYWxvZ1tpLnRvTG93ZXJDYXNlKCldPU1vZGFsRGlhbG9nW2ldfX1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5tb2RhbGRpYWxvZy5qcyJdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///226\n");

/***/ }),
/* 227 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Odometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'odo';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.border': 'black', 'chart.background.color': '#eee', 'chart.background.lines.color': '#ddd', 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.value.text': false, 'chart.value.text.decimals': 0, 'chart.needle.color': 'black', 'chart.needle.width': 2, 'chart.needle.head': true, 'chart.needle.tail': true, 'chart.needle.type': 'pointer', 'chart.needle.extra': [], 'chart.needle.triangle.border': '#aaa', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.green.max': max * 0.75, 'chart.red.min': max * 0.9, 'chart.green.color': 'Gradient(white:#0c0)', 'chart.yellow.color': 'Gradient(white:#ff0)', 'chart.red.color': 'Gradient(white:#f00)', 'chart.label.area': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.font': null, 'chart.title.bold': true, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.contextmenu': null, 'chart.linewidth': 1, 'chart.shadow.inner': false, 'chart.shadow.inner.color': 'black', 'chart.shadow.inner.offsetx': 3, 'chart.shadow.inner.offsety': 3, 'chart.shadow.inner.blur': 6, 'chart.shadow.outer': false, 'chart.shadow.outer.color': 'black', 'chart.shadow.outer.offsetx': 3, 'chart.shadow.outer.offsety': 3, 'chart.shadow.outer.blur': 6, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.border': false, 'chart.border.color1': '#BEBCB0', 'chart.border.color2': '#F0EFEA', 'chart.border.color3': '#BEBCB0', 'chart.tickmarks': true, 'chart.tickmarks.highlighted': false, 'chart.tickmarks.big.color': '#999', 'chart.zerostart': false, 'chart.labels': null }, _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.value.units.pre', ''), _defineProperty(_properties, 'chart.value.units.post', ''), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.text.size', 10), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.style') {\n      alert('[RGRAPH] The RGraph property chart.needle.style has changed to chart.needle.color');\n    }\n    if (name == 'chart.needle.thickness') {\n      name = 'chart.needle.width';\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (this.value > this.max) {\n      this.value = this.max;\n    }\n    if (this.value < this.min) {\n      this.value = this.min;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2) - (prop['chart.border'] ? 25 : 0);this.diameter = 2 * this.radius;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.range = this.max - this.min;this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && ca.width > ca.height) this.centerx = 5 + this.radius;if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];if (prop['chart.border']) {\n        this.radius -= 25;\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    co.lineWidth = prop['chart.linewidth'];this.DrawBackground();this.DrawLabels();this.DrawNeedle(this.value, prop['chart.needle.color']);if (prop['chart.needle.extra'].length > 0) {\n      for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n        var needle = prop['chart.needle.extra'][i];this.DrawNeedle(needle[0], needle[1], needle[2]);\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0) {\n      var colors = [prop['chart.needle.color']];if (prop['chart.needle.extra'].length > 0) {\n        for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n          var needle = prop['chart.needle.extra'][i];colors.push(needle[1]);\n        }\n      }\n      RG.DrawKey(this, prop['chart.key'], colors);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.beginPath();if (prop['chart.shadow.outer']) {\n      RG.setShadow(this, prop['chart.shadow.outer.color'], prop['chart.shadow.outer.offsetx'], prop['chart.shadow.outer.offsety'], prop['chart.shadow.outer.blur']);\n    }\n    var backgroundColor = prop['chart.background.color'];co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0.0001, RG.TWOPI, false);co.fill();RG.noShadow(this);co.strokeStyle = '#666';co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fill();if (prop['chart.tickmarks']) {\n      co.beginPath();co.strokeStyle = '#bbb';for (var i = 0; i <= 360; i += 3) {\n        co.arc(this.centerx, this.centery, this.radius, 0, i / 57.3, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    co.beginPath();co.lineWidth = 1;co.strokeStyle = 'black';co.fillStyle = backgroundColor;co.strokeStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius - 5, 0, RG.TWOPI, false);co.fill();co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.lines.color'];for (var i = 0; i < 360; i += 18) {\n      co.arc(this.centerx, this.centery, this.radius, 0, RG.degrees2Radians(i), false);co.lineTo(this.centerx, this.centery);\n    }\n    co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.border'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.stroke();if (prop['chart.shadow.inner']) {\n      co.beginPath();RG.SetShadow(this, prop['chart.shadow.inner.color'], prop['chart.shadow.inner.offsetx'], prop['chart.shadow.inner.offsety'], prop['chart.shadow.inner.blur']);co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0, RG.TWOPI, 0);co.fill();co.stroke();RG.NoShadow(this);\n    }\n    var greengrad = prop['chart.green.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - 2.5, -1 * RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0 - RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var yellowgrad = prop['chart.yellow.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var redgrad = prop['chart.red.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = redgrad;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();if (prop['chart.border']) {\n      var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius + 20);grad.addColorStop(0, prop['chart.border.color1']);grad.addColorStop(0.5, prop['chart.border.color2']);grad.addColorStop(1, prop['chart.border.color3']);co.beginPath();co.fillStyle = grad;co.strokeStyle = 'rgba(0,0,0,0)';\n      co.lineWidth = 0.001;co.arc(this.centerx, this.centery, this.radius + 20, 0, RG.TWOPI, 0);co.arc(this.centerx, this.centery, this.radius - 2, RG.TWOPI, 0, 1);co.fill();\n    }\n    co.lineWidth = prop['chart.linewidth'];if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (!prop['chart.tickmarks.highlighted']) {\n      for (var i = 18; i <= 360; i += 36) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];co.lineWidth = 2;co.arc(this.centerx, this.centery, this.radius - 1, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.arc(this.centerx, this.centery, this.radius - 7, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.stroke();\n      }\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color) {\n    var length = arguments[2] ? arguments[2] : this.radius - prop['chart.label.area'];co.fillStyle = '#999';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, 0, RG.TWOPI, false);co.fill();co.closePath();co.fill();co.fillStyle = color;\n    co.strokeStyle = '#666';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 8, 0, RG.TWOPI, false);co.fill();co.closePath();co.stroke();co.fill();if (prop['chart.needle.type'] == 'pointer') {\n      co.strokeStyle = color;co.lineWidth = prop['chart.needle.width'];co.lineCap = 'round';co.lineJoin = 'round';co.beginPath();co.beginPath();co.moveTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, 20, (value / this.range * 360 + 90) / (180 / RG.PI), (value / this.range * 360 + 90 + 0.01) / (180 / RG.PI), false);\n      }\n      co.arc(this.centerx, this.centery, length - 10, (value / this.range * 360 - 90) / (180 / RG.PI), (value / this.range * 360 - 90 + 0.1) / (180 / RG.PI), false);co.closePath();\n    } else if (prop['chart.needle.type'] == 'triangle') {\n      co.lineWidth = 0.01;co.lineEnd = 'square';co.lineJoin = 'miter';co.beginPath();co.fillStyle = prop['chart.needle.triangle.border'];co.arc(this.centerx, this.centery, 11, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 11, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 15, 0, RG.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;co.arc(this.centerx, this.centery, 7, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 7, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 13, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.stroke();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 7, 0, RG.TWOPI, 0);co.closePath();co.fill();\n    }\n    co.stroke();co.fill();co.beginPath();co.fillStyle = color;co.arc(this.centerx, this.centery, prop['chart.needle.type'] == 'pointer' ? 7 : 12, 0.01, RG.TWOPI, false);co.fill();if (prop['chart.needle.head'] && prop['chart.needle.type'] == 'pointer') {\n      co.lineWidth = 1;co.fillStyle = color;co.lineJoin = 'miter';co.lineCap = 'butt';co.beginPath();co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90 + 0.1) / 57.3, false);co.arc(this.centerx, this.centery, length - 20, RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 80 : 85)), RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 100 : 95)), 1);co.closePath();co.fill();\n    }\n    co.beginPath();co.fillStyle = 'gray';co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 2, 0, 6.2795, false);co.closePath();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var size = prop['chart.text.size'];var font = prop['chart.text.font'];var centerx = this.centerx;var centery = this.centery;var r = this.radius - prop['chart.label.area'] / 2;var start = this.min;var end = this.max;var decimals = prop['chart.scale.decimals'];var labels = prop['chart.labels'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];co.beginPath();co.fillStyle = prop['chart.text.color'];if (labels) {\n      for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + Math.cos(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'y': centery + Math.sin(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'text': String(labels[i]), 'valign': 'center', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (1 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 36, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (2 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 72, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.949 * r, 'y': centery + 0.31 * r, 'text': RG.number_format(this, ((end - start) * (3 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 108, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (4 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 144, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery + r, 'text': RG.number_format(this, ((end - start) * (5 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 180, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (6 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 216, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.949 * r, 'y': centery + 0.300 * r, 'text': RG.number_format(this, ((end - start) * (7 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 252, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (8 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 288, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (9 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 324, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery - r, 'text': prop['chart.zerostart'] ? RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post) : RG.number_format(this, ((end - start) * (10 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n    }\n    co.fill();if (prop['chart.value.text']) {\n      co.strokeStyle = 'black';RG.Text2(this, { 'font': font, 'size': size + 2, 'x': centerx, 'y': centery + size + 15, 'text': String(prop['chart.value.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.units.post']), 'halign': 'center', 'valign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);\n    var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (mouseXY[0] >= this.centerx && mouseXY[1] <= this.centery) {\n      angle -= RG.TWOPI;\n    }\n    var value = angle / RG.TWOPI * (this.max - this.min) + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(ca);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.TWOPI;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var current = obj.currentValue || 0;var origValue = Number(obj.currentValue);var newValue = obj.value;var diff = newValue - origValue;var step = diff / frames;var callback = arguments[1] || function () {};function iterator() {\n      obj.value = origValue + frame * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgub2RvLmpzPzY3MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5PZG9tZXRlcj1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLnZhbHVlIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkXG52YXIgY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgbWluPWNvbmYubWluO3ZhciBtYXg9Y29uZi5tYXg7dmFyIHZhbHVlPWNvbmYudmFsdWU7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgaWQ9Y29uZjt2YXIgY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgbWluPWFyZ3VtZW50c1sxXTt2YXIgbWF4PWFyZ3VtZW50c1syXTt2YXIgdmFsdWU9YXJndW1lbnRzWzNdO31cbnRoaXMuaWQ9aWQ7dGhpcy5jYW52YXM9Y2FudmFzO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0P3RoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLHthbHBoYToodHlwZW9mIGlkPT09J29iamVjdCcmJmlkLmFscGhhPT09ZmFsc2UpP2ZhbHNlOnRydWV9KTpudWxsO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLnR5cGU9J29kbyc7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMubWluPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1pbik7dGhpcy5tYXg9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmN1cnJlbnRWYWx1ZT1udWxsO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuYmFja2dyb3VuZC5ib3JkZXInOidibGFjaycsJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOicjZWVlJywnY2hhcnQuYmFja2dyb3VuZC5saW5lcy5jb2xvcic6JyNkZGQnLCdjaGFydC5jZW50ZXJ4JzpudWxsLCdjaGFydC5jZW50ZXJ5JzpudWxsLCdjaGFydC5yYWRpdXMnOm51bGwsJ2NoYXJ0LnZhbHVlLnRleHQnOmZhbHNlLCdjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJzowLCdjaGFydC5uZWVkbGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lm5lZWRsZS53aWR0aCc6MiwnY2hhcnQubmVlZGxlLmhlYWQnOnRydWUsJ2NoYXJ0Lm5lZWRsZS50YWlsJzp0cnVlLCdjaGFydC5uZWVkbGUudHlwZSc6J3BvaW50ZXInLCdjaGFydC5uZWVkbGUuZXh0cmEnOltdLCdjaGFydC5uZWVkbGUudHJpYW5nbGUuYm9yZGVyJzonI2FhYScsJ2NoYXJ0LnRleHQuc2l6ZSc6MTIsJ2NoYXJ0LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LnRleHQuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6ZmFsc2UsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuZ3JlZW4ubWF4JzptYXgqMC43NSwnY2hhcnQucmVkLm1pbic6bWF4KjAuOSwnY2hhcnQuZ3JlZW4uY29sb3InOidHcmFkaWVudCh3aGl0ZTojMGMwKScsJ2NoYXJ0LnllbGxvdy5jb2xvcic6J0dyYWRpZW50KHdoaXRlOiNmZjApJywnY2hhcnQucmVkLmNvbG9yJzonR3JhZGllbnQod2hpdGU6I2YwMCknLCdjaGFydC5sYWJlbC5hcmVhJzozNSwnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmNvbnRleHRtZW51JzpudWxsLCdjaGFydC5saW5ld2lkdGgnOjEsJ2NoYXJ0LnNoYWRvdy5pbm5lcic6ZmFsc2UsJ2NoYXJ0LnNoYWRvdy5pbm5lci5jb2xvcic6J2JsYWNrJywnY2hhcnQuc2hhZG93LmlubmVyLm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5pbm5lci5vZmZzZXR5JzozLCdjaGFydC5zaGFkb3cuaW5uZXIuYmx1cic6NiwnY2hhcnQuc2hhZG93Lm91dGVyJzpmYWxzZSwnY2hhcnQuc2hhZG93Lm91dGVyLmNvbG9yJzonYmxhY2snLCdjaGFydC5zaGFkb3cub3V0ZXIub2Zmc2V0eCc6MywnY2hhcnQuc2hhZG93Lm91dGVyLm9mZnNldHknOjMsJ2NoYXJ0LnNoYWRvdy5vdXRlci5ibHVyJzo2LCdjaGFydC5hbm5vdGF0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzonYmxhY2snLCdjaGFydC5zY2FsZS5kZWNpbWFscyc6MCwnY2hhcnQuc2NhbGUucG9pbnQnOicuJywnY2hhcnQuc2NhbGUudGhvdXNhbmQnOicsJywnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmhkaXInOidyaWdodCcsJ2NoYXJ0Lnpvb20udmRpcic6J2Rvd24nLCdjaGFydC56b29tLmZyYW1lcyc6MjUsJ2NoYXJ0Lnpvb20uZGVsYXknOjE2LjY2NiwnY2hhcnQuem9vbS5zaGFkb3cnOnRydWUsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQuem9vbS5hY3Rpb24nOid6b29tJywnY2hhcnQucmVzaXphYmxlJzpmYWxzZSwnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOlswLDBdLCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC5ib3JkZXInOmZhbHNlLCdjaGFydC5ib3JkZXIuY29sb3IxJzonI0JFQkNCMCcsJ2NoYXJ0LmJvcmRlci5jb2xvcjInOicjRjBFRkVBJywnY2hhcnQuYm9yZGVyLmNvbG9yMyc6JyNCRUJDQjAnLCdjaGFydC50aWNrbWFya3MnOnRydWUsJ2NoYXJ0LnRpY2ttYXJrcy5oaWdobGlnaHRlZCc6ZmFsc2UsJ2NoYXJ0LnRpY2ttYXJrcy5iaWcuY29sb3InOicjOTk5JywnY2hhcnQuemVyb3N0YXJ0JzpmYWxzZSwnY2hhcnQubGFiZWxzJzpudWxsLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQudmFsdWUudW5pdHMucHJlJzonJywnY2hhcnQudmFsdWUudW5pdHMucG9zdCc6JycsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmhhbGlnbic6J3JpZ2h0JywnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzonc3F1YXJlJywnY2hhcnQua2V5LnJvdW5kZWQnOnRydWUsJ2NoYXJ0LmtleS50ZXh0LnNpemUnOjEwLCdjaGFydC5rZXkuY29sb3JzJzpudWxsLCdjaGFydC5rZXkudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbnt2YXIgdmFsdWU9YXJndW1lbnRzWzFdfHxudWxsO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC5uZWVkbGUuc3R5bGUnKXthbGVydCgnW1JHUkFQSF0gVGhlIFJHcmFwaCBwcm9wZXJ0eSBjaGFydC5uZWVkbGUuc3R5bGUgaGFzIGNoYW5nZWQgdG8gY2hhcnQubmVlZGxlLmNvbG9yJyk7fVxuaWYobmFtZT09J2NoYXJ0Lm5lZWRsZS50aGlja25lc3MnKXtuYW1lPSdjaGFydC5uZWVkbGUud2lkdGgnO31cbmlmKG5hbWU9PSdjaGFydC52YWx1ZScpe3RoaXMudmFsdWU9dmFsdWU7cmV0dXJuO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZihuYW1lPT0nY2hhcnQudmFsdWUnKXtyZXR1cm4gdGhpcy52YWx1ZTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7aWYodGhpcy52YWx1ZT50aGlzLm1heCl7dGhpcy52YWx1ZT10aGlzLm1heDt9XG5pZih0aGlzLnZhbHVlPHRoaXMubWluKXt0aGlzLnZhbHVlPXRoaXMubWluO31cbnRoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnJhZGl1cz1NYXRoLm1pbigoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzIsKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMilcbi0ocHJvcFsnY2hhcnQuYm9yZGVyJ10/MjU6MCk7dGhpcy5kaWFtZXRlcj0yKnRoaXMucmFkaXVzO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKSt0aGlzLmd1dHRlclRvcDt0aGlzLnJhbmdlPXRoaXMubWF4LXRoaXMubWluO3RoaXMuY29vcmRzVGV4dD1bXTtpZihwcm9wWydjaGFydC5rZXknXSYmcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoPjAmJmNhLndpZHRoPmNhLmhlaWdodCl0aGlzLmNlbnRlcng9NSt0aGlzLnJhZGl1cztpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeCddKT09J251bWJlcicpdGhpcy5jZW50ZXJ4PXByb3BbJ2NoYXJ0LmNlbnRlcngnXTtpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVyeSddKT09J251bWJlcicpdGhpcy5jZW50ZXJ5PXByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZih0eXBlb2YocHJvcFsnY2hhcnQucmFkaXVzJ10pPT0nbnVtYmVyJyl7dGhpcy5yYWRpdXM9cHJvcFsnY2hhcnQucmFkaXVzJ107aWYocHJvcFsnY2hhcnQuYm9yZGVyJ10pe3RoaXMucmFkaXVzLT0yNTt9fVxuaWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG5jby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107dGhpcy5EcmF3QmFja2dyb3VuZCgpO3RoaXMuRHJhd0xhYmVscygpO3RoaXMuRHJhd05lZWRsZSh0aGlzLnZhbHVlLHByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddKTtpZihwcm9wWydjaGFydC5uZWVkbGUuZXh0cmEnXS5sZW5ndGg+MCl7Zm9yKHZhciBpPTA7aTxwcm9wWydjaGFydC5uZWVkbGUuZXh0cmEnXS5sZW5ndGg7KytpKXt2YXIgbmVlZGxlPXByb3BbJ2NoYXJ0Lm5lZWRsZS5leHRyYSddW2ldO3RoaXMuRHJhd05lZWRsZShuZWVkbGVbMF0sbmVlZGxlWzFdLG5lZWRsZVsyXSk7fX1cbmlmKHByb3BbJ2NoYXJ0LmtleSddJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGg+MCl7dmFyIGNvbG9ycz1bcHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ11dO2lmKHByb3BbJ2NoYXJ0Lm5lZWRsZS5leHRyYSddLmxlbmd0aD4wKXtmb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0Lm5lZWRsZS5leHRyYSddLmxlbmd0aDsrK2kpe3ZhciBuZWVkbGU9cHJvcFsnY2hhcnQubmVlZGxlLmV4dHJhJ11baV07Y29sb3JzLnB1c2gobmVlZGxlWzFdKTt9fVxuUkcuRHJhd0tleSh0aGlzLHByb3BbJ2NoYXJ0LmtleSddLGNvbG9ycyk7fVxuaWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZD10aGlzLkRyYXdCYWNrZ3JvdW5kPWZ1bmN0aW9uKClcbntjby5iZWdpblBhdGgoKTtpZihwcm9wWydjaGFydC5zaGFkb3cub3V0ZXInXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyLmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyLm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub3V0ZXIub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vdXRlci5ibHVyJ10pO31cbnZhciBiYWNrZ3JvdW5kQ29sb3I9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLmZpbGxTdHlsZT1iYWNrZ3JvdW5kQ29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsMC4wMDAxLFJHLlRXT1BJLGZhbHNlKTtjby5maWxsKCk7Ukcubm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGU9JyM2NjYnO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsUkcuVFdPUEksZmFsc2UpO2NvLmZpbGxTdHlsZT1iYWNrZ3JvdW5kQ29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsMCxSRy5UV09QSSxmYWxzZSk7Y28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT0nI2JiYic7Zm9yKHZhciBpPTA7aTw9MzYwO2krPTMpe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsaS81Ny4zLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7fVxuY28uc3Ryb2tlKCk7fVxuY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPTE7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztjby5maWxsU3R5bGU9YmFja2dyb3VuZENvbG9yO2NvLnN0cm9rZVN0eWxlPWJhY2tncm91bmRDb2xvcjtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy01LDAsUkcuVFdPUEksZmFsc2UpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmxpbmVzLmNvbG9yJ107Zm9yKHZhciBpPTA7aTwzNjA7aSs9MTgpe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsUkcuZGVncmVlczJSYWRpYW5zKGkpLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7fVxuY28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ib3JkZXInXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cywwLFJHLlRXT1BJLGZhbHNlKTtjby5zdHJva2UoKTtpZihwcm9wWydjaGFydC5zaGFkb3cuaW5uZXInXSl7Y28uYmVnaW5QYXRoKCk7UkcuU2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmlubmVyLmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93LmlubmVyLm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cuaW5uZXIub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5pbm5lci5ibHVyJ10pO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LmxhYmVsLmFyZWEnXSwwLFJHLlRXT1BJLDApO2NvLmZpbGwoKTtjby5zdHJva2UoKTtSRy5Ob1NoYWRvdyh0aGlzKTt9XG52YXIgZ3JlZW5ncmFkPXByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ107aWYocHJvcFsnY2hhcnQudGlja21hcmtzLmhpZ2hsaWdodGVkJ10pe2NvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aD01O2NvLnN0cm9rZVN0eWxlPWdyZWVuZ3JhZDtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0yLjUsLTEqUkcuSEFMRlBJLCgoKHByb3BbJ2NoYXJ0LmdyZWVuLm1heCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSpSRy5UV09QSSktUkcuSEFMRlBJLDApO2NvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aD0xO31cbmNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1ncmVlbmdyYWQ7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQubGFiZWwuYXJlYSddLDAtUkcuSEFMRlBJLCgoKHByb3BbJ2NoYXJ0LmdyZWVuLm1heCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSpSRy5UV09QSSktUkcuSEFMRlBJLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO3ZhciB5ZWxsb3dncmFkPXByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2lmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5oaWdobGlnaHRlZCddKXtjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGg9NTtjby5zdHJva2VTdHlsZT15ZWxsb3dncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTIuNSwoKChwcm9wWydjaGFydC5ncmVlbi5tYXgnXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuVFdPUEkpLVJHLkhBTEZQSSwoKChwcm9wWydjaGFydC5yZWQubWluJ10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKlJHLlRXT1BJKS1SRy5IQUxGUEksMCk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoPTE7fVxuY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXllbGxvd2dyYWQ7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQubGFiZWwuYXJlYSddLCgoKHByb3BbJ2NoYXJ0LmdyZWVuLm1heCddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSpSRy5UV09QSSktUkcuSEFMRlBJLCgoKHByb3BbJ2NoYXJ0LnJlZC5taW4nXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqUkcuVFdPUEkpLVJHLkhBTEZQSSxmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTt2YXIgcmVkZ3JhZD1wcm9wWydjaGFydC5yZWQuY29sb3InXTtpZihwcm9wWydjaGFydC50aWNrbWFya3MuaGlnaGxpZ2h0ZWQnXSl7Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoPTU7Y28uc3Ryb2tlU3R5bGU9cmVkZ3JhZDtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0yLjUsKCgocHJvcFsnY2hhcnQucmVkLm1pbiddLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSpSRy5UV09QSSktUkcuSEFMRlBJLFJHLlRXT1BJLVJHLkhBTEZQSSwwKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGg9MTt9XG5jby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cmVkZ3JhZDtjby5zdHJva2VTdHlsZT1yZWRncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LmxhYmVsLmFyZWEnXSwoKChwcm9wWydjaGFydC5yZWQubWluJ10tdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpKlJHLlRXT1BJKS1SRy5IQUxGUEksUkcuVFdPUEktUkcuSEFMRlBJLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0LmJvcmRlciddKXt2YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMrMjApO2dyYWQuYWRkQ29sb3JTdG9wKDAscHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yMSddKTtncmFkLmFkZENvbG9yU3RvcCgwLjUscHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yMiddKTtncmFkLmFkZENvbG9yU3RvcCgxLHByb3BbJ2NoYXJ0LmJvcmRlci5jb2xvcjMnXSk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPWdyYWQ7Y28uc3Ryb2tlU3R5bGU9J3JnYmEoMCwwLDAsMCknXG5jby5saW5lV2lkdGg9MC4wMDE7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMrMjAsMCxSRy5UV09QSSwwKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0yLFJHLlRXT1BJLDAsMSk7Y28uZmlsbCgpO31cbmNvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtpZihwcm9wWydjaGFydC50aXRsZSddKXtSRy5EcmF3VGl0bGUodGhpcyxwcm9wWydjaGFydC50aXRsZSddLHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cyxudWxsLHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMik7fVxuaWYoIXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5oaWdobGlnaHRlZCddKXtmb3IodmFyIGk9MTg7aTw9MzYwO2krPTM2KXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJ107Y28ubGluZVdpZHRoPTI7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMtMSxSRy5kZWdyZWVzMlJhZGlhbnMoaSksUkcuZGVncmVlczJSYWRpYW5zKGkrMC4wMSksZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLTcsUkcuZGVncmVlczJSYWRpYW5zKGkpLFJHLmRlZ3JlZXMyUmFkaWFucyhpKzAuMDEpLGZhbHNlKTtjby5zdHJva2UoKTt9fX07dGhpcy5kcmF3TmVlZGxlPXRoaXMuRHJhd05lZWRsZT1mdW5jdGlvbih2YWx1ZSxjb2xvcilcbnt2YXIgbGVuZ3RoPWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQubGFiZWwuYXJlYSddO2NvLmZpbGxTdHlsZT0nIzk5OSc7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDEwLDAsUkcuVFdPUEksZmFsc2UpO2NvLmZpbGwoKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uZmlsbFN0eWxlPWNvbG9yXG5jby5zdHJva2VTdHlsZT0nIzY2Nic7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDgsMCxSRy5UV09QSSxmYWxzZSk7Y28uZmlsbCgpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtpZihwcm9wWydjaGFydC5uZWVkbGUudHlwZSddPT0ncG9pbnRlcicpe2NvLnN0cm9rZVN0eWxlPWNvbG9yO2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5uZWVkbGUud2lkdGgnXTtjby5saW5lQ2FwPSdyb3VuZCc7Y28ubGluZUpvaW49J3JvdW5kJztjby5iZWdpblBhdGgoKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7aWYocHJvcFsnY2hhcnQubmVlZGxlLnRhaWwnXSl7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMjAsKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSs5MCkvKDE4MC9SRy5QSSksKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSs5MCswLjAxKS8oMTgwL1JHLlBJKSxmYWxzZSk7fVxuY28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbGVuZ3RoLTEwLCgoKHZhbHVlL3RoaXMucmFuZ2UpKjM2MCktOTApLygxODAvUkcuUEkpLCgoKHZhbHVlL3RoaXMucmFuZ2UpKjM2MCktOTArMC4xKS8oMTgwL1JHLlBJKSxmYWxzZSk7Y28uY2xvc2VQYXRoKCk7fWVsc2UgaWYocHJvcFsnY2hhcnQubmVlZGxlLnR5cGUnXT09J3RyaWFuZ2xlJyl7Y28ubGluZVdpZHRoPTAuMDE7Y28ubGluZUVuZD0nc3F1YXJlJztjby5saW5lSm9pbj0nbWl0ZXInO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5uZWVkbGUudHJpYW5nbGUuYm9yZGVyJ107Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMTEsKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSkvNTcuMywoKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSkrMC4wMSkvNTcuMywwKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwxMSwoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApKzE4MCkvNTcuMywoKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSsxODApKzAuMDEpLzU3LjMsMCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbGVuZ3RoLTUsKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKS05MCkvNTcuMywoKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKS05MCkvNTcuMykrMC4wMSwwKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMTUsMCxSRy5UV09QSSwwKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztjby5maWxsU3R5bGU9Y29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksNywoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApKS81Ny4zLCgoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApKSswLjAxKS81Ny4zLDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LDcsKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKSsxODApLzU3LjMsKCgoKHZhbHVlL3RoaXMucmFuZ2UpKjM2MCkrMTgwKSswLjAxKS81Ny4zLDApO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LGxlbmd0aC0xMywoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApLTkwKS81Ny4zLCgoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApLTkwKS81Ny4zKSswLjAxLDApO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSw3LDAsUkcuVFdPUEksMCk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO31cbmNvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9Y29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkscHJvcFsnY2hhcnQubmVlZGxlLnR5cGUnXT09J3BvaW50ZXInPzc6MTIsMC4wMSxSRy5UV09QSSxmYWxzZSk7Y28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0Lm5lZWRsZS5oZWFkJ10mJnByb3BbJ2NoYXJ0Lm5lZWRsZS50eXBlJ109PSdwb2ludGVyJyl7Y28ubGluZVdpZHRoPTE7Y28uZmlsbFN0eWxlPWNvbG9yO2NvLmxpbmVKb2luPSdtaXRlcic7Y28ubGluZUNhcD0nYnV0dCc7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbGVuZ3RoLTUsKCgodmFsdWUvdGhpcy5yYW5nZSkqMzYwKS05MCkvNTcuMywoKCh2YWx1ZS90aGlzLnJhbmdlKSozNjApLTkwKzAuMSkvNTcuMyxmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbGVuZ3RoLTIwLFJHLmRlZ3JlZXMyUmFkaWFucygoKHZhbHVlL3RoaXMucmFuZ2UpKjM2MCktKGxlbmd0aDw2MD84MDo4NSkpLFJHLmRlZ3JlZXMyUmFkaWFucygoKHZhbHVlL3RoaXMucmFuZ2UpKjM2MCktKGxlbmd0aDw2MD8xMDA6OTUpKSwxKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7fVxuY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPSdncmF5Jztjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMiwwLDYuMjc5NSxmYWxzZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIGNlbnRlcng9dGhpcy5jZW50ZXJ4O3ZhciBjZW50ZXJ5PXRoaXMuY2VudGVyeTt2YXIgcj10aGlzLnJhZGl1cy0ocHJvcFsnY2hhcnQubGFiZWwuYXJlYSddLzIpO3ZhciBzdGFydD10aGlzLm1pbjt2YXIgZW5kPXRoaXMubWF4O3ZhciBkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ107dmFyIHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXTt2YXIgdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J107Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtpZihsYWJlbHMpe2Zvcih2YXIgaT0wO2k8bGFiZWxzLmxlbmd0aDsrK2kpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4KyhNYXRoLmNvcygoKGkvbGFiZWxzLmxlbmd0aCkqUkcuVFdPUEkpLVJHLkhBTEZQSSkqKHRoaXMucmFkaXVzLShwcm9wWydjaGFydC5sYWJlbC5hcmVhJ10vMikpKSwneSc6Y2VudGVyeSsoTWF0aC5zaW4oKChpL2xhYmVscy5sZW5ndGgpKlJHLlRXT1BJKS1SRy5IQUxGUEkpKih0aGlzLnJhZGl1cy0ocHJvcFsnY2hhcnQubGFiZWwuYXJlYSddLzIpKSksJ3RleHQnOlN0cmluZyhsYWJlbHNbaV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCd0YWcnOidsYWJlbHMnfSk7fX1lbHNle1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4KygwLjU4OCpyKSwneSc6Y2VudGVyeS0oMC44MDkqciksJ3RleHQnOlJHLm51bWJlcl9mb3JtYXQodGhpcywoKChlbmQtc3RhcnQpKigxLzEwKSkrc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonY2VudGVyJywnYW5nbGUnOjM2LCd0YWcnOidzY2FsZSd9KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeCsoMC45NTEqciksJ3knOmNlbnRlcnktKDAuMzA5KnIpLCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMsKCgoZW5kLXN0YXJ0KSooMi8xMCkpK3N0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ2hhbGlnbic6J2NlbnRlcicsJ3ZhbGlnbic6J2NlbnRlcicsJ2FuZ2xlJzo3MiwndGFnJzonc2NhbGUnfSk7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOmNlbnRlcngrKDAuOTQ5KnIpLCd5JzpjZW50ZXJ5KygwLjMxKnIpLCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMsKCgoZW5kLXN0YXJ0KSooMy8xMCkpK3N0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ2hhbGlnbic6J2NlbnRlcicsJ3ZhbGlnbic6J2NlbnRlcicsJ2FuZ2xlJzoxMDgsJ3RhZyc6J3NjYWxlJ30pO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4KygwLjU4OCpyKSwneSc6Y2VudGVyeSsoMC44MDkqciksJ3RleHQnOlJHLm51bWJlcl9mb3JtYXQodGhpcywoKChlbmQtc3RhcnQpKig0LzEwKSkrc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonY2VudGVyJywnYW5nbGUnOjE0NCwndGFnJzonc2NhbGUnfSk7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOmNlbnRlcngsJ3knOmNlbnRlcnkrciwndGV4dCc6UkcubnVtYmVyX2Zvcm1hdCh0aGlzLCgoKGVuZC1zdGFydCkqKDUvMTApKStzdGFydCkudG9GaXhlZChkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCdhbmdsZSc6MTgwLCd0YWcnOidzY2FsZSd9KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0oMC41ODgqciksJ3knOmNlbnRlcnkrKDAuODA5KnIpLCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMsKCgoZW5kLXN0YXJ0KSooNi8xMCkpK3N0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ2hhbGlnbic6J2NlbnRlcicsJ3ZhbGlnbic6J2NlbnRlcicsJ2FuZ2xlJzoyMTYsJ3RhZyc6J3NjYWxlJ30pO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4LSgwLjk0OSpyKSwneSc6Y2VudGVyeSsoMC4zMDAqciksJ3RleHQnOlJHLm51bWJlcl9mb3JtYXQodGhpcywoKChlbmQtc3RhcnQpKig3LzEwKSkrc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonY2VudGVyJywnYW5nbGUnOjI1MiwndGFnJzonc2NhbGUnfSk7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOmNlbnRlcngtKDAuOTUxKnIpLCd5JzpjZW50ZXJ5LSgwLjMwOSpyKSwndGV4dCc6UkcubnVtYmVyX2Zvcm1hdCh0aGlzLCgoKGVuZC1zdGFydCkqKDgvMTApKStzdGFydCkudG9GaXhlZChkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCdhbmdsZSc6Mjg4LCd0YWcnOidzY2FsZSd9KTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0oMC41ODgqciksJ3knOmNlbnRlcnktKDAuODA5KnIpLCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMsKCgoZW5kLXN0YXJ0KSooOS8xMCkpK3N0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ2hhbGlnbic6J2NlbnRlcicsJ3ZhbGlnbic6J2NlbnRlcicsJ2FuZ2xlJzozMjQsJ3RhZyc6J3NjYWxlJ30pO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4LCd5JzpjZW50ZXJ5LXIsJ3RleHQnOnByb3BbJ2NoYXJ0Lnplcm9zdGFydCddP1JHLm51bWJlcl9mb3JtYXQodGhpcyx0aGlzLm1pbi50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCk6UkcubnVtYmVyX2Zvcm1hdCh0aGlzLCgoKGVuZC1zdGFydCkqKDEwLzEwKSkrc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSwnaGFsaWduJzonY2VudGVyJywndmFsaWduJzonY2VudGVyJywndGFnJzonc2NhbGUnfSk7fVxuY28uZmlsbCgpO2lmKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQnXSl7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJztSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSsyLCd4JzpjZW50ZXJ4LCd5JzpjZW50ZXJ5K3NpemUrMTUsJ3RleHQnOlN0cmluZyhwcm9wWydjaGFydC52YWx1ZS51bml0cy5wcmUnXSt0aGlzLnZhbHVlLnRvRml4ZWQocHJvcFsnY2hhcnQudmFsdWUudGV4dC5kZWNpbWFscyddKStwcm9wWydjaGFydC52YWx1ZS51bml0cy5wb3N0J10pLCdoYWxpZ24nOidjZW50ZXInLCd2YWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6dHJ1ZSwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0YWcnOid2YWx1ZS50ZXh0J30pO319O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSl7fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKVxudmFyIGFuZ2xlPVJHLmdldEFuZ2xlQnlYWSh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LG1vdXNlWFlbMF0sbW91c2VYWVsxXSk7YW5nbGUrPVJHLkhBTEZQSTtpZihtb3VzZVhZWzBdPj10aGlzLmNlbnRlcngmJm1vdXNlWFlbMV08PXRoaXMuY2VudGVyeSl7YW5nbGUtPVJHLlRXT1BJO31cbnZhciB2YWx1ZT0oKGFuZ2xlL1JHLlRXT1BJKSoodGhpcy5tYXgtdGhpcy5taW4pKSt0aGlzLm1pbjtyZXR1cm4gdmFsdWU7fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciByYWRpdXM9UkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksbW91c2VYWVswXSxtb3VzZVhZWzFdKTtpZihtb3VzZVhZWzBdPih0aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzBdPCh0aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzFdPih0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpJiZtb3VzZVhZWzFdPCh0aGlzLmNlbnRlcnkrdGhpcy5yYWRpdXMpJiZyYWRpdXM8PXRoaXMucmFkaXVzKXtyZXR1cm4gdGhpczt9fTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmU9dGhpcy5BZGp1c3RpbmdfbW91c2Vtb3ZlPWZ1bmN0aW9uKGUpXG57aWYocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddJiZSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpJiZSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZD09dGhpcy51aWQpe3RoaXMudmFsdWU9dGhpcy5nZXRWYWx1ZShlKTtSRy5jbGVhcihjYSk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt9fTt0aGlzLmdldEFuZ2xlPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTx0aGlzLm1pbil7cmV0dXJuIG51bGw7fVxudmFyIGFuZ2xlPSgoKHZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pKSpSRy5UV09QSSk7YW5nbGUtPVJHLkhBTEZQSTtyZXR1cm4gYW5nbGU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZ3JlZW4uY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQueWVsbG93LmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5yZWQuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5yZWQuY29sb3InXSk7fVxucHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTtwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7cHJvcFsnY2hhcnQucmVkLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQucmVkLmNvbG9yJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3J8fHR5cGVvZihjb2xvcikhPSdzdHJpbmcnKXtyZXR1cm4gY29sb3I7fVxuaWYoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQ9Y28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwwLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMpO3ZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7dmFyIGN1cnJlbnQ9b2JqLmN1cnJlbnRWYWx1ZXx8MDt2YXIgb3JpZ1ZhbHVlPU51bWJlcihvYmouY3VycmVudFZhbHVlKTt2YXIgbmV3VmFsdWU9b2JqLnZhbHVlO3ZhciBkaWZmPW5ld1ZhbHVlLW9yaWdWYWx1ZTt2YXIgc3RlcD0oZGlmZi9mcmFtZXMpO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBpdGVyYXRvcigpXG57b2JqLnZhbHVlPW9yaWdWYWx1ZSsoZnJhbWUqc3RlcCk7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lKys8ZnJhbWVzKXtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O1JHLmF0dChjYSk7UkcucmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgub2RvLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///227\n");

/***/ }),
/* 228 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Pie = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.total = 0;this.subTotal = 0;this.angles = [];this.data = data;this.properties = [];this.type = 'pie';this.isRGraph = true;this.coords = [];this.coords.key = [];this.coordsSticks = [];this.coordsText = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.exploding = null;for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  this.properties = { 'chart.centerx.adjust': 0, 'chart.centery.adjust': 0, 'chart.colors': ['red', '#ccc', '#cfc', 'blue', 'pink', 'yellow', 'black', 'orange', 'cyan', 'purple', '#78CAEA', '#E284E9', 'white', 'blue', '#9E7BF6'], 'chart.strokestyle': 'white', 'chart.linewidth': 3, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.sticks': false, 'chart.labels.sticks.length': 7, 'chart.labels.sticks.colors': null, 'chart.labels.sticks.usecolors': true, 'chart.labels.sticks.linewidth': 1, 'chart.labels.sticks.hlength': 5, 'chart.labels.sticks.list': false, 'chart.labels.ingraph': null, 'chart.labels.ingraph.color': null, 'chart.labels.ingraph.font': null, 'chart.labels.ingraph.size': null, 'chart.labels.ingraph.bounding': true, 'chart.labels.ingraph.bounding.fill': 'white', 'chart.labels.ingraph.specific': null, 'chart.labels.ingraph.units.pre': '', 'chart.labels.ingraph.units.post': '', 'chart.labels.ingraph.radius': null, 'chart.labels.center': null, 'chart.labels.center.size': 26, 'chart.labels.center.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.center.color': 'black', 'chart.labels.center.italic': false, 'chart.labels.center.bold': false, 'chart.labels.center.units.pre': '', 'chart.labels.center.units.post': '', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': 0.5, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.style': '2d', 'chart.highlight.style.twod.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.style.twod.stroke': 'rgba(255,255,255,0.7)', 'chart.highlight.style.outline.width': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.border': false, 'chart.border.color': 'rgba(255,255,255,0.5)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.variant': 'pie', 'chart.variant.donut.width': null, 'chart.variant.threed.depth': 20, 'chart.exploded': [], 'chart.effect.roundrobin.multiplier': 1, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.centerpin': null, 'chart.centerpin.fill': 'gray', 'chart.centerpin.stroke': 'white', 'chart.origin': 0 - Math.PI / 2, 'chart.events': true, 'chart.labels.colors': [], 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, len = data.length; i < len; i++) {\n    this.total += data[i];this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    if (name == 'chart.labels.spaced') {\n      name = 'chart.labels.sticks.list';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = this.getRadius();this.centerx = this.graph.width / 2 + this.gutterLeft + prop['chart.centerx.adjust'];this.centery = this.graph.height / 2 + this.gutterTop + prop['chart.centery.adjust'];this.subTotal = this.properties['chart.origin'];this.angles = [];this.coordsText = [];if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (this.radius <= 0) {\n      return;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.labels.colors'][prop['chart.labels.colors'].length - 1]);\n      }\n    } else {\n      if (typeof prop['chart.labels.colors'] === 'undefined') {\n        prop['chart.labels.colors'] = [];\n      }\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.text.color']);\n      }\n    }\n    if (prop['chart.variant'].indexOf('3d') > 0) {\n      return this.draw3d();\n    }\n    RG.DrawTitle(this, prop['chart.title'], ca.height / 2 - this.radius - 5, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.total = RG.array_sum(this.data);var tot = this.total;var data = this.data;for (var i = 0, len = this.data.length; i < len; i++) {\n      var angle = data[i] / tot * RG.TWOPI;this.DrawSegment(angle, prop['chart.colors'][i], i == len - 1, i);\n    }\n    RG.NoShadow(this);if (prop['chart.linewidth'] > 0) {\n      this.DrawBorders();\n    }\n    var len = this.angles.length;var r = this.radius;for (var action = 0; action < 2; action += 1) {\n      for (var i = 0; i < len; i++) {\n        co.beginPath();var segment = this.angles[i];if (action === 1) {\n          co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' ? prop['chart.strokestyle'][i] : prop['chart.strokestyle'];\n        }\n        prop['chart.colors'][i] ? co.fillStyle = prop['chart.colors'][i] : null;co.lineJoin = 'round';co.arc(segment[2], segment[3], r, segment[0], segment[1], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(segment[2], segment[3], typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, segment[1], segment[0], true);\n        } else {\n          co.lineTo(segment[2], segment[3]);\n        }\n        co.closePath();action === 0 ? co.fill() : co.stroke();\n      }\n    }\n    if (prop['chart.labels.sticks']) {\n      this.DrawSticks();var strokeStyle = prop['chart.strokestyle'];\n    }\n    if (prop['chart.labels']) {\n      this.DrawLabels();\n    }\n    if (prop['chart.centerpin']) {\n      this.DrawCenterpin();\n    }\n    if (prop['chart.labels.ingraph']) {\n      this.DrawInGraphLabels();\n    }\n    if (!RG.isNull(prop['chart.labels.center'])) {\n      this.drawCenterLabel(prop['chart.labels.center']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.border']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = prop['chart.border.color'];co.arc(this.centerx, this.centery, this.radius - 2, 0, RG.TWOPI, 0);co.stroke();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    RG.NoShadow(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.events'] == true) {\n      RG.InstallEventListeners(this);\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawSegment = this.DrawSegment = function (radians, color, last, index) {\n    if (RGraph.ISOLD && radians == RG.TWOPI) {\n      radians -= 0.0001;\n    } else if (RGraph.ISOLD && radians == 0) {\n      radians = 0.001;\n    }\n    var subTotal = this.subTotal;radians = radians * prop['chart.effect.roundrobin.multiplier'];co.beginPath();color ? co.fillStyle = color : null;co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = 0;if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    if (_typeof(prop['chart.exploded']) == 'object' && prop['chart.exploded'][index] > 0 || typeof prop['chart.exploded'] == 'number') {\n      var explosion = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][index];var x = 0;var y = 0;var h = explosion;var t = subTotal + radians / 2;var x = Math.cos(t) * explosion;var y = Math.sin(t) * explosion;var r = this.radius;co.moveTo(this.centerx + x, this.centery + y);\n    } else {\n      var x = 0;var y = 0;var r = this.radius;\n    }\n    var startAngle = subTotal;var endAngle = subTotal + radians;co.arc(this.centerx + x, this.centery + y, r, startAngle, endAngle, 0);if (prop['chart.variant'] == 'donut') {\n      co.arc(this.centerx + x, this.centery + y, typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, endAngle, startAngle, true);\n    } else {\n      co.lineTo(this.centerx + x, this.centery + y);\n    }\n    co.closePath();this.angles.push([subTotal, subTotal + radians, this.centerx + x, this.centery + y]);co.fill();this.subTotal += radians;\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'].length && prop['chart.labels.sticks.list']) {\n      return this.drawLabelsList();\n    }\n    var hAlignment = 'left',\n        vAlignment = 'center',\n        labels = prop['chart.labels'],\n        context = co,\n        font = prop['chart.text.font'],\n        bold = prop['chart.labels.bold'],\n        text_size = prop['chart.text.size'],\n        cx = this.centerx,\n        cy = this.centery,\n        r = this.radius;RG.noShadow(this);co.fillStyle = 'black';co.beginPath();if (labels && labels.length) {\n      for (i = 0; i < this.angles.length; ++i) {\n        var segment = this.angles[i];if (typeof labels[i] != 'string' && typeof labels[i] != 'number') {\n          continue;\n        }\n        co.moveTo(cx, cy);var a = segment[0] + (segment[1] - segment[0]) / 2,\n            angle = (segment[1] - segment[0]) / 2 + segment[0];if (_typeof(prop['chart.exploded']) === 'object' && prop['chart.exploded'][i] || typeof prop['chart.exploded'] == 'number') {\n          var t = (segment[1] - segment[0]) / 2,\n              seperation = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i];var explosion_offsetx = Math.cos(angle) * seperation,\n              explosion_offsety = Math.sin(angle) * seperation;\n        } else {\n          var explosion_offsetx = 0,\n              explosion_offsety = 0;\n        }\n        if (prop['chart.labels.sticks']) {\n          explosion_offsetx += ma.cos(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);explosion_offsety += ma.sin(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);\n        }\n        var x = cx + explosion_offsetx + (r + 10) * Math.cos(a) + (prop['chart.labels.sticks'] ? a < RG.HALFPI || a > RG.TWOPI + RG.HALFPI ? 2 : -2 : 0),\n            y = cy + explosion_offsety + (r + 10) * Math.sin(a);if (this.coordsSticks && this.coordsSticks[i]) {\n          var x = this.coordsSticks[i][4][0] + (x < cx ? -5 : 5),\n              y = this.coordsSticks[i][4][1];\n        }\n        vAlignment = 'center';hAlignment = x < cx ? 'right' : 'left';co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels.colors']) === 'object' && prop['chart.labels.colors'] && prop['chart.labels.colors'][i]) {\n          co.fillStyle = prop['chart.labels.colors'][i];\n        }\n        RG.text2(this, { font: font, size: text_size, x: x, y: y, text: labels[i], valign: vAlignment, halign: hAlignment, tag: 'labels', bold: bold, color: prop['chart.labels.sticks.usecolors'] ? prop['chart.colors'][i] : 'black' });\n      }\n      co.fill();\n    }\n  };this.drawLabelsList = function () {\n    var segment = this.angles[i],\n        labels = prop['chart.labels'],\n        labels_right = [],\n        labels_left = [],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        text_color = prop['chart.text.color'],\n        left = [],\n        right = [],\n        centerx = this.centerx,\n        centery = this.centery,\n        radius = this.radius,\n        offset = 50;\n    for (var i = 0; i < this.angles.length; ++i) {\n      var angle = this.angles[i][0] + (this.angles[i][1] - this.angles[i][0]) / 2,\n          endpoint_inner = RG.getRadiusEndPoint(centerx, centery, angle, radius + 5),\n          endpoint_outer = RG.getRadiusEndPoint(centerx, centery, angle, radius + 10),\n          explosion = [typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i], ma.cos(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i]), ma.sin(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i])];\n      if (_typeof(prop['chart.labels.sticks.colors']) === 'object' && prop['chart.labels.sticks.colors'] && prop['chart.labels.sticks.colors'][i]) {\n        var color = prop['chart.labels.sticks.colors'][i];\n      } else if (prop['chart.labels.sticks.usecolors'] && prop['chart.colors'][i]) {\n        var color = prop['chart.colors'][i];\n      } else {\n        var color = prop['chart.text.color'];\n      }\n      if (angle > -1 * RG.HALFPI && angle < RG.HALFPI) {\n        labels_right.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      } else {\n        labels_left.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      }\n    }\n    var vspace_right = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_right.length;\n    for (var i = 0, y = prop['chart.gutter.top'] + vspace_right / 2; i < labels_right.length; y += vspace_right, i++) {\n      if (labels_right[i][2]) {\n        var x = this.centerx + this.radius + offset,\n            idx = labels_right[i][0],\n            explosionX = labels_right[i][6][0] ? labels_right[i][6][1] : 0,\n            explosionY = labels_right[i][6][0] ? labels_right[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_right[i][2], valign: 'center', halign: 'left', tag: 'labels', color: labels_right[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_right[i][0];\n        }\n        pa2(co, 'lc round lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_right[i][3][0] + explosionX, labels_right[i][3][1] + explosionY, labels_right[i][4][0] + explosionX, labels_right[i][4][1] + explosionY, this.centerx + this.radius + 25 + explosionX, ma.round(labels_right[i][4][1] + explosionY), ret.x - 5, ret.y + ret.height / 2, labels_right[i][5]);\n      }\n    }\n    var vspace_left = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_left.length;\n    for (var i = labels_left.length - 1, y = prop['chart.gutter.top'] + vspace_left / 2; i >= 0; y += vspace_left, i--) {\n      if (labels_left[i][2]) {\n        var x = this.centerx - this.radius - offset,\n            idx = labels_left[i][0],\n            explosionX = labels_left[i][6][0] ? labels_left[i][6][1] : 0,\n            explosionY = labels_left[i][6][0] ? labels_left[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_left[i][2], valign: 'center', halign: 'right', tag: 'labels', color: labels_left[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_left[i][0];\n        }\n        pa2(co, 'lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_left[i][3][0] + explosionX, labels_left[i][3][1] + explosionY, labels_left[i][4][0] + explosionX, labels_left[i][4][1] + explosionY, this.centerx - this.radius - 25 + explosionX, ma.round(labels_left[i][4][1] + explosionY), ret.x + 5 + ret.width, ret.y + ret.height / 2, labels_left[i][5]);\n      }\n    }\n  };this.drawSticks = this.DrawSticks = function () {\n    var offset = prop['chart.linewidth'] / 2,\n        exploded = prop['chart.exploded'],\n        sticks = prop['chart.labels.sticks'],\n        colors = prop['chart.colors'],\n        cx = this.centerx,\n        cy = this.centery,\n        radius = this.radius,\n        points = [],\n        linewidth = prop['chart.labels.sticks.linewidth'];\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      var segment = this.angles[i];if ((typeof sticks === 'undefined' ? 'undefined' : _typeof(sticks)) === 'object' && !sticks[i]) {\n        continue;\n      }\n      var radians = segment[1] - segment[0];co.beginPath();co.strokeStyle = typeof prop['chart.labels.sticks.colors'] === 'string' ? prop['chart.labels.sticks.colors'] : !RG.isNull(prop['chart.labels.sticks.colors']) ? prop['chart.labels.sticks.colors'][i] : 'gray';co.lineWidth = linewidth;if (typeof prop['chart.labels.sticks.color'] === 'string') {\n        co.strokeStyle = prop['chart.labels.sticks.color'];\n      }\n      if (prop['chart.labels.sticks.usecolors']) {\n        co.strokeStyle = prop['chart.colors'][i];\n      }\n      var midpoint = segment[0] + radians / 2;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && exploded[i]) {\n        var extra = exploded[i];\n      } else if (typeof exploded === 'number') {\n        var extra = exploded;\n      } else {\n        var extra = 0;\n      }\n      var stickLength = _typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length'];points[0] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + extra + offset);points[1] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra - 5);points[2] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3][0] += points[3][0] > cx ? 5 : -5;points[4] = [points[2][0] + (points[2][0] > cx ? 5 + prop['chart.labels.sticks.hlength'] : -5 - prop['chart.labels.sticks.hlength']), points[2][1]];co.moveTo(points[0][0], points[0][1]);co.quadraticCurveTo(points[2][0], points[2][1], points[4][0], points[4][1]);co.stroke();this.coordsSticks[i] = [points[0], points[1], points[2], points[3], points[4]];\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.FixEventObject(e);var accuracy = arguments[1] ? arguments[1] : 0;var canvas = ca;var context = co;var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var r = this.radius;var angles = this.angles;var ret = [];for (var i = 0, len = angles.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.arc(angles[i][2], angles[i][3], this.radius, angles[i][0], angles[i][1], false);if (this.type == 'pie' && prop['chart.variant'] == 'donut') {\n        co.arc(angles[i][2], angles[i][3], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2, angles[i][1], angles[i][0], true);\n      } else {\n        co.lineTo(angles[i][2], angles[i][3]);\n      }\n      co.closePath();if (!co.isPointInPath(mouseX, mouseY)) {\n        continue;\n      }\n      ret[0] = angles[i][2];ret[1] = angles[i][3];ret[2] = this.radius;ret[3] = angles[i][0] - RG.TWOPI;ret[4] = angles[i][1];ret[5] = i;if (ret[3] < 0) ret[3] += RG.TWOPI;if (ret[4] > RG.TWOPI) ret[4] -= RG.TWOPI;var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], ret[5]) : null;ret['object'] = this;ret['x'] = ret[0];ret['y'] = ret[1];ret['radius'] = ret[2];ret['angle.start'] = ret[3];ret['angle.end'] = ret[4];ret['index'] = ret[5];ret['tooltip'] = tooltip;return ret;\n    }\n    return null;\n  };this.drawBorders = this.DrawBorders = function () {\n    if (prop['chart.linewidth'] > 0) {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];var r = this.radius;for (var i = 0, len = this.angles.length; i < len; ++i) {\n        var segment = this.angles[i];co.beginPath();co.arc(segment[2], segment[3], r, segment[0], segment[0] + 0.001, 0);co.arc(segment[2], segment[3], prop['chart.variant'] == 'donut' ? typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : r / 2 : r, segment[0], segment[0] + 0.0001, 0);co.closePath();co.stroke();\n      }\n    }\n  };this.getRadius = function () {\n    this.graph = { width: ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], height: ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'] };\n    if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];\n    } else {\n      this.radius = Math.min(this.graph.width, this.graph.height) / 2;\n    }\n    return this.radius;\n  };this.explodeSegment = this.Explode = function (index, size) {\n    if (typeof this.exploding === 'number' && this.exploding === index) {\n      return;\n    }\n    if (!prop['chart.exploded']) {\n      prop['chart.exploded'] = [];\n    }\n    if (typeof prop['chart.exploded'] == 'number') {\n      var original_explode = prop['chart.exploded'];var exploded = prop['chart.exploded'];prop['chart.exploded'] = [];for (var i = 0, len = this.data.length; i < len; ++i) {\n        prop['chart.exploded'][i] = exploded;\n      }\n    }\n    prop['chart.exploded'][index] = typeof original_explode == 'number' ? original_explode : 0;this.exploding = index;var delay = RG.ISIE && !RG.ISIE10 ? 25 : 16.666;for (var o = 0; o < size; ++o) {\n      setTimeout(function () {\n        prop['chart.exploded'][index] += 1;RG.Clear(ca);RG.RedrawCanvas(ca);\n      }, o * delay);\n    }\n    var obj = this;setTimeout(function () {\n      obj.exploding = null;\n    }, size * delay);\n  };this.highlight_segment = function (segment) {\n    co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];co.moveTo(segment[0], segment[1]);co.arc(segment[0], segment[1], segment[2], this.angles[segment[5]][0], this.angles[segment[5]][1], 0);co.lineTo(segment[0], segment[1]);co.closePath();co.stroke();co.fill();\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] == '3d') {\n        co.lineWidth = 1;var extent = 2;co.beginPath();RG.NoShadow(this);co.fillStyle = 'rgba(0,0,0,0)';co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'], shape['y'], shape['radius'] / 5, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.fill();co.beginPath();co.shadowColor = '#666';co.shadowBlur = 3;co.shadowOffsetX = 3;co.shadowOffsetY = 3;co.fillStyle = prop['chart.colors'][shape['index']];co.strokeStyle = prop['chart.strokestyle'];co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'] - extent, shape['y'] - extent);\n        }\n        co.closePath();co.stroke();co.fill();RG.NoShadow(this);if (prop['chart.border']) {\n          co.beginPath();co.strokeStyle = prop['chart.border.color'];co.lineWidth = 5;co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] - 2, shape['angle.start'], shape['angle.end'], false);co.stroke();\n        }\n      } else if (prop['chart.highlight.style'] === 'outline') {\n        var tooltip = RG.Registry.get('chart.tooltip'),\n            index = tooltip.__index__,\n            coords = this.angles[index],\n            color = this.get('colors')[index];\n        width = this.radius / 12.5;if (typeof prop['chart.highlight.style.outline.width'] === 'number') {\n          width = prop['chart.highlight.style.outline.width'];\n        }\n        RGraph.path2(co, 'ga 0.25 b a % % % % % false a % % % % % true c f % ga 1', coords[2], coords[3], this.radius + 2 + width, coords[0], coords[1], coords[2], coords[3], this.radius + 2, coords[1], coords[0], color);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];if (prop['chart.variant'].indexOf('donut') > -1) {\n          co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);co.arc(shape['x'], shape['y'], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.arc(shape['x'], shape['y'], shape['radius'] + 1, shape['angle.start'], shape['angle.end'], false);co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (typeof prop['chart.centerpin'] == 'number' && prop['chart.centerpin'] > 0) {\n      var cx = this.centerx;var cy = this.centery;co.beginPath();co.strokeStyle = prop['chart.centerpin.stroke'] ? prop['chart.centerpin.stroke'] : prop['chart.strokestyle'];co.fillStyle = prop['chart.centerpin.fill'] ? prop['chart.centerpin.fill'] : prop['chart.strokestyle'];co.moveTo(cx, cy);co.arc(cx, cy, prop['chart.centerpin'], 0, RG.TWOPI, false);co.stroke();co.fill();\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function () {\n    var context = co;var cx = this.centerx;var cy = this.centery;var radius = prop['chart.labels.ingraph.radius'];if (radius <= 2 && radius > 0) {\n      radiusFactor = radius;\n    } else {\n      radiusFactor = 0.5;\n    }\n    if (prop['chart.variant'] == 'donut') {\n      var r = this.radius * (0.5 + radiusFactor * 0.5);if (typeof prop['chart.variant.donut.width'] == 'number') {\n        var r = this.radius - prop['chart.variant.donut.width'] + prop['chart.variant.donut.width'] / 2;\n      }\n    } else {\n      var r = this.radius * radiusFactor;\n    }\n    if (radius > 2) {\n      r = radius;\n    }\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      if (_typeof(prop['chart.exploded']) == 'object' && typeof prop['chart.exploded'][i] == 'number') {\n        var explosion = prop['chart.exploded'][i];\n      } else if (typeof prop['chart.exploded'] == 'number') {\n        var explosion = parseInt(prop['chart.exploded']);\n      } else {\n        var explosion = 0;\n      }\n      var angleStart = this.angles[i][0];var angleEnd = this.angles[i][1];var angleCenter = (angleEnd - angleStart) / 2 + angleStart;var coords = RG.getRadiusEndPoint(this.centerx, this.centery, angleCenter, r + (explosion ? explosion : 0));var x = coords[0];var y = coords[1];var text = prop['chart.labels.ingraph.specific'] && typeof prop['chart.labels.ingraph.specific'][i] == 'string' ? prop['chart.labels.ingraph.specific'][i] : RG.number_format(this, this.data[i], prop['chart.labels.ingraph.units.pre'], prop['chart.labels.ingraph.units.post']);if (text) {\n        co.beginPath();var font = typeof prop['chart.labels.ingraph.font'] === 'string' ? prop['chart.labels.ingraph.font'] : prop['chart.text.font'];var size = typeof prop['chart.labels.ingraph.size'] === 'number' ? prop['chart.labels.ingraph.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.labels.ingraph.color'] ? prop['chart.labels.ingraph.color'] : 'black';RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': text, 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.labels.ingraph.bounding'], 'bounding.fill': prop['chart.labels.ingraph.bounding.fill'], 'tag': 'labels.ingraph' });co.stroke();\n      }\n    }\n  };this.drawCenterLabel = function (label) {\n    var font = prop['chart.labels.center.font'],\n        size = prop['chart.labels.center.size'],\n        color = prop['chart.labels.center.color'],\n        unitsPre = prop['chart.labels.center.units.pre'],\n        unitsPost = prop['chart.labels.center.units.post'],\n        bold = prop['chart.labels.center.bold'],\n        italic = prop['chart.labels.center.italic'];RG.text2(this, { color: color, bold: bold, italic: italic, font: font, size: size, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', text: RG.numberFormat(this, label, unitsPre, unitsPost) });\n  };\n  this.getAngle = function (value) {\n    if (value > this.total) {\n      return null;\n    }\n    var angle = value / this.total * RG.TWOPI;angle += prop['chart.origin'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.arrayClone(prop['chart.key.colors']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.style.twod.fill'] = RG.arrayClone(prop['chart.highlight.style.twod.fill']);this.original_colors['chart.highlight.style.twod.stroke'] = RG.arrayClone(prop['chart.highlight.style.twod.stroke']);this.original_colors['chart.ingraph.bounding.fill'] = RG.arrayClone(prop['chart.ingraph.bounding.fill']);this.original_colors['chart.ingraph.color'] = RG.arrayClone(prop['chart.ingraph.color']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.style.twod.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.fill']);prop['chart.highlight.style.twod.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.stroke']);prop['chart.labels.ingraph.bounding.fill'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.bounding.fill']);prop['chart.labels.ingraph.color'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.variant'] == 'donut') {\n        var radius_start = typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2;\n      } else {\n        var radius_start = 0;\n      }\n      var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, Math.min(ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / 2);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.angles && this.angles[index]) {\n      var segment = this.angles[index];var x = segment[2];var y = segment[3];var start = segment[0];var end = segment[1];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.lineWidth = 2;co.lineJoin = 'bevel';co.beginPath();co.moveTo(x, y);co.arc(x, y, this.radius, start, end, false);co.closePath();co.fill();co.stroke();\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.draw3d = function () {\n    var scaleX = 1.5,\n        depth = prop['chart.variant.threed.depth'],\n        prop_shadow = prop['chart.shadow'],\n        prop_labels = prop['chart.labels'],\n        prop_labelsSticks = prop['chart.labels.sticks'];\n    this.set({ labels: [], labelsSticks: false, strokestyle: 'rgba(0,0,0,0)' });this.set({ variant: this.get('variant').replace(/3d/, '') });this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);for (var i = depth; i > 0; i -= 1) {\n      this.set({ centeryAdjust: i });if (i === parseInt(depth / 2)) {\n        this.set({ labels: prop_labels, labelsSticks: prop_labelsSticks });\n      }\n      if (i === 0) {\n        this.set({ shadow: prop_shadow });\n      }\n      this.draw();this.set('shadow', false);if (i <= parseInt(depth / 2)) {\n        this.set({ labels: [], labelsSticks: false });\n      }\n      if (i > 1) {\n        if (prop['chart.variant'].indexOf('donut') !== -1) {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'a', this.angles[j][2], this.angles[j][3], this.radius / 2, this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], this.angles[j][0], true, 'f', 'rgba(0,0,0,0.15)']);\n          }\n        } else {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'm', this.angles[j][2], this.angles[j][3], 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'c', 'f', 'rgba(0,0,0,0.15)']);\n          }\n        }\n      }\n    }\n    this.set({ variant: this.get('variant') + '3d', shadow: prop_shadow, labels: prop_labels, labelsSticks: prop_labelsSticks });return this;\n  };this.explode = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var maxExplode = Number(typeof opt.radius === 'number' ? opt.radius : ma.max(ca.width, ca.height));var currentExplode = Number(obj.get('exploded')) || 0;var step = (maxExplode - currentExplode) / frames;var iterator = function iterator() {\n      obj.set('exploded', currentExplode + step * frame);RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var radius = obj.getRadius();prop['chart.radius'] = 0;var iterator = function iterator() {\n      obj.set('chart.radius', frame / frames * radius);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frame = 0,\n        frames = opt.frames || 30,\n        radius = obj.getRadius(),\n        labels = obj.get('labels');\n    obj.Set('chart.events', false);obj.Set('chart.labels', []);var iterator = function iterator() {\n      obj.set('effect.roundrobin.multiplier', RG.Effects.getEasingMultiplier(frames, frame));RGraph.redrawCanvas(ca);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        obj.set({ events: true, labels: labels });RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);this.implode = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frames = opt.frames || 30,\n        frame = 0,\n        explodedMax = ma.max(ca.width, ca.height),\n        exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucGllLmpzP2E3MDIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5QaWU9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5kYXRhPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBpZD1jb25mLmlkLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksZGF0YT1jb25mLmRhdGEscGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBpZD1jb25mLGNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksZGF0YT1hcmd1bWVudHNbMV07fVxudGhpcy5pZD1pZDt0aGlzLmNhbnZhcz1jYW52YXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOih0eXBlb2YgaWQ9PT0nb2JqZWN0JyYmaWQuYWxwaGE9PT1mYWxzZSk/ZmFsc2U6dHJ1ZX0pOm51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMudG90YWw9MDt0aGlzLnN1YlRvdGFsPTA7dGhpcy5hbmdsZXM9W107dGhpcy5kYXRhPWRhdGE7dGhpcy5wcm9wZXJ0aWVzPVtdO3RoaXMudHlwZT0ncGllJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMua2V5PVtdO3RoaXMuY29vcmRzU3RpY2tzPVtdO3RoaXMuY29vcmRzVGV4dD1bXTt0aGlzLnVpZD1SR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkPXRoaXMuY2FudmFzLnVpZD90aGlzLmNhbnZhcy51aWQ6UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5leHBsb2Rpbmc9bnVsbDtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldPT09J3N0cmluZycpe3RoaXMuZGF0YVtpXT1wYXJzZUZsb2F0KHRoaXMuZGF0YVtpXSk7fX1cbnRoaXMucHJvcGVydGllcz17J2NoYXJ0LmNlbnRlcnguYWRqdXN0JzowLCdjaGFydC5jZW50ZXJ5LmFkanVzdCc6MCwnY2hhcnQuY29sb3JzJzpbJ3JlZCcsJyNjY2MnLCcjY2ZjJywnYmx1ZScsJ3BpbmsnLCd5ZWxsb3cnLCdibGFjaycsJ29yYW5nZScsJ2N5YW4nLCdwdXJwbGUnLCcjNzhDQUVBJywnI0UyODRFOScsJ3doaXRlJywnYmx1ZScsJyM5RTdCRjYnXSwnY2hhcnQuc3Ryb2tlc3R5bGUnOid3aGl0ZScsJ2NoYXJ0LmxpbmV3aWR0aCc6MywnY2hhcnQubGFiZWxzJzpbXSwnY2hhcnQubGFiZWxzLmJvbGQnOmZhbHNlLCdjaGFydC5sYWJlbHMuc3RpY2tzJzpmYWxzZSwnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnOjcsJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJzpudWxsLCdjaGFydC5sYWJlbHMuc3RpY2tzLnVzZWNvbG9ycyc6dHJ1ZSwnY2hhcnQubGFiZWxzLnN0aWNrcy5saW5ld2lkdGgnOjEsJ2NoYXJ0LmxhYmVscy5zdGlja3MuaGxlbmd0aCc6NSwnY2hhcnQubGFiZWxzLnN0aWNrcy5saXN0JzpmYWxzZSwnY2hhcnQubGFiZWxzLmluZ3JhcGgnOm51bGwsJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJzpudWxsLCdjaGFydC5sYWJlbHMuaW5ncmFwaC5mb250JzpudWxsLCdjaGFydC5sYWJlbHMuaW5ncmFwaC5zaXplJzpudWxsLCdjaGFydC5sYWJlbHMuaW5ncmFwaC5ib3VuZGluZyc6dHJ1ZSwnY2hhcnQubGFiZWxzLmluZ3JhcGguYm91bmRpbmcuZmlsbCc6J3doaXRlJywnY2hhcnQubGFiZWxzLmluZ3JhcGguc3BlY2lmaWMnOm51bGwsJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnByZSc6JycsJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnBvc3QnOicnLCdjaGFydC5sYWJlbHMuaW5ncmFwaC5yYWRpdXMnOm51bGwsJ2NoYXJ0LmxhYmVscy5jZW50ZXInOm51bGwsJ2NoYXJ0LmxhYmVscy5jZW50ZXIuc2l6ZSc6MjYsJ2NoYXJ0LmxhYmVscy5jZW50ZXIuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LmxhYmVscy5jZW50ZXIuY29sb3InOidibGFjaycsJ2NoYXJ0LmxhYmVscy5jZW50ZXIuaXRhbGljJzpmYWxzZSwnY2hhcnQubGFiZWxzLmNlbnRlci5ib2xkJzpmYWxzZSwnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wcmUnOicnLCdjaGFydC5sYWJlbHMuY2VudGVyLnVuaXRzLnBvc3QnOicnLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC50aXRsZS5ocG9zJzpudWxsLCdjaGFydC50aXRsZS52cG9zJzowLjUsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmhhbGlnbic6bnVsbCwnY2hhcnQudGl0bGUudmFsaWduJzpudWxsLCdjaGFydC5zaGFkb3cnOnRydWUsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6JyNhYWEnLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MCwnY2hhcnQuc2hhZG93Lm9mZnNldHknOjAsJ2NoYXJ0LnNoYWRvdy5ibHVyJzoxNSwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmNvbnRleHRtZW51JzpudWxsLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC5oaWdobGlnaHQuc3R5bGUnOicyZCcsJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5zdHJva2UnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5oaWdobGlnaHQuc3R5bGUub3V0bGluZS53aWR0aCc6bnVsbCwnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQucmFkaXVzJzpudWxsLCdjaGFydC5ib3JkZXInOmZhbHNlLCdjaGFydC5ib3JkZXIuY29sb3InOidyZ2JhKDI1NSwyNTUsMjU1LDAuNSknLCdjaGFydC5rZXknOm51bGwsJ2NoYXJ0LmtleS5iYWNrZ3JvdW5kJzond2hpdGUnLCdjaGFydC5rZXkucG9zaXRpb24nOidncmFwaCcsJ2NoYXJ0LmtleS5oYWxpZ24nOidyaWdodCcsJ2NoYXJ0LmtleS5zaGFkb3cnOmZhbHNlLCdjaGFydC5rZXkuc2hhZG93LmNvbG9yJzonIzY2NicsJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6MywnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4JzoyLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknOjIsJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOmZhbHNlLCdjaGFydC5rZXkucG9zaXRpb24ueCc6bnVsbCwnY2hhcnQua2V5LnBvc2l0aW9uLnknOm51bGwsJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6J3NxdWFyZScsJ2NoYXJ0LmtleS5yb3VuZGVkJzp0cnVlLCdjaGFydC5rZXkubGluZXdpZHRoJzoxLCdjaGFydC5rZXkuY29sb3JzJzpudWxsLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUnOmZhbHNlLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSc6J2JsYWNrJywnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5sYWJlbCc6J3JnYmEoMjU1LDAsMCwwLjIpJywnY2hhcnQua2V5LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC52YXJpYW50JzoncGllJywnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCc6bnVsbCwnY2hhcnQudmFyaWFudC50aHJlZWQuZGVwdGgnOjIwLCdjaGFydC5leHBsb2RlZCc6W10sJ2NoYXJ0LmVmZmVjdC5yb3VuZHJvYmluLm11bHRpcGxpZXInOjEsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuY2VudGVycGluJzpudWxsLCdjaGFydC5jZW50ZXJwaW4uZmlsbCc6J2dyYXknLCdjaGFydC5jZW50ZXJwaW4uc3Ryb2tlJzond2hpdGUnLCdjaGFydC5vcmlnaW4nOjAtKE1hdGguUEkvMiksJ2NoYXJ0LmV2ZW50cyc6dHJ1ZSwnY2hhcnQubGFiZWxzLmNvbG9ycyc6W10sJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmZvcih2YXIgaT0wLGxlbj1kYXRhLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMudG90YWwrPWRhdGFbaV07dGhpc1snJCcraV09e307fVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmNvbG9yJyl7bmFtZT0nY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCc7fVxuaWYobmFtZT09J2NoYXJ0LmxhYmVscy5zcGFjZWQnKXtuYW1lPSdjaGFydC5sYWJlbHMuc3RpY2tzLmxpc3QnO31cbnByb3BbbmFtZV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5pZihuYW1lPT0nY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuY29sb3InKXtuYW1lPSdjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJzt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5yYWRpdXM9dGhpcy5nZXRSYWRpdXMoKTt0aGlzLmNlbnRlcng9KHRoaXMuZ3JhcGgud2lkdGgvMikrdGhpcy5ndXR0ZXJMZWZ0K3Byb3BbJ2NoYXJ0LmNlbnRlcnguYWRqdXN0J107dGhpcy5jZW50ZXJ5PSh0aGlzLmdyYXBoLmhlaWdodC8yKSt0aGlzLmd1dHRlclRvcCtwcm9wWydjaGFydC5jZW50ZXJ5LmFkanVzdCddO3RoaXMuc3ViVG90YWw9dGhpcy5wcm9wZXJ0aWVzWydjaGFydC5vcmlnaW4nXTt0aGlzLmFuZ2xlcz1bXTt0aGlzLmNvb3Jkc1RleHQ9W107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddPT09J251bWJlcicpdGhpcy5yYWRpdXM9cHJvcFsnY2hhcnQucmFkaXVzJ107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXT09PSdudW1iZXInKXRoaXMuY2VudGVyeD1wcm9wWydjaGFydC5jZW50ZXJ4J107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXT09PSdudW1iZXInKXRoaXMuY2VudGVyeT1wcm9wWydjaGFydC5jZW50ZXJ5J107aWYodGhpcy5yYWRpdXM8PTApe3JldHVybjt9XG5pZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXS5sZW5ndGg8cHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoKXt3aGlsZShwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10ubGVuZ3RoPHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCl7cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddLnB1c2gocHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddW3Byb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXS5sZW5ndGgtMV0pO319ZWxzZXtpZih0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddPT09J3VuZGVmaW5lZCcpe3Byb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXT1bXTt9XG53aGlsZShwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10ubGVuZ3RoPHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCl7cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddLnB1c2gocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTt9fVxuaWYocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJzNkJyk+MCl7cmV0dXJuIHRoaXMuZHJhdzNkKCk7fVxuUkcuRHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSwoY2EuaGVpZ2h0LzIpLXRoaXMucmFkaXVzLTUsdGhpcy5jZW50ZXJ4LHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10rMik7dGhpcy50b3RhbD1SRy5hcnJheV9zdW0odGhpcy5kYXRhKTt2YXIgdG90PXRoaXMudG90YWw7dmFyIGRhdGE9dGhpcy5kYXRhO2Zvcih2YXIgaT0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuO2krKyl7dmFyIGFuZ2xlPSgoZGF0YVtpXS90b3QpKlJHLlRXT1BJKTt0aGlzLkRyYXdTZWdtZW50KGFuZ2xlLHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldLGk9PShsZW4tMSksaSk7fVxuUkcuTm9TaGFkb3codGhpcyk7aWYocHJvcFsnY2hhcnQubGluZXdpZHRoJ10+MCl7dGhpcy5EcmF3Qm9yZGVycygpO31cbnZhciBsZW49dGhpcy5hbmdsZXMubGVuZ3RoO3ZhciByPXRoaXMucmFkaXVzO2Zvcih2YXIgYWN0aW9uPTA7YWN0aW9uPDI7YWN0aW9uKz0xKXtmb3IodmFyIGk9MDtpPGxlbjtpKyspe2NvLmJlZ2luUGF0aCgpO3ZhciBzZWdtZW50PXRoaXMuYW5nbGVzW2ldO2lmKGFjdGlvbj09PTEpe2NvLnN0cm9rZVN0eWxlPXR5cGVvZihwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKT09J29iamVjdCc/cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXVtpXTpwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO31cbnByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldP2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTpudWxsO2NvLmxpbmVKb2luPSdyb3VuZCc7Y28uYXJjKHNlZ21lbnRbMl0sc2VnbWVudFszXSxyLChzZWdtZW50WzBdKSwoc2VnbWVudFsxXSksZmFsc2UpO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09J2RvbnV0Jyl7Y28uYXJjKHNlZ21lbnRbMl0sc2VnbWVudFszXSx0eXBlb2YocHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddKT09J251bWJlcic/ci1wcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ106ci8yLChzZWdtZW50WzFdKSwoc2VnbWVudFswXSksdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKHNlZ21lbnRbMl0sc2VnbWVudFszXSk7fVxuY28uY2xvc2VQYXRoKCk7YWN0aW9uPT09MD9jby5maWxsKCk6Y28uc3Ryb2tlKCk7fX1cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MnXSl7dGhpcy5EcmF3U3RpY2tzKCk7dmFyIHN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107fVxuaWYocHJvcFsnY2hhcnQubGFiZWxzJ10pe3RoaXMuRHJhd0xhYmVscygpO31cbmlmKHByb3BbJ2NoYXJ0LmNlbnRlcnBpbiddKXt0aGlzLkRyYXdDZW50ZXJwaW4oKTt9XG5pZihwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaCddKXt0aGlzLkRyYXdJbkdyYXBoTGFiZWxzKCk7fVxuaWYoIVJHLmlzTnVsbChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pKXt0aGlzLmRyYXdDZW50ZXJMYWJlbChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LmJvcmRlciddKXtjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGg9NTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5ib3JkZXIuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy0yLDAsUkcuVFdPUEksMCk7Y28uc3Ryb2tlKCk7fVxuaWYocHJvcFsnY2hhcnQua2V5J10mJnByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCl7UkcuRHJhd0tleSh0aGlzLHByb3BbJ2NoYXJ0LmtleSddLHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt9XG5SRy5Ob1NoYWRvdyh0aGlzKTtpZihwcm9wWydjaGFydC5yZXNpemFibGUnXSl7UkcuQWxsb3dSZXNpemluZyh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5ldmVudHMnXT09dHJ1ZSl7UkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO31cbmlmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3U2VnbWVudD10aGlzLkRyYXdTZWdtZW50PWZ1bmN0aW9uKHJhZGlhbnMsY29sb3IsbGFzdCxpbmRleClcbntpZihSR3JhcGguSVNPTEQmJnJhZGlhbnM9PVJHLlRXT1BJKXtyYWRpYW5zLT0wLjAwMDE7fWVsc2UgaWYoUkdyYXBoLklTT0xEJiZyYWRpYW5zPT0wKXtyYWRpYW5zPTAuMDAxO31cbnZhciBzdWJUb3RhbD10aGlzLnN1YlRvdGFsO3JhZGlhbnM9cmFkaWFucypwcm9wWydjaGFydC5lZmZlY3Qucm91bmRyb2Jpbi5tdWx0aXBsaWVyJ107Y28uYmVnaW5QYXRoKCk7Y29sb3I/Y28uZmlsbFN0eWxlPWNvbG9yOm51bGw7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGg9MDtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31cbmlmKCh0eXBlb2YocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC5leHBsb2RlZCddW2luZGV4XT4wKXx8dHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pPT0nbnVtYmVyJyl7dmFyIGV4cGxvc2lvbj10eXBlb2YocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmV4cGxvZGVkJ106cHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpbmRleF07dmFyIHg9MDt2YXIgeT0wO3ZhciBoPWV4cGxvc2lvbjt2YXIgdD1zdWJUb3RhbCsocmFkaWFucy8yKTt2YXIgeD0oTWF0aC5jb3ModCkqZXhwbG9zaW9uKTt2YXIgeT0oTWF0aC5zaW4odCkqZXhwbG9zaW9uKTt2YXIgcj10aGlzLnJhZGl1cztjby5tb3ZlVG8odGhpcy5jZW50ZXJ4K3gsdGhpcy5jZW50ZXJ5K3kpO31lbHNle3ZhciB4PTA7dmFyIHk9MDt2YXIgcj10aGlzLnJhZGl1czt9XG52YXIgc3RhcnRBbmdsZT1zdWJUb3RhbDt2YXIgZW5kQW5nbGU9KChzdWJUb3RhbCtyYWRpYW5zKSk7Y28uYXJjKHRoaXMuY2VudGVyeCt4LHRoaXMuY2VudGVyeSt5LHIsc3RhcnRBbmdsZSxlbmRBbmdsZSwwKTtpZihwcm9wWydjaGFydC52YXJpYW50J109PSdkb251dCcpe2NvLmFyYyh0aGlzLmNlbnRlcngreCx0aGlzLmNlbnRlcnkreSx0eXBlb2YocHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddKT09J251bWJlcic/ci1wcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ106ci8yLGVuZEFuZ2xlLHN0YXJ0QW5nbGUsdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKHRoaXMuY2VudGVyeCt4LHRoaXMuY2VudGVyeSt5KTt9XG5jby5jbG9zZVBhdGgoKTt0aGlzLmFuZ2xlcy5wdXNoKFtzdWJUb3RhbCxzdWJUb3RhbCtyYWRpYW5zLHRoaXMuY2VudGVyeCt4LHRoaXMuY2VudGVyeSt5XSk7Y28uZmlsbCgpO3RoaXMuc3ViVG90YWwrPXJhZGlhbnM7fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgmJnByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGlzdCddKXtyZXR1cm4gdGhpcy5kcmF3TGFiZWxzTGlzdCgpO31cbnZhciBoQWxpZ25tZW50PSdsZWZ0Jyx2QWxpZ25tZW50PSdjZW50ZXInLGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXSxjb250ZXh0PWNvLGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sYm9sZD1wcm9wWydjaGFydC5sYWJlbHMuYm9sZCddLHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSxjeD10aGlzLmNlbnRlcngsY3k9dGhpcy5jZW50ZXJ5LHI9dGhpcy5yYWRpdXM7Ukcubm9TaGFkb3codGhpcyk7Y28uZmlsbFN0eWxlPSdibGFjayc7Y28uYmVnaW5QYXRoKCk7aWYobGFiZWxzJiZsYWJlbHMubGVuZ3RoKXtmb3IoaT0wO2k8dGhpcy5hbmdsZXMubGVuZ3RoOysraSl7dmFyIHNlZ21lbnQ9dGhpcy5hbmdsZXNbaV07aWYodHlwZW9mIGxhYmVsc1tpXSE9J3N0cmluZycmJnR5cGVvZiBsYWJlbHNbaV0hPSdudW1iZXInKXtjb250aW51ZTt9XG5jby5tb3ZlVG8oY3gsY3kpO3ZhciBhPXNlZ21lbnRbMF0rKChzZWdtZW50WzFdLXNlZ21lbnRbMF0pLzIpLGFuZ2xlPSgoc2VnbWVudFsxXS1zZWdtZW50WzBdKS8yKStzZWdtZW50WzBdO2lmKHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddPT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV18fHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddPT0nbnVtYmVyJyl7dmFyIHQ9KChzZWdtZW50WzFdLXNlZ21lbnRbMF0pLzIpLHNlcGVyYXRpb249dHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pPT0nbnVtYmVyJz9wcm9wWydjaGFydC5leHBsb2RlZCddOnByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV07dmFyIGV4cGxvc2lvbl9vZmZzZXR4PShNYXRoLmNvcyhhbmdsZSkqc2VwZXJhdGlvbiksZXhwbG9zaW9uX29mZnNldHk9KE1hdGguc2luKGFuZ2xlKSpzZXBlcmF0aW9uKTt9ZWxzZXt2YXIgZXhwbG9zaW9uX29mZnNldHg9MCxleHBsb3Npb25fb2Zmc2V0eT0wO31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MnXSl7ZXhwbG9zaW9uX29mZnNldHgrPShtYS5jb3MoYW5nbGUpKih0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXT09PSdvYmplY3QnP3Byb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ11baV06cHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXSkpO2V4cGxvc2lvbl9vZmZzZXR5Kz0obWEuc2luKGFuZ2xlKSoodHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ109PT0nb2JqZWN0Jz9wcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmxlbmd0aCddW2ldOnByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ10pKTt9XG52YXIgeD1jeCtleHBsb3Npb25fb2Zmc2V0eCsoKHIrMTApKk1hdGguY29zKGEpKSsocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddPyhhPFJHLkhBTEZQSXx8YT4oUkcuVFdPUEkrUkcuSEFMRlBJKT8yOi0yKTowKSx5PWN5K2V4cGxvc2lvbl9vZmZzZXR5KygoKHIrMTApKk1hdGguc2luKGEpKSk7aWYodGhpcy5jb29yZHNTdGlja3MmJnRoaXMuY29vcmRzU3RpY2tzW2ldKXt2YXIgeD10aGlzLmNvb3Jkc1N0aWNrc1tpXVs0XVswXSsoeDxjeD8tNTo1KSx5PXRoaXMuY29vcmRzU3RpY2tzW2ldWzRdWzFdO31cbnZBbGlnbm1lbnQ9J2NlbnRlcic7aEFsaWdubWVudD14PGN4PydyaWdodCc6J2xlZnQnO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXT09PSdvYmplY3QnJiZwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10mJnByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXVtpXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXVtpXTt9XG5SRy50ZXh0Mih0aGlzLHtmb250OmZvbnQsc2l6ZTp0ZXh0X3NpemUseDp4LHk6eSx0ZXh0OmxhYmVsc1tpXSx2YWxpZ246dkFsaWdubWVudCxoYWxpZ246aEFsaWdubWVudCx0YWc6J2xhYmVscycsYm9sZDpib2xkLGNvbG9yOnByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MudXNlY29sb3JzJ10/cHJvcFsnY2hhcnQuY29sb3JzJ11baV06J2JsYWNrJ30pO31cbmNvLmZpbGwoKTt9fTt0aGlzLmRyYXdMYWJlbHNMaXN0PWZ1bmN0aW9uKClcbnt2YXIgc2VnbWVudD10aGlzLmFuZ2xlc1tpXSxsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ10sbGFiZWxzX3JpZ2h0PVtdLGxhYmVsc19sZWZ0PVtdLHRleHRfZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXSx0ZXh0X3NpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sdGV4dF9jb2xvcj1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sbGVmdD1bXSxyaWdodD1bXSxjZW50ZXJ4PXRoaXMuY2VudGVyeCxjZW50ZXJ5PXRoaXMuY2VudGVyeSxyYWRpdXM9dGhpcy5yYWRpdXMsb2Zmc2V0PTUwXG5mb3IodmFyIGk9MDtpPHRoaXMuYW5nbGVzLmxlbmd0aDsrK2kpe3ZhciBhbmdsZT10aGlzLmFuZ2xlc1tpXVswXSsoKHRoaXMuYW5nbGVzW2ldWzFdLXRoaXMuYW5nbGVzW2ldWzBdKS8yKSxlbmRwb2ludF9pbm5lcj1SRy5nZXRSYWRpdXNFbmRQb2ludChjZW50ZXJ4LGNlbnRlcnksYW5nbGUscmFkaXVzKzUpLGVuZHBvaW50X291dGVyPVJHLmdldFJhZGl1c0VuZFBvaW50KGNlbnRlcngsY2VudGVyeSxhbmdsZSxyYWRpdXMrMTApLGV4cGxvc2lvbj1bKHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddPT09J251bWJlcic/cHJvcFsnY2hhcnQuZXhwbG9kZWQnXTpwcm9wWydjaGFydC5leHBsb2RlZCddW2ldKSwobWEuY29zKGFuZ2xlKSoodHlwZW9mIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ109PT0nbnVtYmVyJz9wcm9wWydjaGFydC5leHBsb2RlZCddOnByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV0pKSwobWEuc2luKGFuZ2xlKSoodHlwZW9mIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ109PT0nbnVtYmVyJz9wcm9wWydjaGFydC5leHBsb2RlZCddOnByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV0pKV1cbmlmKHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddPT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJ10mJnByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJ11baV0pe3ZhciBjb2xvcj1wcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddW2ldO31lbHNlIGlmKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MudXNlY29sb3JzJ10mJnByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldKXt2YXIgY29sb3I9cHJvcFsnY2hhcnQuY29sb3JzJ11baV07fWVsc2V7dmFyIGNvbG9yPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt9XG5pZihhbmdsZT4oLTEqUkcuSEFMRlBJKSYmYW5nbGU8UkcuSEFMRlBJKXtsYWJlbHNfcmlnaHQucHVzaChbaSxhbmdsZSxsYWJlbHNbaV0/bGFiZWxzW2ldOicnLGVuZHBvaW50X2lubmVyLGVuZHBvaW50X291dGVyLGNvbG9yLFJHLmFycmF5Q2xvbmUoZXhwbG9zaW9uKV0pO31lbHNle2xhYmVsc19sZWZ0LnB1c2goW2ksYW5nbGUsbGFiZWxzW2ldP2xhYmVsc1tpXTonJyxlbmRwb2ludF9pbm5lcixlbmRwb2ludF9vdXRlcixjb2xvcixSRy5hcnJheUNsb25lKGV4cGxvc2lvbildKTt9fVxudmFyIHZzcGFjZV9yaWdodD0oY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXS1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pL2xhYmVsc19yaWdodC5sZW5ndGhcbmZvcih2YXIgaT0wLHk9KHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSsodnNwYWNlX3JpZ2h0LzIpKTtpPGxhYmVsc19yaWdodC5sZW5ndGg7eSs9dnNwYWNlX3JpZ2h0LGkrKyl7aWYobGFiZWxzX3JpZ2h0W2ldWzJdKXt2YXIgeD10aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMrb2Zmc2V0LGlkeD1sYWJlbHNfcmlnaHRbaV1bMF0sZXhwbG9zaW9uWD1sYWJlbHNfcmlnaHRbaV1bNl1bMF0/bGFiZWxzX3JpZ2h0W2ldWzZdWzFdOjAsZXhwbG9zaW9uWT1sYWJlbHNfcmlnaHRbaV1bNl1bMF0/bGFiZWxzX3JpZ2h0W2ldWzZdWzJdOjBcbnZhciByZXQ9UkcudGV4dDIodGhpcyx7Zm9udDp0ZXh0X2ZvbnQsc2l6ZTp0ZXh0X3NpemUseDp4K2V4cGxvc2lvblgseTp5K2V4cGxvc2lvblksdGV4dDpsYWJlbHNfcmlnaHRbaV1bMl0sdmFsaWduOidjZW50ZXInLGhhbGlnbjonbGVmdCcsdGFnOidsYWJlbHMnLGNvbG9yOmxhYmVsc19yaWdodFtpXVs1XX0pO2lmKHJldCYmcmV0Lm5vZGUpe3JldC5ub2RlLl9faW5kZXhfXz1sYWJlbHNfcmlnaHRbaV1bMF07fVxucGEyKGNvLCdsYyByb3VuZCBsdyAlIGIgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAlJyxwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmxpbmV3aWR0aCddLGxhYmVsc19yaWdodFtpXVszXVswXStleHBsb3Npb25YLGxhYmVsc19yaWdodFtpXVszXVsxXStleHBsb3Npb25ZLGxhYmVsc19yaWdodFtpXVs0XVswXStleHBsb3Npb25YLGxhYmVsc19yaWdodFtpXVs0XVsxXStleHBsb3Npb25ZLHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cysyNStleHBsb3Npb25YLG1hLnJvdW5kKGxhYmVsc19yaWdodFtpXVs0XVsxXStleHBsb3Npb25ZKSxyZXQueC01LHJldC55KyhyZXQuaGVpZ2h0LzIpLGxhYmVsc19yaWdodFtpXVs1XSk7fX1cbnZhciB2c3BhY2VfbGVmdD0oY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXS1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pL2xhYmVsc19sZWZ0Lmxlbmd0aFxuZm9yKHZhciBpPShsYWJlbHNfbGVmdC5sZW5ndGgtMSkseT0ocHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKyh2c3BhY2VfbGVmdC8yKSk7aT49MDt5Kz12c3BhY2VfbGVmdCxpLS0pe2lmKGxhYmVsc19sZWZ0W2ldWzJdKXt2YXIgeD10aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMtb2Zmc2V0LGlkeD1sYWJlbHNfbGVmdFtpXVswXSxleHBsb3Npb25YPWxhYmVsc19sZWZ0W2ldWzZdWzBdP2xhYmVsc19sZWZ0W2ldWzZdWzFdOjAsZXhwbG9zaW9uWT1sYWJlbHNfbGVmdFtpXVs2XVswXT9sYWJlbHNfbGVmdFtpXVs2XVsyXTowXG52YXIgcmV0PVJHLnRleHQyKHRoaXMse2ZvbnQ6dGV4dF9mb250LHNpemU6dGV4dF9zaXplLHg6eCtleHBsb3Npb25YLHk6eStleHBsb3Npb25ZLHRleHQ6bGFiZWxzX2xlZnRbaV1bMl0sdmFsaWduOidjZW50ZXInLGhhbGlnbjoncmlnaHQnLHRhZzonbGFiZWxzJyxjb2xvcjpsYWJlbHNfbGVmdFtpXVs1XX0pO2lmKHJldCYmcmV0Lm5vZGUpe3JldC5ub2RlLl9faW5kZXhfXz1sYWJlbHNfbGVmdFtpXVswXTt9XG5wYTIoY28sJ2x3ICUgYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBzICUnLHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGluZXdpZHRoJ10sbGFiZWxzX2xlZnRbaV1bM11bMF0rZXhwbG9zaW9uWCxsYWJlbHNfbGVmdFtpXVszXVsxXStleHBsb3Npb25ZLGxhYmVsc19sZWZ0W2ldWzRdWzBdK2V4cGxvc2lvblgsbGFiZWxzX2xlZnRbaV1bNF1bMV0rZXhwbG9zaW9uWSx0aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMtMjUrZXhwbG9zaW9uWCxtYS5yb3VuZChsYWJlbHNfbGVmdFtpXVs0XVsxXStleHBsb3Npb25ZKSxyZXQueCs1K3JldC53aWR0aCxyZXQueSsocmV0LmhlaWdodC8yKSxsYWJlbHNfbGVmdFtpXVs1XSk7fX19O3RoaXMuZHJhd1N0aWNrcz10aGlzLkRyYXdTdGlja3M9ZnVuY3Rpb24oKVxue3ZhciBvZmZzZXQ9cHJvcFsnY2hhcnQubGluZXdpZHRoJ10vMixleHBsb2RlZD1wcm9wWydjaGFydC5leHBsb2RlZCddLHN0aWNrcz1wcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzJ10sY29sb3JzPXByb3BbJ2NoYXJ0LmNvbG9ycyddLGN4PXRoaXMuY2VudGVyeCxjeT10aGlzLmNlbnRlcnkscmFkaXVzPXRoaXMucmFkaXVzLHBvaW50cz1bXSxsaW5ld2lkdGg9cHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5saW5ld2lkdGgnXVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuYW5nbGVzLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciBzZWdtZW50PXRoaXMuYW5nbGVzW2ldO2lmKHR5cGVvZiBzdGlja3M9PT0nb2JqZWN0JyYmIXN0aWNrc1tpXSl7Y29udGludWU7fVxudmFyIHJhZGlhbnM9c2VnbWVudFsxXS1zZWdtZW50WzBdO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddPT09J3N0cmluZyc/cHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5jb2xvcnMnXTooIVJHLmlzTnVsbChwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddKT9wcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddW2ldOidncmF5Jyk7Y28ubGluZVdpZHRoPWxpbmV3aWR0aDtpZih0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5jb2xvciddPT09J3N0cmluZycpe2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3InXTt9XG5pZihwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLnVzZWNvbG9ycyddKXtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTt9XG52YXIgbWlkcG9pbnQ9KHNlZ21lbnRbMF0rKHJhZGlhbnMvMikpO2lmKHR5cGVvZiBleHBsb2RlZD09PSdvYmplY3QnJiZleHBsb2RlZFtpXSl7dmFyIGV4dHJhPWV4cGxvZGVkW2ldO31lbHNlIGlmKHR5cGVvZiBleHBsb2RlZD09PSdudW1iZXInKXt2YXIgZXh0cmE9ZXhwbG9kZWQ7fWVsc2V7dmFyIGV4dHJhPTA7fVxudmFyIHN0aWNrTGVuZ3RoPXR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmxlbmd0aCddPT09J29iamVjdCc/cHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXVtpXTpwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmxlbmd0aCddO3BvaW50c1swXT1SRy5nZXRSYWRpdXNFbmRQb2ludChjeCxjeSxtaWRwb2ludCxyYWRpdXMrZXh0cmErb2Zmc2V0KTtwb2ludHNbMV09UkcuZ2V0UmFkaXVzRW5kUG9pbnQoY3gsY3ksbWlkcG9pbnQscmFkaXVzK3N0aWNrTGVuZ3RoK2V4dHJhLTUpO3BvaW50c1syXT1SRy5nZXRSYWRpdXNFbmRQb2ludChjeCxjeSxtaWRwb2ludCxyYWRpdXMrc3RpY2tMZW5ndGgrZXh0cmEpO3BvaW50c1szXT1SRy5nZXRSYWRpdXNFbmRQb2ludChjeCxjeSxtaWRwb2ludCxyYWRpdXMrc3RpY2tMZW5ndGgrZXh0cmEpO3BvaW50c1szXVswXSs9KHBvaW50c1szXVswXT5jeD81Oi01KTtwb2ludHNbNF09W3BvaW50c1syXVswXSsocG9pbnRzWzJdWzBdPmN4PzUrcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5obGVuZ3RoJ106LTUtcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5obGVuZ3RoJ10pLHBvaW50c1syXVsxXV07Y28ubW92ZVRvKHBvaW50c1swXVswXSxwb2ludHNbMF1bMV0pO2NvLnF1YWRyYXRpY0N1cnZlVG8ocG9pbnRzWzJdWzBdLHBvaW50c1syXVsxXSxwb2ludHNbNF1bMF0scG9pbnRzWzRdWzFdKTtjby5zdHJva2UoKTt0aGlzLmNvb3Jkc1N0aWNrc1tpXT1bcG9pbnRzWzBdLHBvaW50c1sxXSxwb2ludHNbMl0scG9pbnRzWzNdLHBvaW50c1s0XV07fX07dGhpcy5nZXRTaGFwZT10aGlzLmdldFNlZ21lbnQ9ZnVuY3Rpb24oZSlcbntSRy5GaXhFdmVudE9iamVjdChlKTt2YXIgYWNjdXJhY3k9YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3ZhciBjYW52YXM9Y2E7dmFyIGNvbnRleHQ9Y287dmFyIG1vdXNlQ29vcmRzPVJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZPW1vdXNlQ29vcmRzWzFdO3ZhciByPXRoaXMucmFkaXVzO3ZhciBhbmdsZXM9dGhpcy5hbmdsZXM7dmFyIHJldD1bXTtmb3IodmFyIGk9MCxsZW49YW5nbGVzLmxlbmd0aDtpPGxlbjsrK2kpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPSdyZ2JhKDAsMCwwLDApJztjby5hcmMoYW5nbGVzW2ldWzJdLGFuZ2xlc1tpXVszXSx0aGlzLnJhZGl1cyxhbmdsZXNbaV1bMF0sYW5nbGVzW2ldWzFdLGZhbHNlKTtpZih0aGlzLnR5cGU9PSdwaWUnJiZwcm9wWydjaGFydC52YXJpYW50J109PSdkb251dCcpe2NvLmFyYyhhbmdsZXNbaV1bMl0sYW5nbGVzW2ldWzNdLCh0eXBlb2YocHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddKT09J251bWJlcic/dGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddOnRoaXMucmFkaXVzLzIpLGFuZ2xlc1tpXVsxXSxhbmdsZXNbaV1bMF0sdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKGFuZ2xlc1tpXVsyXSxhbmdsZXNbaV1bM10pO31cbmNvLmNsb3NlUGF0aCgpO2lmKCFjby5pc1BvaW50SW5QYXRoKG1vdXNlWCxtb3VzZVkpKXtjb250aW51ZTt9XG5yZXRbMF09YW5nbGVzW2ldWzJdO3JldFsxXT1hbmdsZXNbaV1bM107cmV0WzJdPXRoaXMucmFkaXVzO3JldFszXT1hbmdsZXNbaV1bMF0tUkcuVFdPUEk7cmV0WzRdPWFuZ2xlc1tpXVsxXTtyZXRbNV09aTtpZihyZXRbM108MClyZXRbM10rPVJHLlRXT1BJO2lmKHJldFs0XT5SRy5UV09QSSlyZXRbNF0tPVJHLlRXT1BJO3ZhciB0b29sdGlwPVJHLnBhcnNlVG9vbHRpcFRleHQ/UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLHJldFs1XSk6bnVsbDtyZXRbJ29iamVjdCddPXRoaXM7cmV0Wyd4J109cmV0WzBdO3JldFsneSddPXJldFsxXTtyZXRbJ3JhZGl1cyddPXJldFsyXTtyZXRbJ2FuZ2xlLnN0YXJ0J109cmV0WzNdO3JldFsnYW5nbGUuZW5kJ109cmV0WzRdO3JldFsnaW5kZXgnXT1yZXRbNV07cmV0Wyd0b29sdGlwJ109dG9vbHRpcDtyZXR1cm4gcmV0O31cbnJldHVybiBudWxsO307dGhpcy5kcmF3Qm9yZGVycz10aGlzLkRyYXdCb3JkZXJzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5saW5ld2lkdGgnXT4wKXtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTt2YXIgcj10aGlzLnJhZGl1cztmb3IodmFyIGk9MCxsZW49dGhpcy5hbmdsZXMubGVuZ3RoO2k8bGVuOysraSl7dmFyIHNlZ21lbnQ9dGhpcy5hbmdsZXNbaV07Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHNlZ21lbnRbMl0sc2VnbWVudFszXSxyLChzZWdtZW50WzBdKSwoc2VnbWVudFswXSswLjAwMSksMCk7Y28uYXJjKHNlZ21lbnRbMl0sc2VnbWVudFszXSxwcm9wWydjaGFydC52YXJpYW50J109PSdkb251dCc/KHR5cGVvZihwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10pPT0nbnVtYmVyJz90aGlzLnJhZGl1cy1wcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ106ci8yKTpyLHNlZ21lbnRbMF0sc2VnbWVudFswXSswLjAwMDEsMCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7fX19O3RoaXMuZ2V0UmFkaXVzPWZ1bmN0aW9uKClcbnt0aGlzLmdyYXBoPXt3aWR0aDpjYS53aWR0aC1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLGhlaWdodDpjYS5oZWlnaHQtcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddLXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXX1cbmlmKHR5cGVvZihwcm9wWydjaGFydC5yYWRpdXMnXSk9PSdudW1iZXInKXt0aGlzLnJhZGl1cz1wcm9wWydjaGFydC5yYWRpdXMnXTt9ZWxzZXt0aGlzLnJhZGl1cz1NYXRoLm1pbih0aGlzLmdyYXBoLndpZHRoLHRoaXMuZ3JhcGguaGVpZ2h0KS8yO31cbnJldHVybiB0aGlzLnJhZGl1czt9O3RoaXMuZXhwbG9kZVNlZ21lbnQ9dGhpcy5FeHBsb2RlPWZ1bmN0aW9uKGluZGV4LHNpemUpXG57aWYodHlwZW9mIHRoaXMuZXhwbG9kaW5nPT09J251bWJlcicmJnRoaXMuZXhwbG9kaW5nPT09aW5kZXgpe3JldHVybjt9XG5pZighcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSl7cHJvcFsnY2hhcnQuZXhwbG9kZWQnXT1bXTt9XG5pZih0eXBlb2YocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk9PSdudW1iZXInKXt2YXIgb3JpZ2luYWxfZXhwbG9kZT1wcm9wWydjaGFydC5leHBsb2RlZCddO3ZhciBleHBsb2RlZD1wcm9wWydjaGFydC5leHBsb2RlZCddO3Byb3BbJ2NoYXJ0LmV4cGxvZGVkJ109W107Zm9yKHZhciBpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTxsZW47KytpKXtwcm9wWydjaGFydC5leHBsb2RlZCddW2ldPWV4cGxvZGVkO319XG5wcm9wWydjaGFydC5leHBsb2RlZCddW2luZGV4XT10eXBlb2Yob3JpZ2luYWxfZXhwbG9kZSk9PSdudW1iZXInP29yaWdpbmFsX2V4cGxvZGU6MDt0aGlzLmV4cGxvZGluZz1pbmRleDt2YXIgZGVsYXk9UkcuSVNJRSYmIVJHLklTSUUxMD8yNToxNi42NjY7Zm9yKHZhciBvPTA7bzxzaXplOysrbyl7c2V0VGltZW91dChmdW5jdGlvbigpXG57cHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpbmRleF0rPTE7UkcuQ2xlYXIoY2EpO1JHLlJlZHJhd0NhbnZhcyhjYSk7fSxvKmRlbGF5KTt9XG52YXIgb2JqPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpXG57b2JqLmV4cGxvZGluZz1udWxsO30sc2l6ZSpkZWxheSk7fTt0aGlzLmhpZ2hsaWdodF9zZWdtZW50PWZ1bmN0aW9uKHNlZ21lbnQpXG57Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmZpbGwnXTtjby5tb3ZlVG8oc2VnbWVudFswXSxzZWdtZW50WzFdKTtjby5hcmMoc2VnbWVudFswXSxzZWdtZW50WzFdLHNlZ21lbnRbMl0sdGhpcy5hbmdsZXNbc2VnbWVudFs1XV1bMF0sdGhpcy5hbmdsZXNbc2VnbWVudFs1XV1bMV0sMCk7Y28ubGluZVRvKHNlZ21lbnRbMF0sc2VnbWVudFsxXSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNlIGlmKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT0nM2QnKXtjby5saW5lV2lkdGg9MTt2YXIgZXh0ZW50PTI7Y28uYmVnaW5QYXRoKCk7UkcuTm9TaGFkb3codGhpcyk7Y28uZmlsbFN0eWxlPSdyZ2JhKDAsMCwwLDApJztjby5hcmMoc2hhcGVbJ3gnXSxzaGFwZVsneSddLHNoYXBlWydyYWRpdXMnXSxzaGFwZVsnYW5nbGUuc3RhcnQnXSxzaGFwZVsnYW5nbGUuZW5kJ10sZmFsc2UpO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09J2RvbnV0Jyl7Y28uYXJjKHNoYXBlWyd4J10sc2hhcGVbJ3knXSxzaGFwZVsncmFkaXVzJ10vNSxzaGFwZVsnYW5nbGUuZW5kJ10sc2hhcGVbJ2FuZ2xlLnN0YXJ0J10sdHJ1ZSk7fWVsc2V7Y28ubGluZVRvKHNoYXBlWyd4J10sc2hhcGVbJ3knXSk7fVxuY28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLnNoYWRvd0NvbG9yPScjNjY2Jztjby5zaGFkb3dCbHVyPTM7Y28uc2hhZG93T2Zmc2V0WD0zO2NvLnNoYWRvd09mZnNldFk9Mztjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bc2hhcGVbJ2luZGV4J11dO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uYXJjKHNoYXBlWyd4J10tZXh0ZW50LHNoYXBlWyd5J10tZXh0ZW50LHNoYXBlWydyYWRpdXMnXSxzaGFwZVsnYW5nbGUuc3RhcnQnXSxzaGFwZVsnYW5nbGUuZW5kJ10sZmFsc2UpO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09J2RvbnV0Jyl7Y28uYXJjKHNoYXBlWyd4J10tZXh0ZW50LHNoYXBlWyd5J10tZXh0ZW50LHNoYXBlWydyYWRpdXMnXS8yLHNoYXBlWydhbmdsZS5lbmQnXSxzaGFwZVsnYW5nbGUuc3RhcnQnXSx0cnVlKX1lbHNle2NvLmxpbmVUbyhzaGFwZVsneCddLWV4dGVudCxzaGFwZVsneSddLWV4dGVudCk7fVxuY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmJvcmRlciddKXtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5ib3JkZXIuY29sb3InXTtjby5saW5lV2lkdGg9NTtjby5hcmMoc2hhcGVbJ3gnXS1leHRlbnQsc2hhcGVbJ3knXS1leHRlbnQsc2hhcGVbJ3JhZGl1cyddLTIsc2hhcGVbJ2FuZ2xlLnN0YXJ0J10sc2hhcGVbJ2FuZ2xlLmVuZCddLGZhbHNlKTtjby5zdHJva2UoKTt9fWVsc2UgaWYocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nb3V0bGluZScpe3ZhciB0b29sdGlwPVJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQudG9vbHRpcCcpLGluZGV4PXRvb2x0aXAuX19pbmRleF9fLGNvb3Jkcz10aGlzLmFuZ2xlc1tpbmRleF0sY29sb3I9dGhpcy5nZXQoJ2NvbG9ycycpW2luZGV4XVxud2lkdGg9dGhpcy5yYWRpdXMvMTIuNTtpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLm91dGxpbmUud2lkdGgnXT09PSdudW1iZXInKXt3aWR0aD1wcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUub3V0bGluZS53aWR0aCddO31cblJHcmFwaC5wYXRoMihjbywnZ2EgMC4yNSBiIGEgJSAlICUgJSAlIGZhbHNlIGEgJSAlICUgJSAlIHRydWUgYyBmICUgZ2EgMScsY29vcmRzWzJdLGNvb3Jkc1szXSx0aGlzLnJhZGl1cysyK3dpZHRoLGNvb3Jkc1swXSxjb29yZHNbMV0sY29vcmRzWzJdLGNvb3Jkc1szXSx0aGlzLnJhZGl1cysyLGNvb3Jkc1sxXSxjb29yZHNbMF0sY29sb3IpO31lbHNle2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLnN0cm9rZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJ107aWYocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJ2RvbnV0Jyk+LTEpe2NvLmFyYyhzaGFwZVsneCddLHNoYXBlWyd5J10sc2hhcGVbJ3JhZGl1cyddLHNoYXBlWydhbmdsZS5zdGFydCddLHNoYXBlWydhbmdsZS5lbmQnXSxmYWxzZSk7Y28uYXJjKHNoYXBlWyd4J10sc2hhcGVbJ3knXSx0eXBlb2YocHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddKT09J251bWJlcic/dGhpcy5yYWRpdXMtcHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddOnNoYXBlWydyYWRpdXMnXS8yLHNoYXBlWydhbmdsZS5lbmQnXSxzaGFwZVsnYW5nbGUuc3RhcnQnXSx0cnVlKTt9ZWxzZXtjby5hcmMoc2hhcGVbJ3gnXSxzaGFwZVsneSddLHNoYXBlWydyYWRpdXMnXSsxLHNoYXBlWydhbmdsZS5zdGFydCddLHNoYXBlWydhbmdsZS5lbmQnXSxmYWxzZSk7Y28ubGluZVRvKHNoYXBlWyd4J10sc2hhcGVbJ3knXSk7fVxuY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO319fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbntpZih0aGlzLmdldFNoYXBlKGUpKXtyZXR1cm4gdGhpczt9fTt0aGlzLmRyYXdDZW50ZXJwaW49dGhpcy5EcmF3Q2VudGVycGluPWZ1bmN0aW9uKClcbntpZih0eXBlb2YocHJvcFsnY2hhcnQuY2VudGVycGluJ10pPT0nbnVtYmVyJyYmcHJvcFsnY2hhcnQuY2VudGVycGluJ10+MCl7dmFyIGN4PXRoaXMuY2VudGVyeDt2YXIgY3k9dGhpcy5jZW50ZXJ5O2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5zdHJva2UnXT9wcm9wWydjaGFydC5jZW50ZXJwaW4uc3Ryb2tlJ106cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY2VudGVycGluLmZpbGwnXT9wcm9wWydjaGFydC5jZW50ZXJwaW4uZmlsbCddOnByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28ubW92ZVRvKGN4LGN5KTtjby5hcmMoY3gsY3kscHJvcFsnY2hhcnQuY2VudGVycGluJ10sMCxSRy5UV09QSSxmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO319O3RoaXMuZHJhd0luR3JhcGhMYWJlbHM9dGhpcy5EcmF3SW5HcmFwaExhYmVscz1mdW5jdGlvbigpXG57dmFyIGNvbnRleHQ9Y287dmFyIGN4PXRoaXMuY2VudGVyeDt2YXIgY3k9dGhpcy5jZW50ZXJ5O3ZhciByYWRpdXM9cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGgucmFkaXVzJ107aWYocmFkaXVzPD0yJiZyYWRpdXM+MCl7cmFkaXVzRmFjdG9yPXJhZGl1czt9ZWxzZXtyYWRpdXNGYWN0b3I9MC41O31cbmlmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXT09J2RvbnV0Jyl7dmFyIHI9dGhpcy5yYWRpdXMqKDAuNSsocmFkaXVzRmFjdG9yKjAuNSkpO2lmKHR5cGVvZihwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10pPT0nbnVtYmVyJyl7dmFyIHI9KHRoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSkrKHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXS8yKTt9fWVsc2V7dmFyIHI9dGhpcy5yYWRpdXMqcmFkaXVzRmFjdG9yO31cbmlmKHJhZGl1cz4yKXtyPXJhZGl1czt9XG5mb3IodmFyIGk9MCxsZW49dGhpcy5hbmdsZXMubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pPT0nb2JqZWN0JyYmdHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV0pPT0nbnVtYmVyJyl7dmFyIGV4cGxvc2lvbj1wcm9wWydjaGFydC5leHBsb2RlZCddW2ldO31lbHNlIGlmKHR5cGVvZihwcm9wWydjaGFydC5leHBsb2RlZCddKT09J251bWJlcicpe3ZhciBleHBsb3Npb249cGFyc2VJbnQocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk7fWVsc2V7dmFyIGV4cGxvc2lvbj0wO31cbnZhciBhbmdsZVN0YXJ0PXRoaXMuYW5nbGVzW2ldWzBdO3ZhciBhbmdsZUVuZD10aGlzLmFuZ2xlc1tpXVsxXTt2YXIgYW5nbGVDZW50ZXI9KChhbmdsZUVuZC1hbmdsZVN0YXJ0KS8yKSthbmdsZVN0YXJ0O3ZhciBjb29yZHM9UkcuZ2V0UmFkaXVzRW5kUG9pbnQodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxhbmdsZUNlbnRlcixyKyhleHBsb3Npb24/ZXhwbG9zaW9uOjApKTt2YXIgeD1jb29yZHNbMF07dmFyIHk9Y29vcmRzWzFdO3ZhciB0ZXh0PXByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnNwZWNpZmljJ10mJnR5cGVvZihwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5zcGVjaWZpYyddW2ldKT09J3N0cmluZyc/cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguc3BlY2lmaWMnXVtpXTpSRy5udW1iZXJfZm9ybWF0KHRoaXMsdGhpcy5kYXRhW2ldLHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnByZSddLHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnBvc3QnXSk7aWYodGV4dCl7Y28uYmVnaW5QYXRoKCk7dmFyIGZvbnQ9dHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmZvbnQnXT09PSdzdHJpbmcnP3Byb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmZvbnQnXTpwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZT10eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguc2l6ZSddPT09J251bWJlcic/cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguc2l6ZSddOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKzI7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJ10/cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguY29sb3InXTonYmxhY2snO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp4LCd5Jzp5LCd0ZXh0Jzp0ZXh0LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguYm91bmRpbmcnXSwnYm91bmRpbmcuZmlsbCc6cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguYm91bmRpbmcuZmlsbCddLCd0YWcnOidsYWJlbHMuaW5ncmFwaCd9KTtjby5zdHJva2UoKTt9fX07dGhpcy5kcmF3Q2VudGVyTGFiZWw9ZnVuY3Rpb24obGFiZWwpXG57dmFyIGZvbnQ9cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5mb250J10sc2l6ZT1wcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLnNpemUnXSxjb2xvcj1wcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJ10sdW5pdHNQcmU9cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wcmUnXSx1bml0c1Bvc3Q9cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wb3N0J10sYm9sZD1wcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmJvbGQnXSxpdGFsaWM9cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnXTtSRy50ZXh0Mih0aGlzLHtjb2xvcjpjb2xvcixib2xkOmJvbGQsaXRhbGljOml0YWxpYyxmb250OmZvbnQsc2l6ZTpzaXplLHg6dGhpcy5jZW50ZXJ4LHk6dGhpcy5jZW50ZXJ5LGhhbGlnbjonY2VudGVyJyx2YWxpZ246J2NlbnRlcicsdGV4dDpSRy5udW1iZXJGb3JtYXQodGhpcyxsYWJlbCx1bml0c1ByZSx1bml0c1Bvc3QpfSk7fVxudGhpcy5nZXRBbmdsZT1mdW5jdGlvbih2YWx1ZSlcbntpZih2YWx1ZT50aGlzLnRvdGFsKXtyZXR1cm4gbnVsbDt9XG52YXIgYW5nbGU9KHZhbHVlL3RoaXMudG90YWwpKlJHLlRXT1BJO2FuZ2xlKz1wcm9wWydjaGFydC5vcmlnaW4nXTtyZXR1cm4gYW5nbGU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmtleS5jb2xvcnMnXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmluZ3JhcGguYm91bmRpbmcuZmlsbCddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaW5ncmFwaC5ib3VuZGluZy5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5pbmdyYXBoLmNvbG9yJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5pbmdyYXBoLmNvbG9yJ10pO31cbmZvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQuY29sb3JzJ10ubGVuZ3RoOysraSl7cHJvcFsnY2hhcnQuY29sb3JzJ11baV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11baV0pO31cbnZhciBrZXlDb2xvcnM9cHJvcFsnY2hhcnQua2V5LmNvbG9ycyddO2lmKGtleUNvbG9ycyl7Zm9yKHZhciBpPTA7aTxrZXlDb2xvcnMubGVuZ3RoOysraSl7a2V5Q29sb3JzW2ldPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGtleUNvbG9yc1tpXSk7fX1cbnByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmZpbGwnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmJvdW5kaW5nLmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5ib3VuZGluZy5maWxsJ10pO3Byb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguY29sb3InXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mKGNvbG9yKSE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTtpZihwcm9wWydjaGFydC52YXJpYW50J109PSdkb251dCcpe3ZhciByYWRpdXNfc3RhcnQ9dHlwZW9mKHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSk9PSdudW1iZXInP3RoaXMucmFkaXVzLXByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXTp0aGlzLnJhZGl1cy8yO31lbHNle3ZhciByYWRpdXNfc3RhcnQ9MDt9XG52YXIgZ3JhZD1jby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHJhZGl1c19zdGFydCx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LE1hdGgubWluKGNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10tcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXS1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pLzIpO3ZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0PWZ1bmN0aW9uKGluZGV4KVxue2lmKHRoaXMuYW5nbGVzJiZ0aGlzLmFuZ2xlc1tpbmRleF0pe3ZhciBzZWdtZW50PXRoaXMuYW5nbGVzW2luZGV4XTt2YXIgeD1zZWdtZW50WzJdO3ZhciB5PXNlZ21lbnRbM107dmFyIHN0YXJ0PXNlZ21lbnRbMF07dmFyIGVuZD1zZWdtZW50WzFdO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCddO2NvLmxpbmVXaWR0aD0yO2NvLmxpbmVKb2luPSdiZXZlbCc7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgseSk7Y28uYXJjKHgseSx0aGlzLnJhZGl1cyxzdGFydCxlbmQsZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTt9fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307dGhpcy5kcmF3M2Q9ZnVuY3Rpb24oKVxue3ZhciBzY2FsZVg9MS41LGRlcHRoPXByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmRlcHRoJ10scHJvcF9zaGFkb3c9cHJvcFsnY2hhcnQuc2hhZG93J10scHJvcF9sYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ10scHJvcF9sYWJlbHNTdGlja3M9cHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddXG50aGlzLnNldCh7bGFiZWxzOltdLGxhYmVsc1N0aWNrczpmYWxzZSxzdHJva2VzdHlsZToncmdiYSgwLDAsMCwwKSd9KTt0aGlzLnNldCh7dmFyaWFudDp0aGlzLmdldCgndmFyaWFudCcpLnJlcGxhY2UoLzNkLywnJyl9KTt0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKHNjYWxlWCwwLDAsMSwoY2Eud2lkdGgqKHNjYWxlWCktY2Eud2lkdGgpKiAtMC41LDApO2Zvcih2YXIgaT1kZXB0aDtpPjA7aS09MSl7dGhpcy5zZXQoe2NlbnRlcnlBZGp1c3Q6aX0pO2lmKGk9PT1wYXJzZUludChkZXB0aC8yKSl7dGhpcy5zZXQoe2xhYmVsczpwcm9wX2xhYmVscyxsYWJlbHNTdGlja3M6cHJvcF9sYWJlbHNTdGlja3N9KTt9XG5pZihpPT09MCl7dGhpcy5zZXQoe3NoYWRvdzpwcm9wX3NoYWRvd30pO31cbnRoaXMuZHJhdygpO3RoaXMuc2V0KCdzaGFkb3cnLGZhbHNlKTtpZihpPD1wYXJzZUludChkZXB0aC8yKSl7dGhpcy5zZXQoe2xhYmVsczpbXSxsYWJlbHNTdGlja3M6ZmFsc2V9KTt9XG5pZihpPjEpe2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCdkb251dCcpIT09LTEpe2Zvcih2YXIgaj0wO2o8dGhpcy5hbmdsZXMubGVuZ3RoOysrail7cGEyKGNvLFsnYicsJ2EnLHRoaXMuYW5nbGVzW2pdWzJdLHRoaXMuYW5nbGVzW2pdWzNdLHRoaXMucmFkaXVzKzEsdGhpcy5hbmdsZXNbal1bMF0sdGhpcy5hbmdsZXNbal1bMV0qcHJvcFsnY2hhcnQuZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllciddLGZhbHNlLCdhJyx0aGlzLmFuZ2xlc1tqXVsyXSx0aGlzLmFuZ2xlc1tqXVszXSx0aGlzLnJhZGl1cy8yLHRoaXMuYW5nbGVzW2pdWzFdKnByb3BbJ2NoYXJ0LmVmZmVjdC5yb3VuZHJvYmluLm11bHRpcGxpZXInXSx0aGlzLmFuZ2xlc1tqXVswXSx0cnVlLCdmJywncmdiYSgwLDAsMCwwLjE1KSddKTt9fWVsc2V7Zm9yKHZhciBqPTA7ajx0aGlzLmFuZ2xlcy5sZW5ndGg7KytqKXtwYTIoY28sWydiJywnbScsdGhpcy5hbmdsZXNbal1bMl0sdGhpcy5hbmdsZXNbal1bM10sJ2EnLHRoaXMuYW5nbGVzW2pdWzJdLHRoaXMuYW5nbGVzW2pdWzNdLHRoaXMucmFkaXVzKzEsdGhpcy5hbmdsZXNbal1bMF0sdGhpcy5hbmdsZXNbal1bMV0qcHJvcFsnY2hhcnQuZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllciddLGZhbHNlLCdjJywnZicsJ3JnYmEoMCwwLDAsMC4xNSknXSk7fX19fVxudGhpcy5zZXQoe3ZhcmlhbnQ6dGhpcy5nZXQoJ3ZhcmlhbnQnKSsnM2QnLHNoYWRvdzpwcm9wX3NoYWRvdyxsYWJlbHM6cHJvcF9sYWJlbHMsbGFiZWxzU3RpY2tzOnByb3BfbGFiZWxzU3RpY2tzfSk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4cGxvZGU9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZnVuY3Rpb24oKXt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lcz9vcHQuZnJhbWVzOjMwO3ZhciBmcmFtZT0wO3ZhciBtYXhFeHBsb2RlPU51bWJlcih0eXBlb2Ygb3B0LnJhZGl1cz09PSdudW1iZXInP29wdC5yYWRpdXM6bWEubWF4KGNhLndpZHRoLGNhLmhlaWdodCkpO3ZhciBjdXJyZW50RXhwbG9kZT1OdW1iZXIob2JqLmdldCgnZXhwbG9kZWQnKSl8fDA7dmFyIHN0ZXA9KG1heEV4cGxvZGUtY3VycmVudEV4cGxvZGUpL2ZyYW1lczt2YXIgaXRlcmF0b3I9ZnVuY3Rpb24oKVxue29iai5zZXQoJ2V4cGxvZGVkJyxjdXJyZW50RXhwbG9kZSsoc3RlcCpmcmFtZSkpO1JHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lKys8ZnJhbWVzKXtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgY2FudmFzPW9iai5jYW52YXM7dmFyIG9wdD1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZnVuY3Rpb24oKXt9O3ZhciByYWRpdXM9b2JqLmdldFJhZGl1cygpO3Byb3BbJ2NoYXJ0LnJhZGl1cyddPTA7dmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbntvYmouc2V0KCdjaGFydC5yYWRpdXMnLChmcmFtZS9mcmFtZXMpKnJhZGl1cyk7UkcucmVkcmF3Q2FudmFzKGNhKTtpZihmcmFtZSsrPGZyYW1lcyl7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtjYWxsYmFjayhvYmopO319O2l0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLnJvdW5kcm9iaW49dGhpcy5yb3VuZFJvYmluPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe30sZnJhbWU9MCxmcmFtZXM9b3B0LmZyYW1lc3x8MzAscmFkaXVzPW9iai5nZXRSYWRpdXMoKSxsYWJlbHM9b2JqLmdldCgnbGFiZWxzJylcbm9iai5TZXQoJ2NoYXJ0LmV2ZW50cycsZmFsc2UpO29iai5TZXQoJ2NoYXJ0LmxhYmVscycsW10pO3ZhciBpdGVyYXRvcj1mdW5jdGlvbigpXG57b2JqLnNldCgnZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllcicsUkcuRWZmZWN0cy5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcyxmcmFtZSkpO1JHcmFwaC5yZWRyYXdDYW52YXMoY2EpO2lmKGZyYW1lKys8ZnJhbWVzKXtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle29iai5zZXQoe2V2ZW50czp0cnVlLGxhYmVsczpsYWJlbHN9KTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Y2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuYXR0KGNhKTt0aGlzLmltcGxvZGU9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxmcmFtZXM9b3B0LmZyYW1lc3x8MzAsZnJhbWU9MCxleHBsb2RlZE1heD1tYS5tYXgoY2Eud2lkdGgsY2EuaGVpZ2h0KSxleHBsb2RlZD1leHBsb2RlZE1heDtmdW5jdGlvbiBpdGVyYXRvcigpXG57ZXhwbG9kZWQ9ZXhwbG9kZWRNYXgtKChmcmFtZS9mcmFtZXMpKmV4cGxvZGVkTWF4KTtvYmouU2V0KCdleHBsb2RlZCcsZXhwbG9kZWQpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmKGZyYW1lKys8ZnJhbWVzKXtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5waWUuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///228\n");

/***/ }),
/* 229 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Radar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;if (typeof conf.data[0] === 'number' || typeof conf.data[0] === 'string') {\n      conf.data = [conf.data];\n    }\n  } else {\n    var conf = { id: conf, data: [] };if (_typeof(arguments[1]) === 'object' && typeof arguments[1][0] === 'number') {\n      for (var i = 1; i < arguments.length; ++i) {\n        conf.data.push(RGraph.arrayClone(arguments[i]));\n      }\n    } else if (_typeof(arguments[1]) === 'object' && _typeof(arguments[1][0]) === 'object' && typeof arguments[1][0][0] === 'number') {\n      conf.data = RGraph.arrayClone(arguments[1]);\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(conf.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'radar';this.isRGraph = true;this.data = [];this.max = 0;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coordsText = [];this.original_data = [];this.original_colors = [];this.firstDraw = true;for (var i = 0, len = conf.data.length; i < len; ++i) {\n    for (var j = 0; j < conf.data[i].length; ++j) {\n      if (typeof conf.data[i][j] === 'string') {\n        conf.data[i][j] = parseFloat(conf.data[i][j]);\n      }\n    }\n    this.original_data.push(RGraph.arrayClone(conf.data[i]));this.data.push(RGraph.arrayClone(conf.data[i]));this.max = Math.max(this.max, RGraph.arrayMax(conf.data[i]));\n  }\n  this.properties = (_properties = { 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.linewidth': 1, 'chart.colors': ['rgba(255,255,0,0.25)', 'rgba(0,255,255,0.25)', 'rgba(255,0,0,0.5)', 'red', 'green', 'blue', 'pink', 'aqua', 'brown', 'orange', 'grey'], 'chart.colors.alpha': null, 'chart.circle': 0, 'chart.circle.fill': 'red', 'chart.circle.stroke': 'black', 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.offset': 10, 'chart.labels.axes': '', 'chart.labels.background.fill': 'white', 'chart.labels.boxed': false, 'chart.labels.axes.bold': [], 'chart.labels.axes.boxed': null, 'chart.labels.axes.boxed.zero': true, 'chart.labels.axes.boxed.background': 'rgba(255,255,255,0.9)', 'chart.labels.specific': [], 'chart.labels.count': 5, 'chart.background.circles': true, 'chart.background.circles.count': null, 'chart.background.circles.color': '#ddd', 'chart.background.circles.poly': true, 'chart.background.circles.spokes': 24, 'chart.text.size': 12, 'chart.text.size.scale': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null }, _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.linewidth', 1), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'rgba(255,0,0,0.3)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.highlight.stroke', 'gray'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.highlight.point.radius', 2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.ymax', null), _defineProperty(_properties, 'chart.accumulative', false), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.numxticks', 5), _defineProperty(_properties, 'chart.numyticks', 5), _defineProperty(_properties, 'chart.axes.color', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlights', false), _defineProperty(_properties, 'chart.highlights.stroke', '#ddd'), _defineProperty(_properties, 'chart.highlights.fill', null), _defineProperty(_properties, 'chart.highlights.radius', 3), _defineProperty(_properties, 'chart.fill.click', null), _defineProperty(_properties, 'chart.fill.mousemove', null), _defineProperty(_properties, 'chart.fill.tooltips', null), _defineProperty(_properties, 'chart.fill.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.fill.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.fill.mousemove.redraw', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    if (this.data[dataset].length < 3) {\n      alert('[RADAR] You must specify at least 3 data points');return;\n    }\n  }\n  var idx = 0;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    for (var i = 0, len = this.data[dataset].length; i < len; ++i) {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    if (name == 'chart.color') {\n      this.properties['chart.colors'] = [value];\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coords = [];this.coords2 = [];this.coordsText = [];this.data = RG.arrayClone(this.original_data);if (prop['chart.accumulative']) {\n      for (var i = 0; i < this.data.length; ++i) {\n        if (this.data[i].length != this.data[0].length) {\n          alert('[RADAR] Error! When the radar has chart.accumulative set to true all the datasets must have the same number of elements');\n        }\n      }\n    }\n    if (RG.isNull(prop['chart.labels.axes.boxed'])) {\n      prop['chart.labels.axes.boxed'] = [];for (var i = 0; i < (prop['chart.labels.specific'].length || prop['chart.labels.count'] || 5); ++i) {\n        prop['chart.labels.axes.boxed'][i] = false;\n      }\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;if (typeof prop['chart.centerx'] == 'number') this.centerx = 2 * prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = 2 * prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (!prop['chart.ymax']) {\n      if (prop['chart.accumulative']) {\n        var accumulation = [];var len = this.original_data[0].length;\n        for (var i = 1; i < this.original_data.length; ++i) {\n          if (this.original_data[i].length != len) {\n            alert('[RADAR] Error! Stacked Radar chart datasets must all be the same size!');\n          }\n          for (var j = 0; j < this.original_data[i].length; ++j) {\n            this.data[i][j] += this.data[i - 1][j];this.max = Math.max(this.max, this.data[i][j]);\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, 'min': 0, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'min': 0, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    this.drawBackground();this.drawAxes();this.drawCircle();this.drawLabels();co.save();co.beginPath();co.arc(this.centerx, this.centery, this.radius * 2, -RG.HALFPI, RG.TWOPI * prop['chart.animation.trace.clip'] - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.clip();this.DrawChart();this.DrawHighlights();co.restore();this.drawAxisLabels();if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.diameter'] ? prop['chart.title.diameter'] : null);\n    }\n    if (prop['chart.key']) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if ((prop['chart.fill.click'] || prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) && !this.__fill_click_listeners_installed__) {\n      this.AddFillListeners();this.__fill_click_listeners_installed__ = true;\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    var color = prop['chart.background.circles.color'];var poly = prop['chart.background.circles.poly'];var spacing = prop['chart.background.circles.spacing'];var spokes = prop['chart.background.circles.spokes'];co.lineWidth = 1;if (prop['chart.background.circles'] && poly == false) {\n      co.strokeStyle = color;co.beginPath();var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.strokeStyle = color;for (var i = 0; i < 360; i += 360 / spokes) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI, (i + 0.001) / 360 * RG.TWOPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n    } else if (prop['chart.background.circles'] && poly == true) {\n      co.strokeStyle = color;var increment = 360 / this.data[0].length;\n      for (var i = 0; i < 360; i += increment) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI - RG.HALFPI, (i + 0.001) / 360 * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n      co.strokeStyle = color;var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.beginPath();for (var a = 0; a <= 360; a += 360 / this.data[0].length) {\n          co.arc(this.centerx, this.centery, r, RG.degrees2Radians(a) - RG.HALFPI, RG.degrees2Radians(a) + 0.001 - RG.HALFPI, false);\n        }\n        co.closePath();co.stroke();\n      }\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.strokeStyle = prop['chart.axes.color'];var halfsize = this.radius;co.beginPath();co.moveTo(Math.round(this.centerx), this.centery + this.radius);co.lineTo(Math.round(this.centerx), this.centery - this.radius);co.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));co.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));for (var y = this.centery - this.radius; y < this.centery + this.radius; y += this.radius / prop['chart.numyticks']) {\n      co.moveTo(this.centerx - 3, Math.round(y));co.lineTo(this.centerx + 3, Math.round(y));\n    }\n    co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));co.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);co.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);for (var x = this.centerx - this.radius; x < this.centerx + this.radius; x += this.radius / prop['chart.numxticks']) {\n      co.moveTo(Math.round(x), this.centery - 3);co.lineTo(Math.round(x), this.centery + 3);\n    }\n    co.stroke();\n  };this.drawChart = this.DrawChart = function () {\n    var alpha = prop['chart.colors.alpha'];if (typeof alpha == 'number') {\n      var oldAlpha = co.globalAlpha;co.globalAlpha = alpha;\n    }\n    var numDatasets = this.data.length;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n      co.beginPath();var coords_dataset = [];for (var i = 0; i < this.data[dataset].length; ++i) {\n        var coords = this.GetCoordinates(dataset, i);if (coords_dataset == null) {\n          coords_dataset = [];\n        }\n        coords_dataset.push(coords);this.coords.push(coords);\n      }\n      this.coords2[dataset] = coords_dataset;co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][dataset] ? prop['chart.colors'][dataset] : 'rgba(0,0,0,0)';if (co.fillStyle === 'transparent') {\n        co.fillStyle = 'rgba(0,0,0,0)';\n      }\n      co.lineWidth = prop['chart.linewidth'];for (i = 0; i < coords_dataset.length; ++i) {\n        if (i == 0) {\n          co.moveTo(coords_dataset[i][0], coords_dataset[i][1]);\n        } else {\n          co.lineTo(coords_dataset[i][0], coords_dataset[i][1]);\n        }\n      }\n      if (prop['chart.accumulative'] && dataset > 0) {\n        co.lineTo(coords_dataset[0][0], coords_dataset[0][1]);co.moveTo(last_coords[0][0], last_coords[0][1]);for (var i = coords_dataset.length - 1; i >= 0; --i) {\n          co.lineTo(last_coords[i][0], last_coords[i][1]);\n        }\n      }\n      var last_coords = coords_dataset;co.closePath();co.stroke();co.fill();\n    }\n    if (typeof alpha == 'number') {\n      co.globalAlpha = oldAlpha;\n    }\n  };this.getCoordinates = this.GetCoordinates = function (dataset, index) {\n    var len = this.data[dataset].length;var mag = this.data[dataset][index] / this.max * this.radius;var angle = RG.TWOPI / len * index;angle -= RG.HALFPI;var x = Math.cos(angle) * mag;var y = Math.sin(angle) * mag;x = this.centerx + x;y = this.centery + y;return [x, y];\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];if (labels && labels.length > 0) {\n      co.lineWidth = 1;co.strokeStyle = 'gray';co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var bgFill = prop['chart.labels.background.fill'],\n          bold = prop['chart.labels.bold'],\n          bgBoxed = prop['chart.labels.boxed'],\n          offset = prop['chart.labels.offset'],\n          font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          radius = this.radius,\n          color = prop['chart.labels.color'] || prop['chart.text.color'];\n      for (var i = 0; i < labels.length; ++i) {\n        var angle = RG.TWOPI / prop['chart.labels'].length * i;angle -= RG.HALFPI;var x = this.centerx + ma.cos(angle) * (radius + offset);var y = this.centery + ma.sin(angle) * (radius + offset);var halign = x < this.centerx ? 'right' : 'left';if (i == 0 || i / labels.length == 0.5) halign = 'center';if (labels[i] && labels[i].length) {\n          RG.text2(this, { 'color': color, 'font': font, 'size': size, 'x': x, 'y': y, 'text': labels[i], 'valign': 'center', 'halign': halign, 'bounding': bgBoxed, 'boundingFill': bgFill, 'bold': bold, 'tag': 'labels' });\n        }\n      }\n    }\n  };this.drawCircle = this.DrawCircle = function () {\n    var circle = {};circle.limit = prop['chart.circle'];circle.fill = prop['chart.circle.fill'];circle.stroke = prop['chart.circle.stroke'];if (circle.limit) {\n      var r = circle.limit / this.max * this.radius;co.fillStyle = circle.fill;co.strokeStyle = circle.stroke;co.beginPath();co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();co.stroke();\n    }\n  };this.drawAxisLabels = this.DrawAxisLabels = function () {\n    if (RG.isArray(prop['chart.labels.specific']) && prop['chart.labels.specific'].length) {\n      this.drawSpecificAxisLabels();return;\n    }\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var r = this.radius,\n        font = prop['chart.text.font'],\n        size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        color = prop['chart.labels.axes.boxed.background'],\n        drawzero = false,\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        bold = prop['chart.labels.axes.bold'],\n        boxed = prop['chart.labels.axes.boxed'],\n        centerx = this.centerx,\n        centery = this.centery,\n        scale = this.scale;co.fillStyle = prop['chart.text.color'];if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery - r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery + r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (drawzero) {\n      RG.Text2(this, { font: font, size: size, x: centerx, y: centery, text: RG.numberFormat(this, Number(0).toFixed(), units_pre, units_post), valign: 'center', halign: 'center', bounding: prop['chart.labels.axes.boxed.zero'], boundingFill: color, boundingStroke: 'rgba(0,0,0,0)', bold: prop['chart.labels.axes.bold.zero'], tag: 'scale' });\n    }\n  };this.drawSpecificAxisLabels = this.DrawSpecificAxisLabels = function () {\n    var labels = prop['chart.labels.specific'];var bold = RG.array_pad(prop['chart.labels.axes.bold'], labels.length);var boxed = RG.array_pad(prop['chart.labels.axes.boxed'], labels.length);var reversed_labels = RG.array_reverse(labels);var reversed_bold = RG.array_reverse(bold);var reversed_boxed = RG.array_reverse(boxed);var font = prop['chart.text.font'];var size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n      if (axes.indexOf('n') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery - this.radius + this.radius / labels.length * i, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('s') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery + this.radius / labels.length * (i + 1), 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });if (axes.indexOf('w') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx - this.radius + this.radius / labels.length * i, 'y': this.centery, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('e') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx + this.radius / labels.length * (i + 1), 'y': this.centery, 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });\n    }\n  };this.getShape = this.getPoint = function (e) {\n    for (var i = 0; i < this.coords.length; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltips = prop['chart.tooltips'];var index = Number(i);var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX < x + 5 && mouseX > x - 5 && mouseY > y - 5 && mouseY < y + 5) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], index);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: null, 'dataset': null, 4: index, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius) {\n      return this;\n    }\n  };this.drawHighlights = this.DrawHighlights = function () {\n    if (prop['chart.highlights']) {\n      var sequentialIdx = 0;var dataset = 0;var index = 0;var radius = prop['chart.highlights.radius'];for (var dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var index = 0; index < this.data[dataset].length; ++index) {\n          co.beginPath();co.strokeStyle = prop['chart.highlights.stroke'];co.fillStyle = prop['chart.highlights.fill'] ? prop['chart.highlights.fill'] : _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.arc(this.coords[sequentialIdx][0], this.coords[sequentialIdx][1], radius, 0, RG.TWOPI, false);co.stroke();co.fill();++sequentialIdx;\n        }\n      }\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var radius = value / this.max * this.radius;return radius;\n  };this.getAngle = function (numitems, index) {\n    var angle = RG.TWOPI / numitems * index;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.circle.fill'] = RG.array_clone(prop['chart.circle.fill']);this.original_colors['chart.circle.stroke'] = RG.array_clone(prop['chart.circle.stroke']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (typeof keyColors != 'null' && keyColors && keyColors.length) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.circle.fill'] = this.parseSingleColorForGradient(prop['chart.circle.fill']);prop['chart.circle.stroke'] = this.parseSingleColorForGradient(prop['chart.circle.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.addFillListeners = this.AddFillListeners = function (e) {\n    var obj = this;var func = function func(e) {\n      var coords = this.coords;var coords2 = this.coords2;var mouseXY = RG.getMouseXY(e);var dataset = 0;if (e.type == 'mousemove' && prop['chart.fill.mousemove.redraw']) {\n        RG.RedrawCanvas(ca);\n      }\n      for (var dataset = obj.coords2.length - 1; dataset >= 0; --dataset) {\n        co.beginPath();co.moveTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);for (var j = 0; j < obj.coords2[dataset].length; ++j) {\n          co.lineTo(obj.coords2[dataset][j][0], obj.coords2[dataset][j][1]);\n        }\n        co.lineTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n          co.lineTo(obj.coords2[dataset - 1][0][0], obj.coords2[dataset - 1][0][1]);for (var j = obj.coords2[dataset - 1].length - 1; j >= 0; --j) {\n            co.lineTo(obj.coords2[dataset - 1][j][0], obj.coords2[dataset - 1][j][1]);\n          }\n        }\n        co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n          var inPath = true;break;\n        }\n      }\n      if (inPath) {\n        var fillTooltips = prop['chart.fill.tooltips'];if (e.type == 'click') {\n          if (prop['chart.fill.click']) {\n            prop['chart.fill.click'](e, dataset);\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            obj.DatasetTooltip(e, dataset);\n          }\n        }\n        if (e.type == 'mousemove') {\n          if (prop['chart.fill.mousemove']) {\n            prop['chart.fill.mousemove'](e, dataset);\n          }\n          if (!RG.is_null(fillTooltips)) {\n            e.target.style.cursor = 'pointer';\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            e.target.style.cursor = 'pointer';\n          }\n        }\n        e.stopPropagation();\n      } else if (e.type == 'mousemove') {\n        ca.style.cursor = 'default';\n      }\n    };if (prop['chart.fill.click'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('click', func, false);\n    }\n    if (prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('mousemove', func, false);\n    }\n  };this.highlightDataset = this.HighlightDataset = function (dataset) {\n    co.beginPath();for (var j = 0; j < this.coords2[dataset].length; ++j) {\n      if (j == 0) {\n        co.moveTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);\n      } else {\n        co.lineTo(this.coords2[dataset][j][0], this.coords2[dataset][j][1]);\n      }\n    }\n    co.lineTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n      co.lineTo(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]);for (var j = this.coords2[dataset - 1].length - 1; j >= 0; --j) {\n        co.lineTo(this.coords2[dataset - 1][j][0], this.coords2[dataset - 1][j][1]);\n      }\n    }\n    co.strokeStyle = prop['chart.fill.highlight.stroke'];co.fillStyle = prop['chart.fill.highlight.fill'];co.stroke();co.fill();\n  };this.datasetTooltip = this.DatasetTooltip = function (e, dataset) {\n    this.HighlightDataset(dataset);var text = prop['chart.fill.tooltips'][dataset];var x = 0;var y = this.coords2[dataset][0][1] + RG.getCanvasXY(ca)[1];RG.Tooltip(this, text, x, y, 0, e);\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (i == 0) {\n          co.moveTo(coords[i][0], coords[i][1]);\n        } else {\n          co.lineTo(coords[i][0], coords[i][1]);\n        }\n      }\n      co.closePath();co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var callback = arguments[1] ? arguments[1] : function () {};var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var data = RG.array_clone(obj.data);function iterator() {\n      for (var i = 0, len = data.length; i < len; ++i) {\n        for (var j = 0, len2 = data[i].length; j < len2; ++j) {\n          obj.original_data[i][j] = frame / frames * data[i][j];\n        }\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);var iterator = function iterator() {\n      if (frame < frames) {\n        obj.Set('animation.trace.clip', frame / frames);frame++;RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.Set('animation.trace.clip', 1);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucmFkYXIuanM/MmI1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlJhZGFyPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuZGF0YT09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO2lmKHR5cGVvZiBjb25mLmRhdGFbMF09PT0nbnVtYmVyJ3x8dHlwZW9mIGNvbmYuZGF0YVswXT09PSdzdHJpbmcnKXtjb25mLmRhdGE9W2NvbmYuZGF0YV07fX1lbHNle3ZhciBjb25mPXtpZDpjb25mLGRhdGE6W119O2lmKHR5cGVvZiBhcmd1bWVudHNbMV09PT0nb2JqZWN0JyYmdHlwZW9mIGFyZ3VtZW50c1sxXVswXT09PSdudW1iZXInKXtmb3IodmFyIGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXtjb25mLmRhdGEucHVzaChSR3JhcGguYXJyYXlDbG9uZShhcmd1bWVudHNbaV0pKTt9fWVsc2UgaWYodHlwZW9mIGFyZ3VtZW50c1sxXT09PSdvYmplY3QnJiZ0eXBlb2YgYXJndW1lbnRzWzFdWzBdPT09J29iamVjdCcmJnR5cGVvZiBhcmd1bWVudHNbMV1bMF1bMF09PT0nbnVtYmVyJyl7Y29uZi5kYXRhPVJHcmFwaC5hcnJheUNsb25lKGFyZ3VtZW50c1sxXSk7fX1cbnRoaXMuaWQ9Y29uZi5pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dD90aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy50eXBlPSdyYWRhcic7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMuZGF0YT1bXTt0aGlzLm1heD0wO3RoaXMudWlkPVJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQ9dGhpcy5jYW52YXMudWlkP3RoaXMuY2FudmFzLnVpZDpSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfZGF0YT1bXTt0aGlzLm9yaWdpbmFsX2NvbG9ycz1bXTt0aGlzLmZpcnN0RHJhdz10cnVlO2Zvcih2YXIgaT0wLGxlbj1jb25mLmRhdGEubGVuZ3RoO2k8bGVuOysraSl7Zm9yKHZhciBqPTA7ajxjb25mLmRhdGFbaV0ubGVuZ3RoOysrail7aWYodHlwZW9mIGNvbmYuZGF0YVtpXVtqXT09PSdzdHJpbmcnKXtjb25mLmRhdGFbaV1bal09cGFyc2VGbG9hdChjb25mLmRhdGFbaV1bal0pO319XG50aGlzLm9yaWdpbmFsX2RhdGEucHVzaChSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGFbaV0pKTt0aGlzLmRhdGEucHVzaChSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGFbaV0pKTt0aGlzLm1heD1NYXRoLm1heCh0aGlzLm1heCxSR3JhcGguYXJyYXlNYXgoY29uZi5kYXRhW2ldKSk7fVxudGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQuc3Ryb2tlc3R5bGUnOicjYWFhJywnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LmxpbmV3aWR0aCc6MSwnY2hhcnQuY29sb3JzJzpbJ3JnYmEoMjU1LDI1NSwwLDAuMjUpJywncmdiYSgwLDI1NSwyNTUsMC4yNSknLCdyZ2JhKDI1NSwwLDAsMC41KScsJ3JlZCcsJ2dyZWVuJywnYmx1ZScsJ3BpbmsnLCdhcXVhJywnYnJvd24nLCdvcmFuZ2UnLCdncmV5J10sJ2NoYXJ0LmNvbG9ycy5hbHBoYSc6bnVsbCwnY2hhcnQuY2lyY2xlJzowLCdjaGFydC5jaXJjbGUuZmlsbCc6J3JlZCcsJ2NoYXJ0LmNpcmNsZS5zdHJva2UnOidibGFjaycsJ2NoYXJ0LmxhYmVscyc6W10sJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLm9mZnNldCc6MTAsJ2NoYXJ0LmxhYmVscy5heGVzJzonJywnY2hhcnQubGFiZWxzLmJhY2tncm91bmQuZmlsbCc6J3doaXRlJywnY2hhcnQubGFiZWxzLmJveGVkJzpmYWxzZSwnY2hhcnQubGFiZWxzLmF4ZXMuYm9sZCc6W10sJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJzpudWxsLCdjaGFydC5sYWJlbHMuYXhlcy5ib3hlZC56ZXJvJzp0cnVlLCdjaGFydC5sYWJlbHMuYXhlcy5ib3hlZC5iYWNrZ3JvdW5kJzoncmdiYSgyNTUsMjU1LDI1NSwwLjkpJywnY2hhcnQubGFiZWxzLnNwZWNpZmljJzpbXSwnY2hhcnQubGFiZWxzLmNvdW50Jzo1LCdjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5jb3VudCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLmNvbG9yJzonI2RkZCcsJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5wb2x5Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuc3Bva2VzJzoyNCwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5zaXplLnNjYWxlJzpudWxsLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC50aXRsZS5ocG9zJzpudWxsLCdjaGFydC50aXRsZS52cG9zJzpudWxsLCdjaGFydC50aXRsZS5jb2xvcic6J2JsYWNrJywnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmxpbmV3aWR0aCc6MSwnY2hhcnQua2V5JzpudWxsLCdjaGFydC5rZXkuYmFja2dyb3VuZCc6J3doaXRlJywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uJzonZ3JhcGgnLCdjaGFydC5rZXkuaGFsaWduJzoncmlnaHQnLCdjaGFydC5rZXkucG9zaXRpb24uZ3V0dGVyLmJveGVkJzpmYWxzZSwnY2hhcnQua2V5LnBvc2l0aW9uLngnOm51bGwsJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzpudWxsLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkucm91bmRlZCc6dHJ1ZSwnY2hhcnQua2V5LmxpbmV3aWR0aCc6MSwnY2hhcnQua2V5LmNvbG9ycyc6bnVsbCwnY2hhcnQua2V5LmludGVyYWN0aXZlJzpmYWxzZSwnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOidyZ2JhKDI1NSwwLDAsMC4zKScsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOidyZ2JhKDI1NSwwLDAsMC4yKScsJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQuYW5ub3RhdGFibGUnOmZhbHNlLCdjaGFydC5hbm5vdGF0ZS5jb2xvcic6J2JsYWNrJywnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmhkaXInOidyaWdodCcsJ2NoYXJ0Lnpvb20udmRpcic6J2Rvd24nLCdjaGFydC56b29tLmZyYW1lcyc6MjUsJ2NoYXJ0Lnpvb20uZGVsYXknOjE2LjY2NiwnY2hhcnQuem9vbS5zaGFkb3cnOnRydWUsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQuem9vbS5hY3Rpb24nOid6b29tJywnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25tb3VzZW1vdmUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J2dyYXknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmhpZ2hsaWdodC5wb2ludC5yYWRpdXMnOjIsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC55bWF4JzpudWxsLCdjaGFydC5hY2N1bXVsYXRpdmUnOmZhbHNlLCdjaGFydC5yYWRpdXMnOm51bGwsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbm1vdXNlbW92ZScsJ2NoYXJ0LmNlbnRlcngnOm51bGwsJ2NoYXJ0LmNlbnRlcnknOm51bGwsJ2NoYXJ0LnJhZGl1cyc6bnVsbCwnY2hhcnQubnVteHRpY2tzJzo1LCdjaGFydC5udW15dGlja3MnOjUsJ2NoYXJ0LmF4ZXMuY29sb3InOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0cyc6ZmFsc2UsJ2NoYXJ0LmhpZ2hsaWdodHMuc3Ryb2tlJzonI2RkZCcsJ2NoYXJ0LmhpZ2hsaWdodHMuZmlsbCc6bnVsbCwnY2hhcnQuaGlnaGxpZ2h0cy5yYWRpdXMnOjMsJ2NoYXJ0LmZpbGwuY2xpY2snOm51bGwsJ2NoYXJ0LmZpbGwubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5maWxsLnRvb2x0aXBzJzpudWxsLCdjaGFydC5maWxsLmhpZ2hsaWdodC5maWxsJzoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywnY2hhcnQuZmlsbC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmZpbGwubW91c2Vtb3ZlLnJlZHJhdyc6ZmFsc2UsJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJzoxLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5mb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuZGF0YS5sZW5ndGg7KytkYXRhc2V0KXtpZih0aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoPDMpe2FsZXJ0KCdbUkFEQVJdIFlvdSBtdXN0IHNwZWNpZnkgYXQgbGVhc3QgMyBkYXRhIHBvaW50cycpO3JldHVybjt9fVxudmFyIGlkeD0wO2Zvcih2YXIgZGF0YXNldD0wO2RhdGFzZXQ8dGhpcy5kYXRhLmxlbmd0aDsrK2RhdGFzZXQpe2Zvcih2YXIgaT0wLGxlbj10aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoO2k8bGVuOysraSl7dGhpc1snJCcrKGlkeCsrKV09e307fX1cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC50ZXh0LmRpYW1ldGVyJyl7bmFtZT0nY2hhcnQudGV4dC5zaXplJzt9XG5pZihuYW1lPT0nY2hhcnQuY29sb3InKXt0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbG9ycyddPVt2YWx1ZV07fVxucHJvcFtuYW1lXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC50ZXh0LmRpYW1ldGVyJyl7bmFtZT0nY2hhcnQudGV4dC5zaXplJzt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvb3JkczI9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuZGF0YT1SRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxfZGF0YSk7aWYocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10pe2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHRoaXMuZGF0YVtpXS5sZW5ndGghPXRoaXMuZGF0YVswXS5sZW5ndGgpe2FsZXJ0KCdbUkFEQVJdIEVycm9yISBXaGVuIHRoZSByYWRhciBoYXMgY2hhcnQuYWNjdW11bGF0aXZlIHNldCB0byB0cnVlIGFsbCB0aGUgZGF0YXNldHMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO319fVxuaWYoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJ10pKXtwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5ib3hlZCddPVtdO2Zvcih2YXIgaT0wO2k8KHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddLmxlbmd0aHx8cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J118fDUpOysraSl7cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQnXVtpXT1mYWxzZTt9fVxudGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKSt0aGlzLmd1dHRlclRvcDt0aGlzLnJhZGl1cz1NYXRoLm1pbihjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCxjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzI7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXT09J251bWJlcicpdGhpcy5jZW50ZXJ4PTIqcHJvcFsnY2hhcnQuY2VudGVyeCddO2lmKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J109PSdudW1iZXInKXRoaXMuY2VudGVyeT0yKnByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZih0eXBlb2YgcHJvcFsnY2hhcnQucmFkaXVzJ109PSdudW1iZXInKXRoaXMucmFkaXVzPXByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxuaWYoIXByb3BbJ2NoYXJ0LnltYXgnXSl7aWYocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10pe3ZhciBhY2N1bXVsYXRpb249W107dmFyIGxlbj10aGlzLm9yaWdpbmFsX2RhdGFbMF0ubGVuZ3RoXG5mb3IodmFyIGk9MTtpPHRoaXMub3JpZ2luYWxfZGF0YS5sZW5ndGg7KytpKXtpZih0aGlzLm9yaWdpbmFsX2RhdGFbaV0ubGVuZ3RoIT1sZW4pe2FsZXJ0KCdbUkFEQVJdIEVycm9yISBTdGFja2VkIFJhZGFyIGNoYXJ0IGRhdGFzZXRzIG11c3QgYWxsIGJlIHRoZSBzYW1lIHNpemUhJyk7fVxuZm9yKHZhciBqPTA7ajx0aGlzLm9yaWdpbmFsX2RhdGFbaV0ubGVuZ3RoOysrail7dGhpcy5kYXRhW2ldW2pdKz10aGlzLmRhdGFbaS0xXVtqXTt0aGlzLm1heD1NYXRoLm1heCh0aGlzLm1heCx0aGlzLmRhdGFbaV1bal0pO319fVxudGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOnR5cGVvZihwcm9wWydjaGFydC55bWF4J10pPT0nbnVtYmVyJz9wcm9wWydjaGFydC55bWF4J106dGhpcy5tYXgsJ21pbic6MCwnc2NhbGUuZGVjaW1hbHMnOk51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLnRob3VzYW5kJzpwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCdzY2FsZS5yb3VuZCc6cHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwndW5pdHMucHJlJzpwcm9wWydjaGFydC51bml0cy5wcmUnXSwndW5pdHMucG9zdCc6cHJvcFsnY2hhcnQudW5pdHMucG9zdCddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt9ZWxzZXt2YXIgeW1heD1wcm9wWydjaGFydC55bWF4J107dGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOnltYXgsJ21pbic6MCwnc3RyaWN0Jzp0cnVlLCdzY2FsZS5kZWNpbWFscyc6TnVtYmVyKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddfSk7dGhpcy5tYXg9dGhpcy5zY2FsZTIubWF4O31cbnRoaXMuZHJhd0JhY2tncm91bmQoKTt0aGlzLmRyYXdBeGVzKCk7dGhpcy5kcmF3Q2lyY2xlKCk7dGhpcy5kcmF3TGFiZWxzKCk7Y28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKjIsLVJHLkhBTEZQSSwoUkcuVFdPUEkqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnRyYWNlLmNsaXAnXSktUkcuSEFMRlBJLGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uY2xvc2VQYXRoKCk7Y28uY2xpcCgpO3RoaXMuRHJhd0NoYXJ0KCk7dGhpcy5EcmF3SGlnaGxpZ2h0cygpO2NvLnJlc3RvcmUoKTt0aGlzLmRyYXdBeGlzTGFiZWxzKCk7aWYocHJvcFsnY2hhcnQudGl0bGUnXSl7UkcuRHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSx0aGlzLmd1dHRlclRvcCxudWxsLHByb3BbJ2NoYXJ0LnRpdGxlLmRpYW1ldGVyJ10/cHJvcFsnY2hhcnQudGl0bGUuZGlhbWV0ZXInXTpudWxsKX1cbmlmKHByb3BbJ2NoYXJ0LmtleSddKXtSRy5EcmF3S2V5KHRoaXMscHJvcFsnY2hhcnQua2V5J10scHJvcFsnY2hhcnQuY29sb3JzJ10pO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZigocHJvcFsnY2hhcnQuZmlsbC5jbGljayddfHxwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZSddfHwhUkcuaXNfbnVsbChwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ10pKSYmIXRoaXMuX19maWxsX2NsaWNrX2xpc3RlbmVyc19pbnN0YWxsZWRfXyl7dGhpcy5BZGRGaWxsTGlzdGVuZXJzKCk7dGhpcy5fX2ZpbGxfY2xpY2tfbGlzdGVuZXJzX2luc3RhbGxlZF9fPXRydWU7fVxuaWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHcmFwaC5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZD10aGlzLkRyYXdCYWNrZ3JvdW5kPWZ1bmN0aW9uKClcbnt2YXIgY29sb3I9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLmNvbG9yJ107dmFyIHBvbHk9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLnBvbHknXTt2YXIgc3BhY2luZz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuc3BhY2luZyddO3ZhciBzcG9rZXM9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLnNwb2tlcyddO2NvLmxpbmVXaWR0aD0xO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcyddJiZwb2x5PT1mYWxzZSl7Y28uc3Ryb2tlU3R5bGU9Y29sb3I7Y28uYmVnaW5QYXRoKCk7dmFyIG51bXJpbmdzPXR5cGVvZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuY291bnQnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5jb3VudCddOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO2Zvcih2YXIgcj0wO3I8PXRoaXMucmFkaXVzO3IrPSh0aGlzLnJhZGl1cy9udW1yaW5ncykpe2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxyLDAsUkcuVFdPUEksZmFsc2UpO31cbmNvLnN0cm9rZSgpO2NvLnN0cm9rZVN0eWxlPWNvbG9yO2Zvcih2YXIgaT0wO2k8MzYwO2krPSgzNjAvc3Bva2VzKSl7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsKGkvMzYwKSpSRy5UV09QSSwoKGkrMC4wMDEpLzM2MCkqUkcuVFdPUEksZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTt9fWVsc2UgaWYocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzJ10mJnBvbHk9PXRydWUpe2NvLnN0cm9rZVN0eWxlPWNvbG9yO3ZhciBpbmNyZW1lbnQ9MzYwL3RoaXMuZGF0YVswXS5sZW5ndGhcbmZvcih2YXIgaT0wO2k8MzYwO2krPWluY3JlbWVudCl7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsKChpLzM2MCkqUkcuVFdPUEkpLVJHLkhBTEZQSSwoKChpKzAuMDAxKS8zNjApKlJHLlRXT1BJKS1SRy5IQUxGUEksZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTt9XG5jby5zdHJva2VTdHlsZT1jb2xvcjt2YXIgbnVtcmluZ3M9dHlwZW9mKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5jb3VudCddKT09J251bWJlcic/cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLmNvdW50J106cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107Zm9yKHZhciByPTA7cjw9dGhpcy5yYWRpdXM7cis9KHRoaXMucmFkaXVzL251bXJpbmdzKSl7Y28uYmVnaW5QYXRoKCk7Zm9yKHZhciBhPTA7YTw9MzYwO2ErPSgzNjAvdGhpcy5kYXRhWzBdLmxlbmd0aCkpe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHIsUkcuZGVncmVlczJSYWRpYW5zKGEpLVJHLkhBTEZQSSxSRy5kZWdyZWVzMlJhZGlhbnMoYSkrMC4wMDEtUkcuSEFMRlBJLGZhbHNlKTt9XG5jby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTt9fX07dGhpcy5kcmF3QXhlcz10aGlzLkRyYXdBeGVzPWZ1bmN0aW9uKClcbntjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5heGVzLmNvbG9yJ107dmFyIGhhbGZzaXplPXRoaXMucmFkaXVzO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeCksdGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKTtjby5saW5lVG8oTWF0aC5yb3VuZCh0aGlzLmNlbnRlcngpLHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cyk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC01LE1hdGgucm91bmQodGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCs1LE1hdGgucm91bmQodGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKSk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC01LE1hdGgucm91bmQodGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCs1LE1hdGgucm91bmQodGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSk7Zm9yKHZhciB5PSh0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpO3k8KHRoaXMuY2VudGVyeSt0aGlzLnJhZGl1cyk7eSs9KHRoaXMucmFkaXVzL3Byb3BbJ2NoYXJ0Lm51bXl0aWNrcyddKSl7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC0zLE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngrMyxNYXRoLnJvdW5kKHkpKTt9XG5jby5tb3ZlVG8odGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzLE1hdGgucm91bmQodGhpcy5jZW50ZXJ5KSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cyxNYXRoLnJvdW5kKHRoaXMuY2VudGVyeSkpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5LTUpO2NvLmxpbmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5KzUpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5LTUpO2NvLmxpbmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5KzUpO2Zvcih2YXIgeD0odGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKTt4PCh0aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMpO3grPSh0aGlzLnJhZGl1cy9wcm9wWydjaGFydC5udW14dGlja3MnXSkpe2NvLm1vdmVUbyhNYXRoLnJvdW5kKHgpLHRoaXMuY2VudGVyeS0zKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4KSx0aGlzLmNlbnRlcnkrMyk7fVxuY28uc3Ryb2tlKCk7fTt0aGlzLmRyYXdDaGFydD10aGlzLkRyYXdDaGFydD1mdW5jdGlvbigpXG57dmFyIGFscGhhPXByb3BbJ2NoYXJ0LmNvbG9ycy5hbHBoYSddO2lmKHR5cGVvZihhbHBoYSk9PSdudW1iZXInKXt2YXIgb2xkQWxwaGE9Y28uZ2xvYmFsQWxwaGE7Y28uZ2xvYmFsQWxwaGE9YWxwaGE7fVxudmFyIG51bURhdGFzZXRzPXRoaXMuZGF0YS5sZW5ndGg7Zm9yKHZhciBkYXRhc2V0PTA7ZGF0YXNldDx0aGlzLmRhdGEubGVuZ3RoOysrZGF0YXNldCl7Y28uYmVnaW5QYXRoKCk7dmFyIGNvb3Jkc19kYXRhc2V0PVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDsrK2kpe3ZhciBjb29yZHM9dGhpcy5HZXRDb29yZGluYXRlcyhkYXRhc2V0LGkpO2lmKGNvb3Jkc19kYXRhc2V0PT1udWxsKXtjb29yZHNfZGF0YXNldD1bXTt9XG5jb29yZHNfZGF0YXNldC5wdXNoKGNvb3Jkcyk7dGhpcy5jb29yZHMucHVzaChjb29yZHMpO31cbnRoaXMuY29vcmRzMltkYXRhc2V0XT1jb29yZHNfZGF0YXNldDtjby5zdHJva2VTdHlsZT0odHlwZW9mKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pPT0nb2JqZWN0JyYmcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXVtkYXRhc2V0XSk/cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXVtkYXRhc2V0XTpwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtkYXRhc2V0XT9wcm9wWydjaGFydC5jb2xvcnMnXVtkYXRhc2V0XToncmdiYSgwLDAsMCwwKSc7aWYoY28uZmlsbFN0eWxlPT09J3RyYW5zcGFyZW50Jyl7Y28uZmlsbFN0eWxlPSdyZ2JhKDAsMCwwLDApJzt9XG5jby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ107Zm9yKGk9MDtpPGNvb3Jkc19kYXRhc2V0Lmxlbmd0aDsrK2kpe2lmKGk9PTApe2NvLm1vdmVUbyhjb29yZHNfZGF0YXNldFtpXVswXSxjb29yZHNfZGF0YXNldFtpXVsxXSk7fWVsc2V7Y28ubGluZVRvKGNvb3Jkc19kYXRhc2V0W2ldWzBdLGNvb3Jkc19kYXRhc2V0W2ldWzFdKTt9fVxuaWYocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10mJmRhdGFzZXQ+MCl7Y28ubGluZVRvKGNvb3Jkc19kYXRhc2V0WzBdWzBdLGNvb3Jkc19kYXRhc2V0WzBdWzFdKTtjby5tb3ZlVG8obGFzdF9jb29yZHNbMF1bMF0sbGFzdF9jb29yZHNbMF1bMV0pO2Zvcih2YXIgaT1jb29yZHNfZGF0YXNldC5sZW5ndGgtMTtpPj0wOy0taSl7Y28ubGluZVRvKGxhc3RfY29vcmRzW2ldWzBdLGxhc3RfY29vcmRzW2ldWzFdKTt9fVxudmFyIGxhc3RfY29vcmRzPWNvb3Jkc19kYXRhc2V0O2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt9XG5pZih0eXBlb2YoYWxwaGEpPT0nbnVtYmVyJyl7Y28uZ2xvYmFsQWxwaGE9b2xkQWxwaGE7fX07dGhpcy5nZXRDb29yZGluYXRlcz10aGlzLkdldENvb3JkaW5hdGVzPWZ1bmN0aW9uKGRhdGFzZXQsaW5kZXgpXG57dmFyIGxlbj10aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoO3ZhciBtYWc9KHRoaXMuZGF0YVtkYXRhc2V0XVtpbmRleF0vdGhpcy5tYXgpKnRoaXMucmFkaXVzO3ZhciBhbmdsZT0oUkcuVFdPUEkvbGVuKSppbmRleDthbmdsZS09UkcuSEFMRlBJO3ZhciB4PU1hdGguY29zKGFuZ2xlKSptYWc7dmFyIHk9TWF0aC5zaW4oYW5nbGUpKm1hZzt4PXRoaXMuY2VudGVyeCt4O3k9dGhpcy5jZW50ZXJ5K3k7cmV0dXJuW3gseV07fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbnt2YXIgbGFiZWxzPXByb3BbJ2NoYXJ0LmxhYmVscyddO2lmKGxhYmVscyYmbGFiZWxzLmxlbmd0aD4wKXtjby5saW5lV2lkdGg9MTtjby5zdHJva2VTdHlsZT0nZ3JheSc7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGJnRmlsbD1wcm9wWydjaGFydC5sYWJlbHMuYmFja2dyb3VuZC5maWxsJ10sYm9sZD1wcm9wWydjaGFydC5sYWJlbHMuYm9sZCddLGJnQm94ZWQ9cHJvcFsnY2hhcnQubGFiZWxzLmJveGVkJ10sb2Zmc2V0PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQnXSxmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHNpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10scmFkaXVzPXRoaXMucmFkaXVzLGNvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ11cbmZvcih2YXIgaT0wO2k8bGFiZWxzLmxlbmd0aDsrK2kpe3ZhciBhbmdsZT0oUkcuVFdPUEkvcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoKSppO2FuZ2xlLT1SRy5IQUxGUEk7dmFyIHg9dGhpcy5jZW50ZXJ4KyhtYS5jb3MoYW5nbGUpKihyYWRpdXMrb2Zmc2V0KSk7dmFyIHk9dGhpcy5jZW50ZXJ5KyhtYS5zaW4oYW5nbGUpKihyYWRpdXMrb2Zmc2V0KSk7dmFyIGhhbGlnbj14PHRoaXMuY2VudGVyeD8ncmlnaHQnOidsZWZ0JztpZihpPT0wfHwoaS9sYWJlbHMubGVuZ3RoKT09MC41KWhhbGlnbj0nY2VudGVyJztpZihsYWJlbHNbaV0mJmxhYmVsc1tpXS5sZW5ndGgpe1JHLnRleHQyKHRoaXMseydjb2xvcic6Y29sb3IsJ2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOngsJ3knOnksJ3RleHQnOmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzpoYWxpZ24sJ2JvdW5kaW5nJzpiZ0JveGVkLCdib3VuZGluZ0ZpbGwnOmJnRmlsbCwnYm9sZCc6Ym9sZCwndGFnJzonbGFiZWxzJ30pO319fX07dGhpcy5kcmF3Q2lyY2xlPXRoaXMuRHJhd0NpcmNsZT1mdW5jdGlvbigpXG57dmFyIGNpcmNsZT17fTtjaXJjbGUubGltaXQ9cHJvcFsnY2hhcnQuY2lyY2xlJ107Y2lyY2xlLmZpbGw9cHJvcFsnY2hhcnQuY2lyY2xlLmZpbGwnXTtjaXJjbGUuc3Ryb2tlPXByb3BbJ2NoYXJ0LmNpcmNsZS5zdHJva2UnXTtpZihjaXJjbGUubGltaXQpe3ZhciByPShjaXJjbGUubGltaXQvdGhpcy5tYXgpKnRoaXMucmFkaXVzO2NvLmZpbGxTdHlsZT1jaXJjbGUuZmlsbDtjby5zdHJva2VTdHlsZT1jaXJjbGUuc3Ryb2tlO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHIsMCxSRy5UV09QSSwwKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7fX07dGhpcy5kcmF3QXhpc0xhYmVscz10aGlzLkRyYXdBeGlzTGFiZWxzPWZ1bmN0aW9uKClcbntpZihSRy5pc0FycmF5KHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddKSYmcHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoKXt0aGlzLmRyYXdTcGVjaWZpY0F4aXNMYWJlbHMoKTtyZXR1cm47fVxuY28ubGluZVdpZHRoPTE7Y28uZmlsbFN0eWxlPSdibGFjayc7Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJzt2YXIgcj10aGlzLnJhZGl1cyxmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHNpemU9dHlwZW9mKHByb3BbJ2NoYXJ0LnRleHQuc2l6ZS5zY2FsZSddKT09J251bWJlcic/cHJvcFsnY2hhcnQudGV4dC5zaXplLnNjYWxlJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ10sYXhlcz1wcm9wWydjaGFydC5sYWJlbHMuYXhlcyddLnRvTG93ZXJDYXNlKCksY29sb3I9cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQuYmFja2dyb3VuZCddLGRyYXd6ZXJvPWZhbHNlLHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXSx1bml0c19wb3N0PXByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLGJvbGQ9cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm9sZCddLGJveGVkPXByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJ10sY2VudGVyeD10aGlzLmNlbnRlcngsY2VudGVyeT10aGlzLmNlbnRlcnksc2NhbGU9dGhpcy5zY2FsZTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmKGF4ZXMuaW5kZXhPZignbicpPi0xKXtmb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy5UZXh0Mih0aGlzLHsnYm9sZCc6Ym9sZFtpXSwnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeCwneSc6Y2VudGVyeS0ociooKGkrMSkvdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkpLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J2NlbnRlcicsJ2JvdW5kaW5nJzpib3hlZFtpXXx8Y29sb3IsJ2JvdW5kaW5nRmlsbCc6Y29sb3IsJ2JvdW5kaW5nU3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ3RhZyc6J3NjYWxlJ30pO31cbmRyYXd6ZXJvPXRydWU7fVxuaWYoYXhlcy5pbmRleE9mKCdzJyk+LTEpe2Zvcih2YXIgaT0wO2k8dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsrK2kpe1JHLlRleHQyKHRoaXMseydib2xkJzpib2xkW2ldLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4LCd5JzpjZW50ZXJ5KyhyKigoaSsxKS90aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSksJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOmJveGVkW2ldfHxjb2xvciwnYm91bmRpbmdGaWxsJzpjb2xvciwnYm91bmRpbmdTdHJva2UnOidyZ2JhKDAsMCwwLDApJywndGFnJzonc2NhbGUnfSk7fVxuZHJhd3plcm89dHJ1ZTt9XG5pZihheGVzLmluZGV4T2YoJ2UnKT4tMSl7Zm9yKHZhciBpPTA7aTx0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOysraSl7UkcuVGV4dDIodGhpcyx7J2JvbGQnOmJvbGRbaV0sJ2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOmNlbnRlcngrKHIqKChpKzEpL3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpKSwneSc6Y2VudGVyeSwndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW2ldLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6Ym94ZWRbaV18fGNvbG9yLCdib3VuZGluZ0ZpbGwnOmNvbG9yLCdib3VuZGluZ1N0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCd0YWcnOidzY2FsZSd9KTt9XG5kcmF3emVybz10cnVlO31cbmlmKGF4ZXMuaW5kZXhPZigndycpPi0xKXtmb3IodmFyIGk9MDtpPHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7KytpKXtSRy5UZXh0Mih0aGlzLHsnYm9sZCc6Ym9sZFtpXSwnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0ociooKGkrMSkvdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkpLCd5JzpjZW50ZXJ5LCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J2NlbnRlcicsJ2JvdW5kaW5nJzpib3hlZFtpXXx8Y29sb3IsJ2JvdW5kaW5nRmlsbCc6Y29sb3IsJ2JvdW5kaW5nU3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ3RhZyc6J3NjYWxlJ30pO31cbmRyYXd6ZXJvPXRydWU7fVxuaWYoZHJhd3plcm8pe1JHLlRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUseDpjZW50ZXJ4LHk6Y2VudGVyeSx0ZXh0OlJHLm51bWJlckZvcm1hdCh0aGlzLE51bWJlcigwKS50b0ZpeGVkKCksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLHZhbGlnbjonY2VudGVyJyxoYWxpZ246J2NlbnRlcicsYm91bmRpbmc6cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQuemVybyddLGJvdW5kaW5nRmlsbDpjb2xvcixib3VuZGluZ1N0cm9rZToncmdiYSgwLDAsMCwwKScsYm9sZDpwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5ib2xkLnplcm8nXSx0YWc6J3NjYWxlJ30pO319O3RoaXMuZHJhd1NwZWNpZmljQXhpc0xhYmVscz10aGlzLkRyYXdTcGVjaWZpY0F4aXNMYWJlbHM9ZnVuY3Rpb24oKVxue3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ107dmFyIGJvbGQ9UkcuYXJyYXlfcGFkKHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJvbGQnXSxsYWJlbHMubGVuZ3RoKTt2YXIgYm94ZWQ9UkcuYXJyYXlfcGFkKHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJ10sbGFiZWxzLmxlbmd0aCk7dmFyIHJldmVyc2VkX2xhYmVscz1SRy5hcnJheV9yZXZlcnNlKGxhYmVscyk7dmFyIHJldmVyc2VkX2JvbGQ9UkcuYXJyYXlfcmV2ZXJzZShib2xkKTt2YXIgcmV2ZXJzZWRfYm94ZWQ9UkcuYXJyYXlfcmV2ZXJzZShib3hlZCk7dmFyIGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHNpemU9dHlwZW9mKHByb3BbJ2NoYXJ0LnRleHQuc2l6ZS5zY2FsZSddKT09J251bWJlcic/cHJvcFsnY2hhcnQudGV4dC5zaXplLnNjYWxlJ106cHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIGF4ZXM9cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMnXS50b0xvd2VyQ2FzZSgpO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Zm9yKHZhciBpPTA7aTxsYWJlbHMubGVuZ3RoOysraSl7aWYoYXhlcy5pbmRleE9mKCduJyk+LTEpUkcuVGV4dDIodGhpcyx7J3RhZyc6J2xhYmVscy5zcGVjaWZpYycsJ2JvbGQnOnJldmVyc2VkX2JvbGRbaV0sJ2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOnRoaXMuY2VudGVyeCwneSc6dGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKygodGhpcy5yYWRpdXMvbGFiZWxzLmxlbmd0aCkqaSksJ3RleHQnOnJldmVyc2VkX2xhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOnJldmVyc2VkX2JveGVkW2ldLCdib3VuZGluZ0ZpbGwnOid3aGl0ZSd9KTtpZihheGVzLmluZGV4T2YoJ3MnKT4tMSlSRy5UZXh0Mih0aGlzLHsndGFnJzonbGFiZWxzLnNwZWNpZmljJywnYm9sZCc6Ym9sZFtpXSwnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6dGhpcy5jZW50ZXJ4LCd5Jzp0aGlzLmNlbnRlcnkrKCh0aGlzLnJhZGl1cy9sYWJlbHMubGVuZ3RoKSooaSsxKSksJ3RleHQnOmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOmJveGVkW2ldLCdib3VuZGluZ0ZpbGwnOid3aGl0ZSd9KTtpZihheGVzLmluZGV4T2YoJ3cnKT4tMSlSRy5UZXh0Mih0aGlzLHsndGFnJzonbGFiZWxzLnNwZWNpZmljJywnYm9sZCc6cmV2ZXJzZWRfYm9sZFtpXSwnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6dGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKygodGhpcy5yYWRpdXMvbGFiZWxzLmxlbmd0aCkqaSksJ3knOnRoaXMuY2VudGVyeSwndGV4dCc6cmV2ZXJzZWRfbGFiZWxzW2ldLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6cmV2ZXJzZWRfYm94ZWRbaV0sJ2JvdW5kaW5nRmlsbCc6J3doaXRlJ30pO2lmKGF4ZXMuaW5kZXhPZignZScpPi0xKVJHLlRleHQyKHRoaXMseyd0YWcnOidsYWJlbHMuc3BlY2lmaWMnLCdib2xkJzpib2xkW2ldLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp0aGlzLmNlbnRlcngrKCh0aGlzLnJhZGl1cy9sYWJlbHMubGVuZ3RoKSooaSsxKSksJ3knOnRoaXMuY2VudGVyeSwndGV4dCc6bGFiZWxzW2ldLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6Ym94ZWRbaV0sJ2JvdW5kaW5nRmlsbCc6J3doaXRlJ30pO319O3RoaXMuZ2V0U2hhcGU9dGhpcy5nZXRQb2ludD1mdW5jdGlvbihlKVxue2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMubGVuZ3RoOysraSl7dmFyIHg9dGhpcy5jb29yZHNbaV1bMF07dmFyIHk9dGhpcy5jb29yZHNbaV1bMV07dmFyIHRvb2x0aXBzPXByb3BbJ2NoYXJ0LnRvb2x0aXBzJ107dmFyIGluZGV4PU51bWJlcihpKTt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVg9bW91c2VYWVswXTt2YXIgbW91c2VZPW1vdXNlWFlbMV07aWYobW91c2VYPCh4KzUpJiZtb3VzZVg+KHgtNSkmJm1vdXNlWT4oeS01KSYmbW91c2VZPCh5KzUpKXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10saW5kZXgpO3JldHVybnswOnRoaXMsJ29iamVjdCc6dGhpcywxOngsJ3gnOngsMjp5LCd5Jzp5LDM6bnVsbCwnZGF0YXNldCc6bnVsbCw0OmluZGV4LCdpbmRleCc6aSwndG9vbHRpcCc6dG9vbHRpcH19fX07dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7UkcuSGlnaGxpZ2h0LlBvaW50KHRoaXMsc2hhcGUpO319O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7aWYobW91c2VYWVswXT4odGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKSYmbW91c2VYWVswXTwodGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzKSYmbW91c2VYWVsxXT4odGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSYmbW91c2VYWVsxXTwodGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5kcmF3SGlnaGxpZ2h0cz10aGlzLkRyYXdIaWdobGlnaHRzPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5oaWdobGlnaHRzJ10pe3ZhciBzZXF1ZW50aWFsSWR4PTA7dmFyIGRhdGFzZXQ9MDt2YXIgaW5kZXg9MDt2YXIgcmFkaXVzPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodHMucmFkaXVzJ107Zm9yKHZhciBkYXRhc2V0PTA7ZGF0YXNldDx0aGlzLmRhdGEubGVuZ3RoOysrZGF0YXNldCl7Zm9yKHZhciBpbmRleD0wO2luZGV4PHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7KytpbmRleCl7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuaGlnaGxpZ2h0cy5zdHJva2UnXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuaGlnaGxpZ2h0cy5maWxsJ10/cHJvcFsnY2hhcnQuaGlnaGxpZ2h0cy5maWxsJ106KCh0eXBlb2YocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC5zdHJva2VzdHlsZSddW2RhdGFzZXRdKT9wcm9wWydjaGFydC5zdHJva2VzdHlsZSddW2RhdGFzZXRdOnByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO2NvLmFyYyh0aGlzLmNvb3Jkc1tzZXF1ZW50aWFsSWR4XVswXSx0aGlzLmNvb3Jkc1tzZXF1ZW50aWFsSWR4XVsxXSxyYWRpdXMsMCxSRy5UV09QSSxmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpOysrc2VxdWVudGlhbElkeDt9fX19O3RoaXMuZ2V0UmFkaXVzPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPDB8fHZhbHVlPnRoaXMubWF4KXtyZXR1cm4gbnVsbDt9XG52YXIgcmFkaXVzPSh2YWx1ZS90aGlzLm1heCkqdGhpcy5yYWRpdXM7cmV0dXJuIHJhZGl1czt9O3RoaXMuZ2V0QW5nbGU9ZnVuY3Rpb24obnVtaXRlbXMsaW5kZXgpXG57dmFyIGFuZ2xlPShSRy5UV09QSS9udW1pdGVtcykqaW5kZXg7YW5nbGUtPVJHLkhBTEZQSTtyZXR1cm4gYW5nbGU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGl0bGUuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50aXRsZS5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGV4dC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jaXJjbGUuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNpcmNsZS5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jaXJjbGUuc3Ryb2tlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY2lyY2xlLnN0cm9rZSddKTt9XG5mb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmNvbG9ycyddW2ldPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldKTt9XG52YXIga2V5Q29sb3JzPXByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXTtpZih0eXBlb2Yoa2V5Q29sb3JzKSE9J251bGwnJiZrZXlDb2xvcnMmJmtleUNvbG9ycy5sZW5ndGgpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQua2V5LmNvbG9ycyddLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXVtpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0pO319XG5wcm9wWydjaGFydC50aXRsZS5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuY2lyY2xlLmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jaXJjbGUuZmlsbCddKTtwcm9wWydjaGFydC5jaXJjbGUuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY2lyY2xlLnN0cm9rZSddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMCx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTE7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5hZGRGaWxsTGlzdGVuZXJzPXRoaXMuQWRkRmlsbExpc3RlbmVycz1mdW5jdGlvbihlKVxue3ZhciBvYmo9dGhpczt2YXIgZnVuYz1mdW5jdGlvbihlKVxue3ZhciBjb29yZHM9dGhpcy5jb29yZHM7dmFyIGNvb3JkczI9dGhpcy5jb29yZHMyO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIGRhdGFzZXQ9MDtpZihlLnR5cGU9PSdtb3VzZW1vdmUnJiZwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZS5yZWRyYXcnXSl7UkcuUmVkcmF3Q2FudmFzKGNhKTt9XG5mb3IodmFyIGRhdGFzZXQ9KG9iai5jb29yZHMyLmxlbmd0aC0xKTtkYXRhc2V0Pj0wOy0tZGF0YXNldCl7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKG9iai5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLG9iai5jb29yZHMyW2RhdGFzZXRdWzBdWzFdKTtmb3IodmFyIGo9MDtqPG9iai5jb29yZHMyW2RhdGFzZXRdLmxlbmd0aDsrK2ope2NvLmxpbmVUbyhvYmouY29vcmRzMltkYXRhc2V0XVtqXVswXSxvYmouY29vcmRzMltkYXRhc2V0XVtqXVsxXSk7fVxuY28ubGluZVRvKG9iai5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLG9iai5jb29yZHMyW2RhdGFzZXRdWzBdWzFdKTtpZihwcm9wWydjaGFydC5hY2N1bXVsYXRpdmUnXSYmZGF0YXNldD4wKXtjby5saW5lVG8ob2JqLmNvb3JkczJbZGF0YXNldC0xXVswXVswXSxvYmouY29vcmRzMltkYXRhc2V0LTFdWzBdWzFdKTtmb3IodmFyIGo9KG9iai5jb29yZHMyW2RhdGFzZXQtMV0ubGVuZ3RoLTEpO2o+PTA7LS1qKXtjby5saW5lVG8ob2JqLmNvb3JkczJbZGF0YXNldC0xXVtqXVswXSxvYmouY29vcmRzMltkYXRhc2V0LTFdW2pdWzFdKTt9fVxuY28uY2xvc2VQYXRoKCk7aWYoY28uaXNQb2ludEluUGF0aChtb3VzZVhZWzBdLG1vdXNlWFlbMV0pKXt2YXIgaW5QYXRoPXRydWU7YnJlYWs7fX1cbmlmKGluUGF0aCl7dmFyIGZpbGxUb29sdGlwcz1wcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ107aWYoZS50eXBlPT0nY2xpY2snKXtpZihwcm9wWydjaGFydC5maWxsLmNsaWNrJ10pe3Byb3BbJ2NoYXJ0LmZpbGwuY2xpY2snXShlLGRhdGFzZXQpO31cbmlmKHByb3BbJ2NoYXJ0LmZpbGwudG9vbHRpcHMnXSYmcHJvcFsnY2hhcnQuZmlsbC50b29sdGlwcyddW2RhdGFzZXRdKXtvYmouRGF0YXNldFRvb2x0aXAoZSxkYXRhc2V0KTt9fVxuaWYoZS50eXBlPT0nbW91c2Vtb3ZlJyl7aWYocHJvcFsnY2hhcnQuZmlsbC5tb3VzZW1vdmUnXSl7cHJvcFsnY2hhcnQuZmlsbC5tb3VzZW1vdmUnXShlLGRhdGFzZXQpO31cbmlmKCFSRy5pc19udWxsKGZpbGxUb29sdGlwcykpe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fVxuaWYocHJvcFsnY2hhcnQuZmlsbC50b29sdGlwcyddJiZwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ11bZGF0YXNldF0pe2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fX1cbmUuc3RvcFByb3BhZ2F0aW9uKCk7fWVsc2UgaWYoZS50eXBlPT0nbW91c2Vtb3ZlJyl7Y2Euc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt9fTtpZihwcm9wWydjaGFydC5maWxsLmNsaWNrJ118fCFSRy5pc19udWxsKHByb3BbJ2NoYXJ0LmZpbGwudG9vbHRpcHMnXSkpe2NhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jLGZhbHNlKTt9XG5pZihwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZSddfHwhUkcuaXNfbnVsbChwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ10pKXtjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmMsZmFsc2UpO319O3RoaXMuaGlnaGxpZ2h0RGF0YXNldD10aGlzLkhpZ2hsaWdodERhdGFzZXQ9ZnVuY3Rpb24oZGF0YXNldClcbntjby5iZWdpblBhdGgoKTtmb3IodmFyIGo9MDtqPHRoaXMuY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7KytqKXtpZihqPT0wKXtjby5tb3ZlVG8odGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLHRoaXMuY29vcmRzMltkYXRhc2V0XVswXVsxXSk7fWVsc2V7Y28ubGluZVRvKHRoaXMuY29vcmRzMltkYXRhc2V0XVtqXVswXSx0aGlzLmNvb3JkczJbZGF0YXNldF1bal1bMV0pO319XG5jby5saW5lVG8odGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLHRoaXMuY29vcmRzMltkYXRhc2V0XVswXVsxXSk7aWYocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10mJmRhdGFzZXQ+MCl7Y28ubGluZVRvKHRoaXMuY29vcmRzMltkYXRhc2V0LTFdWzBdWzBdLHRoaXMuY29vcmRzMltkYXRhc2V0LTFdWzBdWzFdKTtmb3IodmFyIGo9KHRoaXMuY29vcmRzMltkYXRhc2V0LTFdLmxlbmd0aC0xKTtqPj0wOy0tail7Y28ubGluZVRvKHRoaXMuY29vcmRzMltkYXRhc2V0LTFdW2pdWzBdLHRoaXMuY29vcmRzMltkYXRhc2V0LTFdW2pdWzFdKTt9fVxuY28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuZmlsbC5oaWdobGlnaHQuc3Ryb2tlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmZpbGwuaGlnaGxpZ2h0LmZpbGwnXTtjby5zdHJva2UoKTtjby5maWxsKCk7fTt0aGlzLmRhdGFzZXRUb29sdGlwPXRoaXMuRGF0YXNldFRvb2x0aXA9ZnVuY3Rpb24oZSxkYXRhc2V0KVxue3RoaXMuSGlnaGxpZ2h0RGF0YXNldChkYXRhc2V0KTt2YXIgdGV4dD1wcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ11bZGF0YXNldF07dmFyIHg9MDt2YXIgeT10aGlzLmNvb3JkczJbZGF0YXNldF1bMF1bMV0rUkcuZ2V0Q2FudmFzWFkoY2EpWzFdO1JHLlRvb2x0aXAodGhpcyx0ZXh0LHgseSwwLGUpO307dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodD1mdW5jdGlvbihpbmRleClcbnt2YXIgY29vcmRzPXRoaXMuY29vcmRzMltpbmRleF07aWYoY29vcmRzKXt2YXIgcHJlX2xpbmV3aWR0aD1jby5saW5lV2lkdGg7dmFyIHByZV9saW5lY2FwPWNvLmxpbmVDYXA7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddKzEwO2NvLmxpbmVDYXA9J3JvdW5kJztjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0wLGxlbj1jb29yZHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKGk9PTApe2NvLm1vdmVUbyhjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdKTt9ZWxzZXtjby5saW5lVG8oY29vcmRzW2ldWzBdLGNvb3Jkc1tpXVsxXSk7fX1cbmNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aD1wcmVfbGluZXdpZHRoO2NvLmxpbmVDYXA9cHJlX2xpbmVjYXA7fX07dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMuZ3Jvdz1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmZ1bmN0aW9uKCl7fTt2YXIgb3B0PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307dmFyIGZyYW1lcz1vcHQuZnJhbWVzP29wdC5mcmFtZXM6MzA7dmFyIGZyYW1lPTA7dmFyIGRhdGE9UkcuYXJyYXlfY2xvbmUob2JqLmRhdGEpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntmb3IodmFyIGk9MCxsZW49ZGF0YS5sZW5ndGg7aTxsZW47KytpKXtmb3IodmFyIGo9MCxsZW4yPWRhdGFbaV0ubGVuZ3RoO2o8bGVuMjsrK2ope29iai5vcmlnaW5hbF9kYXRhW2ldW2pdPShmcmFtZS9mcmFtZXMpKmRhdGFbaV1bal07fX1cblJHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lPGZyYW1lcyl7ZnJhbWUrKztSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLnRyYWNlPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8NjA7dmFyIGZyYW1lPTA7dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O29iai5TZXQoJ2FuaW1hdGlvbi50cmFjZS5jbGlwJywwKTt2YXIgaXRlcmF0b3I9ZnVuY3Rpb24oKVxue2lmKGZyYW1lPGZyYW1lcyl7b2JqLlNldCgnYW5pbWF0aW9uLnRyYWNlLmNsaXAnLGZyYW1lL2ZyYW1lcyk7ZnJhbWUrKztSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle29iai5TZXQoJ2FuaW1hdGlvbi50cmFjZS5jbGlwJywxKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Y2FsbGJhY2sob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5yYWRhci5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///229\n");

/***/ }),
/* 230 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Rose = RGraph.Effects.Rose || {};RGraph.Rose = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.data = conf.data;this.canvas.__object__ = this;this.type = 'rose';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;this.angles = [];this.angles2 = [];this.properties = { 'chart.background.axes': true, 'chart.background.axes.color': 'black', 'chart.background.grid': true, 'chart.background.grid.color': '#ccc', 'chart.background.grid.size': null, 'chart.background.grid.radials': null, 'chart.background.grid.count': 5, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.angles.start': 0, 'chart.colors': ['rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)', 'rgba(0,255,255,0.5)', 'rgb(0,255,0)', 'gray', 'blue', 'rgb(255,128,255)', 'green', 'pink', 'gray', 'aqua'], 'chart.linewidth': 1, 'chart.colors.sequential': false, 'chart.colors.alpha': null, 'chart.margin': 0, 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.position': 'center', 'chart.labels.axes': 'nsew', 'chart.labels.boxed': false, 'chart.labels.offset': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.variant': 'stacked', 'chart.variant.threed.depth': 10, 'chart.exploded': 0, 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.animation.roundrobin.factor': 1, 'chart.animation.roundrobin.radius': true, 'chart.animation.grow.multiplier': 1, 'chart.labels.count': 5, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    } else if (_typeof(this.data[i]) === 'object') {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(this.data);for (var i = 0; i < linear_data.length; ++i) {\n    this[\"$\" + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.background.grid.spokes') name = 'chart.background.grid.radials';if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.angles = [];this.angles2 = [];this.total = 0;this.startRadians = prop['chart.angles.start'];this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - this.gutterRight + 5;\n    }\n    if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.variant'].indexOf('3d') !== -1) {\n      var scaleX = 1.5;this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);\n    }\n    this.drawBackground();if (prop['chart.variant'].indexOf('3d') !== -1) {\n      RG.setShadow(this, 'rgba(0,0,0,0.35)', 0, 15, 25);for (var i = prop['chart.variant.threed.depth']; i > 0; i -= 1) {\n        this.centery -= 1;this.drawRose({ storeAngles: false });RG.setShadow(this, 'rgba(0,0,0,0)', 0, 0, 0);for (var j = 0, len = this.angles.length; j < len; j += 1) {\n          var a = this.angles[j];pa2(co, ['b', 'm', a[4], a[5], 'a', a[4], a[5], a[3] + 1.5, a[0] - 0.01, a[1] + 0.01, false, 'c', 'f', 'rgba(0,0,0,0.1)']);\n        }\n      }\n    }\n    this.drawRose();this.drawLabels();co.strokeStyle = 'rgba(0,0,0,0)';\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.adjustable']) {\n      RG.AllowAdjusting(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      if (!RG.allowSegmentHighlight) {\n        alert('[WARNING] The segment highlight function does not exist - have you included the dynamic library?');\n      }\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : this.data.length, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.lineWidth = 1;if (prop['chart.background.grid']) {\n      if (typeof prop['chart.background.grid.count'] == 'number') {\n        prop['chart.background.grid.size'] = this.radius / prop['chart.background.grid.count'];\n      }\n      co.beginPath();co.strokeStyle = prop['chart.background.grid.color'];for (var i = prop['chart.background.grid.size']; i <= this.radius; i += prop['chart.background.grid.size']) {\n        co.moveTo(this.centerx + i, this.centery);co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.beginPath();if (typeof prop['chart.background.grid.radials'] !== 'number') {\n        prop['chart.background.grid.radials'] = this.data.length;\n      }\n      var num = 360 / prop['chart.background.grid.radials'];for (var i = num; i <= 360; i += num) {\n        co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI + this.startRadians, (i + 0.0001) / (180 / RG.PI) - RG.HALFPI + this.startRadians, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    if (prop['chart.background.axes']) {\n      co.beginPath();co.strokeStyle = prop['chart.background.axes.color'];co.moveTo(this.centerx - this.radius, ma.round(this.centery));co.lineTo(this.centerx + this.radius, ma.round(this.centery));co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / 5) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3.5);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / 5) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n      co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));co.closePath();co.stroke();\n    }\n    pa2(co, 'b c');\n  };this.drawRose = this.DrawRose = function () {\n    var max = 0,\n        data = this.data,\n        margin = RG.degrees2Radians(prop['chart.margin']),\n        opt = arguments[0] || {};co.lineWidth = prop['chart.linewidth'];if (RG.isNull(prop['chart.ymax'])) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] == 'number') {\n          max = ma.max(max, data[i]);\n        } else if (_typeof(data[i]) == 'object' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n          max = ma.max(max, data[i][0]);\n        } else {\n          max = ma.max(max, RG.arraySum(data[i]));\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': max, 'min': 0, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    this.sum = RG.arraySum(data);co.moveTo(this.centerx, this.centery);co.stroke();if (prop['chart.colors.alpha']) {\n      co.globalAlpha = prop['chart.colors.alpha'];\n    }\n    var sequentialIndex = 0;if (typeof prop['chart.variant'] == 'string' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n      var total = 0;for (var i = 0; i < data.length; ++i) {\n        total += data[i][1];\n      }\n      if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = this.data[i][1] / total * RG.TWOPI;var radius = (this.data[i][0] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        }\n        co.beginPath();var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = (this.startRadians + segmentRadians) * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[i] = [startAngle, endAngle, 0, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);this.redrawRose();\n      }\n    } else {\n      var sequentialColorIndex = 0;if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = 1 / this.data.length * RG.TWOPI;if (typeof this.data[i] == 'number') {\n          co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = prop['chart.colors'][i];\n          }\n          var radius = (this.data[i] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();co.beginPath();if (endAngle == 0) {}\n          this.angles[i] = [startAngle, endAngle, 0, radius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;\n        } else if (_typeof(this.data[i]) == 'object') {\n          var margin = prop['chart.margin'] / (180 / RG.PI);if (!this.angles2[i]) {\n            this.angles2[i] = [];\n          }\n          for (var j = 0; j < this.data[i].length; ++j) {\n            var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][j];if (prop['chart.colors.sequential']) {\n              co.fillStyle = prop['chart.colors'][sequentialColorIndex++];\n            }\n            if (j == 0) {\n              co.beginPath();var startRadius = 0;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? endRadius * prop['chart.animation.roundrobin.factor'] : endRadius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            } else {\n              co.beginPath();var startRadius = endRadius;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius + startRadius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, startRadius * prop['chart.animation.roundrobin.factor'], startAngle, endAngle, 0);co.arc(this.centerx + explodedX, this.centery + explodedY, endRadius * prop['chart.animation.roundrobin.factor'], endAngle, startAngle, true);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            }\n          }\n        }\n        this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);\n      }\n      if (prop['chart.shadow']) {\n        this.redrawRose();\n      }\n    }\n    if (prop['chart.colors.alpha']) {\n      co.globalAlpha = 1;\n    }\n    if (prop['chart.title']) {\n      RG.drawTitle(this, prop['chart.title'], ca.height / 2 - this.radius, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n  };this.redrawRose = function () {\n    var angles = this.angles;for (var i = 0; i < angles.length; ++i) {\n      pa2(co, 'b a % % % % % false a % % % % % true c f % f % ', angles[i][4], angles[i][5], angles[i][2], angles[i][0], angles[i][1], angles[i][4], angles[i][5], angles[i][3], angles[i][1], angles[i][0], angles[i][6], angles[i][7]);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;var key = prop['chart.key'];if (key && key.length) {\n      RG.DrawKey(this, key, prop['chart.colors']);\n    }\n    co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';var radius = this.radius,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        decimals = prop['chart.scale.decimals'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0);if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, radius + 10);\n    }\n    if (typeof prop['chart.text.size.scale'] == 'number') {\n      size = prop['chart.text.size.scale'];\n    }\n    var color = 'rgba(255,255,255,0.8)';if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery - radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery + radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (RG.trim(axes).length > 0) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': typeof prop['chart.ymin'] === 'number' ? RG.numberFormat(this, Number(prop['chart.ymin']).toFixed(prop['chart.ymin'] === 0 ? '0' : prop['chart.scale.decimals']), units_pre, units_post) : '0', 'valign': 'center', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (co, labels, font, size, radius) {\n    var variant = prop['chart.variant'],\n        position = prop['chart.labels.position'],\n        radius = radius + 5 + prop['chart.labels.offset'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0),\n        labelsColor = prop['chart.labels.color'] || prop['chart.text.color'],\n        angles = this.angles;\n    for (var i = 0; i < this.data.length; ++i) {\n      if (typeof variant == 'string' && variant.indexOf('non-equi-angular') !== -1) {\n        var a = Number(angles[i][0]) + (angles[i][1] - angles[i][0]) / 2;\n      } else {\n        var a = RG.TWOPI / this.data.length * (i + 1) - RG.TWOPI / (this.data.length * 2);var a = a - RG.HALFPI + (prop['chart.labels.position'] == 'edge' ? RG.TWOPI / this.data.length / 2 : 0);\n      }\n      var x = centerx + ma.cos(a) * radius;var y = centery + ma.sin(a) * radius;if (x > centerx) {\n        halign = 'left';\n      } else if (Math.round(x) == centerx) {\n        halign = 'center';\n      } else {\n        halign = 'right';\n      }\n      RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'x': x, 'y': y, 'text': String(labels[i]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.fixEventObject(e);var angles = this.angles;var ret = [];var opt = arguments[1] ? arguments[1] : { radius: true };for (var i = 0; i < angles.length; ++i) {\n      var angleStart = angles[i][0];var angleEnd = angles[i][1];var radiusStart = opt.radius === false ? 0 : angles[i][2];var radiusEnd = opt.radius === false ? this.radius : angles[i][3];var centerX = angles[i][4];var centerY = angles[i][5];var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0] - centerX;var mouseY = mouseXY[1] - centerY;co.beginPath();co.arc(centerX, centerY, radiusStart ? radiusStart : 0.01, angleStart, angleEnd, false);co.arc(centerX, centerY, radiusEnd, angleEnd, angleStart, true);co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n        angles[i][6] = i;if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], angles[i][6]);\n        }\n        angles[i]['object'] = this;angles[i]['x'] = angles[i][4];angles[i]['y'] = angles[i][5];angles[i]['angle.start'] = angles[i][0];angles[i]['angle.end'] = angles[i][1];angles[i]['radius.start'] = angles[i][2];angles[i]['radius.end'] = angles[i][3];angles[i]['index'] = angles[i][6];angles[i]['tooltip'] = tooltip ? tooltip : null;return angles[i];\n      }\n    }\n    return null;\n  };this.getExploded = this.getexploded = function (index, startAngle, endAngle, exploded) {\n    var explodedx, explodedy;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) == 'object' && typeof exploded[index] == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded[index];explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded[index];\n    } else if (typeof exploded == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded;explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded;\n    } else {\n      explodedx = 0;explodedy = 0;\n    }\n    return [explodedx, explodedy];\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.arc(shape['x'], shape['y'], shape['radius.end'], shape['angle.start'], shape['angle.end'], false);if (shape['radius.start'] > 0) {\n        co.arc(shape['x'], shape['y'], shape['radius.start'], shape['angle.end'], shape['angle.start'], true);\n      } else {\n        co.lineTo(shape['x'], shape['y']);\n      }\n      co.closePath();co.stroke();co.fill();\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (prop['chart.variant'].indexOf('3d') !== -1) {\n      radius /= -1;\n    }\n    if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var r = value / this.max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var segments = this.angles2;for (var i = 0; i < this.angles2.length; i += 1) {\n      co.beginPath();co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][2], segments[i][index][0], segments[i][index][1], false);co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][3], segments[i][index][1], segments[i][index][0], true);co.closePath();co.fill();co.stroke();\n    }\n    return;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.explode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = Number(this.Get('exploded'));function iterator() {\n      exploded = frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this;var opt = arguments[0] || {};\n    var frames = opt.frames || 30;var frame = 0;var original_margin = prop['chart.margin'];var margin = 360 / this.data.length / 2;var callback = arguments[1] || function () {};this.Set('chart.margin', margin);this.Set('chart.animation.roundrobin.factor', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animation.roundrobin.factor', frame / frames);obj.set('margin', frame / frames * original_margin);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.set('animation.roundrobin.factor', 1);obj.set('margin', original_margin);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.implode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;function iterator() {\n      obj.Set('animation.grow.multiplier', frame / frames);RG.clear(ca);RG.redrawCanvas(ca);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucm9zZS5qcz9iZThlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguRWZmZWN0cz1SR3JhcGguRWZmZWN0c3x8e307UkdyYXBoLkVmZmVjdHMuUm9zZT1SR3JhcGguRWZmZWN0cy5Sb3NlfHx7fTtSR3JhcGguUm9zZT1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgY29uZj17aWQ6Y29uZn07Y29uZi5kYXRhPWFyZ3VtZW50c1sxXTt9XG50aGlzLmlkPWNvbmYuaWQ7dGhpcy5jYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7dGhpcy5kYXRhPWNvbmYuZGF0YTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy50eXBlPSdyb3NlJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLmNlbnRlcng9MDt0aGlzLmNlbnRlcnk9MDt0aGlzLnJhZGl1cz0wO3RoaXMubWF4PTA7dGhpcy5hbmdsZXM9W107dGhpcy5hbmdsZXMyPVtdO3RoaXMucHJvcGVydGllcz17J2NoYXJ0LmJhY2tncm91bmQuYXhlcyc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5heGVzLmNvbG9yJzonYmxhY2snLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6JyNjY2MnLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuc2l6ZSc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb3VudCc6NSwnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQucmFkaXVzJzpudWxsLCdjaGFydC5hbmdsZXMuc3RhcnQnOjAsJ2NoYXJ0LmNvbG9ycyc6WydyZ2JhKDI1NSwwLDAsMC41KScsJ3JnYmEoMjU1LDI1NSwwLDAuNSknLCdyZ2JhKDAsMjU1LDI1NSwwLjUpJywncmdiKDAsMjU1LDApJywnZ3JheScsJ2JsdWUnLCdyZ2IoMjU1LDEyOCwyNTUpJywnZ3JlZW4nLCdwaW5rJywnZ3JheScsJ2FxdWEnXSwnY2hhcnQubGluZXdpZHRoJzoxLCdjaGFydC5jb2xvcnMuc2VxdWVudGlhbCc6ZmFsc2UsJ2NoYXJ0LmNvbG9ycy5hbHBoYSc6bnVsbCwnY2hhcnQubWFyZ2luJzowLCdjaGFydC5zdHJva2VzdHlsZSc6JyNhYWEnLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzonI2FhYScsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzowLCdjaGFydC5zaGFkb3cub2Zmc2V0eSc6MCwnY2hhcnQuc2hhZG93LmJsdXInOjE1LCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpdGxlLmhwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnZwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLngnOm51bGwsJ2NoYXJ0LnRpdGxlLnknOm51bGwsJ2NoYXJ0LnRpdGxlLmhhbGlnbic6bnVsbCwnY2hhcnQudGl0bGUudmFsaWduJzpudWxsLCdjaGFydC5sYWJlbHMnOm51bGwsJ2NoYXJ0LmxhYmVscy5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLnBvc2l0aW9uJzonY2VudGVyJywnY2hhcnQubGFiZWxzLmF4ZXMnOiduc2V3JywnY2hhcnQubGFiZWxzLmJveGVkJzpmYWxzZSwnY2hhcnQubGFiZWxzLm9mZnNldCc6MCwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LmhhbGlnbic6J3JpZ2h0JywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzonc3F1YXJlJywnY2hhcnQua2V5LnJvdW5kZWQnOnRydWUsJ2NoYXJ0LmtleS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmtleS5jb2xvcnMnOm51bGwsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6ZmFsc2UsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzonYmxhY2snLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5hbm5vdGF0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzonYmxhY2snLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlLCdjaGFydC56b29tLmFjdGlvbic6J3pvb20nLCdjaGFydC5yZXNpemFibGUnOmZhbHNlLCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCc6WzAsMF0sJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LnltYXgnOm51bGwsJ2NoYXJ0LnltaW4nOjAsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzpudWxsLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC52YXJpYW50Jzonc3RhY2tlZCcsJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmRlcHRoJzoxMCwnY2hhcnQuZXhwbG9kZWQnOjAsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJzoxLCdjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5yYWRpdXMnOnRydWUsJ2NoYXJ0LmFuaW1hdGlvbi5ncm93Lm11bHRpcGxpZXInOjEsJ2NoYXJ0LmxhYmVscy5jb3VudCc6NSwnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQnOmZhbHNlLCdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCc6bnVsbCwnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMCwyNTUsMCwwLjUpJywnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmZvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldPXBhcnNlRmxvYXQodGhpcy5kYXRhW2ldKTt9ZWxzZSBpZih0eXBlb2YgdGhpcy5kYXRhW2ldPT09J29iamVjdCcpe2Zvcih2YXIgaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2ope2lmKHR5cGVvZiB0aGlzLmRhdGFbaV1bal09PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldW2pdPXBhcnNlRmxvYXQodGhpcy5kYXRhW2ldW2pdKTt9fX19XG52YXIgbGluZWFyX2RhdGE9UkdyYXBoLmFycmF5TGluZWFyaXplKHRoaXMuZGF0YSk7Zm9yKHZhciBpPTA7aTxsaW5lYXJfZGF0YS5sZW5ndGg7KytpKXt0aGlzW1wiJFwiK2ldPXt9O31cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PT0nY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNwb2tlcycpbmFtZT0nY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnO2lmKG5hbWU9PT0nY2hhcnQuc2VnbWVudHMuaGlnaGxpZ2h0JyluYW1lPSdjaGFydC5zZWdtZW50LmhpZ2hsaWdodCc7aWYobmFtZT09PSdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuZmlsbCcpbmFtZT0nY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc7aWYobmFtZT09PSdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuc3Ryb2tlJyluYW1lPSdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnO3Byb3BbbmFtZS50b0xvd2VyQ2FzZSgpXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMucmFkaXVzPShtYS5taW4oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKTt0aGlzLmNlbnRlcng9KChjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvMikrdGhpcy5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeT0oKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikrdGhpcy5ndXR0ZXJUb3A7dGhpcy5hbmdsZXM9W107dGhpcy5hbmdsZXMyPVtdO3RoaXMudG90YWw9MDt0aGlzLnN0YXJ0UmFkaWFucz1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTt0aGlzLmNvb3Jkc1RleHQ9W107aWYocHJvcFsnY2hhcnQua2V5J10mJnByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aD4wJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGg+PTMpe3RoaXMuY2VudGVyeD10aGlzLmNlbnRlcngtdGhpcy5ndXR0ZXJSaWdodCs1O31cbmlmKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ4J109PSdudW1iZXInKXRoaXMuY2VudGVyeD1wcm9wWydjaGFydC5jZW50ZXJ4J107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXT09J251bWJlcicpdGhpcy5jZW50ZXJ5PXByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZih0eXBlb2YgcHJvcFsnY2hhcnQucmFkaXVzJ109PSdudW1iZXInKXRoaXMucmFkaXVzPXByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxuaWYocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJzNkJykhPT0tMSl7dmFyIHNjYWxlWD0xLjU7dGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybShzY2FsZVgsMCwwLDEsKGNhLndpZHRoKnNjYWxlWC1jYS53aWR0aCkqIC0wLjUsMCk7fVxudGhpcy5kcmF3QmFja2dyb3VuZCgpO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCczZCcpIT09LTEpe1JHLnNldFNoYWRvdyh0aGlzLCdyZ2JhKDAsMCwwLDAuMzUpJywwLDE1LDI1KTtmb3IodmFyIGk9cHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuZGVwdGgnXTtpPjA7aS09MSl7dGhpcy5jZW50ZXJ5LT0xO3RoaXMuZHJhd1Jvc2Uoe3N0b3JlQW5nbGVzOmZhbHNlfSk7Ukcuc2V0U2hhZG93KHRoaXMsJ3JnYmEoMCwwLDAsMCknLDAsMCwwKTtmb3IodmFyIGo9MCxsZW49dGhpcy5hbmdsZXMubGVuZ3RoO2o8bGVuO2orPTEpe3ZhciBhPXRoaXMuYW5nbGVzW2pdO3BhMihjbyxbJ2InLCdtJyxhWzRdLGFbNV0sJ2EnLGFbNF0sYVs1XSxhWzNdKzEuNSxhWzBdLTAuMDEsYVsxXSswLjAxLGZhbHNlLCdjJywnZicsJ3JnYmEoMCwwLDAsMC4xKSddKTt9fX1cbnRoaXMuZHJhd1Jvc2UoKTt0aGlzLmRyYXdMYWJlbHMoKTtjby5zdHJva2VTdHlsZT0ncmdiYSgwLDAsMCwwKSdcbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSl7UkcuQWxsb3dBZGp1c3RpbmcodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0J10pe2lmKCFSRy5hbGxvd1NlZ21lbnRIaWdobGlnaHQpe2FsZXJ0KCdbV0FSTklOR10gVGhlIHNlZ21lbnQgaGlnaGxpZ2h0IGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0IC0gaGF2ZSB5b3UgaW5jbHVkZWQgdGhlIGR5bmFtaWMgbGlicmFyeT8nKTt9XG5SRy5hbGxvd1NlZ21lbnRIaWdobGlnaHQoe29iamVjdDp0aGlzLGNvdW50OnR5cGVvZiBwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCddPT09J251bWJlcic/cHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuY291bnQnXTp0aGlzLmRhdGEubGVuZ3RoLGZpbGw6cHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCddLHN0cm9rZTpwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnXX0pO31cbmlmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmRyYXdCYWNrZ3JvdW5kPXRoaXMuRHJhd0JhY2tncm91bmQ9ZnVuY3Rpb24oKVxue2NvLmxpbmVXaWR0aD0xO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCddKXtpZih0eXBlb2YocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvdW50J10pPT0nbnVtYmVyJyl7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNpemUnXT10aGlzLnJhZGl1cy9wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY291bnQnXTt9XG5jby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXTtmb3IodmFyIGk9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNpemUnXTtpPD10aGlzLnJhZGl1cztpKz1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuc2l6ZSddKXtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4K2ksdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxpLDAsUkcuVFdPUEksZmFsc2UpO31cbmNvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2lmKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQucmFkaWFscyddIT09J251bWJlcicpe3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzJ109dGhpcy5kYXRhLmxlbmd0aH1cbnZhciBudW09KDM2MC9wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQucmFkaWFscyddKTtmb3IodmFyIGk9bnVtO2k8PTM2MDtpKz1udW0pe2NvLmFyYyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLCgoaS8oMTgwL1JHLlBJKSktUkcuSEFMRlBJKSt0aGlzLnN0YXJ0UmFkaWFucywoKChpKzAuMDAwMSkvKDE4MC9SRy5QSSkpLVJHLkhBTEZQSSkrdGhpcy5zdGFydFJhZGlhbnMsZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5KTt9XG5jby5zdHJva2UoKTt9XG5pZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmF4ZXMnXSl7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5heGVzLmNvbG9yJ107Y28ubW92ZVRvKHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyxtYS5yb3VuZCh0aGlzLmNlbnRlcnkpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzLG1hLnJvdW5kKHRoaXMuY2VudGVyeSkpO2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMpLHRoaXMuY2VudGVyeS01KTtjby5saW5lVG8obWEucm91bmQodGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKSx0aGlzLmNlbnRlcnkrNSk7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5LTUpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMpLHRoaXMuY2VudGVyeSs1KTtmb3IodmFyIGk9KHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyk7aTwodGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzKTtpKz0odGhpcy5yYWRpdXMvNSkpe2NvLm1vdmVUbyhtYS5yb3VuZChpKSx0aGlzLmNlbnRlcnktMyk7Y28ubGluZVRvKG1hLnJvdW5kKGkpLHRoaXMuY2VudGVyeSszLjUpO31cbmZvcih2YXIgaT0odGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKTtpPCh0aGlzLmNlbnRlcnkrdGhpcy5yYWRpdXMpO2krPSh0aGlzLnJhZGl1cy81KSl7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC0zLG1hLnJvdW5kKGkpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4KzMsbWEucm91bmQoaSkpO31cbmNvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngpLHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cyk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuY2VudGVyeCksdGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LTUsbWEucm91bmQodGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCs1LG1hLnJvdW5kKHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cykpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngtNSxtYS5yb3VuZCh0aGlzLmNlbnRlcnkrdGhpcy5yYWRpdXMpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4KzUsbWEucm91bmQodGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7fVxucGEyKGNvLCdiIGMnKTt9O3RoaXMuZHJhd1Jvc2U9dGhpcy5EcmF3Um9zZT1mdW5jdGlvbigpXG57dmFyIG1heD0wLGRhdGE9dGhpcy5kYXRhLG1hcmdpbj1SRy5kZWdyZWVzMlJhZGlhbnMocHJvcFsnY2hhcnQubWFyZ2luJ10pLG9wdD1hcmd1bWVudHNbMF18fHt9O2NvLmxpbmVXaWR0aD1wcm9wWydjaGFydC5saW5ld2lkdGgnXTtpZihSRy5pc051bGwocHJvcFsnY2hhcnQueW1heCddKSl7Zm9yKHZhciBpPTA7aTxkYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZiBkYXRhW2ldPT0nbnVtYmVyJyl7bWF4PW1hLm1heChtYXgsZGF0YVtpXSk7fWVsc2UgaWYodHlwZW9mIGRhdGFbaV09PSdvYmplY3QnJiZwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignbm9uLWVxdWktYW5ndWxhcicpIT09LTEpe21heD1tYS5tYXgobWF4LGRhdGFbaV1bMF0pO31lbHNle21heD1tYS5tYXgobWF4LFJHLmFycmF5U3VtKGRhdGFbaV0pKTt9fVxudGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOm1heCwnbWluJzowLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSwnc2NhbGUucm91bmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sJ3VuaXRzLnByZSc6cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sJ3VuaXRzLnBvc3QnOnByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt9ZWxzZXt2YXIgeW1heD1wcm9wWydjaGFydC55bWF4J107dGhpcy5zY2FsZTI9UkcuZ2V0U2NhbGUyKHRoaXMseydtYXgnOnltYXgsJ3N0cmljdCc6dHJ1ZSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnBvaW50Jzpwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCdzY2FsZS5kZWNpbWFscyc6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwneWxhYmVscy5jb3VudCc6cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTt0aGlzLm1heD10aGlzLnNjYWxlMi5tYXh9XG50aGlzLnN1bT1SRy5hcnJheVN1bShkYXRhKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7Y28uc3Ryb2tlKCk7aWYocHJvcFsnY2hhcnQuY29sb3JzLmFscGhhJ10pe2NvLmdsb2JhbEFscGhhPXByb3BbJ2NoYXJ0LmNvbG9ycy5hbHBoYSddO31cbnZhciBzZXF1ZW50aWFsSW5kZXg9MDtpZih0eXBlb2YocHJvcFsnY2hhcnQudmFyaWFudCddKT09J3N0cmluZycmJnByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCdub24tZXF1aS1hbmd1bGFyJykhPT0tMSl7dmFyIHRvdGFsPTA7Zm9yKHZhciBpPTA7aTxkYXRhLmxlbmd0aDsrK2kpe3RvdGFsKz1kYXRhW2ldWzFdO31cbmlmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5zZXRTaGFkb3codGhpcyxwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10scHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7fVxuZm9yKHZhciBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSl7dmFyIHNlZ21lbnRSYWRpYW5zPSgodGhpcy5kYXRhW2ldWzFdL3RvdGFsKSpSRy5UV09QSSk7dmFyIHJhZGl1cz0oKHRoaXMuZGF0YVtpXVswXS1wcm9wWydjaGFydC55bWluJ10pLyh0aGlzLm1heC1wcm9wWydjaGFydC55bWluJ10pKSp0aGlzLnJhZGl1cztyYWRpdXM9cmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5ncm93Lm11bHRpcGxpZXInXTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVswXTtpZihwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11baV07fVxuY28uYmVnaW5QYXRoKCk7dmFyIHN0YXJ0QW5nbGU9KHRoaXMuc3RhcnRSYWRpYW5zKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddKS1SRy5IQUxGUEkrbWFyZ2luO3ZhciBlbmRBbmdsZT0oKHRoaXMuc3RhcnRSYWRpYW5zK3NlZ21lbnRSYWRpYW5zKSpwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSktUkcuSEFMRlBJLW1hcmdpbjt2YXIgZXhwbG9kZWQ9dGhpcy5nZXRleHBsb2RlZChpLHN0YXJ0QW5nbGUsZW5kQW5nbGUscHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk7dmFyIGV4cGxvZGVkWD1leHBsb2RlZFswXTt2YXIgZXhwbG9kZWRZPWV4cGxvZGVkWzFdO2NvLmFyYyh0aGlzLmNlbnRlcngrZXhwbG9kZWRYLHRoaXMuY2VudGVyeStleHBsb2RlZFkscHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4ucmFkaXVzJ10/cmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddOnJhZGl1cyxzdGFydEFuZ2xlLGVuZEFuZ2xlLDApO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngrZXhwbG9kZWRYLHRoaXMuY2VudGVyeStleHBsb2RlZFkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt0aGlzLmFuZ2xlc1tpXT1bc3RhcnRBbmdsZSxlbmRBbmdsZSwwLHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLnJhZGl1cyddP3JhZGl1cypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXTpyYWRpdXMsdGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZLGNvLnN0cm9rZVN0eWxlLGNvLmZpbGxTdHlsZV07c2VxdWVudGlhbEluZGV4Kys7dGhpcy5zdGFydFJhZGlhbnMrPXNlZ21lbnRSYWRpYW5zO31cbmlmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXtSRy5ub1NoYWRvdyh0aGlzKTt0aGlzLnJlZHJhd1Jvc2UoKTt9fWVsc2V7dmFyIHNlcXVlbnRpYWxDb2xvckluZGV4PTA7aWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLnNldFNoYWRvdyh0aGlzLHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXt2YXIgc2VnbWVudFJhZGlhbnM9KDEvdGhpcy5kYXRhLmxlbmd0aCkqUkcuVFdPUEk7aWYodHlwZW9mIHRoaXMuZGF0YVtpXT09J251bWJlcicpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10pe2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtpXTt9XG52YXIgcmFkaXVzPSgodGhpcy5kYXRhW2ldLXByb3BbJ2NoYXJ0LnltaW4nXSkvKHRoaXMubWF4LXByb3BbJ2NoYXJ0LnltaW4nXSkpKnRoaXMucmFkaXVzO3JhZGl1cz1yYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLmdyb3cubXVsdGlwbGllciddO3ZhciBzdGFydEFuZ2xlPSh0aGlzLnN0YXJ0UmFkaWFucypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSktUkcuSEFMRlBJK21hcmdpbjt2YXIgZW5kQW5nbGU9KHRoaXMuc3RhcnRSYWRpYW5zKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddKSsoc2VnbWVudFJhZGlhbnMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10pLVJHLkhBTEZQSS1tYXJnaW47dmFyIGV4cGxvZGVkPXRoaXMuZ2V0ZXhwbG9kZWQoaSxzdGFydEFuZ2xlLGVuZEFuZ2xlLHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pO3ZhciBleHBsb2RlZFg9ZXhwbG9kZWRbMF07dmFyIGV4cGxvZGVkWT1leHBsb2RlZFsxXTtjby5hcmModGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZLHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLnJhZGl1cyddP3JhZGl1cypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXTpyYWRpdXMsc3RhcnRBbmdsZSxlbmRBbmdsZSwwKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7aWYoZW5kQW5nbGU9PTApe31cbnRoaXMuYW5nbGVzW2ldPVtzdGFydEFuZ2xlLGVuZEFuZ2xlLDAscmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLHRoaXMuY2VudGVyeCtleHBsb2RlZFgsdGhpcy5jZW50ZXJ5K2V4cGxvZGVkWSxjby5zdHJva2VTdHlsZSxjby5maWxsU3R5bGVdO3NlcXVlbnRpYWxJbmRleCsrO31lbHNlIGlmKHR5cGVvZih0aGlzLmRhdGFbaV0pPT0nb2JqZWN0Jyl7dmFyIG1hcmdpbj1wcm9wWydjaGFydC5tYXJnaW4nXS8oMTgwL1JHLlBJKTtpZighdGhpcy5hbmdsZXMyW2ldKXt0aGlzLmFuZ2xlczJbaV09W107fVxuZm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysrail7dmFyIHN0YXJ0QW5nbGU9KHRoaXMuc3RhcnRSYWRpYW5zKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddKS1SRy5IQUxGUEkrbWFyZ2luO3ZhciBlbmRBbmdsZT0odGhpcy5zdGFydFJhZGlhbnMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10pKyhzZWdtZW50UmFkaWFucypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSktUkcuSEFMRlBJLW1hcmdpbjt2YXIgZXhwbG9kZWQ9dGhpcy5nZXRleHBsb2RlZChpLHN0YXJ0QW5nbGUsZW5kQW5nbGUscHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk7dmFyIGV4cGxvZGVkWD1leHBsb2RlZFswXTt2YXIgZXhwbG9kZWRZPWV4cGxvZGVkWzFdO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW2pdO2lmKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10pe2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVtzZXF1ZW50aWFsQ29sb3JJbmRleCsrXTt9XG5pZihqPT0wKXtjby5iZWdpblBhdGgoKTt2YXIgc3RhcnRSYWRpdXM9MDt2YXIgZW5kUmFkaXVzPSgodGhpcy5kYXRhW2ldW2pdLXByb3BbJ2NoYXJ0LnltaW4nXSkvKHRoaXMubWF4LXByb3BbJ2NoYXJ0LnltaW4nXSkpKnRoaXMucmFkaXVzO2VuZFJhZGl1cz1lbmRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLmdyb3cubXVsdGlwbGllciddO2NvLmFyYyh0aGlzLmNlbnRlcngrZXhwbG9kZWRYLHRoaXMuY2VudGVyeStleHBsb2RlZFkscHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4ucmFkaXVzJ10/ZW5kUmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddOmVuZFJhZGl1cyxzdGFydEFuZ2xlLGVuZEFuZ2xlLDApO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngrZXhwbG9kZWRYLHRoaXMuY2VudGVyeStleHBsb2RlZFkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt0aGlzLmFuZ2xlc1tzZXF1ZW50aWFsSW5kZXgrK109W3N0YXJ0QW5nbGUsZW5kQW5nbGUsMCxlbmRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sdGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZLGNvLnN0cm9rZVN0eWxlLGNvLmZpbGxTdHlsZV07dGhpcy5hbmdsZXMyW2ldW2pdPVtzdGFydEFuZ2xlLGVuZEFuZ2xlLDAsZW5kUmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLHRoaXMuY2VudGVyeCtleHBsb2RlZFgsdGhpcy5jZW50ZXJ5K2V4cGxvZGVkWSxjby5zdHJva2VTdHlsZSxjby5maWxsU3R5bGVdO31lbHNle2NvLmJlZ2luUGF0aCgpO3ZhciBzdGFydFJhZGl1cz1lbmRSYWRpdXM7dmFyIGVuZFJhZGl1cz0oKCh0aGlzLmRhdGFbaV1bal0tcHJvcFsnY2hhcnQueW1pbiddKS8odGhpcy5tYXgtcHJvcFsnY2hhcnQueW1pbiddKSkqdGhpcy5yYWRpdXMpK3N0YXJ0UmFkaXVzO2VuZFJhZGl1cz1lbmRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLmdyb3cubXVsdGlwbGllciddO2NvLmFyYyh0aGlzLmNlbnRlcngrZXhwbG9kZWRYLHRoaXMuY2VudGVyeStleHBsb2RlZFksc3RhcnRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sc3RhcnRBbmdsZSxlbmRBbmdsZSwwKTtjby5hcmModGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZLGVuZFJhZGl1cypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSxlbmRBbmdsZSxzdGFydEFuZ2xlLHRydWUpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt0aGlzLmFuZ2xlc1tzZXF1ZW50aWFsSW5kZXgrK109W3N0YXJ0QW5nbGUsZW5kQW5nbGUsc3RhcnRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sZW5kUmFkaXVzKnByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLHRoaXMuY2VudGVyeCtleHBsb2RlZFgsdGhpcy5jZW50ZXJ5K2V4cGxvZGVkWSxjby5zdHJva2VTdHlsZSxjby5maWxsU3R5bGVdO3RoaXMuYW5nbGVzMltpXVtqXT1bc3RhcnRBbmdsZSxlbmRBbmdsZSxzdGFydFJhZGl1cypwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSxlbmRSYWRpdXMqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sdGhpcy5jZW50ZXJ4K2V4cGxvZGVkWCx0aGlzLmNlbnRlcnkrZXhwbG9kZWRZLGNvLnN0cm9rZVN0eWxlLGNvLmZpbGxTdHlsZV07fX19XG50aGlzLnN0YXJ0UmFkaWFucys9c2VnbWVudFJhZGlhbnM7fVxuaWYocHJvcFsnY2hhcnQuc2hhZG93J10pe1JHLm5vU2hhZG93KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LnNoYWRvdyddKXt0aGlzLnJlZHJhd1Jvc2UoKTt9fVxuaWYocHJvcFsnY2hhcnQuY29sb3JzLmFscGhhJ10pe2NvLmdsb2JhbEFscGhhPTE7fVxuaWYocHJvcFsnY2hhcnQudGl0bGUnXSl7UkcuZHJhd1RpdGxlKHRoaXMscHJvcFsnY2hhcnQudGl0bGUnXSwoY2EuaGVpZ2h0LzIpLXRoaXMucmFkaXVzLHRoaXMuY2VudGVyeCxwcm9wWydjaGFydC50aXRsZS5zaXplJ10/cHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKzIpO319O3RoaXMucmVkcmF3Um9zZT1mdW5jdGlvbigpXG57dmFyIGFuZ2xlcz10aGlzLmFuZ2xlcztmb3IodmFyIGk9MDtpPGFuZ2xlcy5sZW5ndGg7KytpKXtwYTIoY28sJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZSBjIGYgJSBmICUgJyxhbmdsZXNbaV1bNF0sYW5nbGVzW2ldWzVdLGFuZ2xlc1tpXVsyXSxhbmdsZXNbaV1bMF0sYW5nbGVzW2ldWzFdLGFuZ2xlc1tpXVs0XSxhbmdsZXNbaV1bNV0sYW5nbGVzW2ldWzNdLGFuZ2xlc1tpXVsxXSxhbmdsZXNbaV1bMF0sYW5nbGVzW2ldWzZdLGFuZ2xlc1tpXVs3XSk7fX07dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57Y28ubGluZVdpZHRoPTE7dmFyIGtleT1wcm9wWydjaGFydC5rZXknXTtpZihrZXkmJmtleS5sZW5ndGgpe1JHLkRyYXdLZXkodGhpcyxrZXkscHJvcFsnY2hhcnQuY29sb3JzJ10pO31cbmNvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Y28uc3Ryb2tlU3R5bGU9J2JsYWNrJzt2YXIgcmFkaXVzPXRoaXMucmFkaXVzLGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSxheGVzPXByb3BbJ2NoYXJ0LmxhYmVscy5heGVzJ10udG9Mb3dlckNhc2UoKSxkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXSx1bml0c19wb3N0PXByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxjZW50ZXJ4PXRoaXMuY2VudGVyeCxjZW50ZXJ5PXRoaXMuY2VudGVyeSsocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJzNkJykhPT0tMT9wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCddOjApO2lmKHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMnXT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmxhYmVscyddKXt0aGlzLkRyYXdDaXJjdWxhckxhYmVscyhjbyxwcm9wWydjaGFydC5sYWJlbHMnXSxmb250LHNpemUscmFkaXVzKzEwKTt9XG5pZih0eXBlb2YocHJvcFsnY2hhcnQudGV4dC5zaXplLnNjYWxlJ10pPT0nbnVtYmVyJyl7c2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUuc2NhbGUnXTt9XG52YXIgY29sb3I9J3JnYmEoMjU1LDI1NSwyNTUsMC44KSc7aWYoYXhlcy5pbmRleE9mKCduJyk+LTEpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107KytpKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0xMCwneSc6Y2VudGVyeS0ocmFkaXVzKigoaSsxKS9wcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSkpLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J3JpZ2h0JywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nLmZpbGwnOmNvbG9yLCdib3VuZGluZy5zdHJva2UnOnByb3BbJ2NoYXJ0LmxhYmVscy5ib3hlZCddPydibGFjayc6J3JnYmEoMCwwLDAsMCknLCd0YWcnOidzY2FsZSd9KTt9fVxuaWYoYXhlcy5pbmRleE9mKCdzJyk+LTEpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107KytpKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0xMCwneSc6Y2VudGVyeSsocmFkaXVzKigoaSsxKS9wcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSkpLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6J3JpZ2h0JywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nLmZpbGwnOmNvbG9yLCdib3VuZGluZy5zdHJva2UnOnByb3BbJ2NoYXJ0LmxhYmVscy5ib3hlZCddPydibGFjayc6J3JnYmEoMCwwLDAsMCknLCd0YWcnOidzY2FsZSd9KTt9fVxuaWYoYXhlcy5pbmRleE9mKCdlJyk+LTEpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107KytpKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeCsocmFkaXVzKigoaSsxKS9wcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSkpLCd5JzpjZW50ZXJ5KzEwLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsJ2JvdW5kaW5nJzp0cnVlLCdib3VuZGluZy5maWxsJzpjb2xvciwnYm91bmRpbmcuc3Ryb2tlJzpwcm9wWydjaGFydC5sYWJlbHMuYm94ZWQnXT8nYmxhY2snOidyZ2JhKDAsMCwwLDApJywndGFnJzonc2NhbGUnfSk7fX1cbmlmKGF4ZXMuaW5kZXhPZigndycpPi0xKXtmb3IodmFyIGk9MDtpPHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddOysraSl7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnNpemUsJ3gnOmNlbnRlcngtKHJhZGl1cyooKGkrMSkvcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10pKSwneSc6Y2VudGVyeSsxMCwndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW2ldLCd2YWxpZ24nOid0b3AnLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6dHJ1ZSwnYm91bmRpbmcuZmlsbCc6Y29sb3IsJ2JvdW5kaW5nLnN0cm9rZSc6cHJvcFsnY2hhcnQubGFiZWxzLmJveGVkJ10/J2JsYWNrJzoncmdiYSgwLDAsMCwwKScsJ3RhZyc6J3NjYWxlJ30pO319XG5pZihSRy50cmltKGF4ZXMpLmxlbmd0aD4wKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeCwneSc6Y2VudGVyeSwndGV4dCc6dHlwZW9mIHByb3BbJ2NoYXJ0LnltaW4nXT09PSdudW1iZXInP1JHLm51bWJlckZvcm1hdCh0aGlzLE51bWJlcihwcm9wWydjaGFydC55bWluJ10pLnRvRml4ZWQocHJvcFsnY2hhcnQueW1pbiddPT09MD8nMCc6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpOicwJywndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nLmZpbGwnOmNvbG9yLCdib3VuZGluZy5zdHJva2UnOnByb3BbJ2NoYXJ0LmxhYmVscy5ib3hlZCddPydibGFjayc6J3JnYmEoMCwwLDAsMCknLCd0YWcnOidzY2FsZSd9KTt9fTt0aGlzLmRyYXdDaXJjdWxhckxhYmVscz10aGlzLkRyYXdDaXJjdWxhckxhYmVscz1mdW5jdGlvbihjbyxsYWJlbHMsZm9udCxzaXplLHJhZGl1cylcbnt2YXIgdmFyaWFudD1wcm9wWydjaGFydC52YXJpYW50J10scG9zaXRpb249cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10scmFkaXVzPXJhZGl1cys1K3Byb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQnXSxjZW50ZXJ4PXRoaXMuY2VudGVyeCxjZW50ZXJ5PXRoaXMuY2VudGVyeSsocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJzNkJykhPT0tMT9wcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCddOjApLGxhYmVsc0NvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sYW5nbGVzPXRoaXMuYW5nbGVzXG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtpZih0eXBlb2YodmFyaWFudCk9PSdzdHJpbmcnJiZ2YXJpYW50LmluZGV4T2YoJ25vbi1lcXVpLWFuZ3VsYXInKSE9PS0xKXt2YXIgYT1OdW1iZXIoYW5nbGVzW2ldWzBdKSsoKGFuZ2xlc1tpXVsxXS1hbmdsZXNbaV1bMF0pLzIpO31lbHNle3ZhciBhPShSRy5UV09QSS90aGlzLmRhdGEubGVuZ3RoKSooaSsxKS0oUkcuVFdPUEkvKHRoaXMuZGF0YS5sZW5ndGgqMikpO3ZhciBhPWEtUkcuSEFMRlBJKyhwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXT09J2VkZ2UnPygoUkcuVFdPUEkvdGhpcy5kYXRhLmxlbmd0aCkvMik6MCk7fVxudmFyIHg9Y2VudGVyeCsobWEuY29zKGEpKnJhZGl1cyk7dmFyIHk9Y2VudGVyeSsobWEuc2luKGEpKnJhZGl1cyk7aWYoeD5jZW50ZXJ4KXtoYWxpZ249J2xlZnQnO31lbHNlIGlmKE1hdGgucm91bmQoeCk9PWNlbnRlcngpe2hhbGlnbj0nY2VudGVyJzt9ZWxzZXtoYWxpZ249J3JpZ2h0Jzt9XG5SRy50ZXh0Mih0aGlzLHsnY29sb3InOmxhYmVsc0NvbG9yLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4Jzp4LCd5Jzp5LCd0ZXh0JzpTdHJpbmcobGFiZWxzW2ldKSwnaGFsaWduJzpoYWxpZ24sJ3ZhbGlnbic6J2NlbnRlcicsJ3RhZyc6J2xhYmVscyd9KTt9fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0U2VnbWVudD1mdW5jdGlvbihlKVxue1JHLmZpeEV2ZW50T2JqZWN0KGUpO3ZhciBhbmdsZXM9dGhpcy5hbmdsZXM7dmFyIHJldD1bXTt2YXIgb3B0PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e3JhZGl1czp0cnVlfTtmb3IodmFyIGk9MDtpPGFuZ2xlcy5sZW5ndGg7KytpKXt2YXIgYW5nbGVTdGFydD1hbmdsZXNbaV1bMF07dmFyIGFuZ2xlRW5kPWFuZ2xlc1tpXVsxXTt2YXIgcmFkaXVzU3RhcnQ9b3B0LnJhZGl1cz09PWZhbHNlPzA6YW5nbGVzW2ldWzJdO3ZhciByYWRpdXNFbmQ9b3B0LnJhZGl1cz09PWZhbHNlP3RoaXMucmFkaXVzOmFuZ2xlc1tpXVszXTt2YXIgY2VudGVyWD1hbmdsZXNbaV1bNF07dmFyIGNlbnRlclk9YW5nbGVzW2ldWzVdO3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdLWNlbnRlclg7dmFyIG1vdXNlWT1tb3VzZVhZWzFdLWNlbnRlclk7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKGNlbnRlclgsY2VudGVyWSxyYWRpdXNTdGFydD9yYWRpdXNTdGFydDowLjAxLGFuZ2xlU3RhcnQsYW5nbGVFbmQsZmFsc2UpO2NvLmFyYyhjZW50ZXJYLGNlbnRlclkscmFkaXVzRW5kLGFuZ2xlRW5kLGFuZ2xlU3RhcnQsdHJ1ZSk7Y28uY2xvc2VQYXRoKCk7aWYoY28uaXNQb2ludEluUGF0aChtb3VzZVhZWzBdLG1vdXNlWFlbMV0pKXthbmdsZXNbaV1bNl09aTtpZihSRy5wYXJzZVRvb2x0aXBUZXh0KXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sYW5nbGVzW2ldWzZdKTt9XG5hbmdsZXNbaV1bJ29iamVjdCddPXRoaXM7YW5nbGVzW2ldWyd4J109YW5nbGVzW2ldWzRdO2FuZ2xlc1tpXVsneSddPWFuZ2xlc1tpXVs1XTthbmdsZXNbaV1bJ2FuZ2xlLnN0YXJ0J109YW5nbGVzW2ldWzBdO2FuZ2xlc1tpXVsnYW5nbGUuZW5kJ109YW5nbGVzW2ldWzFdO2FuZ2xlc1tpXVsncmFkaXVzLnN0YXJ0J109YW5nbGVzW2ldWzJdO2FuZ2xlc1tpXVsncmFkaXVzLmVuZCddPWFuZ2xlc1tpXVszXTthbmdsZXNbaV1bJ2luZGV4J109YW5nbGVzW2ldWzZdO2FuZ2xlc1tpXVsndG9vbHRpcCddPXRvb2x0aXA/dG9vbHRpcDpudWxsO3JldHVybiBhbmdsZXNbaV07fX1cbnJldHVybiBudWxsO307dGhpcy5nZXRFeHBsb2RlZD10aGlzLmdldGV4cGxvZGVkPWZ1bmN0aW9uKGluZGV4LHN0YXJ0QW5nbGUsZW5kQW5nbGUsZXhwbG9kZWQpXG57dmFyIGV4cGxvZGVkeCxleHBsb2RlZHk7aWYodHlwZW9mKGV4cGxvZGVkKT09J29iamVjdCcmJnR5cGVvZihleHBsb2RlZFtpbmRleF0pPT0nbnVtYmVyJyl7ZXhwbG9kZWR4PU1hdGguY29zKCgoZW5kQW5nbGUtc3RhcnRBbmdsZSkvMikrc3RhcnRBbmdsZSkqZXhwbG9kZWRbaW5kZXhdO2V4cGxvZGVkeT1NYXRoLnNpbigoKGVuZEFuZ2xlLXN0YXJ0QW5nbGUpLzIpK3N0YXJ0QW5nbGUpKmV4cGxvZGVkW2luZGV4XTt9ZWxzZSBpZih0eXBlb2YoZXhwbG9kZWQpPT0nbnVtYmVyJyl7ZXhwbG9kZWR4PU1hdGguY29zKCgoZW5kQW5nbGUtc3RhcnRBbmdsZSkvMikrc3RhcnRBbmdsZSkqZXhwbG9kZWQ7ZXhwbG9kZWR5PU1hdGguc2luKCgoZW5kQW5nbGUtc3RhcnRBbmdsZSkvMikrc3RhcnRBbmdsZSkqZXhwbG9kZWQ7fWVsc2V7ZXhwbG9kZWR4PTA7ZXhwbG9kZWR5PTA7fVxucmV0dXJuW2V4cGxvZGVkeCxleHBsb2RlZHldO307dGhpcy5hbGxvd1Rvb2x0aXBzPXRoaXMuQWxsb3dUb29sdGlwcz1mdW5jdGlvbigpXG57UkcuUHJlTG9hZFRvb2x0aXBJbWFnZXModGhpcyk7UkcuSW5zdGFsbFdpbmRvd01vdXNlZG93blRvb2x0aXBMaXN0ZW5lcih0aGlzKTtSRy5JbnN0YWxsQ2FudmFzTW91c2Vtb3ZlVG9vbHRpcExpc3RlbmVyKHRoaXMpO1JHLkluc3RhbGxDYW52YXNNb3VzZXVwVG9vbHRpcExpc3RlbmVyKHRoaXMpO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pe2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO3JldHVybjt9XG5jby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ107Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107Y28uYXJjKHNoYXBlWyd4J10sc2hhcGVbJ3knXSxzaGFwZVsncmFkaXVzLmVuZCddLHNoYXBlWydhbmdsZS5zdGFydCddLHNoYXBlWydhbmdsZS5lbmQnXSxmYWxzZSk7aWYoc2hhcGVbJ3JhZGl1cy5zdGFydCddPjApe2NvLmFyYyhzaGFwZVsneCddLHNoYXBlWyd5J10sc2hhcGVbJ3JhZGl1cy5zdGFydCddLHNoYXBlWydhbmdsZS5lbmQnXSxzaGFwZVsnYW5nbGUuc3RhcnQnXSx0cnVlKTt9ZWxzZXtjby5saW5lVG8oc2hhcGVbJ3gnXSxzaGFwZVsneSddKTt9XG5jby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7fX07dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIHJhZGl1cz1SRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVhZWzBdLG1vdXNlWFlbMV0pO2lmKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCczZCcpIT09LTEpe3JhZGl1cy89LTE7fVxuaWYobW91c2VYWVswXT4odGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKSYmbW91c2VYWVswXTwodGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzKSYmbW91c2VYWVsxXT4odGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSYmbW91c2VYWVsxXTwodGhpcy5jZW50ZXJ5K3RoaXMucmFkaXVzKSYmcmFkaXVzPD10aGlzLnJhZGl1cyl7cmV0dXJuIHRoaXM7fX07dGhpcy5nZXRSYWRpdXM9ZnVuY3Rpb24odmFsdWUpXG57aWYodmFsdWU8MHx8dmFsdWU+dGhpcy5tYXgpe3JldHVybiBudWxsO31cbnZhciByPSh2YWx1ZS90aGlzLm1heCkqdGhpcy5yYWRpdXM7cmV0dXJuIHI7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGV4dC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRpdGxlLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO31cbmZvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQuY29sb3JzJ10ubGVuZ3RoOysraSl7cHJvcFsnY2hhcnQuY29sb3JzJ11baV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11baV0pO31cbmlmKCFSRy5pc19udWxsKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSkpe2Zvcih2YXIgaT0wO2k8cHJvcFsnY2hhcnQua2V5LmNvbG9ycyddLmxlbmd0aDsrK2kpe3Byb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXVtpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0pO319XG5wcm9wWydjaGFydC50ZXh0LmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtwcm9wWydjaGFydC50aXRsZS5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3J8fHR5cGVvZihjb2xvcikhPSdzdHJpbmcnKXtyZXR1cm4gY29sb3I7fVxuaWYoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQ9Y28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSwwLHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMpO3ZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MTtqPHBhcnRzLmxlbmd0aDsrK2ope2dyYWQuYWRkQ29sb3JTdG9wKGoqZGlmZixSRy50cmltKHBhcnRzW2pdKSk7fX1cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0PWZ1bmN0aW9uKGluZGV4KVxue3ZhciBzZWdtZW50cz10aGlzLmFuZ2xlczI7Zm9yKHZhciBpPTA7aTx0aGlzLmFuZ2xlczIubGVuZ3RoO2krPTEpe2NvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aD0yO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmFyYyhzZWdtZW50c1tpXVtpbmRleF1bNF0sc2VnbWVudHNbaV1baW5kZXhdWzVdLHNlZ21lbnRzW2ldW2luZGV4XVsyXSxzZWdtZW50c1tpXVtpbmRleF1bMF0sc2VnbWVudHNbaV1baW5kZXhdWzFdLGZhbHNlKTtjby5hcmMoc2VnbWVudHNbaV1baW5kZXhdWzRdLHNlZ21lbnRzW2ldW2luZGV4XVs1XSxzZWdtZW50c1tpXVtpbmRleF1bM10sc2VnbWVudHNbaV1baW5kZXhdWzFdLHNlZ21lbnRzW2ldW2luZGV4XVswXSx0cnVlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7fVxucmV0dXJufTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuaWYodHlwZW9mIHRoaXNbdHlwZV0hPT0nZnVuY3Rpb24nKXt0aGlzW3R5cGVdPWZ1bmM7fWVsc2V7UkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307dGhpcy5leHBsb2RlPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXM/b3B0LmZyYW1lczozMDt2YXIgZnJhbWU9MDt2YXIgZXhwbG9kZWRNYXg9bWEubWF4KGNhLndpZHRoLGNhLmhlaWdodCk7dmFyIGV4cGxvZGVkPU51bWJlcih0aGlzLkdldCgnZXhwbG9kZWQnKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue2V4cGxvZGVkPShmcmFtZS9mcmFtZXMpKmV4cGxvZGVkTWF4O29iai5TZXQoJ2V4cGxvZGVkJyxleHBsb2RlZCk7UkcuY2xlYXIoY2EpO1JHLnJlZHJhd0NhbnZhcyhjYSk7aWYoZnJhbWUrKzxmcmFtZXMpe1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy5yb3VuZHJvYmluPXRoaXMucm91bmRSb2Jpbj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzO3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fVxudmFyIGZyYW1lcz1vcHQuZnJhbWVzfHwzMDt2YXIgZnJhbWU9MDt2YXIgb3JpZ2luYWxfbWFyZ2luPXByb3BbJ2NoYXJ0Lm1hcmdpbiddO3ZhciBtYXJnaW49KDM2MC90aGlzLmRhdGEubGVuZ3RoKS8yO3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt0aGlzLlNldCgnY2hhcnQubWFyZ2luJyxtYXJnaW4pO3RoaXMuU2V0KCdjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InLDApO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWUrKzxmcmFtZXMpe29iai5zZXQoJ2FuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvcicsZnJhbWUvZnJhbWVzKTtvYmouc2V0KCdtYXJnaW4nLChmcmFtZS9mcmFtZXMpKm9yaWdpbmFsX21hcmdpbik7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle29iai5zZXQoJ2FuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvcicsMSk7b2JqLnNldCgnbWFyZ2luJyxvcmlnaW5hbF9tYXJnaW4pO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmltcGxvZGU9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7dmFyIGV4cGxvZGVkTWF4PW1hLm1heChjYS53aWR0aCxjYS5oZWlnaHQpO3ZhciBleHBsb2RlZD1leHBsb2RlZE1heDtmdW5jdGlvbiBpdGVyYXRvcigpXG57ZXhwbG9kZWQ9ZXhwbG9kZWRNYXgtKChmcmFtZS9mcmFtZXMpKmV4cGxvZGVkTWF4KTtvYmouU2V0KCdleHBsb2RlZCcsZXhwbG9kZWQpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmKGZyYW1lKys8ZnJhbWVzKXtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpczt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e307dmFyIGNhbGxiYWNrPWFyZ3VtZW50c1sxXXx8ZnVuY3Rpb24oKXt9O3ZhciBmcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTA7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue29iai5TZXQoJ2FuaW1hdGlvbi5ncm93Lm11bHRpcGxpZXInLGZyYW1lL2ZyYW1lcyk7UkcuY2xlYXIoY2EpO1JHLnJlZHJhd0NhbnZhcyhjYSk7aWYoZnJhbWU8ZnJhbWVzKXtmcmFtZSsrO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucm9zZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///230\n");

/***/ }),
/* 231 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.RScatter = RGraph.Rscatter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && typeof conf.data[0][0] === 'number') {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = arguments[1][i];\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  this.id = conf.id;\n  this.canvas = document.getElementById(this.id);\n  this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'rscatter';this.hasTooltips = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (typeof this.data[i][j][0] === 'string') {\n        this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n      }\n      if (typeof this.data[i][j][1] === 'string') {\n        this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n      }\n    }\n  }\n  this.properties = { 'chart.background.color': 'transparent', 'chart.background.grid': true, 'chart.background.grid.diagonals': true, 'chart.background.grid.diagonals.count': null, 'chart.background.grid.radials': true, 'chart.background.grid.radials.count': null, 'chart.background.grid.linewidth': 1, 'chart.background.grid.color': '#ccc', 'chart.radius': null, 'chart.colors': [], 'chart.colors.default': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.axes': 'nsew', 'chart.labels.axes.background': 'rgba(255,255,255,0.8)', 'chart.labels.count': 5, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot': 3, 'chart.tooltips.coords.page': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.ymax': null, 'chart.ymin': 0, 'chart.tickmarks': 'cross', 'chart.ticksize': 3, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.highlight.stroke': 'transparent', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.point.radius': 3, 'chart.axes.color': 'black', 'chart.axes.numticks': null, 'chart.axes.caps': true, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.line': false, 'chart.line.close': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['black'], 'chart.line.shadow': false, 'chart.line.shadow.color': 'black', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, idx = 0; i < this.data.length; ++i) {\n    for (var j = 0, len = this.data[i].length; j < len; j += 1, idx += 1) {\n      this['$' + idx] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.count') name = 'chart.segment.highlight.count';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.coords = [];this.coords2 = [];this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var max = prop['chart.ymax'];var min = prop['chart.ymin'];if (typeof max == 'number') {\n      this.max = max;this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });\n    } else {\n      for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          this.max = Math.max(this.max, this.data[i][j][1]);\n        }\n      }\n      this.min = prop['chart.ymin'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': min, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - prop['chart.gutter.right'] + 5;\n    }\n    if (_typeof(prop['chart.key']) == 'object' && RG.is_array(prop['chart.key']) && prop['chart.key'][0]) {\n      prop['chart.colors'] = [];for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          if (typeof this.data[i][j][2] == 'string') {\n            prop['chart.colors'].push(this.data[i][j][2]);\n          }\n        }\n      }\n    }\n    this.Set('chart.tooltips', []);for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        if (typeof this.data[i][j][3] == 'string') {\n          prop['chart.tooltips'].push(this.data[i][j][3]);\n        }\n      }\n    }\n    co.beginPath();this.DrawBackground();this.DrawRscatter();this.DrawLabels();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius - 10, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.background.color'] != 'transparent') {\n      pa2(co, ['b', 'a', this.centerx, this.centery, this.radius, 0, 2 * ma.PI, -1, 'f', prop['chart.background.color']]);\n    }\n    var gridEnabled = prop['chart.background.grid'];if (gridEnabled) {\n      co.lineWidth = prop['chart.background.grid.linewidth'];if (prop['chart.background.grid.radials']) {\n        co.strokeStyle = prop['chart.background.grid.color'];if (RG.isNull(prop['chart.background.grid.radials.count'])) {\n          prop['chart.background.grid.radials.count'] = prop['chart.labels.count'];\n        }\n        var r = this.radius / prop['chart.background.grid.radials.count'];for (var i = 0, len = this.radius; i <= len; i += r) {\n          co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, 0);\n        }\n        co.stroke();\n      }\n      if (prop['chart.background.grid.diagonals']) {\n        co.strokeStyle = prop['chart.background.grid.color'];co.beginPath();var inc = 360 / (prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8);for (var i = inc; i < 360; i += inc) {\n          co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI, (i + 0.01) / (180 / RG.PI) - RG.HALFPI, 0);co.lineTo(this.centerx, this.centery);\n        }\n        co.stroke();\n      }\n    }\n    co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.axes.color'];co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));if (prop['chart.axes.caps']) {\n      co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);\n    }\n    if (!RG.isNull(prop['chart.axes.numticks'])) {\n      var numticks = prop['chart.axes.numticks'];\n    } else {\n      var numticks = prop['chart.labels.count'];\n    }\n    var caps = prop['chart.axes.caps'];if (numticks) {\n      for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / numticks) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / numticks) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n    }\n    co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);if (prop['chart.axes.caps']) {\n      co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));\n    }\n    co.closePath();co.stroke();\n  };this.drawRscatter = this.DrawRscatter = function () {\n    for (var dataset = 0; dataset < this.data.length; dataset += 1) {\n      var data = this.data[dataset];this.coords2[dataset] = [];var drawPoints = function drawPoints(obj) {\n        for (var i = 0; i < data.length; ++i) {\n          var d1 = data[i][0],\n              d2 = data[i][1],\n              a = d1 / (180 / RG.PI),\n              r = (d2 - prop['chart.ymin']) / (obj.scale2.max - obj.scale2.min) * obj.radius,\n              x = ma.sin(a) * r,\n              y = ma.cos(a) * r,\n              color = data[i][2] ? data[i][2] : prop['chart.colors.default'],\n              tooltip = data[i][3] ? data[i][3] : null;\n          if (tooltip && String(tooltip).length) {\n            obj.hasTooltips = true;\n          }\n          x = x + obj.centerx;y = obj.centery - y;obj.drawTick(x, y, color);obj.coords.push([x, y, color, tooltip]);obj.coords2[dataset].push([x, y, color, tooltip]);\n        }\n      };\n      drawPoints(this);if (prop['chart.line']) {\n        this.drawLine(dataset);\n      }\n    }\n  };this.drawLine = function (idx) {\n    var opt = { dataset: idx, coords: this.coords2[idx], color: prop['chart.line.colors'][idx], shadow: prop['chart.line.shadow'], shadowColor: prop['chart.line.shadow.color'], shadowOffsetX: prop['chart.line.shadow.offsetx'], shadowOffsetY: prop['chart.line.shadow.offsety'], shadowBlur: prop['chart.line.shadow.blur'], linewidth: prop['chart.line.linewidth'] };co.beginPath();co.strokeStyle = this.parseSingleColorForGradient(opt.color);co.lineWidth = _typeof(prop['chart.line.linewidth']) === 'object' ? prop['chart.line.linewidth'][idx] : prop['chart.line.linewidth'];co.lineCap = 'round';if (opt.shadow) {\n      RG.setShadow(this, opt.shadowColor, opt.shadowOffsetX, opt.shadowOffsetY, opt.shadowBlur);\n    }\n    for (var i = 0; i < this.coords2[idx].length; ++i) {\n      if (i === 0) {\n        co.moveTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);var startCoords = RG.arrayClone(this.coords2[idx]);\n      } else {\n        co.lineTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);\n      }\n    }\n    if (typeof prop['chart.line.close'] === 'boolean' && prop['chart.line.close'] || _typeof(prop['chart.line.close']) === 'object' && prop['chart.line.close'][idx]) {\n      co.lineTo(this.coords2[idx][0][0], this.coords2[idx][0][1]);\n    }\n    co.stroke();RG.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var key = prop['chart.key'];var r = this.radius;var axesColor = prop['chart.axes.color'];var color = prop['chart.text.color'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var decimals = prop['chart.scale.decimals'];var centerx = this.centerx;var centery = this.centery;co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, r);\n    }\n    var offset = 10;var centered = false;if (axesColor === 'rgba(0,0,0,0)' || axesColor === 'rgb(0,0,0)' || axesColor === 'transparent') {\n      offset = 0;centered = true;\n    }\n    for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n      if (axes.indexOf('n') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery - r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('s') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery + r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('e') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('w') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });\n    }\n    if (prop['chart.labels.axes'].length > 0 && prop['chart.scale.zerostart']) {\n      RG.text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': RG.numberFormat(this, Number(this.scale2.min).toFixed(this.scale2.decimals), this.scale2.units_pre, this.scale2.units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': prop['chart.labels.axes.background'], 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n    if (key && key.length) {\n      RG.drawKey(this, key, prop['chart.colors']);\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (context, labels, font_face, font_size, r) {\n    var r = r + 10,\n        color = prop['chart.labels.color'];for (var i = 0; i < labels.length; ++i) {\n      var a = 360 / labels.length * (i + 1) - 360 / (labels.length * 2);var a = a - 90 + (prop['chart.labels.position'] == 'edge' ? 360 / labels.length / 2 : 0);var x = ma.cos(a / (180 / RG.PI)) * r;var y = ma.sin(a / (180 / RG.PI)) * r;RG.Text2(this, { 'color': color, 'font': font_face, 'size': font_size, 'x': this.centerx + x, 'y': this.centery + y, 'text': String(labels[i]), 'valign': 'center', 'halign': this.centerx + x > this.centerx ? 'left' : 'right', 'tag': 'labels' });\n    }\n  };this.drawTick = this.DrawTick = function (x, y, color) {\n    var tickmarks = prop['chart.tickmarks'];var ticksize = prop['chart.ticksize'];co.strokeStyle = color;co.fillStyle = color;var prevLinewidth = co.lineWidth;co.lineWidth = 1;if (tickmarks == 'cross') {\n      co.beginPath();co.moveTo(x + ticksize, y + ticksize);co.lineTo(x - ticksize, y - ticksize);co.stroke();co.beginPath();co.moveTo(x - ticksize, y + ticksize);co.lineTo(x + ticksize, y - ticksize);co.stroke();\n    } else if (tickmarks == 'circle') {\n      co.beginPath();co.arc(x, y, ticksize, 0, 6.2830, false);co.fill();\n    } else if (tickmarks == 'square') {\n      co.beginPath();co.fillRect(x - ticksize, y - ticksize, 2 * ticksize, 2 * ticksize);co.fill();\n    } else if (tickmarks == 'diamond') {\n      co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x + ticksize, y);co.lineTo(x, y + ticksize);co.lineTo(x - ticksize, y);co.closePath();co.fill();\n    } else if (tickmarks == 'plus') {\n      co.lineWidth = 1;co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x, y + ticksize);co.moveTo(x - ticksize, y);co.lineTo(x + ticksize, y);co.stroke();\n    }\n    co.lineWidth = prevLinewidth;\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var i = 0, len = this.coords.length; i < len; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltip = this.coords[i][3];if (mouseX < x + offset && mouseX > x - offset && mouseY < y + offset && mouseY > y - offset) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: x, 2: y, 3: i, 'object': this, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var centerx = this.centerx;var centery = this.centery;var radius = this.radius;if (mouseX > centerx - radius && mouseX < centerx + radius && mouseY > centery - radius && mouseY < centery + radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    var max = this.max;if (value < 0 || value > max) {\n      return null;\n    }\n    var r = value / max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.colors.default'] = RG.arrayClone(prop['chart.colors.default']);this.original_colors['chart.background.grid.color'] = RG.arrayClone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.arrayClone(prop['chart.background.color']);this.original_colors['chart.segment.highlight.stroke'] = RG.arrayClone(prop['chart.segment.highlight.stroke']);this.original_colors['chart.segment.highlight.fill'] = RG.arrayClone(prop['chart.segment.highlight.fill']);\n    }\n    for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        this.data[i][j][2] = this.parseSingleColorForGradient(this.data[i][j][2]);\n      }\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.colors.default'] = this.parseSingleColorForGradient(prop['chart.colors.default']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords2 && this.coords2[index] && this.coords2[index].length) {\n      this.coords2[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 2, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);\n      }\n    }\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucnNjYXR0ZXIuanM/ZjNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlJTY2F0dGVyPVJHcmFwaC5Sc2NhdHRlcj1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt0aGlzLmRhdGE9bmV3IEFycmF5KGNvbmYuZGF0YS5sZW5ndGgpO3RoaXMuZGF0YT1SR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO2lmKHR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuZGF0YVswXT09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5kYXRhWzBdWzBdPT09J251bWJlcicpe3ZhciB0bXA9UkdyYXBoLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtjb25mLmRhdGE9bmV3IEFycmF5KCk7Y29uZi5kYXRhWzBdPVJHcmFwaC5hcnJheUNsb25lKHRtcCk7dGhpcy5kYXRhPVJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YSk7fX1lbHNle3ZhciBjb25mPXtpZDpjb25mfTtjb25mLmRhdGE9YXJndW1lbnRzWzFdO3RoaXMuZGF0YT1bXTtpZihhcmd1bWVudHNbMV1bMF0mJmFyZ3VtZW50c1sxXVswXVswXSYmdHlwZW9mIGFyZ3VtZW50c1sxXVswXVswXT09J29iamVjdCcpe2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzWzFdLmxlbmd0aDsrK2kpe3RoaXMuZGF0YVtpXT1hcmd1bWVudHNbMV1baV07fX1lbHNle2Zvcih2YXIgaT0xO2k8YXJndW1lbnRzLmxlbmd0aDsrK2kpe3RoaXMuZGF0YVtpLTFdPVJHcmFwaC5hcnJheUNsb25lKGFyZ3VtZW50c1tpXSk7fX19XG50aGlzLmlkPWNvbmYuaWRcbnRoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpXG50aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dD90aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy50eXBlPSdyc2NhdHRlcic7dGhpcy5oYXNUb29sdGlwcz1mYWxzZTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLmNlbnRlcng9MDt0aGlzLmNlbnRlcnk9MDt0aGlzLnJhZGl1cz0wO3RoaXMubWF4PTA7Zm9yKHZhciBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSl7Zm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysrail7aWYodHlwZW9mIHRoaXMuZGF0YVtpXVtqXVswXT09PSdzdHJpbmcnKXt0aGlzLmRhdGFbaV1bal1bMF09cGFyc2VGbG9hdCh0aGlzLmRhdGFbaV1bal1bMF0pO31cbmlmKHR5cGVvZiB0aGlzLmRhdGFbaV1bal1bMV09PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldW2pdWzFdPXBhcnNlRmxvYXQodGhpcy5kYXRhW2ldW2pdWzFdKTt9fX1cbnRoaXMucHJvcGVydGllcz17J2NoYXJ0LmJhY2tncm91bmQuY29sb3InOid0cmFuc3BhcmVudCcsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscyc6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscy5jb3VudCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzLmNvdW50JzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQubGluZXdpZHRoJzoxLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOicjY2NjJywnY2hhcnQucmFkaXVzJzpudWxsLCdjaGFydC5jb2xvcnMnOltdLCdjaGFydC5jb2xvcnMuZGVmYXVsdCc6J2JsYWNrJywnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQudGl0bGUuaHBvcyc6bnVsbCwnY2hhcnQudGl0bGUudnBvcyc6bnVsbCwnY2hhcnQudGl0bGUuYm9sZCc6dHJ1ZSwnY2hhcnQudGl0bGUuZm9udCc6bnVsbCwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmxhYmVscyc6bnVsbCwnY2hhcnQubGFiZWxzLmNvbG9yJzpudWxsLCdjaGFydC5sYWJlbHMuYXhlcyc6J25zZXcnLCdjaGFydC5sYWJlbHMuYXhlcy5iYWNrZ3JvdW5kJzoncmdiYSgyNTUsMjU1LDI1NSwwLjgpJywnY2hhcnQubGFiZWxzLmNvdW50Jzo1LCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQua2V5JzpudWxsLCdjaGFydC5rZXkuYmFja2dyb3VuZCc6J3doaXRlJywnY2hhcnQua2V5LnBvc2l0aW9uJzonZ3JhcGgnLCdjaGFydC5rZXkuaGFsaWduJzoncmlnaHQnLCdjaGFydC5rZXkuc2hhZG93JzpmYWxzZSwnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6JyM2NjYnLCdjaGFydC5rZXkuc2hhZG93LmJsdXInOjMsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCc6MiwnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzoyLCdjaGFydC5rZXkucG9zaXRpb24uZ3V0dGVyLmJveGVkJzpmYWxzZSwnY2hhcnQua2V5LnBvc2l0aW9uLngnOm51bGwsJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzpudWxsLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkucm91bmRlZCc6dHJ1ZSwnY2hhcnQua2V5LmxpbmV3aWR0aCc6MSwnY2hhcnQua2V5LmNvbG9ycyc6bnVsbCwnY2hhcnQua2V5LmludGVyYWN0aXZlJzpmYWxzZSwnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzoncmdiYSgyNTUsMCwwLDAuOSknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29ubW91c2Vtb3ZlJywnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5ob3RzcG90JzozLCdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQueW1heCc6bnVsbCwnY2hhcnQueW1pbic6MCwnY2hhcnQudGlja21hcmtzJzonY3Jvc3MnLCdjaGFydC50aWNrc2l6ZSc6MywnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOm51bGwsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LnNjYWxlLnJvdW5kJzpmYWxzZSwnY2hhcnQuc2NhbGUuemVyb3N0YXJ0Jzp0cnVlLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzondHJhbnNwYXJlbnQnLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmhpZ2hsaWdodC5wb2ludC5yYWRpdXMnOjMsJ2NoYXJ0LmF4ZXMuY29sb3InOidibGFjaycsJ2NoYXJ0LmF4ZXMubnVtdGlja3MnOm51bGwsJ2NoYXJ0LmF4ZXMuY2Fwcyc6dHJ1ZSwnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQnOmZhbHNlLCdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCc6bnVsbCwnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMCwyNTUsMCwwLjUpJywnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmxpbmUnOmZhbHNlLCdjaGFydC5saW5lLmNsb3NlJzpmYWxzZSwnY2hhcnQubGluZS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmxpbmUuY29sb3JzJzpbJ2JsYWNrJ10sJ2NoYXJ0LmxpbmUuc2hhZG93JzpmYWxzZSwnY2hhcnQubGluZS5zaGFkb3cuY29sb3InOidibGFjaycsJ2NoYXJ0LmxpbmUuc2hhZG93LmJsdXInOjIsJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJ31cbmZvcih2YXIgaT0wLGlkeD0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2Zvcih2YXIgaj0wLGxlbj10aGlzLmRhdGFbaV0ubGVuZ3RoO2o8bGVuO2orPTEsaWR4Kz0xKXt0aGlzWyckJytpZHhdPXt9fX1cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PT0nY2hhcnQuc2VnbWVudHMuaGlnaGxpZ2h0JyluYW1lPSdjaGFydC5zZWdtZW50LmhpZ2hsaWdodCc7aWYobmFtZT09PSdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuY291bnQnKW5hbWU9J2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmNvdW50JztpZihuYW1lPT09J2NoYXJ0LnNlZ21lbnRzLmhpZ2hsaWdodC5maWxsJyluYW1lPSdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJztpZihuYW1lPT09J2NoYXJ0LnNlZ21lbnRzLmhpZ2hsaWdodC5zdHJva2UnKW5hbWU9J2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSc7cHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5yYWRpdXM9KE1hdGgubWluKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0LGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMik7dGhpcy5jZW50ZXJ4PSgoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpLzIpK3RoaXMuZ3V0dGVyTGVmdDt0aGlzLmNlbnRlcnk9KChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wO3RoaXMuY29vcmRzPVtdO3RoaXMuY29vcmRzMj1bXTt0aGlzLmNvb3Jkc1RleHQ9W107aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmNlbnRlcngnXSk9PSdudW1iZXInKXRoaXMuY2VudGVyeD1wcm9wWydjaGFydC5jZW50ZXJ4J107aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmNlbnRlcnknXSk9PSdudW1iZXInKXRoaXMuY2VudGVyeT1wcm9wWydjaGFydC5jZW50ZXJ5J107aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnJhZGl1cyddKT09J251bWJlcicpdGhpcy5yYWRpdXM9cHJvcFsnY2hhcnQucmFkaXVzJ107aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG52YXIgbWF4PXByb3BbJ2NoYXJ0LnltYXgnXTt2YXIgbWluPXByb3BbJ2NoYXJ0LnltaW4nXTtpZih0eXBlb2YobWF4KT09J251bWJlcicpe3RoaXMubWF4PW1heDt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6bWF4LCdtaW4nOm1pbiwnc3RyaWN0Jzp0cnVlLCdzY2FsZS5kZWNpbWFscyc6TnVtYmVyKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddfSk7fWVsc2V7Zm9yKHZhciBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoO2krPTEpe2Zvcih2YXIgaj0wLGxlbj10aGlzLmRhdGFbaV0ubGVuZ3RoO2o8bGVuO2orPTEpe3RoaXMubWF4PU1hdGgubWF4KHRoaXMubWF4LHRoaXMuZGF0YVtpXVtqXVsxXSk7fX1cbnRoaXMubWluPXByb3BbJ2NoYXJ0LnltaW4nXTt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6dGhpcy5tYXgsJ21pbic6bWluLCdzY2FsZS5kZWNpbWFscyc6TnVtYmVyKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddfSk7dGhpcy5tYXg9dGhpcy5zY2FsZTIubWF4O31cbmlmKHByb3BbJ2NoYXJ0LmtleSddJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGg+MCYmcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoPj0zKXt0aGlzLmNlbnRlcng9dGhpcy5jZW50ZXJ4LXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddKzU7fVxuaWYodHlwZW9mKHByb3BbJ2NoYXJ0LmtleSddKT09J29iamVjdCcmJlJHLmlzX2FycmF5KHByb3BbJ2NoYXJ0LmtleSddKSYmcHJvcFsnY2hhcnQua2V5J11bMF0pe3Byb3BbJ2NoYXJ0LmNvbG9ycyddPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKz0xKXtmb3IodmFyIGo9MCxsZW49dGhpcy5kYXRhW2ldLmxlbmd0aDtqPGxlbjtqKz0xKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzJdPT0nc3RyaW5nJyl7cHJvcFsnY2hhcnQuY29sb3JzJ10ucHVzaCh0aGlzLmRhdGFbaV1bal1bMl0pO319fX1cbnRoaXMuU2V0KCdjaGFydC50b29sdGlwcycsW10pO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKz0xKXtmb3IodmFyIGo9MCxsZW49dGhpcy5kYXRhW2ldLmxlbmd0aDtqPGxlbjtqKz0xKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzNdPT0nc3RyaW5nJyl7cHJvcFsnY2hhcnQudG9vbHRpcHMnXS5wdXNoKHRoaXMuZGF0YVtpXVtqXVszXSk7fX19XG5jby5iZWdpblBhdGgoKTt0aGlzLkRyYXdCYWNrZ3JvdW5kKCk7dGhpcy5EcmF3UnNjYXR0ZXIoKTt0aGlzLkRyYXdMYWJlbHMoKTtpZihwcm9wWydjaGFydC5jb250ZXh0bWVudSddKXtSRy5TaG93Q29udGV4dCh0aGlzKTt9XG5pZihwcm9wWydjaGFydC50aXRsZSddKXtSRy5EcmF3VGl0bGUodGhpcyxwcm9wWydjaGFydC50aXRsZSddLHRoaXMuY2VudGVyeS10aGlzLnJhZGl1cy0xMCx0aGlzLmNlbnRlcngscHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddP3Byb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXTpwcm9wWydjaGFydC50ZXh0LnNpemUnXSsyKTt9XG5pZihwcm9wWydjaGFydC5yZXNpemFibGUnXSl7UkcuQWxsb3dSZXNpemluZyh0aGlzKTt9XG5SRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYocHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQnXSl7UkcuYWxsb3dTZWdtZW50SGlnaGxpZ2h0KHtvYmplY3Q6dGhpcyxjb3VudDp0eXBlb2YgcHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuY291bnQnXT09PSdudW1iZXInP3Byb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmNvdW50J106KChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGlhZ29uYWxzLmNvdW50J10/cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscy5jb3VudCddOihwcm9wWydjaGFydC5sYWJlbHMnXT9wcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg6OCkpKSxmaWxsOnByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXSxzdHJva2U6cHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ119KTt9XG5pZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZD10aGlzLkRyYXdCYWNrZ3JvdW5kPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10hPSd0cmFuc3BhcmVudCcpe3BhMihjbyxbJ2InLCdhJyx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLDAsMiptYS5QSSwtMSwnZicscHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddXSk7fVxudmFyIGdyaWRFbmFibGVkPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCddO2lmKGdyaWRFbmFibGVkKXtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmxpbmV3aWR0aCddO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzJ10pe2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO2lmKFJHLmlzTnVsbChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQucmFkaWFscy5jb3VudCddKSl7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMuY291bnQnXT1wcm9wWydjaGFydC5sYWJlbHMuY291bnQnXTt9XG52YXIgcj10aGlzLnJhZGl1cy9wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQucmFkaWFscy5jb3VudCddO2Zvcih2YXIgaT0wLGxlbj10aGlzLnJhZGl1cztpPD1sZW47aSs9cil7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksaSwwLFJHLlRXT1BJLDApO31cbmNvLnN0cm9rZSgpO31cbmlmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kaWFnb25hbHMnXSl7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7dmFyIGluYz0zNjAvKChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGlhZ29uYWxzLmNvdW50J10/cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscy5jb3VudCddOihwcm9wWydjaGFydC5sYWJlbHMnXT9wcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg6OCkpKTtmb3IodmFyIGk9aW5jO2k8MzYwO2krPWluYyl7Y28uYXJjKHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksdGhpcy5yYWRpdXMsKGkvKDE4MC9SRy5QSSkpLVJHLkhBTEZQSSwoKGkrMC4wMSkvKDE4MC9SRy5QSSkpLVJHLkhBTEZQSSwwKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSk7fVxuY28uc3Ryb2tlKCk7fX1cbmNvLmxpbmVXaWR0aD0xO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmF4ZXMuY29sb3InXTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzLE1hdGgucm91bmQodGhpcy5jZW50ZXJ5KSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cyxNYXRoLnJvdW5kKHRoaXMuY2VudGVyeSkpO2lmKHByb3BbJ2NoYXJ0LmF4ZXMuY2FwcyddKXtjby5tb3ZlVG8obWEucm91bmQodGhpcy5jZW50ZXJ4LXRoaXMucmFkaXVzKSx0aGlzLmNlbnRlcnktNSk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyksdGhpcy5jZW50ZXJ5KzUpO2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngrdGhpcy5yYWRpdXMpLHRoaXMuY2VudGVyeS01KTtjby5saW5lVG8obWEucm91bmQodGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzKSx0aGlzLmNlbnRlcnkrNSk7fVxuaWYoIVJHLmlzTnVsbChwcm9wWydjaGFydC5heGVzLm51bXRpY2tzJ10pKXt2YXIgbnVtdGlja3M9cHJvcFsnY2hhcnQuYXhlcy5udW10aWNrcyddfWVsc2V7dmFyIG51bXRpY2tzPXByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO31cbnZhciBjYXBzPXByb3BbJ2NoYXJ0LmF4ZXMuY2FwcyddO2lmKG51bXRpY2tzKXtmb3IodmFyIGk9KHRoaXMuY2VudGVyeC10aGlzLnJhZGl1cyk7aTwodGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzKTtpKz0odGhpcy5yYWRpdXMvbnVtdGlja3MpKXtjby5tb3ZlVG8obWEucm91bmQoaSksdGhpcy5jZW50ZXJ5LTMpO2NvLmxpbmVUbyhtYS5yb3VuZChpKSx0aGlzLmNlbnRlcnkrMyk7fVxuZm9yKHZhciBpPSh0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpO2k8KHRoaXMuY2VudGVyeSt0aGlzLnJhZGl1cyk7aSs9KHRoaXMucmFkaXVzL251bXRpY2tzKSl7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC0zLG1hLnJvdW5kKGkpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4KzMsbWEucm91bmQoaSkpO319XG5jby5tb3ZlVG8obWEucm91bmQodGhpcy5jZW50ZXJ4KSx0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngpLHRoaXMuY2VudGVyeSt0aGlzLnJhZGl1cyk7aWYocHJvcFsnY2hhcnQuYXhlcy5jYXBzJ10pe2NvLm1vdmVUbyh0aGlzLmNlbnRlcngtNSxtYS5yb3VuZCh0aGlzLmNlbnRlcnktdGhpcy5yYWRpdXMpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4KzUsbWEucm91bmQodGhpcy5jZW50ZXJ5LXRoaXMucmFkaXVzKSk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeC01LG1hLnJvdW5kKHRoaXMuY2VudGVyeSt0aGlzLnJhZGl1cykpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngrNSxtYS5yb3VuZCh0aGlzLmNlbnRlcnkrdGhpcy5yYWRpdXMpKTt9XG5jby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTt9O3RoaXMuZHJhd1JzY2F0dGVyPXRoaXMuRHJhd1JzY2F0dGVyPWZ1bmN0aW9uKClcbntmb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuZGF0YS5sZW5ndGg7ZGF0YXNldCs9MSl7dmFyIGRhdGE9dGhpcy5kYXRhW2RhdGFzZXRdO3RoaXMuY29vcmRzMltkYXRhc2V0XT1bXTt2YXIgZHJhd1BvaW50cz1mdW5jdGlvbihvYmopXG57Zm9yKHZhciBpPTA7aTxkYXRhLmxlbmd0aDsrK2kpe3ZhciBkMT1kYXRhW2ldWzBdLGQyPWRhdGFbaV1bMV0sYT1kMS8oMTgwL1JHLlBJKSxyPSgoZDItcHJvcFsnY2hhcnQueW1pbiddKS8ob2JqLnNjYWxlMi5tYXgtb2JqLnNjYWxlMi5taW4pKSpvYmoucmFkaXVzLHg9bWEuc2luKGEpKnIseT1tYS5jb3MoYSkqcixjb2xvcj1kYXRhW2ldWzJdP2RhdGFbaV1bMl06cHJvcFsnY2hhcnQuY29sb3JzLmRlZmF1bHQnXSx0b29sdGlwPWRhdGFbaV1bM10/ZGF0YVtpXVszXTpudWxsXG5pZih0b29sdGlwJiZTdHJpbmcodG9vbHRpcCkubGVuZ3RoKXtvYmouaGFzVG9vbHRpcHM9dHJ1ZTt9XG54PXgrb2JqLmNlbnRlcng7eT1vYmouY2VudGVyeS15O29iai5kcmF3VGljayh4LHksY29sb3IpO29iai5jb29yZHMucHVzaChbeCx5LGNvbG9yLHRvb2x0aXBdKTtvYmouY29vcmRzMltkYXRhc2V0XS5wdXNoKFt4LHksY29sb3IsdG9vbHRpcF0pO319XG5kcmF3UG9pbnRzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmxpbmUnXSl7dGhpcy5kcmF3TGluZShkYXRhc2V0KTt9fX07dGhpcy5kcmF3TGluZT1mdW5jdGlvbihpZHgpXG57dmFyIG9wdD17ZGF0YXNldDppZHgsY29vcmRzOnRoaXMuY29vcmRzMltpZHhdLGNvbG9yOnByb3BbJ2NoYXJ0LmxpbmUuY29sb3JzJ11baWR4XSxzaGFkb3c6cHJvcFsnY2hhcnQubGluZS5zaGFkb3cnXSxzaGFkb3dDb2xvcjpwcm9wWydjaGFydC5saW5lLnNoYWRvdy5jb2xvciddLHNoYWRvd09mZnNldFg6cHJvcFsnY2hhcnQubGluZS5zaGFkb3cub2Zmc2V0eCddLHNoYWRvd09mZnNldFk6cHJvcFsnY2hhcnQubGluZS5zaGFkb3cub2Zmc2V0eSddLHNoYWRvd0JsdXI6cHJvcFsnY2hhcnQubGluZS5zaGFkb3cuYmx1ciddLGxpbmV3aWR0aDpwcm9wWydjaGFydC5saW5lLmxpbmV3aWR0aCddfTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChvcHQuY29sb3IpO2NvLmxpbmVXaWR0aD10eXBlb2YgcHJvcFsnY2hhcnQubGluZS5saW5ld2lkdGgnXT09PSdvYmplY3QnP3Byb3BbJ2NoYXJ0LmxpbmUubGluZXdpZHRoJ11baWR4XTpwcm9wWydjaGFydC5saW5lLmxpbmV3aWR0aCddO2NvLmxpbmVDYXA9J3JvdW5kJztpZihvcHQuc2hhZG93KXtSRy5zZXRTaGFkb3codGhpcyxvcHQuc2hhZG93Q29sb3Isb3B0LnNoYWRvd09mZnNldFgsb3B0LnNoYWRvd09mZnNldFksb3B0LnNoYWRvd0JsdXIpO31cbmZvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMyW2lkeF0ubGVuZ3RoOysraSl7aWYoaT09PTApe2NvLm1vdmVUbyh0aGlzLmNvb3JkczJbaWR4XVtpXVswXSx0aGlzLmNvb3JkczJbaWR4XVtpXVsxXSk7dmFyIHN0YXJ0Q29vcmRzPVJHLmFycmF5Q2xvbmUodGhpcy5jb29yZHMyW2lkeF0pO31lbHNle2NvLmxpbmVUbyh0aGlzLmNvb3JkczJbaWR4XVtpXVswXSx0aGlzLmNvb3JkczJbaWR4XVtpXVsxXSk7fX1cbmlmKCh0eXBlb2YgcHJvcFsnY2hhcnQubGluZS5jbG9zZSddPT09J2Jvb2xlYW4nJiZwcm9wWydjaGFydC5saW5lLmNsb3NlJ10pfHwodHlwZW9mIHByb3BbJ2NoYXJ0LmxpbmUuY2xvc2UnXT09PSdvYmplY3QnJiZwcm9wWydjaGFydC5saW5lLmNsb3NlJ11baWR4XSkpe2NvLmxpbmVUbyh0aGlzLmNvb3JkczJbaWR4XVswXVswXSx0aGlzLmNvb3JkczJbaWR4XVswXVsxXSk7fVxuY28uc3Ryb2tlKCk7Ukcubm9TaGFkb3codGhpcyk7fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbntjby5saW5lV2lkdGg9MTtjby5maWxsU3R5bGU9J2JsYWNrJztjby5zdHJva2VTdHlsZT0nYmxhY2snO3ZhciBrZXk9cHJvcFsnY2hhcnQua2V5J107dmFyIHI9dGhpcy5yYWRpdXM7dmFyIGF4ZXNDb2xvcj1wcm9wWydjaGFydC5heGVzLmNvbG9yJ107dmFyIGNvbG9yPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgYXhlcz1wcm9wWydjaGFydC5sYWJlbHMuYXhlcyddLnRvTG93ZXJDYXNlKCk7dmFyIHVuaXRzX3ByZT1wcm9wWydjaGFydC51bml0cy5wcmUnXTt2YXIgdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGRlY2ltYWxzPXByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107dmFyIGNlbnRlcng9dGhpcy5jZW50ZXJ4O3ZhciBjZW50ZXJ5PXRoaXMuY2VudGVyeTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmKHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMnXT09J29iamVjdCcmJnByb3BbJ2NoYXJ0LmxhYmVscyddKXt0aGlzLkRyYXdDaXJjdWxhckxhYmVscyhjbyxwcm9wWydjaGFydC5sYWJlbHMnXSxmb250LHNpemUscik7fVxudmFyIG9mZnNldD0xMDt2YXIgY2VudGVyZWQ9ZmFsc2U7aWYoYXhlc0NvbG9yPT09J3JnYmEoMCwwLDAsMCknfHxheGVzQ29sb3I9PT0ncmdiKDAsMCwwKSd8fGF4ZXNDb2xvcj09PSd0cmFuc3BhcmVudCcpe29mZnNldD0wO2NlbnRlcmVkPXRydWU7fVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7aTxsZW47KytpKXtpZihheGVzLmluZGV4T2YoJ24nKT4tMSlSRy50ZXh0Mih0aGlzLHsndGFnJzonc2NhbGUnLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4LW9mZnNldCwneSc6Y2VudGVyeS0ociooKGkrMSkvbGVuKSksJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzpjZW50ZXJlZD8nY2VudGVyJzoncmlnaHQnLGJvdW5kaW5nOnRydWUsYm91bmRpbmdGaWxsOnByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJhY2tncm91bmQnXSxib3VuZGluZ1N0cm9rZToncmdiYSgwLDAsMCwwKSd9KTtpZihheGVzLmluZGV4T2YoJ3MnKT4tMSlSRy50ZXh0Mih0aGlzLHsndGFnJzonc2NhbGUnLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4LW9mZnNldCwneSc6Y2VudGVyeSsociooKGkrMSkvbGVuKSksJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzpjZW50ZXJlZD8nY2VudGVyJzoncmlnaHQnLGJvdW5kaW5nOnRydWUsYm91bmRpbmdGaWxsOnByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJhY2tncm91bmQnXSxib3VuZGluZ1N0cm9rZToncmdiYSgwLDAsMCwwKSd9KTtpZihheGVzLmluZGV4T2YoJ2UnKT4tMSlSRy50ZXh0Mih0aGlzLHsndGFnJzonc2NhbGUnLCdmb250Jzpmb250LCdzaXplJzpzaXplLCd4JzpjZW50ZXJ4KyhyKigoaSsxKS9sZW4pKSwneSc6Y2VudGVyeStvZmZzZXQsJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndmFsaWduJzpjZW50ZXJlZD8nY2VudGVyJzondG9wJywnaGFsaWduJzonY2VudGVyJyxib3VuZGluZzp0cnVlLGJvdW5kaW5nRmlsbDpwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5iYWNrZ3JvdW5kJ10sYm91bmRpbmdTdHJva2U6J3JnYmEoMCwwLDAsMCknfSk7aWYoYXhlcy5pbmRleE9mKCd3Jyk+LTEpUkcudGV4dDIodGhpcyx7J3RhZyc6J3NjYWxlJywnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeC0ociooKGkrMSkvbGVuKSksJ3knOmNlbnRlcnkrb2Zmc2V0LCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3ZhbGlnbic6Y2VudGVyZWQ/J2NlbnRlcic6J3RvcCcsJ2hhbGlnbic6J2NlbnRlcicsYm91bmRpbmc6dHJ1ZSxib3VuZGluZ0ZpbGw6cHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYmFja2dyb3VuZCddLGJvdW5kaW5nU3Ryb2tlOidyZ2JhKDAsMCwwLDApJ30pO31cbmlmKHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzJ10ubGVuZ3RoPjAmJnByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6Y2VudGVyeCwneSc6Y2VudGVyeSwndGV4dCc6UkcubnVtYmVyRm9ybWF0KHRoaXMsTnVtYmVyKHRoaXMuc2NhbGUyLm1pbikudG9GaXhlZCh0aGlzLnNjYWxlMi5kZWNpbWFscyksdGhpcy5zY2FsZTIudW5pdHNfcHJlLHRoaXMuc2NhbGUyLnVuaXRzX3Bvc3QpLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCdib3VuZGluZyc6dHJ1ZSwnYm91bmRpbmdGaWxsJzpwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5iYWNrZ3JvdW5kJ10sJ2JvdW5kaW5nU3Ryb2tlJzoncmdiYSgwLDAsMCwwKScsJ3RhZyc6J3NjYWxlJ30pO31cbmlmKGtleSYma2V5Lmxlbmd0aCl7UkcuZHJhd0tleSh0aGlzLGtleSxwcm9wWydjaGFydC5jb2xvcnMnXSk7fX07dGhpcy5kcmF3Q2lyY3VsYXJMYWJlbHM9dGhpcy5EcmF3Q2lyY3VsYXJMYWJlbHM9ZnVuY3Rpb24oY29udGV4dCxsYWJlbHMsZm9udF9mYWNlLGZvbnRfc2l6ZSxyKVxue3ZhciByPXIrMTAsY29sb3I9cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ107Zm9yKHZhciBpPTA7aTxsYWJlbHMubGVuZ3RoOysraSl7dmFyIGE9KDM2MC9sYWJlbHMubGVuZ3RoKSooaSsxKS0oMzYwLyhsYWJlbHMubGVuZ3RoKjIpKTt2YXIgYT1hLTkwKyhwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXT09J2VkZ2UnPygoMzYwL2xhYmVscy5sZW5ndGgpLzIpOjApO3ZhciB4PW1hLmNvcyhhLygxODAvUkcuUEkpKSpyO3ZhciB5PW1hLnNpbihhLygxODAvUkcuUEkpKSpyO1JHLlRleHQyKHRoaXMseydjb2xvcic6Y29sb3IsJ2ZvbnQnOmZvbnRfZmFjZSwnc2l6ZSc6Zm9udF9zaXplLCd4Jzp0aGlzLmNlbnRlcngreCwneSc6dGhpcy5jZW50ZXJ5K3ksJ3RleHQnOlN0cmluZyhsYWJlbHNbaV0pLCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOigodGhpcy5jZW50ZXJ4K3gpPnRoaXMuY2VudGVyeCk/J2xlZnQnOidyaWdodCcsJ3RhZyc6J2xhYmVscyd9KTt9fTt0aGlzLmRyYXdUaWNrPXRoaXMuRHJhd1RpY2s9ZnVuY3Rpb24oeCx5LGNvbG9yKVxue3ZhciB0aWNrbWFya3M9cHJvcFsnY2hhcnQudGlja21hcmtzJ107dmFyIHRpY2tzaXplPXByb3BbJ2NoYXJ0LnRpY2tzaXplJ107Y28uc3Ryb2tlU3R5bGU9Y29sb3I7Y28uZmlsbFN0eWxlPWNvbG9yO3ZhciBwcmV2TGluZXdpZHRoPWNvLmxpbmVXaWR0aDtjby5saW5lV2lkdGg9MTtpZih0aWNrbWFya3M9PSdjcm9zcycpe2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4K3RpY2tzaXplLHkrdGlja3NpemUpO2NvLmxpbmVUbyh4LXRpY2tzaXplLHktdGlja3NpemUpO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LXRpY2tzaXplLHkrdGlja3NpemUpO2NvLmxpbmVUbyh4K3RpY2tzaXplLHktdGlja3NpemUpO2NvLnN0cm9rZSgpO31lbHNlIGlmKHRpY2ttYXJrcz09J2NpcmNsZScpe2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh4LHksdGlja3NpemUsMCw2LjI4MzAsZmFsc2UpO2NvLmZpbGwoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdzcXVhcmUnKXtjby5iZWdpblBhdGgoKTtjby5maWxsUmVjdCh4LXRpY2tzaXplLHktdGlja3NpemUsMip0aWNrc2l6ZSwyKnRpY2tzaXplKTtjby5maWxsKCk7fWVsc2UgaWYodGlja21hcmtzPT0nZGlhbW9uZCcpe2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LHktdGlja3NpemUpO2NvLmxpbmVUbyh4K3RpY2tzaXplLHkpO2NvLmxpbmVUbyh4LHkrdGlja3NpemUpO2NvLmxpbmVUbyh4LXRpY2tzaXplLHkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdwbHVzJyl7Y28ubGluZVdpZHRoPTE7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgseS10aWNrc2l6ZSk7Y28ubGluZVRvKHgseSt0aWNrc2l6ZSk7Y28ubW92ZVRvKHgtdGlja3NpemUseSk7Y28ubGluZVRvKHgrdGlja3NpemUseSk7Y28uc3Ryb2tlKCk7fVxuY28ubGluZVdpZHRoPXByZXZMaW5ld2lkdGg7fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0UG9pbnQ9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVg9bW91c2VYWVswXTt2YXIgbW91c2VZPW1vdXNlWFlbMV07dmFyIG92ZXJIb3RzcG90PWZhbHNlO3ZhciBvZmZzZXQ9cHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdCddO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47KytpKXt2YXIgeD10aGlzLmNvb3Jkc1tpXVswXTt2YXIgeT10aGlzLmNvb3Jkc1tpXVsxXTt2YXIgdG9vbHRpcD10aGlzLmNvb3Jkc1tpXVszXTtpZihtb3VzZVg8KHgrb2Zmc2V0KSYmbW91c2VYPih4LW9mZnNldCkmJm1vdXNlWTwoeStvZmZzZXQpJiZtb3VzZVk+KHktb2Zmc2V0KSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO3JldHVybnswOnRoaXMsMTp4LDI6eSwzOmksJ29iamVjdCc6dGhpcywneCc6eCwneSc6eSwnaW5kZXgnOmksJ3Rvb2x0aXAnOnRvb2x0aXB9O319fTt0aGlzLmFsbG93VG9vbHRpcHM9dGhpcy5BbGxvd1Rvb2x0aXBzPWZ1bmN0aW9uKClcbntSRy5QcmVMb2FkVG9vbHRpcEltYWdlcyh0aGlzKTtSRy5JbnN0YWxsV2luZG93TW91c2Vkb3duVG9vbHRpcExpc3RlbmVyKHRoaXMpO1JHLkluc3RhbGxDYW52YXNNb3VzZW1vdmVUb29sdGlwTGlzdGVuZXIodGhpcyk7UkcuSW5zdGFsbENhbnZhc01vdXNldXBUb29sdGlwTGlzdGVuZXIodGhpcyk7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXtSRy5IaWdobGlnaHQuUG9pbnQodGhpcyxzaGFwZSk7fX07dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlWFlbMF07dmFyIG1vdXNlWT1tb3VzZVhZWzFdO3ZhciBjZW50ZXJ4PXRoaXMuY2VudGVyeDt2YXIgY2VudGVyeT10aGlzLmNlbnRlcnk7dmFyIHJhZGl1cz10aGlzLnJhZGl1cztpZihtb3VzZVg+KGNlbnRlcngtcmFkaXVzKSYmbW91c2VYPChjZW50ZXJ4K3JhZGl1cykmJm1vdXNlWT4oY2VudGVyeS1yYWRpdXMpJiZtb3VzZVk8KGNlbnRlcnkrcmFkaXVzKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5nZXRSYWRpdXM9ZnVuY3Rpb24odmFsdWUpXG57dmFyIG1heD10aGlzLm1heDtpZih2YWx1ZTwwfHx2YWx1ZT5tYXgpe3JldHVybiBudWxsO31cbnZhciByPSh2YWx1ZS9tYXgpKnRoaXMucmFkaXVzO3JldHVybiByO307dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXT1SRy5hcnJheV9jbG9uZSh0aGlzLmRhdGEpO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycy5kZWZhdWx0J109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMuZGVmYXVsdCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT1SRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10pO31cbmZvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKz0xKXtmb3IodmFyIGo9MCxsZW49dGhpcy5kYXRhW2ldLmxlbmd0aDtqPGxlbjtqKz0xKXt0aGlzLmRhdGFbaV1bal1bMl09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldW2pdWzJdKTt9fVxucHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wWydjaGFydC5jb2xvcnMuZGVmYXVsdCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycy5kZWZhdWx0J10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTtwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXSk7fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcnx8dHlwZW9mIGNvbG9yIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksMCx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzKTt2YXIgZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCxSRy50cmltKHBhcnRzWzBdKSk7Zm9yKHZhciBqPTE7ajxwYXJ0cy5sZW5ndGg7KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodD1mdW5jdGlvbihpbmRleClcbntpZih0aGlzLmNvb3JkczImJnRoaXMuY29vcmRzMltpbmRleF0mJnRoaXMuY29vcmRzMltpbmRleF0ubGVuZ3RoKXt0aGlzLmNvb3JkczJbaW5kZXhdLmZvckVhY2goZnVuY3Rpb24odmFsdWUsaWR4LGFycilcbntjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uYXJjKHZhbHVlWzBdLHZhbHVlWzFdLHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10rMiwwLFJHLlRXT1BJLGZhbHNlKTtjby5maWxsKCk7fSk7fX07dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXM9ZnVuY3Rpb24oKVxue2Zvcih2YXIgaT0wLGxlbj10aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddLmxlbmd0aDtpPGxlbjsrK2kpe2Zvcih2YXIgaj0wLGxlbjI9dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXS5sZW5ndGg7ajxsZW4yOysrail7dGhpcy5kYXRhW2ldW2pdWzJdPVJHLmFycmF5X2Nsb25lKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bal1bMl0pO319fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5yc2NhdHRlci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///231\n");

/***/ }),
/* 232 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Scatter = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && (typeof conf.data[0][0] === 'number' || typeof conf.data[0][0] === 'string')) {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = RGraph.arrayClone(arguments[1][i]);\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  if (!RGraph.isArray(this.data[0][0])) {\n    this.data = [this.data];\n  }\n  for (var i = 0, len = this.data.length; i < len; ++i) {\n    for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][0] === 'string') {\n        if (this.data[i][j][0].match(/^[.0-9]+$/)) {\n          this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n        } else if (this.data[i][j][0] === '') {\n          this.data[i][j][0] = 0;\n        }\n      }\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][1] === 'string') {\n        if (this.data[i][j][1].match(/[.0-9]+/)) {\n          this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n        } else if (this.data[i][j][1] === '') {\n          this.data[i][j][1] = 0;\n        }\n      }\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.canvas.__object__ = this;this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.max = 0;this.coords = [];this.type = 'scatter';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.hbars': null, 'chart.background.vbars': null, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.tooltips': [], 'chart.tooltips.effect': 'fade', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.hotspot': 3, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.units.pre': '', 'chart.units.post': '', 'chart.numyticks': 10, 'chart.tickmarks': 'cross', 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 5, 'chart.numxticks': true, 'chart.xaxis': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.colors.bubble.graduated': true, 'chart.xmin': 0, 'chart.xmax': 0, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.invert': false, 'chart.ylabels.specific': null, 'chart.ylabels.inside': false, 'chart.contextmenu': null, 'chart.defaultcolor': 'black', 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.linewidth': 1, 'chart.crosshairs.coords': false, 'chart.crosshairs.coords.fixed': true, 'chart.crosshairs.coords.fadeout': false, 'chart.crosshairs.coords.labels.x': 'X', 'chart.crosshairs.coords.labels.y': 'Y', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.line': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['green', 'red'], 'chart.line.shadow.color': 'rgba(0,0,0,0)', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.line.stepped': false, 'chart.line.visible': true, 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.boxplot.width': 1, 'chart.boxplot.capped': true, 'chart.resizable': false, 'chart.resize.handle.background': null }, _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.labels.specific.align', 'left'), _defineProperty(_properties, 'chart.xscale', false), _defineProperty(_properties, 'chart.xscale.units.pre', ''), _defineProperty(_properties, 'chart.xscale.units.post', ''), _defineProperty(_properties, 'chart.xscale.numlabels', 10), _defineProperty(_properties, 'chart.xscale.formatter', null), _defineProperty(_properties, 'chart.xscale.decimals', 0), _defineProperty(_properties, 'chart.xscale.thousand', ','), _defineProperty(_properties, 'chart.xscale.point', '.'), _defineProperty(_properties, 'chart.noendxtick', false), _defineProperty(_properties, 'chart.noendytick', true), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.animation.trace', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _properties);\n  for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (RGraph.isNull(this.data[i][j])) {\n        this.data[i][j] = [];\n      }\n      if (this.data[i][j] && typeof this.data[i][j][0] == 'string') {\n        this.data[i][j][0] = RGraph.parseDate(this.data[i][j][0]);\n      }\n    }\n  }\n  this.data_arr = [];for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      this.data_arr.push(this.data[i][j]);\n    }\n  }\n  for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas) {\n    alert('[SCATTER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.xticks') {\n      name == 'chart.numxticks';\n    }\n    if (name == 'chart.line.colors') {\n      prop['chart.colors'] = value;\n    }\n    if (name == 'chart.tooltip.hotspot') {\n      name = 'chart.tooltips.hotspot';\n    }\n    if (name == 'chart.yaxispos' && value != 'left' && value != 'right') {\n      alert(\"[SCATTER] chart.yaxispos should be left or right. You've set it to: '\" + value + \"' Changing it to left\");value = 'left';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center') {\n        alert('[SCATTER] (' + this.id + ') chart.xaxispos should be center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.noxaxis') {\n      name = 'chart.xaxis';value = !value;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] === 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.hasTooltips = false;var overHotspot = false;this.coords = [];if (typeof prop['chart.xmin'] == 'string') prop['chart.xmin'] = RG.parseDate(prop['chart.xmin']);if (typeof prop['chart.xmax'] == 'string') prop['chart.xmax'] = RG.parseDate(prop['chart.xmax']);if (!RGraph.ISOLD) {\n      this.Set('chart.tooltips', []);for (var i = 0, len = this.data.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (this.data[i][j] && this.data[i][j][3]) {\n            prop['chart.tooltips'].push(this.data[i][j][3]);this.hasTooltips = true;\n          } else {\n            prop['chart.tooltips'].push(null);\n          }\n        }\n      }\n    }\n    this.max = 0;if (typeof prop['chart.ymax'] === 'number') {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;var decimals = prop['chart.scale.decimals'];\n    } else {\n      var i = 0;var j = 0;for (i = 0, len = this.data.length; i < len; i += 1) {\n        for (j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (!RG.isNull(this.data[i][j]) && this.data[i][j][1] != null) {\n            this.max = Math.max(this.max, _typeof(this.data[i][j][1]) == 'object' ? RG.array_max(this.data[i][j][1]) : Math.abs(this.data[i][j][1]));\n          }\n        }\n      }\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    this.grapharea = ca.height - this.gutterTop - this.gutterBottom;RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.background.vbars'] && prop['chart.background.vbars'].length) {\n      this.DrawVBars();\n    }\n    if (!prop['chart.noaxes']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();if (prop['chart.animation.trace']) {\n      co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();\n    }\n    for (i = 0; i < this.data.length; ++i) {\n      this.DrawMarks(i);co.shadowColor = prop['chart.line.shadow.color'];co.shadowOffsetX = prop['chart.line.shadow.offsetx'];co.shadowOffsetY = prop['chart.line.shadow.offsety'];co.shadowBlur = prop['chart.line.shadow.blur'];this.DrawLine(i);RG.NoShadow(this);\n    }\n    if (prop['chart.line']) {\n      for (var i = 0, len = this.data.length; i < len; i += 1) {\n        this.DrawMarks(i);\n      }\n    }\n    if (prop['chart.animation.trace']) {\n      co.restore();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.line.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.DrawAboveLabels();\n    }\n    this.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };\n  this.drawAxes = this.DrawAxes = function () {\n    var graphHeight = ca.height - this.gutterTop - this.gutterBottom;co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = (prop['chart.axis.linewidth'] || 1) + 0.001;if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.xaxis']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));co.lineTo(ca.width - this.gutterRight, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));\n      } else {\n        var y = this.getYCoord(this.scale2.min > 0 ? this.scale2.min : 0);co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    if (prop['chart.noyaxis'] === false) {\n      var numyticks = prop['chart.numyticks'];for (i = 0; i < numyticks; ++i) {\n        var y = (ca.height - this.gutterTop - this.gutterBottom) / numyticks * i;y = y + this.gutterTop;if (prop['chart.xaxispos'] == 'center' && i == numyticks / 2) {\n          continue;\n        }\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, Math.round(y));co.lineTo(ca.width - this.gutterRight, Math.round(y));\n        }\n      }\n      if (prop['chart.numyticks'] > 0) {\n        if (prop['chart.xaxispos'] == 'center' && prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n        } else if (prop['chart.xaxispos'] == 'center') {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));\n        }\n      }\n      if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'left') {\n        co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n      } else if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'right') {\n        co.moveTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));\n      }\n      if (prop['chart.xaxispos'] === 'bottom' && prop['chart.numyticks'] > 0) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(this.gutterLeft - 3, ma.round(this.getYCoord(prop['chart.ymin'])));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(ca.width - this.gutterRight, ma.round(this.getYCoord(prop['chart.ymin'])));\n        }\n      }\n    }\n    if (prop['chart.numxticks'] > 0 && prop['chart.xaxis']) {\n      var x = 0,\n          y = this.getYCoord(prop['chart.ylabels.invert'] ? this.scale2.max : this.scale2.max > 0 && this.scale2.min > 0 ? this.scale2.min : 0) - 3,\n          size = 3;if (prop['chart.ymin'] === 0 && prop['chart.xaxispos'] === 'bottom') {\n        y += 3;\n      }\n      if (this.scale2.max > 0 && this.scale2.min > 0) {\n        y += 3;\n      }\n      this.xTickGap = prop['chart.labels'] && prop['chart.labels'].length ? (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length : (ca.width - this.gutterLeft - this.gutterRight) / 10;if (typeof prop['chart.numxticks'] == 'number') {\n        this.xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' && prop['chart.noyaxis'] == false ? this.xTickGap : 0); x <= ca.width - this.gutterRight - (prop['chart.yaxispos'] == 'left' || prop['chart.noyaxis'] == true ? -1 : 1); x += this.xTickGap) {\n        if (prop['chart.yaxispos'] == 'left' && prop['chart.noendxtick'] == true && x == ca.width - this.gutterRight) {\n          continue;\n        } else if (prop['chart.yaxispos'] == 'right' && prop['chart.noendxtick'] == true && x == this.gutterLeft) {\n          continue;\n        }\n        co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y + (prop['chart.xaxispos'] === 'center' || prop['chart.ymin'] < 0 ? size * 2 : size));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        xMin = prop['chart.xmin'],\n        xMax = prop['chart.xmax'],\n        yMax = this.scale2.max,\n        yMin = prop['chart.ymin'] ? prop['chart.ymin'] : 0,\n        text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        numYLabels = prop['chart.ylabels.count'],\n        invert = prop['chart.ylabels.invert'],\n        inside = prop['chart.ylabels.inside'],\n        context = co,\n        canvas = ca,\n        boxed = false,\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    this.halfTextHeight = text_size / 2;this.halfGraphHeight = (ca.height - this.gutterTop - this.gutterBottom) / 2;if (prop['chart.ylabels']) {\n      var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n        if (prop['chart.yaxispos'] == 'left') {\n          xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n        } else {\n          xPos = ca.width - prop['chart.gutter.right'] - 5;align = 'right';boxed = true;\n        }\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific'] != null && prop['chart.ylabels.specific'].length) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 0) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0; i < labels.length; ++i) {\n            var y = this.gutterTop + i * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          var reversed_labels = RG.array_reverse(labels);for (var i = 0; i < reversed_labels.length; ++i) {\n            var y = this.gutterTop + this.grapharea / 2 + (i + 1) * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': reversed_labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          if (prop['chart.ymin'] != 0) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.grapharea / 2 + this.gutterTop + offsety, 'text': prop['chart.ylabels.specific'][prop['chart.ylabels.specific'].length - 1], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n        }\n        if (!prop['chart.ylabels.specific'] && typeof numYLabels == 'number') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n            } else {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n            }\n          }\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[len - (i + 1)], 'tag': 'scale' });\n            } else {\n              if (i == len - 1 && invert) {\n                continue;\n              }\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n            }\n          }\n          if (!invert && (yMin > 0 || prop['chart.scale.zerostart'])) {\n            RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: this.gutterTop + this.halfGraphHeight + offsety, valign: 'center', halign: align, bounding: boxed, boundingFill: 'white', text: RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n          }\n          if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.number_format(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight * 2 + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      } else {\n        var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n          if (prop['chart.yaxispos'] == 'left') {\n            xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n          } else {\n            xPos = ca.width - this.gutterRight - 5;align = 'right';boxed = true;\n          }\n        }\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 9999) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0, len = labels.length; i < len; i += 1) {\n            var y = this.gutterTop + i * (this.grapharea / (len - 1));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'halign': align, 'valign': 'center', 'bounding': boxed, 'tag': 'scale' });\n          }\n        } else {\n          if (typeof numYLabels == 'number') {\n            if (invert) {\n              for (var i = 0; i < numYLabels; ++i) {\n                var interval = (ca.height - this.gutterTop - this.gutterBottom) / numYLabels;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + (i + 1) * interval + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && !prop['chart.ymin']) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, this.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n              }\n            } else {\n              for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.grapharea - (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && prop['chart.ymin'] == 0) {\n                RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: ca.height - this.gutterBottom + offsety, valign: 'center', halign: align, boundin: boxed, boundingFill: 'white', text: RG.numberFormat(this, 0 .toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n              }\n            }\n          }\n          if ((prop['chart.ymin'] || prop['chart.scale.zerostart']) && !invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          } else if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (prop['chart.xscale']) {\n      var numXLabels = prop['chart.xscale.numlabels'],\n          y = ca.height - this.gutterBottom + 5 + text_size / 2,\n          units_pre_x = prop['chart.xscale.units.pre'],\n          units_post_x = prop['chart.xscale.units.post'],\n          decimals = prop['chart.xscale.decimals'],\n          point = prop['chart.xscale.point'],\n          thousand = prop['chart.xscale.thousand'],\n          color = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      if (!prop['chart.xmax']) {\n        var xmax = 0;var xmin = prop['chart.xmin'];for (var ds = 0, len = this.data.length; ds < len; ds += 1) {\n          for (var point = 0, len2 = this.data[ds].length; point < len2; point += 1) {\n            xmax = Math.max(xmax, this.data[ds][point][0]);\n          }\n        }\n      } else {\n        xmax = prop['chart.xmax'];xmin = prop['chart.xmin'];\n      }\n      this.xscale2 = RG.getScale2(this, { 'max': xmax, 'min': xmin, 'scale.decimals': decimals, 'scale.point': point, 'scale.thousand': thousand, 'units.pre': units_pre_x, 'units.post': units_post_x, 'ylabels.count': numXLabels, 'strict': true });this.Set('chart.xmax', this.xscale2.max);var interval = (ca.width - this.gutterLeft - this.gutterRight) / this.xscale2.labels.length;for (var i = 0, len = this.xscale2.labels.length; i < len; i += 1) {\n        var num = (prop['chart.xmax'] - prop['chart.xmin']) * ((i + 1) / numXLabels) + (xmin || 0),\n            x = this.gutterLeft + (i + 1) * interval,\n            text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, num)) : this.xscale2.labels[i];RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n      }\n      var text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, prop['chart.xmin'])) : String(prop['chart.xmin']);RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': this.gutterLeft + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n    } else {\n      var graphArea = ca.width - this.gutterLeft - this.gutterRight;var xInterval = graphArea / prop['chart.labels'].length;var xPos = this.gutterLeft;var yPos = ca.height - this.gutterBottom + 3;var labels = prop['chart.labels'];var color = prop['chart.labels.color'];var bold = prop['chart.labels.bold'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];var angle = 0;var valign = 'top';var halign = 'center';if (prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yPos += 10;\n      }\n      for (i = 0; i < labels.length; ++i) {\n        if (_typeof(labels[i]) == 'object') {\n          if (prop['chart.labels.specific.align'] == 'center') {\n            var rightEdge = 0;if (labels[i + 1] && labels[i + 1][1]) {\n              rightEdge = labels[i + 1][1];\n            } else {\n              rightEdge = prop['chart.xmax'];\n            }\n            var offset = (this.getXCoord(rightEdge) - this.getXCoord(labels[i][1])) / 2;\n          } else {\n            var offset = 5;\n          }\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': this.getXCoord(labels[i][1]) + offset + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': angle != 0 ? 'right' : prop['chart.labels.specific.align'] == 'center' ? 'center' : 'left', 'text': String(labels[i][0]), 'angle': angle, 'marker': false, 'tag': 'labels.specific' });co.beginPath();co.strokeStyle = '#bbb';co.moveTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom + 20);co.stroke();\n        } else {\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': xPos + xInterval / 2 + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': halign, 'text': String(labels[i]), 'angle': angle, 'tag': 'labels' });\n        }\n        xPos += xInterval;\n      }\n      if (_typeof(labels[0]) == 'object') {\n        co.beginPath();co.strokeStyle = '#bbb';co.moveTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom);co.lineTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom + 20);co.stroke();\n      }\n    }\n  };this.drawMarks = this.DrawMarks = function (i) {\n    this.coords[i] = [];var xmax = prop['chart.xmax'];var default_color = prop['chart.defaultcolor'];for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n      var data_points = this.data[i];if (RG.isNull(data_points[j])) {\n        continue;\n      }\n      var xCoord = data_points[j][0];var yCoord = data_points[j][1];var color = data_points[j][2] ? data_points[j][2] : default_color;var tooltip = data_points[j] && data_points[j][3] ? data_points[j][3] : null;this.DrawMark(i, xCoord, yCoord, xmax, this.scale2.max, color, tooltip, this.coords[i], data_points, j);\n    }\n  };this.drawMark = this.DrawMark = function (data_set_index, x, y, xMax, yMax, color, tooltip, coords, data, data_index) {\n    var tickmarks = prop['chart.tickmarks'],\n        tickSize = prop['chart.ticksize'],\n        xMin = prop['chart.xmin'],\n        x = (x - xMin) / (xMax - xMin) * (ca.width - this.gutterLeft - this.gutterRight),\n        originalX = x,\n        originalY = y;if (tickmarks && (typeof tickmarks === 'undefined' ? 'undefined' : _typeof(tickmarks)) == 'object') {\n      tickmarks = tickmarks[data_set_index];\n    }\n    if ((typeof tickSize === 'undefined' ? 'undefined' : _typeof(tickSize)) == 'object') {\n      var tickSize = tickSize[data_set_index];var halfTickSize = tickSize / 2;\n    } else {\n      var halfTickSize = tickSize / 2;\n    }\n    if (y && (typeof y === 'undefined' ? 'undefined' : _typeof(y)) === 'object' && typeof y[0] === 'number' && typeof y[1] === 'number' && typeof y[2] === 'number' && typeof y[3] === 'number' && typeof y[4] === 'number') {\n      this.Set('chart.boxplot', true);var y0 = this.getYCoord(y[0]),\n          y1 = this.getYCoord(y[1]),\n          y2 = this.getYCoord(y[2]),\n          y3 = this.getYCoord(y[3]),\n          y4 = this.getYCoord(y[4]),\n          col1 = y[5],\n          col2 = y[6],\n          boxWidth = typeof y[7] == 'number' ? y[7] : prop['chart.boxplot.width'];\n    } else {\n      var yCoord = this.getYCoord(y);\n    }\n    x += this.gutterLeft;co.beginPath();co.strokeStyle = color;if (prop['chart.boxplot']) {\n      boxWidth = boxWidth / prop['chart.xmax'] * (ca.width - this.gutterLeft - this.gutterRight);var halfBoxWidth = boxWidth / 2;if (prop['chart.line.visible']) {\n        co.beginPath();if (typeof y[8] === 'string') {\n          co.strokeStyle = y[8];\n        }\n        co.strokeRect(x - halfBoxWidth, y1, boxWidth, y3 - y1);if (col1) {\n          co.fillStyle = col1;co.fillRect(x - halfBoxWidth, y1, boxWidth, y2 - y1);\n        }\n        if (col2) {\n          co.fillStyle = col2;co.fillRect(x - halfBoxWidth, y2, boxWidth, y3 - y2);\n        }\n        co.stroke();co.beginPath();if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y0));co.lineTo(x + halfBoxWidth, ma.round(y0));\n        }\n        co.moveTo(ma.round(x), y0);co.lineTo(ma.round(x), y1);if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y4));co.lineTo(x + halfBoxWidth, ma.round(y4));\n        }\n        co.moveTo(ma.round(x), y4);co.lineTo(ma.round(x), y3);co.stroke();\n      }\n    }\n    if (prop['chart.line.visible'] && typeof y == 'number' && !y0 && !y1 && !y2 && !y3 && !y4) {\n      if (tickmarks == 'circle') {\n        co.arc(x, yCoord, halfTickSize, 0, 6.28, 0);co.fillStyle = color;co.fill();\n      } else if (tickmarks == 'plus') {\n        co.moveTo(x, yCoord - halfTickSize);co.lineTo(x, yCoord + halfTickSize);co.moveTo(x - halfTickSize, yCoord);co.lineTo(x + halfTickSize, yCoord);co.stroke();\n      } else if (tickmarks == 'square') {\n        co.strokeStyle = color;co.fillStyle = color;co.fillRect(x - halfTickSize, yCoord - halfTickSize, tickSize, tickSize);\n      } else if (tickmarks == 'cross') {\n        co.moveTo(x - halfTickSize, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord + halfTickSize);co.moveTo(x + halfTickSize, yCoord - halfTickSize);co.lineTo(x - halfTickSize, yCoord + halfTickSize);co.stroke();\n      } else if (tickmarks == 'diamond') {\n        co.fillStyle = co.strokeStyle;co.moveTo(x, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord);co.lineTo(x, yCoord + halfTickSize);co.lineTo(x - halfTickSize, yCoord);co.lineTo(x, yCoord - halfTickSize);co.fill();co.stroke();\n      } else if (typeof tickmarks == 'function') {\n        var graphWidth = ca.width - this.gutterLeft - this.gutterRight,\n            graphheight = ca.height - this.gutterTop - this.gutterBottom,\n            xVal = (x - this.gutterLeft) / graphWidth * xMax,\n            yVal = (graphheight - (yCoord - this.gutterTop)) / graphheight * yMax;tickmarks(this, data, x, yCoord, xVal, yVal, xMax, yMax, color, data_set_index, data_index);\n      } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n        var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n          img.src = tickmarks.substr(6);\n        } else {\n          img.src = tickmarks;\n        }\n        img.onload = function () {\n          if (prop['chart.tickmarks.image.halign'] === 'center') x -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') x -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yCoord -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yCoord -= this.height;x += prop['chart.tickmarks.image.offsetx'];yCoord += prop['chart.tickmarks.image.offsety'];co.drawImage(this, x, yCoord);\n        };\n      } else if (tickmarks === null) {} else {\n        alert('[SCATTER] (' + this.id + ') Unknown tickmark style: ' + tickmarks);\n      }\n    }\n    if (prop['chart.boxplot'] && typeof y0 === 'number' && typeof y1 === 'number' && typeof y2 === 'number' && typeof y3 === 'number' && typeof y4 === 'number') {\n      x = [x - halfBoxWidth, x + halfBoxWidth];yCoord = [y0, y1, y2, y3, y4];\n    }\n    coords.push([x, yCoord, tooltip]);\n  };this.drawLine = this.DrawLine = function (i) {\n    if (typeof prop['chart.line.visible'] == 'boolean' && prop['chart.line.visible'] == false) {\n      return;\n    }\n    if (prop['chart.line'] && this.coords[i].length >= 2) {\n      if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash(prop['chart.line.dash']);\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';co.lineWidth = this.getLineWidth(i);co.strokeStyle = prop['chart.line.colors'][i];co.beginPath();var prevY = null;var currY = null;for (var j = 0, len = this.coords[i].length; j < len; j += 1) {\n        var xPos = this.coords[i][j][0];var yPos = this.coords[i][j][1];if (j > 0) prevY = this.coords[i][j - 1][1];currY = yPos;if (j == 0 || RG.is_null(prevY) || RG.is_null(currY)) {\n          co.moveTo(xPos, yPos);\n        } else {\n          var stepped = prop['chart.line.stepped'];if (typeof stepped == 'boolean' && stepped || (typeof stepped === 'undefined' ? 'undefined' : _typeof(stepped)) == 'object' && stepped[i]) {\n            co.lineTo(this.coords[i][j][0], this.coords[i][j - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        }\n      }\n      co.stroke();if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash([1, 0]);\n      }\n    }\n    co.lineWidth = 1;\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.line.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[SCATTER] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.drawVBars = this.DrawVBars = function () {\n    var vbars = prop['chart.background.vbars'];var graphWidth = ca.width - this.gutterLeft - this.gutterRight;if (vbars) {\n      var xmax = prop['chart.xmax'];var xmin = prop['chart.xmin'];for (var i = 0, len = vbars.length; i < len; i += 1) {\n        var key = i;var value = vbars[key];if (typeof value[0] == 'string') value[0] = RG.parseDate(value[0]);if (typeof value[1] == 'string') value[1] = RG.parseDate(value[1]) - value[0];var x = (value[0] - xmin) / (xmax - xmin) * graphWidth + this.gutterLeft;var width = value[1] / (xmax - xmin) * graphWidth;co.fillStyle = value[2];co.fillRect(x, this.gutterTop, width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function (obj) {\n    var labels = obj.Get('chart.labels.ingraph');var labels_processed = [];if (!labels) {\n      return;\n    }\n    var fgcolor = 'black';var bgcolor = 'white';var direction = 1;for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] == 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] == 'string' || _typeof(labels[i]) == 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.NoShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      var i = 0;for (var set = 0; set < obj.coords.length; ++set) {\n        for (var point = 0; point < obj.coords[set].length; ++point) {\n          if (labels_processed[i]) {\n            var x = obj.coords[set][point][0];var y = obj.coords[set][point][1];var length = typeof labels_processed[i][4] == 'number' ? labels_processed[i][4] : 25;var text_x = x;var text_y = y - 5 - length;co.moveTo(x, y - 5);co.lineTo(x, y - 5 - length);co.stroke();co.beginPath();co.moveTo(x, y - 5);co.lineTo(x - 3, y - 10);co.lineTo(x + 3, y - 10);co.closePath();co.beginPath();co.fillStyle = _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][1] == 'string' ? labels_processed[i][1] : 'black';RG.text2(this, { 'font': obj.Get('chart.text.font'), 'size': obj.Get('chart.text.size'), 'x': text_x, 'y': text_y, 'text': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][0] == 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][2] == 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels.ingraph' });co.fill();\n          }\n          i++;\n        }\n      }\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var i = 0, len2 = this.coords[set].length; i < len2; ++i) {\n        var x = this.coords[set][i][0];var y = this.coords[set][i][1];var tooltip = this.data[set][i][3];if (typeof y == 'number') {\n          if (mouseX <= x + offset && mouseX >= x - offset && mouseY <= y + offset && mouseY >= y - offset) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);var index_adjusted = i;for (var ds = set - 1; ds >= 0; --ds) {\n              index_adjusted += this.data[ds].length;\n            }\n            return { 0: this, 1: x, 2: y, 3: set, 4: i, 5: this.data[set][i][3], 'object': this, 'x': x, 'y': y, 'dataset': set, 'index': i, 'tooltip': tooltip, 'index_adjusted': index_adjusted };\n          }\n        } else if (RG.is_null(y)) {} else {\n          var mark = this.data[set][i];var width = prop['chart.boxplot.width'];if (typeof mark[1][7] == 'number') {\n            width = mark[1][7];\n          }\n          if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) == 'object' && mouseX > x[0] && mouseX < x[1] && mouseY < y[1] && mouseY > y[3]) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);return { 0: this, 1: x[0], 2: x[1] - x[0], 3: y[1], 4: y[3] - y[1], 5: set, 6: i, 7: this.data[set][i][3], 'object': this, 'x': x[0], 'y': y[1], 'width': x[1] - x[0], 'height': y[3] - y[1], 'dataset': set, 'index': i, 'tooltip': tooltip };\n          }\n        }\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'];var font = prop['chart.text.font'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var point = 0, len2 = this.coords[set].length; point < len2; ++point) {\n        var x_val = this.data[set][point][0];var y_val = this.data[set][point][1];if (!RG.is_null(y_val)) {\n          if (RG.is_array(y_val)) {\n            var max = 0;for (var i = 0; i < y_val; ++i) {\n              max = Math.max(max, y_val[i]);\n            }\n            y_val = max;\n          }\n          var x_pos = this.coords[set][point][0];var y_pos = this.coords[set][point][1];RG.Text2(this, { 'font': font, 'size': size, 'x': x_pos, 'y': y_pos - 5 - size, 'text': x_val.toFixed(prop['chart.labels.above.decimals']) + ', ' + y_val.toFixed(prop['chart.labels.above.decimals']), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': 'rgba(255, 255, 255, 0.7)', 'tag': 'labels.above' });\n        }\n      }\n    }\n  };this.getYValue = this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value *= 2;if (value >= 0) {\n        value += this.min;\n        if (prop['chart.ylabels.invert']) {\n          value -= this.min;value = this.max - value;\n        }\n      } else {\n        value -= this.min;if (prop['chart.ylabels.invert']) {\n          value += this.min;value = this.max + value;value *= -1;\n        }\n      }\n    } else {\n      var value = (this.grapharea - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value += this.min;if (prop['chart.ylabels.invert']) {\n        value -= this.min;value = this.max - value;\n      }\n    }\n    return value;\n  };this.getXValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg);var mouseX = mouseXY[0];var mouseY = mouseXY[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    var width = ca.width - this.gutterLeft - this.gutterRight;var value = (mouseX - this.gutterLeft) / width * (prop['chart.xmax'] - prop['chart.xmin']);\n    value += prop['chart.xmin'];return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      if (shape['height']) {\n        RG.Highlight.Rect(this, shape);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft - 3 && mouseXY[0] < ca.width - this.gutterRight + 3 && mouseXY[1] > this.gutterTop - 3 && mouseXY[1] < ca.height - this.gutterBottom + 3) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (typeof value != 'number' && typeof value != 'string') {\n      return null;\n    }\n    if (typeof value === 'string') {\n      value = RG.parseDate(value);\n    }\n    var xmin = prop['chart.xmin'];var xmax = prop['chart.xmax'];var x;if (value < xmin) return null;if (value > xmax) return null;var gutterRight = this.gutterRight;var gutterLeft = this.gutterLeft;if (prop['chart.yaxispos'] == 'right') {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = ca.width - gutterRight - x;\n    } else {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = x + gutterLeft;\n    }\n    return x;\n  };this.getYCoord = this.getYCoordFromValue = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var invert = prop['chart.ylabels.invert'];var xaxispos = prop['chart.xaxispos'];var graphHeight = ca.height - this.gutterTop - this.gutterBottom;var halfGraphHeight = graphHeight / 2;var ymax = this.max;var ymin = prop['chart.ymin'];var coord = 0;if (value > ymax || prop['chart.xaxispos'] == 'bottom' && value < ymin || prop['chart.xaxispos'] == 'center' && (value > 0 && value < ymin || value < 0 && value > -1 * ymin)) {\n      return null;\n    }\n    if (xaxispos == 'center') {\n      coord = (Math.abs(value) - ymin) / (ymax - ymin) * halfGraphHeight;if (invert) {\n        coord = halfGraphHeight - coord;\n      }\n      if (value < 0) {\n        coord += this.gutterTop;coord += halfGraphHeight;\n      } else {\n        coord = halfGraphHeight - coord;coord += this.gutterTop;\n      }\n    } else {\n      coord = (value - ymin) / (ymax - ymin) * graphHeight;if (invert) {\n        coord = graphHeight - coord;\n      }\n      coord = graphHeight - coord;coord = this.gutterTop + coord;\n    }\n    return coord;\n  };RG.Scatter.Bubble = function (scatter, min, max, width, data) {\n    this.scatter = scatter;this.min = min;this.max = max;this.width = width;this.data = data;this.coords = [];this.type = 'scatter.bubble';\n    this.set = this.Set = function (name, value) {\n      this.scatter.set(name, value);return this;\n    };this.get = this.Get = function (name) {\n      this.scatter.get(name);\n    };this.draw = this.Draw = function () {\n      var bubble_min = this.min,\n          bubble_max = this.max,\n          bubble_data = this.data,\n          bubble_max_width = this.width;var obj_bubble = this,\n          obj_scatter = this.scatter;this.scatter.ondraw = function (obj) {\n        for (var i = 0; i < obj.coords[0].length; ++i) {\n          bubble_data[i] = ma.max(bubble_data[i], bubble_min);bubble_data[i] = ma.min(bubble_data[i], bubble_max);var r = (bubble_data[i] - bubble_min) / (bubble_max - bubble_min) * bubble_max_width,\n              color = obj_scatter.data[0][i][2] ? obj_scatter.data[0][i][2] : obj_scatter.properties['chart.defaultcolor'];co.beginPath();co.fillStyle = RG.radialGradient(obj, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, 0, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, r, prop['chart.colors.bubble.graduated'] ? 'white' : color, color);co.arc(obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, 0, RG.TWOPI, false);co.fill();obj_bubble.coords[i] = [obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, co.fillStyle];\n        }\n      };\n      this.scatter.Draw();return this;\n    };\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.background.vbars'] = RG.array_clone(prop['chart.background.vbars']);this.original_colors['chart.background.hbars'] = RG.array_clone(prop['chart.background.hbars']);this.original_colors['chart.line.colors'] = RG.array_clone(prop['chart.line.colors']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var data = this.data;if (data) {\n      for (var dataset = 0; dataset < data.length; ++dataset) {\n        for (var i = 0; i < this.data[dataset].length; ++i) {\n          if (this.data[dataset][i] && _typeof(this.data[dataset][i][1]) == 'object' && this.data[dataset][i][1]) {\n            if (typeof this.data[dataset][i][1][5] == 'string') this.data[dataset][i][1][5] = this.parseSingleColorForGradient(this.data[dataset][i][1][5]);if (typeof this.data[dataset][i][1][6] == 'string') this.data[dataset][i][1][6] = this.parseSingleColorForGradient(this.data[dataset][i][1][6]);\n          }\n          if (!RG.isNull(this.data[dataset][i])) {\n            this.data[dataset][i][2] = this.parseSingleColorForGradient(this.data[dataset][i][2]);\n          }\n        }\n      }\n    }\n    var hbars = prop['chart.background.hbars'];if (hbars) {\n      for (i = 0; i < hbars.length; ++i) {\n        hbars[i][2] = this.parseSingleColorForGradient(hbars[i][2]);\n      }\n    }\n    var vbars = prop['chart.background.vbars'];if (vbars) {\n      for (i = 0; i < vbars.length; ++i) {\n        vbars[i][2] = this.parseSingleColorForGradient(vbars[i][2]);\n      }\n    }\n    var colors = prop['chart.line.colors'];if (colors) {\n      for (i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords && this.coords[index] && this.coords[index].length) {\n      this.coords[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 3, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.trace = this.trace2 = function () {\n    var obj = this,\n        callback = arguments[2],\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {};\n    obj.Set('animationTrace', true);obj.Set('animationTraceClip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animationTraceClip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);if (_typeof(this.data[i][j][1]) === 'object') {\n          this.data[i][j][1][5] = RG.array_clone(this.original_colors['data'][i][j][1][5]);this.data[i][j][1][6] = RG.array_clone(this.original_colors['data'][i][j][1][6]);\n        }\n      }\n    }\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc2NhdHRlci5qcz80MTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguU2NhdHRlcj1mdW5jdGlvbihjb25mKVxue2lmKHR5cGVvZiBjb25mPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt0aGlzLmRhdGE9bmV3IEFycmF5KGNvbmYuZGF0YS5sZW5ndGgpO3RoaXMuZGF0YT1SR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO2lmKHR5cGVvZiBjb25mLmRhdGE9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuZGF0YVswXT09PSdvYmplY3QnJiYodHlwZW9mIGNvbmYuZGF0YVswXVswXT09PSdudW1iZXInfHx0eXBlb2YgY29uZi5kYXRhWzBdWzBdPT09J3N0cmluZycpKXt2YXIgdG1wPVJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YSk7Y29uZi5kYXRhPW5ldyBBcnJheSgpO2NvbmYuZGF0YVswXT1SR3JhcGguYXJyYXlDbG9uZSh0bXApO3RoaXMuZGF0YT1SR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO319ZWxzZXt2YXIgY29uZj17aWQ6Y29uZn07Y29uZi5kYXRhPWFyZ3VtZW50c1sxXTt0aGlzLmRhdGE9W107aWYoYXJndW1lbnRzWzFdWzBdJiZhcmd1bWVudHNbMV1bMF1bMF0mJnR5cGVvZiBhcmd1bWVudHNbMV1bMF1bMF09PSdvYmplY3QnKXtmb3IodmFyIGk9MDtpPGFyZ3VtZW50c1sxXS5sZW5ndGg7KytpKXt0aGlzLmRhdGFbaV09UkdyYXBoLmFycmF5Q2xvbmUoYXJndW1lbnRzWzFdW2ldKTt9fWVsc2V7Zm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoOysraSl7dGhpcy5kYXRhW2ktMV09UkdyYXBoLmFycmF5Q2xvbmUoYXJndW1lbnRzW2ldKTt9fX1cbmlmKCFSR3JhcGguaXNBcnJheSh0aGlzLmRhdGFbMF1bMF0pKXt0aGlzLmRhdGE9W3RoaXMuZGF0YV07fVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTxsZW47KytpKXtmb3IodmFyIGo9MCxsZW4yPXRoaXMuZGF0YVtpXS5sZW5ndGg7ajxsZW4yOysrail7aWYodHlwZW9mIHRoaXMuZGF0YVtpXVtqXT09PSdvYmplY3QnJiYhUkdyYXBoLmlzTnVsbCh0aGlzLmRhdGFbaV1bal0pJiZ0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzBdPT09J3N0cmluZycpe2lmKHRoaXMuZGF0YVtpXVtqXVswXS5tYXRjaCgvXlsuMC05XSskLykpe3RoaXMuZGF0YVtpXVtqXVswXT1wYXJzZUZsb2F0KHRoaXMuZGF0YVtpXVtqXVswXSk7fWVsc2UgaWYodGhpcy5kYXRhW2ldW2pdWzBdPT09Jycpe3RoaXMuZGF0YVtpXVtqXVswXT0wO319XG5pZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdPT09J29iamVjdCcmJiFSR3JhcGguaXNOdWxsKHRoaXMuZGF0YVtpXVtqXSkmJnR5cGVvZiB0aGlzLmRhdGFbaV1bal1bMV09PT0nc3RyaW5nJyl7aWYodGhpcy5kYXRhW2ldW2pdWzFdLm1hdGNoKC9bLjAtOV0rLykpe3RoaXMuZGF0YVtpXVtqXVsxXT1wYXJzZUZsb2F0KHRoaXMuZGF0YVtpXVtqXVsxXSk7fWVsc2UgaWYodGhpcy5kYXRhW2ldW2pdWzFdPT09Jycpe3RoaXMuZGF0YVtpXVtqXVsxXT0wO319fX1cbnRoaXMuaWQ9Y29uZi5pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQ/dGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTpudWxsO3RoaXMubWF4PTA7dGhpcy5jb29yZHM9W107dGhpcy50eXBlPSdzY2F0dGVyJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCc6MSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzonI2RkZCcsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbic6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzo1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOjIwLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS55JzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLncnOm51bGwsJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuaCc6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5hbGlnbic6bnVsbCwnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6bnVsbCwnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5hbmdsZSc6MCwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LnRvb2x0aXBzJzpbXSwnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25tb3VzZW1vdmUnLCdjaGFydC50b29sdGlwcy5ob3RzcG90JzozLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMuY29vcmRzLnBhZ2UnOmZhbHNlLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQubnVteXRpY2tzJzoxMCwnY2hhcnQudGlja21hcmtzJzonY3Jvc3MnLCdjaGFydC50aWNrbWFya3MuaW1hZ2UuaGFsaWduJzonY2VudGVyJywnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbic6J2NlbnRlcicsJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR4JzowLCdjaGFydC50aWNrbWFya3MuaW1hZ2Uub2Zmc2V0eSc6MCwnY2hhcnQudGlja3NpemUnOjUsJ2NoYXJ0Lm51bXh0aWNrcyc6dHJ1ZSwnY2hhcnQueGF4aXMnOnRydWUsJ2NoYXJ0Lmd1dHRlci5sZWZ0JzoyNSwnY2hhcnQuZ3V0dGVyLnJpZ2h0JzoyNSwnY2hhcnQuZ3V0dGVyLnRvcCc6MjUsJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOjMwLCdjaGFydC5jb2xvcnMuYnViYmxlLmdyYWR1YXRlZCc6dHJ1ZSwnY2hhcnQueG1pbic6MCwnY2hhcnQueG1heCc6MCwnY2hhcnQueW1heCc6bnVsbCwnY2hhcnQueW1pbic6MCwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCc6dHJ1ZSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC50aXRsZS5ocG9zJzpudWxsLCdjaGFydC50aXRsZS52cG9zJzpudWxsLCdjaGFydC50aXRsZS5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS5mb250JzpudWxsLCdjaGFydC50aXRsZS54YXhpcyc6JycsJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzpudWxsLCdjaGFydC50aXRsZS55YXhpcyc6JycsJ2NoYXJ0LnRpdGxlLnlheGlzLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJzpudWxsLCdjaGFydC50aXRsZS54YXhpcy5wb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLnBvcyc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMueCc6bnVsbCwnY2hhcnQudGl0bGUueWF4aXMueSc6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMueCc6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMueSc6bnVsbCwnY2hhcnQudGl0bGUueCc6bnVsbCwnY2hhcnQudGl0bGUueSc6bnVsbCwnY2hhcnQudGl0bGUuaGFsaWduJzpudWxsLCdjaGFydC50aXRsZS52YWxpZ24nOm51bGwsJ2NoYXJ0LmxhYmVscyc6W10sJ2NoYXJ0LmxhYmVscy5ib2xkJzpmYWxzZSwnY2hhcnQubGFiZWxzLmNvbG9yJzpudWxsLCdjaGFydC5sYWJlbHMuaW5ncmFwaCc6bnVsbCwnY2hhcnQubGFiZWxzLmFib3ZlJzpmYWxzZSwnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnOjgsJ2NoYXJ0LmxhYmVscy5hYm92ZS5kZWNpbWFscyc6MCwnY2hhcnQubGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzowLCdjaGFydC55bGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSc6MCwnY2hhcnQueWxhYmVscyc6dHJ1ZSwnY2hhcnQueWxhYmVscy5jb3VudCc6NSwnY2hhcnQueWxhYmVscy5pbnZlcnQnOmZhbHNlLCdjaGFydC55bGFiZWxzLnNwZWNpZmljJzpudWxsLCdjaGFydC55bGFiZWxzLmluc2lkZSc6ZmFsc2UsJ2NoYXJ0LmNvbnRleHRtZW51JzpudWxsLCdjaGFydC5kZWZhdWx0Y29sb3InOidibGFjaycsJ2NoYXJ0LnhheGlzcG9zJzonYm90dG9tJywnY2hhcnQueWF4aXNwb3MnOidsZWZ0JywnY2hhcnQuY3Jvc3NoYWlycyc6ZmFsc2UsJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InOicjMzMzJywnY2hhcnQuY3Jvc3NoYWlycy5saW5ld2lkdGgnOjEsJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzJzpmYWxzZSwnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMuZml4ZWQnOnRydWUsJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmZhZGVvdXQnOmZhbHNlLCdjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5sYWJlbHMueCc6J1gnLCdjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5sYWJlbHMueSc6J1knLCdjaGFydC5jcm9zc2hhaXJzLmhsaW5lJzp0cnVlLCdjaGFydC5jcm9zc2hhaXJzLnZsaW5lJzp0cnVlLCdjaGFydC5hbm5vdGF0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzonYmxhY2snLCdjaGFydC5saW5lJzpmYWxzZSwnY2hhcnQubGluZS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmxpbmUuY29sb3JzJzpbJ2dyZWVuJywncmVkJ10sJ2NoYXJ0LmxpbmUuc2hhZG93LmNvbG9yJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmxpbmUuc2hhZG93LmJsdXInOjIsJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHknOjMsJ2NoYXJ0LmxpbmUuc3RlcHBlZCc6ZmFsc2UsJ2NoYXJ0LmxpbmUudmlzaWJsZSc6dHJ1ZSwnY2hhcnQubm9heGVzJzpmYWxzZSwnY2hhcnQubm95YXhpcyc6ZmFsc2UsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LmhhbGlnbic6J3JpZ2h0JywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmludGVyYWN0aXZlJzpmYWxzZSwnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzoncmdiYSgyNTUsMCwwLDAuOSknLCdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzoncmdiYSgyNTUsMCwwLDAuMiknLCdjaGFydC5rZXkuY29sb3Iuc2hhcGUnOidzcXVhcmUnLCdjaGFydC5rZXkucm91bmRlZCc6dHJ1ZSwnY2hhcnQua2V5LmxpbmV3aWR0aCc6MSwnY2hhcnQua2V5LmNvbG9ycyc6bnVsbCwnY2hhcnQua2V5LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LmF4aXMuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LmJveHBsb3Qud2lkdGgnOjEsJ2NoYXJ0LmJveHBsb3QuY2FwcGVkJzp0cnVlLCdjaGFydC5yZXNpemFibGUnOmZhbHNlLCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnhtaW4nOjAsJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYy5hbGlnbic6J2xlZnQnLCdjaGFydC54c2NhbGUnOmZhbHNlLCdjaGFydC54c2NhbGUudW5pdHMucHJlJzonJywnY2hhcnQueHNjYWxlLnVuaXRzLnBvc3QnOicnLCdjaGFydC54c2NhbGUubnVtbGFiZWxzJzoxMCwnY2hhcnQueHNjYWxlLmZvcm1hdHRlcic6bnVsbCwnY2hhcnQueHNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC54c2NhbGUudGhvdXNhbmQnOicsJywnY2hhcnQueHNjYWxlLnBvaW50JzonLicsJ2NoYXJ0Lm5vZW5keHRpY2snOmZhbHNlLCdjaGFydC5ub2VuZHl0aWNrJzp0cnVlLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZSc6ZmFsc2UsJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJzoxfVxuZm9yKHZhciBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSl7Zm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysrail7aWYoUkdyYXBoLmlzTnVsbCh0aGlzLmRhdGFbaV1bal0pKXt0aGlzLmRhdGFbaV1bal09W107fVxuaWYodGhpcy5kYXRhW2ldW2pdJiZ0eXBlb2YodGhpcy5kYXRhW2ldW2pdWzBdKT09J3N0cmluZycpe3RoaXMuZGF0YVtpXVtqXVswXT1SR3JhcGgucGFyc2VEYXRlKHRoaXMuZGF0YVtpXVtqXVswXSk7fX19XG50aGlzLmRhdGFfYXJyPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2Zvcih2YXIgaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2ope3RoaXMuZGF0YV9hcnIucHVzaCh0aGlzLmRhdGFbaV1bal0pO319XG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YV9hcnIubGVuZ3RoOysraSl7dGhpc1snJCcraV09e319XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbU0NBVFRFUl0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47fVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0Lnh0aWNrcycpe25hbWU9PSdjaGFydC5udW14dGlja3MnO31cbmlmKG5hbWU9PSdjaGFydC5saW5lLmNvbG9ycycpe3Byb3BbJ2NoYXJ0LmNvbG9ycyddPXZhbHVlO31cbmlmKG5hbWU9PSdjaGFydC50b29sdGlwLmhvdHNwb3QnKXtuYW1lPSdjaGFydC50b29sdGlwcy5ob3RzcG90Jzt9XG5pZihuYW1lPT0nY2hhcnQueWF4aXNwb3MnJiZ2YWx1ZSE9J2xlZnQnJiZ2YWx1ZSE9J3JpZ2h0Jyl7YWxlcnQoXCJbU0NBVFRFUl0gY2hhcnQueWF4aXNwb3Mgc2hvdWxkIGJlIGxlZnQgb3IgcmlnaHQuIFlvdSd2ZSBzZXQgaXQgdG86ICdcIit2YWx1ZStcIicgQ2hhbmdpbmcgaXQgdG8gbGVmdFwiKTt2YWx1ZT0nbGVmdCc7fVxuaWYobmFtZT09J2NoYXJ0LnhheGlzcG9zJyl7aWYodmFsdWUhPSdib3R0b20nJiZ2YWx1ZSE9J2NlbnRlcicpe2FsZXJ0KCdbU0NBVFRFUl0gKCcrdGhpcy5pZCsnKSBjaGFydC54YXhpc3BvcyBzaG91bGQgYmUgY2VudGVyIG9yIGJvdHRvbS4gVHJpZWQgdG8gc2V0IGl0IHRvOiAnK3ZhbHVlKycgQ2hhbmdpbmcgaXQgdG8gY2VudGVyJyk7dmFsdWU9J2NlbnRlcic7fX1cbmlmKG5hbWU9PSdjaGFydC5ub3hheGlzJyl7bmFtZT0nY2hhcnQueGF4aXMnO3ZhbHVlPSF2YWx1ZTt9XG5wcm9wW25hbWUudG9Mb3dlckNhc2UoKV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue2lmKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlJ109PT0nc3RyaW5nJyl7UkcuRHJhd0JhY2tncm91bmRJbWFnZSh0aGlzKTt9XG5SRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5ndXR0ZXJMZWZ0PXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodD1wcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcD1wcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b209cHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuaGFzVG9vbHRpcHM9ZmFsc2U7dmFyIG92ZXJIb3RzcG90PWZhbHNlO3RoaXMuY29vcmRzPVtdO2lmKHR5cGVvZihwcm9wWydjaGFydC54bWluJ10pPT0nc3RyaW5nJylwcm9wWydjaGFydC54bWluJ109UkcucGFyc2VEYXRlKHByb3BbJ2NoYXJ0LnhtaW4nXSk7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnhtYXgnXSk9PSdzdHJpbmcnKXByb3BbJ2NoYXJ0LnhtYXgnXT1SRy5wYXJzZURhdGUocHJvcFsnY2hhcnQueG1heCddKTtpZighUkdyYXBoLklTT0xEKXt0aGlzLlNldCgnY2hhcnQudG9vbHRpcHMnLFtdKTtmb3IodmFyIGk9MCxsZW49dGhpcy5kYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXtmb3IodmFyIGo9MCxsZW4yPXRoaXMuZGF0YVtpXS5sZW5ndGg7ajxsZW4yO2orPTEpe2lmKHRoaXMuZGF0YVtpXVtqXSYmdGhpcy5kYXRhW2ldW2pdWzNdKXtwcm9wWydjaGFydC50b29sdGlwcyddLnB1c2godGhpcy5kYXRhW2ldW2pdWzNdKTt0aGlzLmhhc1Rvb2x0aXBzPXRydWU7fWVsc2V7cHJvcFsnY2hhcnQudG9vbHRpcHMnXS5wdXNoKG51bGwpO319fX1cbnRoaXMubWF4PTA7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LnltYXgnXT09PSdudW1iZXInKXt0aGlzLm1heD1wcm9wWydjaGFydC55bWF4J107dGhpcy5taW49cHJvcFsnY2hhcnQueW1pbiddP3Byb3BbJ2NoYXJ0LnltaW4nXTowO3RoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp0aGlzLm1heCwnbWluJzp0aGlzLm1pbiwnc3RyaWN0Jzp0cnVlLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzpwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTt0aGlzLm1heD10aGlzLnNjYWxlMi5tYXg7dGhpcy5taW49dGhpcy5zY2FsZTIubWluO3ZhciBkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO31lbHNle3ZhciBpPTA7dmFyIGo9MDtmb3IoaT0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuO2krPTEpe2ZvcihqPTAsbGVuMj10aGlzLmRhdGFbaV0ubGVuZ3RoO2o8bGVuMjtqKz0xKXtpZighUkcuaXNOdWxsKHRoaXMuZGF0YVtpXVtqXSkmJnRoaXMuZGF0YVtpXVtqXVsxXSE9bnVsbCl7dGhpcy5tYXg9TWF0aC5tYXgodGhpcy5tYXgsdHlwZW9mKHRoaXMuZGF0YVtpXVtqXVsxXSk9PSdvYmplY3QnP1JHLmFycmF5X21heCh0aGlzLmRhdGFbaV1bal1bMV0pOk1hdGguYWJzKHRoaXMuZGF0YVtpXVtqXVsxXSkpO319fVxudGhpcy5taW49cHJvcFsnY2hhcnQueW1pbiddP3Byb3BbJ2NoYXJ0LnltaW4nXTowO3RoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp0aGlzLm1heCwnbWluJzp0aGlzLm1pbiwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnBvaW50Jzpwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCdzY2FsZS5kZWNpbWFscyc6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwneWxhYmVscy5jb3VudCc6cHJvcFsnY2hhcnQueWxhYmVscy5jb3VudCddLCdzY2FsZS5yb3VuZCc6cHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwndW5pdHMucHJlJzpwcm9wWydjaGFydC51bml0cy5wcmUnXSwndW5pdHMucG9zdCc6cHJvcFsnY2hhcnQudW5pdHMucG9zdCddfSk7dGhpcy5tYXg9dGhpcy5zY2FsZTIubWF4O3RoaXMubWluPXRoaXMuc2NhbGUyLm1pbjt9XG50aGlzLmdyYXBoYXJlYT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b207UkcuYmFja2dyb3VuZC5EcmF3KHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXSYmcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5oYmFycyddLmxlbmd0aCl7UkcuRHJhd0JhcnModGhpcyk7fVxuaWYocHJvcFsnY2hhcnQuYmFja2dyb3VuZC52YmFycyddJiZwcm9wWydjaGFydC5iYWNrZ3JvdW5kLnZiYXJzJ10ubGVuZ3RoKXt0aGlzLkRyYXdWQmFycygpO31cbmlmKCFwcm9wWydjaGFydC5ub2F4ZXMnXSl7dGhpcy5EcmF3QXhlcygpO31cbnRoaXMuRHJhd0xhYmVscygpO2lmKHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZSddKXtjby5zYXZlKCk7Y28uYmVnaW5QYXRoKCk7Y28ucmVjdCgwLDAsY2Eud2lkdGgqcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnRyYWNlLmNsaXAnXSxjYS5oZWlnaHQpO2NvLmNsaXAoKTt9XG5mb3IoaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe3RoaXMuRHJhd01hcmtzKGkpO2NvLnNoYWRvd0NvbG9yPXByb3BbJ2NoYXJ0LmxpbmUuc2hhZG93LmNvbG9yJ107Y28uc2hhZG93T2Zmc2V0WD1wcm9wWydjaGFydC5saW5lLnNoYWRvdy5vZmZzZXR4J107Y28uc2hhZG93T2Zmc2V0WT1wcm9wWydjaGFydC5saW5lLnNoYWRvdy5vZmZzZXR5J107Y28uc2hhZG93Qmx1cj1wcm9wWydjaGFydC5saW5lLnNoYWRvdy5ibHVyJ107dGhpcy5EcmF3TGluZShpKTtSRy5Ob1NoYWRvdyh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5saW5lJ10pe2Zvcih2YXIgaT0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuO2krPTEpe3RoaXMuRHJhd01hcmtzKGkpO319XG5pZihwcm9wWydjaGFydC5hbmltYXRpb24udHJhY2UnXSl7Y28ucmVzdG9yZSgpO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLlNob3dDb250ZXh0KHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LmtleSddJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpe1JHLkRyYXdLZXkodGhpcyxwcm9wWydjaGFydC5rZXknXSxwcm9wWydjaGFydC5saW5lLmNvbG9ycyddKTt9XG5pZihwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUnXSl7dGhpcy5EcmF3QWJvdmVMYWJlbHMoKTt9XG50aGlzLkRyYXdJbkdyYXBoTGFiZWxzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO31cblJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO31cbnRoaXMuZHJhd0F4ZXM9dGhpcy5EcmF3QXhlcz1mdW5jdGlvbigpXG57dmFyIGdyYXBoSGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5heGlzLmNvbG9yJ107Y28ubGluZVdpZHRoPShwcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddfHwxKSswLjAwMTtpZihwcm9wWydjaGFydC5ub3lheGlzJ109PWZhbHNlKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsdGhpcy5ndXR0ZXJUb3ApO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTt9ZWxzZXtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCx0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTt9fVxuaWYocHJvcFsnY2hhcnQueGF4aXMnXSl7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQodGhpcy5ndXR0ZXJUb3ArKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpKSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsbWEucm91bmQodGhpcy5ndXR0ZXJUb3ArKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpKSk7fWVsc2V7dmFyIHk9dGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZTIubWluPjA/dGhpcy5zY2FsZTIubWluOjApO2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQseSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQseSk7fX1cbmlmKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXT09PWZhbHNlKXt2YXIgbnVteXRpY2tzPXByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddO2ZvcihpPTA7aTxudW15dGlja3M7KytpKXt2YXIgeT0oKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvbnVteXRpY2tzKSppO3k9eSt0aGlzLmd1dHRlclRvcDtpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyYmaT09KG51bXl0aWNrcy8yKSl7Y29udGludWU7fVxuaWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnKXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LG1hLnJvdW5kKHkpKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LTMsbWEucm91bmQoeSkpO31lbHNle2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzMsTWF0aC5yb3VuZCh5KSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsTWF0aC5yb3VuZCh5KSk7fX1cbmlmKHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddPjApe2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInJiZwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdC0zLG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCszLG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO319XG5pZihwcm9wWydjaGFydC54YXhpcyddPT09ZmFsc2UmJnByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdC0zLG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnhheGlzJ109PT1mYWxzZSYmcHJvcFsnY2hhcnQueWF4aXNwb3MnXT09PSdyaWdodCcpe2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LG1hLnJvdW5kKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzMsbWEucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09PSdib3R0b20nJiZwcm9wWydjaGFydC5udW15dGlja3MnXT4wKXtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCcpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQodGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQtMyxtYS5yb3VuZCh0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pKSk7fWVsc2V7Y28ubW92ZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrMyxtYS5yb3VuZCh0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pKSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsbWEucm91bmQodGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKSkpO319fVxuaWYocHJvcFsnY2hhcnQubnVteHRpY2tzJ10+MCYmcHJvcFsnY2hhcnQueGF4aXMnXSl7dmFyIHg9MCx5PXRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J10/dGhpcy5zY2FsZTIubWF4Oih0aGlzLnNjYWxlMi5tYXg+MCYmdGhpcy5zY2FsZTIubWluPjA/dGhpcy5zY2FsZTIubWluOjApKS0zLHNpemU9MztpZihwcm9wWydjaGFydC55bWluJ109PT0wJiZwcm9wWydjaGFydC54YXhpc3BvcyddPT09J2JvdHRvbScpe3krPTM7fVxuaWYodGhpcy5zY2FsZTIubWF4PjAmJnRoaXMuc2NhbGUyLm1pbj4wKXt5Kz0zO31cbnRoaXMueFRpY2tHYXA9KHByb3BbJ2NoYXJ0LmxhYmVscyddJiZwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgpPygoY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3Byb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCk6KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8xMDtpZih0eXBlb2YocHJvcFsnY2hhcnQubnVteHRpY2tzJ10pPT0nbnVtYmVyJyl7dGhpcy54VGlja0dhcD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO31cbmZvcih4PSh0aGlzLmd1dHRlckxlZnQrKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0JyYmcHJvcFsnY2hhcnQubm95YXhpcyddPT1mYWxzZT90aGlzLnhUaWNrR2FwOjApKTt4PD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC0ocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnfHxwcm9wWydjaGFydC5ub3lheGlzJ109PXRydWU/LTE6MSkpO3grPXRoaXMueFRpY2tHYXApe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0JyYmcHJvcFsnY2hhcnQubm9lbmR4dGljayddPT10cnVlJiZ4PT0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkpe2NvbnRpbnVlO31lbHNlIGlmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdyaWdodCcmJnByb3BbJ2NoYXJ0Lm5vZW5keHRpY2snXT09dHJ1ZSYmeD09dGhpcy5ndXR0ZXJMZWZ0KXtjb250aW51ZTt9XG5jby5tb3ZlVG8obWEucm91bmQoeCkseSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHkrKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PT0nY2VudGVyJ3x8cHJvcFsnY2hhcnQueW1pbiddPDA/c2l6ZSoyOnNpemUpKTt9fVxuY28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoPTE7fTt0aGlzLmRyYXdMYWJlbHM9dGhpcy5EcmF3TGFiZWxzPWZ1bmN0aW9uKClcbntjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHhNaW49cHJvcFsnY2hhcnQueG1pbiddLHhNYXg9cHJvcFsnY2hhcnQueG1heCddLHlNYXg9dGhpcy5zY2FsZTIubWF4LHlNaW49cHJvcFsnY2hhcnQueW1pbiddP3Byb3BbJ2NoYXJ0LnltaW4nXTowLHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSx1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J10sbnVtWUxhYmVscz1wcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10saW52ZXJ0PXByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J10saW5zaWRlPXByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10sY29udGV4dD1jbyxjYW52YXM9Y2EsYm94ZWQ9ZmFsc2Usb2Zmc2V0eD1wcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddXG50aGlzLmhhbGZUZXh0SGVpZ2h0PXRleHRfc2l6ZS8yO3RoaXMuaGFsZkdyYXBoSGVpZ2h0PShjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzI7aWYocHJvcFsnY2hhcnQueWxhYmVscyddKXt2YXIgeFBvcz1wcm9wWydjaGFydC55YXhpc3BvcyddPT0nbGVmdCc/dGhpcy5ndXR0ZXJMZWZ0LTU6Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs1O3ZhciBhbGlnbj1wcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnPydsZWZ0JzoncmlnaHQnO2lmKGluc2lkZSl7aWYocHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnKXt4UG9zPXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10rNTthbGlnbj0nbGVmdCc7Ym94ZWQ9dHJ1ZTt9ZWxzZXt4UG9zPWNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLTU7YWxpZ249J3JpZ2h0Jztib3hlZD10cnVlO319XG5pZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7aWYodHlwZW9mKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk9PSdvYmplY3QnJiZwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10hPW51bGwmJnByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGgpe3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddO2lmKHByb3BbJ2NoYXJ0LnltaW4nXT4wKXtsYWJlbHM9W107Zm9yKHZhciBpPTA7aTwocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aC0xKTsrK2kpe2xhYmVscy5wdXNoKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXVtpXSk7fX1cbmZvcih2YXIgaT0wO2k8bGFiZWxzLmxlbmd0aDsrK2kpe3ZhciB5PXRoaXMuZ3V0dGVyVG9wKyhpKih0aGlzLmdyYXBoYXJlYS8obGFiZWxzLmxlbmd0aCoyKSkpO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzpsYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwndGFnJzonbGFiZWxzLnNwZWNpZmljJ30pO31cbnZhciByZXZlcnNlZF9sYWJlbHM9UkcuYXJyYXlfcmV2ZXJzZShsYWJlbHMpO2Zvcih2YXIgaT0wO2k8cmV2ZXJzZWRfbGFiZWxzLmxlbmd0aDsrK2kpe3ZhciB5PXRoaXMuZ3V0dGVyVG9wKyh0aGlzLmdyYXBoYXJlYS8yKSsoKGkrMSkqKHRoaXMuZ3JhcGhhcmVhLyhsYWJlbHMubGVuZ3RoKjIpKSk7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eFBvcytvZmZzZXR4LCd5Jzp5K29mZnNldHksJ3RleHQnOnJldmVyc2VkX2xhYmVsc1tpXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJveGVkLCd0YWcnOidsYWJlbHMuc3BlY2lmaWMnfSk7fVxuaWYocHJvcFsnY2hhcnQueW1pbiddIT0wKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOih0aGlzLmdyYXBoYXJlYS8yKSt0aGlzLmd1dHRlclRvcCtvZmZzZXR5LCd0ZXh0Jzpwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11bcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aC0xXSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJveGVkLCd0YWcnOidsYWJlbHMuc3BlY2lmaWMnfSk7fX1cbmlmKCFwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10mJnR5cGVvZiBudW1ZTGFiZWxzPT0nbnVtYmVyJyl7Zm9yKHZhciBpPTAsbGVuPXRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7aTxsZW47aSs9MSl7aWYoIWludmVydCl7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eFBvcytvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCt0aGlzLmhhbGZHcmFwaEhlaWdodC0oKChpKzEpL251bVlMYWJlbHMpKnRoaXMuaGFsZkdyYXBoSGVpZ2h0KStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym94ZWQsJ2JvdW5kaW5nRmlsbCc6J3doaXRlJywndGV4dCc6dGhpcy5zY2FsZTIubGFiZWxzW2ldLCd0YWcnOidzY2FsZSd9KTt9ZWxzZXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZkdyYXBoSGVpZ2h0LSgoaS9udW1ZTGFiZWxzKSp0aGlzLmhhbGZHcmFwaEhlaWdodCkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJveGVkLCdib3VuZGluZ0ZpbGwnOid3aGl0ZScsJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1t0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoLShpKzEpXSwndGFnJzonc2NhbGUnfSk7fX1cbmZvcih2YXIgaT0wLGxlbj10aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKCFpbnZlcnQpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmR3JhcGhIZWlnaHQrdGhpcy5oYWxmR3JhcGhIZWlnaHQtKChpL251bVlMYWJlbHMpKnRoaXMuaGFsZkdyYXBoSGVpZ2h0KStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym94ZWQsJ2JvdW5kaW5nRmlsbCc6J3doaXRlJywndGV4dCc6Jy0nK3RoaXMuc2NhbGUyLmxhYmVsc1tsZW4tKGkrMSldLCd0YWcnOidzY2FsZSd9KTt9ZWxzZXtpZihpPT0obGVuLTEpJiZpbnZlcnQpe2NvbnRpbnVlO31cblJHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArdGhpcy5oYWxmR3JhcGhIZWlnaHQrdGhpcy5oYWxmR3JhcGhIZWlnaHQtKCgoaSsxKS9udW1ZTGFiZWxzKSp0aGlzLmhhbGZHcmFwaEhlaWdodCkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJveGVkLCdib3VuZGluZ0ZpbGwnOid3aGl0ZScsJ3RleHQnOictJyt0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3RhZyc6J3NjYWxlJ30pO319XG5pZighaW52ZXJ0JiYoeU1pbj4wfHxwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSkpe1JHLnRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnRleHRfc2l6ZSx4OnhQb3Mrb2Zmc2V0eCx5OnRoaXMuZ3V0dGVyVG9wK3RoaXMuaGFsZkdyYXBoSGVpZ2h0K29mZnNldHksdmFsaWduOidjZW50ZXInLGhhbGlnbjphbGlnbixib3VuZGluZzpib3hlZCxib3VuZGluZ0ZpbGw6J3doaXRlJyx0ZXh0OlJHLm51bWJlckZvcm1hdCh0aGlzLHlNaW4udG9GaXhlZCh0aGlzLnNjYWxlMi5taW49PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLHRhZzonc2NhbGUnfSk7fVxuaWYoaW52ZXJ0KXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0ZXh0JzpSRy5udW1iZXJfZm9ybWF0KHRoaXMseU1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbj09PTA/MDpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ3RhZyc6J3NjYWxlJ30pO1JHLnRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArKHRoaXMuaGFsZkdyYXBoSGVpZ2h0KjIpK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0ZXh0JzonLScrUkcubnVtYmVyRm9ybWF0KHRoaXMseU1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbj09PTA/MDpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSx1bml0c19wcmUsdW5pdHNfcG9zdCksJ3RhZyc6J3NjYWxlJ30pO319fWVsc2V7dmFyIHhQb3M9cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J2xlZnQnP3RoaXMuZ3V0dGVyTGVmdC01OmNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQrNTt2YXIgYWxpZ249cHJvcFsnY2hhcnQueWF4aXNwb3MnXT09J3JpZ2h0Jz8nbGVmdCc6J3JpZ2h0JztpZihpbnNpZGUpe2lmKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ109PSdsZWZ0Jyl7eFBvcz1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddKzU7YWxpZ249J2xlZnQnO2JveGVkPXRydWU7fWVsc2V7eFBvcz1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LTU7YWxpZ249J3JpZ2h0Jztib3hlZD10cnVlO319XG5pZih0eXBlb2YgcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddPT0nb2JqZWN0JyYmcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKXt2YXIgbGFiZWxzPXByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXTtpZihwcm9wWydjaGFydC55bWluJ10+OTk5OSl7bGFiZWxzPVtdO2Zvcih2YXIgaT0wO2k8KHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGgtMSk7KytpKXtsYWJlbHMucHVzaChwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11baV0pO319XG5mb3IodmFyIGk9MCxsZW49bGFiZWxzLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgeT10aGlzLmd1dHRlclRvcCsoaSoodGhpcy5ncmFwaGFyZWEvKGxlbi0xKSkpO1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd0ZXh0JzpsYWJlbHNbaV0sJ2hhbGlnbic6YWxpZ24sJ3ZhbGlnbic6J2NlbnRlcicsJ2JvdW5kaW5nJzpib3hlZCwndGFnJzonc2NhbGUnfSk7fX1lbHNle2lmKHR5cGVvZihudW1ZTGFiZWxzKT09J251bWJlcicpe2lmKGludmVydCl7Zm9yKHZhciBpPTA7aTxudW1ZTGFiZWxzOysraSl7dmFyIGludGVydmFsPShjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pL251bVlMYWJlbHM7UkcuVGV4dDIodGhpcyx7J2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwneCc6eFBvcytvZmZzZXR4LCd5Jzp0aGlzLmd1dHRlclRvcCsoKGkrMSkqaW50ZXJ2YWwpK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0ZXh0Jzp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sJ3RhZyc6J3NjYWxlJ30pO31cbmlmKCFwcm9wWydjaGFydC54YXhpcyddJiYhcHJvcFsnY2hhcnQueW1pbiddKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0ZXh0JzpSRy5udW1iZXJGb3JtYXQodGhpcywodGhpcy5taW4pLnRvRml4ZWQodGhpcy5zY2FsZTIubWluPT09MD8wOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLHVuaXRzX3ByZSx1bml0c19wb3N0KSwndGFnJzonc2NhbGUnfSk7fX1lbHNle2Zvcih2YXIgaT0wLGxlbj10aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoO2k8bGVuO2krPTEpe1JHLlRleHQyKHRoaXMseydmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ3gnOnhQb3Mrb2Zmc2V0eCwneSc6dGhpcy5ndXR0ZXJUb3ArdGhpcy5ncmFwaGFyZWEtKCgoaSsxKS90aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSp0aGlzLmdyYXBoYXJlYSkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzphbGlnbiwnYm91bmRpbmcnOmJveGVkLCdib3VuZGluZ0ZpbGwnOid3aGl0ZScsJ3RleHQnOnRoaXMuc2NhbGUyLmxhYmVsc1tpXSwndGFnJzonc2NhbGUnfSk7fVxuaWYoIXByb3BbJ2NoYXJ0LnhheGlzJ10mJnByb3BbJ2NoYXJ0LnltaW4nXT09MCl7UkcudGV4dDIodGhpcyx7Zm9udDpmb250LHNpemU6dGV4dF9zaXplLHg6eFBvcytvZmZzZXR4LHk6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHksdmFsaWduOidjZW50ZXInLGhhbGlnbjphbGlnbixib3VuZGluOmJveGVkLGJvdW5kaW5nRmlsbDond2hpdGUnLHRleHQ6UkcubnVtYmVyRm9ybWF0KHRoaXMsKDApLnRvRml4ZWQodGhpcy5zY2FsZTIubWluPT09MD8wOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLHVuaXRzX3ByZSx1bml0c19wb3N0KSx0YWc6J3NjYWxlJ30pO319fVxuaWYoKHByb3BbJ2NoYXJ0LnltaW4nXXx8cHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pJiYhaW52ZXJ0KXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOmNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOmFsaWduLCdib3VuZGluZyc6Ym94ZWQsJ2JvdW5kaW5nRmlsbCc6J3doaXRlJywndGV4dCc6UkcubnVtYmVyRm9ybWF0KHRoaXMscHJvcFsnY2hhcnQueW1pbiddLnRvRml4ZWQodGhpcy5zY2FsZTIubWluPT09MD8wOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLHVuaXRzX3ByZSx1bml0c19wb3N0KSwndGFnJzonc2NhbGUnfSk7fWVsc2UgaWYoaW52ZXJ0KXtSRy50ZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6dGV4dF9zaXplLCd4Jzp4UG9zK29mZnNldHgsJ3knOnRoaXMuZ3V0dGVyVG9wK29mZnNldHksJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6YWxpZ24sJ2JvdW5kaW5nJzpib3hlZCwnYm91bmRpbmdGaWxsJzond2hpdGUnLCd0ZXh0JzpSRy5udW1iZXJGb3JtYXQodGhpcyxwcm9wWydjaGFydC55bWluJ10udG9GaXhlZCh0aGlzLnNjYWxlMi5taW49PT0wPzA6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLCd0YWcnOidzY2FsZSd9KTt9fX19XG5pZihwcm9wWydjaGFydC54c2NhbGUnXSl7dmFyIG51bVhMYWJlbHM9cHJvcFsnY2hhcnQueHNjYWxlLm51bWxhYmVscyddLHk9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzUrKHRleHRfc2l6ZS8yKSx1bml0c19wcmVfeD1wcm9wWydjaGFydC54c2NhbGUudW5pdHMucHJlJ10sdW5pdHNfcG9zdF94PXByb3BbJ2NoYXJ0LnhzY2FsZS51bml0cy5wb3N0J10sZGVjaW1hbHM9cHJvcFsnY2hhcnQueHNjYWxlLmRlY2ltYWxzJ10scG9pbnQ9cHJvcFsnY2hhcnQueHNjYWxlLnBvaW50J10sdGhvdXNhbmQ9cHJvcFsnY2hhcnQueHNjYWxlLnRob3VzYW5kJ10sY29sb3I9cHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10sYm9sZD1wcm9wWydjaGFydC5sYWJlbHMuYm9sZCddLG9mZnNldHg9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxvZmZzZXR5PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J11cbmlmKCFwcm9wWydjaGFydC54bWF4J10pe3ZhciB4bWF4PTA7dmFyIHhtaW49cHJvcFsnY2hhcnQueG1pbiddO2Zvcih2YXIgZHM9MCxsZW49dGhpcy5kYXRhLmxlbmd0aDtkczxsZW47ZHMrPTEpe2Zvcih2YXIgcG9pbnQ9MCxsZW4yPXRoaXMuZGF0YVtkc10ubGVuZ3RoO3BvaW50PGxlbjI7cG9pbnQrPTEpe3htYXg9TWF0aC5tYXgoeG1heCx0aGlzLmRhdGFbZHNdW3BvaW50XVswXSk7fX19ZWxzZXt4bWF4PXByb3BbJ2NoYXJ0LnhtYXgnXTt4bWluPXByb3BbJ2NoYXJ0LnhtaW4nXX1cbnRoaXMueHNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6eG1heCwnbWluJzp4bWluLCdzY2FsZS5kZWNpbWFscyc6ZGVjaW1hbHMsJ3NjYWxlLnBvaW50Jzpwb2ludCwnc2NhbGUudGhvdXNhbmQnOnRob3VzYW5kLCd1bml0cy5wcmUnOnVuaXRzX3ByZV94LCd1bml0cy5wb3N0Jzp1bml0c19wb3N0X3gsJ3lsYWJlbHMuY291bnQnOm51bVhMYWJlbHMsJ3N0cmljdCc6dHJ1ZX0pO3RoaXMuU2V0KCdjaGFydC54bWF4Jyx0aGlzLnhzY2FsZTIubWF4KTt2YXIgaW50ZXJ2YWw9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS90aGlzLnhzY2FsZTIubGFiZWxzLmxlbmd0aDtmb3IodmFyIGk9MCxsZW49dGhpcy54c2NhbGUyLmxhYmVscy5sZW5ndGg7aTxsZW47aSs9MSl7dmFyIG51bT0oKHByb3BbJ2NoYXJ0LnhtYXgnXS1wcm9wWydjaGFydC54bWluJ10pKigoaSsxKS9udW1YTGFiZWxzKSkrKHhtaW58fDApLHg9dGhpcy5ndXR0ZXJMZWZ0KygoaSsxKSppbnRlcnZhbCksdGV4dD10eXBlb2YgcHJvcFsnY2hhcnQueHNjYWxlLmZvcm1hdHRlciddPT09J2Z1bmN0aW9uJz9TdHJpbmcocHJvcFsnY2hhcnQueHNjYWxlLmZvcm1hdHRlciddKHRoaXMsbnVtKSk6dGhpcy54c2NhbGUyLmxhYmVsc1tpXTtSRy50ZXh0Mih0aGlzLHsnY29sb3InOmNvbG9yLCdmb250Jzpmb250LCdzaXplJzp0ZXh0X3NpemUsJ2JvbGQnOmJvbGQsJ3gnOngrb2Zmc2V0eCwneSc6eStvZmZzZXR5LCd2YWxpZ24nOidjZW50ZXInLCdoYWxpZ24nOidjZW50ZXInLCd0ZXh0Jzp0ZXh0LCd0YWcnOid4c2NhbGUnfSk7fVxudmFyIHRleHQ9dHlwZW9mIHByb3BbJ2NoYXJ0LnhzY2FsZS5mb3JtYXR0ZXInXT09PSdmdW5jdGlvbic/U3RyaW5nKHByb3BbJ2NoYXJ0LnhzY2FsZS5mb3JtYXR0ZXInXSh0aGlzLHByb3BbJ2NoYXJ0LnhtaW4nXSkpOlN0cmluZyhwcm9wWydjaGFydC54bWluJ10pO1JHLnRleHQyKHRoaXMseydjb2xvcic6Y29sb3IsJ2ZvbnQnOmZvbnQsJ3NpemUnOnRleHRfc2l6ZSwnYm9sZCc6Ym9sZCwneCc6dGhpcy5ndXR0ZXJMZWZ0K29mZnNldHgsJ3knOnkrb2Zmc2V0eSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywndGV4dCc6dGV4dCwndGFnJzoneHNjYWxlJ30pO31lbHNle3ZhciBncmFwaEFyZWE9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQ7dmFyIHhJbnRlcnZhbD1ncmFwaEFyZWEvcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoO3ZhciB4UG9zPXRoaXMuZ3V0dGVyTGVmdDt2YXIgeVBvcz0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSszO3ZhciBsYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzJ107dmFyIGNvbG9yPXByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddO3ZhciBib2xkPXByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ107dmFyIG9mZnNldHg9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXTt2YXIgb2Zmc2V0eT1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddO3ZhciBhbmdsZT0wO3ZhciB2YWxpZ249J3RvcCc7dmFyIGhhbGlnbj0nY2VudGVyJztpZihwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ10+MCl7YW5nbGU9LTEqcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddO3ZhbGlnbj0nY2VudGVyJztoYWxpZ249J3JpZ2h0Jzt5UG9zKz0xMDt9XG5mb3IoaT0wO2k8bGFiZWxzLmxlbmd0aDsrK2kpe2lmKHR5cGVvZihsYWJlbHNbaV0pPT0nb2JqZWN0Jyl7aWYocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljLmFsaWduJ109PSdjZW50ZXInKXt2YXIgcmlnaHRFZGdlPTA7aWYobGFiZWxzW2krMV0mJmxhYmVsc1tpKzFdWzFdKXtyaWdodEVkZ2U9bGFiZWxzW2krMV1bMV07fWVsc2V7cmlnaHRFZGdlPXByb3BbJ2NoYXJ0LnhtYXgnXTt9XG52YXIgb2Zmc2V0PSh0aGlzLmdldFhDb29yZChyaWdodEVkZ2UpLXRoaXMuZ2V0WENvb3JkKGxhYmVsc1tpXVsxXSkpLzI7fWVsc2V7dmFyIG9mZnNldD01O31cblJHLnRleHQyKHRoaXMseydjb2xvcic6Y29sb3IsJ2ZvbnQnOmZvbnQsJ3NpemUnOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCdib2xkJzpib2xkLCd4Jzp0aGlzLmdldFhDb29yZChsYWJlbHNbaV1bMV0pK29mZnNldCtvZmZzZXR4LCd5Jzp5UG9zK29mZnNldHksJ3ZhbGlnbic6dmFsaWduLCdoYWxpZ24nOmFuZ2xlIT0wPydyaWdodCc6KHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYy5hbGlnbiddPT0nY2VudGVyJz8nY2VudGVyJzonbGVmdCcpLCd0ZXh0JzpTdHJpbmcobGFiZWxzW2ldWzBdKSwnYW5nbGUnOmFuZ2xlLCdtYXJrZXInOmZhbHNlLCd0YWcnOidsYWJlbHMuc3BlY2lmaWMnfSk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9JyNiYmInO2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQrKGdyYXBoQXJlYSooKGxhYmVsc1tpXVsxXS14TWluKS8ocHJvcFsnY2hhcnQueG1heCddLXhNaW4pKSkpLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCsoZ3JhcGhBcmVhKigobGFiZWxzW2ldWzFdLXhNaW4pLyhwcm9wWydjaGFydC54bWF4J10teE1pbikpKSksY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzIwKTtjby5zdHJva2UoKTt9ZWxzZXtSRy50ZXh0Mih0aGlzLHsnY29sb3InOmNvbG9yLCdmb250Jzpmb250LCdzaXplJzpwcm9wWydjaGFydC50ZXh0LnNpemUnXSwnYm9sZCc6Ym9sZCwneCc6eFBvcysoeEludGVydmFsLzIpK29mZnNldHgsJ3knOnlQb3Mrb2Zmc2V0eSwndmFsaWduJzp2YWxpZ24sJ2hhbGlnbic6aGFsaWduLCd0ZXh0JzpTdHJpbmcobGFiZWxzW2ldKSwnYW5nbGUnOmFuZ2xlLCd0YWcnOidsYWJlbHMnfSk7fVxueFBvcys9eEludGVydmFsO31cbmlmKHR5cGVvZihsYWJlbHNbMF0pPT0nb2JqZWN0Jyl7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9JyNiYmInO2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQrZ3JhcGhBcmVhLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCtncmFwaEFyZWEsY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzIwKTtjby5zdHJva2UoKTt9fX07dGhpcy5kcmF3TWFya3M9dGhpcy5EcmF3TWFya3M9ZnVuY3Rpb24oaSlcbnt0aGlzLmNvb3Jkc1tpXT1bXTt2YXIgeG1heD1wcm9wWydjaGFydC54bWF4J107dmFyIGRlZmF1bHRfY29sb3I9cHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ107Zm9yKHZhciBqPTAsbGVuPXRoaXMuZGF0YVtpXS5sZW5ndGg7ajxsZW47ais9MSl7dmFyIGRhdGFfcG9pbnRzPXRoaXMuZGF0YVtpXTtpZihSRy5pc051bGwoZGF0YV9wb2ludHNbal0pKXtjb250aW51ZTt9XG52YXIgeENvb3JkPWRhdGFfcG9pbnRzW2pdWzBdO3ZhciB5Q29vcmQ9ZGF0YV9wb2ludHNbal1bMV07dmFyIGNvbG9yPWRhdGFfcG9pbnRzW2pdWzJdP2RhdGFfcG9pbnRzW2pdWzJdOmRlZmF1bHRfY29sb3I7dmFyIHRvb2x0aXA9KGRhdGFfcG9pbnRzW2pdJiZkYXRhX3BvaW50c1tqXVszXSk/ZGF0YV9wb2ludHNbal1bM106bnVsbDt0aGlzLkRyYXdNYXJrKGkseENvb3JkLHlDb29yZCx4bWF4LHRoaXMuc2NhbGUyLm1heCxjb2xvcix0b29sdGlwLHRoaXMuY29vcmRzW2ldLGRhdGFfcG9pbnRzLGopO319O3RoaXMuZHJhd01hcms9dGhpcy5EcmF3TWFyaz1mdW5jdGlvbihkYXRhX3NldF9pbmRleCx4LHkseE1heCx5TWF4LGNvbG9yLHRvb2x0aXAsY29vcmRzLGRhdGEsZGF0YV9pbmRleClcbnt2YXIgdGlja21hcmtzPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddLHRpY2tTaXplPXByb3BbJ2NoYXJ0LnRpY2tzaXplJ10seE1pbj1wcm9wWydjaGFydC54bWluJ10seD0oKHgteE1pbikvKHhNYXgteE1pbikpKihjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCksb3JpZ2luYWxYPXgsb3JpZ2luYWxZPXk7aWYodGlja21hcmtzJiZ0eXBlb2YodGlja21hcmtzKT09J29iamVjdCcpe3RpY2ttYXJrcz10aWNrbWFya3NbZGF0YV9zZXRfaW5kZXhdO31cbmlmKHR5cGVvZih0aWNrU2l6ZSk9PSdvYmplY3QnKXt2YXIgdGlja1NpemU9dGlja1NpemVbZGF0YV9zZXRfaW5kZXhdO3ZhciBoYWxmVGlja1NpemU9dGlja1NpemUvMjt9ZWxzZXt2YXIgaGFsZlRpY2tTaXplPXRpY2tTaXplLzI7fVxuaWYoeSYmdHlwZW9mIHk9PT0nb2JqZWN0JyYmdHlwZW9mIHlbMF09PT0nbnVtYmVyJyYmdHlwZW9mIHlbMV09PT0nbnVtYmVyJyYmdHlwZW9mIHlbMl09PT0nbnVtYmVyJyYmdHlwZW9mIHlbM109PT0nbnVtYmVyJyYmdHlwZW9mIHlbNF09PT0nbnVtYmVyJyl7dGhpcy5TZXQoJ2NoYXJ0LmJveHBsb3QnLHRydWUpO3ZhciB5MD10aGlzLmdldFlDb29yZCh5WzBdKSx5MT10aGlzLmdldFlDb29yZCh5WzFdKSx5Mj10aGlzLmdldFlDb29yZCh5WzJdKSx5Mz10aGlzLmdldFlDb29yZCh5WzNdKSx5ND10aGlzLmdldFlDb29yZCh5WzRdKSxjb2wxPXlbNV0sY29sMj15WzZdLGJveFdpZHRoPXR5cGVvZiB5WzddPT0nbnVtYmVyJz95WzddOnByb3BbJ2NoYXJ0LmJveHBsb3Qud2lkdGgnXTt9ZWxzZXt2YXIgeUNvb3JkPXRoaXMuZ2V0WUNvb3JkKHkpO31cbngrPXRoaXMuZ3V0dGVyTGVmdDtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1jb2xvcjtpZihwcm9wWydjaGFydC5ib3hwbG90J10pe2JveFdpZHRoPShib3hXaWR0aC9wcm9wWydjaGFydC54bWF4J10pKihjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCk7dmFyIGhhbGZCb3hXaWR0aD1ib3hXaWR0aC8yO2lmKHByb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddKXtjby5iZWdpblBhdGgoKTtpZih0eXBlb2YgeVs4XT09PSdzdHJpbmcnKXtjby5zdHJva2VTdHlsZT15WzhdO31cbmNvLnN0cm9rZVJlY3QoeC1oYWxmQm94V2lkdGgseTEsYm94V2lkdGgseTMteTEpO2lmKGNvbDEpe2NvLmZpbGxTdHlsZT1jb2wxO2NvLmZpbGxSZWN0KHgtaGFsZkJveFdpZHRoLHkxLGJveFdpZHRoLHkyLXkxKTt9XG5pZihjb2wyKXtjby5maWxsU3R5bGU9Y29sMjtjby5maWxsUmVjdCh4LWhhbGZCb3hXaWR0aCx5Mixib3hXaWR0aCx5My15Mik7fVxuY28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7aWYocHJvcFsnY2hhcnQuYm94cGxvdC5jYXBwZWQnXSl7Y28ubW92ZVRvKHgtaGFsZkJveFdpZHRoLG1hLnJvdW5kKHkwKSk7Y28ubGluZVRvKHgraGFsZkJveFdpZHRoLG1hLnJvdW5kKHkwKSk7fVxuY28ubW92ZVRvKG1hLnJvdW5kKHgpLHkwKTtjby5saW5lVG8obWEucm91bmQoeCkseTEpO2lmKHByb3BbJ2NoYXJ0LmJveHBsb3QuY2FwcGVkJ10pe2NvLm1vdmVUbyh4LWhhbGZCb3hXaWR0aCxtYS5yb3VuZCh5NCkpO2NvLmxpbmVUbyh4K2hhbGZCb3hXaWR0aCxtYS5yb3VuZCh5NCkpO31cbmNvLm1vdmVUbyhtYS5yb3VuZCh4KSx5NCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLHkzKTtjby5zdHJva2UoKTt9fVxuaWYocHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ10mJnR5cGVvZih5KT09J251bWJlcicmJiF5MCYmIXkxJiYheTImJiF5MyYmIXk0KXtpZih0aWNrbWFya3M9PSdjaXJjbGUnKXtjby5hcmMoeCx5Q29vcmQsaGFsZlRpY2tTaXplLDAsNi4yOCwwKTtjby5maWxsU3R5bGU9Y29sb3I7Y28uZmlsbCgpO31lbHNlIGlmKHRpY2ttYXJrcz09J3BsdXMnKXtjby5tb3ZlVG8oeCx5Q29vcmQtaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCx5Q29vcmQraGFsZlRpY2tTaXplKTtjby5tb3ZlVG8oeC1oYWxmVGlja1NpemUseUNvb3JkKTtjby5saW5lVG8oeCtoYWxmVGlja1NpemUseUNvb3JkKTtjby5zdHJva2UoKTt9ZWxzZSBpZih0aWNrbWFya3M9PSdzcXVhcmUnKXtjby5zdHJva2VTdHlsZT1jb2xvcjtjby5maWxsU3R5bGU9Y29sb3I7Y28uZmlsbFJlY3QoeC1oYWxmVGlja1NpemUseUNvb3JkLWhhbGZUaWNrU2l6ZSx0aWNrU2l6ZSx0aWNrU2l6ZSk7fWVsc2UgaWYodGlja21hcmtzPT0nY3Jvc3MnKXtjby5tb3ZlVG8oeC1oYWxmVGlja1NpemUseUNvb3JkLWhhbGZUaWNrU2l6ZSk7Y28ubGluZVRvKHgraGFsZlRpY2tTaXplLHlDb29yZCtoYWxmVGlja1NpemUpO2NvLm1vdmVUbyh4K2hhbGZUaWNrU2l6ZSx5Q29vcmQtaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeC1oYWxmVGlja1NpemUseUNvb3JkK2hhbGZUaWNrU2l6ZSk7Y28uc3Ryb2tlKCk7fWVsc2UgaWYodGlja21hcmtzPT0nZGlhbW9uZCcpe2NvLmZpbGxTdHlsZT1jby5zdHJva2VTdHlsZTtjby5tb3ZlVG8oeCx5Q29vcmQtaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCtoYWxmVGlja1NpemUseUNvb3JkKTtjby5saW5lVG8oeCx5Q29vcmQraGFsZlRpY2tTaXplKTtjby5saW5lVG8oeC1oYWxmVGlja1NpemUseUNvb3JkKTtjby5saW5lVG8oeCx5Q29vcmQtaGFsZlRpY2tTaXplKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7fWVsc2UgaWYodHlwZW9mKHRpY2ttYXJrcyk9PSdmdW5jdGlvbicpe3ZhciBncmFwaFdpZHRoPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0LGdyYXBoaGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSx4VmFsPSgoeC10aGlzLmd1dHRlckxlZnQpL2dyYXBoV2lkdGgpKnhNYXgseVZhbD0oKGdyYXBoaGVpZ2h0LSh5Q29vcmQtdGhpcy5ndXR0ZXJUb3ApKS9ncmFwaGhlaWdodCkqeU1heDt0aWNrbWFya3ModGhpcyxkYXRhLHgseUNvb3JkLHhWYWwseVZhbCx4TWF4LHlNYXgsY29sb3IsZGF0YV9zZXRfaW5kZXgsZGF0YV9pbmRleCl9ZWxzZSBpZih0eXBlb2YgdGlja21hcmtzPT09J3N0cmluZycmJih0aWNrbWFya3Muc3Vic3RyKDAsNik9PT0naW1hZ2U6J3x8dGlja21hcmtzLnN1YnN0cigwLDUpPT09J2RhdGE6J3x8dGlja21hcmtzLnN1YnN0cigwLDEpPT09Jy8nfHx0aWNrbWFya3Muc3Vic3RyKDAsMyk9PT0nLi4vJ3x8dGlja21hcmtzLnN1YnN0cigwLDcpPT09J2ltYWdlcy8nKSl7dmFyIGltZz1uZXcgSW1hZ2UoKTtpZih0aWNrbWFya3Muc3Vic3RyKDAsNik9PT0naW1hZ2U6Jyl7aW1nLnNyYz10aWNrbWFya3Muc3Vic3RyKDYpO31lbHNle2ltZy5zcmM9dGlja21hcmtzO31cbmltZy5vbmxvYWQ9ZnVuY3Rpb24oKVxue2lmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5oYWxpZ24nXT09PSdjZW50ZXInKXgtPSh0aGlzLndpZHRoLzIpO2lmKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5oYWxpZ24nXT09PSdyaWdodCcpeC09dGhpcy53aWR0aDtpZihwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UudmFsaWduJ109PT0nY2VudGVyJyl5Q29vcmQtPSh0aGlzLmhlaWdodC8yKTtpZihwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UudmFsaWduJ109PT0nYm90dG9tJyl5Q29vcmQtPXRoaXMuaGVpZ2h0O3grPXByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR4J107eUNvb3JkKz1wcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2Uub2Zmc2V0eSddO2NvLmRyYXdJbWFnZSh0aGlzLHgseUNvb3JkKTt9fWVsc2UgaWYodGlja21hcmtzPT09bnVsbCl7fWVsc2V7YWxlcnQoJ1tTQ0FUVEVSXSAoJyt0aGlzLmlkKycpIFVua25vd24gdGlja21hcmsgc3R5bGU6ICcrdGlja21hcmtzKTt9fVxuaWYocHJvcFsnY2hhcnQuYm94cGxvdCddJiZ0eXBlb2YgeTA9PT0nbnVtYmVyJyYmdHlwZW9mIHkxPT09J251bWJlcicmJnR5cGVvZiB5Mj09PSdudW1iZXInJiZ0eXBlb2YgeTM9PT0nbnVtYmVyJyYmdHlwZW9mIHk0PT09J251bWJlcicpe3g9W3gtaGFsZkJveFdpZHRoLHgraGFsZkJveFdpZHRoXTt5Q29vcmQ9W3kwLHkxLHkyLHkzLHk0XTt9XG5jb29yZHMucHVzaChbeCx5Q29vcmQsdG9vbHRpcF0pO307dGhpcy5kcmF3TGluZT10aGlzLkRyYXdMaW5lPWZ1bmN0aW9uKGkpXG57aWYodHlwZW9mKHByb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddKT09J2Jvb2xlYW4nJiZwcm9wWydjaGFydC5saW5lLnZpc2libGUnXT09ZmFsc2Upe3JldHVybjt9XG5pZihwcm9wWydjaGFydC5saW5lJ10mJnRoaXMuY29vcmRzW2ldLmxlbmd0aD49Mil7aWYocHJvcFsnY2hhcnQubGluZS5kYXNoJ10mJnR5cGVvZiBjby5zZXRMaW5lRGFzaD09PSdmdW5jdGlvbicpe2NvLnNldExpbmVEYXNoKHByb3BbJ2NoYXJ0LmxpbmUuZGFzaCddKTt9XG5jby5saW5lQ2FwPSdyb3VuZCc7Y28ubGluZUpvaW49J3JvdW5kJztjby5saW5lV2lkdGg9dGhpcy5nZXRMaW5lV2lkdGgoaSk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQubGluZS5jb2xvcnMnXVtpXTtjby5iZWdpblBhdGgoKTt2YXIgcHJldlk9bnVsbDt2YXIgY3Vyclk9bnVsbDtmb3IodmFyIGo9MCxsZW49dGhpcy5jb29yZHNbaV0ubGVuZ3RoO2o8bGVuO2orPTEpe3ZhciB4UG9zPXRoaXMuY29vcmRzW2ldW2pdWzBdO3ZhciB5UG9zPXRoaXMuY29vcmRzW2ldW2pdWzFdO2lmKGo+MClwcmV2WT10aGlzLmNvb3Jkc1tpXVtqLTFdWzFdO2N1cnJZPXlQb3M7aWYoaj09MHx8UkcuaXNfbnVsbChwcmV2WSl8fFJHLmlzX251bGwoY3VyclkpKXtjby5tb3ZlVG8oeFBvcyx5UG9zKTt9ZWxzZXt2YXIgc3RlcHBlZD1wcm9wWydjaGFydC5saW5lLnN0ZXBwZWQnXTtpZigodHlwZW9mIHN0ZXBwZWQ9PSdib29sZWFuJyYmc3RlcHBlZCl8fCh0eXBlb2Ygc3RlcHBlZD09J29iamVjdCcmJnN0ZXBwZWRbaV0pKXtjby5saW5lVG8odGhpcy5jb29yZHNbaV1bal1bMF0sdGhpcy5jb29yZHNbaV1bai0xXVsxXSk7fVxuY28ubGluZVRvKHhQb3MseVBvcyk7fX1cbmNvLnN0cm9rZSgpO2lmKHByb3BbJ2NoYXJ0LmxpbmUuZGFzaCddJiZ0eXBlb2YgY28uc2V0TGluZURhc2g9PT0nZnVuY3Rpb24nKXtjby5zZXRMaW5lRGFzaChbMSwwXSk7fX1cbmNvLmxpbmVXaWR0aD0xO307dGhpcy5nZXRMaW5lV2lkdGg9dGhpcy5HZXRMaW5lV2lkdGg9ZnVuY3Rpb24oaSlcbnt2YXIgbGluZXdpZHRoPXByb3BbJ2NoYXJ0LmxpbmUubGluZXdpZHRoJ107aWYodHlwZW9mIGxpbmV3aWR0aD09J251bWJlcicpe3JldHVybiBsaW5ld2lkdGg7fWVsc2UgaWYodHlwZW9mIGxpbmV3aWR0aD09J29iamVjdCcpe2lmKGxpbmV3aWR0aFtpXSl7cmV0dXJuIGxpbmV3aWR0aFtpXTt9ZWxzZXtyZXR1cm4gbGluZXdpZHRoWzBdO31cbmFsZXJ0KCdbU0NBVFRFUl0gRXJyb3IhIGNoYXJ0LmxpbmV3aWR0aCBzaG91bGQgYmUgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5IG9mIG9uZSBvciBtb3JlIG51bWJlcnMnKTt9fTt0aGlzLmRyYXdWQmFycz10aGlzLkRyYXdWQmFycz1mdW5jdGlvbigpXG57dmFyIHZiYXJzPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXTt2YXIgZ3JhcGhXaWR0aD1jYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodDtpZih2YmFycyl7dmFyIHhtYXg9cHJvcFsnY2hhcnQueG1heCddO3ZhciB4bWluPXByb3BbJ2NoYXJ0LnhtaW4nXTtmb3IodmFyIGk9MCxsZW49dmJhcnMubGVuZ3RoO2k8bGVuO2krPTEpe3ZhciBrZXk9aTt2YXIgdmFsdWU9dmJhcnNba2V5XTtpZih0eXBlb2YgdmFsdWVbMF09PSdzdHJpbmcnKXZhbHVlWzBdPVJHLnBhcnNlRGF0ZSh2YWx1ZVswXSk7aWYodHlwZW9mIHZhbHVlWzFdPT0nc3RyaW5nJyl2YWx1ZVsxXT1SRy5wYXJzZURhdGUodmFsdWVbMV0pLXZhbHVlWzBdO3ZhciB4PSgoKHZhbHVlWzBdLXhtaW4pLyh4bWF4LXhtaW4pKSpncmFwaFdpZHRoKSt0aGlzLmd1dHRlckxlZnQ7dmFyIHdpZHRoPSh2YWx1ZVsxXS8oeG1heC14bWluKSkqZ3JhcGhXaWR0aDtjby5maWxsU3R5bGU9dmFsdWVbMl07Y28uZmlsbFJlY3QoeCx0aGlzLmd1dHRlclRvcCx3aWR0aCwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKSk7fX19O3RoaXMuZHJhd0luR3JhcGhMYWJlbHM9dGhpcy5EcmF3SW5HcmFwaExhYmVscz1mdW5jdGlvbihvYmopXG57dmFyIGxhYmVscz1vYmouR2V0KCdjaGFydC5sYWJlbHMuaW5ncmFwaCcpO3ZhciBsYWJlbHNfcHJvY2Vzc2VkPVtdO2lmKCFsYWJlbHMpe3JldHVybjt9XG52YXIgZmdjb2xvcj0nYmxhY2snO3ZhciBiZ2NvbG9yPSd3aGl0ZSc7dmFyIGRpcmVjdGlvbj0xO2Zvcih2YXIgaT0wLGxlbj1sYWJlbHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKHR5cGVvZihsYWJlbHNbaV0pPT0nbnVtYmVyJyl7Zm9yKHZhciBqPTA7ajxsYWJlbHNbaV07KytqKXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2gobnVsbCk7fX1lbHNlIGlmKHR5cGVvZihsYWJlbHNbaV0pPT0nc3RyaW5nJ3x8dHlwZW9mKGxhYmVsc1tpXSk9PSdvYmplY3QnKXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2gobGFiZWxzW2ldKTt9ZWxzZXtsYWJlbHNfcHJvY2Vzc2VkLnB1c2goJycpO319XG5SRy5Ob1NoYWRvdyhvYmopO2lmKGxhYmVsc19wcm9jZXNzZWQmJmxhYmVsc19wcm9jZXNzZWQubGVuZ3RoPjApe3ZhciBpPTA7Zm9yKHZhciBzZXQ9MDtzZXQ8b2JqLmNvb3Jkcy5sZW5ndGg7KytzZXQpe2Zvcih2YXIgcG9pbnQ9MDtwb2ludDxvYmouY29vcmRzW3NldF0ubGVuZ3RoOysrcG9pbnQpe2lmKGxhYmVsc19wcm9jZXNzZWRbaV0pe3ZhciB4PW9iai5jb29yZHNbc2V0XVtwb2ludF1bMF07dmFyIHk9b2JqLmNvb3Jkc1tzZXRdW3BvaW50XVsxXTt2YXIgbGVuZ3RoPXR5cGVvZihsYWJlbHNfcHJvY2Vzc2VkW2ldWzRdKT09J251bWJlcic/bGFiZWxzX3Byb2Nlc3NlZFtpXVs0XToyNTt2YXIgdGV4dF94PXg7dmFyIHRleHRfeT15LTUtbGVuZ3RoO2NvLm1vdmVUbyh4LHktNSk7Y28ubGluZVRvKHgseS01LWxlbmd0aCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgseS01KTtjby5saW5lVG8oeC0zLHktMTApO2NvLmxpbmVUbyh4KzMseS0xMCk7Y28uY2xvc2VQYXRoKCk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPSh0eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXSk9PSdvYmplY3QnJiZ0eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXVsxXSk9PSdzdHJpbmcnKT9sYWJlbHNfcHJvY2Vzc2VkW2ldWzFdOidibGFjayc7UkcudGV4dDIodGhpcyx7J2ZvbnQnOm9iai5HZXQoJ2NoYXJ0LnRleHQuZm9udCcpLCdzaXplJzpvYmouR2V0KCdjaGFydC50ZXh0LnNpemUnKSwneCc6dGV4dF94LCd5Jzp0ZXh0X3ksJ3RleHQnOih0eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXSk9PSdvYmplY3QnJiZ0eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXVswXSk9PSdzdHJpbmcnKT9sYWJlbHNfcHJvY2Vzc2VkW2ldWzBdOmxhYmVsc19wcm9jZXNzZWRbaV0sJ3ZhbGlnbic6J2JvdHRvbScsJ2hhbGlnbic6J2NlbnRlcicsJ2JvdW5kaW5nJzp0cnVlLCdib3VuZGluZy5maWxsJzoodHlwZW9mKGxhYmVsc19wcm9jZXNzZWRbaV0pPT0nb2JqZWN0JyYmdHlwZW9mKGxhYmVsc19wcm9jZXNzZWRbaV1bMl0pPT0nc3RyaW5nJyk/bGFiZWxzX3Byb2Nlc3NlZFtpXVsyXTond2hpdGUnLCd0YWcnOidsYWJlbHMuaW5ncmFwaCd9KTtjby5maWxsKCk7fVxuaSsrO319fX07dGhpcy5nZXRTaGFwZT10aGlzLmdldFBvaW50PWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlWFlbMF07dmFyIG1vdXNlWT1tb3VzZVhZWzFdO3ZhciBvdmVySG90c3BvdD1mYWxzZTt2YXIgb2Zmc2V0PXByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3QnXTtmb3IodmFyIHNldD0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7c2V0PGxlbjsrK3NldCl7Zm9yKHZhciBpPTAsbGVuMj10aGlzLmNvb3Jkc1tzZXRdLmxlbmd0aDtpPGxlbjI7KytpKXt2YXIgeD10aGlzLmNvb3Jkc1tzZXRdW2ldWzBdO3ZhciB5PXRoaXMuY29vcmRzW3NldF1baV1bMV07dmFyIHRvb2x0aXA9dGhpcy5kYXRhW3NldF1baV1bM107aWYodHlwZW9mKHkpPT0nbnVtYmVyJyl7aWYobW91c2VYPD0oeCtvZmZzZXQpJiZtb3VzZVg+PSh4LW9mZnNldCkmJm1vdXNlWTw9KHkrb2Zmc2V0KSYmbW91c2VZPj0oeS1vZmZzZXQpKXt2YXIgdG9vbHRpcD1SRy5wYXJzZVRvb2x0aXBUZXh0KHRoaXMuZGF0YVtzZXRdW2ldWzNdLDApO3ZhciBpbmRleF9hZGp1c3RlZD1pO2Zvcih2YXIgZHM9KHNldC0xKTtkcz49MDstLWRzKXtpbmRleF9hZGp1c3RlZCs9dGhpcy5kYXRhW2RzXS5sZW5ndGg7fVxucmV0dXJuezA6dGhpcywxOngsMjp5LDM6c2V0LDQ6aSw1OnRoaXMuZGF0YVtzZXRdW2ldWzNdLCdvYmplY3QnOnRoaXMsJ3gnOngsJ3knOnksJ2RhdGFzZXQnOnNldCwnaW5kZXgnOmksJ3Rvb2x0aXAnOnRvb2x0aXAsJ2luZGV4X2FkanVzdGVkJzppbmRleF9hZGp1c3RlZH07fX1lbHNlIGlmKFJHLmlzX251bGwoeSkpe31lbHNle3ZhciBtYXJrPXRoaXMuZGF0YVtzZXRdW2ldO3ZhciB3aWR0aD1wcm9wWydjaGFydC5ib3hwbG90LndpZHRoJ107aWYodHlwZW9mKG1hcmtbMV1bN10pPT0nbnVtYmVyJyl7d2lkdGg9bWFya1sxXVs3XTt9XG5pZih0eXBlb2YoeCk9PSdvYmplY3QnJiZtb3VzZVg+eFswXSYmbW91c2VYPHhbMV0mJm1vdXNlWTx5WzFdJiZtb3VzZVk+eVszXSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dCh0aGlzLmRhdGFbc2V0XVtpXVszXSwwKTtyZXR1cm57MDp0aGlzLDE6eFswXSwyOnhbMV0teFswXSwzOnlbMV0sNDp5WzNdLXlbMV0sNTpzZXQsNjppLDc6dGhpcy5kYXRhW3NldF1baV1bM10sJ29iamVjdCc6dGhpcywneCc6eFswXSwneSc6eVsxXSwnd2lkdGgnOnhbMV0teFswXSwnaGVpZ2h0Jzp5WzNdLXlbMV0sJ2RhdGFzZXQnOnNldCwnaW5kZXgnOmksJ3Rvb2x0aXAnOnRvb2x0aXB9O319fX19O3RoaXMuZHJhd0Fib3ZlTGFiZWxzPXRoaXMuRHJhd0Fib3ZlTGFiZWxzPWZ1bmN0aW9uKClcbnt2YXIgc2l6ZT1wcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSddO3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciB1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddO2Zvcih2YXIgc2V0PTAsbGVuPXRoaXMuY29vcmRzLmxlbmd0aDtzZXQ8bGVuOysrc2V0KXtmb3IodmFyIHBvaW50PTAsbGVuMj10aGlzLmNvb3Jkc1tzZXRdLmxlbmd0aDtwb2ludDxsZW4yOysrcG9pbnQpe3ZhciB4X3ZhbD10aGlzLmRhdGFbc2V0XVtwb2ludF1bMF07dmFyIHlfdmFsPXRoaXMuZGF0YVtzZXRdW3BvaW50XVsxXTtpZighUkcuaXNfbnVsbCh5X3ZhbCkpe2lmKFJHLmlzX2FycmF5KHlfdmFsKSl7dmFyIG1heD0wO2Zvcih2YXIgaT0wO2k8eV92YWw7KytpKXttYXg9TWF0aC5tYXgobWF4LHlfdmFsW2ldKTt9XG55X3ZhbD1tYXg7fVxudmFyIHhfcG9zPXRoaXMuY29vcmRzW3NldF1bcG9pbnRdWzBdO3ZhciB5X3Bvcz10aGlzLmNvb3Jkc1tzZXRdW3BvaW50XVsxXTtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6eF9wb3MsJ3knOnlfcG9zLTUtc2l6ZSwndGV4dCc6eF92YWwudG9GaXhlZChwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnXSkrJywgJyt5X3ZhbC50b0ZpeGVkKHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5kZWNpbWFscyddKSwndmFsaWduJzonY2VudGVyJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nRmlsbCc6J3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsJ3RhZyc6J2xhYmVscy5hYm92ZSd9KTt9fX19O3RoaXMuZ2V0WVZhbHVlPXRoaXMuZ2V0VmFsdWU9ZnVuY3Rpb24oYXJnKVxue2lmKGFyZy5sZW5ndGg9PTIpe3ZhciBtb3VzZVg9YXJnWzBdO3ZhciBtb3VzZVk9YXJnWzFdO31lbHNle3ZhciBtb3VzZUNvb3Jkcz1SRy5nZXRNb3VzZVhZKGFyZyk7dmFyIG1vdXNlWD1tb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZPW1vdXNlQ29vcmRzWzFdO31cbnZhciBvYmo9dGhpcztpZihtb3VzZVk8dGhpcy5ndXR0ZXJUb3B8fG1vdXNlWT4oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKXx8bW91c2VYPHRoaXMuZ3V0dGVyTGVmdHx8bW91c2VYPihjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSl7cmV0dXJuIG51bGw7fVxuaWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe3ZhciB2YWx1ZT0oKCh0aGlzLmdyYXBoYXJlYS8yKS0obW91c2VZLXRoaXMuZ3V0dGVyVG9wKSkvdGhpcy5ncmFwaGFyZWEpKih0aGlzLm1heC10aGlzLm1pbilcbnZhbHVlKj0yO2lmKHZhbHVlPj0wKXt2YWx1ZSs9dGhpcy5taW5cbmlmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J10pe3ZhbHVlLT10aGlzLm1pbjt2YWx1ZT10aGlzLm1heC12YWx1ZTt9fWVsc2V7dmFsdWUtPXRoaXMubWluO2lmKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J10pe3ZhbHVlKz10aGlzLm1pbjt2YWx1ZT10aGlzLm1heCt2YWx1ZTt2YWx1ZSo9LTE7fX19ZWxzZXt2YXIgdmFsdWU9KCh0aGlzLmdyYXBoYXJlYS0obW91c2VZLXRoaXMuZ3V0dGVyVG9wKSkvdGhpcy5ncmFwaGFyZWEpKih0aGlzLm1heC10aGlzLm1pbilcbnZhbHVlKz10aGlzLm1pbjtpZihwcm9wWydjaGFydC55bGFiZWxzLmludmVydCddKXt2YWx1ZS09dGhpcy5taW47dmFsdWU9dGhpcy5tYXgtdmFsdWU7fX1cbnJldHVybiB2YWx1ZTt9O3RoaXMuZ2V0WFZhbHVlPWZ1bmN0aW9uKGFyZylcbntpZihhcmcubGVuZ3RoPT0yKXt2YXIgbW91c2VYPWFyZ1swXTt2YXIgbW91c2VZPWFyZ1sxXTt9ZWxzZXt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGFyZyk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdO3ZhciBtb3VzZVk9bW91c2VYWVsxXTt9XG52YXIgb2JqPXRoaXM7aWYobW91c2VZPHRoaXMuZ3V0dGVyVG9wfHxtb3VzZVk+KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSl8fG1vdXNlWDx0aGlzLmd1dHRlckxlZnR8fG1vdXNlWD4oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkpe3JldHVybiBudWxsO31cbnZhciB3aWR0aD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpO3ZhciB2YWx1ZT0oKG1vdXNlWC10aGlzLmd1dHRlckxlZnQpL3dpZHRoKSoocHJvcFsnY2hhcnQueG1heCddLXByb3BbJ2NoYXJ0LnhtaW4nXSlcbnZhbHVlKz1wcm9wWydjaGFydC54bWluJ107cmV0dXJuIHZhbHVlO307dGhpcy5oaWdobGlnaHQ9dGhpcy5IaWdobGlnaHQ9ZnVuY3Rpb24oc2hhcGUpXG57aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7fWVsc2V7aWYoc2hhcGVbJ2hlaWdodCddKXtSRy5IaWdobGlnaHQuUmVjdCh0aGlzLHNoYXBlKTt9ZWxzZXtSRy5IaWdobGlnaHQuUG9pbnQodGhpcyxzaGFwZSk7fX19O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSk7aWYobW91c2VYWVswXT4odGhpcy5ndXR0ZXJMZWZ0LTMpJiZtb3VzZVhZWzBdPChjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzMpJiZtb3VzZVhZWzFdPih0aGlzLmd1dHRlclRvcC0zKSYmbW91c2VYWVsxXTwoKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkrMykpe3JldHVybiB0aGlzO319O3RoaXMuZ2V0WENvb3JkPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHR5cGVvZiB2YWx1ZSE9J251bWJlcicmJnR5cGVvZiB2YWx1ZSE9J3N0cmluZycpe3JldHVybiBudWxsO31cbmlmKHR5cGVvZiB2YWx1ZT09PSdzdHJpbmcnKXt2YWx1ZT1SRy5wYXJzZURhdGUodmFsdWUpO31cbnZhciB4bWluPXByb3BbJ2NoYXJ0LnhtaW4nXTt2YXIgeG1heD1wcm9wWydjaGFydC54bWF4J107dmFyIHg7aWYodmFsdWU8eG1pbilyZXR1cm4gbnVsbDtpZih2YWx1ZT54bWF4KXJldHVybiBudWxsO3ZhciBndXR0ZXJSaWdodD10aGlzLmd1dHRlclJpZ2h0O3ZhciBndXR0ZXJMZWZ0PXRoaXMuZ3V0dGVyTGVmdDtpZihwcm9wWydjaGFydC55YXhpc3BvcyddPT0ncmlnaHQnKXt4PSgodmFsdWUteG1pbikvKHhtYXgteG1pbikpKihjYS53aWR0aC1ndXR0ZXJMZWZ0LWd1dHRlclJpZ2h0KTt4PShjYS53aWR0aC1ndXR0ZXJSaWdodC14KTt9ZWxzZXt4PSgodmFsdWUteG1pbikvKHhtYXgteG1pbikpKihjYS53aWR0aC1ndXR0ZXJMZWZ0LWd1dHRlclJpZ2h0KTt4PXgrZ3V0dGVyTGVmdDt9XG5yZXR1cm4geDt9O3RoaXMuZ2V0WUNvb3JkPXRoaXMuZ2V0WUNvb3JkRnJvbVZhbHVlPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHR5cGVvZih2YWx1ZSkhPSdudW1iZXInKXtyZXR1cm4gbnVsbDt9XG52YXIgaW52ZXJ0PXByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J107dmFyIHhheGlzcG9zPXByb3BbJ2NoYXJ0LnhheGlzcG9zJ107dmFyIGdyYXBoSGVpZ2h0PWNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbTt2YXIgaGFsZkdyYXBoSGVpZ2h0PWdyYXBoSGVpZ2h0LzI7dmFyIHltYXg9dGhpcy5tYXg7dmFyIHltaW49cHJvcFsnY2hhcnQueW1pbiddO3ZhciBjb29yZD0wO2lmKHZhbHVlPnltYXh8fChwcm9wWydjaGFydC54YXhpc3BvcyddPT0nYm90dG9tJyYmdmFsdWU8eW1pbil8fChwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyYmKCh2YWx1ZT4wJiZ2YWx1ZTx5bWluKXx8KHZhbHVlPDAmJnZhbHVlPigtMSp5bWluKSkpKSl7cmV0dXJuIG51bGw7fVxuaWYoeGF4aXNwb3M9PSdjZW50ZXInKXtjb29yZD0oKE1hdGguYWJzKHZhbHVlKS15bWluKS8oeW1heC15bWluKSkqaGFsZkdyYXBoSGVpZ2h0O2lmKGludmVydCl7Y29vcmQ9aGFsZkdyYXBoSGVpZ2h0LWNvb3JkO31cbmlmKHZhbHVlPDApe2Nvb3JkKz10aGlzLmd1dHRlclRvcDtjb29yZCs9aGFsZkdyYXBoSGVpZ2h0O31lbHNle2Nvb3JkPWhhbGZHcmFwaEhlaWdodC1jb29yZDtjb29yZCs9dGhpcy5ndXR0ZXJUb3A7fX1lbHNle2Nvb3JkPSgodmFsdWUteW1pbikvKHltYXgteW1pbikpKmdyYXBoSGVpZ2h0O2lmKGludmVydCl7Y29vcmQ9Z3JhcGhIZWlnaHQtY29vcmQ7fVxuY29vcmQ9Z3JhcGhIZWlnaHQtY29vcmQ7Y29vcmQ9dGhpcy5ndXR0ZXJUb3ArY29vcmQ7fVxucmV0dXJuIGNvb3JkO307UkcuU2NhdHRlci5CdWJibGU9ZnVuY3Rpb24oc2NhdHRlcixtaW4sbWF4LHdpZHRoLGRhdGEpXG57dGhpcy5zY2F0dGVyPXNjYXR0ZXI7dGhpcy5taW49bWluO3RoaXMubWF4PW1heDt0aGlzLndpZHRoPXdpZHRoO3RoaXMuZGF0YT1kYXRhO3RoaXMuY29vcmRzPVtdO3RoaXMudHlwZT0nc2NhdHRlci5idWJibGUnXG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue3RoaXMuc2NhdHRlci5zZXQobmFtZSx2YWx1ZSk7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue3RoaXMuc2NhdHRlci5nZXQobmFtZSk7fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbnt2YXIgYnViYmxlX21pbj10aGlzLm1pbixidWJibGVfbWF4PXRoaXMubWF4LGJ1YmJsZV9kYXRhPXRoaXMuZGF0YSxidWJibGVfbWF4X3dpZHRoPXRoaXMud2lkdGg7dmFyIG9ial9idWJibGU9dGhpcyxvYmpfc2NhdHRlcj10aGlzLnNjYXR0ZXI7dGhpcy5zY2F0dGVyLm9uZHJhdz1mdW5jdGlvbihvYmopXG57Zm9yKHZhciBpPTA7aTxvYmouY29vcmRzWzBdLmxlbmd0aDsrK2kpe2J1YmJsZV9kYXRhW2ldPW1hLm1heChidWJibGVfZGF0YVtpXSxidWJibGVfbWluKTtidWJibGVfZGF0YVtpXT1tYS5taW4oYnViYmxlX2RhdGFbaV0sYnViYmxlX21heCk7dmFyIHI9KChidWJibGVfZGF0YVtpXS1idWJibGVfbWluKS8oYnViYmxlX21heC1idWJibGVfbWluKSkqYnViYmxlX21heF93aWR0aCxjb2xvcj1vYmpfc2NhdHRlci5kYXRhWzBdW2ldWzJdP29ial9zY2F0dGVyLmRhdGFbMF1baV1bMl06b2JqX3NjYXR0ZXIucHJvcGVydGllc1snY2hhcnQuZGVmYXVsdGNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPVJHLnJhZGlhbEdyYWRpZW50KG9iaixvYmpfc2NhdHRlci5jb29yZHNbMF1baV1bMF0rKHIvMi41KSxvYmpfc2NhdHRlci5jb29yZHNbMF1baV1bMV0tKHIvMi41KSwwLG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVswXSsoci8yLjUpLG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVsxXS0oci8yLjUpLHIscHJvcFsnY2hhcnQuY29sb3JzLmJ1YmJsZS5ncmFkdWF0ZWQnXT8nd2hpdGUnOmNvbG9yLGNvbG9yKTtjby5hcmMob2JqX3NjYXR0ZXIuY29vcmRzWzBdW2ldWzBdLG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVsxXSxyLDAsUkcuVFdPUEksZmFsc2UpO2NvLmZpbGwoKTtvYmpfYnViYmxlLmNvb3Jkc1tpXT1bb2JqX3NjYXR0ZXIuY29vcmRzWzBdW2ldWzBdLG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVsxXSxyLGNvLmZpbGxTdHlsZV07fX1cbnRoaXMuc2NhdHRlci5EcmF3KCk7cmV0dXJuIHRoaXM7fTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ109UkcuYXJyYXlfY2xvbmUodGhpcy5kYXRhKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC52YmFycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5saW5lLmNvbG9ycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmxpbmUuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5kZWZhdWx0Y29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYXhpcy5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7fVxudmFyIGRhdGE9dGhpcy5kYXRhO2lmKGRhdGEpe2Zvcih2YXIgZGF0YXNldD0wO2RhdGFzZXQ8ZGF0YS5sZW5ndGg7KytkYXRhc2V0KXtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7KytpKXtpZih0aGlzLmRhdGFbZGF0YXNldF1baV0mJnR5cGVvZih0aGlzLmRhdGFbZGF0YXNldF1baV1bMV0pPT0nb2JqZWN0JyYmdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdKXtpZih0eXBlb2YodGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzVdKT09J3N0cmluZycpdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzVdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXVs1XSk7aWYodHlwZW9mKHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXVs2XSk9PSdzdHJpbmcnKXRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXVs2XT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCh0aGlzLmRhdGFbZGF0YXNldF1baV1bMV1bNl0pO31cbmlmKCFSRy5pc051bGwodGhpcy5kYXRhW2RhdGFzZXRdW2ldKSl7dGhpcy5kYXRhW2RhdGFzZXRdW2ldWzJdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsyXSk7fX19fVxudmFyIGhiYXJzPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXTtpZihoYmFycyl7Zm9yKGk9MDtpPGhiYXJzLmxlbmd0aDsrK2kpe2hiYXJzW2ldWzJdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGhiYXJzW2ldWzJdKTt9fVxudmFyIHZiYXJzPXByb3BbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXTtpZih2YmFycyl7Zm9yKGk9MDtpPHZiYXJzLmxlbmd0aDsrK2kpe3ZiYXJzW2ldWzJdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHZiYXJzW2ldWzJdKTt9fVxudmFyIGNvbG9ycz1wcm9wWydjaGFydC5saW5lLmNvbG9ycyddO2lmKGNvbG9ycyl7Zm9yKGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTt9fVxucHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTtwcm9wWydjaGFydC5heGlzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YoY29sb3IpIT0nc3RyaW5nJyl7cmV0dXJuIGNvbG9yO31cbmlmKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSwwLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQ9ZnVuY3Rpb24oaW5kZXgpXG57aWYodGhpcy5jb29yZHMmJnRoaXMuY29vcmRzW2luZGV4XSYmdGhpcy5jb29yZHNbaW5kZXhdLmxlbmd0aCl7dGhpcy5jb29yZHNbaW5kZXhdLmZvckVhY2goZnVuY3Rpb24odmFsdWUsaWR4LGFycilcbntjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uYXJjKHZhbHVlWzBdLHZhbHVlWzFdLHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10rMywwLFJHLlRXT1BJLGZhbHNlKTtjby5maWxsKCk7fSk7fX07dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMudHJhY2U9dGhpcy50cmFjZTI9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxjYWxsYmFjaz1hcmd1bWVudHNbMl0sb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDMwLGZyYW1lPTAsY2FsbGJhY2s9YXJndW1lbnRzWzFdfHxmdW5jdGlvbigpe31cbm9iai5TZXQoJ2FuaW1hdGlvblRyYWNlJyx0cnVlKTtvYmouU2V0KCdhbmltYXRpb25UcmFjZUNsaXAnLDApO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYoZnJhbWUrKzxmcmFtZXMpe29iai5zZXQoJ2FuaW1hdGlvblRyYWNlQ2xpcCcsZnJhbWUvZnJhbWVzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7fWVsc2V7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O3RoaXMucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzPWZ1bmN0aW9uKClcbntmb3IodmFyIGk9MCxsZW49dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXS5sZW5ndGg7aTxsZW47KytpKXtmb3IodmFyIGo9MCxsZW4yPXRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV0ubGVuZ3RoO2o8bGVuMjsrK2ope3RoaXMuZGF0YVtpXVtqXVsyXT1SRy5hcnJheV9jbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldW2pdWzJdKTtpZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzFdPT09J29iamVjdCcpe3RoaXMuZGF0YVtpXVtqXVsxXVs1XT1SRy5hcnJheV9jbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldW2pdWzFdWzVdKTt0aGlzLmRhdGFbaV1bal1bMV1bNl09UkcuYXJyYXlfY2xvbmUodGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVtqXVsxXVs2XSk7fX19fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zY2F0dGVyLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///232\n");

/***/ }),
/* 233 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SemiCircularProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'semicircularprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.color': 'rgba(0,0,0,0)', 'chart.colors': ['#0c0'], 'chart.linewidth': 2, 'chart.strokestyle': '#666', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.width': null, 'chart.angles.start': Math.PI, 'chart.angles.end': 2 * Math.PI, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.formatter': null, 'chart.scale.round': false, 'chart.shadow': false, 'chart.shadow.color': 'rgba(220,220,220,1)', 'chart.shadow.blur': 2, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.labels.center': true, 'chart.labels.center.font': null, 'chart.labels.center.bold': false, 'chart.labels.center.italic': false, 'chart.labels.center.fade': false, 'chart.labels.center.size': 40, 'chart.labels.center.color': 'black', 'chart.labels.center.valign': 'bottom', 'chart.labels.min.color': null, 'chart.labels.min.font': null, 'chart.labels.min.bold': false, 'chart.labels.min.size': null, 'chart.labels.min.italic': false, 'chart.labels.min.offset.angle': 0, 'chart.labels.min.offsetx': 0, 'chart.labels.min.offsety': 0, 'chart.labels.max.color': null, 'chart.labels.max.font': null, 'chart.labels.max.bold': false, 'chart.labels.max.size': null, 'chart.labels.max.italic': false, 'chart.labels.max.offset.angle': 0, 'chart.labels.max.offsetx': 0, 'chart.labels.max.offsety': 0, 'chart.title': '', 'chart.title.bold': true, 'chart.title.italic': false, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.tooltips.coords.page': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[SEMICIRCULARPROGRESS] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min((ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2, ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']);this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.width = this.radius / 3;if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.width'] === 'number') this.width = prop['chart.width'];this.coords = [];this.coordsText = [];this.drawMeter();this.drawLabels();if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    this.allowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawMeter = this.DrawMeter = function () {\n    var start = prop['chart.angles.start'],\n        end = prop['chart.angles.end'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'strict': true, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': 5, 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.background.color'] !== 'rgba(0,0,0,0)') {\n      pa2(co, 'fs % fr % % % %', prop['chart.background.color'], 0, 0, ca.width, ca.height);\n    }\n    pa2(co, 'lw % b a % % % % % false a % % % % % true c s % f % sx % sy % sc % sb % f % sx 0 sy 0 sb 0 sc rgba(0,0,0,0) lw 1', prop['chart.linewidth'], this.centerx, this.centery, this.radius, start, end, this.centerx, this.centery, this.radius - this.width, end, start, prop['chart.strokestyle'], typeof prop['chart.colors'][1] !== 'undefined' ? prop['chart.colors'][1] : prop['chart.colors'][0], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow'] ? prop['chart.shadow.color'] : 'rgba(0,0,0,0)', prop['chart.shadow.blur'], typeof prop['chart.colors'][1] !== 'undefined' ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0.85)');var angle = start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min));pa2(co, 'b a % % % % % false a % % % % % true c f %', this.centerx, this.centery, this.radius, start, angle, this.centerx, this.centery, this.radius - this.width, start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min)), start, prop['chart.colors'][0]);this.coords = [[this.centerx, this.centery, this.radius, start, end, this.width, angle]];\n  };this.drawLabels = this.DrawLabels = function () {\n    var min = RG.numberFormat(this, this.scale2.min, prop['chart.units.pre'], prop['chart.units.post']);\n    var max = RG.numberFormat(this, this.scale2.max, prop['chart.units.pre'], prop['chart.units.post']);\n    if (prop['chart.angles.start'] === RGraph.PI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.start'] <= RGraph.PI) {\n      var halign = 'left';var valign = 'center';\n    } else if (prop['chart.angles.start'] >= RGraph.PI) {\n      var halign = 'right';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.start'] + prop['chart.labels.min.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.min.font'] || prop['chart.text.font'], bold: prop['chart.labels.min.bold'] || prop['chart.text.bold'], size: prop['chart.labels.min.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.min.offsetx'], y: xy[1] + prop['chart.labels.min.offsety'], valign: valign, halign: halign, text: min, color: prop['chart.labels.min.color'] || prop['chart.text.color'], italic: prop['chart.labels.min.italic'] });if (prop['chart.angles.end'] === RGraph.TWOPI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.end'] >= RGraph.TWOPI) {\n      var halign = 'right';var valign = 'center';\n    } else if (prop['chart.angles.end'] <= RGraph.TWOPI) {\n      var halign = 'left';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.end'] + prop['chart.labels.max.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.max.font'] || prop['chart.text.font'], bold: prop['chart.labels.max.bold'] || prop['chart.text.bold'], size: prop['chart.labels.max.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.max.offsetx'], y: xy[1] + prop['chart.labels.max.offsety'], valign: valign, halign: halign, text: max, color: prop['chart.labels.max.color'] || prop['chart.text.color'], italic: prop['chart.labels.max.italic'] });if (prop['chart.labels.center']) {\n      var ret = RG.text2(this, { font: prop['chart.labels.center.font'] || prop['chart.text.font'], size: prop['chart.labels.center.size'] || 50, bold: prop['chart.labels.center.bold'], italic: prop['chart.labels.center.italic'], x: this.centerx, y: this.centery, valign: prop['chart.labels.center.valign'], halign: 'center', text: RG.numberFormat(this, this.value.toFixed(prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), color: prop['chart.labels.center.color'] || prop['chart.text.color'] });if (prop['chart.labels.center.fade'] && ret.node) {\n        ret.node.style.opacity = 0;var delay = 25,\n            incr = 0.1;for (var i = 0; i < 10; ++i) {\n          (function (index) {\n            setTimeout(function () {\n              ret.node.style.opacity = incr * index;\n            }, delay * (index + 1));\n          })(i);\n        }\n      }\n    }\n    RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size']);\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], this.coords[0][6], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], this.coords[0][6], this.coords[0][3]);if (co.isPointInPath(mouseX, mouseY)) {\n      return { object: this, 0: this, x: this.coords[0][0], 1: this.coords[0][0], y: this.coords[0][1], 2: this.coords[0][1], radius: this.coords[0][2], 3: this.coords[0][2], width: this.coords[0][5], 4: this.coords[0][5], start: this.coords[0][3], 5: this.coords[0][3], end: this.coords[0][6], 6: this.coords[0][6], index: 0, tooltip: !RG.isNull(prop['chart.tooltips']) ? prop['chart.tooltips'][0] : null };\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle && mouseX >= this.centerx && mouseY > this.centery) {\n      angle += RGraph.TWOPI;\n    }\n    if (angle < prop['chart.angles.start'] && mouseX > this.centerx) {\n      angle = prop['chart.angles.end'];\n    }\n    if (angle < prop['chart.angles.start']) {\n      angle = prop['chart.angles.start'];\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      pa2(co, 'lw 5 b a % % % % % false a % % % % % true c s % f % lw 1', shape.x, shape.y, shape.radius, shape.start, shape.end, shape.x, shape.y, shape.radius - shape.width, shape.end, shape.start, prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);pa2(co, 'b a % % % % % false', this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end']);pa2(co, 'a % % % % % true', this.centerx, this.centery, this.radius - this.width, prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseXY[0], mouseXY[1]) ? this : null;\n  };this.allowAdjusting = this.AllowAdjusting = function () {};this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = this.getValue(e);if (typeof value === 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(this.canvas);\n      }\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = value / this.max * (prop['chart.angles.end'] - prop['chart.angles.start']);\n    angle += prop['chart.angles.start'];return angle;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], prop['chart.angles.start'], prop['chart.angles.end'], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.colors'][1] = this.parseSingleColorForGradient(prop['chart.colors'][1]);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        initial_value = this.currentValue,\n        opt = arguments[0] || {},\n        numFrames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        diff = this.value - Number(this.currentValue),\n        increment = diff / numFrames;\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        obj.value = initial_value + increment * frame;RG.clear(ca);RG.redrawCanvas(ca);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc2VtaWNpcmN1bGFycHJvZ3Jlc3MuanM/YzNjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlNlbWlDaXJjdWxhclByb2dyZXNzPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgY29uZj17aWQ6YXJndW1lbnRzWzBdLG1pbjphcmd1bWVudHNbMV0sbWF4OmFyZ3VtZW50c1syXSx2YWx1ZTphcmd1bWVudHNbM119fVxudGhpcy5pZD1jb25mLmlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X189dGhpczt0aGlzLm1pbj1SR3JhcGguc3RyaW5nc1RvTnVtYmVycyhjb25mLm1pbik7dGhpcy5tYXg9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5tYXgpO3RoaXMudmFsdWU9UkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi52YWx1ZSk7dGhpcy50eXBlPSdzZW1pY2lyY3VsYXJwcm9ncmVzcyc7dGhpcy5jb29yZHM9W107dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMuY3VycmVudFZhbHVlPW51bGw7dGhpcy51aWQ9UkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzoncmdiYSgwLDAsMCwwKScsJ2NoYXJ0LmNvbG9ycyc6WycjMGMwJ10sJ2NoYXJ0LmxpbmV3aWR0aCc6MiwnY2hhcnQuc3Ryb2tlc3R5bGUnOicjNjY2JywnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MzUsJ2NoYXJ0LnJhZGl1cyc6bnVsbCwnY2hhcnQuY2VudGVyeCc6bnVsbCwnY2hhcnQuY2VudGVyeSc6bnVsbCwnY2hhcnQud2lkdGgnOm51bGwsJ2NoYXJ0LmFuZ2xlcy5zdGFydCc6TWF0aC5QSSwnY2hhcnQuYW5nbGVzLmVuZCc6KDIqTWF0aC5QSSksJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC5zY2FsZS5mb3JtYXR0ZXInOm51bGwsJ2NoYXJ0LnNjYWxlLnJvdW5kJzpmYWxzZSwnY2hhcnQuc2hhZG93JzpmYWxzZSwnY2hhcnQuc2hhZG93LmNvbG9yJzoncmdiYSgyMjAsMjIwLDIyMCwxKScsJ2NoYXJ0LnNoYWRvdy5ibHVyJzoyLCdjaGFydC5zaGFkb3cub2Zmc2V0eCc6MiwnY2hhcnQuc2hhZG93Lm9mZnNldHknOjIsJ2NoYXJ0LmxhYmVscy5jZW50ZXInOnRydWUsJ2NoYXJ0LmxhYmVscy5jZW50ZXIuZm9udCc6bnVsbCwnY2hhcnQubGFiZWxzLmNlbnRlci5ib2xkJzpmYWxzZSwnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnOmZhbHNlLCdjaGFydC5sYWJlbHMuY2VudGVyLmZhZGUnOmZhbHNlLCdjaGFydC5sYWJlbHMuY2VudGVyLnNpemUnOjQwLCdjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJzonYmxhY2snLCdjaGFydC5sYWJlbHMuY2VudGVyLnZhbGlnbic6J2JvdHRvbScsJ2NoYXJ0LmxhYmVscy5taW4uY29sb3InOm51bGwsJ2NoYXJ0LmxhYmVscy5taW4uZm9udCc6bnVsbCwnY2hhcnQubGFiZWxzLm1pbi5ib2xkJzpmYWxzZSwnY2hhcnQubGFiZWxzLm1pbi5zaXplJzpudWxsLCdjaGFydC5sYWJlbHMubWluLml0YWxpYyc6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5taW4ub2Zmc2V0LmFuZ2xlJzowLCdjaGFydC5sYWJlbHMubWluLm9mZnNldHgnOjAsJ2NoYXJ0LmxhYmVscy5taW4ub2Zmc2V0eSc6MCwnY2hhcnQubGFiZWxzLm1heC5jb2xvcic6bnVsbCwnY2hhcnQubGFiZWxzLm1heC5mb250JzpudWxsLCdjaGFydC5sYWJlbHMubWF4LmJvbGQnOmZhbHNlLCdjaGFydC5sYWJlbHMubWF4LnNpemUnOm51bGwsJ2NoYXJ0LmxhYmVscy5tYXguaXRhbGljJzpmYWxzZSwnY2hhcnQubGFiZWxzLm1heC5vZmZzZXQuYW5nbGUnOjAsJ2NoYXJ0LmxhYmVscy5tYXgub2Zmc2V0eCc6MCwnY2hhcnQubGFiZWxzLm1heC5vZmZzZXR5JzowLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLml0YWxpYyc6ZmFsc2UsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQuY29udGV4dG1lbnUnOm51bGwsJ2NoYXJ0LnVuaXRzLnByZSc6JycsJ2NoYXJ0LnVuaXRzLnBvc3QnOicnLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzonZmFkZScsJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6J1JHcmFwaF90b29sdGlwJywnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5ldmVudCc6J29uY2xpY2snLCdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6dHJ1ZSwnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0Lnpvb20uYWN0aW9uJzonem9vbScsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuZXZlbnRzLmNsaWNrJzpudWxsLCdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzpudWxsLCdjaGFydC5jbGVhcnRvJzoncmdiYSgwLDAsMCwwKSd9XG5pZighdGhpcy5jYW52YXMpe2FsZXJ0KCdbU0VNSUNJUkNVTEFSUFJPR1JFU1NdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO31cbmlmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXT12YWx1ZTtyZXR1cm4gdGhpczt9O3RoaXMuZ2V0PXRoaXMuR2V0PWZ1bmN0aW9uKG5hbWUpXG57aWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbnJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07fTt0aGlzLmRyYXc9dGhpcy5EcmF3PWZ1bmN0aW9uKClcbntSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG50aGlzLmN1cnJlbnRWYWx1ZT10aGlzLnZhbHVlO3RoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnJhZGl1cz1tYS5taW4oKGNhLndpZHRoLXByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10tcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10pLzIsY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXS1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pO3RoaXMuY2VudGVyeD0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PWNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbTt0aGlzLndpZHRoPXRoaXMucmFkaXVzLzM7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddPT09J251bWJlcicpdGhpcy5yYWRpdXM9cHJvcFsnY2hhcnQucmFkaXVzJ107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXT09PSdudW1iZXInKXRoaXMuY2VudGVyeD1wcm9wWydjaGFydC5jZW50ZXJ4J107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXT09PSdudW1iZXInKXRoaXMuY2VudGVyeT1wcm9wWydjaGFydC5jZW50ZXJ5J107aWYodHlwZW9mIHByb3BbJ2NoYXJ0LndpZHRoJ109PT0nbnVtYmVyJyl0aGlzLndpZHRoPXByb3BbJ2NoYXJ0LndpZHRoJ107dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuZHJhd01ldGVyKCk7dGhpcy5kcmF3TGFiZWxzKCk7aWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7Ukcuc2hvd0NvbnRleHQodGhpcyk7fVxuUkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5hbGxvd1Jlc2l6aW5nKHRoaXMpO31cbnRoaXMuYWxsb3dBZGp1c3RpbmcoKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3TWV0ZXI9dGhpcy5EcmF3TWV0ZXI9ZnVuY3Rpb24oKVxue3ZhciBzdGFydD1wcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxlbmQ9cHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddO3RoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHsnbWF4Jzp0aGlzLm1heCwnc3RyaWN0Jzp0cnVlLCdtaW4nOnRoaXMubWluLCdzY2FsZS50aG91c2FuZCc6cHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwnc2NhbGUucG9pbnQnOnByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sJ3NjYWxlLmRlY2ltYWxzJzpwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCd5bGFiZWxzLmNvdW50Jzo1LCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTtpZihwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10hPT0ncmdiYSgwLDAsMCwwKScpe3BhMihjbywnZnMgJSBmciAlICUgJSAlJyxwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10sMCwwLGNhLndpZHRoLGNhLmhlaWdodCk7fVxucGEyKGNvLCdsdyAlIGIgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZSBjIHMgJSBmICUgc3ggJSBzeSAlIHNjICUgc2IgJSBmICUgc3ggMCBzeSAwIHNiIDAgc2MgcmdiYSgwLDAsMCwwKSBsdyAxJyxwcm9wWydjaGFydC5saW5ld2lkdGgnXSx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLHN0YXJ0LGVuZCx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXRoaXMud2lkdGgsZW5kLHN0YXJ0LHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10sdHlwZW9mIHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdIT09J3VuZGVmaW5lZCc/cHJvcFsnY2hhcnQuY29sb3JzJ11bMV06cHJvcFsnY2hhcnQuY29sb3JzJ11bMF0scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdyddP3Byb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddOidyZ2JhKDAsMCwwLDApJyxwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddLHR5cGVvZiBwcm9wWydjaGFydC5jb2xvcnMnXVsxXSE9PSd1bmRlZmluZWQnPydyZ2JhKDAsMCwwLDApJzoncmdiYSgyNTUsMjU1LDI1NSwwLjg1KScpO3ZhciBhbmdsZT1zdGFydCsoKGVuZC1zdGFydCkqKCh0aGlzLnZhbHVlLXRoaXMuc2NhbGUyLm1pbikvKHRoaXMubWF4LXRoaXMuc2NhbGUyLm1pbikpKTtwYTIoY28sJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZSBjIGYgJScsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyxzdGFydCxhbmdsZSx0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHRoaXMucmFkaXVzLXRoaXMud2lkdGgsc3RhcnQrKChlbmQtc3RhcnQpKigodGhpcy52YWx1ZS10aGlzLnNjYWxlMi5taW4pLyh0aGlzLm1heC10aGlzLnNjYWxlMi5taW4pKSksc3RhcnQscHJvcFsnY2hhcnQuY29sb3JzJ11bMF0pO3RoaXMuY29vcmRzPVtbdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyxzdGFydCxlbmQsdGhpcy53aWR0aCxhbmdsZV1dO307dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIG1pbj1SRy5udW1iZXJGb3JtYXQodGhpcyx0aGlzLnNjYWxlMi5taW4scHJvcFsnY2hhcnQudW5pdHMucHJlJ10scHJvcFsnY2hhcnQudW5pdHMucG9zdCddKVxudmFyIG1heD1SRy5udW1iZXJGb3JtYXQodGhpcyx0aGlzLnNjYWxlMi5tYXgscHJvcFsnY2hhcnQudW5pdHMucHJlJ10scHJvcFsnY2hhcnQudW5pdHMucG9zdCddKVxuaWYocHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J109PT1SR3JhcGguUEkpe3ZhciBoYWxpZ249J2NlbnRlcic7dmFyIHZhbGlnbj0ndG9wJzt9ZWxzZSBpZihwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTw9UkdyYXBoLlBJKXt2YXIgaGFsaWduPSdsZWZ0Jzt2YXIgdmFsaWduPSdjZW50ZXInO31lbHNlIGlmKHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddPj1SR3JhcGguUEkpe3ZhciBoYWxpZ249J3JpZ2h0Jzt2YXIgdmFsaWduPSdjZW50ZXInO31cbnZhciB4eT1SRy5nZXRSYWRpdXNFbmRQb2ludCh0aGlzLmNlbnRlcngsdGhpcy5jZW50ZXJ5LHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddK3Byb3BbJ2NoYXJ0LmxhYmVscy5taW4ub2Zmc2V0LmFuZ2xlJ10sdGhpcy5yYWRpdXMtKHRoaXMud2lkdGgvMikpO1JHLnRleHQyKHRoaXMse2ZvbnQ6cHJvcFsnY2hhcnQubGFiZWxzLm1pbi5mb250J118fHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLGJvbGQ6cHJvcFsnY2hhcnQubGFiZWxzLm1pbi5ib2xkJ118fHByb3BbJ2NoYXJ0LnRleHQuYm9sZCddLHNpemU6cHJvcFsnY2hhcnQubGFiZWxzLm1pbi5zaXplJ118fHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLHg6eHlbMF0rcHJvcFsnY2hhcnQubGFiZWxzLm1pbi5vZmZzZXR4J10seTp4eVsxXStwcm9wWydjaGFydC5sYWJlbHMubWluLm9mZnNldHknXSx2YWxpZ246dmFsaWduLGhhbGlnbjpoYWxpZ24sdGV4dDptaW4sY29sb3I6cHJvcFsnY2hhcnQubGFiZWxzLm1pbi5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10saXRhbGljOnByb3BbJ2NoYXJ0LmxhYmVscy5taW4uaXRhbGljJ119KTtpZihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ109PT1SR3JhcGguVFdPUEkpe3ZhciBoYWxpZ249J2NlbnRlcic7dmFyIHZhbGlnbj0ndG9wJzt9ZWxzZSBpZihwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10+PVJHcmFwaC5UV09QSSl7dmFyIGhhbGlnbj0ncmlnaHQnO3ZhciB2YWxpZ249J2NlbnRlcic7fWVsc2UgaWYocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddPD1SR3JhcGguVFdPUEkpe3ZhciBoYWxpZ249J2xlZnQnO3ZhciB2YWxpZ249J2NlbnRlcic7fVxudmFyIHh5PVJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnkscHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddK3Byb3BbJ2NoYXJ0LmxhYmVscy5tYXgub2Zmc2V0LmFuZ2xlJ10sdGhpcy5yYWRpdXMtKHRoaXMud2lkdGgvMikpO1JHLnRleHQyKHRoaXMse2ZvbnQ6cHJvcFsnY2hhcnQubGFiZWxzLm1heC5mb250J118fHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLGJvbGQ6cHJvcFsnY2hhcnQubGFiZWxzLm1heC5ib2xkJ118fHByb3BbJ2NoYXJ0LnRleHQuYm9sZCddLHNpemU6cHJvcFsnY2hhcnQubGFiZWxzLm1heC5zaXplJ118fHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLHg6eHlbMF0rcHJvcFsnY2hhcnQubGFiZWxzLm1heC5vZmZzZXR4J10seTp4eVsxXStwcm9wWydjaGFydC5sYWJlbHMubWF4Lm9mZnNldHknXSx2YWxpZ246dmFsaWduLGhhbGlnbjpoYWxpZ24sdGV4dDptYXgsY29sb3I6cHJvcFsnY2hhcnQubGFiZWxzLm1heC5jb2xvciddfHxwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10saXRhbGljOnByb3BbJ2NoYXJ0LmxhYmVscy5tYXguaXRhbGljJ119KTtpZihwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pe3ZhciByZXQ9UkcudGV4dDIodGhpcyx7Zm9udDpwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmZvbnQnXXx8cHJvcFsnY2hhcnQudGV4dC5mb250J10sc2l6ZTpwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLnNpemUnXXx8NTAsYm9sZDpwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmJvbGQnXSxpdGFsaWM6cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnXSx4OnRoaXMuY2VudGVyeCx5OnRoaXMuY2VudGVyeSx2YWxpZ246cHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci52YWxpZ24nXSxoYWxpZ246J2NlbnRlcicsdGV4dDpSRy5udW1iZXJGb3JtYXQodGhpcyx0aGlzLnZhbHVlLnRvRml4ZWQocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkscHJvcFsnY2hhcnQudW5pdHMucHJlJ10scHJvcFsnY2hhcnQudW5pdHMucG9zdCddKSxjb2xvcjpwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJ118fHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXX0pO2lmKHByb3BbJ2NoYXJ0LmxhYmVscy5jZW50ZXIuZmFkZSddJiZyZXQubm9kZSl7cmV0Lm5vZGUuc3R5bGUub3BhY2l0eT0wO3ZhciBkZWxheT0yNSxpbmNyPTAuMTtmb3IodmFyIGk9MDtpPDEwOysraSl7KGZ1bmN0aW9uKGluZGV4KVxue3NldFRpbWVvdXQoZnVuY3Rpb24oKVxue3JldC5ub2RlLnN0eWxlLm9wYWNpdHk9aW5jcippbmRleDt9LGRlbGF5KihpbmRleCsxKSk7fSkoaSk7fX19XG5SRy5kcmF3VGl0bGUodGhpcyxwcm9wWydjaGFydC50aXRsZSddLHRoaXMuZ3V0dGVyVG9wLG51bGwscHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddKTt9O3RoaXMuZ2V0U2hhcGU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdXG5wYTIoY28sJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZScsdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5jb29yZHNbMF1bMl0sdGhpcy5jb29yZHNbMF1bM10sdGhpcy5jb29yZHNbMF1bNl0sdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5jb29yZHNbMF1bMl0tdGhpcy5jb29yZHNbMF1bNV0sdGhpcy5jb29yZHNbMF1bNl0sdGhpcy5jb29yZHNbMF1bM10pO2lmKGNvLmlzUG9pbnRJblBhdGgobW91c2VYLG1vdXNlWSkpe3JldHVybntvYmplY3Q6dGhpcywwOnRoaXMseDp0aGlzLmNvb3Jkc1swXVswXSwxOnRoaXMuY29vcmRzWzBdWzBdLHk6dGhpcy5jb29yZHNbMF1bMV0sMjp0aGlzLmNvb3Jkc1swXVsxXSxyYWRpdXM6dGhpcy5jb29yZHNbMF1bMl0sMzp0aGlzLmNvb3Jkc1swXVsyXSx3aWR0aDp0aGlzLmNvb3Jkc1swXVs1XSw0OnRoaXMuY29vcmRzWzBdWzVdLHN0YXJ0OnRoaXMuY29vcmRzWzBdWzNdLDU6dGhpcy5jb29yZHNbMF1bM10sZW5kOnRoaXMuY29vcmRzWzBdWzZdLDY6dGhpcy5jb29yZHNbMF1bNl0saW5kZXg6MCx0b29sdGlwOiFSRy5pc051bGwocHJvcFsnY2hhcnQudG9vbHRpcHMnXSk/cHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXTpudWxsfTt9fTt0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXSxhbmdsZT1SRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSxtb3VzZVgsbW91c2VZKTtpZihhbmdsZSYmbW91c2VYPj10aGlzLmNlbnRlcngmJm1vdXNlWT50aGlzLmNlbnRlcnkpe2FuZ2xlKz1SR3JhcGguVFdPUEk7fVxuaWYoYW5nbGU8cHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10mJm1vdXNlWD50aGlzLmNlbnRlcngpe2FuZ2xlPXByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXTt9XG5pZihhbmdsZTxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSl7YW5nbGU9cHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J107fVxudmFyIHZhbHVlPSgoKGFuZ2xlLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKS8ocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSkqKHRoaXMubWF4LXRoaXMubWluKSkrdGhpcy5taW47dmFsdWU9bWEubWF4KHZhbHVlLHRoaXMubWluKTt2YWx1ZT1tYS5taW4odmFsdWUsdGhpcy5tYXgpO3JldHVybiB2YWx1ZTt9O3RoaXMuaGlnaGxpZ2h0PXRoaXMuSGlnaGxpZ2h0PWZ1bmN0aW9uKHNoYXBlKVxue2lmKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXT09PSdmdW5jdGlvbicpeyhwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSkoc2hhcGUpO31lbHNle3BhMihjbywnbHcgNSBiIGEgJSAlICUgJSAlIGZhbHNlIGEgJSAlICUgJSAlIHRydWUgYyBzICUgZiAlIGx3IDEnLHNoYXBlLngsc2hhcGUueSxzaGFwZS5yYWRpdXMsc2hhcGUuc3RhcnQsc2hhcGUuZW5kLHNoYXBlLngsc2hhcGUueSxzaGFwZS5yYWRpdXMtc2hhcGUud2lkdGgsc2hhcGUuZW5kLHNoYXBlLnN0YXJ0LHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSxwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt9fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3BhMihjbywnYiBhICUgJSAlICUgJSBmYWxzZScsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cyxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10pO3BhMihjbywnYSAlICUgJSAlICUgdHJ1ZScsdGhpcy5jZW50ZXJ4LHRoaXMuY2VudGVyeSx0aGlzLnJhZGl1cy10aGlzLndpZHRoLHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSk7cmV0dXJuIGNvLmlzUG9pbnRJblBhdGgobW91c2VYWVswXSxtb3VzZVhZWzFdKT90aGlzOm51bGw7fTt0aGlzLmFsbG93QWRqdXN0aW5nPXRoaXMuQWxsb3dBZGp1c3Rpbmc9ZnVuY3Rpb24oKXt9O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZT10aGlzLkFkanVzdGluZ19tb3VzZW1vdmU9ZnVuY3Rpb24oZSlcbntpZihwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10mJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykmJlJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkPT10aGlzLnVpZCl7dmFyIHZhbHVlPXRoaXMuZ2V0VmFsdWUoZSk7aWYodHlwZW9mIHZhbHVlPT09J251bWJlcicpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmFkanVzdCcpO3RoaXMudmFsdWU9TnVtYmVyKHZhbHVlLnRvRml4ZWQocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkpO1JHLnJlZHJhd0NhbnZhcyh0aGlzLmNhbnZhcyk7fX19O3RoaXMuZ2V0QW5nbGU9ZnVuY3Rpb24odmFsdWUpXG57aWYodmFsdWU+dGhpcy5tYXh8fHZhbHVlPHRoaXMubWluKXtyZXR1cm4gbnVsbDt9XG52YXIgYW5nbGU9KHZhbHVlL3RoaXMubWF4KSoocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKVxuYW5nbGUrPXByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddO3JldHVybiBhbmdsZTt9O3RoaXMub3ZlckNoYXJ0QXJlYT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHcmFwaC5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdXG5wYTIoY28sJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZScsdGhpcy5jb29yZHNbMF1bMF0sdGhpcy5jb29yZHNbMF1bMV0sdGhpcy5jb29yZHNbMF1bMl0scHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10scHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLHRoaXMuY29vcmRzWzBdWzBdLHRoaXMuY29vcmRzWzBdWzFdLHRoaXMuY29vcmRzWzBdWzJdLXRoaXMuY29vcmRzWzBdWzVdLHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSxwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSk7cmV0dXJuIGNvLmlzUG9pbnRJblBhdGgobW91c2VYLG1vdXNlWSk7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7fVxucHJvcFsnY2hhcnQuY29sb3JzJ11bMF09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11bMF0pO3Byb3BbJ2NoYXJ0LmNvbG9ycyddWzFdPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3J8fHR5cGVvZiBjb2xvciE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xLGxlbj1wYXJ0cy5sZW5ndGg7ajxsZW47KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO31cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLmZpcnN0RHJhd0Z1bmM9ZnVuY3Rpb24oKVxue307dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsaW5pdGlhbF92YWx1ZT10aGlzLmN1cnJlbnRWYWx1ZSxvcHQ9YXJndW1lbnRzWzBdfHx7fSxudW1GcmFtZXM9b3B0LmZyYW1lc3x8MzAsZnJhbWU9MCxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxkaWZmPXRoaXMudmFsdWUtTnVtYmVyKHRoaXMuY3VycmVudFZhbHVlKSxpbmNyZW1lbnQ9ZGlmZi9udW1GcmFtZXNcbmZ1bmN0aW9uIGl0ZXJhdG9yKClcbntmcmFtZSsrO2lmKGZyYW1lPD1udW1GcmFtZXMpe29iai52YWx1ZT1pbml0aWFsX3ZhbHVlKyhpbmNyZW1lbnQqZnJhbWUpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTt9ZWxzZXtjYWxsYmFjaygpO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuUmVnaXN0ZXIodGhpcyk7aWYocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyl7UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLGNvbmYub3B0aW9ucyk7fX07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc2VtaWNpcmN1bGFycHJvZ3Jlc3MuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///233\n");

/***/ }),
/* 234 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Bar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'bar';this.coords = [];this.stackedBackfaces = [];this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, variant: null, variant3dOffsetx: 10, variant3dOffsety: 5, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', hmargin: 3, hmarginGrouped: 2, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, keyTextFont: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');if (prop.variant !== '3d') {\n        prop.variant3dOffsetx = 0;prop.variant3dOffsety = 0;\n      } else {\n        this.svg.all.setAttribute('transform', 'skewY(5)');\n      }\n      RG.SVG.createDefs(this);this.coords = [];this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);if (prop.variant === '3d') {\n        RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, prop.gutterTop, prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, this.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft, this.height - prop.gutterBottom, prop.gutterLeft, prop.gutterTop), fill: '#ddd', stroke: '#ccc' } });this.threed_xaxis_group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph_3d_bar_xaxis_negative' } });RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, this.getYCoord(0), prop.gutterLeft + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight, this.getYCoord(0), prop.gutterLeft, this.getYCoord(0)), fill: '#ddd', stroke: '#ccc' } });\n      }\n      this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      var y = this.getYCoord(0);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = this.graphWidth / this.data.length,\n              height = (ma.abs(this.data[i]) - ma.abs(this.scale.min)) / (ma.abs(this.scale.max) - ma.abs(this.scale.min)) * this.graphHeight,\n              width = this.graphWidth / this.data.length - prop.hmargin - prop.hmargin,\n              x = prop.gutterLeft + prop.hmargin + outerSegment * i;if (this.scale.min >= 0 && this.scale.max > 0) {\n            y = this.getYCoord(this.scale.min) - height;\n          } else if (this.scale.min < 0 && this.scale.max > 0) {\n            height = ma.abs(this.data[i]) / (this.scale.max - this.scale.min) * this.graphHeight;y = this.getYCoord(0) - height;if (this.data[i] < 0) {\n              y = this.getYCoord(0);\n            }\n          } else if (this.scale.min < 0 && this.scale.max < 0) {\n            height = (ma.abs(this.data[i]) - ma.abs(this.scale.max)) / (ma.abs(this.scale.min) - ma.abs(this.scale.max)) * this.graphHeight;y = prop.gutterTop;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: prop.variant === '3d' && this.data[i] < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width < 0 ? 0 : width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n            this.drawTop3dFace({ rect: rect, value: this.data[i] });this.drawSide3dFace({ rect: rect, value: this.data[i] });\n          }\n          if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = this.graphWidth / this.data.length,\n              innerSegment = outerSegment - 2 * prop.hmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = (innerSegment - (this.data[i].length - 1) * prop.hmarginGrouped) / this.data[i].length,\n                x = outerSegment * i + prop.hmargin + prop.gutterLeft + j * width + (j - 1) * prop.hmarginGrouped;x = prop.gutterLeft + outerSegment * i + width * j + prop.hmargin + j * prop.hmarginGrouped;if (this.scale.min === 0 && this.scale.max > this.scale.min) {\n              var height = (this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(0) - height;\n            } else if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n              var height = (this.data[i][j] - this.scale.max) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.max);height = ma.abs(height);\n            } else if (this.scale.max > 0 && this.scale.min < 0) {\n              var height = ma.abs(this.data[i][j]) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.data[i][j] < 0 ? this.getYCoord(0) : this.getYCoord(this.data[i][j]);\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var height = ma.abs(this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.min) - height;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: prop.variant === '3d' && this.data[i][j] < 0 ? this.threed_xaxis_group : this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = this.graphWidth / this.data.length;var y = this.getYCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var height = ma.round(this.data[i][j] / (this.max - this.min) * this.graphHeight),\n                width = section - 2 * prop.hmargin,\n                x = prop.gutterLeft + i * section + prop.hmargin,\n                y = y - height;if (j === 0 && prop.shadow) {\n              var fullHeight = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphHeight);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { fill: 'white', x: x, y: this.height - prop.gutterBottom - fullHeight, width: width, height: fullHeight, 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getYCoord = function (value) {\n      if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {}\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0,\n            stacked_total = 0;;for (var i = 0; i < this.coords.length; ++i, seq++) {\n          var num = typeof this.data[i] === 'number' ? this.data[i] : data_seq[seq];if (prop.grouping === 'stacked') {\n            var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);var group = indexes[0];var datapiece = indexes[1];if (datapiece !== this.data[group].length - 1) {\n              continue;\n            } else {\n              num = RG.SVG.arraySum(this.data[group]);\n            }\n          }\n          var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n            str = prop.labelsAboveSpecific[seq];\n          } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n            continue;\n          }\n          var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (data_seq[i] >= 0) {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n          } else {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n          }\n          RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.drawTop3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(255,255,255,0.7)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_top_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(255,255,255,0.7)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x, y, x + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w, y) } });rect.rgraph_3d_top_face[i] = face;\n      }\n    };this.drawSide3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(0,0,0,0.3)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_side_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(0,0,0,0.3)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x + w, y, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y + h - prop.variant3dOffsety, x + w, y + h) } });rect.rgraph_3d_side_face[i] = face;\n      }\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            height = ma.abs(obj.getYCoord(data[i]) - obj.getYCoord(0));obj.data[i] = data[i] * multiplier;height = multiplier * height;obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i] < 0 ? obj.getYCoord(0) : obj.getYCoord(0) - height);if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped') {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n              if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeHeight = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              height = ma.abs(obj.getYCoord(data[i][j]) - obj.getYCoord(0));height = multiplier * height;obj.data[i][j] = data[i][j] * multiplier;height = ma.round(height);obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i][j] < 0 ? obj.getYCoord(0) + accumulativeHeight : obj.getYCoord(0) - height - accumulativeHeight);if (prop.variant === '3d') {\n                if (obj.coords[seq].object.rgraph_3d_side_face[0].parentNode) obj.coords[seq].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[0]);if (obj.coords[seq].object.rgraph_3d_side_face[1].parentNode) obj.coords[seq].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[1]);if (obj.coords[seq].object.rgraph_3d_top_face[0].parentNode) obj.coords[seq].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[0]);if (obj.coords[seq].object.rgraph_3d_top_face[1].parentNode) obj.coords[seq].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[seq].object });obj.drawTop3dFace({ rect: obj.coords[seq].object });if (obj.coords[seq].object.parentNode) {\n                  var parent = obj.coords[seq].object.parentNode;var node = parent.removeChild(obj.coords[seq].object);parent.appendChild(node);\n                }\n              }\n              accumulativeHeight += prop.grouping === 'stacked' ? height : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('height', accumulativeHeight);obj.stackedBackfaces[i].setAttribute('y', obj.height - prop.gutterBottom - accumulativeHeight);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {};for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('height', 0);if (this.coords[i].object.rgraph_3d_side_face) {\n          this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[1]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[1]);\n        }\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalHeight = obj.coords[i].object.getAttribute('data-original-height'),\n                height,\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));var height = ma.min((frame - opt.startFrames[i]) / framesperbar * originalHeight, originalHeight);obj.coords[i].object.setAttribute('height', height < 0 ? 0 : height);obj.coords[i].object.setAttribute('y', value >= 0 ? obj.getYCoord(0) - height : obj.getYCoord(0));if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n            if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('y', parseInt(obj.coords[i - 1].object.getAttribute('y')) - height);\n              }\n            }\n            if (prop.variant === '3d') {\n              obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped' || prop.grouping === 'stacked' && indexes[1] + 1 === obj.data[indexes[0]].length) {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmJhci5qcz9jMWJiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguU1ZHPVJHcmFwaC5TVkd8fHt9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aCx3aW49d2luZG93LGRvYz1kb2N1bWVudDtSRy5TVkcuQmFyPWZ1bmN0aW9uKGNvbmYpXG57dGhpcy5zZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbntpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7Zm9yKGkgaW4gYXJndW1lbnRzWzBdKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt2YXIgcmV0PVJHLlNWRy5jb21tb25TZXR0ZXIoe29iamVjdDp0aGlzLG5hbWU6aSx2YWx1ZTphcmd1bWVudHNbMF1baV19KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnNldChuYW1lLHZhbHVlKTt9fX1lbHNle3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTpuYW1lLHZhbHVlOnZhbHVlfSk7bmFtZT1yZXQubmFtZTt2YWx1ZT1yZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdPXZhbHVlO31cbnJldHVybiB0aGlzO307dGhpcy5pZD1jb25mLmlkO3RoaXMudWlkPVJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLnN2Zz1SRy5TVkcuY3JlYXRlU1ZHKHtjb250YWluZXI6dGhpcy5jb250YWluZXJ9KTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy53aWR0aD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTt0aGlzLmhlaWdodD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7dGhpcy5kYXRhPWNvbmYuZGF0YTt0aGlzLnR5cGU9J2Jhcic7dGhpcy5jb29yZHM9W107dGhpcy5zdGFja2VkQmFja2ZhY2VzPVtdO3RoaXMub3JpZ2luYWxDb2xvcnM9e307dGhpcy5ncmFkaWVudENvdW50ZXI9MTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9J2lubGluZS1ibG9jayc7dGhpcy5wcm9wZXJ0aWVzPXtndXR0ZXJMZWZ0OjM1LGd1dHRlclJpZ2h0OjM1LGd1dHRlclRvcDozNSxndXR0ZXJCb3R0b206MzUsdmFyaWFudDpudWxsLHZhcmlhbnQzZE9mZnNldHg6MTAsdmFyaWFudDNkT2Zmc2V0eTo1LGJhY2tncm91bmRDb2xvcjpudWxsLGJhY2tncm91bmRJbWFnZTpudWxsLGJhY2tncm91bmRJbWFnZUFzcGVjdDonbm9uZScsYmFja2dyb3VuZEltYWdlU3RyZXRjaDp0cnVlLGJhY2tncm91bmRJbWFnZU9wYWNpdHk6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VYOm51bGwsYmFja2dyb3VuZEltYWdlWTpudWxsLGJhY2tncm91bmRJbWFnZVc6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VIOm51bGwsYmFja2dyb3VuZEdyaWQ6dHJ1ZSxiYWNrZ3JvdW5kR3JpZENvbG9yOicjZGRkJyxiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDoxLGJhY2tncm91bmRHcmlkSGxpbmVzOnRydWUsYmFja2dyb3VuZEdyaWRIbGluZXNDb3VudDpudWxsLGJhY2tncm91bmRHcmlkVmxpbmVzOnRydWUsYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudDpudWxsLGJhY2tncm91bmRHcmlkQm9yZGVyOnRydWUsY29sb3JzOlsncmVkJywnIzBmMCcsJyMwMGYnLCcjZmYwJywnIzBmZicsJyMwZjAnLCdwaW5rJywnb3JhbmdlJywnZ3JheScsJ2JsYWNrJywncmVkJywnIzBmMCcsJyMwMGYnLCcjZmYwJywnIzBmZicsJyMwZjAnLCdwaW5rJywnb3JhbmdlJywnZ3JheScsJ2JsYWNrJ10sY29sb3JzU2VxdWVudGlhbDpmYWxzZSxzdHJva2VzdHlsZToncmdiYSgwLDAsMCwwKScsaG1hcmdpbjozLGhtYXJnaW5Hcm91cGVkOjIseWF4aXM6dHJ1ZSx5YXhpc1RpY2ttYXJrczp0cnVlLHlheGlzVGlja21hcmtzTGVuZ3RoOjMseWF4aXNDb2xvcjonYmxhY2snLHlheGlzU2NhbGU6dHJ1ZSx5YXhpc0xhYmVsczpudWxsLHlheGlzTGFiZWxzT2Zmc2V0eDowLHlheGlzTGFiZWxzT2Zmc2V0eTowLHlheGlzTGFiZWxzQ291bnQ6NSx5YXhpc1VuaXRzUHJlOicnLHlheGlzVW5pdHNQb3N0OicnLHlheGlzU3RyaWN0OmZhbHNlLHlheGlzRGVjaW1hbHM6MCx5YXhpc1BvaW50OicuJyx5YXhpc1Rob3VzYW5kOicsJyx5YXhpc1JvdW5kOmZhbHNlLHlheGlzTWF4Om51bGwseWF4aXNNaW46MCx5YXhpc0Zvcm1hdHRlcjpudWxsLHhheGlzOnRydWUseGF4aXNUaWNrbWFya3M6dHJ1ZSx4YXhpc1RpY2ttYXJrc0xlbmd0aDo1LHhheGlzTGFiZWxzOm51bGwseGF4aXNMYWJlbHNQb3NpdGlvbjonc2VjdGlvbicseGF4aXNMYWJlbHNQb3NpdGlvbkVkZ2VUaWNrbWFya3NDb3VudDpudWxsLHhheGlzQ29sb3I6J2JsYWNrJyx4YXhpc0xhYmVsc09mZnNldHg6MCx4YXhpc0xhYmVsc09mZnNldHk6MCxsYWJlbHNBYm92ZTpmYWxzZSxsYWJlbHNBYm92ZUZvbnQ6bnVsbCxsYWJlbHNBYm92ZVNpemU6bnVsbCxsYWJlbHNBYm92ZUJvbGQ6bnVsbCxsYWJlbHNBYm92ZUl0YWxpYzpudWxsLGxhYmVsc0Fib3ZlQ29sb3I6bnVsbCxsYWJlbHNBYm92ZUJhY2tncm91bmQ6bnVsbCxsYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nOjAsbGFiZWxzQWJvdmVVbml0c1ByZTpudWxsLGxhYmVsc0Fib3ZlVW5pdHNQb3N0Om51bGwsbGFiZWxzQWJvdmVQb2ludDpudWxsLGxhYmVsc0Fib3ZlVGhvdXNhbmQ6bnVsbCxsYWJlbHNBYm92ZUZvcm1hdHRlcjpudWxsLGxhYmVsc0Fib3ZlRGVjaW1hbHM6bnVsbCxsYWJlbHNBYm92ZU9mZnNldHg6MCxsYWJlbHNBYm92ZU9mZnNldHk6MCxsYWJlbHNBYm92ZUhhbGlnbjonY2VudGVyJyxsYWJlbHNBYm92ZVZhbGlnbjonYm90dG9tJyxsYWJlbHNBYm92ZVNwZWNpZmljOm51bGwsdGV4dENvbG9yOidibGFjaycsdGV4dEZvbnQ6J3NhbnMtc2VyaWYnLHRleHRTaXplOjEyLHRleHRCb2xkOmZhbHNlLHRleHRJdGFsaWM6ZmFsc2UsbGluZXdpZHRoOjEsZ3JvdXBpbmc6J2dyb3VwZWQnLHRvb2x0aXBzOm51bGwsdG9vbHRpcHNPdmVycmlkZTpudWxsLHRvb2x0aXBzRWZmZWN0OidmYWRlJyx0b29sdGlwc0Nzc0NsYXNzOidSR3JhcGhfdG9vbHRpcCcsdG9vbHRpcHNFdmVudDonY2xpY2snLGhpZ2hsaWdodFN0cm9rZToncmdiYSgwLDAsMCwwKScsaGlnaGxpZ2h0RmlsbDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxoaWdobGlnaHRMaW5ld2lkdGg6MSx0aXRsZTonJyx0aXRsZVNpemU6MTYsdGl0bGVYOm51bGwsdGl0bGVZOm51bGwsdGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVWYWxpZ246bnVsbCx0aXRsZUNvbG9yOidibGFjaycsdGl0bGVGb250Om51bGwsdGl0bGVCb2xkOmZhbHNlLHRpdGxlSXRhbGljOmZhbHNlLHRpdGxlU3VidGl0bGU6JycsdGl0bGVTdWJ0aXRsZVNpemU6MTAsdGl0bGVTdWJ0aXRsZVg6bnVsbCx0aXRsZVN1YnRpdGxlWTpudWxsLHRpdGxlU3VidGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVTdWJ0aXRsZVZhbGlnbjpudWxsLHRpdGxlU3VidGl0bGVDb2xvcjonI2FhYScsdGl0bGVTdWJ0aXRsZUZvbnQ6bnVsbCx0aXRsZVN1YnRpdGxlQm9sZDpmYWxzZSx0aXRsZVN1YnRpdGxlSXRhbGljOmZhbHNlLHNoYWRvdzpmYWxzZSxzaGFkb3dPZmZzZXR4OjIsc2hhZG93T2Zmc2V0eToyLHNoYWRvd0JsdXI6MixzaGFkb3dPcGFjaXR5OjAuMjUsa2V5Om51bGwsa2V5Q29sb3JzOm51bGwsa2V5T2Zmc2V0eDowLGtleU9mZnNldHk6MCxrZXlUZXh0T2Zmc2V0eDowLGtleVRleHRPZmZzZXR5Oi0xLGtleVRleHRTaXplOm51bGwsa2V5VGV4dEJvbGQ6bnVsbCxrZXlUZXh0SXRhbGljOm51bGwsa2V5VGV4dEZvbnQ6bnVsbCxhdHRyaWJ1dGlvbjp0cnVlLGF0dHJpYnV0aW9uWDpudWxsLGF0dHJpYnV0aW9uWTpudWxsLGF0dHJpYnV0aW9uSHJlZjpudWxsLGF0dHJpYnV0aW9uSGFsaWduOidyaWdodCcsYXR0cmlidXRpb25WYWxpZ246J2JvdHRvbScsYXR0cmlidXRpb25TaXplOjcsYXR0cmlidXRpb25Db2xvcjonZ3JheScsYXR0cmlidXRpb25Gb250OidzYW5zLXNlcmlmJyxhdHRyaWJ1dGlvbkl0YWxpYzpmYWxzZSxhdHRyaWJ1dGlvbkJvbGQ6ZmFsc2V9O2lmKFJHLlNWRy5GWCYmdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTt9XG52YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7dGhpcy5kcmF3PWZ1bmN0aW9uKClcbntSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO2lmKHByb3AudmFyaWFudCE9PSczZCcpe3Byb3AudmFyaWFudDNkT2Zmc2V0eD0wO3Byb3AudmFyaWFudDNkT2Zmc2V0eT0wO31lbHNle3RoaXMuc3ZnLmFsbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3NrZXdZKDUpJyk7fVxuUkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5jb29yZHM9W107dGhpcy5ncmFwaFdpZHRoPXRoaXMud2lkdGgtcHJvcC5ndXR0ZXJMZWZ0LXByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodD10aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbTtSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHtvYmplY3Q6dGhpc30pO3RoaXMucGFyc2VDb2xvcnMoKTt2YXIgdmFsdWVzPVtdO2Zvcih2YXIgaT0wLG1heD0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0nbnVtYmVyJyl7dmFsdWVzLnB1c2godGhpcy5kYXRhW2ldKTt9ZWxzZSBpZihSRy5TVkcuaXNBcnJheSh0aGlzLmRhdGFbaV0pJiZwcm9wLmdyb3VwaW5nPT09J2dyb3VwZWQnKXt2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlNYXgodGhpcy5kYXRhW2ldKSk7fWVsc2UgaWYoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcC5ncm91cGluZz09PSdzdGFja2VkJyl7dmFsdWVzLnB1c2goUkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkpO319XG52YXIgbWF4PVJHLlNWRy5hcnJheU1heCh2YWx1ZXMpO2lmKHR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicpe21heD1wcm9wLnlheGlzTWF4O31cbmlmKHByb3AueWF4aXNNaW49PT0nbWlycm9yJ3x8cHJvcC55YXhpc01pbj09PSdtaWRkbGUnfHxwcm9wLnlheGlzTWluPT09J2NlbnRlcicpe3ZhciBtaXJyb3JTY2FsZT10cnVlO3Byb3AueWF4aXNNaW49MDt9XG50aGlzLnNjYWxlPVJHLlNWRy5nZXRTY2FsZSh7b2JqZWN0OnRoaXMsbnVtbGFiZWxzOnByb3AueWF4aXNMYWJlbHNDb3VudCx1bml0c1ByZTpwcm9wLnlheGlzVW5pdHNQcmUsdW5pdHNQb3N0OnByb3AueWF4aXNVbml0c1Bvc3QsbWF4Om1heCxtaW46cHJvcC55YXhpc01pbixwb2ludDpwcm9wLnlheGlzUG9pbnQscm91bmQ6cHJvcC55YXhpc1JvdW5kLHRob3VzYW5kOnByb3AueWF4aXNUaG91c2FuZCxkZWNpbWFsczpwcm9wLnlheGlzRGVjaW1hbHMsc3RyaWN0OnR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicsZm9ybWF0dGVyOnByb3AueWF4aXNGb3JtYXR0ZXJ9KTtpZihtaXJyb3JTY2FsZSl7dGhpcy5zY2FsZT1SRy5TVkcuZ2V0U2NhbGUoe29iamVjdDp0aGlzLG51bWxhYmVsczpwcm9wLnlheGlzTGFiZWxzQ291bnQsdW5pdHNQcmU6cHJvcC55YXhpc1VuaXRzUHJlLHVuaXRzUG9zdDpwcm9wLnlheGlzVW5pdHNQb3N0LG1heDp0aGlzLnNjYWxlLm1heCxtaW46dGhpcy5zY2FsZS5tYXgqIC0xLHBvaW50OnByb3AueWF4aXNQb2ludCxyb3VuZDpmYWxzZSx0aG91c2FuZDpwcm9wLnlheGlzVGhvdXNhbmQsZGVjaW1hbHM6cHJvcC55YXhpc0RlY2ltYWxzLHN0cmljdDp0eXBlb2YgcHJvcC55YXhpc01heD09PSdudW1iZXInLGZvcm1hdHRlcjpwcm9wLnlheGlzRm9ybWF0dGVyfSk7fVxudGhpcy5tYXg9dGhpcy5zY2FsZS5tYXg7dGhpcy5taW49dGhpcy5zY2FsZS5taW47cHJvcC55YXhpc01heD10aGlzLnNjYWxlLm1heDtwcm9wLnlheGlzTWluPXRoaXMuc2NhbGUubWluO1JHLlNWRy5kcmF3QmFja2dyb3VuZCh0aGlzKTtpZihwcm9wLnZhcmlhbnQ9PT0nM2QnKXtSRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOidNIHsxfSB7Mn0gTCB7M30gezR9IEwgezV9IHs2fSBMIHs3fSB7OH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQscHJvcC5ndXR0ZXJUb3AscHJvcC5ndXR0ZXJMZWZ0K3Byb3AudmFyaWFudDNkT2Zmc2V0eCxwcm9wLmd1dHRlclRvcC1wcm9wLnZhcmlhbnQzZE9mZnNldHkscHJvcC5ndXR0ZXJMZWZ0K3Byb3AudmFyaWFudDNkT2Zmc2V0eCx0aGlzLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS1wcm9wLnZhcmlhbnQzZE9mZnNldHkscHJvcC5ndXR0ZXJMZWZ0LHRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLHByb3AuZ3V0dGVyTGVmdCxwcm9wLmd1dHRlclRvcCksZmlsbDonI2RkZCcsc3Ryb2tlOicjY2NjJ319KTt0aGlzLnRocmVlZF94YXhpc19ncm91cD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZTonZycscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntjbGFzc05hbWU6J3JncmFwaF8zZF9iYXJfeGF4aXNfbmVnYXRpdmUnfX0pO1JHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6J00gezF9IHsyfSBMIHszfSB7NH0gTCB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCx0aGlzLmdldFlDb29yZCgwKSxwcm9wLmd1dHRlckxlZnQrcHJvcC52YXJpYW50M2RPZmZzZXR4LHRoaXMuZ2V0WUNvb3JkKDApLXByb3AudmFyaWFudDNkT2Zmc2V0eSx0aGlzLndpZHRoLXByb3AuZ3V0dGVyUmlnaHQrcHJvcC52YXJpYW50M2RPZmZzZXR4LHRoaXMuZ2V0WUNvb3JkKDApLXByb3AudmFyaWFudDNkT2Zmc2V0eSx0aGlzLndpZHRoLXByb3AuZ3V0dGVyUmlnaHQsdGhpcy5nZXRZQ29vcmQoMCkscHJvcC5ndXR0ZXJMZWZ0LHRoaXMuZ2V0WUNvb3JkKDApKSxmaWxsOicjZGRkJyxzdHJva2U6JyNjY2MnfX0pO31cbnRoaXMuZHJhd0JhcnMoKTtSRy5TVkcuZHJhd1hBeGlzKHRoaXMpO1JHLlNWRy5kcmF3WUF4aXModGhpcyk7dGhpcy5kcmF3TGFiZWxzQWJvdmUoKTtpZih0eXBlb2YgcHJvcC5rZXkhPT1udWxsJiZSRy5TVkcuZHJhd0tleSl7UkcuU1ZHLmRyYXdLZXkodGhpcyk7fWVsc2UgaWYoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSl7YWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7fVxuUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmRyYXdCYXJzPWZ1bmN0aW9uKClcbnt2YXIgeT10aGlzLmdldFlDb29yZCgwKTtpZihwcm9wLnNoYWRvdyl7UkcuU1ZHLnNldFNoYWRvdyh7b2JqZWN0OnRoaXMsb2Zmc2V0eDpwcm9wLnNoYWRvd09mZnNldHgsb2Zmc2V0eTpwcm9wLnNoYWRvd09mZnNldHksYmx1cjpwcm9wLnNoYWRvd0JsdXIsb3BhY2l0eTpwcm9wLnNoYWRvd09wYWNpdHksaWQ6J2Ryb3BTaGFkb3cnfSk7fVxuZm9yKHZhciBpPTAsc2VxdWVudGlhbEluZGV4PTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSwrK3NlcXVlbnRpYWxJbmRleCl7aWYodHlwZW9mIHRoaXMuZGF0YVtpXT09PSdudW1iZXInKXt2YXIgb3V0ZXJTZWdtZW50PXRoaXMuZ3JhcGhXaWR0aC90aGlzLmRhdGEubGVuZ3RoLGhlaWdodD0obWEuYWJzKHRoaXMuZGF0YVtpXSktbWEuYWJzKHRoaXMuc2NhbGUubWluKSkvKG1hLmFicyh0aGlzLnNjYWxlLm1heCktbWEuYWJzKHRoaXMuc2NhbGUubWluKSkqdGhpcy5ncmFwaEhlaWdodCx3aWR0aD0odGhpcy5ncmFwaFdpZHRoL3RoaXMuZGF0YS5sZW5ndGgpLXByb3AuaG1hcmdpbi1wcm9wLmhtYXJnaW4seD1wcm9wLmd1dHRlckxlZnQrcHJvcC5obWFyZ2luKyhvdXRlclNlZ21lbnQqaSk7aWYodGhpcy5zY2FsZS5taW4+PTAmJnRoaXMuc2NhbGUubWF4PjApe3k9dGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZS5taW4pLWhlaWdodDt9ZWxzZSBpZih0aGlzLnNjYWxlLm1pbjwwJiZ0aGlzLnNjYWxlLm1heD4wKXtoZWlnaHQ9KG1hLmFicyh0aGlzLmRhdGFbaV0pLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpKnRoaXMuZ3JhcGhIZWlnaHQ7eT10aGlzLmdldFlDb29yZCgwKS1oZWlnaHQ7aWYodGhpcy5kYXRhW2ldPDApe3k9dGhpcy5nZXRZQ29vcmQoMCk7fX1lbHNlIGlmKHRoaXMuc2NhbGUubWluPDAmJnRoaXMuc2NhbGUubWF4PDApe2hlaWdodD0obWEuYWJzKHRoaXMuZGF0YVtpXSktbWEuYWJzKHRoaXMuc2NhbGUubWF4KSkvKG1hLmFicyh0aGlzLnNjYWxlLm1pbiktbWEuYWJzKHRoaXMuc2NhbGUubWF4KSkqdGhpcy5ncmFwaEhlaWdodDt5PXByb3AuZ3V0dGVyVG9wO31cbnZhciByZWN0PVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidyZWN0JyxwYXJlbnQ6cHJvcC52YXJpYW50PT09JzNkJyYmdGhpcy5kYXRhW2ldPDA/dGhpcy50aHJlZWRfeGF4aXNfZ3JvdXA6dGhpcy5zdmcuYWxsLGF0dHI6e3N0cm9rZTpwcm9wLnN0cm9rZXN0eWxlLGZpbGw6cHJvcC5jb2xvcnNTZXF1ZW50aWFsPyhwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdP3Byb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF06cHJvcC5jb2xvcnNbcHJvcC5jb2xvcnMubGVuZ3RoLTFdKTpwcm9wLmNvbG9yc1swXSx4OngseTp5LHdpZHRoOndpZHRoPDA/MDp3aWR0aCxoZWlnaHQ6aGVpZ2h0LCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdkYXRhLW9yaWdpbmFsLXgnOngsJ2RhdGEtb3JpZ2luYWwteSc6eSwnZGF0YS1vcmlnaW5hbC13aWR0aCc6d2lkdGgsJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzpoZWlnaHQsJ2RhdGEtdG9vbHRpcCc6KCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzLmxlbmd0aCk/cHJvcC50b29sdGlwc1tpXTonJywnZGF0YS1pbmRleCc6aSwnZGF0YS1zZXF1ZW50aWFsLWluZGV4JzpzZXF1ZW50aWFsSW5kZXgsJ2RhdGEtdmFsdWUnOnRoaXMuZGF0YVtpXSxmaWx0ZXI6cHJvcC5zaGFkb3c/J3VybCgjZHJvcFNoYWRvdyknOicnfX0pO3RoaXMuY29vcmRzLnB1c2goe29iamVjdDpyZWN0LHg6eCx5OnktKHRoaXMuZGF0YVtpXT4wP2hlaWdodDowKSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0fSk7aWYocHJvcC52YXJpYW50PT09JzNkJyl7dGhpcy5kcmF3VG9wM2RGYWNlKHtyZWN0OnJlY3QsdmFsdWU6dGhpcy5kYXRhW2ldfSk7dGhpcy5kcmF3U2lkZTNkRmFjZSh7cmVjdDpyZWN0LHZhbHVlOnRoaXMuZGF0YVtpXX0pO31cbmlmKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pe3ZhciBvYmo9dGhpczsoZnVuY3Rpb24oaWR4LHNlcSlcbntyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sJycpLGZ1bmN0aW9uKGUpXG57b2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHtvYmplY3Q6b2JqLGluZGV4OmlkeCxncm91cDpudWxsLHNlcXVlbnRpYWxJbmRleDpzZXEsdGV4dDpwcm9wLnRvb2x0aXBzW3NlcV0sZXZlbnQ6ZX0pO29iai5oaWdobGlnaHQoZS50YXJnZXQpO30sZmFsc2UpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbihlKVxue2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcid9LGZhbHNlKTt9KShpLHNlcXVlbnRpYWxJbmRleCk7fX1lbHNlIGlmKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkmJnByb3AuZ3JvdXBpbmc9PT0nZ3JvdXBlZCcpe3ZhciBvdXRlclNlZ21lbnQ9KHRoaXMuZ3JhcGhXaWR0aC90aGlzLmRhdGEubGVuZ3RoKSxpbm5lclNlZ21lbnQ9b3V0ZXJTZWdtZW50LSgyKnByb3AuaG1hcmdpbik7Zm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysraiwrK3NlcXVlbnRpYWxJbmRleCl7dmFyIHdpZHRoPSgoaW5uZXJTZWdtZW50LSgodGhpcy5kYXRhW2ldLmxlbmd0aC0xKSpwcm9wLmhtYXJnaW5Hcm91cGVkKSkvdGhpcy5kYXRhW2ldLmxlbmd0aCkseD0ob3V0ZXJTZWdtZW50KmkpK3Byb3AuaG1hcmdpbitwcm9wLmd1dHRlckxlZnQrKGoqd2lkdGgpKygoai0xKSpwcm9wLmhtYXJnaW5Hcm91cGVkKTt4PXByb3AuZ3V0dGVyTGVmdCsob3V0ZXJTZWdtZW50KmkpKyh3aWR0aCpqKStwcm9wLmhtYXJnaW4rKGoqcHJvcC5obWFyZ2luR3JvdXBlZCk7aWYodGhpcy5zY2FsZS5taW49PT0wJiZ0aGlzLnNjYWxlLm1heD50aGlzLnNjYWxlLm1pbil7dmFyIGhlaWdodD0oKHRoaXMuZGF0YVtpXVtqXS10aGlzLnNjYWxlLm1pbikvKHRoaXMuc2NhbGUubWF4LXRoaXMuc2NhbGUubWluKSkqdGhpcy5ncmFwaEhlaWdodCx5PXRoaXMuZ2V0WUNvb3JkKDApLWhlaWdodDt9ZWxzZSBpZih0aGlzLnNjYWxlLm1heDw9MCYmdGhpcy5zY2FsZS5taW48dGhpcy5zY2FsZS5tYXgpe3ZhciBoZWlnaHQ9KCh0aGlzLmRhdGFbaV1bal0tdGhpcy5zY2FsZS5tYXgpLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpKnRoaXMuZ3JhcGhIZWlnaHQseT10aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlLm1heCk7aGVpZ2h0PW1hLmFicyhoZWlnaHQpO31lbHNlIGlmKHRoaXMuc2NhbGUubWF4PjAmJnRoaXMuc2NhbGUubWluPDApe3ZhciBoZWlnaHQ9KG1hLmFicyh0aGlzLmRhdGFbaV1bal0pLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpKnRoaXMuZ3JhcGhIZWlnaHQseT10aGlzLmRhdGFbaV1bal08MD90aGlzLmdldFlDb29yZCgwKTp0aGlzLmdldFlDb29yZCh0aGlzLmRhdGFbaV1bal0pO31lbHNlIGlmKHRoaXMuc2NhbGUubWluPjAmJnRoaXMuc2NhbGUubWF4PnRoaXMuc2NhbGUubWluKXt2YXIgaGVpZ2h0PShtYS5hYnModGhpcy5kYXRhW2ldW2pdLXRoaXMuc2NhbGUubWluKS8odGhpcy5zY2FsZS5tYXgtdGhpcy5zY2FsZS5taW4pKSp0aGlzLmdyYXBoSGVpZ2h0LHk9dGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZS5taW4pLWhlaWdodDt9XG52YXIgcmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnByb3AudmFyaWFudD09PSczZCcmJnRoaXMuZGF0YVtpXVtqXTwwP3RoaXMudGhyZWVkX3hheGlzX2dyb3VwOnRoaXMuc3ZnLmFsbCx0eXBlOidyZWN0JyxhdHRyOntzdHJva2U6cHJvcFsnc3Ryb2tlc3R5bGUnXSxmaWxsOihwcm9wLmNvbG9yc1NlcXVlbnRpYWwmJnByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0pP3Byb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF06cHJvcC5jb2xvcnNbal0seDp4LHk6eSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0LCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdkYXRhLW9yaWdpbmFsLXgnOngsJ2RhdGEtb3JpZ2luYWwteSc6eSwnZGF0YS1vcmlnaW5hbC13aWR0aCc6d2lkdGgsJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzpoZWlnaHQsJ2RhdGEtaW5kZXgnOmksJ2RhdGEtc2VxdWVudGlhbC1pbmRleCc6c2VxdWVudGlhbEluZGV4LCdkYXRhLXRvb2x0aXAnOighUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSYmcHJvcC50b29sdGlwcy5sZW5ndGgpP3Byb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XTonJywnZGF0YS12YWx1ZSc6dGhpcy5kYXRhW2ldW2pdLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6Jyd9fSk7dGhpcy5jb29yZHMucHVzaCh7b2JqZWN0OnJlY3QseDp4LHk6eS0odGhpcy5kYXRhW2ldW2pdPjA/aGVpZ2h0OjApLHdpZHRoOndpZHRoLGhlaWdodDpoZWlnaHR9KTtpZihwcm9wLnZhcmlhbnQ9PT0nM2QnKXt0aGlzLmRyYXdUb3AzZEZhY2Uoe3JlY3Q6cmVjdCx2YWx1ZTp0aGlzLmRhdGFbaV1bal19KTt0aGlzLmRyYXdTaWRlM2RGYWNlKHtyZWN0OnJlY3QsdmFsdWU6dGhpcy5kYXRhW2ldW2pdfSk7fVxuaWYoIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykmJnByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSl7dmFyIG9iaj10aGlzOyhmdW5jdGlvbihpZHgsc2VxKVxue29iai5yZW1vdmVIaWdobGlnaHQoKTt2YXIgaW5kZXhlcz1SRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNlcSxvYmouZGF0YSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudC5yZXBsYWNlKC9eb24vLCcnKSxmdW5jdGlvbihlKVxue1JHLlNWRy50b29sdGlwKHtvYmplY3Q6b2JqLGdyb3VwOmlkeCxpbmRleDppbmRleGVzWzFdLHNlcXVlbnRpYWxJbmRleDpzZXEsdGV4dDpwcm9wLnRvb2x0aXBzW3NlcV0sZXZlbnQ6ZX0pO29iai5oaWdobGlnaHQoZS50YXJnZXQpO30sZmFsc2UpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbihlKVxue2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcid9LGZhbHNlKTt9KShpLHNlcXVlbnRpYWxJbmRleCk7fX1cbi0tc2VxdWVudGlhbEluZGV4O31lbHNlIGlmKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkmJnByb3AuZ3JvdXBpbmc9PT0nc3RhY2tlZCcpe3ZhciBzZWN0aW9uPSh0aGlzLmdyYXBoV2lkdGgvdGhpcy5kYXRhLmxlbmd0aCk7dmFyIHk9dGhpcy5nZXRZQ29vcmQoMCk7Zm9yKHZhciBqPTA7ajx0aGlzLmRhdGFbaV0ubGVuZ3RoOysraiwrK3NlcXVlbnRpYWxJbmRleCl7dmFyIGhlaWdodD1tYS5yb3VuZCgodGhpcy5kYXRhW2ldW2pdLyh0aGlzLm1heC10aGlzLm1pbikpKnRoaXMuZ3JhcGhIZWlnaHQpLHdpZHRoPXNlY3Rpb24tKDIqcHJvcC5obWFyZ2luKSx4PXByb3AuZ3V0dGVyTGVmdCsoaSpzZWN0aW9uKStwcm9wLmhtYXJnaW4seT15LWhlaWdodDtpZihqPT09MCYmcHJvcC5zaGFkb3cpe3ZhciBmdWxsSGVpZ2h0PW1hLmFicygoUkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkvKHRoaXMubWF4LXRoaXMubWluKSkqdGhpcy5ncmFwaEhlaWdodCk7dmFyIHJlY3Q9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncmVjdCcsYXR0cjp7ZmlsbDond2hpdGUnLHg6eCx5OnRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLWZ1bGxIZWlnaHQsd2lkdGg6d2lkdGgsaGVpZ2h0OmZ1bGxIZWlnaHQsJ3N0cm9rZS13aWR0aCc6MCwnZGF0YS1pbmRleCc6aSxmaWx0ZXI6J3VybCgjZHJvcFNoYWRvdyknfX0pO3RoaXMuc3RhY2tlZEJhY2tmYWNlc1tpXT1yZWN0O31cbnZhciByZWN0PVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J3JlY3QnLGF0dHI6e3N0cm9rZTpwcm9wWydzdHJva2VzdHlsZSddLGZpbGw6cHJvcC5jb2xvcnNTZXF1ZW50aWFsPyhwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdP3Byb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF06cHJvcC5jb2xvcnNbcHJvcC5jb2xvcnMubGVuZ3RoLTFdKTpwcm9wLmNvbG9yc1tqXSx4OngseTp5LHdpZHRoOndpZHRoLGhlaWdodDpoZWlnaHQsJ3N0cm9rZS13aWR0aCc6cHJvcC5saW5ld2lkdGgsJ2RhdGEtb3JpZ2luYWwteCc6eCwnZGF0YS1vcmlnaW5hbC15Jzp5LCdkYXRhLW9yaWdpbmFsLXdpZHRoJzp3aWR0aCwnZGF0YS1vcmlnaW5hbC1oZWlnaHQnOmhlaWdodCwnZGF0YS1pbmRleCc6aSwnZGF0YS1zZXF1ZW50aWFsLWluZGV4JzpzZXF1ZW50aWFsSW5kZXgsJ2RhdGEtdG9vbHRpcCc6KCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzLmxlbmd0aCk/cHJvcC50b29sdGlwc1tzZXF1ZW50aWFsSW5kZXhdOicnLCdkYXRhLXZhbHVlJzp0aGlzLmRhdGFbaV1bal19fSk7dGhpcy5jb29yZHMucHVzaCh7b2JqZWN0OnJlY3QseDp4LHk6eSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0fSk7aWYocHJvcC52YXJpYW50PT09JzNkJyl7dGhpcy5kcmF3VG9wM2RGYWNlKHtyZWN0OnJlY3QsdmFsdWU6dGhpcy5kYXRhW2ldW2pdfSk7dGhpcy5kcmF3U2lkZTNkRmFjZSh7cmVjdDpyZWN0LHZhbHVlOnRoaXMuZGF0YVtpXVtqXX0pO31cbmlmKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pe3ZhciBvYmo9dGhpczsoZnVuY3Rpb24oaWR4LHNlcSlcbntyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sJycpLGZ1bmN0aW9uKGUpXG57b2JqLnJlbW92ZUhpZ2hsaWdodCgpO3ZhciBpbmRleGVzPVJHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQoc2VxLG9iai5kYXRhKTtSRy5TVkcudG9vbHRpcCh7b2JqZWN0Om9iaixpbmRleDppbmRleGVzWzFdLGdyb3VwOmlkeCxzZXF1ZW50aWFsSW5kZXg6c2VxLHRleHQ6cHJvcC50b29sdGlwc1tzZXFdLGV2ZW50OmV9KTtvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTt9LGZhbHNlKTtyZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZnVuY3Rpb24oZSlcbntlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO30pKGksc2VxdWVudGlhbEluZGV4KTt9fVxuLS1zZXF1ZW50aWFsSW5kZXg7fX19O3RoaXMuZ2V0WUNvb3JkPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPnRoaXMuc2NhbGUubWF4KXtyZXR1cm4gbnVsbDt9XG52YXIgeSx4YXhpc3Bvcz1wcm9wLnhheGlzcG9zO2lmKHZhbHVlPHRoaXMuc2NhbGUubWluKXtyZXR1cm4gbnVsbDt9XG55PSgodmFsdWUtdGhpcy5zY2FsZS5taW4pLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpO3kqPSh0aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbSk7eT10aGlzLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS15O3JldHVybiB5O307dGhpcy5oaWdobGlnaHQ9ZnVuY3Rpb24ocmVjdClcbnt2YXIgeD1yZWN0LmdldEF0dHJpYnV0ZSgneCcpLHk9cmVjdC5nZXRBdHRyaWJ1dGUoJ3knKSx3aWR0aD1yZWN0LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSxoZWlnaHQ9cmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO3ZhciBoaWdobGlnaHQ9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncmVjdCcsYXR0cjp7c3Ryb2tlOnByb3AuaGlnaGxpZ2h0U3Ryb2tlLGZpbGw6cHJvcC5oaWdobGlnaHRGaWxsLHg6eCx5Onksd2lkdGg6d2lkdGgsaGVpZ2h0OmhlaWdodCwnc3Ryb2tlLXdpZHRoJzpwcm9wLmhpZ2hsaWdodExpbmV3aWR0aH19KTtpZihwcm9wLnRvb2x0aXBzRXZlbnQ9PT0nbW91c2Vtb3ZlJyl7fVxuUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsaGlnaGxpZ2h0KTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpe3RoaXMub3JpZ2luYWxDb2xvcnM9e2NvbG9yczpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksYmFja2dyb3VuZEdyaWRDb2xvcjpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IpLGhpZ2hsaWdodEZpbGw6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKSxiYWNrZ3JvdW5kQ29sb3I6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpfX1cbnZhciBjb2xvcnM9cHJvcC5jb2xvcnM7aWYoY29sb3JzKXtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOmNvbG9yc1tpXX0pO319XG5wcm9wLmJhY2tncm91bmRHcmlkQ29sb3I9UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuYmFja2dyb3VuZEdyaWRDb2xvcn0pO3Byb3AuaGlnaGxpZ2h0RmlsbD1SRy5TVkcucGFyc2VDb2xvckxpbmVhcih7b2JqZWN0OnRoaXMsY29sb3I6cHJvcC5oaWdobGlnaHRGaWxsfSk7cHJvcC5iYWNrZ3JvdW5kQ29sb3I9UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuYmFja2dyb3VuZENvbG9yfSk7fTt0aGlzLmRyYXdMYWJlbHNBYm92ZT1mdW5jdGlvbigpXG57aWYocHJvcC5sYWJlbHNBYm92ZSl7dmFyIGRhdGFfc2VxPVJHLlNWRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLHNlcT0wLHN0YWNrZWRfdG90YWw9MDs7Zm9yKHZhciBpPTA7aTx0aGlzLmNvb3Jkcy5sZW5ndGg7KytpLHNlcSsrKXt2YXIgbnVtPXR5cGVvZiB0aGlzLmRhdGFbaV09PT0nbnVtYmVyJz90aGlzLmRhdGFbaV06ZGF0YV9zZXFbc2VxXTtpZihwcm9wLmdyb3VwaW5nPT09J3N0YWNrZWQnKXt2YXIgaW5kZXhlcz1SRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKGksdGhpcy5kYXRhKTt2YXIgZ3JvdXA9aW5kZXhlc1swXTt2YXIgZGF0YXBpZWNlPWluZGV4ZXNbMV07aWYoZGF0YXBpZWNlIT09KHRoaXMuZGF0YVtncm91cF0ubGVuZ3RoLTEpKXtjb250aW51ZTt9ZWxzZXtudW09UkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YVtncm91cF0pO319XG52YXIgc3RyPVJHLlNWRy5udW1iZXJGb3JtYXQoe29iamVjdDp0aGlzLG51bTpudW0udG9GaXhlZChwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHMpLHByZXBlbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1ByZT09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1ByZTpudWxsLGFwcGVuZDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1Bvc3Q6bnVsbCxwb2ludDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVBvaW50PT09J3N0cmluZyc/cHJvcC5sYWJlbHNBYm92ZVBvaW50Om51bGwsdGhvdXNhbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVUaG91c2FuZD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVUaG91c2FuZDpudWxsLGZvcm1hdHRlcjp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcj09PSdmdW5jdGlvbic/cHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcjpudWxsfSk7aWYocHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljJiZwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMubGVuZ3RoJiYodHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdPT09J3N0cmluZyd8fHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXT09PSdudW1iZXInKSl7c3RyPXByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdO31lbHNlIGlmKHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyYmcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljLmxlbmd0aCYmdHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdIT09J3N0cmluZycmJnR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXSE9PSdudW1iZXInKXtjb250aW51ZTt9XG52YXIgeD1wYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSkrcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLzIpK3Byb3AubGFiZWxzQWJvdmVPZmZzZXR4O2lmKGRhdGFfc2VxW2ldPj0wKXt2YXIgeT1wYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSktNytwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eTt2YXIgdmFsaWduPXByb3AubGFiZWxzQWJvdmVWYWxpZ247fWVsc2V7dmFyIHk9cGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpK3BhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKzctcHJvcC5sYWJlbHNBYm92ZU9mZnNldHk7dmFyIHZhbGlnbj1wcm9wLmxhYmVsc0Fib3ZlVmFsaWduPT09J3RvcCc/J2JvdHRvbSc6J3RvcCc7fVxuUkcuU1ZHLnRleHQoe29iamVjdDp0aGlzLHBhcmVudDp0aGlzLnN2Zy5hbGwsdGV4dDpzdHIseDp4LHk6eSxoYWxpZ246cHJvcC5sYWJlbHNBYm92ZUhhbGlnbix2YWxpZ246dmFsaWduLGZvbnQ6cHJvcC5sYWJlbHNBYm92ZUZvbnR8fHByb3AudGV4dEZvbnQsc2l6ZTpwcm9wLmxhYmVsc0Fib3ZlU2l6ZXx8cHJvcC50ZXh0U2l6ZSxib2xkOnByb3AubGFiZWxzQWJvdmVCb2xkfHxwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLmxhYmVsc0Fib3ZlSXRhbGljfHxwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC5sYWJlbHNBYm92ZUNvbG9yfHxwcm9wLnRleHRDb2xvcixiYWNrZ3JvdW5kOnByb3AubGFiZWxzQWJvdmVCYWNrZ3JvdW5kfHxudWxsLHBhZGRpbmc6cHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nfHwwfSk7fX19O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5SRy5TVkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5yZW1vdmVIaWdobGlnaHQ9ZnVuY3Rpb24oKVxue3ZhciBoaWdobGlnaHQ9UkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO2lmKGhpZ2hsaWdodCYmaGlnaGxpZ2h0LnBhcmVudE5vZGUpe2hpZ2hsaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZ2hsaWdodCk7fVxuUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsbnVsbCk7fTt0aGlzLmRyYXdUb3AzZEZhY2U9ZnVuY3Rpb24ob3B0KVxue3ZhciByZWN0PW9wdC5yZWN0LGFycj1bcGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKSksJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSddLHg9cGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSkseT1wYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgneScpKSx3PXBhcnNlSW50KHJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSxoPXBhcnNlSW50KHJlY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7cmVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2U9W107Zm9yKHZhciBpPTA7aTwyOysraSl7dmFyIGNvbG9yPShpPT09MD9yZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknKTt2YXIgZmFjZT1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncGF0aCcscGFyZW50OnByb3AudmFyaWFudD09PSczZCcmJm9wdC52YWx1ZTwwP3RoaXMudGhyZWVkX3hheGlzX2dyb3VwOnRoaXMuc3ZnLmFsbCxhdHRyOntzdHJva2U6cHJvcC5zdHJva2VzdHlsZSxmaWxsOmNvbG9yLCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLGQ6J00gezF9IHsyfSBMIHszfSB7NH0gTCB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KHgseSx4K3Byb3AudmFyaWFudDNkT2Zmc2V0eCx5LXByb3AudmFyaWFudDNkT2Zmc2V0eSx4K3crcHJvcC52YXJpYW50M2RPZmZzZXR4LHktcHJvcC52YXJpYW50M2RPZmZzZXR5LHgrdyx5KX19KTtyZWN0LnJncmFwaF8zZF90b3BfZmFjZVtpXT1mYWNlfX07dGhpcy5kcmF3U2lkZTNkRmFjZT1mdW5jdGlvbihvcHQpXG57dmFyIHJlY3Q9b3B0LnJlY3QsYXJyPVtwYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpKSwncmdiYSgwLDAsMCwwLjMpJ10seD1wYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgneCcpKSx5PXBhcnNlSW50KHJlY3QuZ2V0QXR0cmlidXRlKCd5JykpLHc9cGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpLGg9cGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtyZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2U9W107Zm9yKHZhciBpPTA7aTwyOysraSl7dmFyIGNvbG9yPShpPT09MD9yZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpOidyZ2JhKDAsMCwwLDAuMyknKTt2YXIgZmFjZT1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncGF0aCcscGFyZW50OnByb3AudmFyaWFudD09PSczZCcmJm9wdC52YWx1ZTwwP3RoaXMudGhyZWVkX3hheGlzX2dyb3VwOnRoaXMuc3ZnLmFsbCxhdHRyOntzdHJva2U6cHJvcC5zdHJva2VzdHlsZSxmaWxsOmNvbG9yLCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLGQ6J00gezF9IHsyfSBMIHszfSB7NH0gTCB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KHgrdyx5LHgrdytwcm9wLnZhcmlhbnQzZE9mZnNldHgseS1wcm9wLnZhcmlhbnQzZE9mZnNldHkseCt3K3Byb3AudmFyaWFudDNkT2Zmc2V0eCx5K2gtcHJvcC52YXJpYW50M2RPZmZzZXR5LHgrdyx5K2gpfX0pO3JlY3QucmdyYXBoXzNkX3NpZGVfZmFjZVtpXT1mYWNlfX07dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDMwLGZyYW1lPTAsb2JqPXRoaXMsZGF0YT1bXSxoZWlnaHQ9bnVsbCxzZXE9MDtkYXRhPVJHLlNWRy5hcnJheUNsb25lKHRoaXMuZGF0YSk7dGhpcy5kcmF3KCk7dmFyIGl0ZXJhdGU9ZnVuY3Rpb24oKVxue2Zvcih2YXIgaT0wLHNlcT0wLGxlbj1vYmouY29vcmRzLmxlbmd0aDtpPGxlbjsrK2ksKytzZXEpe3ZhciBtdWx0aXBsaWVyPShmcmFtZS9mcmFtZXMpKlJHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcyxmcmFtZSkqUkcuU1ZHLkZYLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLGZyYW1lKTtpZih0eXBlb2YgZGF0YVtpXT09PSdudW1iZXInKXtoZWlnaHQ9bWEuYWJzKG9iai5nZXRZQ29vcmQoZGF0YVtpXSktb2JqLmdldFlDb29yZCgwKSk7b2JqLmRhdGFbaV09ZGF0YVtpXSptdWx0aXBsaWVyO2hlaWdodD1tdWx0aXBsaWVyKmhlaWdodDtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO29iai5jb29yZHNbc2VxXS5vYmplY3Quc2V0QXR0cmlidXRlKCd5JyxkYXRhW2ldPDA/b2JqLmdldFlDb29yZCgwKTpvYmouZ2V0WUNvb3JkKDApLWhlaWdodCk7aWYocHJvcC52YXJpYW50PT09JzNkJyl7aWYob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVswXS5wYXJlbnROb2RlKW9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdKTtpZihvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzFdLnBhcmVudE5vZGUpb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMV0pO2lmKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlKW9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXSk7aWYob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUpb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdKTtvYmouZHJhd1NpZGUzZEZhY2Uoe3JlY3Q6b2JqLmNvb3Jkc1tpXS5vYmplY3R9KTtpZihwcm9wLmdyb3VwaW5nPT09J2dyb3VwZWQnKXtvYmouZHJhd1RvcDNkRmFjZSh7cmVjdDpvYmouY29vcmRzW2ldLm9iamVjdH0pO31cbmlmKG9iai5jb29yZHNbaV0ub2JqZWN0LnBhcmVudE5vZGUpe3ZhciBwYXJlbnQ9b2JqLmNvb3Jkc1tpXS5vYmplY3QucGFyZW50Tm9kZTt2YXIgbm9kZT1wYXJlbnQucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QpO3BhcmVudC5hcHBlbmRDaGlsZChub2RlKTt9fX1lbHNlIGlmKHR5cGVvZiBkYXRhW2ldPT09J29iamVjdCcpe3ZhciBhY2N1bXVsYXRpdmVIZWlnaHQ9MDtmb3IodmFyIGo9MCxsZW4yPWRhdGFbaV0ubGVuZ3RoO2o8bGVuMjsrK2osKytzZXEpe2hlaWdodD1tYS5hYnMob2JqLmdldFlDb29yZChkYXRhW2ldW2pdKS1vYmouZ2V0WUNvb3JkKDApKTtoZWlnaHQ9bXVsdGlwbGllcipoZWlnaHQ7b2JqLmRhdGFbaV1bal09ZGF0YVtpXVtqXSptdWx0aXBsaWVyO2hlaWdodD1tYS5yb3VuZChoZWlnaHQpO29iai5jb29yZHNbc2VxXS5vYmplY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7b2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3knLGRhdGFbaV1bal08MD8ob2JqLmdldFlDb29yZCgwKSthY2N1bXVsYXRpdmVIZWlnaHQpOihvYmouZ2V0WUNvb3JkKDApLWhlaWdodC1hY2N1bXVsYXRpdmVIZWlnaHQpKTtpZihwcm9wLnZhcmlhbnQ9PT0nM2QnKXtpZihvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZSlvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0pO2lmKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlKW9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXSk7aWYob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0ucGFyZW50Tm9kZSlvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdKTtpZihvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXS5wYXJlbnROb2RlKW9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMV0pO29iai5kcmF3U2lkZTNkRmFjZSh7cmVjdDpvYmouY29vcmRzW3NlcV0ub2JqZWN0fSk7b2JqLmRyYXdUb3AzZEZhY2Uoe3JlY3Q6b2JqLmNvb3Jkc1tzZXFdLm9iamVjdH0pO2lmKG9iai5jb29yZHNbc2VxXS5vYmplY3QucGFyZW50Tm9kZSl7dmFyIHBhcmVudD1vYmouY29vcmRzW3NlcV0ub2JqZWN0LnBhcmVudE5vZGU7dmFyIG5vZGU9cGFyZW50LnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QpO3BhcmVudC5hcHBlbmRDaGlsZChub2RlKTt9fVxuYWNjdW11bGF0aXZlSGVpZ2h0Kz0ocHJvcC5ncm91cGluZz09PSdzdGFja2VkJz9oZWlnaHQ6MCk7fVxuaWYob2JqLnN0YWNrZWRCYWNrZmFjZXNbaV0pe29iai5zdGFja2VkQmFja2ZhY2VzW2ldLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxhY2N1bXVsYXRpdmVIZWlnaHQpO29iai5zdGFja2VkQmFja2ZhY2VzW2ldLnNldEF0dHJpYnV0ZSgneScsb2JqLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS1hY2N1bXVsYXRpdmVIZWlnaHQpO31cbi0tc2VxO319XG5pZihmcmFtZSsrPGZyYW1lcyl7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRlKTt9ZWxzZSBpZihvcHQuY2FsbGJhY2speyhvcHQuY2FsbGJhY2spKG9iaik7fX07aXRlcmF0ZSgpO3JldHVybiB0aGlzO307dGhpcy53YXZlPWZ1bmN0aW9uKClcbnt0aGlzLmRyYXcoKTt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e307b3B0LmZyYW1lcz1vcHQuZnJhbWVzfHw2MDtvcHQuc3RhcnRGcmFtZXM9W107b3B0LmNvdW50ZXJzPVtdO3ZhciBmcmFtZXNwZXJiYXI9b3B0LmZyYW1lcy8zLGZyYW1lPS0xLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9O2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSs9MSl7b3B0LnN0YXJ0RnJhbWVzW2ldPSgob3B0LmZyYW1lcy8yKS8ob2JqLmNvb3Jkcy5sZW5ndGgtMSkpKmk7b3B0LmNvdW50ZXJzW2ldPTA7dGhpcy5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywwKTtpZih0aGlzLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZSl7dGhpcy5zdmcuYWxsLnJlbW92ZUNoaWxkKHRoaXMuY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdKTt0aGlzLnN2Zy5hbGwucmVtb3ZlQ2hpbGQodGhpcy5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMV0pO3RoaXMuc3ZnLmFsbC5yZW1vdmVDaGlsZCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdKTt0aGlzLnN2Zy5hbGwucmVtb3ZlQ2hpbGQodGhpcy5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXSk7fX1cbmZ1bmN0aW9uIGl0ZXJhdG9yKClcbnsrK2ZyYW1lO2Zvcih2YXIgaT0wLGxlbj1vYmouY29vcmRzLmxlbmd0aDtpPGxlbjtpKz0xKXtpZihmcmFtZT5vcHQuc3RhcnRGcmFtZXNbaV0pe3ZhciBvcmlnaW5hbEhlaWdodD1vYmouY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JyksaGVpZ2h0LHZhbHVlPXBhcnNlRmxvYXQob2JqLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykpO3ZhciBoZWlnaHQ9bWEubWluKCgoZnJhbWUtb3B0LnN0YXJ0RnJhbWVzW2ldKS9mcmFtZXNwZXJiYXIpKm9yaWdpbmFsSGVpZ2h0LG9yaWdpbmFsSGVpZ2h0KTtvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0PDA/MDpoZWlnaHQpO29iai5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgneScsdmFsdWU+PTA/b2JqLmdldFlDb29yZCgwKS1oZWlnaHQ6b2JqLmdldFlDb29yZCgwKSk7aWYocHJvcC52YXJpYW50PT09JzNkJyl7aWYob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVswXS5wYXJlbnROb2RlKW9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdKTtpZihvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzFdLnBhcmVudE5vZGUpb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMV0pO2lmKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlKW9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXSk7aWYob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUpb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdKTtpZihvYmouY29vcmRzW2ldLm9iamVjdC5wYXJlbnROb2RlKXt2YXIgcGFyZW50PW9iai5jb29yZHNbaV0ub2JqZWN0LnBhcmVudE5vZGU7dmFyIG5vZGU9cGFyZW50LnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0KTtwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7fX1cbmlmKHByb3AuZ3JvdXBpbmc9PT0nc3RhY2tlZCcpe3ZhciBzZXE9b2JqLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnKTt2YXIgaW5kZXhlcz1SRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNlcSxvYmouZGF0YSk7aWYoaW5kZXhlc1sxXT4wKXtvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3knLHBhcnNlSW50KG9iai5jb29yZHNbaS0xXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpLWhlaWdodCk7fX1cbmlmKHByb3AudmFyaWFudD09PSczZCcpe29iai5kcmF3U2lkZTNkRmFjZSh7cmVjdDpvYmouY29vcmRzW2ldLm9iamVjdH0pO2lmKHByb3AuZ3JvdXBpbmc9PT0nZ3JvdXBlZCd8fChwcm9wLmdyb3VwaW5nPT09J3N0YWNrZWQnJiYoaW5kZXhlc1sxXSsxKT09PW9iai5kYXRhW2luZGV4ZXNbMF1dLmxlbmd0aCkpe29iai5kcmF3VG9wM2RGYWNlKHtyZWN0Om9iai5jb29yZHNbaV0ub2JqZWN0fSk7fX19fVxuaWYoZnJhbWU+PW9wdC5mcmFtZXMpe2NhbGxiYWNrKG9iaik7fWVsc2V7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtmb3IoaSBpbiBjb25mLm9wdGlvbnMpe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3RoaXMuc2V0KGksY29uZi5vcHRpb25zW2ldKTt9fX07cmV0dXJuIHRoaXM7fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuYmFyLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///234\n");

/***/ }),
/* 235 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.AJAX = RGraph.SVG.AJAX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.SVG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.SVG.AJAX.getNumber = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.SVG.AJAX.getString = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.SVG.AJAX.getJSON = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.SVG.AJAX.getCSV = function (url, callback) {\n    var seperator = typeof arguments[2] === 'string' ? arguments[2] : ',',\n        lineSep = typeof arguments[3] === 'string' ? arguments[3] : \"\\r?\\n\";RG.SVG.AJAX(url, function () {\n      var text = this.responseText,\n          regexp = new RegExp(seperator),\n          lines = this.responseText.split(lineSep),\n          rows = [];for (var i = 0; i < lines.length; ++i) {\n        var row = lines[i].split(seperator);for (var j = 0, len = row.length; j < len; ++j) {\n          if (row[j].match(/^[0-9.]+$/)) {\n            row[j] = parseFloat(row[j]);\n          }\n        }\n        rows.push(row);\n      }\n      callback(rows);\n    });\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5hamF4LmpzPzU3NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWUsaXNSR3JhcGhTVkc6dHJ1ZX07UkdyYXBoLlNWRz1SR3JhcGguU1ZHfHx7fTtSR3JhcGguU1ZHLkFKQVg9UkdyYXBoLlNWRy5BSkFYfHx7fTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57dmFyIFJHPVJHcmFwaCx1YT1uYXZpZ2F0b3IudXNlckFnZW50LG1hPU1hdGg7UkcuU1ZHLkFKQVg9ZnVuY3Rpb24odXJsLGNhbGxiYWNrKVxue2lmKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCl7dmFyIGh0dHBSZXF1ZXN0PW5ldyBYTUxIdHRwUmVxdWVzdCgpO31lbHNlIGlmKHdpbmRvdy5BY3RpdmVYT2JqZWN0KXt2YXIgaHR0cFJlcXVlc3Q9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTt9XG5odHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKVxue2lmKHRoaXMucmVhZHlTdGF0ZT09NCYmdGhpcy5zdGF0dXM9PTIwMCl7dGhpcy5fX3VzZXJfY2FsbGJhY2tfXz1jYWxsYmFjazt0aGlzLl9fdXNlcl9jYWxsYmFja19fKHRoaXMucmVzcG9uc2VUZXh0KTt9fVxuaHR0cFJlcXVlc3Qub3BlbignR0VUJyx1cmwsdHJ1ZSk7aHR0cFJlcXVlc3Quc2VuZCgpO307UkcuU1ZHLkFKQVguUE9TVD1mdW5jdGlvbih1cmwsZGF0YSxjYWxsYmFjaylcbnt2YXIgY3J1bWJzPVtdO2lmKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCl7dmFyIGh0dHBSZXF1ZXN0PW5ldyBYTUxIdHRwUmVxdWVzdCgpO31lbHNlIGlmKHdpbmRvdy5BY3RpdmVYT2JqZWN0KXt2YXIgaHR0cFJlcXVlc3Q9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTt9XG5odHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKVxue2lmKHRoaXMucmVhZHlTdGF0ZT09NCYmdGhpcy5zdGF0dXM9PTIwMCl7dGhpcy5fX3VzZXJfY2FsbGJhY2tfXz1jYWxsYmFjazt0aGlzLl9fdXNlcl9jYWxsYmFja19fKHRoaXMucmVzcG9uc2VUZXh0KTt9fVxuaHR0cFJlcXVlc3Qub3BlbignUE9TVCcsdXJsLHRydWUpO2h0dHBSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtmb3IoaSBpbiBkYXRhKXtpZih0eXBlb2YgaT09J3N0cmluZycpe2NydW1icy5wdXNoKGkrJz0nK2VuY29kZVVSSUNvbXBvbmVudChkYXRhW2ldKSk7fX1cbmh0dHBSZXF1ZXN0LnNlbmQoY3J1bWJzLmpvaW4oJyYnKSk7fTtSRy5TVkcuQUpBWC5nZXROdW1iZXI9ZnVuY3Rpb24odXJsLGNhbGxiYWNrKVxue1JHLlNWRy5BSkFYKHVybCxmdW5jdGlvbigpXG57dmFyIG51bT1wYXJzZUZsb2F0KHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhudW0pO30pO307UkcuU1ZHLkFKQVguZ2V0U3RyaW5nPWZ1bmN0aW9uKHVybCxjYWxsYmFjaylcbntSRy5TVkcuQUpBWCh1cmwsZnVuY3Rpb24oKVxue3ZhciBzdHI9U3RyaW5nKHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhzdHIpO30pO307UkcuU1ZHLkFKQVguZ2V0SlNPTj1mdW5jdGlvbih1cmwsY2FsbGJhY2spXG57UkcuU1ZHLkFKQVgodXJsLGZ1bmN0aW9uKClcbnt2YXIganNvbj1ldmFsKCcoJyt0aGlzLnJlc3BvbnNlVGV4dCsnKScpO2NhbGxiYWNrKGpzb24pO30pO307UkcuU1ZHLkFKQVguZ2V0Q1NWPWZ1bmN0aW9uKHVybCxjYWxsYmFjaylcbnt2YXIgc2VwZXJhdG9yPSh0eXBlb2YgYXJndW1lbnRzWzJdPT09J3N0cmluZyc/YXJndW1lbnRzWzJdOicsJyksbGluZVNlcD0odHlwZW9mIGFyZ3VtZW50c1szXT09PSdzdHJpbmcnP2FyZ3VtZW50c1szXTpcIlxccj9cXG5cIik7UkcuU1ZHLkFKQVgodXJsLGZ1bmN0aW9uKClcbnt2YXIgdGV4dD10aGlzLnJlc3BvbnNlVGV4dCxyZWdleHA9bmV3IFJlZ0V4cChzZXBlcmF0b3IpLGxpbmVzPXRoaXMucmVzcG9uc2VUZXh0LnNwbGl0KGxpbmVTZXApLHJvd3M9W107Zm9yKHZhciBpPTA7aTxsaW5lcy5sZW5ndGg7KytpKXt2YXIgcm93PWxpbmVzW2ldLnNwbGl0KHNlcGVyYXRvcik7Zm9yKHZhciBqPTAsbGVuPXJvdy5sZW5ndGg7ajxsZW47KytqKXtpZihyb3dbal0ubWF0Y2goL15bMC05Ll0rJC8pKXtyb3dbal09cGFyc2VGbG9hdChyb3dbal0pO319XG5yb3dzLnB1c2gocm93KTt9XG5jYWxsYmFjayhyb3dzKTt9KTt9O30pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5hamF4LmpzIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///235\n");

/***/ }),
/* 236 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.REG = { store: [] };RG.SVG.OR = { objects: [] };RG.SVG.TRIG = {};RG.SVG.TRIG.HALFPI = ma.PI * .4999;RG.SVG.TRIG.PI = RG.SVG.TRIG.HALFPI * 2;RG.SVG.TRIG.TWOPI = RG.SVG.TRIG.PI * 2;RG.SVG.ISIE = ua.indexOf('rident') > 0;RG.SVG.ISFF = ua.indexOf('irefox') > 0;RG.SVG.events = [];RG.SVG.ISFF = ua.indexOf('Firefox') != -1;RG.SVG.ISOPERA = ua.indexOf('Opera') != -1;RG.SVG.ISCHROME = ua.indexOf('Chrome') != -1;RG.SVG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.SVG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.SVG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.SVG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.SVG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.SVG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.SVG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.SVG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.SVG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.SVG.ISIE10UP = RG.SVG.ISIE10 || RG.SVG.ISIE11UP;RG.SVG.ISIE9UP = RG.SVG.ISIE9 || RG.SVG.ISIE10UP;RG.SVG.createSVG = function (opt) {\n    var container = opt.container;if (container.__svg__) {\n      return container.__svg__;\n    }\n    var svg = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");svg.setAttribute('style', 'top: 0; left: 0; position: absolute');svg.setAttribute('width', container.offsetWidth);svg.setAttribute('height', container.offsetHeight);svg.setAttribute('version', '1.1');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", 'xmlns', 'http://www.w3.org/2000/svg');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");container.appendChild(svg);container.__svg__ = svg;container.style.position = 'relative';var group = RG.SVG.create({ svg: svg, type: 'g', attr: { className: 'all-elements' } });container.__svg__.all = group;return svg;\n  };RG.SVG.createDefs = function (obj) {\n    if (!obj.svg.defs) {\n      var defs = RG.SVG.create({ svg: obj.svg, type: 'defs' });obj.svg.defs = defs;\n    }\n    return defs;\n  };RG.SVG.create = function (opt) {\n    var ns = \"http://www.w3.org/2000/svg\",\n        tag = doc.createElementNS(ns, opt.type);for (var o in opt.attr) {\n      if (typeof o === 'string') {\n        var name = o;if (o === 'className') {\n          name = 'class';\n        }\n        if ((opt.type === 'a' || opt.type === 'image') && o === 'xlink:href') {\n          tag.setAttributeNS('http://www.w3.org/1999/xlink', o, String(opt.attr[o]));\n        } else {\n          tag.setAttribute(name, String(opt.attr[o]));\n        }\n      }\n    }\n    for (var o in opt.style) {\n      if (typeof o === 'string') {\n        tag.style[o] = String(opt.style[o]);\n      }\n    }\n    if (opt.parent) {\n      opt.parent.appendChild(tag);\n    } else {\n      opt.svg.appendChild(tag);\n    }\n    return tag;\n  };RG.SVG.drawXAxis = function (obj) {\n    var prop = obj.properties;if (prop.xaxis) {\n      var y = obj.type === 'hbar' ? obj.height - prop.gutterBottom : obj.getYCoord(obj.scale.min < 0 && obj.scale.max < 0 ? obj.scale.max : obj.scale.min > 0 && obj.scale.max > 0 ? obj.scale.min : 0);var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft, y + 0.01, obj.width - prop.gutterRight, y), fill: prop.xaxisColor, stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': 'crispEdges', 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.height - prop.gutterBottom,\n            endY = obj.height - prop.gutterBottom + prop.xaxisTickmarksLength;\n      } else {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.getYCoord(0) - (prop.yaxisMin < 0 ? prop.xaxisTickmarksLength : 0),\n            endY = obj.getYCoord(0) + prop.xaxisTickmarksLength;if (obj.scale.min < 0 && obj.scale.max <= 0) {\n          startY = prop.gutterTop;endY = prop.gutterTop - prop.xaxisTickmarksLength;\n        }\n        if (obj.scale.min > 0 && obj.scale.max > 0) {\n          startY = obj.getYCoord(obj.scale.min);endY = obj.getYCoord(obj.scale.min) + prop.xaxisTickmarksLength;\n        }\n      }\n      if (prop.xaxisTickmarks) {\n        if (prop.xaxisScale) {\n          for (var i = 0; i < obj.scale.numlabels + (prop.yaxis && prop.xaxisMin === 0 ? 0 : 1); ++i) {\n            if (obj.type === 'hbar') {\n              var dataPoints = obj.data.length;\n            }\n            x = prop.gutterLeft + (i + (prop.yaxis && prop.xaxisMin === 0 ? 1 : 0)) * (obj.graphWidth / obj.scale.numlabels);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        } else {\n          if (prop.xaxisLabelsPosition === 'section') {\n            if (obj.type === 'bar' || obj.type === 'waterfall') {\n              var dataPoints = obj.data.length;\n            } else if (obj.type === 'line') {\n              var dataPoints = obj.data[0].length;\n            } else if (obj.type === 'scatter') {\n              var dataPoints = prop.xaxisLabels ? prop.xaxisLabels.length : 10;\n            }\n            for (var i = 0; i < dataPoints; ++i) {\n              x = prop.gutterLeft + (i + 1) * (obj.graphWidth / dataPoints);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          } else if (prop.xaxisLabelsPosition === 'edge') {\n            if (typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number') {\n              var len = prop.xaxisLabelsPositionEdgeTickmarksCount;\n            } else {\n              var len = obj.data && obj.data[0] && obj.data[0].length ? obj.data[0].length : 0;\n            }\n            for (var i = 0; i < len; ++i) {\n              var gap = obj.graphWidth / (len - 1),\n                  x = prop.gutterLeft + (i + 1) * gap;RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          }\n        }\n        if (prop.yaxis === false) {\n          RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft + 0.001, startY, prop.gutterLeft, endY), stroke: obj.properties.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", parent: obj.svg.all } });\n        }\n      }\n    }\n    if (prop.xaxisScale) {\n      var segment = obj.graphWidth / prop.xaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var x = prop.gutterLeft + segment * i + segment + prop.xaxisLabelsOffsetx;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: x, y: obj.height - prop.gutterBottom + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n      if (prop.xaxisLabelsCount > 0) {\n        var y = obj.height - prop.gutterBottom + prop.xaxisLabelsOffsety + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10),\n            str = RG.SVG.numberFormat({ object: obj, num: prop.xaxisMin.toFixed(prop.xaxisDecimals), prepend: prop.xaxisUnitsPre, append: prop.xaxisUnitsPost, point: prop.xaxisPoint, thousand: prop.xaxisThousand, formatter: prop.xaxisFormatter });var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.xaxisFormatter === 'function' ? prop.xaxisFormatter(this, prop.xaxisMin) : str, x: prop.gutterLeft + prop.xaxisLabelsOffsetx, y: y, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n    } else {\n      if (_typeof(prop.xaxisLabels) === 'object' && !RG.SVG.isNull(prop.xaxisLabels)) {\n        if (prop.xaxisLabelsPosition === 'section') {\n          var segment = (obj.width - prop.gutterLeft - prop.gutterRight) / prop.xaxisLabels.length;for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + segment / 2 + i * segment;if (obj.scale.max <= 0 && obj.scale.min < obj.scale.max) {\n              var y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'bottom';\n            } else {\n              var y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'top';\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        } else if (prop.xaxisLabelsPosition === 'edge') {\n          if (obj.type === 'line') {\n            var hmargin = prop.hmargin;\n          } else {\n            var hmargin = 0;\n          }\n          var segment = (obj.graphWidth - hmargin - hmargin) / (prop.xaxisLabels.length - 1);for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + i * segment + hmargin;if (obj.scale.max <= 0 && obj.scale.min < 0) {\n              valign = 'bottom';y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisTickmarksLength - 5) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            } else {\n              valign = 'top';y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisTickmarksLength - 5) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        }\n      }\n    }\n  };RG.SVG.drawYAxis = function (obj) {\n    var prop = obj.properties;if (prop.yaxis) {\n      if (obj.type === 'hbar') {\n        var x = obj.getXCoord(prop.xaxisMin > 0 ? prop.xaxisMin : 0);if (prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          x = obj.getXCoord(prop.xaxisMax);\n        }\n      } else {\n        var x = prop.gutterLeft;\n      }\n      var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x, prop.gutterTop, x + 0.001, obj.height - prop.gutterBottom), stroke: prop.yaxisColor, fill: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var height = (obj.graphHeight - prop.vmarginTop - prop.vmarginBottom) / prop.yaxisLabels.length,\n            y = prop.gutterTop + prop.vmarginTop,\n            len = prop.yaxisLabels.length,\n            startX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0),\n            endX = obj.getXCoord(0) - prop.yaxisTickmarksLength;if (obj.type === 'hbar' && prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          startX = obj.getXCoord(prop.xaxisMax);endX = obj.getXCoord(prop.xaxisMax) + 5;\n        }\n        if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if (prop.xaxis === false) {\n            if (obj.type === 'hbar' && prop.xaxisMin <= 0 && prop.xaxisMax < 0) {\n              var startX = obj.getXCoord(prop.xaxisMax);var endX = obj.getXCoord(prop.xaxisMax) + prop.yaxisTickmarksLength;\n            } else {\n              var startX = obj.getXCoord(0) - prop.yaxisTickmarksLength;var endX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0);\n            }\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom), endX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom) - 0.001), stroke: obj.properties.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      } else {\n        var height = obj.graphHeight / prop.yaxisLabelsCount,\n            y = prop.gutterTop,\n            len = prop.yaxisLabelsCount,\n            startX = prop.gutterLeft,\n            endX = prop.gutterLeft - prop.yaxisTickmarksLength;if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if ((prop.yaxisMin !== 0 || prop.xaxis === false) && !(obj.scale.min > 0 && obj.scale.max > 0)) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft - prop.yaxisTickmarksLength, obj.height - prop.gutterBottom, prop.gutterLeft, obj.height - prop.gutterBottom - 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      }\n    }\n    if (prop.yaxisScale) {\n      var segment = (obj.height - prop.gutterTop - prop.gutterBottom) / prop.yaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var y = obj.height - prop.gutterBottom - segment * i - segment;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n      var y = obj.height - prop.gutterBottom,\n          str = prop.yaxisUnitsPre + prop.yaxisMin.toFixed(prop.yaxisDecimals).replace(/\\./, prop.yaxisPoint) + prop.yaxisUnitsPost;var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.yaxisFormatter === 'function' ? prop.yaxisFormatter(this, prop.yaxisMin) : str, x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n    } else if (prop.yaxisLabels && prop.yaxisLabels.length) {\n      for (var i = 0; i < prop.yaxisLabels.length; ++i) {\n        var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length,\n            y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsety,\n            x = prop.gutterLeft - 7 - (prop.yaxisLinewidth || 1) + prop.yaxisLabelsOffsetx,\n            halign = 'right';if (obj.type === 'hbar' && obj.scale.min < obj.scale.max && obj.scale.max <= 0) {\n          halign = 'left';x = obj.width - prop.gutterRight + 7 + prop.yaxisLabelsOffsetx;\n        } else if (obj.type === 'hbar' && !prop.yaxisLabelsSpecific) {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length;y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsetx;\n        } else {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / (prop.yaxisLabels.length - 1);y = obj.height - prop.gutterBottom - segment * i + prop.yaxisLabelsOffsetx;\n        }\n        var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.yaxisLabels[i] ? prop.yaxisLabels[i] : '', x: x, y: y, halign: halign, valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n    }\n  };RG.SVG.drawBackground = function (obj) {\n    var prop = obj.properties;if (typeof prop.variant3dOffsetx !== 'number') prop.variant3dOffsetx = 0;if (typeof prop.variant3dOffsety !== 'number') prop.variant3dOffsety = 0;if (prop.backgroundColor) {\n      RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'rect', attr: { x: -1 + prop.variant3dOffsetx, y: -1 - prop.variant3dOffsety, width: parseFloat(obj.svg.getAttribute('width')) + 2, height: parseFloat(obj.svg.getAttribute('height')) + 2, fill: prop.backgroundColor } });\n    }\n    if (prop.backgroundImage) {\n      var attr = { 'xlink:href': prop.backgroundImage, preserveAspectRatio: prop.backgroundImageAspect || 'none', x: prop.gutterLeft, y: prop.gutterTop };if (prop.backgroundImageStretch) {\n        attr.x = prop.gutterLeft + prop.variant3dOffsetx;attr.y = prop.gutterTop + prop.variant3dOffsety;attr.width = obj.width - prop.gutterLeft - prop.gutterRight;attr.height = obj.height - prop.gutterTop - prop.gutterBottom;\n      } else {\n        if (typeof prop.backgroundImageX === 'number') {\n          attr.x = prop.backgroundImageX + prop.variant3dOffsetx;\n        }\n        if (typeof prop.backgroundImageY === 'number') {\n          attr.y = prop.backgroundImageY + prop.variant3dOffsety;\n        }\n        if (typeof prop.backgroundImageW === 'number') {\n          attr.width = prop.backgroundImageW;\n        }\n        if (typeof prop.backgroundImageH === 'number') {\n          attr.height = prop.backgroundImageH;\n        }\n      }\n      if (prop.variant === '3d') {\n        attr.x += prop.variant3dOffsetx;attr.y -= prop.variant3dOffsety;\n      }\n      var img = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'image', attr: attr, style: { opacity: typeof prop.backgroundImageOpacity === 'number' ? prop.backgroundImageOpacity : 1 } });\n    }\n    if (prop.backgroundGrid) {\n      var parts = [];if (prop.backgroundGridHlines) {\n        var count = typeof prop.backgroundGridHlinesCount === 'number' ? prop.backgroundGridHlinesCount : obj.type === 'hbar' ? prop.yaxisLabels.length || obj.data.length || 5 : prop.yaxisLabelsCount;for (var i = 0; i < count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety));\n        }\n        parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      if (prop.backgroundGridVlines) {\n        if (obj.type === 'line' && RG.SVG.isArray(obj.data[0])) {\n          var len = obj.data[0].length;\n        } else if (obj.type === 'hbar') {\n          var len = prop.xaxisLabelsCount || 10;\n        } else if (obj.type === 'scatter') {\n          var len = prop.xaxisLabels && prop.xaxisLabels.length || 10;\n        } else {\n          var len = obj.data.length;\n        }\n        var count = typeof prop.backgroundGridVlinesCount === 'number' ? prop.backgroundGridVlinesCount : len;if (prop.xaxisLabelsPosition === 'edge') {\n          count--;\n        }\n        for (var i = 0; i <= count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n        }\n      }\n      if (prop.backgroundGridBorder) {\n        parts.push('M{1} {2} L{3} {4} L{5} {6} L{7} {8} z'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      var grid = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: parts.join(' '), stroke: prop.backgroundGridColor, fill: 'rgba(0,0,0,0)', 'stroke-width': prop.backgroundGridLinewidth, 'shape-rendering': \"crispEdges\" } });\n    }\n    RG.SVG.drawTitle(obj);\n  };RG.SVG.isNull = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.SVG.getScale = function (opt) {\n    var obj = opt.object,\n        prop = obj.properties,\n        numlabels = opt.numlabels,\n        unitsPre = opt.unitsPre,\n        unitsPost = opt.unitsPost,\n        max = Number(opt.max),\n        min = Number(opt.min),\n        strict = opt.strict,\n        decimals = Number(opt.decimals),\n        point = opt.point,\n        thousand = opt.thousand,\n        originalMax = max,\n        round = opt.round,\n        scale = { max: 1, labels: [], values: [] },\n        formatter = opt.formatter;if (max === 0 && min === 0) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = ((max - min) / numlabels * (i + 1) + min).toFixed(decimals);scale.labels.push(unitsPre + label + unitsPost);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.SVG.numberFormat({ object: obj, num: value, prepend: unitsPre, append: unitsPost, point: prop.yaxisPoint, thousand: prop.yaxisThousand, formatter: formatter }));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(originalMax) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(originalMax) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;for (var i = 0; i < numlabels; ++i) {\n        var label = RG.SVG.numberFormat({ object: obj, num: ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand, formatter: formatter });scale.labels.push(label);scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n    } else if (typeof max === 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.SVG.numberFormat({ object: obj, formatter: formatter, num: ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand }));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.unitsPre = unitsPre;scale.unitsPost = unitsPost;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.SVG.arrayFill = RG.SVG.arrayPad = function (opt) {\n    var arr = opt.array,\n        len = opt.length,\n        value = opt.value ? opt.value : null;if (arr.length < len) {\n      for (var i = arr.length; i < len; i += 1) {\n        arr[i] = value;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayMax = function (arr) {\n    var max = null;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.SVG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.SVG.arrayPad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayLinearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.SVG.arrayLinearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.SVG.arrayShift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.SVG.arrayReverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.SVG.arrayClone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    if (RG.SVG.isArray(obj)) {\n      var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n        if (typeof obj[i] === 'number') {\n          temp[i] = function (arg) {\n            return Number(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'string') {\n          temp[i] = function (arg) {\n            return String(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'function') {\n          temp[i] = obj[i];\n        } else {\n          temp[i] = RG.SVG.arrayClone(obj[i]);\n        }\n      }\n    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {\n      var temp = {};for (var i in obj) {\n        if (typeof i === 'string') {\n          temp[i] = obj[i];\n        }\n      }\n    }\n    return temp;\n  };RG.SVG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.SVG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.SVG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.SVG.arrayReverse(out2);return out2;\n  };RG.SVG.isArray = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.SVG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.SVG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.SVG.numberFormat = function (opt) {\n    var obj = opt.object,\n        prepend = opt.prepend ? String(opt.prepend) : '',\n        append = opt.append ? String(opt.append) : '',\n        output = '',\n        decimal_seperator = typeof opt.point === 'string' ? opt.point : '.',\n        thousand_seperator = typeof opt.thousand === 'string' ? opt.thousand : ',',\n        num = opt.num;RegExp.$1 = '';if (typeof opt.formatter === 'function') {\n      return opt.formatter(obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    } else {\n      decimal = '';\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + thousand_seperator) == 0) {\n      output = '-' + output.substr(('-' + thousand_seperator).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.SVG.text = function (opt) {\n    var obj = opt.object,\n        parent = opt.parent || opt.object.svg.all,\n        size = opt.size,\n        bold = opt.bold,\n        font = opt.font,\n        italic = opt.italic,\n        halign = opt.halign,\n        valign = opt.valign,\n        str = opt.text,\n        x = opt.x,\n        y = opt.y,\n        color = opt.color ? opt.color : 'black',\n        background = opt.background || null,\n        padding = opt.padding || 0;if (halign === 'right') {\n      halign = 'end';\n    } else if (halign === 'center' || halign === 'middle') {\n      halign = 'middle';\n    } else {\n      halign = 'start';\n    }\n    if (valign === 'top') {\n      valign = 'hanging';\n    } else if (valign === 'center' || valign === 'middle') {\n      valign = 'central';valign = 'middle';\n    } else {\n      valign = 'bottom';\n    }\n    var text = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'text', attr: { fill: color, x: x, y: y, 'font-size': typeof size === 'number' ? size + 'pt' : size, 'font-weight': bold ? 900 : 100, 'font-family': font ? font : 'sans-serif', 'font-style': italic ? 'italic' : 'normal', 'text-anchor': halign, 'dominant-baseline': valign } });var textNode = document.createTextNode(str);text.appendChild(textNode);if (typeof background === 'string') {\n      var bbox = text.getBBox(),\n          rect = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'rect', attr: { x: bbox.x - padding, y: bbox.y - padding, width: bbox.width + padding * 2, height: bbox.height + padding * 2, fill: background } });parent.insertBefore(rect, text);\n    }\n    if (RG.SVG.ISIE && valign === 'hanging') {\n      text.setAttribute('y', y + text.scrollHeight / 2);\n    } else if (RG.SVG.ISIE && valign === 'middle') {\n      text.setAttribute('y', y + text.scrollHeight / 3);\n    }\n    if (RG.SVG.ISFF) {\n      Y = y + text.scrollHeight / 3;\n    }\n    return text;\n  };RG.SVG.createUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.SVG.isFixed = function (svg) {\n    var obj = svg.parentNode,\n        i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position === 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.SVG.REG.set = function (name, value) {\n    RG.SVG.REG.store[name] = value;return value;\n  };RG.SVG.REG.get = function (name) {\n    return RG.SVG.REG.store[name];\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.hideTooltip = function () {\n    var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.parentNode) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.SVG.REG.set('tooltip', null);\n    }\n    if (tooltip && tooltip.__object__) {\n      RG.SVG.removeHighlight(tooltip.__object__);\n    }\n  };RG.SVG.setShadow = function (options) {\n    var obj = options.object,\n        offsetx = options.offsetx || 0,\n        offsety = options.offsety || 0,\n        blur = options.blur || 0,\n        opacity = options.opacity || 0,\n        id = options.id;var filter = RG.SVG.create({ svg: obj.svg, parent: obj.svg.defs, type: 'filter', attr: { id: id, width: \"130%\", height: \"130%\" } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feOffset', attr: { result: 'offOut', 'in': 'SourceGraphic', dx: offsetx, dy: offsety } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feColorMatrix', attr: { result: 'matrixOut', 'in': 'offOut', type: 'matrix', values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 {1} 0'.format(opacity) } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feGaussianBlur', attr: { result: 'blurOut', 'in': 'matrixOut', stdDeviation: blur } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feBlend', attr: { 'in': 'SourceGraphic', 'in2': 'blurOut', mode: 'normal' } });\n  };RG.SVG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0,\n        grouped_index = 0;while (--index >= 0) {\n      if (RG.SVG.isNull(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.SVG.TRIG.toCartesian = function (options) {\n    return { x: options.cx + options.r * ma.cos(options.angle), y: options.cy + options.r * ma.sin(options.angle) };\n  };RG.SVG.TRIG.getArcPath = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = options.end - options.start;var largeArc = '0';var sweep = '0';if (options.anticlockwise && diff > 3.14) {\n      largeArc = '0';sweep = '0';\n    } else if (options.anticlockwise && diff <= 3.14) {\n      largeArc = '1';sweep = '0';\n    } else if (!options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    } else if (!options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '1';\n    }\n    if (options.start > options.end && options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '0';\n    }\n    if (options.start > options.end && options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    }\n    if (typeof options.moveto === 'boolean' && options.moveto === false) {\n      var d = [\"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath2 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", options.cx, options.cy, \"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath3 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getRadiusEndPoint = function (opt) {\n    if (arguments.length === 1) {\n      var angle = opt.angle,\n          r = opt.r;\n    } else if (arguments.length === 4) {\n      var angle = arguments[0],\n          r = arguments[1];\n    }\n    var x = ma.cos(angle) * r,\n        y = ma.sin(angle) * r;return [x, y];\n  };RG.SVG.drawTitle = function (obj) {\n    var prop = obj.properties;var valign = 'bottom';if (obj.type === 'pie') {\n      if (RG.SVG.isNull(prop.titleX)) {\n        prop.titleX = obj.centerx;prop.titleSubtitleX = obj.centerx;\n      }\n      if (RG.SVG.isNull(prop.titleY)) {\n        prop.titleY = obj.centery - obj.radius - 10;\n      }\n    }\n    if (obj.scale && obj.scale.max <= 0 && obj.scale.min < 0 && typeof prop.titleY !== 'number' && obj.type !== 'hbar') {\n      prop.titleY = obj.height - prop.gutterBottom + 10;var positionBottom = true;valign = 'top';\n    } else if (typeof prop.titleY !== 'number') {\n      var positionBottom = false;prop.titleY = prop.gutterTop - 10;valign = 'bottom';if (!RG.SVG.isNull(prop.key)) {\n        prop.titleY -= 2 * (prop.keyTextSize || prop.textSize);\n      }\n    }\n    if (prop.titleSubtitle && typeof prop.titleSubtitleY !== 'number' && !positionBottom) {\n      prop.titleY = prop.titleY - prop.titleSubtitleSize * 1.5;\n    }\n    prop.titleSubTitleSize = prop.titleSubTitleSize || prop.textSize;prop.titleSubtitleY = prop.titleSubtitleY || prop.titleY + 18;if (positionBottom && typeof prop.titleSubtitleY !== 'number') {\n      prop.titleSubtitleY = prop.titleY + 26;\n    }\n    if (prop.title) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.title.toString(), size: prop.titleSize || prop.textSize + 4 || 16, x: typeof prop.titleX === 'number' ? prop.titleX + (prop.variant3dOffsetx || 0) : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleY + (prop.variant3dOffsety || 0), halign: prop.titleHalign || 'center', valign: prop.titleValign || valign, color: prop.titleColor || prop.textColor || 'black', bold: prop.titleBold || false, italic: prop.titleItalic || false, font: prop.titleFont || prop.textFont || 'Arial' });\n    }\n    if (prop.titleSubtitle) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.titleSubtitle, size: prop.titleSubtitleSize, x: typeof prop.titleSubtitleX === 'number' ? prop.titleSubtitleX : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleSubtitleY + (prop.variant3dOffsety || 0), halign: prop.titleSubtitleHalign || 'center', valign: prop.titleSubtitleValign || valign, color: prop.titleSubtitleColor || prop.textColor || '#aaa', bold: prop.titleSubtitleBold || false, italic: prop.titleSubtitleItalic || false, font: prop.titleSubtitleFont || prop.textFont || 'Arial' });\n    }\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return String(str).replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return String(str).replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.parseColorLinear = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);if (opt && opt.direction && opt.direction === 'horizontal') {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: opt.start || 0, x2: opt.end || '100%', y1: 0, y2: 0, gradientUnits: \"userSpaceOnUse\" } });\n      } else {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: 0, x2: 0, y1: opt.start || 0, y2: opt.end || '100%', gradientUnits: \"userSpaceOnUse\" } });\n      }\n      var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-linear-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.parseColorRadial = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);var grad = RG.SVG.create({ type: 'radialGradient', parent: obj.svg.defs, attr: { id: 'RGraph-radial-gradient' + obj.gradientCounter, gradientUnits: opt.gradientUnits || 'userSpaceOnUse', cx: opt.cx || obj.centerx, cy: opt.cy || obj.centery, fx: opt.fx || obj.centerx, fy: opt.fy || obj.centery, r: opt.r || obj.radius } });var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-radial-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.resetColorsToOriginalValues = function (opt) {\n    var obj = opt.object;if (obj.originalColors) {\n      for (var j in obj.originalColors) {\n        if (typeof j === 'string') {\n          obj.properties[j] = RG.SVG.arrayClone(obj.originalColors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.originalColors = {};obj.colorsParsed = false;obj.gradientCounter = 1;\n  };RG.SVG.clear = function (svg) {\n    while (svg.all.lastChild) {\n      svg.all.removeChild(svg.all.lastChild);\n    }\n  };RG.SVG.addCustomEventListener = function (obj, name, func) {\n    if (typeof RG.SVG.events[obj.uid] === 'undefined') {\n      RG.SVG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.SVG.events[obj.uid].push({ object: obj, event: name, func: func });return RG.SVG.events[obj.uid].length - 1;\n  };RG.SVG.fireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[uid]) === 'object' && RG.SVG.events[uid].length > 0) {\n        for (var j = 0, len = RG.SVG.events[uid].length; j < len; ++j) {\n          if (RG.SVG.events[uid][j] && RG.SVG.events[uid][j].event === name) {\n            RG.SVG.events[uid][j].func(obj);\n          }\n        }\n      }\n    }\n  };RG.SVG.removeAllCustomEventListeners = function () {\n    var uid = arguments[0];if (uid && RG.SVG.events[uid]) {\n      RG.SVG.events[uid] = {};\n    } else {\n      RG.SVG.events = [];\n    }\n  };RG.SVG.removeCustomEventListener = function (obj, i) {\n    if (_typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[obj.uid]) === 'object' && _typeof(RG.SVG.events[obj.uid][i]) === 'object') {\n      RG.SVG.events[obj.uid][i] = null;\n    }\n  };RG.SVG.removeHighlight = function (obj) {\n    var highlight = RG.SVG.REG.get('highlight');if (highlight && RG.SVG.isArray(highlight) && highlight.length) {\n      for (var i = 0, len = highlight.length; i < len; ++i) {\n        if (highlight[i].parentNode) {\n          highlight[i].parentNode.removeChild(highlight[i]);\n        }\n      }\n    } else if (highlight && highlight.parentNode) {\n      if (obj.type === 'scatter') {\n        highlight.setAttribute('fill', 'transparent');\n      } else {\n        highlight.parentNode.removeChild(highlight);\n      }\n    }\n  };RG.SVG.redraw = function () {\n    if (arguments.length === 1) {\n      var svg = arguments[0];RG.SVG.clear(svg);var objects = RG.SVG.OR.get('id:' + svg.parentNode.id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.SVG.resetColorsToOriginalValues({ object: objects[i] });objects[i].draw();\n      }\n    } else {\n      var tags = RG.SVG.OR.tags();for (var i in tags) {\n        RG.SVG.redraw(tags[i]);\n      }\n    }\n  };RG.SVG.parseDate = function (str) {\n    var d = new Date();var defaults = { seconds: '00', minutes: '00', hours: '00', date: d.getDate(), month: d.getMonth() + 1, year: d.getFullYear() };var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'],\n        months_regex = months.join('|');for (var i = 0; i < months.length; ++i) {\n      months[months[i]] = i;months[months[i].substring(0, 3)] = i;months_regex = months_regex + '|' + months[i].substring(0, 3);\n    }\n    var sep = '[-./_=+~#:;,]+';var tokens = str.split(/ +/);for (var i = 0, len = tokens.length; i < len; ++i) {\n      if (tokens[i]) {\n        if (tokens[i].match(/^\\d\\d\\d\\d$/)) {\n          defaults.year = tokens[i];\n        }\n        var res = isMonth(tokens[i]);if (typeof res === 'number') {\n          defaults.month = res + 1;\n        }\n        if (tokens[i].match(/^\\d?\\d(?:st|nd|rd|th)?$/)) {\n          defaults.date = parseInt(tokens[i]);\n        }\n        if (tokens[i].match(/^(\\d\\d):(\\d\\d)(?:(\\d\\d))?$/)) {\n          defaults.hours = parseInt(RegExp.$1);defaults.minutes = parseInt(RegExp.$2);if (RegExp.$3) {\n            defaults.seconds = parseInt(RegExp.$3);\n          }\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$3);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$1);\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$1);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$3);\n        }\n      }\n    }\n    str = '{1}/{2}/{3} {4}:{5}:{6}'.format(defaults.year, String(defaults.month).length === 1 ? '0' + defaults.month : defaults.month, String(defaults.date).length === 1 ? '0' + defaults.date : defaults.date, String(defaults.hours).length === 1 ? '0' + defaults.hours : defaults.hours, String(defaults.minutes).length === 1 ? '0' + defaults.minutes : defaults.minutes, String(defaults.seconds).length === 1 ? '0' + defaults.seconds : defaults.seconds);return Date.parse(str);function isMonth(str) {\n      var res = str.toLowerCase().match(months_regex);return res ? months[res[0]] : false;\n    }\n  };RG.SVG.OR.add = function (obj) {\n    RG.SVG.OR.objects.push(obj);return obj;\n  };RG.SVG.OR.get = function () {\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'id:') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].id === arguments[0].substr(3)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 4).toLowerCase() === 'type') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].type === arguments[0].substr(5)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'uid') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].uid === arguments[0].substr(4)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    return RG.SVG.OR.objects;\n  };RG.SVG.OR.tags = function () {\n    var tags = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n      if (!tags[RG.SVG.OR.objects[i].svg.parentNode.id]) {\n        tags[RG.SVG.OR.objects[i].svg.parentNode.id] = RG.SVG.OR.objects[i].svg;\n      }\n    }\n    return tags;\n  };RG.SVG.getSVGXY = function (svg) {\n    var x = 0,\n        y = 0,\n        el = svg.parentNode;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.SVG.ISCHROME || RG.SVG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName && el.tagName.toLowerCase() != 'body');var paddingLeft = svg.style.paddingLeft ? parseInt(svg.style.paddingLeft) : 0,\n        paddingTop = svg.style.paddingTop ? parseInt(svg.style.paddingTop) : 0,\n        borderLeft = svg.style.borderLeftWidth ? parseInt(svg.style.borderLeftWidth) : 0,\n        borderTop = svg.style.borderTopWidth ? parseInt(svg.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.SVG.FX.update = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.SVG.FX.getEasingMultiplier = function (frames, frame) {\n    var multiplier = ma.pow(ma.sin(frame / frames * RG.SVG.TRIG.HALFPI), 3);return multiplier;\n  };RG.SVG.measureText = function (opt) {\n    var text = opt.text || '',\n        bold = opt.bold || false,\n        font = opt.font || 'Arial',\n        size = opt.size || 10,\n        str = text + ':' + bold + ':' + font + ':' + size;if (typeof RG.SVG.measuretext_cache === 'undefined') {\n      RG.SVG.measuretext_cache = [];\n    }\n    if (_typeof(RG.SVG.measuretext_cache) == 'object' && RG.SVG.measuretext_cache[str]) {\n      return RG.SVG.measuretext_cache[str];\n    }\n    if (!RG.SVG.measuretext_cache['text-span']) {\n      var span = document.createElement('SPAN');span.style.position = 'absolute';span.style.padding = 0;span.style.display = 'inline';span.style.top = '-200px';span.style.left = '-200px';span.style.lineHeight = '1em';document.body.appendChild(span);RG.SVG.measuretext_cache['text-span'] = span;\n    } else if (RG.SVG.measuretext_cache['text-span']) {\n      var span = RG.SVG.measuretext_cache['text-span'];\n    }\n    span.innerHTML = text.replace(/\\r\\n/g, '<br />');span.style.fontFamily = font;span.style.fontWeight = bold ? 'bold' : 'normal';span.style.fontSize = size + 'pt';var sizes = [span.offsetWidth, span.offsetHeight];RG.SVG.measuretext_cache[str] = sizes;return sizes;\n  };RG.SVG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.SVG.getAdjustedNumber = function (opt) {\n    var value = opt.value,\n        prop = opt.prop;if (typeof prop === 'string' && match(/^(\\+|-)([0-9.]+)/)) {\n      if (RegExp.$1 === '+') {\n        value += parseFloat(RegExp.$2);\n      } else if (RegExp.$1 === '-') {\n        value -= parseFloat(RegExp.$2);\n      }\n    }\n    return value;\n  };RG.SVG.attribution = function (obj) {\n    return;\n  };RG.SVG.parseGradient = function (str) {};RG.SVG.random = function (opt) {\n    var min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0,\n        r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.SVG.arrayRand = RG.SVG.arrayRandom = RG.SVG.random.array = function (opt) {\n    var num = opt.num,\n        min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0;for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.SVG.random({ min: min, max: max, dp: dp }));\n    }\n    return arr;\n  };RG.SVG.commonSetter = function (opt) {\n    var obj = opt.object,\n        name = opt.name,\n        value = opt.value;if (name === 'tooltipsEvent' && value !== 'click' && value !== 'mousemove') {\n      value = 'click';\n    }\n    return { name: name, value: value };\n  };RG.SVG.log = function (opt) {\n    var num = opt.num,\n        base = opt.base;return ma.log(num) / (base ? ma.log(base) : 1);\n  };RG.SVG.donut = function (opt) {\n    var arcPath1 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.outerRadius, start: 0, end: RG.SVG.TRIG.TWOPI, anticlockwise: false, lineto: false });var arcPath2 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.innerRadius, start: RG.SVG.TRIG.TWOPI, end: 0, anticlockwise: true, lineto: false });var path = RG.SVG.create({ svg: opt.svg, type: 'path', attr: { d: arcPath1 + arcPath2, stroke: opt.stroke, fill: opt.fill } });return path;\n  };if (typeof RG.SVG.tooltip !== 'function') {\n    RG.SVG.tooltip = function () {\n      $a('The tooltip library has not been included!');\n    };\n  }\n})(window, document);window.$p = function (obj) {\n  var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n    return '';\n  }\n  switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n      str += 'function () {}';break;case 'undefined':\n      str += 'undefined';break;case 'null':\n      str += 'null';break;case 'object':\n      if (RGraph.SVG.isNull(obj)) {\n        str += indent + 'null\\n';\n      } else {\n        str += indent + 'Object {' + '\\n';\n        for (j in obj) {\n          str += indent + '    ' + j + ' => ' + window.$p(obj[j], true, indent + '    ', counter + 1) + '\\n';\n        }\n        str += indent + '}';\n      }\n      break;default:\n      str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n  if (!arguments[1]) {\n    alert(str);\n  }\n  return str;\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5jb3JlLmpzPzY4NzIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWUsaXNSR3JhcGhTVkc6dHJ1ZX07UkdyYXBoLlNWRz1SR3JhcGguU1ZHfHx7fTtSR3JhcGguU1ZHLkZYPVJHcmFwaC5TVkcuRlh8fHt9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aDtSRy5TVkcuUkVHPXtzdG9yZTpbXX07UkcuU1ZHLk9SPXtvYmplY3RzOltdfTtSRy5TVkcuVFJJRz17fTtSRy5TVkcuVFJJRy5IQUxGUEk9bWEuUEkqLjQ5OTk7UkcuU1ZHLlRSSUcuUEk9UkcuU1ZHLlRSSUcuSEFMRlBJKjI7UkcuU1ZHLlRSSUcuVFdPUEk9UkcuU1ZHLlRSSUcuUEkqMjtSRy5TVkcuSVNJRT11YS5pbmRleE9mKCdyaWRlbnQnKT4wO1JHLlNWRy5JU0ZGPXVhLmluZGV4T2YoJ2lyZWZveCcpPjA7UkcuU1ZHLmV2ZW50cz1bXTtSRy5TVkcuSVNGRj11YS5pbmRleE9mKCdGaXJlZm94JykhPS0xO1JHLlNWRy5JU09QRVJBPXVhLmluZGV4T2YoJ09wZXJhJykhPS0xO1JHLlNWRy5JU0NIUk9NRT11YS5pbmRleE9mKCdDaHJvbWUnKSE9LTE7UkcuU1ZHLklTU0FGQVJJPXVhLmluZGV4T2YoJ1NhZmFyaScpIT0tMSYmIVJHLklTQ0hST01FO1JHLlNWRy5JU1dFQktJVD11YS5pbmRleE9mKCdXZWJLaXQnKSE9LTE7UkcuU1ZHLklTSUU9dWEuaW5kZXhPZignVHJpZGVudCcpPjB8fG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpPjA7UkcuU1ZHLklTSUU2PXVhLmluZGV4T2YoJ01TSUUgNicpPjA7UkcuU1ZHLklTSUU3PXVhLmluZGV4T2YoJ01TSUUgNycpPjA7UkcuU1ZHLklTSUU4PXVhLmluZGV4T2YoJ01TSUUgOCcpPjA7UkcuU1ZHLklTSUU5PXVhLmluZGV4T2YoJ01TSUUgOScpPjA7UkcuU1ZHLklTSUUxMD11YS5pbmRleE9mKCdNU0lFIDEwJyk+MDtSRy5TVkcuSVNJRTExVVA9dWEuaW5kZXhPZignTVNJRScpPT0tMSYmdWEuaW5kZXhPZignVHJpZGVudCcpPjA7UkcuU1ZHLklTSUUxMFVQPVJHLlNWRy5JU0lFMTB8fFJHLlNWRy5JU0lFMTFVUDtSRy5TVkcuSVNJRTlVUD1SRy5TVkcuSVNJRTl8fFJHLlNWRy5JU0lFMTBVUDtSRy5TVkcuY3JlYXRlU1ZHPWZ1bmN0aW9uKG9wdClcbnt2YXIgY29udGFpbmVyPW9wdC5jb250YWluZXI7aWYoY29udGFpbmVyLl9fc3ZnX18pe3JldHVybiBjb250YWluZXIuX19zdmdfXzt9XG52YXIgc3ZnPWRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwic3ZnXCIpO3N2Zy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywndG9wOiAwOyBsZWZ0OiAwOyBwb3NpdGlvbjogYWJzb2x1dGUnKTtzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsY29udGFpbmVyLm9mZnNldFdpZHRoKTtzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGNvbnRhaW5lci5vZmZzZXRIZWlnaHQpO3N2Zy5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCcxLjEnKTtzdmcuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiLCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7c3ZnLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIixcInhtbG5zOnhsaW5rXCIsXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIpO2NvbnRhaW5lci5hcHBlbmRDaGlsZChzdmcpO2NvbnRhaW5lci5fX3N2Z19fPXN2Zztjb250YWluZXIuc3R5bGUucG9zaXRpb249J3JlbGF0aXZlJzt2YXIgZ3JvdXA9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnN2Zyx0eXBlOidnJyxhdHRyOntjbGFzc05hbWU6J2FsbC1lbGVtZW50cyd9fSk7Y29udGFpbmVyLl9fc3ZnX18uYWxsPWdyb3VwO3JldHVybiBzdmc7fTtSRy5TVkcuY3JlYXRlRGVmcz1mdW5jdGlvbihvYmopXG57aWYoIW9iai5zdmcuZGVmcyl7dmFyIGRlZnM9UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcsdHlwZTonZGVmcyd9KTtvYmouc3ZnLmRlZnM9ZGVmczt9XG5yZXR1cm4gZGVmczt9O1JHLlNWRy5jcmVhdGU9ZnVuY3Rpb24ob3B0KVxue3ZhciBucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdGFnPWRvYy5jcmVhdGVFbGVtZW50TlMobnMsb3B0LnR5cGUpO2Zvcih2YXIgbyBpbiBvcHQuYXR0cil7aWYodHlwZW9mIG89PT0nc3RyaW5nJyl7dmFyIG5hbWU9bztpZihvPT09J2NsYXNzTmFtZScpe25hbWU9J2NsYXNzJzt9XG5pZigob3B0LnR5cGU9PT0nYSd8fG9wdC50eXBlPT09J2ltYWdlJykmJm89PT0neGxpbms6aHJlZicpe3RhZy5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsbyxTdHJpbmcob3B0LmF0dHJbb10pKTt9ZWxzZXt0YWcuc2V0QXR0cmlidXRlKG5hbWUsU3RyaW5nKG9wdC5hdHRyW29dKSk7fX19XG5mb3IodmFyIG8gaW4gb3B0LnN0eWxlKXtpZih0eXBlb2Ygbz09PSdzdHJpbmcnKXt0YWcuc3R5bGVbb109U3RyaW5nKG9wdC5zdHlsZVtvXSk7fX1cbmlmKG9wdC5wYXJlbnQpe29wdC5wYXJlbnQuYXBwZW5kQ2hpbGQodGFnKTt9ZWxzZXtvcHQuc3ZnLmFwcGVuZENoaWxkKHRhZyk7fVxucmV0dXJuIHRhZzt9O1JHLlNWRy5kcmF3WEF4aXM9ZnVuY3Rpb24ob2JqKVxue3ZhciBwcm9wPW9iai5wcm9wZXJ0aWVzO2lmKHByb3AueGF4aXMpe3ZhciB5PW9iai50eXBlPT09J2hiYXInP29iai5oZWlnaHQtcHJvcC5ndXR0ZXJCb3R0b206b2JqLmdldFlDb29yZChvYmouc2NhbGUubWluPDAmJm9iai5zY2FsZS5tYXg8MD9vYmouc2NhbGUubWF4OihvYmouc2NhbGUubWluPjAmJm9iai5zY2FsZS5tYXg+MD9vYmouc2NhbGUubWluOjApKTt2YXIgYXhpcz1SRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDonTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQseSswLjAxLG9iai53aWR0aC1wcm9wLmd1dHRlclJpZ2h0LHkpLGZpbGw6cHJvcC54YXhpc0NvbG9yLHN0cm9rZTpwcm9wLnhheGlzQ29sb3IsJ3N0cm9rZS13aWR0aCc6dHlwZW9mIHByb3AueGF4aXNMaW5ld2lkdGg9PT0nbnVtYmVyJz9wcm9wLnhheGlzTGluZXdpZHRoOjEsJ3NoYXBlLXJlbmRlcmluZyc6J2NyaXNwRWRnZXMnLCdzdHJva2UtbGluZWNhcCc6J3NxdWFyZSd9fSk7aWYob2JqLnR5cGU9PT0naGJhcicpe3ZhciB3aWR0aD1vYmouZ3JhcGhXaWR0aC9vYmouZGF0YS5sZW5ndGgseD1wcm9wLmd1dHRlckxlZnQsc3RhcnRZPShvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tKSxlbmRZPShvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tKStwcm9wLnhheGlzVGlja21hcmtzTGVuZ3RoO31lbHNle3ZhciB3aWR0aD1vYmouZ3JhcGhXaWR0aC9vYmouZGF0YS5sZW5ndGgseD1wcm9wLmd1dHRlckxlZnQsc3RhcnRZPW9iai5nZXRZQ29vcmQoMCktKHByb3AueWF4aXNNaW48MD9wcm9wLnhheGlzVGlja21hcmtzTGVuZ3RoOjApLGVuZFk9b2JqLmdldFlDb29yZCgwKStwcm9wLnhheGlzVGlja21hcmtzTGVuZ3RoO2lmKG9iai5zY2FsZS5taW48MCYmb2JqLnNjYWxlLm1heDw9MCl7c3RhcnRZPXByb3AuZ3V0dGVyVG9wO2VuZFk9cHJvcC5ndXR0ZXJUb3AtcHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aDt9XG5pZihvYmouc2NhbGUubWluPjAmJm9iai5zY2FsZS5tYXg+MCl7c3RhcnRZPW9iai5nZXRZQ29vcmQob2JqLnNjYWxlLm1pbik7ZW5kWT1vYmouZ2V0WUNvb3JkKG9iai5zY2FsZS5taW4pK3Byb3AueGF4aXNUaWNrbWFya3NMZW5ndGg7fX1cbmlmKHByb3AueGF4aXNUaWNrbWFya3Mpe2lmKHByb3AueGF4aXNTY2FsZSl7Zm9yKHZhciBpPTA7aTwob2JqLnNjYWxlLm51bWxhYmVscysocHJvcC55YXhpcyYmcHJvcC54YXhpc01pbj09PTA/MDoxKSk7KytpKXtpZihvYmoudHlwZT09PSdoYmFyJyl7dmFyIGRhdGFQb2ludHM9b2JqLmRhdGEubGVuZ3RoO31cbng9cHJvcC5ndXR0ZXJMZWZ0KygoaSsocHJvcC55YXhpcyYmcHJvcC54YXhpc01pbj09PTA/MTowKSkqKG9iai5ncmFwaFdpZHRoL29iai5zY2FsZS5udW1sYWJlbHMpKTtSRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDonTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdCh4KzAuMDAxLHN0YXJ0WSx4LGVuZFkpLHN0cm9rZTpwcm9wLnhheGlzQ29sb3IsJ3N0cm9rZS13aWR0aCc6dHlwZW9mIHByb3AueGF4aXNMaW5ld2lkdGg9PT0nbnVtYmVyJz9wcm9wLnhheGlzTGluZXdpZHRoOjEsJ3NoYXBlLXJlbmRlcmluZyc6XCJjcmlzcEVkZ2VzXCJ9fSk7fX1lbHNle2lmKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbj09PSdzZWN0aW9uJyl7aWYob2JqLnR5cGU9PT0nYmFyJ3x8b2JqLnR5cGU9PT0nd2F0ZXJmYWxsJyl7dmFyIGRhdGFQb2ludHM9b2JqLmRhdGEubGVuZ3RoO31lbHNlIGlmKG9iai50eXBlPT09J2xpbmUnKXt2YXIgZGF0YVBvaW50cz1vYmouZGF0YVswXS5sZW5ndGg7fWVsc2UgaWYob2JqLnR5cGU9PT0nc2NhdHRlcicpe3ZhciBkYXRhUG9pbnRzPXByb3AueGF4aXNMYWJlbHM/cHJvcC54YXhpc0xhYmVscy5sZW5ndGg6MTA7fVxuZm9yKHZhciBpPTA7aTxkYXRhUG9pbnRzOysraSl7eD1wcm9wLmd1dHRlckxlZnQrKChpKzEpKihvYmouZ3JhcGhXaWR0aC9kYXRhUG9pbnRzKSk7UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9iai5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6J017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoeCswLjAwMSxzdGFydFkseCxlbmRZKSxzdHJva2U6cHJvcC54YXhpc0NvbG9yLCdzdHJva2Utd2lkdGgnOnR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoPT09J251bWJlcic/cHJvcC54YXhpc0xpbmV3aWR0aDoxLCdzaGFwZS1yZW5kZXJpbmcnOlwiY3Jpc3BFZGdlc1wifX0pO319ZWxzZSBpZihwcm9wLnhheGlzTGFiZWxzUG9zaXRpb249PT0nZWRnZScpe2lmKHR5cGVvZiBwcm9wLnhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ9PT0nbnVtYmVyJyl7dmFyIGxlbj1wcm9wLnhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ7fWVsc2V7dmFyIGxlbj1vYmouZGF0YSYmb2JqLmRhdGFbMF0mJm9iai5kYXRhWzBdLmxlbmd0aD9vYmouZGF0YVswXS5sZW5ndGg6MDt9XG5mb3IodmFyIGk9MDtpPGxlbjsrK2kpe3ZhciBnYXA9KChvYmouZ3JhcGhXaWR0aCkvKGxlbi0xKSkseD1wcm9wLmd1dHRlckxlZnQrKChpKzEpKmdhcCk7UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9iai5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6J017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoeCswLjAwMSxzdGFydFkseCxlbmRZKSxzdHJva2U6cHJvcC54YXhpc0NvbG9yLCdzdHJva2Utd2lkdGgnOnR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoPT09J251bWJlcic/cHJvcC54YXhpc0xpbmV3aWR0aDoxLCdzaGFwZS1yZW5kZXJpbmcnOlwiY3Jpc3BFZGdlc1wifX0pO319fVxuaWYocHJvcC55YXhpcz09PWZhbHNlKXtSRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDonTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQrMC4wMDEsc3RhcnRZLHByb3AuZ3V0dGVyTGVmdCxlbmRZKSxzdHJva2U6b2JqLnByb3BlcnRpZXMueGF4aXNDb2xvciwnc3Ryb2tlLXdpZHRoJzp0eXBlb2YgcHJvcC54YXhpc0xpbmV3aWR0aD09PSdudW1iZXInP3Byb3AueGF4aXNMaW5ld2lkdGg6MSwnc2hhcGUtcmVuZGVyaW5nJzpcImNyaXNwRWRnZXNcIixwYXJlbnQ6b2JqLnN2Zy5hbGwsfX0pO319fVxuaWYocHJvcC54YXhpc1NjYWxlKXt2YXIgc2VnbWVudD1vYmouZ3JhcGhXaWR0aC9wcm9wLnhheGlzTGFiZWxzQ291bnQ7Zm9yKHZhciBpPTA7aTxvYmouc2NhbGUubGFiZWxzLmxlbmd0aDsrK2kpe3ZhciB4PXByb3AuZ3V0dGVyTGVmdCsoc2VnbWVudCppKStzZWdtZW50K3Byb3AueGF4aXNMYWJlbHNPZmZzZXR4O1JHLlNWRy50ZXh0KHtvYmplY3Q6b2JqLHBhcmVudDpvYmouc3ZnLmFsbCx0ZXh0Om9iai5zY2FsZS5sYWJlbHNbaV0seDp4LHk6KG9iai5oZWlnaHQtcHJvcC5ndXR0ZXJCb3R0b20pKyhwcm9wLnhheGlzP3Byb3AueGF4aXNUaWNrbWFya3NMZW5ndGgrNjoxMCkrKHByb3AueGF4aXNMaW5ld2lkdGh8fDEpK3Byb3AueGF4aXNMYWJlbHNPZmZzZXR5LGhhbGlnbjonY2VudGVyJyx2YWxpZ246J3RvcCcsZm9udDpwcm9wLnhheGlzVGV4dEZvbnR8fHByb3AudGV4dEZvbnQsc2l6ZTpwcm9wLnhheGlzVGV4dFNpemV8fCh0eXBlb2YgcHJvcC50ZXh0U2l6ZT09PSdudW1iZXInP3Byb3AudGV4dFNpemUrJ3B0Jzpwcm9wLnRleHRTaXplKSxib2xkOnByb3AueGF4aXNUZXh0Qm9sZHx8cHJvcC50ZXh0Qm9sZCxpdGFsaWM6cHJvcC54YXhpc1RleHRJdGFsaWN8fHByb3AudGV4dEl0YWxpYyxjb2xvcjpwcm9wLnhheGlzVGV4dENvbG9yfHxwcm9wLnRleHRDb2xvcn0pO31cbmlmKHByb3AueGF4aXNMYWJlbHNDb3VudD4wKXt2YXIgeT1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tK3Byb3AueGF4aXNMYWJlbHNPZmZzZXR5Kyhwcm9wLnhheGlzP3Byb3AueGF4aXNUaWNrbWFya3NMZW5ndGgrNjoxMCksc3RyPVJHLlNWRy5udW1iZXJGb3JtYXQoe29iamVjdDpvYmosbnVtOnByb3AueGF4aXNNaW4udG9GaXhlZChwcm9wLnhheGlzRGVjaW1hbHMpLHByZXBlbmQ6cHJvcC54YXhpc1VuaXRzUHJlLGFwcGVuZDpwcm9wLnhheGlzVW5pdHNQb3N0LHBvaW50OnByb3AueGF4aXNQb2ludCx0aG91c2FuZDpwcm9wLnhheGlzVGhvdXNhbmQsZm9ybWF0dGVyOnByb3AueGF4aXNGb3JtYXR0ZXJ9KTt2YXIgdGV4dD1SRy5TVkcudGV4dCh7b2JqZWN0Om9iaixwYXJlbnQ6b2JqLnN2Zy5hbGwsdGV4dDp0eXBlb2YgcHJvcC54YXhpc0Zvcm1hdHRlcj09PSdmdW5jdGlvbic/KHByb3AueGF4aXNGb3JtYXR0ZXIpKHRoaXMscHJvcC54YXhpc01pbik6c3RyLHg6cHJvcC5ndXR0ZXJMZWZ0K3Byb3AueGF4aXNMYWJlbHNPZmZzZXR4LHk6eSxoYWxpZ246J2NlbnRlcicsdmFsaWduOid0b3AnLGZvbnQ6cHJvcC54YXhpc1RleHRGb250fHxwcm9wLnRleHRGb250LHNpemU6cHJvcC54YXhpc1RleHRTaXplfHwodHlwZW9mIHByb3AudGV4dFNpemU9PT0nbnVtYmVyJz9wcm9wLnRleHRTaXplKydwdCc6cHJvcC50ZXh0U2l6ZSksYm9sZDpwcm9wLnhheGlzVGV4dEJvbGR8fHByb3AudGV4dEJvbGQsaXRhbGljOnByb3AueGF4aXNUZXh0SXRhbGljfHxwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC54YXhpc1RleHRDb2xvcnx8cHJvcC50ZXh0Q29sb3J9KTt9fWVsc2V7aWYodHlwZW9mIHByb3AueGF4aXNMYWJlbHM9PT0nb2JqZWN0JyYmIVJHLlNWRy5pc051bGwocHJvcC54YXhpc0xhYmVscykpe2lmKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbj09PSdzZWN0aW9uJyl7dmFyIHNlZ21lbnQ9KG9iai53aWR0aC1wcm9wLmd1dHRlckxlZnQtcHJvcC5ndXR0ZXJSaWdodCkvcHJvcC54YXhpc0xhYmVscy5sZW5ndGg7Zm9yKHZhciBpPTA7aTxwcm9wLnhheGlzTGFiZWxzLmxlbmd0aDsrK2kpe3ZhciB4PXByb3AuZ3V0dGVyTGVmdCsoc2VnbWVudC8yKSsoaSpzZWdtZW50KTtpZihvYmouc2NhbGUubWF4PD0wJiZvYmouc2NhbGUubWluPG9iai5zY2FsZS5tYXgpe3ZhciB5PXByb3AuZ3V0dGVyVG9wLShSRy5TVkcuSVNGRj81OjEwKS0ocHJvcC54YXhpc0xpbmV3aWR0aHx8MSkrcHJvcC54YXhpc0xhYmVsc09mZnNldHk7dmFyIHZhbGlnbj0nYm90dG9tJzt9ZWxzZXt2YXIgeT1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tKyhSRy5TVkcuSVNGRj81OjEwKSsocHJvcC54YXhpc0xpbmV3aWR0aHx8MSkrcHJvcC54YXhpc0xhYmVsc09mZnNldHk7dmFyIHZhbGlnbj0ndG9wJzt9XG5SRy5TVkcudGV4dCh7b2JqZWN0Om9iaixwYXJlbnQ6b2JqLnN2Zy5hbGwsdGV4dDpwcm9wLnhheGlzTGFiZWxzW2ldLHg6eCtwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eCx5OnksdmFsaWduOnZhbGlnbixoYWxpZ246J2NlbnRlcicsc2l6ZTpwcm9wLnhheGlzVGV4dFNpemV8fHByb3AudGV4dFNpemUsaXRhbGljOnByb3AueGF4aXNUZXh0SXRhbGljfHxwcm9wLnRleHRJdGFsaWMsZm9udDpwcm9wLnhheGlzVGV4dEZvbnR8fHByb3AudGV4dEZvbnQsYm9sZDpwcm9wLnhheGlzVGV4dEJvbGR8fHByb3AudGV4dEJvbGQsY29sb3I6cHJvcC54YXhpc1RleHRDb2xvcnx8cHJvcC50ZXh0Q29sb3J9KTt9fWVsc2UgaWYocHJvcC54YXhpc0xhYmVsc1Bvc2l0aW9uPT09J2VkZ2UnKXtpZihvYmoudHlwZT09PSdsaW5lJyl7dmFyIGhtYXJnaW49cHJvcC5obWFyZ2luO31lbHNle3ZhciBobWFyZ2luPTA7fVxudmFyIHNlZ21lbnQ9KG9iai5ncmFwaFdpZHRoLWhtYXJnaW4taG1hcmdpbikvKHByb3AueGF4aXNMYWJlbHMubGVuZ3RoLTEpO2Zvcih2YXIgaT0wO2k8cHJvcC54YXhpc0xhYmVscy5sZW5ndGg7KytpKXt2YXIgeD1wcm9wLmd1dHRlckxlZnQrKGkqc2VnbWVudCkraG1hcmdpbjtpZihvYmouc2NhbGUubWF4PD0wJiZvYmouc2NhbGUubWluPDApe3ZhbGlnbj0nYm90dG9tJzt5PXByb3AuZ3V0dGVyVG9wLShSRy5TVkcuSVNGRj81OjEwKS0ocHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aC01KS0ocHJvcC54YXhpc0xpbmV3aWR0aHx8MSkrcHJvcC54YXhpc0xhYmVsc09mZnNldHl9ZWxzZXt2YWxpZ249J3RvcCc7eT1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tKyhSRy5TVkcuSVNGRj81OjEwKSsocHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aC01KSsocHJvcC54YXhpc0xpbmV3aWR0aHx8MSkrcHJvcC54YXhpc0xhYmVsc09mZnNldHk7fVxuUkcuU1ZHLnRleHQoe29iamVjdDpvYmoscGFyZW50Om9iai5zdmcuYWxsLHRleHQ6cHJvcC54YXhpc0xhYmVsc1tpXSx4OngrcHJvcC54YXhpc0xhYmVsc09mZnNldHgseTp5LHZhbGlnbjp2YWxpZ24saGFsaWduOidjZW50ZXInLHNpemU6cHJvcC54YXhpc1RleHRTaXplfHxwcm9wLnRleHRTaXplLGl0YWxpYzpwcm9wLnhheGlzVGV4dEl0YWxpY3x8cHJvcC50ZXh0SXRhbGljLGZvbnQ6cHJvcC54YXhpc1RleHRGb250fHxwcm9wLnRleHRGb250LGJvbGQ6cHJvcC54YXhpc1RleHRCb2xkfHxwcm9wLnRleHRCb2xkLGNvbG9yOnByb3AueGF4aXNUZXh0Q29sb3J8fHByb3AudGV4dENvbG9yfSk7fX19fX07UkcuU1ZHLmRyYXdZQXhpcz1mdW5jdGlvbihvYmopXG57dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYocHJvcC55YXhpcyl7aWYob2JqLnR5cGU9PT0naGJhcicpe3ZhciB4PW9iai5nZXRYQ29vcmQocHJvcC54YXhpc01pbj4wP3Byb3AueGF4aXNNaW46MCk7aWYocHJvcC54YXhpc01pbjwwJiZwcm9wLnhheGlzTWF4PD0wKXt4PW9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCk7fX1lbHNle3ZhciB4PXByb3AuZ3V0dGVyTGVmdDt9XG52YXIgYXhpcz1SRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDonTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdCh4LHByb3AuZ3V0dGVyVG9wLHgrMC4wMDEsb2JqLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbSksc3Ryb2tlOnByb3AueWF4aXNDb2xvcixmaWxsOnByb3AueWF4aXNDb2xvciwnc3Ryb2tlLXdpZHRoJzp0eXBlb2YgcHJvcC55YXhpc0xpbmV3aWR0aD09PSdudW1iZXInP3Byb3AueWF4aXNMaW5ld2lkdGg6MSwnc2hhcGUtcmVuZGVyaW5nJzpcImNyaXNwRWRnZXNcIiwnc3Ryb2tlLWxpbmVjYXAnOidzcXVhcmUnfX0pO2lmKG9iai50eXBlPT09J2hiYXInKXt2YXIgaGVpZ2h0PShvYmouZ3JhcGhIZWlnaHQtcHJvcC52bWFyZ2luVG9wLXByb3Audm1hcmdpbkJvdHRvbSkvcHJvcC55YXhpc0xhYmVscy5sZW5ndGgseT1wcm9wLmd1dHRlclRvcCtwcm9wLnZtYXJnaW5Ub3AsbGVuPXByb3AueWF4aXNMYWJlbHMubGVuZ3RoLHN0YXJ0WD1vYmouZ2V0WENvb3JkKDApKyhwcm9wLnhheGlzTWluPDA/cHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aDowKSxlbmRYPW9iai5nZXRYQ29vcmQoMCktcHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aDtpZihvYmoudHlwZT09PSdoYmFyJyYmcHJvcC54YXhpc01pbjwwJiZwcm9wLnhheGlzTWF4PD0wKXtzdGFydFg9b2JqLmdldFhDb29yZChwcm9wLnhheGlzTWF4KTtlbmRYPW9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCkrNTt9XG5pZihwcm9wLnlheGlzVGlja21hcmtzKXtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe3ZhciBheGlzPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOidNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHN0YXJ0WCx5LGVuZFgseSswLjAwMSksc3Ryb2tlOnByb3AueWF4aXNDb2xvciwnc3Ryb2tlLXdpZHRoJzp0eXBlb2YgcHJvcC55YXhpc0xpbmV3aWR0aD09PSdudW1iZXInP3Byb3AueWF4aXNMaW5ld2lkdGg6MSwnc2hhcGUtcmVuZGVyaW5nJzpcImNyaXNwRWRnZXNcIn19KTt5Kz1oZWlnaHQ7fVxuaWYocHJvcC54YXhpcz09PWZhbHNlKXtpZihvYmoudHlwZT09PSdoYmFyJyYmcHJvcC54YXhpc01pbjw9MCYmcHJvcC54YXhpc01heDwwKXt2YXIgc3RhcnRYPW9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCk7dmFyIGVuZFg9b2JqLmdldFhDb29yZChwcm9wLnhheGlzTWF4KStwcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoO31lbHNle3ZhciBzdGFydFg9b2JqLmdldFhDb29yZCgwKS1wcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoO3ZhciBlbmRYPW9iai5nZXRYQ29vcmQoMCkrKHByb3AueGF4aXNNaW48MD9wcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoOjApO31cbnZhciBheGlzPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOidNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHN0YXJ0WCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLXBhcnNlRmxvYXQocHJvcC52bWFyZ2luQm90dG9tKSxlbmRYLG9iai5oZWlnaHQtcHJvcC5ndXR0ZXJCb3R0b20tcGFyc2VGbG9hdChwcm9wLnZtYXJnaW5Cb3R0b20pLTAuMDAxKSxzdHJva2U6b2JqLnByb3BlcnRpZXMueWF4aXNDb2xvciwnc3Ryb2tlLXdpZHRoJzp0eXBlb2YgcHJvcC55YXhpc0xpbmV3aWR0aD09PSdudW1iZXInP3Byb3AueWF4aXNMaW5ld2lkdGg6MSwnc2hhcGUtcmVuZGVyaW5nJzpcImNyaXNwRWRnZXNcIn19KTt9fX1lbHNle3ZhciBoZWlnaHQ9b2JqLmdyYXBoSGVpZ2h0L3Byb3AueWF4aXNMYWJlbHNDb3VudCx5PXByb3AuZ3V0dGVyVG9wLGxlbj1wcm9wLnlheGlzTGFiZWxzQ291bnQsc3RhcnRYPXByb3AuZ3V0dGVyTGVmdCxlbmRYPXByb3AuZ3V0dGVyTGVmdC1wcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoO2lmKHByb3AueWF4aXNUaWNrbWFya3Mpe2Zvcih2YXIgaT0wO2k8bGVuOysraSl7dmFyIGF4aXM9UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9iai5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6J017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoc3RhcnRYLHksZW5kWCx5KzAuMDAxKSxzdHJva2U6cHJvcC55YXhpc0NvbG9yLCdzdHJva2Utd2lkdGgnOnR5cGVvZiBwcm9wLnlheGlzTGluZXdpZHRoPT09J251bWJlcic/cHJvcC55YXhpc0xpbmV3aWR0aDoxLCdzaGFwZS1yZW5kZXJpbmcnOlwiY3Jpc3BFZGdlc1wifX0pO3krPWhlaWdodDt9XG5pZigocHJvcC55YXhpc01pbiE9PTB8fHByb3AueGF4aXM9PT1mYWxzZSkmJiEob2JqLnNjYWxlLm1pbj4wJiZvYmouc2NhbGUubWF4PjApKXt2YXIgYXhpcz1SRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDonTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQtcHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLHByb3AuZ3V0dGVyTGVmdCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLTAuMDAxKSxzdHJva2U6cHJvcC55YXhpc0NvbG9yLCdzdHJva2Utd2lkdGgnOnR5cGVvZiBwcm9wLnlheGlzTGluZXdpZHRoPT09J251bWJlcic/cHJvcC55YXhpc0xpbmV3aWR0aDoxLCdzaGFwZS1yZW5kZXJpbmcnOlwiY3Jpc3BFZGdlc1wifX0pO319fX1cbmlmKHByb3AueWF4aXNTY2FsZSl7dmFyIHNlZ21lbnQ9KG9iai5oZWlnaHQtcHJvcC5ndXR0ZXJUb3AtcHJvcC5ndXR0ZXJCb3R0b20pL3Byb3AueWF4aXNMYWJlbHNDb3VudDtmb3IodmFyIGk9MDtpPG9iai5zY2FsZS5sYWJlbHMubGVuZ3RoOysraSl7dmFyIHk9b2JqLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS0oc2VnbWVudCppKS1zZWdtZW50O1JHLlNWRy50ZXh0KHtvYmplY3Q6b2JqLHBhcmVudDpvYmouc3ZnLmFsbCx0ZXh0Om9iai5zY2FsZS5sYWJlbHNbaV0seDpwcm9wLmd1dHRlckxlZnQtNy0ocHJvcC55YXhpcz8ocHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aC0zKTowKStwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eCx5OnkrcHJvcC55YXhpc0xhYmVsc09mZnNldHksaGFsaWduOidyaWdodCcsdmFsaWduOidjZW50ZXInLGZvbnQ6cHJvcC55YXhpc1RleHRGb250fHxwcm9wLnRleHRGb250LHNpemU6cHJvcC55YXhpc1RleHRTaXplfHwodHlwZW9mIHByb3AudGV4dFNpemU9PT0nbnVtYmVyJz9wcm9wLnRleHRTaXplKydwdCc6cHJvcC50ZXh0U2l6ZSksYm9sZDpwcm9wLnlheGlzVGV4dEJvbGR8fHByb3AudGV4dEJvbGQsaXRhbGljOnByb3AueWF4aXNUZXh0SXRhbGljfHxwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC55YXhpc1RleHRDb2xvcnx8cHJvcC50ZXh0Q29sb3J9KTt9XG52YXIgeT1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLHN0cj0ocHJvcC55YXhpc1VuaXRzUHJlK3Byb3AueWF4aXNNaW4udG9GaXhlZChwcm9wLnlheGlzRGVjaW1hbHMpLnJlcGxhY2UoL1xcLi8scHJvcC55YXhpc1BvaW50KStwcm9wLnlheGlzVW5pdHNQb3N0KTt2YXIgdGV4dD1SRy5TVkcudGV4dCh7b2JqZWN0Om9iaixwYXJlbnQ6b2JqLnN2Zy5hbGwsdGV4dDp0eXBlb2YgcHJvcC55YXhpc0Zvcm1hdHRlcj09PSdmdW5jdGlvbic/KHByb3AueWF4aXNGb3JtYXR0ZXIpKHRoaXMscHJvcC55YXhpc01pbik6c3RyLHg6cHJvcC5ndXR0ZXJMZWZ0LTctKHByb3AueWF4aXM/KHByb3AueWF4aXNUaWNrbWFya3NMZW5ndGgtMyk6MCkrcHJvcC55YXhpc0xhYmVsc09mZnNldHgseTp5K3Byb3AueWF4aXNMYWJlbHNPZmZzZXR5LGhhbGlnbjoncmlnaHQnLHZhbGlnbjonY2VudGVyJyxmb250OnByb3AueWF4aXNUZXh0Rm9udHx8cHJvcC50ZXh0Rm9udCxzaXplOnByb3AueWF4aXNUZXh0U2l6ZXx8KHR5cGVvZiBwcm9wLnRleHRTaXplPT09J251bWJlcic/cHJvcC50ZXh0U2l6ZSsncHQnOnByb3AudGV4dFNpemUpLGJvbGQ6cHJvcC55YXhpc1RleHRCb2xkfHxwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLnlheGlzVGV4dEl0YWxpY3x8cHJvcC50ZXh0SXRhbGljLGNvbG9yOnByb3AueWF4aXNUZXh0Q29sb3J8fHByb3AudGV4dENvbG9yfSk7fWVsc2UgaWYocHJvcC55YXhpc0xhYmVscyYmcHJvcC55YXhpc0xhYmVscy5sZW5ndGgpe2Zvcih2YXIgaT0wO2k8cHJvcC55YXhpc0xhYmVscy5sZW5ndGg7KytpKXt2YXIgc2VnbWVudD0ob2JqLmdyYXBoSGVpZ2h0LShwcm9wLnZtYXJnaW5Ub3B8fDApLShwcm9wLnZtYXJnaW5Cb3R0b218fDApKS9wcm9wLnlheGlzTGFiZWxzLmxlbmd0aCx5PXByb3AuZ3V0dGVyVG9wKyhwcm9wLnZtYXJnaW5Ub3B8fDApKyhzZWdtZW50KmkpKyhzZWdtZW50LzIpK3Byb3AueWF4aXNMYWJlbHNPZmZzZXR5LHg9cHJvcC5ndXR0ZXJMZWZ0LTctKHByb3AueWF4aXNMaW5ld2lkdGh8fDEpK3Byb3AueWF4aXNMYWJlbHNPZmZzZXR4LGhhbGlnbj0ncmlnaHQnO2lmKG9iai50eXBlPT09J2hiYXInJiZvYmouc2NhbGUubWluPG9iai5zY2FsZS5tYXgmJm9iai5zY2FsZS5tYXg8PTApe2hhbGlnbj0nbGVmdCc7eD1vYmoud2lkdGgtcHJvcC5ndXR0ZXJSaWdodCs3K3Byb3AueWF4aXNMYWJlbHNPZmZzZXR4O31lbHNlIGlmKG9iai50eXBlPT09J2hiYXInJiYhcHJvcC55YXhpc0xhYmVsc1NwZWNpZmljKXt2YXIgc2VnbWVudD0ob2JqLmdyYXBoSGVpZ2h0LShwcm9wLnZtYXJnaW5Ub3B8fDApLShwcm9wLnZtYXJnaW5Cb3R0b218fDApKS8ocHJvcC55YXhpc0xhYmVscy5sZW5ndGgpO3k9cHJvcC5ndXR0ZXJUb3ArKHByb3Audm1hcmdpblRvcHx8MCkrKHNlZ21lbnQqaSkrKHNlZ21lbnQvMikrcHJvcC55YXhpc0xhYmVsc09mZnNldHg7fWVsc2V7dmFyIHNlZ21lbnQ9KG9iai5ncmFwaEhlaWdodC0ocHJvcC52bWFyZ2luVG9wfHwwKS0ocHJvcC52bWFyZ2luQm90dG9tfHwwKSkvKHByb3AueWF4aXNMYWJlbHMubGVuZ3RoLTEpO3k9b2JqLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS0oc2VnbWVudCppKStwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eDt9XG52YXIgdGV4dD1SRy5TVkcudGV4dCh7b2JqZWN0Om9iaixwYXJlbnQ6b2JqLnN2Zy5hbGwsdGV4dDpwcm9wLnlheGlzTGFiZWxzW2ldP3Byb3AueWF4aXNMYWJlbHNbaV06JycseDp4LHk6eSxoYWxpZ246aGFsaWduLHZhbGlnbjonY2VudGVyJyxmb250OnByb3AueWF4aXNUZXh0Rm9udHx8cHJvcC50ZXh0Rm9udCxzaXplOnByb3AueWF4aXNUZXh0U2l6ZXx8KHR5cGVvZiBwcm9wLnRleHRTaXplPT09J251bWJlcic/cHJvcC50ZXh0U2l6ZSsncHQnOnByb3AudGV4dFNpemUpLGJvbGQ6cHJvcC55YXhpc1RleHRCb2xkfHxwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLnlheGlzVGV4dEl0YWxpY3x8cHJvcC50ZXh0SXRhbGljLGNvbG9yOnByb3AueWF4aXNUZXh0Q29sb3J8fHByb3AudGV4dENvbG9yfSk7fX19O1JHLlNWRy5kcmF3QmFja2dyb3VuZD1mdW5jdGlvbihvYmopXG57dmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYodHlwZW9mIHByb3AudmFyaWFudDNkT2Zmc2V0eCE9PSdudW1iZXInKXByb3AudmFyaWFudDNkT2Zmc2V0eD0wO2lmKHR5cGVvZiBwcm9wLnZhcmlhbnQzZE9mZnNldHkhPT0nbnVtYmVyJylwcm9wLnZhcmlhbnQzZE9mZnNldHk9MDtpZihwcm9wLmJhY2tncm91bmRDb2xvcil7UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9iai5zdmcuYWxsLHR5cGU6J3JlY3QnLGF0dHI6e3g6LTErcHJvcC52YXJpYW50M2RPZmZzZXR4LHk6LTEtcHJvcC52YXJpYW50M2RPZmZzZXR5LHdpZHRoOnBhcnNlRmxvYXQob2JqLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpKzIsaGVpZ2h0OnBhcnNlRmxvYXQob2JqLnN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKSsyLGZpbGw6cHJvcC5iYWNrZ3JvdW5kQ29sb3J9fSk7fVxuaWYocHJvcC5iYWNrZ3JvdW5kSW1hZ2Upe3ZhciBhdHRyPXsneGxpbms6aHJlZic6cHJvcC5iYWNrZ3JvdW5kSW1hZ2UscHJlc2VydmVBc3BlY3RSYXRpbzpwcm9wLmJhY2tncm91bmRJbWFnZUFzcGVjdHx8J25vbmUnLHg6cHJvcC5ndXR0ZXJMZWZ0LHk6cHJvcC5ndXR0ZXJUb3B9O2lmKHByb3AuYmFja2dyb3VuZEltYWdlU3RyZXRjaCl7YXR0ci54PXByb3AuZ3V0dGVyTGVmdCtwcm9wLnZhcmlhbnQzZE9mZnNldHg7YXR0ci55PXByb3AuZ3V0dGVyVG9wK3Byb3AudmFyaWFudDNkT2Zmc2V0eTthdHRyLndpZHRoPW9iai53aWR0aC1wcm9wLmd1dHRlckxlZnQtcHJvcC5ndXR0ZXJSaWdodDthdHRyLmhlaWdodD1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyVG9wLXByb3AuZ3V0dGVyQm90dG9tO31lbHNle2lmKHR5cGVvZiBwcm9wLmJhY2tncm91bmRJbWFnZVg9PT0nbnVtYmVyJyl7YXR0ci54PXByb3AuYmFja2dyb3VuZEltYWdlWCtwcm9wLnZhcmlhbnQzZE9mZnNldHg7fVxuaWYodHlwZW9mIHByb3AuYmFja2dyb3VuZEltYWdlWT09PSdudW1iZXInKXthdHRyLnk9cHJvcC5iYWNrZ3JvdW5kSW1hZ2VZK3Byb3AudmFyaWFudDNkT2Zmc2V0eTt9XG5pZih0eXBlb2YgcHJvcC5iYWNrZ3JvdW5kSW1hZ2VXPT09J251bWJlcicpe2F0dHIud2lkdGg9cHJvcC5iYWNrZ3JvdW5kSW1hZ2VXO31cbmlmKHR5cGVvZiBwcm9wLmJhY2tncm91bmRJbWFnZUg9PT0nbnVtYmVyJyl7YXR0ci5oZWlnaHQ9cHJvcC5iYWNrZ3JvdW5kSW1hZ2VIO319XG5pZihwcm9wLnZhcmlhbnQ9PT0nM2QnKXthdHRyLngrPXByb3AudmFyaWFudDNkT2Zmc2V0eDthdHRyLnktPXByb3AudmFyaWFudDNkT2Zmc2V0eTt9XG52YXIgaW1nPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidpbWFnZScsYXR0cjphdHRyLHN0eWxlOntvcGFjaXR5OnR5cGVvZiBwcm9wLmJhY2tncm91bmRJbWFnZU9wYWNpdHk9PT0nbnVtYmVyJz9wcm9wLmJhY2tncm91bmRJbWFnZU9wYWNpdHk6MX19KTt9XG5pZihwcm9wLmJhY2tncm91bmRHcmlkKXt2YXIgcGFydHM9W107aWYocHJvcC5iYWNrZ3JvdW5kR3JpZEhsaW5lcyl7dmFyIGNvdW50PXR5cGVvZiBwcm9wLmJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ9PT0nbnVtYmVyJz9wcm9wLmJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6KG9iai50eXBlPT09J2hiYXInPyhwcm9wLnlheGlzTGFiZWxzLmxlbmd0aHx8b2JqLmRhdGEubGVuZ3RofHw1KTpwcm9wLnlheGlzTGFiZWxzQ291bnQpO2Zvcih2YXIgaT0wO2k8Y291bnQ7KytpKXtwYXJ0cy5wdXNoKCdNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCtwcm9wLnZhcmlhbnQzZE9mZnNldHgscHJvcC5ndXR0ZXJUb3ArKG9iai5ncmFwaEhlaWdodC9jb3VudCkqaS1wcm9wLnZhcmlhbnQzZE9mZnNldHksb2JqLndpZHRoLXByb3AuZ3V0dGVyUmlnaHQrcHJvcC52YXJpYW50M2RPZmZzZXR4LHByb3AuZ3V0dGVyVG9wKyhvYmouZ3JhcGhIZWlnaHQvY291bnQpKmktcHJvcC52YXJpYW50M2RPZmZzZXR5KSk7fVxucGFydHMucHVzaCgnTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQrcHJvcC52YXJpYW50M2RPZmZzZXR4LG9iai5oZWlnaHQtcHJvcC5ndXR0ZXJCb3R0b20tcHJvcC52YXJpYW50M2RPZmZzZXR5LG9iai53aWR0aC1wcm9wLmd1dHRlclJpZ2h0K3Byb3AudmFyaWFudDNkT2Zmc2V0eCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLXByb3AudmFyaWFudDNkT2Zmc2V0eSkpO31cbmlmKHByb3AuYmFja2dyb3VuZEdyaWRWbGluZXMpe2lmKG9iai50eXBlPT09J2xpbmUnJiZSRy5TVkcuaXNBcnJheShvYmouZGF0YVswXSkpe3ZhciBsZW49b2JqLmRhdGFbMF0ubGVuZ3RoO31lbHNlIGlmKG9iai50eXBlPT09J2hiYXInKXt2YXIgbGVuPXByb3AueGF4aXNMYWJlbHNDb3VudHx8MTA7fWVsc2UgaWYob2JqLnR5cGU9PT0nc2NhdHRlcicpe3ZhciBsZW49KHByb3AueGF4aXNMYWJlbHMmJnByb3AueGF4aXNMYWJlbHMubGVuZ3RoKXx8MTA7fWVsc2V7dmFyIGxlbj1vYmouZGF0YS5sZW5ndGg7fVxudmFyIGNvdW50PXR5cGVvZiBwcm9wLmJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQ9PT0nbnVtYmVyJz9wcm9wLmJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQ6bGVuO2lmKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbj09PSdlZGdlJyl7Y291bnQtLTt9XG5mb3IodmFyIGk9MDtpPD1jb3VudDsrK2kpe3BhcnRzLnB1c2goJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQocHJvcC5ndXR0ZXJMZWZ0Kygob2JqLmdyYXBoV2lkdGgvY291bnQpKmkpK3Byb3AudmFyaWFudDNkT2Zmc2V0eCxwcm9wLmd1dHRlclRvcC1wcm9wLnZhcmlhbnQzZE9mZnNldHkscHJvcC5ndXR0ZXJMZWZ0Kygob2JqLmdyYXBoV2lkdGgvY291bnQpKmkpK3Byb3AudmFyaWFudDNkT2Zmc2V0eCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLXByb3AudmFyaWFudDNkT2Zmc2V0eSkpO319XG5pZihwcm9wLmJhY2tncm91bmRHcmlkQm9yZGVyKXtwYXJ0cy5wdXNoKCdNezF9IHsyfSBMezN9IHs0fSBMezV9IHs2fSBMezd9IHs4fSB6Jy5mb3JtYXQocHJvcC5ndXR0ZXJMZWZ0K3Byb3AudmFyaWFudDNkT2Zmc2V0eCxwcm9wLmd1dHRlclRvcC1wcm9wLnZhcmlhbnQzZE9mZnNldHksb2JqLndpZHRoLXByb3AuZ3V0dGVyUmlnaHQrcHJvcC52YXJpYW50M2RPZmZzZXR4LHByb3AuZ3V0dGVyVG9wLXByb3AudmFyaWFudDNkT2Zmc2V0eSxvYmoud2lkdGgtcHJvcC5ndXR0ZXJSaWdodCtwcm9wLnZhcmlhbnQzZE9mZnNldHgsb2JqLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS1wcm9wLnZhcmlhbnQzZE9mZnNldHkscHJvcC5ndXR0ZXJMZWZ0K3Byb3AudmFyaWFudDNkT2Zmc2V0eCxvYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLXByb3AudmFyaWFudDNkT2Zmc2V0eSkpO31cbnZhciBncmlkPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOnBhcnRzLmpvaW4oJyAnKSxzdHJva2U6cHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLGZpbGw6J3JnYmEoMCwwLDAsMCknLCdzdHJva2Utd2lkdGgnOnByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGgsJ3NoYXBlLXJlbmRlcmluZyc6XCJjcmlzcEVkZ2VzXCJ9fSk7fVxuUkcuU1ZHLmRyYXdUaXRsZShvYmopO307UkcuU1ZHLmlzTnVsbD1mdW5jdGlvbihhcmcpXG57aWYoYXJnPT1udWxsfHx0eXBlb2YgYXJnPT09J29iamVjdCcmJiFhcmcpe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O1JHLlNWRy5nZXRTY2FsZT1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0LHByb3A9b2JqLnByb3BlcnRpZXMsbnVtbGFiZWxzPW9wdC5udW1sYWJlbHMsdW5pdHNQcmU9b3B0LnVuaXRzUHJlLHVuaXRzUG9zdD1vcHQudW5pdHNQb3N0LG1heD1OdW1iZXIob3B0Lm1heCksbWluPU51bWJlcihvcHQubWluKSxzdHJpY3Q9b3B0LnN0cmljdCxkZWNpbWFscz1OdW1iZXIob3B0LmRlY2ltYWxzKSxwb2ludD1vcHQucG9pbnQsdGhvdXNhbmQ9b3B0LnRob3VzYW5kLG9yaWdpbmFsTWF4PW1heCxyb3VuZD1vcHQucm91bmQsc2NhbGU9e21heDoxLGxhYmVsczpbXSx2YWx1ZXM6W119LGZvcm1hdHRlcj1vcHQuZm9ybWF0dGVyO2lmKG1heD09PTAmJm1pbj09PTApe3ZhciBtYXg9MTtmb3IodmFyIGk9MDtpPG51bWxhYmVsczsrK2kpe3ZhciBsYWJlbD0oKCgobWF4LW1pbikvbnVtbGFiZWxzKSooaSsxKSkrbWluKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS5sYWJlbHMucHVzaCh1bml0c1ByZStsYWJlbCt1bml0c1Bvc3QpO3NjYWxlLnZhbHVlcy5wdXNoKHBhcnNlRmxvYXQobGFiZWwpKX19ZWxzZSBpZihtYXg8PTEmJiFzdHJpY3Qpe3ZhciBhcnI9WzEsMC41LDAuMTAsMC4wNSwwLjAxMCwwLjAwNSwwLjAwMTAsMC4wMDA1LDAuMDAwMTAsMC4wMDAwNSwwLjAwMDAxMCwwLjAwMDAwNSwwLjAwMDAwMTAsMC4wMDAwMDA1LDAuMDAwMDAwMTAsMC4wMDAwMDAwNSwwLjAwMDAwMDAxMCwwLjAwMDAwMDAwNSwwLjAwMDAwMDAwMTAsMC4wMDAwMDAwMDA1LDAuMDAwMDAwMDAwMTAsMC4wMDAwMDAwMDAwNSwwLjAwMDAwMDAwMDAxMCwwLjAwMDAwMDAwMDAwNSwwLjAwMDAwMDAwMDAwMTAsMC4wMDAwMDAwMDAwMDA1XSx2YWxzPVtdO2Zvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDsrK2kpe2lmKG1heD5hcnJbaV0pe2ktLTticmVhazt9fVxuc2NhbGUubWF4PWFycltpXVxuc2NhbGUubGFiZWxzPVtdO3NjYWxlLnZhbHVlcz1bXTtmb3IodmFyIGo9MDtqPG51bWxhYmVsczsrK2ope3ZhciB2YWx1ZT0oKCgoYXJyW2ldLW1pbikvbnVtbGFiZWxzKSooaisxKSkrbWluKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS52YWx1ZXMucHVzaCh2YWx1ZSk7c2NhbGUubGFiZWxzLnB1c2goUkcuU1ZHLm51bWJlckZvcm1hdCh7b2JqZWN0Om9iaixudW06dmFsdWUscHJlcGVuZDp1bml0c1ByZSxhcHBlbmQ6dW5pdHNQb3N0LHBvaW50OnByb3AueWF4aXNQb2ludCx0aG91c2FuZDpwcm9wLnlheGlzVGhvdXNhbmQsZm9ybWF0dGVyOmZvcm1hdHRlcn0pKTt9fWVsc2UgaWYoIXN0cmljdCl7bWF4PW1hLmNlaWwobWF4KTt2YXIgaW50ZXJ2YWw9bWEucG93KDEwLG1hLm1heCgxLE51bWJlcihTdHJpbmcoTnVtYmVyKG1heCktTnVtYmVyKG1pbikpLmxlbmd0aC0xKSkpO3ZhciB0b3BWYWx1ZT1pbnRlcnZhbDt3aGlsZSh0b3BWYWx1ZTxtYXgpe3RvcFZhbHVlKz0oaW50ZXJ2YWwvMik7fVxuaWYoTnVtYmVyKG9yaWdpbmFsTWF4KT5OdW1iZXIodG9wVmFsdWUpKXt0b3BWYWx1ZSs9KGludGVydmFsLzIpO31cbmlmKG1heDw9MTApe3RvcFZhbHVlPShOdW1iZXIob3JpZ2luYWxNYXgpPD01PzU6MTApO31cbmlmKG9iaiYmdHlwZW9mKHJvdW5kKT09J2Jvb2xlYW4nJiZyb3VuZCl7dG9wVmFsdWU9MTAqaW50ZXJ2YWw7fVxuc2NhbGUubWF4PXRvcFZhbHVlO2Zvcih2YXIgaT0wO2k8bnVtbGFiZWxzOysraSl7dmFyIGxhYmVsPVJHLlNWRy5udW1iZXJGb3JtYXQoe29iamVjdDpvYmosbnVtOigoKChpKzEpL251bWxhYmVscykqKHRvcFZhbHVlLW1pbikpK21pbikudG9GaXhlZChkZWNpbWFscykscHJlcGVuZDp1bml0c1ByZSxhcHBlbmQ6dW5pdHNQb3N0LHBvaW50OnBvaW50LHRob3VzYW5kOnRob3VzYW5kLGZvcm1hdHRlcjpmb3JtYXR0ZXJ9KTtzY2FsZS5sYWJlbHMucHVzaChsYWJlbCk7c2NhbGUudmFsdWVzLnB1c2goKCgoKGkrMSkvbnVtbGFiZWxzKSoodG9wVmFsdWUtbWluKSkrbWluKS50b0ZpeGVkKGRlY2ltYWxzKSk7fX1lbHNlIGlmKHR5cGVvZiBtYXg9PT0nbnVtYmVyJyYmc3RyaWN0KXtmb3IodmFyIGk9MDtpPG51bWxhYmVsczsrK2kpe3NjYWxlLmxhYmVscy5wdXNoKFJHLlNWRy5udW1iZXJGb3JtYXQoe29iamVjdDpvYmosZm9ybWF0dGVyOmZvcm1hdHRlcixudW06KCgoKGkrMSkvbnVtbGFiZWxzKSoobWF4LW1pbikpK21pbikudG9GaXhlZChkZWNpbWFscykscHJlcGVuZDp1bml0c1ByZSxhcHBlbmQ6dW5pdHNQb3N0LHBvaW50OnBvaW50LHRob3VzYW5kOnRob3VzYW5kfSkpO3NjYWxlLnZhbHVlcy5wdXNoKCgoKChpKzEpL251bWxhYmVscykqKG1heC1taW4pKSttaW4pLnRvRml4ZWQoZGVjaW1hbHMpKTt9XG5zY2FsZS5tYXg9bWF4O31cbnNjYWxlLnVuaXRzUHJlPXVuaXRzUHJlO3NjYWxlLnVuaXRzUG9zdD11bml0c1Bvc3Q7c2NhbGUucG9pbnQ9cG9pbnQ7c2NhbGUuZGVjaW1hbHM9ZGVjaW1hbHM7c2NhbGUudGhvdXNhbmQ9dGhvdXNhbmQ7c2NhbGUubnVtbGFiZWxzPW51bWxhYmVscztzY2FsZS5yb3VuZD1Cb29sZWFuKHJvdW5kKTtzY2FsZS5taW49bWluO2Zvcih2YXIgaT0wO2k8c2NhbGUudmFsdWVzLmxlbmd0aDsrK2kpe3NjYWxlLnZhbHVlc1tpXT1wYXJzZUZsb2F0KHNjYWxlLnZhbHVlc1tpXSk7fVxucmV0dXJuIHNjYWxlO307UkcuU1ZHLmFycmF5RmlsbD1SRy5TVkcuYXJyYXlQYWQ9ZnVuY3Rpb24ob3B0KVxue3ZhciBhcnI9b3B0LmFycmF5LGxlbj1vcHQubGVuZ3RoLHZhbHVlPShvcHQudmFsdWU/b3B0LnZhbHVlOm51bGwpO2lmKGFyci5sZW5ndGg8bGVuKXtmb3IodmFyIGk9YXJyLmxlbmd0aDtpPGxlbjtpKz0xKXthcnJbaV09dmFsdWU7fX1cbnJldHVybiBhcnI7fTtSRy5TVkcuYXJyYXlTdW09ZnVuY3Rpb24oYXJyKVxue2lmKHR5cGVvZiBhcnI9PT0nbnVtYmVyJyl7cmV0dXJuIGFycjt9XG5pZihSRy5TVkcuaXNOdWxsKGFycikpe3JldHVybiAwO31cbnZhciBpLHN1bSxsZW49YXJyLmxlbmd0aDtmb3IoaT0wLHN1bT0wO2k8bGVuO3N1bSs9YXJyW2krK10pO3JldHVybiBzdW07fTtSRy5TVkcuYXJyYXlNYXg9ZnVuY3Rpb24oYXJyKVxue3ZhciBtYXg9bnVsbFxuaWYodHlwZW9mIGFycj09PSdudW1iZXInKXtyZXR1cm4gYXJyO31cbmlmKFJHLlNWRy5pc051bGwoYXJyKSl7cmV0dXJuIDA7fVxuZm9yKHZhciBpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47KytpKXtpZih0eXBlb2YgYXJyW2ldPT09J251bWJlcicpe3ZhciB2YWw9YXJndW1lbnRzWzFdP21hLmFicyhhcnJbaV0pOmFycltpXTtpZih0eXBlb2YgbWF4PT09J251bWJlcicpe21heD1tYS5tYXgobWF4LHZhbCk7fWVsc2V7bWF4PXZhbDt9fX1cbnJldHVybiBtYXg7fTtSRy5TVkcuYXJyYXlNaW49ZnVuY3Rpb24oYXJyKVxue3ZhciBtYXg9bnVsbCxtaW49bnVsbCxtYT1NYXRoO2lmKHR5cGVvZiBhcnI9PT0nbnVtYmVyJyl7cmV0dXJuIGFycjt9XG5pZihSRy5TVkcuaXNOdWxsKGFycikpe3JldHVybiAwO31cbmZvcih2YXIgaT0wLGxlbj1hcnIubGVuZ3RoO2k8bGVuOysraSl7aWYodHlwZW9mIGFycltpXT09PSdudW1iZXInKXt2YXIgdmFsPWFyZ3VtZW50c1sxXT9tYS5hYnMoYXJyW2ldKTphcnJbaV07aWYodHlwZW9mIG1pbj09PSdudW1iZXInKXttaW49bWEubWluKG1pbix2YWwpO31lbHNle21pbj12YWw7fX19XG5yZXR1cm4gbWluO307UkcuU1ZHLmFycmF5UGFkPWZ1bmN0aW9uKGFycixsZW4pXG57aWYoYXJyLmxlbmd0aDxsZW4pe3ZhciB2YWw9YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO2Zvcih2YXIgaT1hcnIubGVuZ3RoO2k8bGVuO2krPTEpe2FycltpXT12YWw7fX1cbnJldHVybiBhcnI7fTtSRy5TVkcuYXJyYXlTdW09ZnVuY3Rpb24oYXJyKVxue2lmKHR5cGVvZiBhcnI9PT0nbnVtYmVyJyl7cmV0dXJuIGFycjt9XG5pZihSRy5TVkcuaXNOdWxsKGFycikpe3JldHVybiAwO31cbnZhciBpLHN1bSxsZW49YXJyLmxlbmd0aDtmb3IoaT0wLHN1bT0wO2k8bGVuO3N1bSs9YXJyW2krK10pO3JldHVybiBzdW07fTtSRy5TVkcuYXJyYXlMaW5lYXJpemU9ZnVuY3Rpb24oKVxue3ZhciBhcnI9W10sYXJncz1hcmd1bWVudHNcbmZvcih2YXIgaT0wLGxlbj1hcmdzLmxlbmd0aDtpPGxlbjsrK2kpe2lmKHR5cGVvZiBhcmdzW2ldPT09J29iamVjdCcmJmFyZ3NbaV0pe2Zvcih2YXIgaj0wLGxlbjI9YXJnc1tpXS5sZW5ndGg7ajxsZW4yOysrail7dmFyIHN1Yj1SRy5TVkcuYXJyYXlMaW5lYXJpemUoYXJnc1tpXVtqXSk7Zm9yKHZhciBrPTAsbGVuMz1zdWIubGVuZ3RoO2s8bGVuMzsrK2spe2Fyci5wdXNoKHN1YltrXSk7fX19ZWxzZXthcnIucHVzaChhcmdzW2ldKTt9fVxucmV0dXJuIGFycjt9O1JHLlNWRy5hcnJheVNoaWZ0PWZ1bmN0aW9uKGFycilcbnt2YXIgcmV0PVtdO2Zvcih2YXIgaT0xLGxlbj1hcnIubGVuZ3RoO2k8bGVuOysraSl7cmV0LnB1c2goYXJyW2ldKTt9XG5yZXR1cm4gcmV0O307UkcuU1ZHLmFycmF5UmV2ZXJzZT1mdW5jdGlvbihhcnIpXG57aWYoIWFycil7cmV0dXJuO31cbnZhciBuZXdhcnI9W107Zm9yKHZhciBpPWFyci5sZW5ndGgtMTtpPj0wO2ktPTEpe25ld2Fyci5wdXNoKGFycltpXSk7fVxucmV0dXJuIG5ld2Fycjt9O1JHLlNWRy5hcnJheUNsb25lPWZ1bmN0aW9uKG9iailcbntpZihvYmo9PT1udWxsfHx0eXBlb2Ygb2JqIT09J29iamVjdCcpe3JldHVybiBvYmo7fVxuaWYoUkcuU1ZHLmlzQXJyYXkob2JqKSl7dmFyIHRlbXA9W107Zm9yKHZhciBpPTAsbGVuPW9iai5sZW5ndGg7aTxsZW47KytpKXtpZih0eXBlb2Ygb2JqW2ldPT09J251bWJlcicpe3RlbXBbaV09KGZ1bmN0aW9uKGFyZyl7cmV0dXJuIE51bWJlcihhcmcpO30pKG9ialtpXSk7fWVsc2UgaWYodHlwZW9mIG9ialtpXT09PSdzdHJpbmcnKXt0ZW1wW2ldPShmdW5jdGlvbihhcmcpe3JldHVybiBTdHJpbmcoYXJnKTt9KShvYmpbaV0pO31lbHNlIGlmKHR5cGVvZiBvYmpbaV09PT0nZnVuY3Rpb24nKXt0ZW1wW2ldPW9ialtpXTt9ZWxzZXt0ZW1wW2ldPVJHLlNWRy5hcnJheUNsb25lKG9ialtpXSk7fX19ZWxzZSBpZih0eXBlb2Ygb2JqPT09J29iamVjdCcpe3ZhciB0ZW1wPXt9O2Zvcih2YXIgaSBpbiBvYmope2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3RlbXBbaV09b2JqW2ldO319fVxucmV0dXJuIHRlbXA7fTtSRy5TVkcuYXJyYXlJbnZlcnQ9ZnVuY3Rpb24oYXJyKVxue2Zvcih2YXIgaT0wLGxlbj1hcnIubGVuZ3RoO2k8bGVuOysraSl7YXJyW2ldPSFhcnJbaV07fVxucmV0dXJuIGFycjt9O1JHLlNWRy5hcnJheVRyaW09ZnVuY3Rpb24oYXJyKVxue3ZhciBvdXQ9W10sY29udGVudD1mYWxzZTtmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtpZihhcnJbaV0pe2NvbnRlbnQ9dHJ1ZTt9XG5pZihjb250ZW50KXtvdXQucHVzaChhcnJbaV0pO319XG5vdXQ9UkcuU1ZHLmFycmF5UmV2ZXJzZShvdXQpO3ZhciBvdXQyPVtdLGNvbnRlbnQ9ZmFsc2U7Zm9yKHZhciBpPTA7aTxvdXQubGVuZ3RoO2krKyl7aWYob3V0W2ldKXtjb250ZW50PXRydWU7fVxuaWYoY29udGVudCl7b3V0Mi5wdXNoKG91dFtpXSk7fX1cbm91dDI9UkcuU1ZHLmFycmF5UmV2ZXJzZShvdXQyKTtyZXR1cm4gb3V0Mjt9O1JHLlNWRy5pc0FycmF5PWZ1bmN0aW9uKG9iailcbntpZihvYmomJm9iai5jb25zdHJ1Y3Rvcil7dmFyIHBvcz1vYmouY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKCdBcnJheScpO31lbHNle3JldHVybiBmYWxzZTt9XG5yZXR1cm4gb2JqIT1udWxsJiZ0eXBlb2YgcG9zPT09J251bWJlcicmJnBvcz4wJiZwb3M8MjA7fTtSRy5TVkcuYWJzPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHR5cGVvZiB2YWx1ZT09PSdzdHJpbmcnKXt2YWx1ZT1wYXJzZUZsb2F0KHZhbHVlKXx8MDt9XG5pZih0eXBlb2YgdmFsdWU9PT0nbnVtYmVyJyl7cmV0dXJuIG1hLmFicyh2YWx1ZSk7fVxuaWYodHlwZW9mIHZhbHVlPT09J29iamVjdCcpe2ZvcihpIGluIHZhbHVlKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnfHx0eXBlb2YgaT09PSdudW1iZXInfHx0eXBlb2YgaT09PSdvYmplY3QnKXt2YWx1ZVtpXT1SRy5TVkcuYWJzKHZhbHVlW2ldKTt9fVxucmV0dXJuIHZhbHVlO31cbnJldHVybiAwO307UkcuU1ZHLm51bWJlckZvcm1hdD1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0LHByZXBlbmQ9b3B0LnByZXBlbmQ/U3RyaW5nKG9wdC5wcmVwZW5kKTonJyxhcHBlbmQ9b3B0LmFwcGVuZD9TdHJpbmcob3B0LmFwcGVuZCk6Jycsb3V0cHV0PScnLGRlY2ltYWxfc2VwZXJhdG9yPXR5cGVvZiBvcHQucG9pbnQ9PT0nc3RyaW5nJz9vcHQucG9pbnQ6Jy4nLHRob3VzYW5kX3NlcGVyYXRvcj10eXBlb2Ygb3B0LnRob3VzYW5kPT09J3N0cmluZyc/b3B0LnRob3VzYW5kOicsJyxudW09b3B0Lm51bTtSZWdFeHAuJDE9Jyc7aWYodHlwZW9mIG9wdC5mb3JtYXR0ZXI9PT0nZnVuY3Rpb24nKXtyZXR1cm4gb3B0LmZvcm1hdHRlcihvYmosbnVtKTt9XG5pZihTdHJpbmcobnVtKS5pbmRleE9mKCdlJyk+MCl7cmV0dXJuIFN0cmluZyhwcmVwZW5kK1N0cmluZyhudW0pK2FwcGVuZCk7fVxubnVtPVN0cmluZyhudW0pO2lmKG51bS5pbmRleE9mKCcuJyk+MCl7dmFyIHRtcD1udW07bnVtPW51bS5yZXBsYWNlKC9cXC4oLiopLywnJyk7ZGVjaW1hbD10bXAucmVwbGFjZSgvKC4qKVxcLiguKikvLCckMicpO31lbHNle2RlY2ltYWw9Jyc7fVxudmFyIHNlcGVyYXRvcj10aG91c2FuZF9zZXBlcmF0b3I7dmFyIGZvdW5kUG9pbnQ7Zm9yKGk9KG51bS5sZW5ndGgtMSksaj0wO2k+PTA7aisrLGktLSl7dmFyIGNoYXJhY3Rlcj1udW0uY2hhckF0KGkpO2lmKGolMz09MCYmaiE9MCl7b3V0cHV0Kz1zZXBlcmF0b3I7fVxub3V0cHV0Kz1jaGFyYWN0ZXI7fVxudmFyIHJldj1vdXRwdXQ7b3V0cHV0PScnO2ZvcihpPShyZXYubGVuZ3RoLTEpO2k+PTA7aS0tKXtvdXRwdXQrPXJldi5jaGFyQXQoaSk7fVxuaWYob3V0cHV0LmluZGV4T2YoJy0nK3Rob3VzYW5kX3NlcGVyYXRvcik9PTApe291dHB1dD0nLScrb3V0cHV0LnN1YnN0cigoJy0nK3Rob3VzYW5kX3NlcGVyYXRvcikubGVuZ3RoKTt9XG5pZihkZWNpbWFsLmxlbmd0aCl7b3V0cHV0PW91dHB1dCtkZWNpbWFsX3NlcGVyYXRvcitkZWNpbWFsO2RlY2ltYWw9Jyc7UmVnRXhwLiQxPScnO31cbmlmKG91dHB1dC5jaGFyQXQoMCk9PSctJyl7b3V0cHV0PW91dHB1dC5yZXBsYWNlKC8tLywnJyk7cHJlcGVuZD0nLScrcHJlcGVuZDt9XG5yZXR1cm4gcHJlcGVuZCtvdXRwdXQrYXBwZW5kO307UkcuU1ZHLnRleHQ9ZnVuY3Rpb24ob3B0KVxue3ZhciBvYmo9b3B0Lm9iamVjdCxwYXJlbnQ9b3B0LnBhcmVudHx8b3B0Lm9iamVjdC5zdmcuYWxsLHNpemU9b3B0LnNpemUsYm9sZD1vcHQuYm9sZCxmb250PW9wdC5mb250LGl0YWxpYz1vcHQuaXRhbGljLGhhbGlnbj1vcHQuaGFsaWduLHZhbGlnbj1vcHQudmFsaWduLHN0cj1vcHQudGV4dCx4PW9wdC54LHk9b3B0LnksY29sb3I9b3B0LmNvbG9yP29wdC5jb2xvcjonYmxhY2snLGJhY2tncm91bmQ9b3B0LmJhY2tncm91bmR8fG51bGwscGFkZGluZz1vcHQucGFkZGluZ3x8MDtpZihoYWxpZ249PT0ncmlnaHQnKXtoYWxpZ249J2VuZCc7fWVsc2UgaWYoaGFsaWduPT09J2NlbnRlcid8fGhhbGlnbj09PSdtaWRkbGUnKXtoYWxpZ249J21pZGRsZSc7fWVsc2V7aGFsaWduPSdzdGFydCc7fVxuaWYodmFsaWduPT09J3RvcCcpe3ZhbGlnbj0naGFuZ2luZyc7fWVsc2UgaWYodmFsaWduPT09J2NlbnRlcid8fHZhbGlnbj09PSdtaWRkbGUnKXt2YWxpZ249J2NlbnRyYWwnO3ZhbGlnbj0nbWlkZGxlJzt9ZWxzZXt2YWxpZ249J2JvdHRvbSc7fVxudmFyIHRleHQ9UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9wdC5wYXJlbnQsdHlwZTondGV4dCcsYXR0cjp7ZmlsbDpjb2xvcix4OngseTp5LCdmb250LXNpemUnOnR5cGVvZiBzaXplPT09J251bWJlcic/c2l6ZSsncHQnOnNpemUsJ2ZvbnQtd2VpZ2h0Jzpib2xkPzkwMDoxMDAsJ2ZvbnQtZmFtaWx5Jzpmb250P2ZvbnQ6J3NhbnMtc2VyaWYnLCdmb250LXN0eWxlJzppdGFsaWM/J2l0YWxpYyc6J25vcm1hbCcsJ3RleHQtYW5jaG9yJzpoYWxpZ24sJ2RvbWluYW50LWJhc2VsaW5lJzp2YWxpZ259fSk7dmFyIHRleHROb2RlPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cik7dGV4dC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7aWYodHlwZW9mIGJhY2tncm91bmQ9PT0nc3RyaW5nJyl7dmFyIGJib3g9dGV4dC5nZXRCQm94KCkscmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b3B0LnBhcmVudCx0eXBlOidyZWN0JyxhdHRyOnt4OmJib3gueC1wYWRkaW5nLHk6YmJveC55LXBhZGRpbmcsd2lkdGg6YmJveC53aWR0aCsocGFkZGluZyoyKSxoZWlnaHQ6YmJveC5oZWlnaHQrKHBhZGRpbmcqMiksZmlsbDpiYWNrZ3JvdW5kfX0pO3BhcmVudC5pbnNlcnRCZWZvcmUocmVjdCx0ZXh0KTt9XG5pZihSRy5TVkcuSVNJRSYmKHZhbGlnbj09PSdoYW5naW5nJykpe3RleHQuc2V0QXR0cmlidXRlKCd5Jyx5Kyh0ZXh0LnNjcm9sbEhlaWdodC8yKSk7fWVsc2UgaWYoUkcuU1ZHLklTSUUmJnZhbGlnbj09PSdtaWRkbGUnKXt0ZXh0LnNldEF0dHJpYnV0ZSgneScseSsodGV4dC5zY3JvbGxIZWlnaHQvMykpO31cbmlmKFJHLlNWRy5JU0ZGKXtZPXkrKHRleHQuc2Nyb2xsSGVpZ2h0LzMpO31cbnJldHVybiB0ZXh0O307UkcuU1ZHLmNyZWF0ZVVJRD1mdW5jdGlvbigpXG57cmV0dXJuJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLGZ1bmN0aW9uKGMpXG57dmFyIHI9bWEucmFuZG9tKCkqMTZ8MCx2PWM9PSd4Jz9yOihyJjB4M3wweDgpO3JldHVybiB2LnRvU3RyaW5nKDE2KTt9KTt9O1JHLlNWRy5pc0ZpeGVkPWZ1bmN0aW9uKHN2Zylcbnt2YXIgb2JqPXN2Zy5wYXJlbnROb2RlLGk9MDt3aGlsZShvYmomJm9iai50YWdOYW1lLnRvTG93ZXJDYXNlKCkhPSdib2R5JyYmaTw5OSl7aWYob2JqLnN0eWxlLnBvc2l0aW9uPT09J2ZpeGVkJyl7cmV0dXJuIG9iajt9XG5vYmo9b2JqLm9mZnNldFBhcmVudDt9XG5yZXR1cm4gZmFsc2U7fTtSRy5TVkcuUkVHLnNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue1JHLlNWRy5SRUcuc3RvcmVbbmFtZV09dmFsdWU7cmV0dXJuIHZhbHVlO307UkcuU1ZHLlJFRy5nZXQ9ZnVuY3Rpb24obmFtZSlcbntyZXR1cm4gUkcuU1ZHLlJFRy5zdG9yZVtuYW1lXTt9O1JHLlNWRy50cmltPWZ1bmN0aW9uKHN0cilcbntyZXR1cm4gUkcuU1ZHLmx0cmltKFJHLlNWRy5ydHJpbShzdHIpKTt9O1JHLlNWRy5sdHJpbT1mdW5jdGlvbihzdHIpXG57cmV0dXJuIHN0ci5yZXBsYWNlKC9eKFxcc3xcXDApKy8sJycpO307UkcuU1ZHLnJ0cmltPWZ1bmN0aW9uKHN0cilcbntyZXR1cm4gc3RyLnJlcGxhY2UoLyhcXHN8XFwwKSskLywnJyk7fTtSRy5TVkcuaGlkZVRvb2x0aXA9ZnVuY3Rpb24oKVxue3ZhciB0b29sdGlwPVJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwJyk7aWYodG9vbHRpcCYmdG9vbHRpcC5wYXJlbnROb2RlKXt0b29sdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9vbHRpcCk7dG9vbHRpcC5zdHlsZS5kaXNwbGF5PSdub25lJzt0b29sdGlwLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbic7UkcuU1ZHLlJFRy5zZXQoJ3Rvb2x0aXAnLG51bGwpO31cbmlmKHRvb2x0aXAmJnRvb2x0aXAuX19vYmplY3RfXyl7UkcuU1ZHLnJlbW92ZUhpZ2hsaWdodCh0b29sdGlwLl9fb2JqZWN0X18pO319O1JHLlNWRy5zZXRTaGFkb3c9ZnVuY3Rpb24ob3B0aW9ucylcbnt2YXIgb2JqPW9wdGlvbnMub2JqZWN0LG9mZnNldHg9b3B0aW9ucy5vZmZzZXR4fHwwLG9mZnNldHk9b3B0aW9ucy5vZmZzZXR5fHwwLGJsdXI9b3B0aW9ucy5ibHVyfHwwLG9wYWNpdHk9b3B0aW9ucy5vcGFjaXR5fHwwLGlkPW9wdGlvbnMuaWQ7dmFyIGZpbHRlcj1SRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5kZWZzLHR5cGU6J2ZpbHRlcicsYXR0cjp7aWQ6aWQsd2lkdGg6XCIxMzAlXCIsaGVpZ2h0OlwiMTMwJVwifX0pO1JHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpmaWx0ZXIsdHlwZTonZmVPZmZzZXQnLGF0dHI6e3Jlc3VsdDonb2ZmT3V0JywnaW4nOidTb3VyY2VHcmFwaGljJyxkeDpvZmZzZXR4LGR5Om9mZnNldHl9fSk7UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50OmZpbHRlcix0eXBlOidmZUNvbG9yTWF0cml4JyxhdHRyOntyZXN1bHQ6J21hdHJpeE91dCcsJ2luJzonb2ZmT3V0Jyx0eXBlOidtYXRyaXgnLHZhbHVlczonMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgezF9IDAnLmZvcm1hdChvcGFjaXR5KX19KTtSRy5TVkcuY3JlYXRlKHtzdmc6b2JqLnN2ZyxwYXJlbnQ6ZmlsdGVyLHR5cGU6J2ZlR2F1c3NpYW5CbHVyJyxhdHRyOntyZXN1bHQ6J2JsdXJPdXQnLCdpbic6J21hdHJpeE91dCcsc3RkRGV2aWF0aW9uOmJsdXJ9fSk7UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50OmZpbHRlcix0eXBlOidmZUJsZW5kJyxhdHRyOnsnaW4nOidTb3VyY2VHcmFwaGljJywnaW4yJzonYmx1ck91dCcsbW9kZTonbm9ybWFsJ319KTt9O1JHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQ9ZnVuY3Rpb24oaW5kZXgsZGF0YSlcbnt2YXIgZ3JvdXA9MCxncm91cGVkX2luZGV4PTA7d2hpbGUoLS1pbmRleD49MCl7aWYoUkcuU1ZHLmlzTnVsbChkYXRhW2dyb3VwXSkpe2dyb3VwKys7Z3JvdXBlZF9pbmRleD0wO2NvbnRpbnVlO31cbmlmKHR5cGVvZiBkYXRhW2dyb3VwXT09J251bWJlcicpe2dyb3VwKytcbmdyb3VwZWRfaW5kZXg9MDtjb250aW51ZTt9XG5ncm91cGVkX2luZGV4Kys7aWYoZ3JvdXBlZF9pbmRleD49ZGF0YVtncm91cF0ubGVuZ3RoKXtncm91cCsrO2dyb3VwZWRfaW5kZXg9MDt9fVxucmV0dXJuW2dyb3VwLGdyb3VwZWRfaW5kZXhdO307UkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW49ZnVuY3Rpb24ob3B0aW9ucylcbntyZXR1cm57eDpvcHRpb25zLmN4KyhvcHRpb25zLnIqbWEuY29zKG9wdGlvbnMuYW5nbGUpKSx5Om9wdGlvbnMuY3krKG9wdGlvbnMuciptYS5zaW4ob3B0aW9ucy5hbmdsZSkpfTt9O1JHLlNWRy5UUklHLmdldEFyY1BhdGg9ZnVuY3Rpb24ob3B0aW9ucylcbntvcHRpb25zLnN0YXJ0LT0xLjU3O29wdGlvbnMuZW5kLT0xLjU3O3ZhciBzdGFydD1SRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7Y3g6b3B0aW9ucy5jeCxjeTpvcHRpb25zLmN5LHI6b3B0aW9ucy5yLGFuZ2xlOm9wdGlvbnMuc3RhcnR9KTt2YXIgZW5kPVJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtjeDpvcHRpb25zLmN4LGN5Om9wdGlvbnMuY3kscjpvcHRpb25zLnIsYW5nbGU6b3B0aW9ucy5lbmR9KTt2YXIgZGlmZj1vcHRpb25zLmVuZC1vcHRpb25zLnN0YXJ0O3ZhciBsYXJnZUFyYz0nMCc7dmFyIHN3ZWVwPScwJztpZihvcHRpb25zLmFudGljbG9ja3dpc2UmJmRpZmY+My4xNCl7bGFyZ2VBcmM9JzAnO3N3ZWVwPScwJzt9ZWxzZSBpZihvcHRpb25zLmFudGljbG9ja3dpc2UmJmRpZmY8PTMuMTQpe2xhcmdlQXJjPScxJztzd2VlcD0nMCc7fWVsc2UgaWYoIW9wdGlvbnMuYW50aWNsb2Nrd2lzZSYmZGlmZj4zLjE0KXtsYXJnZUFyYz0nMSc7c3dlZXA9JzEnO31lbHNlIGlmKCFvcHRpb25zLmFudGljbG9ja3dpc2UmJmRpZmY8PTMuMTQpe2xhcmdlQXJjPScwJztzd2VlcD0nMSc7fVxuaWYob3B0aW9ucy5zdGFydD5vcHRpb25zLmVuZCYmb3B0aW9ucy5hbnRpY2xvY2t3aXNlJiZkaWZmPD0zLjE0KXtsYXJnZUFyYz0nMCc7c3dlZXA9JzAnO31cbmlmKG9wdGlvbnMuc3RhcnQ+b3B0aW9ucy5lbmQmJm9wdGlvbnMuYW50aWNsb2Nrd2lzZSYmZGlmZj4zLjE0KXtsYXJnZUFyYz0nMSc7c3dlZXA9JzEnO31cbmlmKHR5cGVvZiBvcHRpb25zLm1vdmV0bz09PSdib29sZWFuJyYmb3B0aW9ucy5tb3ZldG89PT1mYWxzZSl7dmFyIGQ9W1wiQVwiLG9wdGlvbnMucixvcHRpb25zLnIsMCxsYXJnZUFyYyxzd2VlcCxlbmQueCxlbmQueV07fWVsc2V7dmFyIGQ9W1wiTVwiLHN0YXJ0Lngsc3RhcnQueSxcIkFcIixvcHRpb25zLnIsb3B0aW9ucy5yLDAsbGFyZ2VBcmMsc3dlZXAsZW5kLngsZW5kLnldO31cbmlmKG9wdGlvbnMuYXJyYXk9PT10cnVlKXtyZXR1cm4gZDt9ZWxzZXtyZXR1cm4gZC5qb2luKFwiIFwiKTt9fTtSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMj1mdW5jdGlvbihvcHRpb25zKVxue29wdGlvbnMuc3RhcnQtPTEuNTc7b3B0aW9ucy5lbmQtPTEuNTc7dmFyIHN0YXJ0PVJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtjeDpvcHRpb25zLmN4LGN5Om9wdGlvbnMuY3kscjpvcHRpb25zLnIsYW5nbGU6b3B0aW9ucy5zdGFydH0pO3ZhciBlbmQ9UkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oe2N4Om9wdGlvbnMuY3gsY3k6b3B0aW9ucy5jeSxyOm9wdGlvbnMucixhbmdsZTpvcHRpb25zLmVuZH0pO3ZhciBkaWZmPW1hLmFicyhvcHRpb25zLmVuZC1vcHRpb25zLnN0YXJ0KTt2YXIgbGFyZ2VBcmM9JzAnO3ZhciBzd2VlcD0nMCc7aWYoIW9wdGlvbnMuYW50aWNsb2Nrd2lzZSl7aWYoZGlmZj5SRy5TVkcuVFJJRy5QSSl7bGFyZ2VBcmM9JzEnO3N3ZWVwPScxJzt9ZWxzZXtsYXJnZUFyYz0nMCc7c3dlZXA9JzEnO319ZWxzZXtpZihkaWZmPlJHLlNWRy5UUklHLlBJKXtsYXJnZUFyYz0nMSc7c3dlZXA9JzAnO31lbHNle2xhcmdlQXJjPScwJztzd2VlcD0nMCc7fX1cbmlmKHR5cGVvZiBvcHRpb25zLmxpbmV0bz09PSdib29sZWFuJyYmb3B0aW9ucy5saW5ldG89PT1mYWxzZSl7dmFyIGQ9W1wiTVwiLHN0YXJ0Lngsc3RhcnQueSxcIkFcIixvcHRpb25zLnIsb3B0aW9ucy5yLDAsbGFyZ2VBcmMsc3dlZXAsZW5kLngsZW5kLnldO31lbHNle3ZhciBkPVtcIk1cIixvcHRpb25zLmN4LG9wdGlvbnMuY3ksXCJMXCIsc3RhcnQueCxzdGFydC55LFwiQVwiLG9wdGlvbnMucixvcHRpb25zLnIsMCxsYXJnZUFyYyxzd2VlcCxlbmQueCxlbmQueV07fVxuaWYob3B0aW9ucy5hcnJheT09PXRydWUpe3JldHVybiBkO31lbHNle3JldHVybiBkLmpvaW4oXCIgXCIpO319O1JHLlNWRy5UUklHLmdldEFyY1BhdGgzPWZ1bmN0aW9uKG9wdGlvbnMpXG57b3B0aW9ucy5zdGFydC09MS41NztvcHRpb25zLmVuZC09MS41Nzt2YXIgc3RhcnQ9UkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oe2N4Om9wdGlvbnMuY3gsY3k6b3B0aW9ucy5jeSxyOm9wdGlvbnMucixhbmdsZTpvcHRpb25zLnN0YXJ0fSk7dmFyIGVuZD1SRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7Y3g6b3B0aW9ucy5jeCxjeTpvcHRpb25zLmN5LHI6b3B0aW9ucy5yLGFuZ2xlOm9wdGlvbnMuZW5kfSk7dmFyIGRpZmY9bWEuYWJzKG9wdGlvbnMuZW5kLW9wdGlvbnMuc3RhcnQpO3ZhciBsYXJnZUFyYz0nMCc7dmFyIHN3ZWVwPScwJztpZighb3B0aW9ucy5hbnRpY2xvY2t3aXNlKXtpZihkaWZmPlJHLlNWRy5UUklHLlBJKXtsYXJnZUFyYz0nMSc7c3dlZXA9JzEnO31lbHNle2xhcmdlQXJjPScwJztzd2VlcD0nMSc7fX1lbHNle2lmKGRpZmY+UkcuU1ZHLlRSSUcuUEkpe2xhcmdlQXJjPScxJztzd2VlcD0nMCc7fWVsc2V7bGFyZ2VBcmM9JzAnO3N3ZWVwPScwJzt9fVxuaWYodHlwZW9mIG9wdGlvbnMubGluZXRvPT09J2Jvb2xlYW4nJiZvcHRpb25zLmxpbmV0bz09PWZhbHNlKXt2YXIgZD1bXCJNXCIsc3RhcnQueCxzdGFydC55LFwiQVwiLG9wdGlvbnMucixvcHRpb25zLnIsMCxsYXJnZUFyYyxzd2VlcCxlbmQueCxlbmQueV07fWVsc2V7dmFyIGQ9W1wiTFwiLHN0YXJ0Lngsc3RhcnQueSxcIkFcIixvcHRpb25zLnIsb3B0aW9ucy5yLDAsbGFyZ2VBcmMsc3dlZXAsZW5kLngsZW5kLnldO31cbmlmKG9wdGlvbnMuYXJyYXk9PT10cnVlKXtyZXR1cm4gZDt9ZWxzZXtyZXR1cm4gZC5qb2luKFwiIFwiKTt9fTtSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludD1mdW5jdGlvbihvcHQpXG57aWYoYXJndW1lbnRzLmxlbmd0aD09PTEpe3ZhciBhbmdsZT1vcHQuYW5nbGUscj1vcHQucjt9ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09NCl7dmFyIGFuZ2xlPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt9XG52YXIgeD1tYS5jb3MoYW5nbGUpKnIseT1tYS5zaW4oYW5nbGUpKnI7cmV0dXJuW3gseV07fTtSRy5TVkcuZHJhd1RpdGxlPWZ1bmN0aW9uKG9iailcbnt2YXIgcHJvcD1vYmoucHJvcGVydGllczt2YXIgdmFsaWduPSdib3R0b20nO2lmKG9iai50eXBlPT09J3BpZScpe2lmKFJHLlNWRy5pc051bGwocHJvcC50aXRsZVgpKXtwcm9wLnRpdGxlWD1vYmouY2VudGVyeDtwcm9wLnRpdGxlU3VidGl0bGVYPW9iai5jZW50ZXJ4O31cbmlmKFJHLlNWRy5pc051bGwocHJvcC50aXRsZVkpKXtwcm9wLnRpdGxlWT1vYmouY2VudGVyeS1vYmoucmFkaXVzLTEwO319XG5pZihvYmouc2NhbGUmJm9iai5zY2FsZS5tYXg8PTAmJm9iai5zY2FsZS5taW48MCYmdHlwZW9mIHByb3AudGl0bGVZIT09J251bWJlcicmJm9iai50eXBlIT09J2hiYXInKXtwcm9wLnRpdGxlWT1vYmouaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tKzEwO3ZhciBwb3NpdGlvbkJvdHRvbT10cnVlO3ZhbGlnbj0ndG9wJzt9ZWxzZSBpZih0eXBlb2YgcHJvcC50aXRsZVkhPT0nbnVtYmVyJyl7dmFyIHBvc2l0aW9uQm90dG9tPWZhbHNlO3Byb3AudGl0bGVZPXByb3AuZ3V0dGVyVG9wLTEwO3ZhbGlnbj0nYm90dG9tJztpZighUkcuU1ZHLmlzTnVsbChwcm9wLmtleSkpe3Byb3AudGl0bGVZLT0oMioocHJvcC5rZXlUZXh0U2l6ZXx8cHJvcC50ZXh0U2l6ZSkpO319XG5pZihwcm9wLnRpdGxlU3VidGl0bGUmJnR5cGVvZiBwcm9wLnRpdGxlU3VidGl0bGVZIT09J251bWJlcicmJiFwb3NpdGlvbkJvdHRvbSl7cHJvcC50aXRsZVk9cHJvcC50aXRsZVktKHByb3AudGl0bGVTdWJ0aXRsZVNpemUqMS41KTt9XG5wcm9wLnRpdGxlU3ViVGl0bGVTaXplPXByb3AudGl0bGVTdWJUaXRsZVNpemV8fHByb3AudGV4dFNpemU7cHJvcC50aXRsZVN1YnRpdGxlWT1wcm9wLnRpdGxlU3VidGl0bGVZfHxwcm9wLnRpdGxlWSsxODtpZihwb3NpdGlvbkJvdHRvbSYmdHlwZW9mIHByb3AudGl0bGVTdWJ0aXRsZVkhPT0nbnVtYmVyJyl7cHJvcC50aXRsZVN1YnRpdGxlWT1wcm9wLnRpdGxlWSsyNjt9XG5pZihwcm9wLnRpdGxlKXtSRy5TVkcudGV4dCh7b2JqZWN0Om9iaixzdmc6b2JqLnN2ZyxwYXJlbnQ6b2JqLnN2Zy5hbGwsdGV4dDpwcm9wLnRpdGxlLnRvU3RyaW5nKCksc2l6ZTpwcm9wLnRpdGxlU2l6ZXx8KHByb3AudGV4dFNpemUrNCl8fDE2LHg6dHlwZW9mIHByb3AudGl0bGVYPT09J251bWJlcic/cHJvcC50aXRsZVgrKHByb3AudmFyaWFudDNkT2Zmc2V0eHx8MCk6cHJvcC5ndXR0ZXJMZWZ0KyhvYmouZ3JhcGhXaWR0aC8yKSsocHJvcC52YXJpYW50M2RPZmZzZXR4fHwwKSx5OnByb3AudGl0bGVZKyhwcm9wLnZhcmlhbnQzZE9mZnNldHl8fDApLGhhbGlnbjpwcm9wLnRpdGxlSGFsaWdufHwnY2VudGVyJyx2YWxpZ246cHJvcC50aXRsZVZhbGlnbnx8dmFsaWduLGNvbG9yOnByb3AudGl0bGVDb2xvcnx8cHJvcC50ZXh0Q29sb3J8fCdibGFjaycsYm9sZDpwcm9wLnRpdGxlQm9sZHx8ZmFsc2UsaXRhbGljOnByb3AudGl0bGVJdGFsaWN8fGZhbHNlLGZvbnQ6cHJvcC50aXRsZUZvbnR8fHByb3AudGV4dEZvbnR8fCdBcmlhbCd9KTt9XG5pZihwcm9wLnRpdGxlU3VidGl0bGUpe1JHLlNWRy50ZXh0KHtvYmplY3Q6b2JqLHN2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0ZXh0OnByb3AudGl0bGVTdWJ0aXRsZSxzaXplOnByb3AudGl0bGVTdWJ0aXRsZVNpemUseDp0eXBlb2YgcHJvcC50aXRsZVN1YnRpdGxlWD09PSdudW1iZXInP3Byb3AudGl0bGVTdWJ0aXRsZVg6cHJvcC5ndXR0ZXJMZWZ0KyhvYmouZ3JhcGhXaWR0aC8yKSsocHJvcC52YXJpYW50M2RPZmZzZXR4fHwwKSx5OnByb3AudGl0bGVTdWJ0aXRsZVkrKHByb3AudmFyaWFudDNkT2Zmc2V0eXx8MCksaGFsaWduOnByb3AudGl0bGVTdWJ0aXRsZUhhbGlnbnx8J2NlbnRlcicsdmFsaWduOnByb3AudGl0bGVTdWJ0aXRsZVZhbGlnbnx8dmFsaWduLGNvbG9yOnByb3AudGl0bGVTdWJ0aXRsZUNvbG9yfHxwcm9wLnRleHRDb2xvcnx8JyNhYWEnLGJvbGQ6cHJvcC50aXRsZVN1YnRpdGxlQm9sZHx8ZmFsc2UsaXRhbGljOnByb3AudGl0bGVTdWJ0aXRsZUl0YWxpY3x8ZmFsc2UsZm9udDpwcm9wLnRpdGxlU3VidGl0bGVGb250fHxwcm9wLnRleHRGb250fHwnQXJpYWwnfSk7fX07UkcuU1ZHLnRyaW09ZnVuY3Rpb24oc3RyKVxue3JldHVybiBSRy5TVkcubHRyaW0oUkcuU1ZHLnJ0cmltKHN0cikpO307UkcuU1ZHLmx0cmltPWZ1bmN0aW9uKHN0cilcbntyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvXihcXHN8XFwwKSsvLCcnKTt9O1JHLlNWRy5ydHJpbT1mdW5jdGlvbihzdHIpXG57cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhcXHN8XFwwKSskLywnJyk7fTtSRy5TVkcucGFyc2VDb2xvckxpbmVhcj1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0LGNvbG9yPW9wdC5jb2xvcjtpZighY29sb3J8fHR5cGVvZiBjb2xvciE9PSdzdHJpbmcnKXtyZXR1cm4gY29sb3I7fVxuaWYoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6JyksZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7aWYob3B0JiZvcHQuZGlyZWN0aW9uJiZvcHQuZGlyZWN0aW9uPT09J2hvcml6b250YWwnKXt2YXIgZ3JhZD1SRy5TVkcuY3JlYXRlKHt0eXBlOidsaW5lYXJHcmFkaWVudCcscGFyZW50Om9iai5zdmcuZGVmcyxhdHRyOntpZDonUkdyYXBoLWxpbmVhci1ncmFkaWVudCcrb2JqLmdyYWRpZW50Q291bnRlcix4MTpvcHQuc3RhcnR8fDAseDI6b3B0LmVuZHx8JzEwMCUnLHkxOjAseTI6MCxncmFkaWVudFVuaXRzOlwidXNlclNwYWNlT25Vc2VcIn19KTt9ZWxzZXt2YXIgZ3JhZD1SRy5TVkcuY3JlYXRlKHt0eXBlOidsaW5lYXJHcmFkaWVudCcscGFyZW50Om9iai5zdmcuZGVmcyxhdHRyOntpZDonUkdyYXBoLWxpbmVhci1ncmFkaWVudCcrb2JqLmdyYWRpZW50Q291bnRlcix4MTowLHgyOjAseTE6b3B0LnN0YXJ0fHwwLHkyOm9wdC5lbmR8fCcxMDAlJyxncmFkaWVudFVuaXRzOlwidXNlclNwYWNlT25Vc2VcIn19KTt9XG52YXIgc3RvcD1SRy5TVkcuY3JlYXRlKHt0eXBlOidzdG9wJyxwYXJlbnQ6Z3JhZCxhdHRyOntvZmZzZXQ6JzAlJywnc3RvcC1jb2xvcic6UkcuU1ZHLnRyaW0ocGFydHNbMF0pfX0pO2Zvcih2YXIgaj0xLGxlbj1wYXJ0cy5sZW5ndGg7ajxsZW47KytqKXtSRy5TVkcuY3JlYXRlKHt0eXBlOidzdG9wJyxwYXJlbnQ6Z3JhZCxhdHRyOntvZmZzZXQ6KGoqZGlmZioxMDApKyclJywnc3RvcC1jb2xvcic6UkcuU1ZHLnRyaW0ocGFydHNbal0pfX0pO319XG5jb2xvcj1ncmFkPyd1cmwoI1JHcmFwaC1saW5lYXItZ3JhZGllbnQnKyhvYmouZ3JhZGllbnRDb3VudGVyKyspKycpJzpjb2xvcjtyZXR1cm4gY29sb3I7fTtSRy5TVkcucGFyc2VDb2xvclJhZGlhbD1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0LGNvbG9yPW9wdC5jb2xvcjtpZighY29sb3J8fHR5cGVvZiBjb2xvciE9PSdzdHJpbmcnKXtyZXR1cm4gY29sb3I7fVxuaWYoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKXt2YXIgcGFydHM9UmVnRXhwLiQxLnNwbGl0KCc6JyksZGlmZj0xLyhwYXJ0cy5sZW5ndGgtMSk7dmFyIGdyYWQ9UkcuU1ZHLmNyZWF0ZSh7dHlwZToncmFkaWFsR3JhZGllbnQnLHBhcmVudDpvYmouc3ZnLmRlZnMsYXR0cjp7aWQ6J1JHcmFwaC1yYWRpYWwtZ3JhZGllbnQnK29iai5ncmFkaWVudENvdW50ZXIsZ3JhZGllbnRVbml0czpvcHQuZ3JhZGllbnRVbml0c3x8J3VzZXJTcGFjZU9uVXNlJyxjeDpvcHQuY3h8fG9iai5jZW50ZXJ4LGN5Om9wdC5jeXx8b2JqLmNlbnRlcnksZng6b3B0LmZ4fHxvYmouY2VudGVyeCxmeTpvcHQuZnl8fG9iai5jZW50ZXJ5LHI6b3B0LnJ8fG9iai5yYWRpdXN9fSk7dmFyIHN0b3A9UkcuU1ZHLmNyZWF0ZSh7dHlwZTonc3RvcCcscGFyZW50OmdyYWQsYXR0cjp7b2Zmc2V0OicwJScsJ3N0b3AtY29sb3InOlJHLlNWRy50cmltKHBhcnRzWzBdKX19KTtmb3IodmFyIGo9MSxsZW49cGFydHMubGVuZ3RoO2o8bGVuOysrail7UkcuU1ZHLmNyZWF0ZSh7dHlwZTonc3RvcCcscGFyZW50OmdyYWQsYXR0cjp7b2Zmc2V0OihqKmRpZmYqMTAwKSsnJScsJ3N0b3AtY29sb3InOlJHLlNWRy50cmltKHBhcnRzW2pdKX19KTt9fVxuY29sb3I9Z3JhZD8ndXJsKCNSR3JhcGgtcmFkaWFsLWdyYWRpZW50Jysob2JqLmdyYWRpZW50Q291bnRlcisrKSsnKSc6Y29sb3I7cmV0dXJuIGNvbG9yO307UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcz1mdW5jdGlvbihvcHQpXG57dmFyIG9iaj1vcHQub2JqZWN0O2lmKG9iai5vcmlnaW5hbENvbG9ycyl7Zm9yKHZhciBqIGluIG9iai5vcmlnaW5hbENvbG9ycyl7aWYodHlwZW9mIGo9PT0nc3RyaW5nJyl7b2JqLnByb3BlcnRpZXNbal09UkcuU1ZHLmFycmF5Q2xvbmUob2JqLm9yaWdpbmFsQ29sb3JzW2pdKTt9fX1cbmlmKHR5cGVvZiBvYmoucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzPT09J2Z1bmN0aW9uJyl7b2JqLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcygpO31cbm9iai5vcmlnaW5hbENvbG9ycz17fTtvYmouY29sb3JzUGFyc2VkPWZhbHNlO29iai5ncmFkaWVudENvdW50ZXI9MTt9O1JHLlNWRy5jbGVhcj1mdW5jdGlvbihzdmcpXG57d2hpbGUoc3ZnLmFsbC5sYXN0Q2hpbGQpe3N2Zy5hbGwucmVtb3ZlQ2hpbGQoc3ZnLmFsbC5sYXN0Q2hpbGQpO319O1JHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyPWZ1bmN0aW9uKG9iaixuYW1lLGZ1bmMpXG57aWYodHlwZW9mIFJHLlNWRy5ldmVudHNbb2JqLnVpZF09PT0ndW5kZWZpbmVkJyl7UkcuU1ZHLmV2ZW50c1tvYmoudWlkXT1bXTt9XG5pZihuYW1lLnN1YnN0cigwLDIpIT09J29uJyl7bmFtZT0nb24nK25hbWU7fVxuUkcuU1ZHLmV2ZW50c1tvYmoudWlkXS5wdXNoKHtvYmplY3Q6b2JqLGV2ZW50Om5hbWUsZnVuYzpmdW5jfSk7cmV0dXJuIFJHLlNWRy5ldmVudHNbb2JqLnVpZF0ubGVuZ3RoLTE7fTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50PWZ1bmN0aW9uKG9iaixuYW1lKVxue2lmKG9iaiYmb2JqLmlzUkdyYXBoKXt2YXIgdWlkPW9iai51aWQ7aWYodHlwZW9mIHVpZD09PSdzdHJpbmcnJiZ0eXBlb2YgUkcuU1ZHLmV2ZW50cz09PSdvYmplY3QnJiZ0eXBlb2YgUkcuU1ZHLmV2ZW50c1t1aWRdPT09J29iamVjdCcmJlJHLlNWRy5ldmVudHNbdWlkXS5sZW5ndGg+MCl7Zm9yKHZhciBqPTAsbGVuPVJHLlNWRy5ldmVudHNbdWlkXS5sZW5ndGg7ajxsZW47KytqKXtpZihSRy5TVkcuZXZlbnRzW3VpZF1bal0mJlJHLlNWRy5ldmVudHNbdWlkXVtqXS5ldmVudD09PW5hbWUpe1JHLlNWRy5ldmVudHNbdWlkXVtqXS5mdW5jKG9iaik7fX19fX07UkcuU1ZHLnJlbW92ZUFsbEN1c3RvbUV2ZW50TGlzdGVuZXJzPWZ1bmN0aW9uKClcbnt2YXIgdWlkPWFyZ3VtZW50c1swXTtpZih1aWQmJlJHLlNWRy5ldmVudHNbdWlkXSl7UkcuU1ZHLmV2ZW50c1t1aWRdPXt9O31lbHNle1JHLlNWRy5ldmVudHM9W107fX07UkcuU1ZHLnJlbW92ZUN1c3RvbUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24ob2JqLGkpXG57aWYodHlwZW9mIFJHLlNWRy5ldmVudHM9PT0nb2JqZWN0JyYmdHlwZW9mIFJHLlNWRy5ldmVudHNbb2JqLnVpZF09PT0nb2JqZWN0JyYmdHlwZW9mIFJHLlNWRy5ldmVudHNbb2JqLnVpZF1baV09PT0nb2JqZWN0Jyl7UkcuU1ZHLmV2ZW50c1tvYmoudWlkXVtpXT1udWxsO319O1JHLlNWRy5yZW1vdmVIaWdobGlnaHQ9ZnVuY3Rpb24ob2JqKVxue3ZhciBoaWdobGlnaHQ9UkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO2lmKGhpZ2hsaWdodCYmUkcuU1ZHLmlzQXJyYXkoaGlnaGxpZ2h0KSYmaGlnaGxpZ2h0Lmxlbmd0aCl7Zm9yKHZhciBpPTAsbGVuPWhpZ2hsaWdodC5sZW5ndGg7aTxsZW47KytpKXtpZihoaWdobGlnaHRbaV0ucGFyZW50Tm9kZSl7aGlnaGxpZ2h0W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0W2ldKTt9fX1lbHNlIGlmKGhpZ2hsaWdodCYmaGlnaGxpZ2h0LnBhcmVudE5vZGUpe2lmKG9iai50eXBlPT09J3NjYXR0ZXInKXtoaWdobGlnaHQuc2V0QXR0cmlidXRlKCdmaWxsJywndHJhbnNwYXJlbnQnKTt9ZWxzZXtoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO319fTtSRy5TVkcucmVkcmF3PWZ1bmN0aW9uKClcbntpZihhcmd1bWVudHMubGVuZ3RoPT09MSl7dmFyIHN2Zz1hcmd1bWVudHNbMF07UkcuU1ZHLmNsZWFyKHN2Zyk7dmFyIG9iamVjdHM9UkcuU1ZHLk9SLmdldCgnaWQ6JytzdmcucGFyZW50Tm9kZS5pZCk7Zm9yKHZhciBpPTAsbGVuPW9iamVjdHMubGVuZ3RoO2k8bGVuOysraSl7UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7b2JqZWN0Om9iamVjdHNbaV19KTtvYmplY3RzW2ldLmRyYXcoKTt9fWVsc2V7dmFyIHRhZ3M9UkcuU1ZHLk9SLnRhZ3MoKTtmb3IodmFyIGkgaW4gdGFncyl7UkcuU1ZHLnJlZHJhdyh0YWdzW2ldKTt9fX07UkcuU1ZHLnBhcnNlRGF0ZT1mdW5jdGlvbihzdHIpXG57dmFyIGQ9bmV3IERhdGUoKTt2YXIgZGVmYXVsdHM9e3NlY29uZHM6JzAwJyxtaW51dGVzOicwMCcsaG91cnM6JzAwJyxkYXRlOmQuZ2V0RGF0ZSgpLG1vbnRoOmQuZ2V0TW9udGgoKSsxLHllYXI6ZC5nZXRGdWxsWWVhcigpfTt2YXIgbW9udGhzPVsnamFudWFyeScsJ2ZlYnJ1YXJ5JywnbWFyY2gnLCdhcHJpbCcsJ21heScsJ2p1bmUnLCdqdWx5JywnYXVndXN0Jywnc2VwdGVtYmVyJywnb2N0b2JlcicsJ25vdmVtYmVyJywnZGVjZW1iZXInXSxtb250aHNfcmVnZXg9bW9udGhzLmpvaW4oJ3wnKTtmb3IodmFyIGk9MDtpPG1vbnRocy5sZW5ndGg7KytpKXttb250aHNbbW9udGhzW2ldXT1pO21vbnRoc1ttb250aHNbaV0uc3Vic3RyaW5nKDAsMyldPWk7bW9udGhzX3JlZ2V4PW1vbnRoc19yZWdleCsnfCcrbW9udGhzW2ldLnN1YnN0cmluZygwLDMpO31cbnZhciBzZXA9J1stLi9fPSt+Izo7LF0rJzt2YXIgdG9rZW5zPXN0ci5zcGxpdCgvICsvKTtmb3IodmFyIGk9MCxsZW49dG9rZW5zLmxlbmd0aDtpPGxlbjsrK2kpe2lmKHRva2Vuc1tpXSl7aWYodG9rZW5zW2ldLm1hdGNoKC9eXFxkXFxkXFxkXFxkJC8pKXtkZWZhdWx0cy55ZWFyPXRva2Vuc1tpXTt9XG52YXIgcmVzPWlzTW9udGgodG9rZW5zW2ldKTtpZih0eXBlb2YgcmVzPT09J251bWJlcicpe2RlZmF1bHRzLm1vbnRoPXJlcysxO31cbmlmKHRva2Vuc1tpXS5tYXRjaCgvXlxcZD9cXGQoPzpzdHxuZHxyZHx0aCk/JC8pKXtkZWZhdWx0cy5kYXRlPXBhcnNlSW50KHRva2Vuc1tpXSk7fVxuaWYodG9rZW5zW2ldLm1hdGNoKC9eKFxcZFxcZCk6KFxcZFxcZCkoPzooXFxkXFxkKSk/JC8pKXtkZWZhdWx0cy5ob3Vycz1wYXJzZUludChSZWdFeHAuJDEpO2RlZmF1bHRzLm1pbnV0ZXM9cGFyc2VJbnQoUmVnRXhwLiQyKTtpZihSZWdFeHAuJDMpe2RlZmF1bHRzLnNlY29uZHM9cGFyc2VJbnQoUmVnRXhwLiQzKTt9fVxuaWYodG9rZW5zW2ldLm1hdGNoKG5ldyBSZWdFeHAoJ14oXFxcXGRcXFxcZFxcXFxkXFxcXGQpJytzZXArJyhcXFxcZFxcXFxkKScrc2VwKycoXFxcXGRcXFxcZCkkJywnaScpKSl7ZGVmYXVsdHMuZGF0ZT1wYXJzZUludChSZWdFeHAuJDMpO2RlZmF1bHRzLm1vbnRoPXBhcnNlSW50KFJlZ0V4cC4kMik7ZGVmYXVsdHMueWVhcj1wYXJzZUludChSZWdFeHAuJDEpO31cbmlmKHRva2Vuc1tpXS5tYXRjaChuZXcgUmVnRXhwKCdeKFxcXFxkXFxcXGQpJytzZXArJyhcXFxcZFxcXFxkKScrc2VwKycoXFxcXGRcXFxcZFxcXFxkXFxcXGQpJCcsJ2knKSkpe2RlZmF1bHRzLmRhdGU9cGFyc2VJbnQoUmVnRXhwLiQxKTtkZWZhdWx0cy5tb250aD1wYXJzZUludChSZWdFeHAuJDIpO2RlZmF1bHRzLnllYXI9cGFyc2VJbnQoUmVnRXhwLiQzKTt9fX1cbnN0cj0nezF9L3syfS97M30gezR9Ons1fTp7Nn0nLmZvcm1hdChkZWZhdWx0cy55ZWFyLFN0cmluZyhkZWZhdWx0cy5tb250aCkubGVuZ3RoPT09MT8nMCcrKGRlZmF1bHRzLm1vbnRoKTpkZWZhdWx0cy5tb250aCxTdHJpbmcoZGVmYXVsdHMuZGF0ZSkubGVuZ3RoPT09MT8nMCcrKGRlZmF1bHRzLmRhdGUpOmRlZmF1bHRzLmRhdGUsU3RyaW5nKGRlZmF1bHRzLmhvdXJzKS5sZW5ndGg9PT0xPycwJysoZGVmYXVsdHMuaG91cnMpOmRlZmF1bHRzLmhvdXJzLFN0cmluZyhkZWZhdWx0cy5taW51dGVzKS5sZW5ndGg9PT0xPycwJysoZGVmYXVsdHMubWludXRlcyk6ZGVmYXVsdHMubWludXRlcyxTdHJpbmcoZGVmYXVsdHMuc2Vjb25kcykubGVuZ3RoPT09MT8nMCcrKGRlZmF1bHRzLnNlY29uZHMpOmRlZmF1bHRzLnNlY29uZHMpO3JldHVybiBEYXRlLnBhcnNlKHN0cik7ZnVuY3Rpb24gaXNNb250aChzdHIpXG57dmFyIHJlcz1zdHIudG9Mb3dlckNhc2UoKS5tYXRjaChtb250aHNfcmVnZXgpO3JldHVybiByZXM/bW9udGhzW3Jlc1swXV06ZmFsc2U7fX07UkcuU1ZHLk9SLmFkZD1mdW5jdGlvbihvYmopXG57UkcuU1ZHLk9SLm9iamVjdHMucHVzaChvYmopO3JldHVybiBvYmo7fTtSRy5TVkcuT1IuZ2V0PWZ1bmN0aW9uKClcbntpZih0eXBlb2YgYXJndW1lbnRzWzBdPT09J3N0cmluZycmJmFyZ3VtZW50c1swXS5zdWJzdHIoMCwzKS50b0xvd2VyQ2FzZSgpPT09J2lkOicpe3ZhciByZXQ9W107Zm9yKHZhciBpPTA7aTxSRy5TVkcuT1Iub2JqZWN0cy5sZW5ndGg7KytpKXtpZihSRy5TVkcuT1Iub2JqZWN0c1tpXS5pZD09PWFyZ3VtZW50c1swXS5zdWJzdHIoMykpe3JldC5wdXNoKFJHLlNWRy5PUi5vYmplY3RzW2ldKTt9fVxucmV0dXJuIHJldDt9XG5pZih0eXBlb2YgYXJndW1lbnRzWzBdPT09J3N0cmluZycmJmFyZ3VtZW50c1swXS5zdWJzdHIoMCw0KS50b0xvd2VyQ2FzZSgpPT09J3R5cGUnKXt2YXIgcmV0PVtdO2Zvcih2YXIgaT0wO2k8UkcuU1ZHLk9SLm9iamVjdHMubGVuZ3RoOysraSl7aWYoUkcuU1ZHLk9SLm9iamVjdHNbaV0udHlwZT09PWFyZ3VtZW50c1swXS5zdWJzdHIoNSkpe3JldC5wdXNoKFJHLlNWRy5PUi5vYmplY3RzW2ldKTt9fVxucmV0dXJuIHJldDt9XG5pZih0eXBlb2YgYXJndW1lbnRzWzBdPT09J3N0cmluZycmJmFyZ3VtZW50c1swXS5zdWJzdHIoMCwzKS50b0xvd2VyQ2FzZSgpPT09J3VpZCcpe3ZhciByZXQ9W107Zm9yKHZhciBpPTA7aTxSRy5TVkcuT1Iub2JqZWN0cy5sZW5ndGg7KytpKXtpZihSRy5TVkcuT1Iub2JqZWN0c1tpXS51aWQ9PT1hcmd1bWVudHNbMF0uc3Vic3RyKDQpKXtyZXQucHVzaChSRy5TVkcuT1Iub2JqZWN0c1tpXSk7fX1cbnJldHVybiByZXQ7fVxucmV0dXJuIFJHLlNWRy5PUi5vYmplY3RzO307UkcuU1ZHLk9SLnRhZ3M9ZnVuY3Rpb24oKVxue3ZhciB0YWdzPVtdO2Zvcih2YXIgaT0wO2k8UkcuU1ZHLk9SLm9iamVjdHMubGVuZ3RoOysraSl7aWYoIXRhZ3NbUkcuU1ZHLk9SLm9iamVjdHNbaV0uc3ZnLnBhcmVudE5vZGUuaWRdKXt0YWdzW1JHLlNWRy5PUi5vYmplY3RzW2ldLnN2Zy5wYXJlbnROb2RlLmlkXT1SRy5TVkcuT1Iub2JqZWN0c1tpXS5zdmc7fX1cbnJldHVybiB0YWdzO307UkcuU1ZHLmdldFNWR1hZPWZ1bmN0aW9uKHN2Zylcbnt2YXIgeD0wLHk9MCxlbD1zdmcucGFyZW50Tm9kZTtkb3t4Kz1lbC5vZmZzZXRMZWZ0O3krPWVsLm9mZnNldFRvcDtpZihlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PSd0YWJsZScmJihSRy5TVkcuSVNDSFJPTUV8fFJHLlNWRy5JU1NBRkFSSSkpe3grPXBhcnNlSW50KGVsLmJvcmRlcil8fDA7eSs9cGFyc2VJbnQoZWwuYm9yZGVyKXx8MDt9XG5lbD1lbC5vZmZzZXRQYXJlbnQ7fXdoaWxlKGVsJiZlbC50YWdOYW1lJiZlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkhPSdib2R5Jyk7dmFyIHBhZGRpbmdMZWZ0PXN2Zy5zdHlsZS5wYWRkaW5nTGVmdD9wYXJzZUludChzdmcuc3R5bGUucGFkZGluZ0xlZnQpOjAscGFkZGluZ1RvcD1zdmcuc3R5bGUucGFkZGluZ1RvcD9wYXJzZUludChzdmcuc3R5bGUucGFkZGluZ1RvcCk6MCxib3JkZXJMZWZ0PXN2Zy5zdHlsZS5ib3JkZXJMZWZ0V2lkdGg/cGFyc2VJbnQoc3ZnLnN0eWxlLmJvcmRlckxlZnRXaWR0aCk6MCxib3JkZXJUb3A9c3ZnLnN0eWxlLmJvcmRlclRvcFdpZHRoP3BhcnNlSW50KHN2Zy5zdHlsZS5ib3JkZXJUb3BXaWR0aCk6MDtpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKT4wKXt4Kz1wYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmJvcmRlckxlZnRXaWR0aCl8fDA7eSs9cGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJUb3BXaWR0aCl8fDA7fVxucmV0dXJuW3grcGFkZGluZ0xlZnQrYm9yZGVyTGVmdCx5K3BhZGRpbmdUb3ArYm9yZGVyVG9wXTt9O1JHLlNWRy5GWC51cGRhdGU9ZnVuY3Rpb24oZnVuYylcbnt3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbi5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luLm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8KGZ1bmN0aW9uKGZ1bmMpe3NldFRpbWVvdXQoZnVuYywxNi42NjYpO30pO3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuYyk7fTtSRy5TVkcuRlguZ2V0RWFzaW5nTXVsdGlwbGllcj1mdW5jdGlvbihmcmFtZXMsZnJhbWUpXG57dmFyIG11bHRpcGxpZXI9bWEucG93KG1hLnNpbigoZnJhbWUvZnJhbWVzKSpSRy5TVkcuVFJJRy5IQUxGUEkpLDMpO3JldHVybiBtdWx0aXBsaWVyO307UkcuU1ZHLm1lYXN1cmVUZXh0PWZ1bmN0aW9uKG9wdClcbnt2YXIgdGV4dD1vcHQudGV4dHx8JycsYm9sZD1vcHQuYm9sZHx8ZmFsc2UsZm9udD1vcHQuZm9udHx8J0FyaWFsJyxzaXplPW9wdC5zaXplfHwxMCxzdHI9dGV4dCsnOicrYm9sZCsnOicrZm9udCsnOicrc2l6ZTtpZih0eXBlb2YgUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlPT09J3VuZGVmaW5lZCcpe1JHLlNWRy5tZWFzdXJldGV4dF9jYWNoZT1bXTt9XG5pZih0eXBlb2YgUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlPT0nb2JqZWN0JyYmUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlW3N0cl0pe3JldHVybiBSRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbc3RyXTt9XG5pZighUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlWyd0ZXh0LXNwYW4nXSl7dmFyIHNwYW49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU1BBTicpO3NwYW4uc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztzcGFuLnN0eWxlLnBhZGRpbmc9MDtzcGFuLnN0eWxlLmRpc3BsYXk9J2lubGluZSc7c3Bhbi5zdHlsZS50b3A9Jy0yMDBweCc7c3Bhbi5zdHlsZS5sZWZ0PSctMjAwcHgnO3NwYW4uc3R5bGUubGluZUhlaWdodD0nMWVtJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwYW4pO1JHLlNWRy5tZWFzdXJldGV4dF9jYWNoZVsndGV4dC1zcGFuJ109c3Bhbjt9ZWxzZSBpZihSRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtc3BhbiddKXt2YXIgc3Bhbj1SRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtc3BhbiddO31cbnNwYW4uaW5uZXJIVE1MPXRleHQucmVwbGFjZSgvXFxyXFxuL2csJzxiciAvPicpO3NwYW4uc3R5bGUuZm9udEZhbWlseT1mb250O3NwYW4uc3R5bGUuZm9udFdlaWdodD1ib2xkPydib2xkJzonbm9ybWFsJztzcGFuLnN0eWxlLmZvbnRTaXplPXNpemUrJ3B0Jzt2YXIgc2l6ZXM9W3NwYW4ub2Zmc2V0V2lkdGgsc3Bhbi5vZmZzZXRIZWlnaHRdO1JHLlNWRy5tZWFzdXJldGV4dF9jYWNoZVtzdHJdPXNpemVzO3JldHVybiBzaXplczt9O1JHLlNWRy5zdHJpbmdzVG9OdW1iZXJzPWZ1bmN0aW9uKHN0cilcbnt2YXIgc2VwPWFyZ3VtZW50c1sxXXx8JywnO2lmKHR5cGVvZiBzdHI9PT0nbnVtYmVyJyl7cmV0dXJuIHN0cjt9XG5pZih0eXBlb2Ygc3RyPT09J3N0cmluZycpe2lmKHN0ci5pbmRleE9mKHNlcCkhPS0xKXtzdHI9c3RyLnNwbGl0KHNlcCk7fWVsc2V7c3RyPXBhcnNlRmxvYXQoc3RyKTt9fVxuaWYodHlwZW9mIHN0cj09PSdvYmplY3QnKXtmb3IodmFyIGk9MCxsZW49c3RyLmxlbmd0aDtpPGxlbjtpKz0xKXtzdHJbaV09cGFyc2VGbG9hdChzdHJbaV0pO319XG5yZXR1cm4gc3RyO307UkcuU1ZHLmdldEFkanVzdGVkTnVtYmVyPWZ1bmN0aW9uKG9wdClcbnt2YXIgdmFsdWU9b3B0LnZhbHVlLHByb3A9b3B0LnByb3A7aWYodHlwZW9mIHByb3A9PT0nc3RyaW5nJyYmbWF0Y2goL14oXFwrfC0pKFswLTkuXSspLykpe2lmKFJlZ0V4cC4kMT09PScrJyl7dmFsdWUrPXBhcnNlRmxvYXQoUmVnRXhwLiQyKTt9ZWxzZSBpZihSZWdFeHAuJDE9PT0nLScpe3ZhbHVlLT1wYXJzZUZsb2F0KFJlZ0V4cC4kMik7fX1cbnJldHVybiB2YWx1ZTt9O1JHLlNWRy5hdHRyaWJ1dGlvbj1mdW5jdGlvbihvYmopXG57cmV0dXJuO307UkcuU1ZHLnBhcnNlR3JhZGllbnQ9ZnVuY3Rpb24oc3RyKVxue307UkcuU1ZHLnJhbmRvbT1mdW5jdGlvbihvcHQpXG57dmFyIG1pbj1vcHQubWluLG1heD1vcHQubWF4LGRwPW9wdC5kcHx8b3B0LmRlY2ltYWxzfHwwLHI9bWEucmFuZG9tKCk7cmV0dXJuIE51bWJlcigoKChtYXgtbWluKSpyKSttaW4pLnRvRml4ZWQoZHApKTt9O1JHLlNWRy5hcnJheVJhbmQ9UkcuU1ZHLmFycmF5UmFuZG9tPVJHLlNWRy5yYW5kb20uYXJyYXk9ZnVuY3Rpb24ob3B0KVxue3ZhciBudW09b3B0Lm51bSxtaW49b3B0Lm1pbixtYXg9b3B0Lm1heCxkcD1vcHQuZHB8fG9wdC5kZWNpbWFsc3x8MDtmb3IodmFyIGk9MCxhcnI9W107aTxudW07aSs9MSl7YXJyLnB1c2goUkcuU1ZHLnJhbmRvbSh7bWluOm1pbixtYXg6bWF4LGRwOmRwfSkpO31cbnJldHVybiBhcnI7fTtSRy5TVkcuY29tbW9uU2V0dGVyPWZ1bmN0aW9uKG9wdClcbnt2YXIgb2JqPW9wdC5vYmplY3QsbmFtZT1vcHQubmFtZSx2YWx1ZT1vcHQudmFsdWU7aWYobmFtZT09PSd0b29sdGlwc0V2ZW50JyYmdmFsdWUhPT0nY2xpY2snJiZ2YWx1ZSE9PSdtb3VzZW1vdmUnKXt2YWx1ZT0nY2xpY2snO31cbnJldHVybntuYW1lOm5hbWUsdmFsdWU6dmFsdWV9O307UkcuU1ZHLmxvZz1mdW5jdGlvbihvcHQpXG57dmFyIG51bT1vcHQubnVtLGJhc2U9b3B0LmJhc2U7cmV0dXJuIG1hLmxvZyhudW0pLyhiYXNlP21hLmxvZyhiYXNlKToxKTt9O1JHLlNWRy5kb251dD1mdW5jdGlvbihvcHQpXG57dmFyIGFyY1BhdGgxPVJHLlNWRy5UUklHLmdldEFyY1BhdGgzKHtjeDpvcHQuY3gsY3k6b3B0LmN5LHI6b3B0Lm91dGVyUmFkaXVzLHN0YXJ0OjAsZW5kOlJHLlNWRy5UUklHLlRXT1BJLGFudGljbG9ja3dpc2U6ZmFsc2UsbGluZXRvOmZhbHNlfSk7dmFyIGFyY1BhdGgyPVJHLlNWRy5UUklHLmdldEFyY1BhdGgzKHtjeDpvcHQuY3gsY3k6b3B0LmN5LHI6b3B0LmlubmVyUmFkaXVzLHN0YXJ0OlJHLlNWRy5UUklHLlRXT1BJLGVuZDowLGFudGljbG9ja3dpc2U6dHJ1ZSxsaW5ldG86ZmFsc2V9KTt2YXIgcGF0aD1SRy5TVkcuY3JlYXRlKHtzdmc6b3B0LnN2Zyx0eXBlOidwYXRoJyxhdHRyOntkOmFyY1BhdGgxK2FyY1BhdGgyLHN0cm9rZTpvcHQuc3Ryb2tlLGZpbGw6b3B0LmZpbGx9fSk7cmV0dXJuIHBhdGg7fTtpZih0eXBlb2YgUkcuU1ZHLnRvb2x0aXAhPT0nZnVuY3Rpb24nKXtSRy5TVkcudG9vbHRpcD1mdW5jdGlvbigpXG57JGEoJ1RoZSB0b29sdGlwIGxpYnJhcnkgaGFzIG5vdCBiZWVuIGluY2x1ZGVkIScpO307fX0pKHdpbmRvdyxkb2N1bWVudCk7d2luZG93LiRwPWZ1bmN0aW9uKG9iailcbnt2YXIgaW5kZW50PShhcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOicgICAgJyk7dmFyIHN0cj0nJzt2YXIgY291bnRlcj10eXBlb2YgYXJndW1lbnRzWzNdPT0nbnVtYmVyJz9hcmd1bWVudHNbM106MDtpZihjb3VudGVyPj01KXtyZXR1cm4nJzt9XG5zd2l0Y2godHlwZW9mIG9iail7Y2FzZSdzdHJpbmcnOnN0cis9b2JqKycgKCcrKHR5cGVvZiBvYmopKycsICcrb2JqLmxlbmd0aCsnKSc7YnJlYWs7Y2FzZSdudW1iZXInOnN0cis9b2JqKycgKCcrKHR5cGVvZiBvYmopKycpJzticmVhaztjYXNlJ2Jvb2xlYW4nOnN0cis9b2JqKycgKCcrKHR5cGVvZiBvYmopKycpJzticmVhaztjYXNlJ2Z1bmN0aW9uJzpzdHIrPSdmdW5jdGlvbiAoKSB7fSc7YnJlYWs7Y2FzZSd1bmRlZmluZWQnOnN0cis9J3VuZGVmaW5lZCc7YnJlYWs7Y2FzZSdudWxsJzpzdHIrPSdudWxsJzticmVhaztjYXNlJ29iamVjdCc6aWYoUkdyYXBoLlNWRy5pc051bGwob2JqKSl7c3RyKz1pbmRlbnQrJ251bGxcXG4nO31lbHNle3N0cis9aW5kZW50KydPYmplY3QgeycrJ1xcbidcbmZvcihqIGluIG9iail7c3RyKz1pbmRlbnQrJyAgICAnK2orJyA9PiAnK3dpbmRvdy4kcChvYmpbal0sdHJ1ZSxpbmRlbnQrJyAgICAnLGNvdW50ZXIrMSkrJ1xcbic7fVxuc3RyKz1pbmRlbnQrJ30nO31cbmJyZWFrO2RlZmF1bHQ6c3RyKz0nVW5rbm93biB0eXBlOiAnK3R5cGVvZiBvYmorJyc7YnJlYWs7fVxuaWYoIWFyZ3VtZW50c1sxXSl7YWxlcnQoc3RyKTt9XG5yZXR1cm4gc3RyO307d2luZG93LiRhPWZ1bmN0aW9uKHYpXG57YWxlcnQodik7fTt3aW5kb3cuJGNsPWZ1bmN0aW9uKHYpXG57cmV0dXJuIGNvbnNvbGUubG9nKHYpO307aWYoIVN0cmluZy5wcm90b3R5cGUuZm9ybWF0KXtTdHJpbmcucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbigpXG57dmFyIGFyZ3M9YXJndW1lbnRzO3JldHVybiB0aGlzLnJlcGxhY2UoL3soXFxkKyl9L2csZnVuY3Rpb24oc3RyLGlkeClcbntyZXR1cm4gdHlwZW9mIGFyZ3NbaWR4LTFdIT09J3VuZGVmaW5lZCc/YXJnc1tpZHgtMV06c3RyO30pO307fVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24uY29yZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///236\n");

/***/ }),
/* 237 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.SVG.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5jc3YuanM/NzU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLkNTVj1mdW5jdGlvbih1cmwsZnVuYylcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aDt0aGlzLnVybD11cmw7dGhpcy5yZWFkeT1mdW5jO3RoaXMuZGF0YT1udWxsO3RoaXMubnVtcm93cz1udWxsO3RoaXMubnVtY29scz1udWxsO3RoaXMuc2VwZXJhdG9yPWFyZ3VtZW50c1syXXx8JywnO3RoaXMuZW5kb2ZsaW5lPWFyZ3VtZW50c1szXXx8L1xccj9cXG4vO3RoaXMuc3BsaXRDU1Y9ZnVuY3Rpb24oc3RyLHNwbGl0KVxue3ZhciBhcnI9W107dmFyIGZpZWxkPScnO3ZhciBpbkRvdWJsZVF1b3Rlcz1mYWxzZTt2YXIgaW5TaW5nbGVRdW90ZXM9ZmFsc2U7dmFyIHByZXNlcnZlPSh0eXBlb2Ygc3BsaXQ9PT0nb2JqZWN0JyYmc3BsaXQucHJlc2VydmUpP3RydWU6ZmFsc2U7aWYodHlwZW9mIHNwbGl0PT09J29iamVjdCcpe2lmKHR5cGVvZiBzcGxpdC5jaGFyPT09J3N0cmluZycpe3NwbGl0PXNwbGl0LmNoYXI7fWVsc2V7c3BsaXQ9JywnO319XG5mb3IodmFyIGk9MCxsZW49c3RyLmxlbmd0aDtpPGxlbjtpKz0xKXtjaGFyPXN0ci5jaGFyQXQoaSk7aWYoKGNoYXI9PT0nXCInKSYmIWluRG91YmxlUXVvdGVzKXtpbkRvdWJsZVF1b3Rlcz10cnVlO2NvbnRpbnVlO31lbHNlIGlmKChjaGFyPT09J1wiJykmJmluRG91YmxlUXVvdGVzKXtpbkRvdWJsZVF1b3Rlcz1mYWxzZTtjb250aW51ZTt9XG5pZigoY2hhcj09PVwiJ1wiKSYmIWluU2luZ2xlUXVvdGVzKXtpblNpbmdsZVF1b3Rlcz10cnVlO2NvbnRpbnVlO31lbHNlIGlmKChjaGFyPT09XCInXCIpJiZpblNpbmdsZVF1b3Rlcyl7aW5TaW5nbGVRdW90ZXM9ZmFsc2U7Y29udGludWU7fWVsc2UgaWYoY2hhcj09PXNwbGl0JiYhaW5Eb3VibGVRdW90ZXMmJiFpblNpbmdsZVF1b3Rlcyl7YXJyLnB1c2goZmllbGQpO2ZpZWxkPScnO2NvbnRpbnVlO31lbHNle2ZpZWxkPWZpZWxkK2NoYXI7fX1cbmFyci5wdXNoKGZpZWxkKTtpZighcHJlc2VydmUpe2ZvcihpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47aSs9MSl7YXJyW2ldPWFycltpXS50cmltKCk7fX1cbnJldHVybiBhcnI7fTt0aGlzLmZldGNoPWZ1bmN0aW9uKClcbnt2YXIgc2VwPXRoaXMuc2VwZXJhdG9yLGVvbD10aGlzLmVuZG9mbGluZSxvYmo9dGhpcztpZih0aGlzLnVybC5zdWJzdHJpbmcoMCwzKT09PSdpZDonfHx0aGlzLnVybC5zdWJzdHJpbmcoMCw0KT09PSdzdHI6Jyl7aWYodGhpcy51cmwuc3Vic3RyaW5nKDAsMyk9PT0naWQ6Jyl7dmFyIGRhdGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy51cmwuc3Vic3RyaW5nKDMpKS5pbm5lckhUTUwudHJpbSgpO31lbHNlIGlmKHRoaXMudXJsLnN1YnN0cmluZygwLDQpPT09J3N0cjonKXt2YXIgZGF0YT10aGlzLnVybC5zdWJzdHJpbmcoNCkudHJpbSgpO31cbm9iai5kYXRhPWRhdGEuc3BsaXQoZW9sKTtvYmoubnVtcm93cz1vYmouZGF0YS5sZW5ndGg7Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjtpKz0xKXt2YXIgcm93PW9iai5zcGxpdENTVihvYmouZGF0YVtpXSx7cHJlc2VydmU6ZmFsc2UsY2hhcjpzZXB9KTtpZighb2JqLm51bWNvbHMpe29iai5udW1jb2xzPXJvdy5sZW5ndGg7fVxuZm9yKHZhciBqPTA7ajxyb3cubGVuZ3RoO2orPTEpe2lmKCgvXlxcLT9bMC05Ll0rJC8pLnRlc3Qocm93W2pdKSl7cm93W2pdPXBhcnNlRmxvYXQocm93W2pdKTt9XG5vYmouZGF0YVtpXT1yb3c7fX1cbm9iai5yZWFkeShvYmopO31lbHNle1JHcmFwaC5TVkcuQUpBWC5nZXRTdHJpbmcodGhpcy51cmwsZnVuY3Rpb24oZGF0YSlcbntkYXRhPWRhdGEucmVwbGFjZSgvKFxccj9cXG4pKyQvLCcnKTtvYmouZGF0YT1kYXRhLnNwbGl0KGVvbCk7b2JqLm51bXJvd3M9b2JqLmRhdGEubGVuZ3RoO2Zvcih2YXIgaT0wLGxlbj1vYmouZGF0YS5sZW5ndGg7aTxsZW47aSs9MSl7dmFyIHJvdz1vYmouc3BsaXRDU1Yob2JqLmRhdGFbaV0se3ByZXNlcnZlOmZhbHNlLGNoYXI6c2VwfSk7aWYoIW9iai5udW1jb2xzKXtvYmoubnVtY29scz1yb3cubGVuZ3RoO31cbmZvcih2YXIgaj0wO2o8cm93Lmxlbmd0aDtqKz0xKXtpZigoL15cXC0/WzAtOS5dKyQvKS50ZXN0KHJvd1tqXSkpe3Jvd1tqXT1wYXJzZUZsb2F0KHJvd1tqXSk7fVxub2JqLmRhdGFbaV09cm93O319XG5vYmoucmVhZHkob2JqKTt9KTt9fTt0aGlzLmdldFJvdz1mdW5jdGlvbihpbmRleClcbnt2YXIgcm93PVtdO3ZhciBzdGFydD1hcmd1bWVudHNbMV18fDA7Zm9yKHZhciBpPXN0YXJ0O2k8dGhpcy5udW1jb2xzO2krPTEpe3Jvdy5wdXNoKHRoaXMuZGF0YVtpbmRleF1baV0pO31cbnJldHVybiByb3c7fTt0aGlzLmdldENvbD10aGlzLmdldENvbHVtbj1mdW5jdGlvbihpbmRleClcbnt2YXIgY29sPVtdO3ZhciBzdGFydD1hcmd1bWVudHNbMV18fDA7Zm9yKHZhciBpPXN0YXJ0O2k8dGhpcy5udW1yb3dzO2krPTEpe2NvbC5wdXNoKHRoaXMuZGF0YVtpXVtpbmRleF0pO31cbnJldHVybiBjb2w7fTt0aGlzLmZldGNoKCk7fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmNzdi5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///237\n");

/***/ }),
/* 238 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.FX.decorate = function (obj) {\n    for (i in RG.SVG.FX) {\n      if (typeof RG.SVG.FX[i] === 'function') {\n        obj[i] = RG.SVG.FX[i];\n      }\n    }\n  };RG.SVG.FX.fadein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};obj.svg.style.opacity = 0;RG.SVG.redraw(this.svg);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeslidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(this.container));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadeslideout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularinoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 1,\n        radius = 0,\n        svgXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadecircularinoutwards_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, ' + color + ' ' + radius + '%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, transparent 0%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularininwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(obj.container.offsetWidth, obj.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutinwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(this.container.offsetWidth, this.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + this.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.reveal = function () {\n    var obj = this,\n        opt = arguments[0] || {};\n    color = opt.color || 'white', frames = opt.frames || 90, duration = frames / 60 * 1000, callback = opt.callback || function () {};\n    var divs = [['rgraph_reveal_left_' + this.id, 0, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_right_' + this.id, this.container.offsetWidth / 2, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_top_' + this.id, 0, 0, this.container.offsetWidth, this.container.offsetHeight / 2], ['rgraph_reveal_bottom_' + this.id, 0, this.container.offsetHeight / 2, this.container.offsetWidth, this.container.offsetHeight / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    RG.SVG.redraw(obj.svg);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + this.container.offsetWidth / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + this.container.offsetHeight / 2, height: 0 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.conceal = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        duration = frames / 60 * 1000,\n        frame = 0;var divs = [['rgraph_conceal_left_' + obj.id, 0, 0, 0, this.container.offsetHeight], ['rgraph_conceal_right_' + obj.id, this.container.offsetWidth, 0, 0, this.container.offsetHeight], ['rgraph_conceal_top_' + obj.id, 0, 0, this.container.offsetWidth, 0], ['rgraph_conceal_bottom_' + obj.id, 0, this.container.offsetHeight, this.container.offsetWidth, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + this.container.offsetWidth / 2, width: this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + this.container.offsetHeight / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + this.container.offsetHeight / 2, height: this.container.offsetHeight / 2 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.SVG.clear(obj.svg);callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color = 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.SVG.FX.vblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(obj.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;obj.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.vblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.width = 0;div.style.height = this.container.offsetHeight + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.slidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10,\n        from = opt.from || 'left';this.container.style.overflow = 'hidden';RG.SVG.redraw(this.svg);this.svg.style.position = 'relative';if (from == 'left') {\n      this.svg.style.left = 0 - this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    } else if (from == 'top') {\n      this.svg.style.left = 0;this.svg.style.top = 0 - this.container.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      this.svg.style.left = 0;this.svg.style.top = this.container.offsetHeight + 'px';\n    } else {\n      this.svg.style.left = this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    }\n    jQuery(this.svg).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.SVG.FX.slideout = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        width = this.container.offetsWidth / 10;this.container.style.overflow = 'hidden';this.svg.style.position = 'relative';this.svg.style.left = 0;this.svg.style.top = 0;if (to == 'left') {\n      jQuery(this.svg).animate({ left: 0 - this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'top') {\n      jQuery(this.svg).animate({ left: 0, top: 0 - this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'bottom') {\n      jQuery(this.svg).animate({ top: 0 + this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else {\n      jQuery(this.svg).animate({ left: 0 + this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    }\n    return this;\n  };RG.SVG.FX.hscissorsopen = function () {\n    var opt = arguments[0] || {},\n        obj = this,\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        frame = 0,\n        duration = frames / 60 * 1000,\n        width = this.container.offsetWidth / 10,\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: this.container.offsetWidth + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 60,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? this.container.offsetWidth : 0) + 'px';div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: 0, width: this.container.offsetWidth + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: this.container.offsetWidth + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(this.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: this.container.offsetHeight + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = width * i + 'px';div.style.top = (i % 2 == 0 ? this.container.offsetHeight : 0) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: 0, height: this.container.offsetHeight + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: this.container.offsetHeight + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5meC5qcz85MmNhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguU1ZHPVJHcmFwaC5TVkd8fHt9O1JHcmFwaC5TVkcuRlg9UkdyYXBoLlNWRy5GWHx8e307KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLlNWRy5GWC5kZWNvcmF0ZT1mdW5jdGlvbihvYmopXG57Zm9yKGkgaW4gUkcuU1ZHLkZYKXtpZih0eXBlb2YgUkcuU1ZHLkZYW2ldPT09J2Z1bmN0aW9uJyl7b2JqW2ldPVJHLlNWRy5GWFtpXTt9fX07UkcuU1ZHLkZYLmZhZGVpbj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwLGZyYW1lPTAsY2FsbGJhY2s9b3B0LmNhbGxiYWNrfHxmdW5jdGlvbigpe307b2JqLnN2Zy5zdHlsZS5vcGFjaXR5PTA7UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7Zm9yKHZhciBpPTE7aTw9ZnJhbWVzOysraSl7KGZ1bmN0aW9uKGluZGV4KVxue3NldFRpbWVvdXQoZnVuY3Rpb24oKVxue29iai5zdmcuc3R5bGUub3BhY2l0eT0oaW5kZXgvZnJhbWVzKTtpZihpbmRleD49ZnJhbWVzKXtjYWxsYmFjayhvYmopO319LChpbmRleC9mcmFtZXMpKmR1cmF0aW9uKTt9KShpKX1cbnJldHVybiB0aGlzO307UkcuU1ZHLkZYLmZhZGVvdXQ9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9O2Zvcih2YXIgaT0xO2k8PWZyYW1lczsrK2kpeyhmdW5jdGlvbihpbmRleClcbntzZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntvYmouc3ZnLnN0eWxlLm9wYWNpdHk9MS0oaW5kZXgvZnJhbWVzKTtpZihpbmRleD49ZnJhbWVzKXtjYWxsYmFjayhvYmopO319LChpbmRleC9mcmFtZXMpKmR1cmF0aW9uKTt9KShpKX1cbnJldHVybiB0aGlzO307UkcuU1ZHLkZYLmZhZGVzbGlkZWluPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGZyYW1lPTAscGM9LTIwLHN0ZXA9KDEyMC1wYykvZnJhbWVzLGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyx3aWR0aD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxoZWlnaHQ9dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9O1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKydcIj48L2Rpdj4nKS5jc3Moe2JhY2tncm91bmQ6J2xpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJytwYysnJSwgJytjb2xvcisnICcrKHBjKzIwKSsnJSknLHdpZHRoOndpZHRoKydweCcsaGVpZ2h0OmhlaWdodCsncHgnLHRvcDowLGxlZnQ6MCxwb3NpdGlvbjonYWJzb2x1dGUnfSkuYXBwZW5kVG8oJCh0aGlzLmNvbnRhaW5lcikpO2Z1bmN0aW9uIGl0ZXJhdG9yKClcbntpZihwYzwxMjApeyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5jc3Moe2JhY2tncm91bmQ6J2xpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJytwYysnJSwgJytjb2xvcisnICcrKHBjKzIwKSsnJSknfSk7cGMrPXN0ZXA7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7fWVsc2V7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguZmFkZXNsaWRlb3V0PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGZyYW1lPTAscGM9LTIwLHN0ZXA9KDEyMC1wYykvZnJhbWVzLGNhbnZhc1hZPVJHLlNWRy5nZXRTVkdYWShvYmouc3ZnKSxjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZScsd2lkdGg9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCsnXCI+PC9kaXY+JykuY3NzKHtiYWNrZ3JvdW5kOidsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAnK2NvbG9yKycgJytwYysnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnKyhwYysyMCkrJyUpJyx3aWR0aDp3aWR0aCsncHgnLGhlaWdodDpoZWlnaHQrJ3B4Jyx0b3A6MCxsZWZ0OjAscG9zaXRpb246J2Fic29sdXRlJ30pLmFwcGVuZFRvKCQob2JqLnN2Zy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue2lmKHBjPDEyMCl7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLmNzcyh7YmFja2dyb3VuZDonbGluZWFyLWdyYWRpZW50KDEzNWRlZywgJytjb2xvcisnICcrcGMrJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJysocGMrMjApKyclKSd9KTtwYys9c3RlcDtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTt9ZWxzZXtSRy5TVkcuY2xlYXIob2JqLnN2Zyk7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguZmFkZWNpcmN1bGFyaW5vdXR3YXJkcz1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxmcmFtZT0xLHJhZGl1cz0wLHN2Z1hZPVJHLlNWRy5nZXRTVkdYWShvYmouc3ZnKSxjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZScsY2FsbGJhY2s9b3B0LmNhbGxiYWNrfHxmdW5jdGlvbigpe307UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7JCgnPGRpdiBpZD1cInJncmFwaF9mYWRlY2lyY3VsYXJpbm91dHdhcmRzX2NvdmVyXycrb2JqLmlkKydcIj48L2Rpdj4nKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCAnK2NvbG9yKycgJytyYWRpdXMrJyUpJyx3aWR0aDp0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnLGhlaWdodDp0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQrJ3B4Jyx0b3A6MCxsZWZ0OjAscG9zaXRpb246J2Fic29sdXRlJ30pLmFwcGVuZFRvKCQob2JqLnN2Zy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue2lmKGZyYW1lPGZyYW1lcyl7JCgnZGl2I3JncmFwaF9mYWRlY2lyY3VsYXJpbm91dHdhcmRzX2NvdmVyXycrb2JqLmlkKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApICcrKChmcmFtZSsrLyBmcmFtZXMpICogMTAwKSArICclLCAnICsgY29sb3IgKyAnICcgKyAoKGZyYW1lKysgL2ZyYW1lcykqMTUwKSsnJSknfSk7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7fWVsc2V7JCgnZGl2I3JncmFwaF9mYWRlY2lyY3VsYXJpbm91dHdhcmRzX2NvdmVyXycrb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuU1ZHLkZYLmZhZGVjaXJjdWxhcm91dG91dHdhcmRzPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGZyYW1lPTAsd2lkdGg9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCxjYW52YXNYWT1SRy5TVkcuZ2V0U1ZHWFkob2JqLnN2ZyksY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9OyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKydcIj48L2Rpdj4nKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCB0cmFuc3BhcmVudCAwJSknLHdpZHRoOndpZHRoKydweCcsaGVpZ2h0OmhlaWdodCsncHgnLHRvcDowLGxlZnQ6MCxwb3NpdGlvbjonYWJzb2x1dGUnfSkuYXBwZW5kVG8oJChvYmouc3ZnLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57aWYoZnJhbWU8ZnJhbWVzKXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkuY3NzKHtiYWNrZ3JvdW5kOidyYWRpYWwtZ3JhZGllbnQoJytjb2xvcisnICcrKChmcmFtZSsrLyBmcmFtZXMpICogMTAwKSArICclLCByZ2JhKDI1NSwyNTUsMjU1LDApICcgKyAoKGZyYW1lKysgL2ZyYW1lcykqMTUwKSsnJSknfSk7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7fWVsc2V7UkcuU1ZHLmNsZWFyKG9iai5zdmcpOyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307UkcuU1ZHLkZYLmZhZGVjaXJjdWxhcmluaW53YXJkcz1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxmcmFtZT0wLHJhZGl1cz1tYS5tYXgob2JqLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxvYmouY29udGFpbmVyLm9mZnNldEhlaWdodCksY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9O1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycrb2JqLmlkKydcIj48L2Rpdj4nKS5jc3Moe2JhY2tncm91bmQ6J3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDEwMCUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUpJyx3aWR0aDp0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnLGhlaWdodDp0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQrJ3B4Jyx0b3A6MCxsZWZ0OjAscG9zaXRpb246J2Fic29sdXRlJ30pLmFwcGVuZFRvKCQob2JqLnN2Zy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue2lmKGZyYW1lPGZyYW1lcyl7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLmNzcyh7YmFja2dyb3VuZDoncmFkaWFsLWdyYWRpZW50KCcrY29sb3IrJyAnKygoKGZyYW1lcy1mcmFtZSsrKS9mcmFtZXMpKjEwMCkrJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJysoKChmcmFtZXMtZnJhbWUrKykvZnJhbWVzKSoxMjApKyclKSd9KTtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTt9ZWxzZXskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK29iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTt9fVxuaXRlcmF0b3IoKTtyZXR1cm4gdGhpczt9O1JHLlNWRy5GWC5mYWRlY2lyY3VsYXJvdXRpbndhcmRzPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGZyYW1lPTAscmFkaXVzPW1hLm1heCh0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCx0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQpLGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nK3RoaXMuaWQrJ1wiPjwvZGl2PicpLmNzcyh7YmFja2dyb3VuZDoncmFkaWFsLWdyYWRpZW50KHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUpJyx3aWR0aDp0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnLGhlaWdodDp0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQrJ3B4Jyx0b3A6MCxsZWZ0OjAscG9zaXRpb246J2Fic29sdXRlJ30pLmFwcGVuZFRvKCQob2JqLnN2Zy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKVxue2lmKGZyYW1lPGZyYW1lcyl7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLmNzcyh7YmFja2dyb3VuZDoncmFkaWFsLWdyYWRpZW50KHJnYmEoMjU1LDI1NSwyNTUsMCkgJysoKChmcmFtZXMtZnJhbWUrKykvZnJhbWVzKSoxMDApKyclLCAnK2NvbG9yKycgJysoKChmcmFtZXMtZnJhbWUrKykvZnJhbWVzKSoxMjApKyclKSd9KTtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTt9ZWxzZXtSRy5TVkcuY2xlYXIob2JqLnN2Zyk7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlgucmV2ZWFsPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e31cbmNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fVxudmFyIGRpdnM9W1sncmdyYXBoX3JldmVhbF9sZWZ0XycrdGhpcy5pZCwwLDAsdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgvMix0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRdLFsncmdyYXBoX3JldmVhbF9yaWdodF8nK3RoaXMuaWQsKHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzIpLDAsKHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzIpLHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodF0sWydyZ3JhcGhfcmV2ZWFsX3RvcF8nK3RoaXMuaWQsMCwwLHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLCh0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQvMildLFsncmdyYXBoX3JldmVhbF9ib3R0b21fJyt0aGlzLmlkLDAsKHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodC8yKSx0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwodGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzIpXV07Zm9yKHZhciBpPTAsbGVuPWRpdnMubGVuZ3RoO2k8bGVuOysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPWRpdnNbaV1bMF07ZGl2LnN0eWxlLmxlZnQ9ZGl2c1tpXVsxXSsncHgnO2Rpdi5zdHlsZS50b3A9ZGl2c1tpXVsyXSsncHgnO2Rpdi5zdHlsZS53aWR0aD1kaXZzW2ldWzNdKydweCc7ZGl2LnN0eWxlLmhlaWdodD1kaXZzW2ldWzRdKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1jb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO31cblJHLlNWRy5yZWRyYXcob2JqLnN2Zyk7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9sZWZ0Xycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDowfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9yaWdodF8nK29iai5pZCkuYW5pbWF0ZSh7bGVmdDonKz0nKyh0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aC8yKSx3aWR0aDowfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF90b3BfJytvYmouaWQpLmFuaW1hdGUoe2hlaWdodDowfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9ib3R0b21fJytvYmouaWQpLmFuaW1hdGUoe3RvcDonKz0nKyh0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQvMiksaGVpZ2h0OjB9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfdG9wX1wiK29iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3JldmVhbF9ib3R0b21fXCIrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX2xlZnRfXCIrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX3JpZ2h0X1wiK29iai5pZCkpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguY29uY2VhbD1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fSxjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZScsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wO3ZhciBkaXZzPVtbJ3JncmFwaF9jb25jZWFsX2xlZnRfJytvYmouaWQsMCwwLDAsdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XSxbJ3JncmFwaF9jb25jZWFsX3JpZ2h0Xycrb2JqLmlkLHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLDAsMCx0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRdLFsncmdyYXBoX2NvbmNlYWxfdG9wXycrb2JqLmlkLDAsMCx0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwwXSxbJ3JncmFwaF9jb25jZWFsX2JvdHRvbV8nK29iai5pZCwwLHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCx0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwwXV07Zm9yKHZhciBpPTAsbGVuPWRpdnMubGVuZ3RoO2k8bGVuOysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPWRpdnNbaV1bMF07ZGl2LnN0eWxlLmxlZnQ9ZGl2c1tpXVsxXSsncHgnO2Rpdi5zdHlsZS50b3A9ZGl2c1tpXVsyXSsncHgnO2Rpdi5zdHlsZS53aWR0aD1kaXZzW2ldWzNdKydweCc7ZGl2LnN0eWxlLmhlaWdodD1kaXZzW2ldWzRdKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1jb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO31cbmpRdWVyeSgnI3JncmFwaF9jb25jZWFsX2xlZnRfJytvYmouaWQpLmFuaW1hdGUoe3dpZHRoOicrPScrKHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzIpfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfcmlnaHRfJytvYmouaWQpLmFuaW1hdGUoe2xlZnQ6Jy09JysodGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgvMiksd2lkdGg6KHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzIpfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfdG9wXycrb2JqLmlkKS5hbmltYXRlKHtoZWlnaHQ6Jys9JysodGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzIpfSxkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfYm90dG9tXycrb2JqLmlkKS5hbmltYXRlKHt0b3A6Jy09JysodGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzIpLGhlaWdodDoodGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzIpfSxkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbigpXG57b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF90b3BfXCIrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF9ib3R0b21fXCIrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF9sZWZ0X1wiK29iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2NvbmNlYWxfcmlnaHRfXCIrb2JqLmlkKSk7UkcuU1ZHLmNsZWFyKG9iai5zdmcpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguaGJsaW5kc29wZW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyxoZWlnaHQ9dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzU7UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7Zm9yKHZhciBpPTA7aTw1OysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfaGJsaW5kc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUubGVmdD0wO2Rpdi5zdHlsZS50b3A9KCh0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQqKGkvNSkpKSsncHgnO2Rpdi5zdHlsZS53aWR0aD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9KHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodC81KSsncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtqUXVlcnkoJyNyZ3JhcGhfaGJsaW5kc18nK2krJ18nK29iai5pZCkuYW5pbWF0ZSh7aGVpZ2h0OjB9LGR1cmF0aW9uKTt9XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzBfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzFfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzJfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzNfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzRfJytvYmouaWQpKTt9LGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y2FsbGJhY2sob2JqKTt9LGR1cmF0aW9uKTtyZXR1cm4gdGhpczt9O1JHLlNWRy5GWC5oYmxpbmRzY2xvc2U9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcj0nd2hpdGUnLGhlaWdodD10aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQvNTtmb3IodmFyIGk9MDtpPDU7KytpKXt2YXIgZGl2PWRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQ9J3JncmFwaF9oYmxpbmRzXycraSsnXycrb2JqLmlkO2Rpdi5zdHlsZS5sZWZ0PTA7ZGl2LnN0eWxlLnRvcD0odGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0KihpLzUpKSsncHgnO2Rpdi5zdHlsZS53aWR0aD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnO2Rpdi5zdHlsZS5oZWlnaHQ9MDtkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX2hibGluZHNfJytpKydfJytvYmouaWQpLmFuaW1hdGUoe2hlaWdodDpoZWlnaHQrJ3B4J30sZHVyYXRpb24pO31cbnNldFRpbWVvdXQoZnVuY3Rpb24oKXtSRy5TVkcuY2xlYXIob2JqLnN2Zyk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzFfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18yXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfM18nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzRfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbisxMDApO307UkcuU1ZHLkZYLnZibGluZHNvcGVuPWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXMsb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDAsZnJhbWU9MCxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fSxjb2xvcj1vcHQuY29sb3J8fCd3aGl0ZScsd2lkdGg9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgvMTA7UkcuU1ZHLnJlZHJhdyhvYmouc3ZnKTtmb3IodmFyIGk9MDtpPDEwOysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdmJsaW5kc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUud2lkdGg9d2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnO2Rpdi5zdHlsZS5sZWZ0PSh0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCooaS8xMCkpKydweCc7ZGl2LnN0eWxlLnRvcD0wO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7b2JqLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO2pRdWVyeSgnI3JncmFwaF92YmxpbmRzXycraSsnXycrb2JqLmlkKS5hbmltYXRlKHt3aWR0aDowfSxkdXJhdGlvbik7fVxuc2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18wXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMV8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzJfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18zXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzVfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc182Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfN18nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzhfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc185Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjayhvYmopO30sZHVyYXRpb24rMTAwKTtyZXR1cm4gdGhpczt9O1JHLlNWRy5GWC52YmxpbmRzY2xvc2U9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyx3aWR0aD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aC8xMDtmb3IodmFyIGk9MDtpPDEwOysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdmJsaW5kc18nK2krJ18nK29iai5pZDtkaXYuc3R5bGUubGVmdD0odGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgqKGkvMTApKSsncHgnO2Rpdi5zdHlsZS50b3A9MDtkaXYuc3R5bGUud2lkdGg9MDtkaXYuc3R5bGUuaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Y29sb3I7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtqUXVlcnkoJyNyZ3JhcGhfdmJsaW5kc18nK2krJ18nK29iai5pZCkuYW5pbWF0ZSh7d2lkdGg6d2lkdGh9LGR1cmF0aW9uKTt9XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7UkcuU1ZHLmNsZWFyKG9iai5zdmcpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzBfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMl8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzNfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNV8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzZfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183Xycrb2JqLmlkKSk7fSxkdXJhdGlvbisxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOF8nK29iai5pZCkpO30sZHVyYXRpb24rMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzlfJytvYmouaWQpKTt9LGR1cmF0aW9uKzEwMCk7c2V0VGltZW91dChmdW5jdGlvbigpe2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbisxMDApO3JldHVybiB0aGlzO307UkcuU1ZHLkZYLnNsaWRlaW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyx3aWR0aD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aC8xMCxmcm9tPW9wdC5mcm9tfHwnbGVmdCc7dGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9J2hpZGRlbic7UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7dGhpcy5zdmcuc3R5bGUucG9zaXRpb249J3JlbGF0aXZlJztpZihmcm9tPT0nbGVmdCcpe3RoaXMuc3ZnLnN0eWxlLmxlZnQ9KDAtdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgpKydweCc7dGhpcy5zdmcuc3R5bGUudG9wPTA7fWVsc2UgaWYoZnJvbT09J3RvcCcpe3RoaXMuc3ZnLnN0eWxlLmxlZnQ9MDt0aGlzLnN2Zy5zdHlsZS50b3A9KDAtdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0KSsncHgnO31lbHNlIGlmKGZyb209PSdib3R0b20nKXt0aGlzLnN2Zy5zdHlsZS5sZWZ0PTA7dGhpcy5zdmcuc3R5bGUudG9wPXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnO31lbHNle3RoaXMuc3ZnLnN0eWxlLmxlZnQ9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgrJ3B4Jzt0aGlzLnN2Zy5zdHlsZS50b3A9MDt9XG5qUXVlcnkodGhpcy5zdmcpLmFuaW1hdGUoe2xlZnQ6MCx0b3A6MH0sZHVyYXRpb24sZnVuY3Rpb24oKVxue2NhbGxiYWNrKG9iaik7fSk7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguc2xpZGVvdXQ9ZnVuY3Rpb24oKVxue3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8OTAsY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLHRvPW9wdC50b3x8J2xlZnQnLGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDAsZnJhbWU9MCxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fSx3aWR0aD10aGlzLmNvbnRhaW5lci5vZmZldHNXaWR0aC8xMDt0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz0naGlkZGVuJzt0aGlzLnN2Zy5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO3RoaXMuc3ZnLnN0eWxlLmxlZnQ9MDt0aGlzLnN2Zy5zdHlsZS50b3A9MDtpZih0bz09J2xlZnQnKXtqUXVlcnkodGhpcy5zdmcpLmFuaW1hdGUoe2xlZnQ6KDAtdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgpKydweCd9LGR1cmF0aW9uLGZ1bmN0aW9uKCl7Y2FsbGJhY2sodGhpcyk7fSk7fWVsc2UgaWYodG89PSd0b3AnKXtqUXVlcnkodGhpcy5zdmcpLmFuaW1hdGUoe2xlZnQ6MCx0b3A6KDAtdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0KSsncHgnfSxkdXJhdGlvbixmdW5jdGlvbigpe2NhbGxiYWNrKHRoaXMpO30pO31lbHNlIGlmKHRvPT0nYm90dG9tJyl7alF1ZXJ5KHRoaXMuc3ZnKS5hbmltYXRlKHt0b3A6KDArdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0KSsncHgnfSxkdXJhdGlvbixmdW5jdGlvbigpe2NhbGxiYWNrKHRoaXMpO30pO31lbHNle2pRdWVyeSh0aGlzLnN2ZykuYW5pbWF0ZSh7bGVmdDooMCt0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCkrJ3B4J30sZHVyYXRpb24sZnVuY3Rpb24oKXtjYWxsYmFjayh0aGlzKTt9KTt9XG5yZXR1cm4gdGhpczt9O1JHLlNWRy5GWC5oc2Npc3NvcnNvcGVuPWZ1bmN0aW9uKClcbnt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e30sb2JqPXRoaXMsZnJhbWVzPW9wdC5mcmFtZXN8fDkwLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyx0bz1vcHQudG98fCdsZWZ0JyxmcmFtZT0wLGR1cmF0aW9uPShmcmFtZXMvNjApKjEwMDAsd2lkdGg9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgvMTAsaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodC81O1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpO2Zvcih2YXIgaT0wO2k8NTsrK2kpe3ZhciBkaXY9ZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2hzY2lzc29yc19cIitpKydfJyt0aGlzLmlkKVxuaWYoIWRpdil7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrdGhpcy5pZDtkaXYuc3R5bGUud2lkdGg9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PSh0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQvNSkrJ3B4JztkaXYuc3R5bGUubGVmdD0wO2Rpdi5zdHlsZS50b3A9KHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCooaS81KSkrJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7fVxuaWYoaSUyPT0wKXtqUXVlcnkoJyMnKydyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrdGhpcy5pZCkuYW5pbWF0ZSh7bGVmdDp0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnLHdpZHRoOjB9LGR1cmF0aW9uKTt9ZWxzZXtqUXVlcnkoJyMnKydyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrdGhpcy5pZCkuYW5pbWF0ZSh7d2lkdGg6MH0sZHVyYXRpb24pO319XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18wXycrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oc2Npc3NvcnNfMV8nK29iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaHNjaXNzb3JzXzJfJytvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18zXycrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oc2Npc3NvcnNfNF8nK29iai5pZCkpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlguaHNjaXNzb3JzY2xvc2U9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lc3x8NjAsZHVyYXRpb249KGZyYW1lcy82MCkqMTAwMCxmcmFtZT0wLGNhbGxiYWNrPW9wdC5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGNvbG9yPW9wdC5jb2xvcnx8J3doaXRlJyxoZWlnaHQ9dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzU7Zm9yKHZhciBpPTA7aTw1OysraSl7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfaHNjaXNzb3JzXycraSsnXycrdGhpcy5pZDtkaXYuc3R5bGUud2lkdGg9MDtkaXYuc3R5bGUuaGVpZ2h0PWhlaWdodCsncHgnO2Rpdi5zdHlsZS5sZWZ0PShpJTI9PTA/dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg6MCkrJ3B4JztkaXYuc3R5bGUudG9wPSh0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQqKGkvNSkpKydweCc7ZGl2LnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj1jb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO2lmKGklMj09MCl7alF1ZXJ5KCcjJysncmdyYXBoX2hzY2lzc29yc18nK2krJ18nK3RoaXMuaWQpLmFuaW1hdGUoe2xlZnQ6MCx3aWR0aDp0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCsncHgnfSxkdXJhdGlvbik7fWVsc2V7alF1ZXJ5KCcjJysncmdyYXBoX2hzY2lzc29yc18nK2krJ18nK3RoaXMuaWQpLmFuaW1hdGUoe3dpZHRoOnRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoKydweCd9LGR1cmF0aW9uKTt9fVxuc2V0VGltZW91dChmdW5jdGlvbigpXG57UkcuU1ZHLmNsZWFyKG9iai5zdmcpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJyswKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJysxKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJysyKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJyszKydfJytvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycrJ3JncmFwaF9oc2Npc3NvcnNfJys0KydfJytvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTtSRy5TVkcuRlgudnNjaXNzb3Jzb3Blbj1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwLGZyYW1lPTAsY2FsbGJhY2s9b3B0LmNhbGxiYWNrfHxmdW5jdGlvbigpe30sY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLHdpZHRoPXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzEwO1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpO2Zvcih2YXIgaT0wO2k8MTA7KytpKXt2YXIgZGl2PWRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF92c2Npc3NvcnNfXCIraSsnXycrdGhpcy5pZCk7aWYoIWRpdil7dmFyIGRpdj1kb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkPSdyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrdGhpcy5pZDtkaXYuc3R5bGUud2lkdGg9d2lkdGgrJ3B4JztkaXYuc3R5bGUuaGVpZ2h0PXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnO2Rpdi5zdHlsZS5sZWZ0PXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoKihpLzEwKSsncHgnO2Rpdi5zdHlsZS50b3A9MDtkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7fVxuaWYoaSUyPT0wKXtqUXVlcnkoJyMnKydyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrdGhpcy5pZCkuYW5pbWF0ZSh7dG9wOnRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnLGhlaWdodDowfSxkdXJhdGlvbik7fWVsc2V7alF1ZXJ5KCcjJysncmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK3RoaXMuaWQpLmFuaW1hdGUoe2hlaWdodDowfSxkdXJhdGlvbik7fX1cbnNldFRpbWVvdXQoZnVuY3Rpb24oKVxue29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzAnKydfJytvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18xJysnXycrb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92c2Npc3NvcnNfMicrJ18nK29iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzMnKydfJytvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc180JysnXycrb2JqLmlkKSk7Y2FsbGJhY2sob2JqKTt9LGR1cmF0aW9uKTtyZXR1cm4gdGhpczt9O1JHLlNWRy5GWC52c2Npc3NvcnNjbG9zZT1mdW5jdGlvbigpXG57dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lcz1vcHQuZnJhbWVzfHw5MCxkdXJhdGlvbj0oZnJhbWVzLzYwKSoxMDAwLGZyYW1lPTAsY2FsbGJhY2s9b3B0LmNhbGxiYWNrfHxmdW5jdGlvbigpe30sY29sb3I9b3B0LmNvbG9yfHwnd2hpdGUnLHdpZHRoPXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLzEwO2Zvcih2YXIgaT0wO2k8MTA7KytpKXt2YXIgZGl2PWRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF92c2Npc3NvcnNfXCIraSsnXycrdGhpcy5pZClcbmlmKCFkaXYpe3ZhciBkaXY9ZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZD0ncmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK3RoaXMuaWQ7ZGl2LnN0eWxlLndpZHRoPXdpZHRoKydweCc7ZGl2LnN0eWxlLmhlaWdodD0wO2Rpdi5zdHlsZS5sZWZ0PSh3aWR0aCppKSsncHgnO2Rpdi5zdHlsZS50b3A9KGklMj09MD90aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ6MCkrJ3B4JztkaXYuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPWNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7fVxuaWYoaSUyPT0wKXtqUXVlcnkoJyMnKydyZ3JhcGhfdnNjaXNzb3JzXycraSsnXycrdGhpcy5pZCkuYW5pbWF0ZSh7dG9wOjAsaGVpZ2h0OnRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCsncHgnfSxkdXJhdGlvbik7fWVsc2V7alF1ZXJ5KCcjJysncmdyYXBoX3ZzY2lzc29yc18nK2krJ18nK3RoaXMuaWQpLmFuaW1hdGUoe2hlaWdodDp0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQrJ3B4J30sZHVyYXRpb24pO319XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKClcbntSRy5TVkcuY2xlYXIob2JqLnN2Zyk7Zm9yKHZhciBpPTA7aTwxMDtpKyspe2pRdWVyeSgnI3JncmFwaF92c2Npc3NvcnNfJytpKydfJytvYmouaWQpLnJlbW92ZSgpO31cbmNhbGxiYWNrKG9iaik7fSxkdXJhdGlvbik7cmV0dXJuIHRoaXM7fTt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24uZnguanMiXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///238\n");

/***/ }),
/* 239 */
/***/ (function(module, exports) {

eval("// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\nRGraph.SVG.HTML = RGraph.SVG.HTML || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math;\n\n    /**\n    * Draws the graph key (used by various graphs)\n    * \n    * @param object obj The graph object\n    * @param array  key An array of the texts to be listed in the key\n    * @param colors An array of the colors to be used\n    */\n    RG.SVG.drawKey = function (obj) {\n        var prop = obj.properties,\n            key = prop.key,\n            colors = prop.keyColors || prop.colors,\n            defaultFont = 'Arial',\n            blobSize = 0,\n            width = 0;\n\n        // Work out the center point of the SVG tag\n        var centerx = obj.svg.getAttribute('width') / 2;\n\n        // First measure the length so that the key can be centered\n        for (var i = 0, length = 0; i < key.length; i++) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            blobSize = ma.max(blobSize, textDimensions[1]);\n\n            width = width + 10 + blobSize + 5 + textDimensions[0];\n        }\n\n        // Center the key\n        x = centerx - width / 2;\n\n        // Loop thru the key and draw them\n        for (var i = 0, y = prop.gutterTop - 5; i < key.length; ++i) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            RG.SVG.create({\n                svg: obj.svg,\n                type: 'rect',\n                parent: obj.svg.all,\n                attr: {\n                    x: x + prop.keyOffsetx,\n                    y: y - blobSize + prop.keyOffsety,\n                    width: blobSize,\n                    height: blobSize,\n                    fill: colors[i]\n                }\n            });\n\n            RGraph.SVG.text({\n                object: obj,\n                parent: obj.svg.all,\n                size: prop.keyTextSize || prop.textSize,\n                bold: prop.keyTextBold || false,\n                font: 'Arial',\n                italic: prop.keyTextItalic || false,\n                halign: 'left',\n                valign: 'bottom',\n                text: key[i],\n                x: x + blobSize + 5 + prop.keyTextOffsetx + prop.keyOffsetx,\n                y: y + prop.keyTextOffsety + prop.keyOffsety,\n                color: 'black',\n                background: 'white',\n                padding: 0\n            });\n\n            x += 10 + blobSize + 5 + textDimensions[0];\n        }\n    };\n\n    /**\n    * Create a TABLE based HTML key. There's lots of options so it's\n    * suggested that you consult the documentation page\n    * \n    * @param mixed id   This should be a string consisting of the ID of the container\n    * @param object prop An object map of the various properties that you can use to\n    *                    configure the key. See the documentation page for a list.\n    */\n    RG.SVG.HTML.key = function (id, prop) {\n        var div = doc.getElementById(id);\n\n        /**\n        * Create the table that becomes the key\n        */\n        var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n            var style = '';\n            for (i in prop.tableCss) {\n                if (typeof i === 'string') {\n                    style = style + i + ': ' + prop.tableCss[i] + ';';\n                }\n            }\n            return style;\n        }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';\n\n        /**\n        * Add the individual key elements\n        */\n        for (var i = 0; i < prop.labels.length; i += 1) {\n            str += '<tr><td><div style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.blobCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.blobCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.labelCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.labelCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + '\" ' + function () {\n                var style = '';\n\n                if (prop['labelCss_' + i]) {\n                    for (var j in prop['labelCss_' + i]) {\n                        style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n                    }\n                }\n\n                return style ? 'style=\"' + style + '\"' : '';\n            }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n        }\n\n        div.innerHTML += str + '</table>';\n\n        // Return the TABLE object that is the HTML key\n        return doc.getElementById('rgraph_key');\n    };\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5rZXkuanM/OTM5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2ZXJzaW9uOiAyMDE3LTA1LTA4XG4gICAgLyoqXG4gICAgKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4gICAgKiB8IFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBSR3JhcGggcGFja2FnZSAtIHlvdSBjYW4gbGVhcm4gbW9yZSBhdDogICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnJncmFwaC5uZXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8IFJHcmFwaCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgT3BlbiBTb3VyY2UgTUlUIGxpY2Vuc2UuIFRoYXQgbWVhbnMgdGhhdCBpdCdzICAgICB8XG4gICAgKiB8IHRvdGFsbHkgZnJlZSB0byB1c2UhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4gICAgKi9cblxuICAgIFJHcmFwaCAgICAgICAgICA9IHdpbmRvdy5SR3JhcGggfHwge2lzUkdyYXBoOiB0cnVlfTtcbiAgICBSR3JhcGguU1ZHICAgICAgPSBSR3JhcGguU1ZHIHx8IHt9O1xuICAgIFJHcmFwaC5TVkcuSFRNTCA9IFJHcmFwaC5TVkcuSFRNTCB8fCB7fTtcbiAgICBcbi8vIE1vZHVsZSBwYXR0ZXJuXG4oZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpXG57XG4gICAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIG1hID0gTWF0aDtcblxuXG5cblxuICAgIC8qKlxuICAgICogRHJhd3MgdGhlIGdyYXBoIGtleSAodXNlZCBieSB2YXJpb3VzIGdyYXBocylcbiAgICAqIFxuICAgICogQHBhcmFtIG9iamVjdCBvYmogVGhlIGdyYXBoIG9iamVjdFxuICAgICogQHBhcmFtIGFycmF5ICBrZXkgQW4gYXJyYXkgb2YgdGhlIHRleHRzIHRvIGJlIGxpc3RlZCBpbiB0aGUga2V5XG4gICAgKiBAcGFyYW0gY29sb3JzIEFuIGFycmF5IG9mIHRoZSBjb2xvcnMgdG8gYmUgdXNlZFxuICAgICovXG4gICAgUkcuU1ZHLmRyYXdLZXkgPSBmdW5jdGlvbiAob2JqKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3AgICAgICAgID0gb2JqLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBrZXkgICAgICAgICA9IHByb3Aua2V5LFxuICAgICAgICAgICAgY29sb3JzICAgICAgPSBwcm9wLmtleUNvbG9ycyB8fCBwcm9wLmNvbG9ycyxcbiAgICAgICAgICAgIGRlZmF1bHRGb250ID0gJ0FyaWFsJyxcbiAgICAgICAgICAgIGJsb2JTaXplICAgID0gMCxcbiAgICAgICAgICAgIHdpZHRoICAgICAgID0gMDtcbiAgICAgICAgXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIFNWRyB0YWdcbiAgICAgICAgdmFyIGNlbnRlcnggPSBvYmouc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDI7XG5cblxuXG5cbiAgICAvLyBGaXJzdCBtZWFzdXJlIHRoZSBsZW5ndGggc28gdGhhdCB0aGUga2V5IGNhbiBiZSBjZW50ZXJlZFxuICAgIGZvciAodmFyIGk9MCxsZW5ndGggPSAwOyBpPGtleS5sZW5ndGg7IGkrKykge1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgbWVhc3VyZSB0aGUgdGV4dFxuICAgICAgICB2YXIgdGV4dERpbWVuc2lvbnMgPSBSRy5TVkcubWVhc3VyZVRleHQoe1xuICAgICAgICAgICAgdGV4dDoga2V5W2ldLFxuICAgICAgICAgICAgYm9sZDogcHJvcC5rZXlUZXh0Qm9sZCB8fCBmYWxzZSxcbiAgICAgICAgICAgIGZvbnQ6IHByb3Aua2V5VGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCB8fCBkZWZhdWx0Rm9udCxcbiAgICAgICAgICAgIHNpemU6IHByb3Aua2V5VGV4dFNpemUgfHwgcHJvcC50ZXh0U2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICBibG9iU2l6ZSA9IG1hLm1heChibG9iU2l6ZSwgdGV4dERpbWVuc2lvbnNbMV0pO1xuXG4gICAgICAgIHdpZHRoID0gd2lkdGggKyAxMCArIGJsb2JTaXplICsgNSArIHRleHREaW1lbnNpb25zWzBdO1xuICAgIH1cblxuICAgIC8vIENlbnRlciB0aGUga2V5XG4gICAgeCA9IGNlbnRlcnggLSB3aWR0aCAvIDI7XG5cblxuXG5cblxuXG5cbiAgICAgICAgLy8gTG9vcCB0aHJ1IHRoZSBrZXkgYW5kIGRyYXcgdGhlbVxuICAgICAgICBmb3IgKHZhciBpPTAseT1wcm9wLmd1dHRlclRvcCAtIDU7IGk8a2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRmlyc3QgbWVhc3VyZSB0aGUgdGV4dFxuICAgICAgICAgICAgdmFyIHRleHREaW1lbnNpb25zID0gUkcuU1ZHLm1lYXN1cmVUZXh0KHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBrZXlbaV0sXG4gICAgICAgICAgICAgICAgYm9sZDogcHJvcC5rZXlUZXh0Qm9sZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb250OiBwcm9wLmtleVRleHRGb250IHx8IHByb3AudGV4dEZvbnQgfHwgZGVmYXVsdEZvbnQsXG4gICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5rZXlUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBcbiAgICAgICAgICAgIFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN2Zzogb2JqLnN2ZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBvYmouc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHggKyBwcm9wLmtleU9mZnNldHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHkgLSBibG9iU2l6ZSArIHByb3Aua2V5T2Zmc2V0eSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJsb2JTaXplLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJsb2JTaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcnNbaV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUkdyYXBoLlNWRy50ZXh0KHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iaixcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IG9iai5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIHNpemU6IHByb3Aua2V5VGV4dFNpemUgfHwgcHJvcC50ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgICBib2xkOiBwcm9wLmtleVRleHRCb2xkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvbnQ6ICdBcmlhbCcsXG4gICAgICAgICAgICAgICAgaXRhbGljOiBwcm9wLmtleVRleHRJdGFsaWN8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBoYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICB2YWxpZ246ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIHRleHQ6IGtleVtpXSxcbiAgICAgICAgICAgICAgICB4OiB4ICsgYmxvYlNpemUgKyA1ICsgcHJvcC5rZXlUZXh0T2Zmc2V0eCArIHByb3Aua2V5T2Zmc2V0eCxcbiAgICAgICAgICAgICAgICB5OiB5ICsgcHJvcC5rZXlUZXh0T2Zmc2V0eSArIHByb3Aua2V5T2Zmc2V0eSxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHggKz0gMTAgKyBibG9iU2l6ZSArIDUgKyB0ZXh0RGltZW5zaW9uc1swXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgVEFCTEUgYmFzZWQgSFRNTCBrZXkuIFRoZXJlJ3MgbG90cyBvZiBvcHRpb25zIHNvIGl0J3NcbiAgICAqIHN1Z2dlc3RlZCB0aGF0IHlvdSBjb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIHBhZ2VcbiAgICAqIFxuICAgICogQHBhcmFtIG1peGVkIGlkICAgVGhpcyBzaG91bGQgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBvZiB0aGUgSUQgb2YgdGhlIGNvbnRhaW5lclxuICAgICogQHBhcmFtIG9iamVjdCBwcm9wIEFuIG9iamVjdCBtYXAgb2YgdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IHlvdSBjYW4gdXNlIHRvXG4gICAgKiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJlIHRoZSBrZXkuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBwYWdlIGZvciBhIGxpc3QuXG4gICAgKi9cbiAgICBSRy5TVkcuSFRNTC5rZXkgPSBmdW5jdGlvbiAoaWQsIHByb3ApXG4gICAge1xuICAgICAgICB2YXIgZGl2ID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICogQ3JlYXRlIHRoZSB0YWJsZSB0aGF0IGJlY29tZXMgdGhlIGtleVxuICAgICAgICAqL1xuICAgICAgICB2YXIgc3RyID0gJzx0YWJsZSBib3JkZXI9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2VsbHBhZGRpbmc9XCIwXCIgaWQ9XCJyZ3JhcGhfa2V5XCIgc3R5bGU9XCJkaXNwbGF5OiBpbmxpbmU7JyArIChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9ICcnXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHByb3AudGFibGVDc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSArIGkgKyAnOiAnICsgcHJvcC50YWJsZUNzc1tpXSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9KSgpICsgJ1wiICcgKyAocHJvcC50YWJsZUNsYXNzID8gJ2NsYXNzPVwiJyArIHByb3AudGFibGVDbGFzcyArICdcIicgOiAnJykgKyAnPic7XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEFkZCB0aGUgaW5kaXZpZHVhbCBrZXkgZWxlbWVudHNcbiAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHByb3AubGFiZWxzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgc3RyICs9ICc8dHI+PHRkPjxkaXYgc3R5bGU9XCInICsgKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gJyc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHByb3AuYmxvYkNzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlICsgaiArICc6ICcgKyBwcm9wLmJsb2JDc3Nbal0gKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9KSgpICsgJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLXJpZ2h0OiA1cHg7IG1hcmdpbi10b3A6IDRweDsgd2lkdGg6IDE1cHg7IGhlaWdodDogMTVweDsgYmFja2dyb3VuZC1jb2xvcjogJyArIHByb3AuY29sb3JzW2ldICsgJ1wiJyArIChwcm9wLmJsb2JDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmJsb2JDbGFzcyArICdcIicgOiAnJykgKyAnPiZuYnNwOzwvZGl2Pjx0ZD4nICsgKHByb3AubGlua3MgJiYgcHJvcC5saW5rc1tpXSA/ICc8YSBocmVmPVwiJyArIHByb3AubGlua3NbaV0gKyAnXCI+JyA6ICcnKSArICc8c3BhbiAnICsgKHByb3AubGFiZWxDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmxhYmVsQ2xhc3MgKyAnXCInIDogJycpICsgJ1wiIHN0eWxlPVwiJyArIChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwcm9wLmxhYmVsQ3NzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUgKyBqICsgJzogJyArIHByb3AubGFiZWxDc3Nbal0gKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9KSgpICsgJ1wiICcgKyAoZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wWydsYWJlbENzc18nICsgaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwcm9wWydsYWJlbENzc18nICsgaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUgKyBqICsgJzogJyArIHByb3BbJ2xhYmVsQ3NzXycgKyBpXVtqXSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZSA/ICdzdHlsZT1cIicgKyBzdHlsZSArICdcIicgOiAnJztcbiAgICAgICAgICAgIH0pKCkgKyAnPicgKyBwcm9wLmxhYmVsc1tpXSArICc8L3NwYW4+JyArIChwcm9wLmxpbmtzICYmIHByb3AubGlua3NbaV0gPyAnPC9hPicgOiAnJykgKyAnPC90ZD48L3RyPic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRpdi5pbm5lckhUTUwgKz0gKHN0ciArICc8L3RhYmxlPicpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgVEFCTEUgb2JqZWN0IHRoYXQgaXMgdGhlIEhUTUwga2V5XG4gICAgICAgIHJldHVybiBkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9rZXknKTtcbiAgICB9O1xuXG5cblxuXG4vLyBFbmQgbW9kdWxlIHBhdHRlcm5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24ua2V5LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBTUE7Ozs7Ozs7QUFPQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUpBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7Ozs7Ozs7O0FBUUE7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///239\n");

/***/ }),
/* 240 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.SVG.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.SVG.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.SVG.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5zaGVldHMuanM/YjFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue1JHcmFwaC5TaGVldHM9ZnVuY3Rpb24oa2V5KVxue3ZhciB3b3Jrc2hlZXQsY2FsbGJhY2ssbGV0dGVycz0nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0zKXt3b3Jrc2hlZXQ9TnVtYmVyKGFyZ3VtZW50c1sxXSk7Y2FsbGJhY2s9YXJndW1lbnRzWzJdO31lbHNle3dvcmtzaGVldD0xO2NhbGxiYWNrPWFyZ3VtZW50c1sxXTt9XG52YXIgdXJsPSdodHRwczovL3NwcmVhZHNoZWV0cy5nb29nbGUuY29tL2ZlZWRzL2NlbGxzL1tLRVldL1tXT1JLU0hFRVRdL3B1YmxpYy9mdWxsP2FsdD1qc29uLWluLXNjcmlwdCZjYWxsYmFjaz1fX3JncmFwaF9KU09OUENhbGxiYWNrJy5yZXBsYWNlKC9cXFtLRVlcXF0vLGtleSkucmVwbGFjZSgvXFxbV09SS1NIRUVUXFxdLyx3b3Jrc2hlZXQpO3RoaXMubG9hZD1mdW5jdGlvbih1cmwsdXNlckNhbGxiYWNrKVxue3ZhciBvYmo9dGhpcztfX3JncmFwaF9KU09OUENhbGxiYWNrPWZ1bmN0aW9uKGpzb24pXG57b2JqLmpzb249anNvbjt2YXIgZ3JpZD1bXSxyb3c9MCxjb2w9MDtmb3IodmFyIGk9MDtpPGpzb24uZmVlZC5lbnRyeS5sZW5ndGg7KytpKXtyb3c9anNvbi5mZWVkLmVudHJ5W2ldLmdzJGNlbGwucm93LTE7Y29sPWpzb24uZmVlZC5lbnRyeVtpXS5ncyRjZWxsLmNvbC0xO2lmKCFncmlkW3Jvd10pe2dyaWRbcm93XT1bXTt9XG5ncmlkW3Jvd11bY29sXT1qc29uLmZlZWQuZW50cnlbaV0uY29udGVudC4kdDt9XG52YXIgbWF4Y29scz0wO2Zvcih2YXIgaT0wO2k8Z3JpZC5sZW5ndGg7KytpKXttYXhjb2xzPWdyaWRbaV0/TWF0aC5tYXgobWF4Y29scyxncmlkW2ldLmxlbmd0aCk6bWF4Y29sczt9XG5mb3IodmFyIGk9MDtpPGdyaWQubGVuZ3RoOysraSl7aWYodHlwZW9mIGdyaWRbaV09PT0ndW5kZWZpbmVkJyl7Z3JpZFtpXT1uZXcgQXJyYXkobWF4Y29scyk7fVxuZm9yKHZhciBqPTA7ajxtYXhjb2xzO2orKyl7aWYodHlwZW9mIGdyaWRbaV1bal09PT0ndW5kZWZpbmVkJyl7Z3JpZFtpXVtqXT0nJzt9XG5pZihncmlkW2ldW2pdLm1hdGNoKC9eWzAtOV0rJC8pKXtncmlkW2ldW2pdPXBhcnNlSW50KGdyaWRbaV1bal0pO31lbHNlIGlmKGdyaWRbaV1bal0ubWF0Y2goL15bMC05Ll0rJC8pKXtncmlkW2ldW2pdPXBhcnNlRmxvYXQoZ3JpZFtpXVtqXSk7fX19XG5vYmouZGF0YT1ncmlkO3VzZXJDYWxsYmFjayhvYmopO307dmFyIHNjcmlwdE5vZGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU0NSSVBUJyk7c2NyaXB0Tm9kZS5zcmM9dXJsO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0Tm9kZSk7fTt0aGlzLnJvdz1mdW5jdGlvbihpbmRleCxzdGFydClcbnt2YXIgb3B0PXt9LHJvdztzdGFydD1zdGFydHx8MTtpZihhcmd1bWVudHMmJnR5cGVvZiBhcmd1bWVudHNbMl09PT0nb2JqZWN0JyYmdHlwZW9mIGFyZ3VtZW50c1syXS50cmltPT09J2Jvb2xlYW4nKXtvcHQudHJpbT1hcmd1bWVudHNbMl0udHJpbTt9ZWxzZXtvcHQudHJpbT10cnVlO31cbnJvdz10aGlzLmRhdGFbaW5kZXgtMV0uc2xpY2Uoc3RhcnQtMSk7aWYob3B0LnRyaW0pe3Jvdz1SR3JhcGguU1ZHLmFycmF5VHJpbShyb3cpO31cbnJldHVybiByb3c7fTt0aGlzLmNvbD1mdW5jdGlvbihpbmRleCxzdGFydClcbnt2YXIgb3B0PXt9LGNvbD1bXTtzdGFydD1zdGFydHx8MTtpZihhcmd1bWVudHMmJnR5cGVvZiBhcmd1bWVudHNbMl09PT0nb2JqZWN0JyYmdHlwZW9mIGFyZ3VtZW50c1syXS50cmltPT09J2Jvb2xlYW4nKXtvcHQudHJpbT1hcmd1bWVudHNbMl0udHJpbTt9ZWxzZXtvcHQudHJpbT10cnVlO31cbmZvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2NvbC5wdXNoKHRoaXMuZGF0YVtpXVtpbmRleC0xXSk7fVxuaWYob3B0LnRyaW0pe2NvbD1SR3JhcGguU1ZHLmFycmF5VHJpbShjb2wpO31cbmNvbD1jb2wuc2xpY2Uoc3RhcnQtMSk7cmV0dXJuIGNvbDt9O3RoaXMuZ2V0SW5kZXhPZkxldHRlcnM9ZnVuY3Rpb24obClcbnt2YXIgcGFydHM9bC5zcGxpdCgnJyk7aWYocGFydHMubGVuZ3RoPT09MSl7cmV0dXJuIGxldHRlcnMuaW5kZXhPZihsKSsxO31lbHNlIGlmKHBhcnRzLmxlbmd0aD09PTIpe3ZhciBpZHg9KChsZXR0ZXJzLmluZGV4T2YocGFydHNbMF0pKzEpKjI2KSsobGV0dGVycy5pbmRleE9mKHBhcnRzWzFdKSsxKTtyZXR1cm4gaWR4O319XG50aGlzLmdldD1mdW5jdGlvbihzdHIpXG57c3RyPXN0ci50b1VwcGVyQ2FzZSgpO2lmKHN0ci5tYXRjaCgvXlthLXpdKyQvaSkpe2lmKHN0ci5sZW5ndGg9PT0xKXt2YXIgaW5kZXg9bGV0dGVycy5pbmRleE9mKHN0cikrMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsMSxhcmd1bWVudHNbMV0pO31lbHNlIGlmKHN0ci5sZW5ndGg9PT0yKXt2YXIgaW5kZXg9KChsZXR0ZXJzLmluZGV4T2Yoc3RyWzBdKSsxKSoyNikrbGV0dGVycy5pbmRleE9mKHN0clsxXSkrMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsMSxhcmd1bWVudHNbMV0pO319XG5pZihzdHIubWF0Y2goL15bMC05XSskL2kpKXtyZXR1cm4gdGhpcy5yb3coc3RyLG51bGwsYXJndW1lbnRzWzFdKTt9XG5pZihzdHIubWF0Y2goL14oW2Etel17MSwyfSkoWzAtOV0rKSQvaSkpe3ZhciBsZXR0ZXI9UmVnRXhwLiQxLG51bWJlcj1SZWdFeHAuJDIsY29sPXRoaXMuZ2V0KGxldHRlcix7dHJpbTpmYWxzZX0pO3JldHVybiBjb2xbbnVtYmVyLTFdO31cbmlmKHN0ci5tYXRjaCgvXihbYS16XXsxLDJ9KShbMC05XSspOihbYS16XXsxLDJ9KShbMC05XSspJC9pKSl7dmFyIGxldHRlcjE9UmVnRXhwLiQxLG51bWJlcjE9UmVnRXhwLiQyLGxldHRlcjI9UmVnRXhwLiQzLG51bWJlcjI9UmVnRXhwLiQ0XG5pZihsZXR0ZXIxPT09bGV0dGVyMil7dmFyIGNlbGxzPVtdLGluZGV4PXRoaXMuZ2V0SW5kZXhPZkxldHRlcnMobGV0dGVyMSksY29sPXRoaXMuY29sKGluZGV4LG51bGwse3RyaW06ZmFsc2V9KTtmb3IodmFyIGk9KG51bWJlcjEtMSk7aTw9KG51bWJlcjItMSk7KytpKXtjZWxscy5wdXNoKGNvbFtpXSk7fX1lbHNlIGlmKG51bWJlcjE9PT1udW1iZXIyKXt2YXIgY2VsbHM9W10scm93PXRoaXMucm93KG51bWJlcjEsbnVsbCx7dHJpbTpmYWxzZX0pLGluZGV4MT10aGlzLmdldEluZGV4T2ZMZXR0ZXJzKGxldHRlcjEpLGluZGV4Mj10aGlzLmdldEluZGV4T2ZMZXR0ZXJzKGxldHRlcjIpXG5mb3IodmFyIGk9KGluZGV4MS0xKTtpPD0oaW5kZXgyLTEpOysraSl7Y2VsbHMucHVzaChyb3dbaV0pO319XG5pZihhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXS50cmltPT09ZmFsc2Upe31lbHNle2NlbGxzPVJHcmFwaC5TVkcuYXJyYXlUcmltKGNlbGxzKTt9XG5yZXR1cm4gY2VsbHM7fX07dGhpcy5sb2FkKHVybCxjYWxsYmFjayk7fTt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24uc2hlZXRzLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///240\n");

/***/ }),
/* 241 */
/***/ (function(module, exports) {

eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.tooltips = {};RG.SVG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '12pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', transition: 'left ease-out .25s, top ease-out .25s' };RG.SVG.tooltip = function (opt) {\n    var obj = opt.object;RG.SVG.fireCustomEvent(obj, 'onbeforetooltip');if (!opt.text || typeof opt.text === 'undefined' || RG.SVG.trim(opt.text).length === 0) {\n      return;\n    }\n    var prop = obj.properties;if (typeof prop.tooltipsOverride === 'function') {\n      return prop.tooltipsOverride(obj, opt);\n    }\n    if (!RG.SVG.REG.get('tooltip')) {\n      var tooltipObj = document.createElement('DIV');tooltipObj.className = prop.tooltipsCssClass;for (var i in RG.SVG.tooltips.style) {\n        if (typeof i === 'string') {\n          tooltipObj.style[i] = RG.SVG.tooltips.style[i];\n        }\n      }\n    } else {\n      var tooltipObj = RG.SVG.REG.get('tooltip');tooltipObj.__object__.removeHighlight();tooltipObj.style.width = '';\n    }\n    if (RG.SVG.REG.get('tooltip-lasty')) {\n      tooltipObj.style.left = RG.SVG.REG.get('tooltip-lastx') + 'px';tooltipObj.style.top = RG.SVG.REG.get('tooltip-lasty') + 'px';\n    }\n    tooltipObj.innerHTML = opt.text;tooltipObj.__text__ = opt.text;tooltipObj.id = '__rgraph_tooltip_' + obj.id + '_' + obj.uid + '_' + opt.index;tooltipObj.__event__ = prop.tooltipsEvent || 'click';tooltipObj.__object__ = obj;if (typeof opt.index === 'number') {\n      tooltipObj.__index__ = opt.index;\n    }\n    if (typeof opt.dataset === 'number') {\n      tooltipObj.__dataset__ = opt.dataset;\n    }\n    if (typeof opt.group === 'number' || RG.SVG.isNull(opt.group)) {\n      tooltipObj.__group__ = opt.group;\n    }\n    if (typeof opt.sequentialIndex === 'number') {\n      tooltipObj.__sequentialIndex__ = opt.sequentialIndex;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth,\n        height = tooltipObj.offsetHeight;tooltipObj.style.left = opt.event.pageX - width / 2 + 'px';tooltipObj.style.top = opt.event.pageY - height - 15 + 'px';tooltipObj.style.width = width + 'px';if (!RG.SVG.REG.get('tooltip-lastx')) {\n      for (var i = 0; i <= 30; ++i) {\n        (function (idx) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = idx / 30 * 1;\n          }, idx / 30 * 200);\n        })(i);\n      }\n    }\n    if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.SVG.isFixed(obj.svg)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = opt.event.pageY - scrollTop - height - 10 + 'px';\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };document.body.addEventListener('mouseup', function (e) {\n      RG.SVG.hideTooltip();\n    }, false);RG.SVG.REG.set('tooltip', tooltipObj);RG.SVG.REG.set('tooltip-lastx', parseFloat(tooltipObj.style.left));RG.SVG.REG.set('tooltip-lasty', parseFloat(tooltipObj.style.top));RG.SVG.fireCustomEvent(obj, 'ontooltip');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi50b29sdGlwcy5qcz9mYWMxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlLGlzUkdyYXBoU1ZHOnRydWV9O1JHcmFwaC5TVkc9UkdyYXBoLlNWR3x8e307KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoO1JHLlNWRy50b29sdGlwcz17fTtSRy5TVkcudG9vbHRpcHMuc3R5bGU9e2Rpc3BsYXk6J2lubGluZS1ibG9jaycscG9zaXRpb246J2Fic29sdXRlJyxwYWRkaW5nOic2cHgnLGZvbnRGYW1pbHk6J0FyaWFsJyxmb250U2l6ZTonMTJwdCcsZm9udFdlaWdodDonbm9ybWFsJyx0ZXh0QWxpZ246J2NlbnRlcicsbGVmdDowLHRvcDowLGJhY2tncm91bmRDb2xvcjoncmdiKDI1NSwyNTUsMjM5KScsY29sb3I6J2JsYWNrJyx2aXNpYmlsaXR5Oid2aXNpYmxlJyx6SW5kZXg6Myxib3JkZXJSYWRpdXM6JzVweCcsYm94U2hhZG93OidyZ2JhKDk2LDk2LDk2LDAuNSkgMCAwIDVweCcsdHJhbnNpdGlvbjonbGVmdCBlYXNlLW91dCAuMjVzLCB0b3AgZWFzZS1vdXQgLjI1cyd9O1JHLlNWRy50b29sdGlwPWZ1bmN0aW9uKG9wdClcbnt2YXIgb2JqPW9wdC5vYmplY3Q7UkcuU1ZHLmZpcmVDdXN0b21FdmVudChvYmosJ29uYmVmb3JldG9vbHRpcCcpO2lmKCFvcHQudGV4dHx8dHlwZW9mIG9wdC50ZXh0PT09J3VuZGVmaW5lZCd8fFJHLlNWRy50cmltKG9wdC50ZXh0KS5sZW5ndGg9PT0wKXtyZXR1cm47fVxudmFyIHByb3A9b2JqLnByb3BlcnRpZXM7aWYodHlwZW9mIHByb3AudG9vbHRpcHNPdmVycmlkZT09PSdmdW5jdGlvbicpe3JldHVybihwcm9wLnRvb2x0aXBzT3ZlcnJpZGUpKG9iaixvcHQpO31cbmlmKCFSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpKXt2YXIgdG9vbHRpcE9iaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTt0b29sdGlwT2JqLmNsYXNzTmFtZT1wcm9wLnRvb2x0aXBzQ3NzQ2xhc3M7Zm9yKHZhciBpIGluIFJHLlNWRy50b29sdGlwcy5zdHlsZSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7dG9vbHRpcE9iai5zdHlsZVtpXT1SRy5TVkcudG9vbHRpcHMuc3R5bGVbaV07fX19ZWxzZXt2YXIgdG9vbHRpcE9iaj1SRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpO3Rvb2x0aXBPYmouX19vYmplY3RfXy5yZW1vdmVIaWdobGlnaHQoKTt0b29sdGlwT2JqLnN0eWxlLndpZHRoPScnO31cbmlmKFJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwLWxhc3R5Jykpe3Rvb2x0aXBPYmouc3R5bGUubGVmdD1SRy5TVkcuUkVHLmdldCgndG9vbHRpcC1sYXN0eCcpKydweCc7dG9vbHRpcE9iai5zdHlsZS50b3A9UkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAtbGFzdHknKSsncHgnO31cbnRvb2x0aXBPYmouaW5uZXJIVE1MPW9wdC50ZXh0O3Rvb2x0aXBPYmouX190ZXh0X189b3B0LnRleHQ7dG9vbHRpcE9iai5pZD0nX19yZ3JhcGhfdG9vbHRpcF8nK29iai5pZCsnXycrb2JqLnVpZCsnXycrb3B0LmluZGV4O3Rvb2x0aXBPYmouX19ldmVudF9fPXByb3AudG9vbHRpcHNFdmVudHx8J2NsaWNrJzt0b29sdGlwT2JqLl9fb2JqZWN0X189b2JqO2lmKHR5cGVvZiBvcHQuaW5kZXg9PT0nbnVtYmVyJyl7dG9vbHRpcE9iai5fX2luZGV4X189b3B0LmluZGV4O31cbmlmKHR5cGVvZiBvcHQuZGF0YXNldD09PSdudW1iZXInKXt0b29sdGlwT2JqLl9fZGF0YXNldF9fPW9wdC5kYXRhc2V0O31cbmlmKHR5cGVvZiBvcHQuZ3JvdXA9PT0nbnVtYmVyJ3x8UkcuU1ZHLmlzTnVsbChvcHQuZ3JvdXApKXt0b29sdGlwT2JqLl9fZ3JvdXBfXz1vcHQuZ3JvdXA7fVxuaWYodHlwZW9mIG9wdC5zZXF1ZW50aWFsSW5kZXg9PT0nbnVtYmVyJyl7dG9vbHRpcE9iai5fX3NlcXVlbnRpYWxJbmRleF9fPW9wdC5zZXF1ZW50aWFsSW5kZXg7fVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b29sdGlwT2JqKTt2YXIgd2lkdGg9dG9vbHRpcE9iai5vZmZzZXRXaWR0aCxoZWlnaHQ9dG9vbHRpcE9iai5vZmZzZXRIZWlnaHQ7dG9vbHRpcE9iai5zdHlsZS5sZWZ0PW9wdC5ldmVudC5wYWdlWC0od2lkdGgvMikrJ3B4Jzt0b29sdGlwT2JqLnN0eWxlLnRvcD1vcHQuZXZlbnQucGFnZVktaGVpZ2h0LTE1KydweCc7dG9vbHRpcE9iai5zdHlsZS53aWR0aD13aWR0aCsncHgnO2lmKCFSRy5TVkcuUkVHLmdldCgndG9vbHRpcC1sYXN0eCcpKXtmb3IodmFyIGk9MDtpPD0zMDsrK2kpeyhmdW5jdGlvbihpZHgpXG57c2V0VGltZW91dChmdW5jdGlvbigpXG57dG9vbHRpcE9iai5zdHlsZS5vcGFjaXR5PShpZHgvMzApKjE7fSwoaWR4LzMwKSoyMDApO30pKGkpO319XG5pZihwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUubGVmdCk8PTUpe3Rvb2x0aXBPYmouc3R5bGUubGVmdD0nNXB4Jzt9XG5pZihwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUubGVmdCkrcGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLndpZHRoKT53aW5kb3cuaW5uZXJXaWR0aCl7dG9vbHRpcE9iai5zdHlsZS5sZWZ0PScnXG50b29sdGlwT2JqLnN0eWxlLnJpZ2h0PSc1cHgnfVxuaWYoUkcuU1ZHLmlzRml4ZWQob2JqLnN2Zykpe3ZhciBzY3JvbGxUb3A9d2luZG93LnNjcm9sbFl8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7dG9vbHRpcE9iai5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO3Rvb2x0aXBPYmouc3R5bGUudG9wPW9wdC5ldmVudC5wYWdlWS1zY3JvbGxUb3AtaGVpZ2h0LTEwKydweCc7fVxudG9vbHRpcE9iai5vbm1vdXNlZG93bj1mdW5jdGlvbihlKVxue2Uuc3RvcFByb3BhZ2F0aW9uKCk7fTt0b29sdGlwT2JqLm9ubW91c2V1cD1mdW5jdGlvbihlKVxue2Uuc3RvcFByb3BhZ2F0aW9uKCk7fTt0b29sdGlwT2JqLm9uY2xpY2s9ZnVuY3Rpb24oZSlcbntpZihlLmJ1dHRvbj09MCl7ZS5zdG9wUHJvcGFnYXRpb24oKTt9fTtkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLGZ1bmN0aW9uKGUpXG57UkcuU1ZHLmhpZGVUb29sdGlwKCk7fSxmYWxzZSk7UkcuU1ZHLlJFRy5zZXQoJ3Rvb2x0aXAnLHRvb2x0aXBPYmopO1JHLlNWRy5SRUcuc2V0KCd0b29sdGlwLWxhc3R4JyxwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUubGVmdCkpO1JHLlNWRy5SRUcuc2V0KCd0b29sdGlwLWxhc3R5JyxwYXJzZUZsb2F0KHRvb2x0aXBPYmouc3R5bGUudG9wKSk7UkcuU1ZHLmZpcmVDdXN0b21FdmVudChvYmosJ29udG9vbHRpcCcpO307fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLnRvb2x0aXBzLmpzIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///241\n");

/***/ }),
/* 242 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.HBar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'hbar';this.coords = [];this.stackedBackfaces = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 100, gutterRight: 35, gutterTop: 35, gutterBottom: 35, gutterLeftAutosize: true, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', vmargin: 3, vmarginGrouped: 2, vmarginTop: 0, vmarginBottom: 0, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisColor: 'black', xaxisLabels: [], xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsCount: 5, xaxisScale: true, xaxisUnitsPre: '', xaxisUnitsPost: '', xaxisStrict: false, xaxisDecimals: 0, xaxisPoint: '.', xaxisThousand: ',', xaxisRound: false, xaxisMax: null, xaxisMin: 0, xaxisFormatter: null, xaxisLabelsPositionEdgeTickmarksCount: null, xaxisTextColor: null, xaxisTextBold: null, xaxisTextItalic: null, xaxisTextFont: null, xaxisTextSize: null, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisLabels: [], yaxisLabelsPosition: 'section', yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisScale: false, yaxisLabelsPositionEdgeTickmarksCount: null, yaxisColor: 'black', yaxisTextFont: null, yaxisTextSize: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'left', labelsAboveValign: 'center', labelsAboveSpecific: null, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleSize: 10, titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);if (prop.gutterLeftAutosize) {\n        for (var i = 0, len = prop.yaxisLabels.length, maxLength = 0; i < len; ++i) {\n          var sizes = RG.SVG.measureText({ text: prop.yaxisLabels[i], bold: prop.yaxisTextBold || prop.textBold, size: prop.yaxisTextSize || prop.textSize, font: prop.yaxisTextFont || prop.textFont });maxLength = ma.max(maxLength, sizes[0]);\n        }\n        prop.gutterLeft = maxLength + 15;\n      }\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.xaxisMax === 'number') {\n        max = prop.xaxisMax;\n      }\n      if (prop.xaxisMin === 'mirror' || prop.xaxisMin === 'middle' || prop.xaxisMin === 'center') {\n        var mirrorScale = true;prop.xaxisMin = prop.xaxisMax * -1;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: max, min: prop.xaxisMin, point: prop.xaxisPoint, round: prop.xaxisRound, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.xaxisPoint, round: false, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });\n      }\n      this.max = this.scale.max;prop.xaxisMax = this.scale.max;this.min = this.scale.min;prop.xaxisMin = this.scale.min;RG.SVG.drawBackground(this);this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              width = this.getWidth(this.data[i]),\n              height = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length - prop.vmargin - prop.vmargin,\n              x = this.getXCoord(this.scale.min < 0 && this.scale.max < 0 || this.scale.min > 0 && this.scale.max > 0 ? this.scale.min : 0) - (this.data[i] < 0 ? width : 0),\n              y = prop.gutterTop + prop.vmarginTop + prop.vmargin + outerSegment * i;if (this.scale.min < 0 && this.scale.max < 0) {\n            x = this.width - prop.gutterRight - width;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-original-width': width, 'data-original-height': height, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              innerSegment = outerSegment - 2 * prop.vmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = (innerSegment - (this.data[i].length - 1) * prop.vmarginGrouped) / this.data[i].length,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerSegment * i + j * height + j * prop.vmarginGrouped,\n                x = this.getXCoord(0) - (this.data[i][j] < 0 ? width : 0);if (this.scale.max < 0 && this.scale.min < this.scale.max) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.max);x = x1;width = x2 - x1;\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.min);x = this.getXCoord(this.scale.min);width = x1 - x2;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-width': width, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length;var x = this.getXCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var outerHeight = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n                width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = outerHeight - 2 * prop.vmargin,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerHeight * i;if (j === 0 && prop.shadow) {\n              var fullWidth = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphWidth);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: x, y: y, width: fullWidth, height: height, fill: 'white', 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-width': width, 'data-original-height': height, 'data-original-x': x, 'data-original-y': y, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n            x += width;\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getXCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var x;if (value < this.scale.min) {\n        return null;\n      }\n      x = (value - this.scale.min) / (this.scale.max - this.scale.min);x *= this.graphWidth;x += prop.gutterLeft;return x;\n    };this.getWidth = function (value) {\n      if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n        var x1 = this.getXCoord(this.scale.max);var x2 = this.getXCoord(value);\n      } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n        var x1 = this.getXCoord(this.scale.min);var x2 = this.getXCoord(value);\n      } else {\n        var x1 = this.getXCoord(0);var x2 = this.getXCoord(value);\n      }\n      return ma.abs(x1 - x2);\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i], direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data = RG.SVG.arrayLinearize(this.data);for (var i = 0; i < this.coords.length; ++i) {\n          var value = data[i].toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);if (RG.SVG.isArray(this.data[indexes[0]]) && prop.grouping === 'stacked') {\n            if (indexes[1] + 1 === this.data[indexes[0]].length) {\n              value = RG.SVG.arraySum(this.data[indexes[0]]);value = value.toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);\n            } else {\n              continue;\n            }\n          }\n          var str = prop.labelsAboveSpecific ? prop.labelsAboveSpecific[i].toString() : RG.SVG.numberFormat({ object: this, num: value, prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });var bold = typeof prop.labelsAboveBold === 'boolean' ? prop.labelsAboveBold : prop.textBold,\n              italic = typeof prop.labelsAboveItalic === 'boolean' ? prop.labelsAboveItalic : prop.textItalic,\n              size = prop.labelsAboveSize || prop.textSize,\n              font = prop.labelsAboveFont || prop.textFont,\n              halign = prop.labelsAboveHalign,\n              valign = prop.labelsAboveValign;var dimensions = RG.SVG.measureText({ text: str, bold: bold, font: font, size: size });var x = value >= 0 ? parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width')) + 7 + prop.labelsAboveOffsetx : parseFloat(this.coords[i].object.getAttribute('x') - 7 - prop.labelsAboveOffsetx),\n              y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height') / 2) + prop.labelsAboveOffsety,\n              width = dimensions[0],\n              height = dimensions[1],\n              halign = value >= 0 ? 'left' : 'right';if (x + width > this.width && value > 0) {\n            halign = 'right';x = this.width - 5;prop.labelsAboveBackground = prop.labelsAboveBackground || 'rgba(255,255,255,0.95)';\n          }\n          var text = RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: halign, valign: valign, font: font, size: size, bold: bold, italic: italic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            width = ma.abs(obj.getXCoord(data[i]) - obj.getXCoord(0));obj.data[i] = data[i] * multiplier;width = multiplier * width;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i] > 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeWidth = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              width = ma.abs(obj.getXCoord(data[i][j]) - obj.getXCoord(0));width = multiplier * width;obj.data[i][j] = data[i][j] * multiplier;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i][j] > 0 ? obj.getXCoord(0) + accumulativeWidth : obj.getXCoord(0) - width - accumulativeWidth);accumulativeWidth += prop.grouping === 'stacked' ? width : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('width', accumulativeWidth);obj.stackedBackfaces[i].setAttribute('x', prop.gutterLeft);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {},\n          width;for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('width', 0);\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalWidth = obj.coords[i].object.getAttribute('data-original-width'),\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));obj.coords[i].object.setAttribute('width', width = ma.min((frame - opt.startFrames[i]) / framesperbar * originalWidth, originalWidth));obj.coords[i].object.setAttribute('x', value >= 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('x', parseInt(obj.coords[i - 1].object.getAttribute('x')) + parseInt(obj.coords[i - 1].object.getAttribute('width')));\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmhiYXIuanM/ZDgzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlNWRz1SR3JhcGguU1ZHfHx7fTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57dmFyIFJHPVJHcmFwaCx1YT1uYXZpZ2F0b3IudXNlckFnZW50LG1hPU1hdGgsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQ7UkcuU1ZHLkhCYXI9ZnVuY3Rpb24oY29uZilcbnt0aGlzLnNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtmb3IoaSBpbiBhcmd1bWVudHNbMF0pe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTppLHZhbHVlOmFyZ3VtZW50c1swXVtpXX0pO25hbWU9cmV0Lm5hbWU7dmFsdWU9cmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsdmFsdWUpO319fWVsc2V7dmFyIHJldD1SRy5TVkcuY29tbW9uU2V0dGVyKHtvYmplY3Q6dGhpcyxuYW1lOm5hbWUsdmFsdWU6dmFsdWV9KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnByb3BlcnRpZXNbbmFtZV09dmFsdWU7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmlkPWNvbmYuaWQ7dGhpcy51aWQ9UkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnPVJHLlNWRy5jcmVhdGVTVkcoe2NvbnRhaW5lcjp0aGlzLmNvbnRhaW5lcn0pO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLndpZHRoPU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0PU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTt0aGlzLmRhdGE9Y29uZi5kYXRhO3RoaXMudHlwZT0naGJhcic7dGhpcy5jb29yZHM9W107dGhpcy5zdGFja2VkQmFja2ZhY2VzPVtdO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMub3JpZ2luYWxDb2xvcnM9e307dGhpcy5ncmFkaWVudENvdW50ZXI9MTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9J2lubGluZS1ibG9jayc7dGhpcy5wcm9wZXJ0aWVzPXtndXR0ZXJMZWZ0OjEwMCxndXR0ZXJSaWdodDozNSxndXR0ZXJUb3A6MzUsZ3V0dGVyQm90dG9tOjM1LGd1dHRlckxlZnRBdXRvc2l6ZTp0cnVlLGJhY2tncm91bmRDb2xvcjpudWxsLGJhY2tncm91bmRJbWFnZTpudWxsLGJhY2tncm91bmRJbWFnZUFzcGVjdDonbm9uZScsYmFja2dyb3VuZEltYWdlU3RyZXRjaDp0cnVlLGJhY2tncm91bmRJbWFnZU9wYWNpdHk6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VYOm51bGwsYmFja2dyb3VuZEltYWdlWTpudWxsLGJhY2tncm91bmRJbWFnZVc6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VIOm51bGwsYmFja2dyb3VuZEdyaWQ6dHJ1ZSxiYWNrZ3JvdW5kR3JpZENvbG9yOicjZGRkJyxiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDoxLGJhY2tncm91bmRHcmlkSGxpbmVzOnRydWUsYmFja2dyb3VuZEdyaWRIbGluZXNDb3VudDpudWxsLGJhY2tncm91bmRHcmlkVmxpbmVzOnRydWUsYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudDpudWxsLGJhY2tncm91bmRHcmlkQm9yZGVyOnRydWUsY29sb3JzOlsncmVkJywnIzBmMCcsJyMwMGYnLCcjZmYwJywnIzBmZicsJyMwZjAnLCdwaW5rJywnb3JhbmdlJywnZ3JheScsJ2JsYWNrJywncmVkJywnIzBmMCcsJyMwMGYnLCcjZmYwJywnIzBmZicsJyMwZjAnLCdwaW5rJywnb3JhbmdlJywnZ3JheScsJ2JsYWNrJ10sY29sb3JzU2VxdWVudGlhbDpmYWxzZSxzdHJva2VzdHlsZToncmdiYSgwLDAsMCwwKScsdm1hcmdpbjozLHZtYXJnaW5Hcm91cGVkOjIsdm1hcmdpblRvcDowLHZtYXJnaW5Cb3R0b206MCx4YXhpczp0cnVlLHhheGlzVGlja21hcmtzOnRydWUseGF4aXNUaWNrbWFya3NMZW5ndGg6NSx4YXhpc0NvbG9yOidibGFjaycseGF4aXNMYWJlbHM6W10seGF4aXNMYWJlbHNPZmZzZXR4OjAseGF4aXNMYWJlbHNPZmZzZXR5OjAseGF4aXNMYWJlbHNDb3VudDo1LHhheGlzU2NhbGU6dHJ1ZSx4YXhpc1VuaXRzUHJlOicnLHhheGlzVW5pdHNQb3N0OicnLHhheGlzU3RyaWN0OmZhbHNlLHhheGlzRGVjaW1hbHM6MCx4YXhpc1BvaW50OicuJyx4YXhpc1Rob3VzYW5kOicsJyx4YXhpc1JvdW5kOmZhbHNlLHhheGlzTWF4Om51bGwseGF4aXNNaW46MCx4YXhpc0Zvcm1hdHRlcjpudWxsLHhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ6bnVsbCx4YXhpc1RleHRDb2xvcjpudWxsLHhheGlzVGV4dEJvbGQ6bnVsbCx4YXhpc1RleHRJdGFsaWM6bnVsbCx4YXhpc1RleHRGb250Om51bGwseGF4aXNUZXh0U2l6ZTpudWxsLHlheGlzOnRydWUseWF4aXNUaWNrbWFya3M6dHJ1ZSx5YXhpc1RpY2ttYXJrc0xlbmd0aDozLHlheGlzTGFiZWxzOltdLHlheGlzTGFiZWxzUG9zaXRpb246J3NlY3Rpb24nLHlheGlzTGFiZWxzT2Zmc2V0eDowLHlheGlzTGFiZWxzT2Zmc2V0eTowLHlheGlzU2NhbGU6ZmFsc2UseWF4aXNMYWJlbHNQb3NpdGlvbkVkZ2VUaWNrbWFya3NDb3VudDpudWxsLHlheGlzQ29sb3I6J2JsYWNrJyx5YXhpc1RleHRGb250Om51bGwseWF4aXNUZXh0U2l6ZTpudWxsLHlheGlzVGV4dENvbG9yOm51bGwseWF4aXNUZXh0Qm9sZDpudWxsLHlheGlzVGV4dEl0YWxpYzpudWxsLHRleHRDb2xvcjonYmxhY2snLHRleHRGb250OidzYW5zLXNlcmlmJyx0ZXh0U2l6ZToxMix0ZXh0Qm9sZDpmYWxzZSx0ZXh0SXRhbGljOmZhbHNlLGxhYmVsc0Fib3ZlOmZhbHNlLGxhYmVsc0Fib3ZlRm9udDpudWxsLGxhYmVsc0Fib3ZlU2l6ZTpudWxsLGxhYmVsc0Fib3ZlQm9sZDpudWxsLGxhYmVsc0Fib3ZlSXRhbGljOm51bGwsbGFiZWxzQWJvdmVDb2xvcjpudWxsLGxhYmVsc0Fib3ZlQmFja2dyb3VuZDpudWxsLGxhYmVsc0Fib3ZlQmFja2dyb3VuZFBhZGRpbmc6MCxsYWJlbHNBYm92ZVVuaXRzUHJlOm51bGwsbGFiZWxzQWJvdmVVbml0c1Bvc3Q6bnVsbCxsYWJlbHNBYm92ZVBvaW50Om51bGwsbGFiZWxzQWJvdmVUaG91c2FuZDpudWxsLGxhYmVsc0Fib3ZlRm9ybWF0dGVyOm51bGwsbGFiZWxzQWJvdmVEZWNpbWFsczpudWxsLGxhYmVsc0Fib3ZlT2Zmc2V0eDowLGxhYmVsc0Fib3ZlT2Zmc2V0eTowLGxhYmVsc0Fib3ZlSGFsaWduOidsZWZ0JyxsYWJlbHNBYm92ZVZhbGlnbjonY2VudGVyJyxsYWJlbHNBYm92ZVNwZWNpZmljOm51bGwsbGluZXdpZHRoOjEsZ3JvdXBpbmc6J2dyb3VwZWQnLHRvb2x0aXBzOm51bGwsdG9vbHRpcHNPdmVycmlkZTpudWxsLHRvb2x0aXBzRWZmZWN0OidmYWRlJyx0b29sdGlwc0Nzc0NsYXNzOidSR3JhcGhfdG9vbHRpcCcsdG9vbHRpcHNFdmVudDonY2xpY2snLGhpZ2hsaWdodFN0cm9rZToncmdiYSgwLDAsMCwwKScsaGlnaGxpZ2h0RmlsbDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxoaWdobGlnaHRMaW5ld2lkdGg6MSx0aXRsZTonJyx0aXRsZVNpemU6MTYsdGl0bGVYOm51bGwsdGl0bGVZOm51bGwsdGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVWYWxpZ246bnVsbCx0aXRsZUNvbG9yOidibGFjaycsdGl0bGVGb250Om51bGwsdGl0bGVCb2xkOmZhbHNlLHRpdGxlSXRhbGljOmZhbHNlLHRpdGxlU3VidGl0bGU6JycsdGl0bGVTdWJ0aXRsZVg6bnVsbCx0aXRsZVN1YnRpdGxlWTpudWxsLHRpdGxlU3VidGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVTdWJ0aXRsZVZhbGlnbjpudWxsLHRpdGxlU3VidGl0bGVDb2xvcjonI2FhYScsdGl0bGVTdWJ0aXRsZVNpemU6MTAsdGl0bGVTdWJ0aXRsZUZvbnQ6bnVsbCx0aXRsZVN1YnRpdGxlQm9sZDpmYWxzZSx0aXRsZVN1YnRpdGxlSXRhbGljOmZhbHNlLHNoYWRvdzpmYWxzZSxzaGFkb3dPZmZzZXR4OjIsc2hhZG93T2Zmc2V0eToyLHNoYWRvd0JsdXI6MixzaGFkb3dPcGFjaXR5OjAuMjUsa2V5Om51bGwsa2V5Q29sb3JzOm51bGwsa2V5T2Zmc2V0eDowLGtleU9mZnNldHk6MCxrZXlUZXh0T2Zmc2V0eDowLGtleVRleHRPZmZzZXR5Oi0xLGtleVRleHRTaXplOm51bGwsa2V5VGV4dEJvbGQ6bnVsbCxrZXlUZXh0SXRhbGljOm51bGwsYXR0cmlidXRpb246dHJ1ZSxhdHRyaWJ1dGlvblg6bnVsbCxhdHRyaWJ1dGlvblk6bnVsbCxhdHRyaWJ1dGlvbkhyZWY6bnVsbCxhdHRyaWJ1dGlvbkhhbGlnbjoncmlnaHQnLGF0dHJpYnV0aW9uVmFsaWduOidib3R0b20nLGF0dHJpYnV0aW9uU2l6ZTo3LGF0dHJpYnV0aW9uQ29sb3I6J2dyYXknLGF0dHJpYnV0aW9uRm9udDonc2Fucy1zZXJpZicsYXR0cmlidXRpb25JdGFsaWM6ZmFsc2UsYXR0cmlidXRpb25Cb2xkOmZhbHNlfTtpZihSRy5TVkcuRlgmJnR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7fVxudmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO3RoaXMuZHJhdz1mdW5jdGlvbigpXG57UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTtSRy5TVkcuY3JlYXRlRGVmcyh0aGlzKTtpZihwcm9wLmd1dHRlckxlZnRBdXRvc2l6ZSl7Zm9yKHZhciBpPTAsbGVuPXByb3AueWF4aXNMYWJlbHMubGVuZ3RoLG1heExlbmd0aD0wO2k8bGVuOysraSl7dmFyIHNpemVzPVJHLlNWRy5tZWFzdXJlVGV4dCh7dGV4dDpwcm9wLnlheGlzTGFiZWxzW2ldLGJvbGQ6cHJvcC55YXhpc1RleHRCb2xkfHxwcm9wLnRleHRCb2xkLHNpemU6cHJvcC55YXhpc1RleHRTaXplfHxwcm9wLnRleHRTaXplLGZvbnQ6cHJvcC55YXhpc1RleHRGb250fHxwcm9wLnRleHRGb250fSk7bWF4TGVuZ3RoPW1hLm1heChtYXhMZW5ndGgsc2l6ZXNbMF0pO31cbnByb3AuZ3V0dGVyTGVmdD1tYXhMZW5ndGgrMTU7fVxudGhpcy5ncmFwaFdpZHRoPXRoaXMud2lkdGgtcHJvcC5ndXR0ZXJMZWZ0LXByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodD10aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbTtSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHtvYmplY3Q6dGhpc30pO3RoaXMucGFyc2VDb2xvcnMoKTt2YXIgdmFsdWVzPVtdO2Zvcih2YXIgaT0wLG1heD0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0nbnVtYmVyJyl7dmFsdWVzLnB1c2godGhpcy5kYXRhW2ldKTt9ZWxzZSBpZihSRy5TVkcuaXNBcnJheSh0aGlzLmRhdGFbaV0pJiZwcm9wLmdyb3VwaW5nPT09J2dyb3VwZWQnKXt2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlNYXgodGhpcy5kYXRhW2ldKSk7fWVsc2UgaWYoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcC5ncm91cGluZz09PSdzdGFja2VkJyl7dmFsdWVzLnB1c2goUkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkpO319XG52YXIgbWF4PVJHLlNWRy5hcnJheU1heCh2YWx1ZXMpO2lmKHR5cGVvZiBwcm9wLnhheGlzTWF4PT09J251bWJlcicpe21heD1wcm9wLnhheGlzTWF4O31cbmlmKHByb3AueGF4aXNNaW49PT0nbWlycm9yJ3x8cHJvcC54YXhpc01pbj09PSdtaWRkbGUnfHxwcm9wLnhheGlzTWluPT09J2NlbnRlcicpe3ZhciBtaXJyb3JTY2FsZT10cnVlO3Byb3AueGF4aXNNaW49cHJvcC54YXhpc01heCogLTE7fVxudGhpcy5zY2FsZT1SRy5TVkcuZ2V0U2NhbGUoe29iamVjdDp0aGlzLG51bWxhYmVsczpwcm9wLnhheGlzTGFiZWxzQ291bnQsdW5pdHNQcmU6cHJvcC54YXhpc1VuaXRzUHJlLHVuaXRzUG9zdDpwcm9wLnhheGlzVW5pdHNQb3N0LG1heDptYXgsbWluOnByb3AueGF4aXNNaW4scG9pbnQ6cHJvcC54YXhpc1BvaW50LHJvdW5kOnByb3AueGF4aXNSb3VuZCx0aG91c2FuZDpwcm9wLnhheGlzVGhvdXNhbmQsZGVjaW1hbHM6cHJvcC54YXhpc0RlY2ltYWxzLHN0cmljdDp0eXBlb2YgcHJvcC54YXhpc01heD09PSdudW1iZXInLGZvcm1hdHRlcjpwcm9wLnhheGlzRm9ybWF0dGVyfSk7aWYobWlycm9yU2NhbGUpe3RoaXMuc2NhbGU9UkcuU1ZHLmdldFNjYWxlKHtvYmplY3Q6dGhpcyxudW1sYWJlbHM6cHJvcC54YXhpc0xhYmVsc0NvdW50LHVuaXRzUHJlOnByb3AueGF4aXNVbml0c1ByZSx1bml0c1Bvc3Q6cHJvcC54YXhpc1VuaXRzUG9zdCxtYXg6dGhpcy5zY2FsZS5tYXgsbWluOnRoaXMuc2NhbGUubWF4KiAtMSxwb2ludDpwcm9wLnhheGlzUG9pbnQscm91bmQ6ZmFsc2UsdGhvdXNhbmQ6cHJvcC54YXhpc1Rob3VzYW5kLGRlY2ltYWxzOnByb3AueGF4aXNEZWNpbWFscyxzdHJpY3Q6dHlwZW9mIHByb3AueGF4aXNNYXg9PT0nbnVtYmVyJyxmb3JtYXR0ZXI6cHJvcC54YXhpc0Zvcm1hdHRlcn0pO31cbnRoaXMubWF4PXRoaXMuc2NhbGUubWF4O3Byb3AueGF4aXNNYXg9dGhpcy5zY2FsZS5tYXg7dGhpcy5taW49dGhpcy5zY2FsZS5taW47cHJvcC54YXhpc01pbj10aGlzLnNjYWxlLm1pbjtSRy5TVkcuZHJhd0JhY2tncm91bmQodGhpcyk7dGhpcy5kcmF3QmFycygpO1JHLlNWRy5kcmF3WEF4aXModGhpcyk7UkcuU1ZHLmRyYXdZQXhpcyh0aGlzKTt0aGlzLmRyYXdMYWJlbHNBYm92ZSgpO2lmKHR5cGVvZiBwcm9wLmtleSE9PW51bGwmJlJHLlNWRy5kcmF3S2V5KXtSRy5TVkcuZHJhd0tleSh0aGlzKTt9ZWxzZSBpZighUkdyYXBoLlNWRy5pc051bGwocHJvcC5rZXkpKXthbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTt9XG5SRy5TVkcuYXR0cmlidXRpb24odGhpcyk7dmFyIG9iaj10aGlzO2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxmdW5jdGlvbihlKVxue1JHLlNWRy5yZW1vdmVIaWdobGlnaHQob2JqKTt9LGZhbHNlKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFycz1mdW5jdGlvbigpXG57aWYocHJvcC5zaGFkb3cpe1JHLlNWRy5zZXRTaGFkb3coe29iamVjdDp0aGlzLG9mZnNldHg6cHJvcC5zaGFkb3dPZmZzZXR4LG9mZnNldHk6cHJvcC5zaGFkb3dPZmZzZXR5LGJsdXI6cHJvcC5zaGFkb3dCbHVyLG9wYWNpdHk6cHJvcC5zaGFkb3dPcGFjaXR5LGlkOidkcm9wU2hhZG93J30pO31cbmZvcih2YXIgaT0wLHNlcXVlbnRpYWxJbmRleD0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2ksKytzZXF1ZW50aWFsSW5kZXgpe2lmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0nbnVtYmVyJyl7dmFyIG91dGVyU2VnbWVudD0odGhpcy5ncmFwaEhlaWdodC1wcm9wLnZtYXJnaW5Ub3AtcHJvcC52bWFyZ2luQm90dG9tKS90aGlzLmRhdGEubGVuZ3RoLHdpZHRoPXRoaXMuZ2V0V2lkdGgodGhpcy5kYXRhW2ldKSxoZWlnaHQ9KCh0aGlzLmdyYXBoSGVpZ2h0LXByb3Audm1hcmdpblRvcC1wcm9wLnZtYXJnaW5Cb3R0b20pL3RoaXMuZGF0YS5sZW5ndGgpLXByb3Audm1hcmdpbi1wcm9wLnZtYXJnaW4seD10aGlzLmdldFhDb29yZCgodGhpcy5zY2FsZS5taW48MCYmdGhpcy5zY2FsZS5tYXg8MCl8fCh0aGlzLnNjYWxlLm1pbj4wJiZ0aGlzLnNjYWxlLm1heD4wKT90aGlzLnNjYWxlLm1pbjowKS0odGhpcy5kYXRhW2ldPDA/d2lkdGg6MCkseT1wcm9wLmd1dHRlclRvcCtwcm9wLnZtYXJnaW5Ub3ArcHJvcC52bWFyZ2luKyhvdXRlclNlZ21lbnQqaSk7aWYodGhpcy5zY2FsZS5taW48MCYmdGhpcy5zY2FsZS5tYXg8MCl7eD10aGlzLndpZHRoLXByb3AuZ3V0dGVyUmlnaHQtd2lkdGg7fVxudmFyIHJlY3Q9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncmVjdCcsYXR0cjp7c3Ryb2tlOnByb3Auc3Ryb2tlc3R5bGUsZmlsbDpwcm9wLmNvbG9yc1NlcXVlbnRpYWw/KHByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0/cHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XTpwcm9wLmNvbG9yc1twcm9wLmNvbG9ycy5sZW5ndGgtMV0pOnByb3AuY29sb3JzWzBdLHg6eCx5Onksd2lkdGg6d2lkdGgsaGVpZ2h0OmhlaWdodCwnc3Ryb2tlLXdpZHRoJzpwcm9wLmxpbmV3aWR0aCwnZGF0YS10b29sdGlwJzooIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykmJnByb3AudG9vbHRpcHMubGVuZ3RoKT9wcm9wLnRvb2x0aXBzW2ldOicnLCdkYXRhLWluZGV4JzppLCdkYXRhLW9yaWdpbmFsLXdpZHRoJzp3aWR0aCwnZGF0YS1vcmlnaW5hbC1oZWlnaHQnOmhlaWdodCwnZGF0YS1zZXF1ZW50aWFsLWluZGV4JzpzZXF1ZW50aWFsSW5kZXgsJ2RhdGEtdmFsdWUnOnRoaXMuZGF0YVtpXSxmaWx0ZXI6cHJvcC5zaGFkb3c/J3VybCgjZHJvcFNoYWRvdyknOicnfX0pO3RoaXMuY29vcmRzLnB1c2goe29iamVjdDpyZWN0LHg6eCx5OnktKHRoaXMuZGF0YVtpXT4wP2hlaWdodDowKSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0fSk7aWYoIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykmJnByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSl7dmFyIG9iaj10aGlzOyhmdW5jdGlvbihpZHgsc2VxKVxue3JlY3QuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQucmVwbGFjZSgvXm9uLywnJyksZnVuY3Rpb24oZSlcbntvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7UkcuU1ZHLnRvb2x0aXAoe29iamVjdDpvYmosaW5kZXg6aWR4LGdyb3VwOm51bGwsc2VxdWVudGlhbEluZGV4OnNlcSx0ZXh0OnByb3AudG9vbHRpcHNbc2VxXSxldmVudDplfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7fSxmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGUpXG57ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdwb2ludGVyJzt9LGZhbHNlKTt9KShpLHNlcXVlbnRpYWxJbmRleCk7fX1lbHNlIGlmKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkmJnByb3AuZ3JvdXBpbmc9PT0nZ3JvdXBlZCcpe3ZhciBvdXRlclNlZ21lbnQ9KCh0aGlzLmdyYXBoSGVpZ2h0LXByb3Audm1hcmdpblRvcC1wcm9wLnZtYXJnaW5Cb3R0b20pL3RoaXMuZGF0YS5sZW5ndGgpLGlubmVyU2VnbWVudD1vdXRlclNlZ21lbnQtKDIqcHJvcC52bWFyZ2luKTtmb3IodmFyIGo9MDtqPHRoaXMuZGF0YVtpXS5sZW5ndGg7KytqLCsrc2VxdWVudGlhbEluZGV4KXt2YXIgd2lkdGg9bWEuYWJzKCh0aGlzLmRhdGFbaV1bal0vKHRoaXMubWF4LXRoaXMubWluKSkqdGhpcy5ncmFwaFdpZHRoKSxoZWlnaHQ9KChpbm5lclNlZ21lbnQtKCh0aGlzLmRhdGFbaV0ubGVuZ3RoLTEpKnByb3Audm1hcmdpbkdyb3VwZWQpKS90aGlzLmRhdGFbaV0ubGVuZ3RoKSx5PXByb3AuZ3V0dGVyVG9wK3Byb3Audm1hcmdpbitwcm9wLnZtYXJnaW5Ub3ArKG91dGVyU2VnbWVudCppKSsoaipoZWlnaHQpKyhqKnByb3Audm1hcmdpbkdyb3VwZWQpLHg9dGhpcy5nZXRYQ29vcmQoMCktKHRoaXMuZGF0YVtpXVtqXTwwP3dpZHRoOjApO2lmKHRoaXMuc2NhbGUubWF4PDAmJnRoaXMuc2NhbGUubWluPHRoaXMuc2NhbGUubWF4KXt2YXIgeDE9dGhpcy5nZXRYQ29vcmQodGhpcy5kYXRhW2ldW2pdKTt2YXIgeDI9dGhpcy5nZXRYQ29vcmQodGhpcy5zY2FsZS5tYXgpO3g9eDE7d2lkdGg9eDIteDE7fWVsc2UgaWYodGhpcy5zY2FsZS5taW4+MCYmdGhpcy5zY2FsZS5tYXg+dGhpcy5zY2FsZS5taW4pe3ZhciB4MT10aGlzLmdldFhDb29yZCh0aGlzLmRhdGFbaV1bal0pO3ZhciB4Mj10aGlzLmdldFhDb29yZCh0aGlzLnNjYWxlLm1pbik7eD10aGlzLmdldFhDb29yZCh0aGlzLnNjYWxlLm1pbik7d2lkdGg9eDEteDI7fVxudmFyIHJlY3Q9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3JlY3QnLHBhcmVudDp0aGlzLnN2Zy5hbGwsYXR0cjp7c3Ryb2tlOnByb3BbJ3N0cm9rZXN0eWxlJ10sZmlsbDoocHJvcC5jb2xvcnNTZXF1ZW50aWFsJiZwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdKT9wcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdOihwcm9wLmNvbG9yc1tqXT9wcm9wLmNvbG9yc1tqXTpwcm9wLmNvbG9yc1twcm9wLmNvbG9ycy5sZW5ndGgtMV0pLHg6eCx5Onksd2lkdGg6d2lkdGgsaGVpZ2h0OmhlaWdodCwnc3Ryb2tlLXdpZHRoJzpwcm9wLmxpbmV3aWR0aCwnZGF0YS1pbmRleCc6aSwnZGF0YS1vcmlnaW5hbC13aWR0aCc6d2lkdGgsJ2RhdGEtc2VxdWVudGlhbC1pbmRleCc6c2VxdWVudGlhbEluZGV4LCdkYXRhLXRvb2x0aXAnOighUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSYmcHJvcC50b29sdGlwcy5sZW5ndGgpP3Byb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XTonJywnZGF0YS12YWx1ZSc6dGhpcy5kYXRhW2ldW2pdLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6Jyd9fSk7dGhpcy5jb29yZHMucHVzaCh7b2JqZWN0OnJlY3QseDp4LHk6eS0odGhpcy5kYXRhW2ldW2pdPjA/aGVpZ2h0OjApLHdpZHRoOndpZHRoLGhlaWdodDpoZWlnaHR9KTtpZighUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSYmcHJvcC50b29sdGlwc1tzZXF1ZW50aWFsSW5kZXhdKXt2YXIgb2JqPXRoaXM7KGZ1bmN0aW9uKGlkeCxzZXEpXG57dmFyIGluZGV4ZXM9UkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsb2JqLmRhdGEpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQucmVwbGFjZSgvXm9uLywnJyksZnVuY3Rpb24oZSlcbntvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7UkcuU1ZHLnRvb2x0aXAoe29iamVjdDpvYmosZ3JvdXA6aWR4LGluZGV4OmluZGV4ZXNbMV0sc2VxdWVudGlhbEluZGV4OnNlcSx0ZXh0OnByb3AudG9vbHRpcHNbc2VxXSxldmVudDplfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7fSxmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGUpXG57ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdwb2ludGVyJ30sZmFsc2UpO30pKGksc2VxdWVudGlhbEluZGV4KTt9fVxuLS1zZXF1ZW50aWFsSW5kZXg7fWVsc2UgaWYoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSYmcHJvcC5ncm91cGluZz09PSdzdGFja2VkJyl7dmFyIHNlY3Rpb249KCh0aGlzLmdyYXBoSGVpZ2h0LXByb3Audm1hcmdpblRvcC1wcm9wLnZtYXJnaW5Cb3R0b20pL3RoaXMuZGF0YS5sZW5ndGgpO3ZhciB4PXRoaXMuZ2V0WENvb3JkKDApO2Zvcih2YXIgaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2osKytzZXF1ZW50aWFsSW5kZXgpe3ZhciBvdXRlckhlaWdodD0odGhpcy5ncmFwaEhlaWdodC1wcm9wLnZtYXJnaW5Ub3AtcHJvcC52bWFyZ2luQm90dG9tKS90aGlzLmRhdGEubGVuZ3RoLHdpZHRoPW1hLmFicygodGhpcy5kYXRhW2ldW2pdLyh0aGlzLm1heC10aGlzLm1pbikpKnRoaXMuZ3JhcGhXaWR0aCksaGVpZ2h0PW91dGVySGVpZ2h0LSgyKnByb3Audm1hcmdpbikseT1wcm9wLmd1dHRlclRvcCtwcm9wLnZtYXJnaW4rcHJvcC52bWFyZ2luVG9wKyhvdXRlckhlaWdodCppKTtpZihqPT09MCYmcHJvcC5zaGFkb3cpe3ZhciBmdWxsV2lkdGg9bWEuYWJzKChSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKS8odGhpcy5tYXgtdGhpcy5taW4pKSp0aGlzLmdyYXBoV2lkdGgpO3ZhciByZWN0PVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J3JlY3QnLGF0dHI6e3g6eCx5Onksd2lkdGg6ZnVsbFdpZHRoLGhlaWdodDpoZWlnaHQsZmlsbDond2hpdGUnLCdzdHJva2Utd2lkdGgnOjAsJ2RhdGEtaW5kZXgnOmksZmlsdGVyOid1cmwoI2Ryb3BTaGFkb3cpJ319KTt0aGlzLnN0YWNrZWRCYWNrZmFjZXNbaV09cmVjdDt9XG52YXIgcmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncmVjdCcscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntzdHJva2U6cHJvcFsnc3Ryb2tlc3R5bGUnXSxmaWxsOnByb3AuY29sb3JzU2VxdWVudGlhbD8ocHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XT9wcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdOnByb3AuY29sb3JzW3Byb3AuY29sb3JzLmxlbmd0aC0xXSk6KHByb3AuY29sb3JzW2pdP3Byb3AuY29sb3JzW2pdOnByb3AuY29sb3JzW3Byb3AuY29sb3JzLmxlbmd0aC0xXSkseDp4LHk6eSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0LCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdkYXRhLW9yaWdpbmFsLXdpZHRoJzp3aWR0aCwnZGF0YS1vcmlnaW5hbC1oZWlnaHQnOmhlaWdodCwnZGF0YS1vcmlnaW5hbC14Jzp4LCdkYXRhLW9yaWdpbmFsLXknOnksJ2RhdGEtaW5kZXgnOmksJ2RhdGEtc2VxdWVudGlhbC1pbmRleCc6c2VxdWVudGlhbEluZGV4LCdkYXRhLXRvb2x0aXAnOighUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSYmcHJvcC50b29sdGlwcy5sZW5ndGgpP3Byb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XTonJywnZGF0YS12YWx1ZSc6dGhpcy5kYXRhW2ldW2pdfX0pO3RoaXMuY29vcmRzLnB1c2goe29iamVjdDpyZWN0LHg6eCx5Onksd2lkdGg6d2lkdGgsaGVpZ2h0OmhlaWdodH0pO2lmKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pe3ZhciBvYmo9dGhpczsoZnVuY3Rpb24oaWR4LHNlcSlcbntyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sJycpLGZ1bmN0aW9uKGUpXG57b2JqLnJlbW92ZUhpZ2hsaWdodCgpO3ZhciBpbmRleGVzPVJHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQoc2VxLG9iai5kYXRhKTtSRy5TVkcudG9vbHRpcCh7b2JqZWN0Om9iaixpbmRleDppbmRleGVzWzFdLGdyb3VwOmlkeCxzZXF1ZW50aWFsSW5kZXg6c2VxLHRleHQ6cHJvcC50b29sdGlwc1tzZXFdLGV2ZW50OmV9KTtvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTt9LGZhbHNlKTtyZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZnVuY3Rpb24oZSlcbntlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInfSxmYWxzZSk7fSkoaSxzZXF1ZW50aWFsSW5kZXgpO31cbngrPXdpZHRoO31cbi0tc2VxdWVudGlhbEluZGV4O319fTt0aGlzLmdldFhDb29yZD1mdW5jdGlvbih2YWx1ZSlcbnt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7aWYodmFsdWU+dGhpcy5zY2FsZS5tYXgpe3JldHVybiBudWxsO31cbnZhciB4O2lmKHZhbHVlPHRoaXMuc2NhbGUubWluKXtyZXR1cm4gbnVsbDt9XG54PSgodmFsdWUtdGhpcy5zY2FsZS5taW4pLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpO3gqPXRoaXMuZ3JhcGhXaWR0aDt4Kz1wcm9wLmd1dHRlckxlZnQ7cmV0dXJuIHg7fTt0aGlzLmdldFdpZHRoPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHRoaXMuc2NhbGUubWF4PD0wJiZ0aGlzLnNjYWxlLm1pbjx0aGlzLnNjYWxlLm1heCl7dmFyIHgxPXRoaXMuZ2V0WENvb3JkKHRoaXMuc2NhbGUubWF4KTt2YXIgeDI9dGhpcy5nZXRYQ29vcmQodmFsdWUpO31lbHNlIGlmKHRoaXMuc2NhbGUubWluPjAmJnRoaXMuc2NhbGUubWF4PnRoaXMuc2NhbGUubWluKXt2YXIgeDE9dGhpcy5nZXRYQ29vcmQodGhpcy5zY2FsZS5taW4pO3ZhciB4Mj10aGlzLmdldFhDb29yZCh2YWx1ZSk7fWVsc2V7dmFyIHgxPXRoaXMuZ2V0WENvb3JkKDApO3ZhciB4Mj10aGlzLmdldFhDb29yZCh2YWx1ZSk7fVxucmV0dXJuIG1hLmFicyh4MS14Mik7fTt0aGlzLmhpZ2hsaWdodD1mdW5jdGlvbihyZWN0KVxue3ZhciB4PXJlY3QuZ2V0QXR0cmlidXRlKCd4JykseT1yZWN0LmdldEF0dHJpYnV0ZSgneScpLHdpZHRoPXJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLGhlaWdodD1yZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7dmFyIGhpZ2hsaWdodD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncmVjdCcscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntzdHJva2U6cHJvcC5oaWdobGlnaHRTdHJva2UsZmlsbDpwcm9wLmhpZ2hsaWdodEZpbGwseDp4LHk6eSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0LCdzdHJva2Utd2lkdGgnOnByb3AuaGlnaGxpZ2h0TGluZXdpZHRofX0pO1JHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLGhpZ2hsaWdodCk7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZighT2JqZWN0LmtleXModGhpcy5vcmlnaW5hbENvbG9ycykubGVuZ3RoKXt0aGlzLm9yaWdpbmFsQ29sb3JzPXtjb2xvcnM6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLGJhY2tncm91bmRHcmlkQ29sb3I6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yKSxoaWdobGlnaHRGaWxsOlJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksYmFja2dyb3VuZENvbG9yOlJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZENvbG9yKX19XG52YXIgY29sb3JzPXByb3AuY29sb3JzO2lmKGNvbG9ycyl7Zm9yKHZhciBpPTA7aTxjb2xvcnMubGVuZ3RoOysraSl7Y29sb3JzW2ldPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpjb2xvcnNbaV0sZGlyZWN0aW9uOidob3Jpem9udGFsJyxzdGFydDpwcm9wLmd1dHRlckxlZnQsZW5kOnRoaXMud2lkdGgtcHJvcC5ndXR0ZXJSaWdodH0pO319XG5wcm9wLmJhY2tncm91bmRHcmlkQ29sb3I9UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuYmFja2dyb3VuZEdyaWRDb2xvcixkaXJlY3Rpb246J2hvcml6b250YWwnLHN0YXJ0OnByb3AuZ3V0dGVyTGVmdCxlbmQ6dGhpcy53aWR0aC1wcm9wLmd1dHRlclJpZ2h0fSk7cHJvcC5oaWdobGlnaHRGaWxsPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmhpZ2hsaWdodEZpbGwsZGlyZWN0aW9uOidob3Jpem9udGFsJyxzdGFydDpwcm9wLmd1dHRlckxlZnQsZW5kOnRoaXMud2lkdGgtcHJvcC5ndXR0ZXJSaWdodH0pO3Byb3AuYmFja2dyb3VuZENvbG9yPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmJhY2tncm91bmRDb2xvcn0pO307dGhpcy5kcmF3TGFiZWxzQWJvdmU9ZnVuY3Rpb24oKVxue2lmKHByb3AubGFiZWxzQWJvdmUpe3ZhciBkYXRhPVJHLlNWRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpO2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMubGVuZ3RoOysraSl7dmFyIHZhbHVlPWRhdGFbaV0udG9GaXhlZCh0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZURlY2ltYWxzPT09J251bWJlcic/cHJvcC5sYWJlbHNBYm92ZURlY2ltYWxzOnByb3AueGF4aXNEZWNpbWFscyk7dmFyIGluZGV4ZXM9UkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChpLHRoaXMuZGF0YSk7aWYoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2luZGV4ZXNbMF1dKSYmcHJvcC5ncm91cGluZz09PSdzdGFja2VkJyl7aWYoKGluZGV4ZXNbMV0rMSk9PT10aGlzLmRhdGFbaW5kZXhlc1swXV0ubGVuZ3RoKXt2YWx1ZT1SRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2luZGV4ZXNbMF1dKTt2YWx1ZT12YWx1ZS50b0ZpeGVkKHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHM9PT0nbnVtYmVyJz9wcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHM6cHJvcC54YXhpc0RlY2ltYWxzKTt9ZWxzZXtjb250aW51ZTt9fVxudmFyIHN0cj1wcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWM/cHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW2ldLnRvU3RyaW5nKCk6UkcuU1ZHLm51bWJlckZvcm1hdCh7b2JqZWN0OnRoaXMsbnVtOnZhbHVlLHByZXBlbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1ByZT09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1ByZTpudWxsLGFwcGVuZDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1Bvc3Q6bnVsbCxwb2ludDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVBvaW50PT09J3N0cmluZyc/cHJvcC5sYWJlbHNBYm92ZVBvaW50Om51bGwsdGhvdXNhbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVUaG91c2FuZD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVUaG91c2FuZDpudWxsLGZvcm1hdHRlcjp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcj09PSdmdW5jdGlvbic/cHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcjpudWxsfSk7dmFyIGJvbGQ9dHlwZW9mIHByb3AubGFiZWxzQWJvdmVCb2xkPT09J2Jvb2xlYW4nP3Byb3AubGFiZWxzQWJvdmVCb2xkOnByb3AudGV4dEJvbGQsaXRhbGljPXR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlSXRhbGljPT09J2Jvb2xlYW4nP3Byb3AubGFiZWxzQWJvdmVJdGFsaWM6cHJvcC50ZXh0SXRhbGljLHNpemU9cHJvcC5sYWJlbHNBYm92ZVNpemV8fHByb3AudGV4dFNpemUsZm9udD1wcm9wLmxhYmVsc0Fib3ZlRm9udHx8cHJvcC50ZXh0Rm9udCxoYWxpZ249cHJvcC5sYWJlbHNBYm92ZUhhbGlnbix2YWxpZ249cHJvcC5sYWJlbHNBYm92ZVZhbGlnbjt2YXIgZGltZW5zaW9ucz1SRy5TVkcubWVhc3VyZVRleHQoe3RleHQ6c3RyLGJvbGQ6Ym9sZCxmb250OmZvbnQsc2l6ZTpzaXplfSk7dmFyIHg9KHZhbHVlPj0wKT8ocGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd4JykpK3BhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkrNytwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eCk6cGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd4JyktNy1wcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eCkseT1wYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSkrcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKS8yKStwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eSx3aWR0aD1kaW1lbnNpb25zWzBdLGhlaWdodD1kaW1lbnNpb25zWzFdLGhhbGlnbj0odmFsdWU+PTApPydsZWZ0JzoncmlnaHQnO2lmKHgrd2lkdGg+dGhpcy53aWR0aCYmdmFsdWU+MCl7aGFsaWduPSdyaWdodCc7eD10aGlzLndpZHRoLTU7cHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmQ9cHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmR8fCdyZ2JhKDI1NSwyNTUsMjU1LDAuOTUpJzt9XG52YXIgdGV4dD1SRy5TVkcudGV4dCh7b2JqZWN0OnRoaXMscGFyZW50OnRoaXMuc3ZnLmFsbCx0ZXh0OnN0cix4OngseTp5LGhhbGlnbjpoYWxpZ24sdmFsaWduOnZhbGlnbixmb250OmZvbnQsc2l6ZTpzaXplLGJvbGQ6Ym9sZCxpdGFsaWM6aXRhbGljLGNvbG9yOnByb3AubGFiZWxzQWJvdmVDb2xvcnx8cHJvcC50ZXh0Q29sb3IsYmFja2dyb3VuZDpwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZHx8bnVsbCxwYWRkaW5nOnByb3AubGFiZWxzQWJvdmVCYWNrZ3JvdW5kUGFkZGluZ3x8MH0pO319fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMucmVtb3ZlSGlnaGxpZ2h0PWZ1bmN0aW9uKClcbnt2YXIgaGlnaGxpZ2h0PVJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtpZihoaWdobGlnaHQmJmhpZ2hsaWdodC5wYXJlbnROb2RlKXtoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO31cblJHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLG51bGwpO307dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDMwLGZyYW1lPTAsb2JqPXRoaXMsZGF0YT1bXSxoZWlnaHQ9bnVsbCxzZXE9MDtkYXRhPVJHLlNWRy5hcnJheUNsb25lKHRoaXMuZGF0YSk7dGhpcy5kcmF3KCk7dmFyIGl0ZXJhdGU9ZnVuY3Rpb24oKVxue2Zvcih2YXIgaT0wLHNlcT0wLGxlbj1vYmouY29vcmRzLmxlbmd0aDtpPGxlbjsrK2ksKytzZXEpe3ZhciBtdWx0aXBsaWVyPShmcmFtZS9mcmFtZXMpKlJHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcyxmcmFtZSkqUkcuU1ZHLkZYLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLGZyYW1lKTtpZih0eXBlb2YgZGF0YVtpXT09PSdudW1iZXInKXt3aWR0aD1tYS5hYnMob2JqLmdldFhDb29yZChkYXRhW2ldKS1vYmouZ2V0WENvb3JkKDApKTtvYmouZGF0YVtpXT1kYXRhW2ldKm11bHRpcGxpZXI7d2lkdGg9bXVsdGlwbGllcip3aWR0aDtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLHdpZHRoKTtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgneCcsZGF0YVtpXT4wP29iai5nZXRYQ29vcmQoMCk6b2JqLmdldFhDb29yZCgwKS13aWR0aCk7fWVsc2UgaWYodHlwZW9mIGRhdGFbaV09PT0nb2JqZWN0Jyl7dmFyIGFjY3VtdWxhdGl2ZVdpZHRoPTA7Zm9yKHZhciBqPTAsbGVuMj1kYXRhW2ldLmxlbmd0aDtqPGxlbjI7KytqLCsrc2VxKXt3aWR0aD1tYS5hYnMob2JqLmdldFhDb29yZChkYXRhW2ldW2pdKS1vYmouZ2V0WENvb3JkKDApKTt3aWR0aD1tdWx0aXBsaWVyKndpZHRoO29iai5kYXRhW2ldW2pdPWRhdGFbaV1bal0qbXVsdGlwbGllcjtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLHdpZHRoKTtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgneCcsZGF0YVtpXVtqXT4wPyhvYmouZ2V0WENvb3JkKDApK2FjY3VtdWxhdGl2ZVdpZHRoKToob2JqLmdldFhDb29yZCgwKS13aWR0aC1hY2N1bXVsYXRpdmVXaWR0aCkpO2FjY3VtdWxhdGl2ZVdpZHRoKz0ocHJvcC5ncm91cGluZz09PSdzdGFja2VkJz93aWR0aDowKTt9XG5pZihvYmouc3RhY2tlZEJhY2tmYWNlc1tpXSl7b2JqLnN0YWNrZWRCYWNrZmFjZXNbaV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsYWNjdW11bGF0aXZlV2lkdGgpO29iai5zdGFja2VkQmFja2ZhY2VzW2ldLnNldEF0dHJpYnV0ZSgneCcscHJvcC5ndXR0ZXJMZWZ0KTt9XG4tLXNlcTt9fVxuaWYoZnJhbWUrKzxmcmFtZXMpe1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0ZSk7fWVsc2UgaWYob3B0LmNhbGxiYWNrKXsob3B0LmNhbGxiYWNrKShvYmopO319O2l0ZXJhdGUoKTtyZXR1cm4gdGhpczt9O3RoaXMud2F2ZT1mdW5jdGlvbigpXG57dGhpcy5kcmF3KCk7dmFyIG9iaj10aGlzLG9wdD1hcmd1bWVudHNbMF18fHt9O29wdC5mcmFtZXM9b3B0LmZyYW1lc3x8NjA7b3B0LnN0YXJ0RnJhbWVzPVtdO29wdC5jb3VudGVycz1bXTt2YXIgZnJhbWVzcGVyYmFyPW9wdC5mcmFtZXMvMyxmcmFtZT0tMSxjYWxsYmFjaz1vcHQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fSx3aWR0aDtmb3IodmFyIGk9MCxsZW49dGhpcy5jb29yZHMubGVuZ3RoO2k8bGVuO2krPTEpe29wdC5zdGFydEZyYW1lc1tpXT0oKG9wdC5mcmFtZXMvMikvKG9iai5jb29yZHMubGVuZ3RoLTEpKSppO29wdC5jb3VudGVyc1tpXT0wO3RoaXMuY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywwKTt9XG5mdW5jdGlvbiBpdGVyYXRvcigpXG57KytmcmFtZTtmb3IodmFyIGk9MCxsZW49b2JqLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSs9MSl7aWYoZnJhbWU+b3B0LnN0YXJ0RnJhbWVzW2ldKXt2YXIgb3JpZ2luYWxXaWR0aD1vYmouY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtd2lkdGgnKSx2YWx1ZT1wYXJzZUZsb2F0KG9iai5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpKTtvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyx3aWR0aD1tYS5taW4oKChmcmFtZS1vcHQuc3RhcnRGcmFtZXNbaV0pL2ZyYW1lc3BlcmJhcikqb3JpZ2luYWxXaWR0aCxvcmlnaW5hbFdpZHRoKSk7b2JqLmNvb3Jkc1tpXS5vYmplY3Quc2V0QXR0cmlidXRlKCd4Jyx2YWx1ZT49MD9vYmouZ2V0WENvb3JkKDApOm9iai5nZXRYQ29vcmQoMCktd2lkdGgpO2lmKHByb3AuZ3JvdXBpbmc9PT0nc3RhY2tlZCcpe3ZhciBzZXE9b2JqLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnKTt2YXIgaW5kZXhlcz1SRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNlcSxvYmouZGF0YSk7aWYoaW5kZXhlc1sxXT4wKXtvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3gnLHBhcnNlSW50KG9iai5jb29yZHNbaS0xXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd4JykpK3BhcnNlSW50KG9iai5jb29yZHNbaS0xXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSk7fX19fVxuaWYoZnJhbWU+PW9wdC5mcmFtZXMpe2NhbGxiYWNrKG9iaik7fWVsc2V7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtmb3IoaSBpbiBjb25mLm9wdGlvbnMpe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3RoaXMuc2V0KGksY29uZi5vcHRpb25zW2ldKTt9fX07cmV0dXJuIHRoaXM7fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuaGJhci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///242\n");

/***/ }),
/* 243 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Line = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));if (RG.SVG.isArray(conf.data) && RG.SVG.isArray(conf.data[0])) {\n      this.data = RG.SVG.arrayClone(conf.data);\n    } else if (RG.SVG.isArray(conf.data)) {\n      this.data = [RG.SVG.arrayClone(conf.data)];\n    } else {\n      this.data = [[]];\n    }\n    this.type = 'line';this.coords = [];this.coords2 = [];this.coordsSpline = [];this.hasMultipleDatasets = _typeof(this.data[0]) === 'object' && _typeof(this.data[1]) === 'object' ? true : false;this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.originalData = RG.SVG.arrayClone(this.data);RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageStretch: true, backgroundImageAspect: 'none', backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', 'blue', '#ff0', '#0ff', 'green'], filled: false, filledColors: [], filledClick: null, filledOpacity: 1, filledAccumulative: false, hmargin: 0, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsPosition: 'edge', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarksStyle: 'none', tickmarksSize: 5, tickmarksFill: 'white', tickmarksLinewidth: 1, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.7)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: -10, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, spline: false, title: '', titleSize: null, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: null, titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.coords = [];this.coords2 = [];this.coordsSpline = [];this.data = RG.SVG.arrayClone(this.originalData);this.tooltipsSequentialIndex = 0;var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && (!prop.filled || !prop.filledAccumulative)) {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.filled && prop.filledAccumulative) {\n          for (var j = 0; j < this.data[i].length; ++j) {\n            values[j] = values[j] || 0;values[j] = values[j] + this.data[i][j];this.data[i][j] = values[j];\n          }\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);for (var i = 0; i < this.data.length; ++i) {\n        this.drawLine(this.data[i], i);\n      }\n      this.redrawLines();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      this.drawLabelsAbove();RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawLine = function (data, index) {\n      var coords = [],\n          path = [];for (var i = 0, len = data.length; i < len; ++i) {\n        var val = data[i],\n            x = (this.graphWidth - prop.hmargin - prop.hmargin) / (len - 1) * i + prop.gutterLeft + prop.hmargin,\n            y = this.getYCoord(val);coords.push([x, y]);\n      }\n      for (var i = 0; i < coords.length; ++i) {\n        if (i === 0 || RG.SVG.isNull(data[i]) || RG.SVG.isNull(data[i - 1])) {\n          var action = 'M';\n        } else {\n          var action = 'L';\n        }\n        path.push(action + '{1} {2}'.format(coords[i][0], coords[i][1]));\n      }\n      this.coords[index] = RG.SVG.arrayClone(coords);this.coords2[index] = RG.SVG.arrayClone(coords);if (prop.spline) {\n        this.coordsSpline[index] = this.drawSpline(coords);\n      }\n      if (prop.filled === true || _typeof(prop.filled) === 'object' && prop.filled[index]) {\n        if (prop.spline) {\n          var fillPath = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n            fillPath.push('L{1} {2}'.format(this.coordsSpline[index][i][0] + (i === this.coordsSpline[index].length - 1 ? 1 : 0), this.coordsSpline[index][i][1]));\n          }\n        } else {\n          var fillPath = RG.SVG.arrayClone(path);\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][this.coords[index].length - 1][0] + 1, index > 0 && prop.filledAccumulative ? prop.spline ? this.coordsSpline[index - 1][this.coordsSpline[index - 1].length - 1][1] : this.coords[index - 1][this.coords[index - 1].length - 1][1] : this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));if (index > 0 && prop.filledAccumulative) {\n          var path2 = RG.SVG.arrayClone(path);if (index > 0 && prop.filledAccumulative) {\n            if (prop.spline) {\n              for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]));\n              }\n            } else {\n              for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n              }\n            }\n          }\n        } else {\n          fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.coords[index][0][1]));for (var i = 0; i < this.data[index].length; ++i) {\n          if (!RG.SVG.isNull(this.data[index][i])) {\n            fillPath.push('L{1} {2}'.format(this.coords[index][i][0], this.getYCoord(0)));break;\n          }\n        }\n        var fillPathObject = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: fillPath.join(' '), stroke: 'rgba(0,0,0,0)', 'fill': prop.filledColors && prop.filledColors[index] ? prop.filledColors[index] : prop.colors[index], 'fill-opacity': prop.filledOpacity, 'stroke-width': 1, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });if (prop.filledClick) {\n          var obj = this;fillPathObject.addEventListener('click', function (e) {\n            prop.filledClick(e, obj, index);\n          }, false);fillPathObject.addEventListener('mousemove', function (e) {\n            e.target.style.cursor = 'pointer';\n          }, false);\n        }\n      }\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      if (prop.spline) {\n        var str = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n          str.push('L{1} {2}'.format(this.coordsSpline[index][i][0], this.coordsSpline[index][i][1]));\n        }\n        str = str.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: str, stroke: prop['colors'][index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      } else {\n        var path2 = RG.SVG.arrayClone(path);if (prop.filled && prop.filledAccumulative && index > 0) {\n          for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n            path2.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n          }\n        }\n        path2 = path2.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path2, stroke: prop.colors[index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      }\n      if (prop.tooltips && prop.tooltips.length) {\n        var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { 'fill': 'transparent', className: \"rgraph_hotspots\" }, style: { cursor: 'pointer' } });for (var i = 0; i < this.coords[index].length && this.tooltipsSequentialIndex < prop.tooltips.length; ++i, ++this.tooltipsSequentialIndex) {\n          if (prop.tooltips[this.tooltipsSequentialIndex] && this.coords[index][i][0] && this.coords[index][i][1]) {\n            var hotspot = RG.SVG.create({ svg: this.svg, parent: group, type: 'circle', attr: { cx: this.coords[index][i][0], cy: this.coords[index][i][1], r: 5, 'data-dataset': index, 'data-index': i } });var obj = this;(function (sequentialIndex) {\n              hotspot.addEventListener(prop.tooltipsEvent, function (e) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(sequentialIndex, obj.data),\n                    index = indexes[1],\n                    dataset = indexes[0];if (RG.SVG.REG.get('tooltip') && RG.SVG.REG.get('tooltip').__index__ === index && RG.SVG.REG.get('tooltip').__dataset__ === dataset) {\n                  return;\n                }\n                RG.SVG.hideTooltip();if (prop.tooltips[sequentialIndex]) {\n                  var text = prop.tooltips[sequentialIndex];\n                }\n                RG.SVG.tooltip({ object: obj, index: index, dataset: dataset, sequentialIndex: sequentialIndex, text: text, event: e });var outer_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 13, fill: obj.properties.colors[dataset], 'fill-opacity': 0.5 }, style: { cursor: 'pointer' } });var outer_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 14, fill: 'white', 'fill-opacity': 0.75 }, style: { cursor: 'pointer' } });var inner_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 6, fill: 'white' }, style: { cursor: 'pointer' } });var inner_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 5, fill: obj.properties.colors[dataset] }, style: { cursor: 'pointer' } });RG.SVG.REG.set('highlight', [outer_highlight1, outer_highlight2, inner_highlight1, inner_highlight2]);\n              }, false);\n            })(this.tooltipsSequentialIndex);\n          }\n        }\n      }\n    };this.drawTickmarks = function (index, data, coords) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] === 'number') {\n          switch (prop.tickmarksStyle) {case 'filledcircle':case 'filledendcircle':\n              if (prop.tickmarksStyle === 'filledcircle' || i === 0 || i === data.length - 1) {\n                var circle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'circle':case 'endcircle':\n              if (prop.tickmarksStyle === 'circle' || prop.tickmarksStyle === 'endcircle' && (i === 0 || i === data.length - 1)) {\n                var outerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });var innerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.tickmarksFill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });break;\n              }\n              break;case 'endrect':case 'rect':\n              if (prop.tickmarksStyle === 'rect' || prop.tickmarksStyle === 'endrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && typeof prop.tickmarksFill[index] === 'string' ? prop.tickmarksFill[index] : prop.tickmarksFill;var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'stroke-width': prop.tickmarksLinewidth, 'stroke': prop.colors[index], 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'filledendrect':case 'filledrect':\n              if (prop.tickmarksStyle === 'filledrect' || prop.tickmarksStyle === 'filledendrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = prop.colors[index];var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }}\n        }\n      }\n    };this.redrawLines = function () {\n      if (prop.spline) {\n        for (var i = 0; i < this.coordsSpline.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coordsSpline[i].length; ++j) {\n            if (j === 0) {\n              path += 'M{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      } else {\n        for (var i = 0; i < this.coords.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coords[i].length; ++j) {\n            if (j === 0 || RG.SVG.isNull(this.data[i][j]) || RG.SVG.isNull(this.data[i][j - 1])) {\n              path += 'M{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropshadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties,\n          y;if (value > this.scale.max) {\n        return null;\n      }\n      if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y');\n    };this.drawSpline = function (coords) {\n      var xCoords = [];gutterLeft = prop.gutterLeft, gutterRight = prop.gutterRight, hmargin = prop.hmargin, interval = (this.graphWidth - 2 * hmargin) / (coords.length - 1), coordsSpline = [];for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n          coords[i] = Number(coords[i][1]);\n        }\n      }\n      var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n        P.push(coords[i]);\n      }\n      P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n        for (var t = 0; t < 10; ++t) {\n          var yCoord = spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);coordsSpline.push([xCoords[xCoords.length - 1], yCoord]);if (typeof index === 'number') {\n            coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n          }\n        }\n      }\n      coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);if (typeof index === 'number') {\n        coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n      }\n      function spline(t, P0, P1, P2, P3) {\n        return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n      }\n      return coordsSpline;\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), filledColors: RG.SVG.arrayClone(prop.filledColors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      var filledColors = prop.filledColors;if (filledColors) {\n        for (var i = 0; i < filledColors.length; ++i) {\n          filledColors[i] = RG.SVG.parseColorLinear({ object: this, color: filledColors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0;for (var dataset = 0; dataset < this.coords.length; ++dataset, seq++) {\n          for (var i = 0; i < this.coords[dataset].length; ++i, seq++) {\n            var str = RG.SVG.numberFormat({ object: this, num: this.data[dataset][i].toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n              str = prop.labelsAboveSpecific[seq];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n              continue;\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: parseFloat(this.coords[dataset][i][0]) + prop.labelsAboveOffsetx, y: parseFloat(this.coords[dataset][i][1]) + prop.labelsAboveOffsety, halign: prop.labelsAboveHalign, valign: prop.labelsAboveValign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n          seq--;\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 60,\n          obj = this;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });var clipPathRect = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'rect', attr: { x: 0, y: 0, width: 0, height: this.height } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;clipPathRect.setAttribute(\"width\", width);if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };\n  return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmxpbmUuanM/MzY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlNWRz1SR3JhcGguU1ZHfHx7fTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57dmFyIFJHPVJHcmFwaCx1YT1uYXZpZ2F0b3IudXNlckFnZW50LG1hPU1hdGgsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQ7UkcuU1ZHLkxpbmU9ZnVuY3Rpb24oY29uZilcbnt0aGlzLnNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtmb3IoaSBpbiBhcmd1bWVudHNbMF0pe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTppLHZhbHVlOmFyZ3VtZW50c1swXVtpXX0pO25hbWU9cmV0Lm5hbWU7dmFsdWU9cmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsdmFsdWUpO319fWVsc2V7dmFyIHJldD1SRy5TVkcuY29tbW9uU2V0dGVyKHtvYmplY3Q6dGhpcyxuYW1lOm5hbWUsdmFsdWU6dmFsdWV9KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnByb3BlcnRpZXNbbmFtZV09dmFsdWU7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmlkPWNvbmYuaWQ7dGhpcy51aWQ9UkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnPVJHLlNWRy5jcmVhdGVTVkcoe2NvbnRhaW5lcjp0aGlzLmNvbnRhaW5lcn0pO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLndpZHRoPU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0PU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtpZihSRy5TVkcuaXNBcnJheShjb25mLmRhdGEpJiZSRy5TVkcuaXNBcnJheShjb25mLmRhdGFbMF0pKXt0aGlzLmRhdGE9UkcuU1ZHLmFycmF5Q2xvbmUoY29uZi5kYXRhKTt9ZWxzZSBpZihSRy5TVkcuaXNBcnJheShjb25mLmRhdGEpKXt0aGlzLmRhdGE9W1JHLlNWRy5hcnJheUNsb25lKGNvbmYuZGF0YSldO31lbHNle3RoaXMuZGF0YT1bW11dO31cbnRoaXMudHlwZT0nbGluZSc7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO3RoaXMuY29vcmRzU3BsaW5lPVtdO3RoaXMuaGFzTXVsdGlwbGVEYXRhc2V0cz10eXBlb2YgdGhpcy5kYXRhWzBdPT09J29iamVjdCcmJnR5cGVvZiB0aGlzLmRhdGFbMV09PT0nb2JqZWN0Jz90cnVlOmZhbHNlO3RoaXMuY29sb3JzUGFyc2VkPWZhbHNlO3RoaXMub3JpZ2luYWxDb2xvcnM9e307dGhpcy5ncmFkaWVudENvdW50ZXI9MTt0aGlzLm9yaWdpbmFsRGF0YT1SRy5TVkcuYXJyYXlDbG9uZSh0aGlzLmRhdGEpO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheT0naW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXM9e2d1dHRlckxlZnQ6MzUsZ3V0dGVyUmlnaHQ6MzUsZ3V0dGVyVG9wOjM1LGd1dHRlckJvdHRvbTozNSxiYWNrZ3JvdW5kQ29sb3I6bnVsbCxiYWNrZ3JvdW5kSW1hZ2U6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoOnRydWUsYmFja2dyb3VuZEltYWdlQXNwZWN0Oidub25lJyxiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5Om51bGwsYmFja2dyb3VuZEltYWdlWDpudWxsLGJhY2tncm91bmRJbWFnZVk6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VXOm51bGwsYmFja2dyb3VuZEltYWdlSDpudWxsLGJhY2tncm91bmRHcmlkOnRydWUsYmFja2dyb3VuZEdyaWRDb2xvcjonI2RkZCcsYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6MSxiYWNrZ3JvdW5kR3JpZEhsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZFZsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZEJvcmRlcjp0cnVlLGNvbG9yczpbJ3JlZCcsJyMwZjAnLCdibHVlJywnI2ZmMCcsJyMwZmYnLCdncmVlbiddLGZpbGxlZDpmYWxzZSxmaWxsZWRDb2xvcnM6W10sZmlsbGVkQ2xpY2s6bnVsbCxmaWxsZWRPcGFjaXR5OjEsZmlsbGVkQWNjdW11bGF0aXZlOmZhbHNlLGhtYXJnaW46MCx5YXhpczp0cnVlLHlheGlzVGlja21hcmtzOnRydWUseWF4aXNUaWNrbWFya3NMZW5ndGg6Myx5YXhpc0NvbG9yOidibGFjaycseWF4aXNTY2FsZTp0cnVlLHlheGlzTGFiZWxzOm51bGwseWF4aXNMYWJlbHNPZmZzZXR4OjAseWF4aXNMYWJlbHNPZmZzZXR5OjAseWF4aXNMYWJlbHNDb3VudDo1LHlheGlzVW5pdHNQcmU6JycseWF4aXNVbml0c1Bvc3Q6JycseWF4aXNTdHJpY3Q6ZmFsc2UseWF4aXNEZWNpbWFsczowLHlheGlzUG9pbnQ6Jy4nLHlheGlzVGhvdXNhbmQ6JywnLHlheGlzUm91bmQ6ZmFsc2UseWF4aXNNYXg6bnVsbCx5YXhpc01pbjowLHlheGlzRm9ybWF0dGVyOm51bGwseGF4aXM6dHJ1ZSx4YXhpc1RpY2ttYXJrczp0cnVlLHhheGlzVGlja21hcmtzTGVuZ3RoOjUseGF4aXNMYWJlbHM6bnVsbCx4YXhpc0xhYmVsc09mZnNldHg6MCx4YXhpc0xhYmVsc09mZnNldHk6MCx4YXhpc0xhYmVsc1Bvc2l0aW9uOidlZGdlJyx4YXhpc0xhYmVsc1Bvc2l0aW9uRWRnZVRpY2ttYXJrc0NvdW50Om51bGwseGF4aXNDb2xvcjonYmxhY2snLHRleHRDb2xvcjonYmxhY2snLHRleHRGb250OidzYW5zLXNlcmlmJyx0ZXh0U2l6ZToxMix0ZXh0Qm9sZDpmYWxzZSx0ZXh0SXRhbGljOmZhbHNlLGxpbmV3aWR0aDoxLHRvb2x0aXBzOm51bGwsdG9vbHRpcHNPdmVycmlkZTpudWxsLHRvb2x0aXBzRWZmZWN0OidmYWRlJyx0b29sdGlwc0Nzc0NsYXNzOidSR3JhcGhfdG9vbHRpcCcsdG9vbHRpcHNFdmVudDonbW91c2Vtb3ZlJyxoaWdobGlnaHRTdHJva2U6J3JnYmEoMCwwLDAsMCknLGhpZ2hsaWdodEZpbGw6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsaGlnaGxpZ2h0TGluZXdpZHRoOjEsdGlja21hcmtzU3R5bGU6J25vbmUnLHRpY2ttYXJrc1NpemU6NSx0aWNrbWFya3NGaWxsOid3aGl0ZScsdGlja21hcmtzTGluZXdpZHRoOjEsbGFiZWxzQWJvdmU6ZmFsc2UsbGFiZWxzQWJvdmVGb250Om51bGwsbGFiZWxzQWJvdmVTaXplOm51bGwsbGFiZWxzQWJvdmVCb2xkOm51bGwsbGFiZWxzQWJvdmVJdGFsaWM6bnVsbCxsYWJlbHNBYm92ZUNvbG9yOm51bGwsbGFiZWxzQWJvdmVCYWNrZ3JvdW5kOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLGxhYmVsc0Fib3ZlQmFja2dyb3VuZFBhZGRpbmc6MixsYWJlbHNBYm92ZVVuaXRzUHJlOm51bGwsbGFiZWxzQWJvdmVVbml0c1Bvc3Q6bnVsbCxsYWJlbHNBYm92ZVBvaW50Om51bGwsbGFiZWxzQWJvdmVUaG91c2FuZDpudWxsLGxhYmVsc0Fib3ZlRm9ybWF0dGVyOm51bGwsbGFiZWxzQWJvdmVEZWNpbWFsczpudWxsLGxhYmVsc0Fib3ZlT2Zmc2V0eDowLGxhYmVsc0Fib3ZlT2Zmc2V0eTotMTAsbGFiZWxzQWJvdmVIYWxpZ246J2NlbnRlcicsbGFiZWxzQWJvdmVWYWxpZ246J2JvdHRvbScsbGFiZWxzQWJvdmVTcGVjaWZpYzpudWxsLHNoYWRvdzpmYWxzZSxzaGFkb3dPZmZzZXR4OjIsc2hhZG93T2Zmc2V0eToyLHNoYWRvd0JsdXI6MixzaGFkb3dPcGFjaXR5OjAuMjUsc3BsaW5lOmZhbHNlLHRpdGxlOicnLHRpdGxlU2l6ZTpudWxsLHRpdGxlWDpudWxsLHRpdGxlWTpudWxsLHRpdGxlSGFsaWduOidjZW50ZXInLHRpdGxlVmFsaWduOm51bGwsdGl0bGVDb2xvcjpudWxsLHRpdGxlRm9udDpudWxsLHRpdGxlQm9sZDpmYWxzZSx0aXRsZUl0YWxpYzpmYWxzZSx0aXRsZVN1YnRpdGxlOicnLHRpdGxlU3VidGl0bGVTaXplOjEwLHRpdGxlU3VidGl0bGVYOm51bGwsdGl0bGVTdWJ0aXRsZVk6bnVsbCx0aXRsZVN1YnRpdGxlSGFsaWduOidjZW50ZXInLHRpdGxlU3VidGl0bGVWYWxpZ246bnVsbCx0aXRsZVN1YnRpdGxlQ29sb3I6JyNhYWEnLHRpdGxlU3VidGl0bGVGb250Om51bGwsdGl0bGVTdWJ0aXRsZUJvbGQ6ZmFsc2UsdGl0bGVTdWJ0aXRsZUl0YWxpYzpmYWxzZSxrZXk6bnVsbCxrZXlDb2xvcnM6bnVsbCxrZXlPZmZzZXR4OjAsa2V5T2Zmc2V0eTowLGtleVRleHRPZmZzZXR4OjAsa2V5VGV4dE9mZnNldHk6LTEsa2V5VGV4dFNpemU6bnVsbCxrZXlUZXh0Qm9sZDpudWxsLGtleVRleHRJdGFsaWM6bnVsbCxhdHRyaWJ1dGlvbjp0cnVlLGF0dHJpYnV0aW9uWDpudWxsLGF0dHJpYnV0aW9uWTpudWxsLGF0dHJpYnV0aW9uSHJlZjpudWxsLGF0dHJpYnV0aW9uSGFsaWduOidyaWdodCcsYXR0cmlidXRpb25WYWxpZ246J2JvdHRvbScsYXR0cmlidXRpb25TaXplOjcsYXR0cmlidXRpb25Db2xvcjonZ3JheScsYXR0cmlidXRpb25Gb250OidzYW5zLXNlcmlmJyxhdHRyaWJ1dGlvbkl0YWxpYzpmYWxzZSxhdHRyaWJ1dGlvbkJvbGQ6ZmFsc2V9O2lmKFJHLlNWRy5GWCYmdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTt9XG52YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7dGhpcy5kcmF3PWZ1bmN0aW9uKClcbntSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO1JHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO3RoaXMuZ3JhcGhXaWR0aD10aGlzLndpZHRoLXByb3AuZ3V0dGVyTGVmdC1wcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQ9dGhpcy5oZWlnaHQtcHJvcC5ndXR0ZXJUb3AtcHJvcC5ndXR0ZXJCb3R0b207UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7b2JqZWN0OnRoaXN9KTt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO3RoaXMuY29vcmRzU3BsaW5lPVtdO3RoaXMuZGF0YT1SRy5TVkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsRGF0YSk7dGhpcy50b29sdGlwc1NlcXVlbnRpYWxJbmRleD0wO3ZhciB2YWx1ZXM9W107Zm9yKHZhciBpPTAsbWF4PTA7aTx0aGlzLmRhdGEubGVuZ3RoOysraSl7aWYodHlwZW9mIHRoaXMuZGF0YVtpXT09PSdudW1iZXInKXt2YWx1ZXMucHVzaCh0aGlzLmRhdGFbaV0pO31lbHNlIGlmKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkmJighcHJvcC5maWxsZWR8fCFwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSkpe3ZhbHVlcy5wdXNoKFJHLlNWRy5hcnJheU1heCh0aGlzLmRhdGFbaV0pKTt9ZWxzZSBpZihSRy5TVkcuaXNBcnJheSh0aGlzLmRhdGFbaV0pJiZwcm9wLmZpbGxlZCYmcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpe2Zvcih2YXIgaj0wO2o8dGhpcy5kYXRhW2ldLmxlbmd0aDsrK2ope3ZhbHVlc1tqXT12YWx1ZXNbal18fDA7dmFsdWVzW2pdPXZhbHVlc1tqXSt0aGlzLmRhdGFbaV1bal07dGhpcy5kYXRhW2ldW2pdPXZhbHVlc1tqXTt9fX1cbnZhciBtYXg9UkcuU1ZHLmFycmF5TWF4KHZhbHVlcyk7aWYodHlwZW9mIHByb3AueWF4aXNNYXg9PT0nbnVtYmVyJyl7bWF4PXByb3AueWF4aXNNYXg7fVxuaWYocHJvcC55YXhpc01pbj09PSdtaXJyb3InKXt2YXIgbWlycm9yU2NhbGU9dHJ1ZTtwcm9wLnlheGlzTWluPTA7fVxudGhpcy5zY2FsZT1SRy5TVkcuZ2V0U2NhbGUoe29iamVjdDp0aGlzLG51bWxhYmVsczpwcm9wLnlheGlzTGFiZWxzQ291bnQsdW5pdHNQcmU6cHJvcC55YXhpc1VuaXRzUHJlLHVuaXRzUG9zdDpwcm9wLnlheGlzVW5pdHNQb3N0LG1heDptYXgsbWluOnByb3AueWF4aXNNaW4scG9pbnQ6cHJvcC55YXhpc1BvaW50LHJvdW5kOnByb3AueWF4aXNSb3VuZCx0aG91c2FuZDpwcm9wLnlheGlzVGhvdXNhbmQsZGVjaW1hbHM6cHJvcC55YXhpc0RlY2ltYWxzLHN0cmljdDp0eXBlb2YgcHJvcC55YXhpc01heD09PSdudW1iZXInLGZvcm1hdHRlcjpwcm9wLnlheGlzRm9ybWF0dGVyfSk7aWYobWlycm9yU2NhbGUpe3RoaXMuc2NhbGU9UkcuU1ZHLmdldFNjYWxlKHtvYmplY3Q6dGhpcyxudW1sYWJlbHM6cHJvcC55YXhpc0xhYmVsc0NvdW50LHVuaXRzUHJlOnByb3AueWF4aXNVbml0c1ByZSx1bml0c1Bvc3Q6cHJvcC55YXhpc1VuaXRzUG9zdCxtYXg6dGhpcy5zY2FsZS5tYXgsbWluOnRoaXMuc2NhbGUubWF4KiAtMSxwb2ludDpwcm9wLnlheGlzUG9pbnQscm91bmQ6ZmFsc2UsdGhvdXNhbmQ6cHJvcC55YXhpc1Rob3VzYW5kLGRlY2ltYWxzOnByb3AueWF4aXNEZWNpbWFscyxzdHJpY3Q6dHlwZW9mIHByb3AueWF4aXNNYXg9PT0nbnVtYmVyJyxmb3JtYXR0ZXI6cHJvcC55YXhpc0Zvcm1hdHRlcn0pO31cbnRoaXMubWF4PXRoaXMuc2NhbGUubWF4O3RoaXMubWluPXRoaXMuc2NhbGUubWluO3Byb3AueWF4aXNNYXg9dGhpcy5zY2FsZS5tYXg7cHJvcC55YXhpc01pbj10aGlzLnNjYWxlLm1pbjtSRy5TVkcuZHJhd0JhY2tncm91bmQodGhpcyk7UkcuU1ZHLmRyYXdYQXhpcyh0aGlzKTtSRy5TVkcuZHJhd1lBeGlzKHRoaXMpO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe3RoaXMuZHJhd0xpbmUodGhpcy5kYXRhW2ldLGkpO31cbnRoaXMucmVkcmF3TGluZXMoKTtpZih0eXBlb2YgcHJvcC5rZXkhPT1udWxsJiZSRy5TVkcuZHJhd0tleSl7UkcuU1ZHLmRyYXdLZXkodGhpcyk7fWVsc2UgaWYoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSl7YWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7fVxudGhpcy5kcmF3TGFiZWxzQWJvdmUoKTtSRy5TVkcuYXR0cmlidXRpb24odGhpcyk7dmFyIG9iaj10aGlzO2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxmdW5jdGlvbihlKVxue1JHLlNWRy5yZW1vdmVIaWdobGlnaHQob2JqKTt9LGZhbHNlKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3TGluZT1mdW5jdGlvbihkYXRhLGluZGV4KVxue3ZhciBjb29yZHM9W10scGF0aD1bXTtmb3IodmFyIGk9MCxsZW49ZGF0YS5sZW5ndGg7aTxsZW47KytpKXt2YXIgdmFsPWRhdGFbaV0seD0oKCh0aGlzLmdyYXBoV2lkdGgtcHJvcC5obWFyZ2luLXByb3AuaG1hcmdpbikvKGxlbi0xKSkqaSkrcHJvcC5ndXR0ZXJMZWZ0K3Byb3AuaG1hcmdpbix5PXRoaXMuZ2V0WUNvb3JkKHZhbCk7Y29vcmRzLnB1c2goW3gseV0pO31cbmZvcih2YXIgaT0wO2k8Y29vcmRzLmxlbmd0aDsrK2kpe2lmKGk9PT0wfHxSRy5TVkcuaXNOdWxsKGRhdGFbaV0pfHxSRy5TVkcuaXNOdWxsKGRhdGFbaS0xXSkpe3ZhciBhY3Rpb249J00nO31lbHNle3ZhciBhY3Rpb249J0wnO31cbnBhdGgucHVzaChhY3Rpb24rJ3sxfSB7Mn0nLmZvcm1hdChjb29yZHNbaV1bMF0sY29vcmRzW2ldWzFdKSk7fVxudGhpcy5jb29yZHNbaW5kZXhdPVJHLlNWRy5hcnJheUNsb25lKGNvb3Jkcyk7dGhpcy5jb29yZHMyW2luZGV4XT1SRy5TVkcuYXJyYXlDbG9uZShjb29yZHMpO2lmKHByb3Auc3BsaW5lKXt0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF09dGhpcy5kcmF3U3BsaW5lKGNvb3Jkcyk7fVxuaWYocHJvcC5maWxsZWQ9PT10cnVlfHwodHlwZW9mIHByb3AuZmlsbGVkPT09J29iamVjdCcmJnByb3AuZmlsbGVkW2luZGV4XSkpe2lmKHByb3Auc3BsaW5lKXt2YXIgZmlsbFBhdGg9WydNezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XVswXVswXSx0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1bMF1bMV0pXTtmb3IodmFyIGk9MTtpPHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XS5sZW5ndGg7KytpKXtmaWxsUGF0aC5wdXNoKCdMezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XVtpXVswXSsoKGk9PT0odGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLmxlbmd0aCktMSk/MTowKSx0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1baV1bMV0pKTt9fWVsc2V7dmFyIGZpbGxQYXRoPVJHLlNWRy5hcnJheUNsb25lKHBhdGgpO31cbmZpbGxQYXRoLnB1c2goJ0x7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNbaW5kZXhdW3RoaXMuY29vcmRzW2luZGV4XS5sZW5ndGgtMV1bMF0rMSxpbmRleD4wJiZwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZT8ocHJvcC5zcGxpbmU/dGhpcy5jb29yZHNTcGxpbmVbaW5kZXgtMV1bdGhpcy5jb29yZHNTcGxpbmVbaW5kZXgtMV0ubGVuZ3RoLTFdWzFdOnRoaXMuY29vcmRzW2luZGV4LTFdW3RoaXMuY29vcmRzW2luZGV4LTFdLmxlbmd0aC0xXVsxXSk6dGhpcy5nZXRZQ29vcmQocHJvcC55YXhpc01pbj4wP3Byb3AueWF4aXNNaW46MCkrKHByb3AueGF4aXM/MDoxKSkpO2lmKGluZGV4PjAmJnByb3AuZmlsbGVkQWNjdW11bGF0aXZlKXt2YXIgcGF0aDI9UkcuU1ZHLmFycmF5Q2xvbmUocGF0aCk7aWYoaW5kZXg+MCYmcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpe2lmKHByb3Auc3BsaW5lKXtmb3IodmFyIGk9dGhpcy5jb29yZHNTcGxpbmVbaW5kZXgtMV0ubGVuZ3RoLTE7aT49MDstLWkpe2ZpbGxQYXRoLnB1c2goJ0x7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNTcGxpbmVbaW5kZXgtMV1baV1bMF0sdGhpcy5jb29yZHNTcGxpbmVbaW5kZXgtMV1baV1bMV0pKTt9fWVsc2V7Zm9yKHZhciBpPXRoaXMuY29vcmRzW2luZGV4LTFdLmxlbmd0aC0xO2k+PTA7LS1pKXtmaWxsUGF0aC5wdXNoKCdMezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzW2luZGV4LTFdW2ldWzBdLHRoaXMuY29vcmRzW2luZGV4LTFdW2ldWzFdKSk7fX19fWVsc2V7ZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleF1bMF1bMF0rKHByb3AueWF4aXM/MTowKSx0aGlzLmdldFlDb29yZChwcm9wLnlheGlzTWluPjA/cHJvcC55YXhpc01pbjowKSsocHJvcC54YXhpcz8wOjEpKSk7fVxuZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleF1bMF1bMF0rKHByb3AueWF4aXM/MTowKSx0aGlzLmNvb3Jkc1tpbmRleF1bMF1bMV0pKTtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YVtpbmRleF0ubGVuZ3RoOysraSl7aWYoIVJHLlNWRy5pc051bGwodGhpcy5kYXRhW2luZGV4XVtpXSkpe2ZpbGxQYXRoLnB1c2goJ0x7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNbaW5kZXhdW2ldWzBdLHRoaXMuZ2V0WUNvb3JkKDApKSk7YnJlYWs7fX1cbnZhciBmaWxsUGF0aE9iamVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOmZpbGxQYXRoLmpvaW4oJyAnKSxzdHJva2U6J3JnYmEoMCwwLDAsMCknLCdmaWxsJzpwcm9wLmZpbGxlZENvbG9ycyYmcHJvcC5maWxsZWRDb2xvcnNbaW5kZXhdP3Byb3AuZmlsbGVkQ29sb3JzW2luZGV4XTpwcm9wLmNvbG9yc1tpbmRleF0sJ2ZpbGwtb3BhY2l0eSc6cHJvcC5maWxsZWRPcGFjaXR5LCdzdHJva2Utd2lkdGgnOjEsJ2NsaXAtcGF0aCc6dGhpcy5pc1RyYWNlPyd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKSc6Jyd9fSk7aWYocHJvcC5maWxsZWRDbGljayl7dmFyIG9iaj10aGlzO2ZpbGxQYXRoT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbihlKVxue3Byb3AuZmlsbGVkQ2xpY2soZSxvYmosaW5kZXgpO30sZmFsc2UpO2ZpbGxQYXRoT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZnVuY3Rpb24oZSlcbntlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO319XG5pZihwcm9wLnNoYWRvdyl7UkcuU1ZHLnNldFNoYWRvdyh7b2JqZWN0OnRoaXMsb2Zmc2V0eDpwcm9wLnNoYWRvd09mZnNldHgsb2Zmc2V0eTpwcm9wLnNoYWRvd09mZnNldHksYmx1cjpwcm9wLnNoYWRvd0JsdXIsb3BhY2l0eTpwcm9wLnNoYWRvd09wYWNpdHksaWQ6J2Ryb3BTaGFkb3cnfSk7fVxuaWYocHJvcC5zcGxpbmUpe3ZhciBzdHI9WydNezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XVswXVswXSx0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1bMF1bMV0pXTtmb3IodmFyIGk9MTtpPHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XS5sZW5ndGg7KytpKXtzdHIucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1baV1bMF0sdGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdW2ldWzFdKSk7fVxuc3RyPXN0ci5qb2luKCcgJyk7dmFyIGxpbmU9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDpzdHIsc3Ryb2tlOnByb3BbJ2NvbG9ycyddW2luZGV4XSwnZmlsbCc6J25vbmUnLCdzdHJva2Utd2lkdGgnOnRoaXMuaGFzTXVsdGlwbGVEYXRhc2V0cyYmcHJvcC5maWxsZWQmJnByb3AuZmlsbGVkQWNjdW11bGF0aXZlPzAuMTooUkcuU1ZHLmlzQXJyYXkocHJvcC5saW5ld2lkdGgpP3Byb3AubGluZXdpZHRoW2luZGV4XTpwcm9wLmxpbmV3aWR0aCswLjAxKSwnc3Ryb2tlLWxpbmVjYXAnOidyb3VuZCcsJ3N0cm9rZS1saW5lam9pbic6J3JvdW5kJyxmaWx0ZXI6cHJvcC5zaGFkb3c/J3VybCgjZHJvcFNoYWRvdyknOicnLCdjbGlwLXBhdGgnOnRoaXMuaXNUcmFjZT8ndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknOicnfX0pO31lbHNle3ZhciBwYXRoMj1SRy5TVkcuYXJyYXlDbG9uZShwYXRoKTtpZihwcm9wLmZpbGxlZCYmcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUmJmluZGV4PjApe2Zvcih2YXIgaT10aGlzLmNvb3Jkc1tpbmRleC0xXS5sZW5ndGgtMTtpPj0wOy0taSl7cGF0aDIucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleC0xXVtpXVswXSx0aGlzLmNvb3Jkc1tpbmRleC0xXVtpXVsxXSkpO319XG5wYXRoMj1wYXRoMi5qb2luKCcgJyk7dmFyIGxpbmU9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDpwYXRoMixzdHJva2U6cHJvcC5jb2xvcnNbaW5kZXhdLCdmaWxsJzonbm9uZScsJ3N0cm9rZS13aWR0aCc6dGhpcy5oYXNNdWx0aXBsZURhdGFzZXRzJiZwcm9wLmZpbGxlZCYmcHJvcC5maWxsZWRBY2N1bXVsYXRpdmU/MC4xOihSRy5TVkcuaXNBcnJheShwcm9wLmxpbmV3aWR0aCk/cHJvcC5saW5ld2lkdGhbaW5kZXhdOnByb3AubGluZXdpZHRoKzAuMDEpLCdzdHJva2UtbGluZWNhcCc6J3JvdW5kJywnc3Ryb2tlLWxpbmVqb2luJzoncm91bmQnLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6JycsJ2NsaXAtcGF0aCc6dGhpcy5pc1RyYWNlPyd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKSc6Jyd9fSk7fVxuaWYocHJvcC50b29sdGlwcyYmcHJvcC50b29sdGlwcy5sZW5ndGgpe3ZhciBncm91cD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidnJyxhdHRyOnsnZmlsbCc6J3RyYW5zcGFyZW50JyxjbGFzc05hbWU6XCJyZ3JhcGhfaG90c3BvdHNcIn0sc3R5bGU6e2N1cnNvcjoncG9pbnRlcid9fSk7Zm9yKHZhciBpPTA7aTx0aGlzLmNvb3Jkc1tpbmRleF0ubGVuZ3RoJiZ0aGlzLnRvb2x0aXBzU2VxdWVudGlhbEluZGV4PHByb3AudG9vbHRpcHMubGVuZ3RoOysraSwrK3RoaXMudG9vbHRpcHNTZXF1ZW50aWFsSW5kZXgpe2lmKHByb3AudG9vbHRpcHNbdGhpcy50b29sdGlwc1NlcXVlbnRpYWxJbmRleF0mJnRoaXMuY29vcmRzW2luZGV4XVtpXVswXSYmdGhpcy5jb29yZHNbaW5kZXhdW2ldWzFdKXt2YXIgaG90c3BvdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50Omdyb3VwLHR5cGU6J2NpcmNsZScsYXR0cjp7Y3g6dGhpcy5jb29yZHNbaW5kZXhdW2ldWzBdLGN5OnRoaXMuY29vcmRzW2luZGV4XVtpXVsxXSxyOjUsJ2RhdGEtZGF0YXNldCc6aW5kZXgsJ2RhdGEtaW5kZXgnOml9fSk7dmFyIG9iaj10aGlzOyhmdW5jdGlvbihzZXF1ZW50aWFsSW5kZXgpXG57aG90c3BvdC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCxmdW5jdGlvbihlKVxue3ZhciBpbmRleGVzPVJHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQoc2VxdWVudGlhbEluZGV4LG9iai5kYXRhKSxpbmRleD1pbmRleGVzWzFdLGRhdGFzZXQ9aW5kZXhlc1swXTtpZihSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpJiZSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpLl9faW5kZXhfXz09PWluZGV4JiZSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpLl9fZGF0YXNldF9fPT09ZGF0YXNldCl7cmV0dXJuO31cblJHLlNWRy5oaWRlVG9vbHRpcCgpO2lmKHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSl7dmFyIHRleHQ9cHJvcC50b29sdGlwc1tzZXF1ZW50aWFsSW5kZXhdO31cblJHLlNWRy50b29sdGlwKHtvYmplY3Q6b2JqLGluZGV4OmluZGV4LGRhdGFzZXQ6ZGF0YXNldCxzZXF1ZW50aWFsSW5kZXg6c2VxdWVudGlhbEluZGV4LHRleHQ6dGV4dCxldmVudDplfSk7dmFyIG91dGVyX2hpZ2hsaWdodDE9UkcuU1ZHLmNyZWF0ZSh7c3ZnOm9iai5zdmcscGFyZW50Om9iai5zdmcuYWxsLHR5cGU6J2NpcmNsZScsYXR0cjp7Y3g6b2JqLmNvb3Jkc1tkYXRhc2V0XVtpbmRleF1bMF0sY3k6b2JqLmNvb3Jkc1tkYXRhc2V0XVtpbmRleF1bMV0scjoxMyxmaWxsOm9iai5wcm9wZXJ0aWVzLmNvbG9yc1tkYXRhc2V0XSwnZmlsbC1vcGFjaXR5JzowLjV9LHN0eWxlOntjdXJzb3I6J3BvaW50ZXInfX0pO3ZhciBvdXRlcl9oaWdobGlnaHQyPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidjaXJjbGUnLGF0dHI6e2N4Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzBdLGN5Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzFdLHI6MTQsZmlsbDond2hpdGUnLCdmaWxsLW9wYWNpdHknOjAuNzV9LHN0eWxlOntjdXJzb3I6J3BvaW50ZXInfX0pO3ZhciBpbm5lcl9oaWdobGlnaHQxPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidjaXJjbGUnLGF0dHI6e2N4Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzBdLGN5Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzFdLHI6NixmaWxsOid3aGl0ZSd9LHN0eWxlOntjdXJzb3I6J3BvaW50ZXInfX0pO3ZhciBpbm5lcl9oaWdobGlnaHQyPVJHLlNWRy5jcmVhdGUoe3N2ZzpvYmouc3ZnLHBhcmVudDpvYmouc3ZnLmFsbCx0eXBlOidjaXJjbGUnLGF0dHI6e2N4Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzBdLGN5Om9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzFdLHI6NSxmaWxsOm9iai5wcm9wZXJ0aWVzLmNvbG9yc1tkYXRhc2V0XX0sc3R5bGU6e2N1cnNvcjoncG9pbnRlcid9fSk7UkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsW291dGVyX2hpZ2hsaWdodDEsb3V0ZXJfaGlnaGxpZ2h0Mixpbm5lcl9oaWdobGlnaHQxLGlubmVyX2hpZ2hsaWdodDJdKTt9LGZhbHNlKTt9KSh0aGlzLnRvb2x0aXBzU2VxdWVudGlhbEluZGV4KTt9fX19O3RoaXMuZHJhd1RpY2ttYXJrcz1mdW5jdGlvbihpbmRleCxkYXRhLGNvb3Jkcylcbntmb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoOysraSl7aWYodHlwZW9mIGRhdGFbaV09PT0nbnVtYmVyJyl7c3dpdGNoKHByb3AudGlja21hcmtzU3R5bGUpe2Nhc2UnZmlsbGVkY2lyY2xlJzpjYXNlJ2ZpbGxlZGVuZGNpcmNsZSc6aWYocHJvcC50aWNrbWFya3NTdHlsZT09PSdmaWxsZWRjaXJjbGUnfHwoaT09PTB8fGk9PT1kYXRhLmxlbmd0aC0xKSl7dmFyIGNpcmNsZT1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidjaXJjbGUnLGF0dHI6e2N4OmNvb3Jkc1tpbmRleF1baV1bMF0sY3k6Y29vcmRzW2luZGV4XVtpXVsxXSxyOnByb3AudGlja21hcmtzU2l6ZSwnZmlsbCc6cHJvcC5jb2xvcnNbaW5kZXhdLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6JycsJ2NsaXAtcGF0aCc6dGhpcy5pc1RyYWNlPyd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKSc6Jyd9fSk7fVxuYnJlYWs7Y2FzZSdjaXJjbGUnOmNhc2UnZW5kY2lyY2xlJzppZihwcm9wLnRpY2ttYXJrc1N0eWxlPT09J2NpcmNsZSd8fChwcm9wLnRpY2ttYXJrc1N0eWxlPT09J2VuZGNpcmNsZScmJihpPT09MHx8aT09PWRhdGEubGVuZ3RoLTEpKSl7dmFyIG91dGVyQ2lyY2xlPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J2NpcmNsZScsYXR0cjp7Y3g6Y29vcmRzW2luZGV4XVtpXVswXSxjeTpjb29yZHNbaW5kZXhdW2ldWzFdLHI6cHJvcC50aWNrbWFya3NTaXplK3Byb3AudGlja21hcmtzTGluZXdpZHRoLCdmaWxsJzpwcm9wLmNvbG9yc1tpbmRleF0sZmlsdGVyOnByb3Auc2hhZG93Pyd1cmwoI2Ryb3BTaGFkb3cpJzonJywnY2xpcC1wYXRoJzp0aGlzLmlzVHJhY2U/J3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJzonJ319KTt2YXIgaW5uZXJDaXJjbGU9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZTonY2lyY2xlJyxhdHRyOntjeDpjb29yZHNbaW5kZXhdW2ldWzBdLGN5OmNvb3Jkc1tpbmRleF1baV1bMV0scjpwcm9wLnRpY2ttYXJrc1NpemUsJ2ZpbGwnOnByb3AudGlja21hcmtzRmlsbCwnY2xpcC1wYXRoJzp0aGlzLmlzVHJhY2U/J3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJzonJ319KTticmVhazt9XG5icmVhaztjYXNlJ2VuZHJlY3QnOmNhc2UncmVjdCc6aWYocHJvcC50aWNrbWFya3NTdHlsZT09PSdyZWN0J3x8KHByb3AudGlja21hcmtzU3R5bGU9PT0nZW5kcmVjdCcmJihpPT09MHx8aT09PWRhdGEubGVuZ3RoLTEpKSl7dmFyIGhhbGY9KHByb3AudGlja21hcmtzU2l6ZStwcm9wLnRpY2ttYXJrc0xpbmV3aWR0aCkvMjt2YXIgZmlsbD10eXBlb2YgcHJvcC50aWNrbWFya3NGaWxsPT09J29iamVjdCcmJnR5cGVvZiBwcm9wLnRpY2ttYXJrc0ZpbGxbaW5kZXhdPT09J3N0cmluZyc/cHJvcC50aWNrbWFya3NGaWxsW2luZGV4XTpwcm9wLnRpY2ttYXJrc0ZpbGw7dmFyIHJlY3Q9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncmVjdCcsYXR0cjp7eDpjb29yZHNbaW5kZXhdW2ldWzBdLWhhbGYseTpjb29yZHNbaW5kZXhdW2ldWzFdLWhhbGYsd2lkdGg6cHJvcC50aWNrbWFya3NTaXplK3Byb3AudGlja21hcmtzTGluZXdpZHRoLGhlaWdodDpwcm9wLnRpY2ttYXJrc1NpemUrcHJvcC50aWNrbWFya3NMaW5ld2lkdGgsJ3N0cm9rZS13aWR0aCc6cHJvcC50aWNrbWFya3NMaW5ld2lkdGgsJ3N0cm9rZSc6cHJvcC5jb2xvcnNbaW5kZXhdLCdmaWxsJzpmaWxsLCdjbGlwLXBhdGgnOnRoaXMuaXNUcmFjZT8ndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknOicnfX0pO31cbmJyZWFrO2Nhc2UnZmlsbGVkZW5kcmVjdCc6Y2FzZSdmaWxsZWRyZWN0JzppZihwcm9wLnRpY2ttYXJrc1N0eWxlPT09J2ZpbGxlZHJlY3QnfHwocHJvcC50aWNrbWFya3NTdHlsZT09PSdmaWxsZWRlbmRyZWN0JyYmKGk9PT0wfHxpPT09ZGF0YS5sZW5ndGgtMSkpKXt2YXIgaGFsZj0ocHJvcC50aWNrbWFya3NTaXplK3Byb3AudGlja21hcmtzTGluZXdpZHRoKS8yO3ZhciBmaWxsPXByb3AuY29sb3JzW2luZGV4XTt2YXIgcmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidyZWN0JyxhdHRyOnt4OmNvb3Jkc1tpbmRleF1baV1bMF0taGFsZix5OmNvb3Jkc1tpbmRleF1baV1bMV0taGFsZix3aWR0aDpwcm9wLnRpY2ttYXJrc1NpemUrcHJvcC50aWNrbWFya3NMaW5ld2lkdGgsaGVpZ2h0OnByb3AudGlja21hcmtzU2l6ZStwcm9wLnRpY2ttYXJrc0xpbmV3aWR0aCwnZmlsbCc6ZmlsbCwnY2xpcC1wYXRoJzp0aGlzLmlzVHJhY2U/J3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJzonJ319KTt9fX19fTt0aGlzLnJlZHJhd0xpbmVzPWZ1bmN0aW9uKClcbntpZihwcm9wLnNwbGluZSl7Zm9yKHZhciBpPTA7aTx0aGlzLmNvb3Jkc1NwbGluZS5sZW5ndGg7KytpKXt2YXIgbGluZXdpZHRoPVJHLlNWRy5pc0FycmF5KHByb3AubGluZXdpZHRoKT9wcm9wLmxpbmV3aWR0aFtpXTpwcm9wLmxpbmV3aWR0aCxjb2xvcj1wcm9wWydjb2xvcnMnXVtpXSxwYXRoPScnO2Zvcih2YXIgaj0wO2o8dGhpcy5jb29yZHNTcGxpbmVbaV0ubGVuZ3RoOysrail7aWYoaj09PTApe3BhdGgrPSdNezF9IHsyfSAnLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpXVtqXVswXSx0aGlzLmNvb3Jkc1NwbGluZVtpXVtqXVsxXSk7fWVsc2V7cGF0aCs9J0x7MX0gezJ9ICcuZm9ybWF0KHRoaXMuY29vcmRzU3BsaW5lW2ldW2pdWzBdLHRoaXMuY29vcmRzU3BsaW5lW2ldW2pdWzFdKTt9fVxuUkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZToncGF0aCcsYXR0cjp7ZDpwYXRoLHN0cm9rZTpjb2xvciwnZmlsbCc6J25vbmUnLCdzdHJva2Utd2lkdGgnOmxpbmV3aWR0aCswLjAxLCdzdHJva2UtbGluZWNhcCc6J3JvdW5kJywnc3Ryb2tlLWxpbmVqb2luJzoncm91bmQnLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6JycsJ2NsaXAtcGF0aCc6dGhpcy5pc1RyYWNlPyd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKSc6Jyd9fSk7fVxuZm9yKHZhciBkYXRhc2V0PTA7ZGF0YXNldDx0aGlzLmNvb3Jkcy5sZW5ndGg7KytkYXRhc2V0KXt0aGlzLmRyYXdUaWNrbWFya3MoZGF0YXNldCx0aGlzLmRhdGFbZGF0YXNldF0sdGhpcy5jb29yZHMpO319ZWxzZXtmb3IodmFyIGk9MDtpPHRoaXMuY29vcmRzLmxlbmd0aDsrK2kpe3ZhciBsaW5ld2lkdGg9UkcuU1ZHLmlzQXJyYXkocHJvcC5saW5ld2lkdGgpP3Byb3AubGluZXdpZHRoW2ldOnByb3AubGluZXdpZHRoLGNvbG9yPXByb3BbJ2NvbG9ycyddW2ldLHBhdGg9Jyc7Zm9yKHZhciBqPTA7ajx0aGlzLmNvb3Jkc1tpXS5sZW5ndGg7KytqKXtpZihqPT09MHx8UkcuU1ZHLmlzTnVsbCh0aGlzLmRhdGFbaV1bal0pfHxSRy5TVkcuaXNOdWxsKHRoaXMuZGF0YVtpXVtqLTFdKSl7cGF0aCs9J017MX0gezJ9ICcuZm9ybWF0KHRoaXMuY29vcmRzW2ldW2pdWzBdLHRoaXMuY29vcmRzW2ldW2pdWzFdKTt9ZWxzZXtwYXRoKz0nTHsxfSB7Mn0gJy5mb3JtYXQodGhpcy5jb29yZHNbaV1bal1bMF0sdGhpcy5jb29yZHNbaV1bal1bMV0pO319XG5SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOnBhdGgsc3Ryb2tlOmNvbG9yLCdmaWxsJzonbm9uZScsJ3N0cm9rZS13aWR0aCc6bGluZXdpZHRoKzAuMDEsJ3N0cm9rZS1saW5lY2FwJzoncm91bmQnLCdzdHJva2UtbGluZWpvaW4nOidyb3VuZCcsZmlsdGVyOnByb3Auc2hhZG93Pyd1cmwoI2Ryb3BzaGFkb3cpJzonJywnY2xpcC1wYXRoJzp0aGlzLmlzVHJhY2U/J3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJzonJ319KTt9XG5mb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuY29vcmRzLmxlbmd0aDsrK2RhdGFzZXQpe3RoaXMuZHJhd1RpY2ttYXJrcyhkYXRhc2V0LHRoaXMuZGF0YVtkYXRhc2V0XSx0aGlzLmNvb3Jkcyk7fX19O3RoaXMuZ2V0WUNvb3JkPWZ1bmN0aW9uKHZhbHVlKVxue3ZhciBwcm9wPXRoaXMucHJvcGVydGllcyx5O2lmKHZhbHVlPnRoaXMuc2NhbGUubWF4KXtyZXR1cm4gbnVsbDt9XG5pZih2YWx1ZTx0aGlzLnNjYWxlLm1pbil7cmV0dXJuIG51bGw7fVxueT0oKHZhbHVlLXRoaXMuc2NhbGUubWluKS8odGhpcy5zY2FsZS5tYXgtdGhpcy5zY2FsZS5taW4pKTt5Kj0odGhpcy5oZWlnaHQtcHJvcC5ndXR0ZXJUb3AtcHJvcC5ndXR0ZXJCb3R0b20pO3k9dGhpcy5oZWlnaHQtcHJvcC5ndXR0ZXJCb3R0b20teTtyZXR1cm4geTt9O3RoaXMuaGlnaGxpZ2h0PWZ1bmN0aW9uKHJlY3QpXG57dmFyIHg9cmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSx5PXJlY3QuZ2V0QXR0cmlidXRlKCd5Jyk7fTt0aGlzLmRyYXdTcGxpbmU9ZnVuY3Rpb24oY29vcmRzKVxue3ZhciB4Q29vcmRzPVtdO2d1dHRlckxlZnQ9cHJvcC5ndXR0ZXJMZWZ0LGd1dHRlclJpZ2h0PXByb3AuZ3V0dGVyUmlnaHQsaG1hcmdpbj1wcm9wLmhtYXJnaW4saW50ZXJ2YWw9KHRoaXMuZ3JhcGhXaWR0aC0oMipobWFyZ2luKSkvKGNvb3Jkcy5sZW5ndGgtMSksY29vcmRzU3BsaW5lPVtdO2Zvcih2YXIgaT0wLGxlbj1jb29yZHMubGVuZ3RoO2k8bGVuO2krPTEpe2lmKHR5cGVvZiBjb29yZHNbaV09PSdvYmplY3QnJiZjb29yZHNbaV0mJmNvb3Jkc1tpXS5sZW5ndGg9PTIpe2Nvb3Jkc1tpXT1OdW1iZXIoY29vcmRzW2ldWzFdKTt9fVxudmFyIFA9W2Nvb3Jkc1swXV07Zm9yKHZhciBpPTA7aTxjb29yZHMubGVuZ3RoOysraSl7UC5wdXNoKGNvb3Jkc1tpXSk7fVxuUC5wdXNoKGNvb3Jkc1tjb29yZHMubGVuZ3RoLTFdKyhjb29yZHNbY29vcmRzLmxlbmd0aC0xXS1jb29yZHNbY29vcmRzLmxlbmd0aC0yXSkpO2Zvcih2YXIgaj0xO2o8UC5sZW5ndGgtMjsrK2ope2Zvcih2YXIgdD0wO3Q8MTA7Kyt0KXt2YXIgeUNvb3JkPXNwbGluZSh0LzEwLFBbai0xXSxQW2pdLFBbaisxXSxQW2orMl0pO3hDb29yZHMucHVzaCgoKGotMSkqaW50ZXJ2YWwpKyh0KihpbnRlcnZhbC8xMCkpK2d1dHRlckxlZnQraG1hcmdpbik7Y29vcmRzU3BsaW5lLnB1c2goW3hDb29yZHNbeENvb3Jkcy5sZW5ndGgtMV0seUNvb3JkXSk7aWYodHlwZW9mIGluZGV4PT09J251bWJlcicpe2Nvb3Jkc1NwbGluZVtpbmRleF0ucHVzaChbeENvb3Jkc1t4Q29vcmRzLmxlbmd0aC0xXSx5Q29vcmRdKTt9fX1cbmNvb3Jkc1NwbGluZS5wdXNoKFsoKGotMSkqaW50ZXJ2YWwpK2d1dHRlckxlZnQraG1hcmdpbixQW2pdXSk7aWYodHlwZW9mIGluZGV4PT09J251bWJlcicpe2Nvb3Jkc1NwbGluZS5wdXNoKFsoKGotMSkqaW50ZXJ2YWwpK2d1dHRlckxlZnQraG1hcmdpbixQW2pdXSk7fVxuZnVuY3Rpb24gc3BsaW5lKHQsUDAsUDEsUDIsUDMpXG57cmV0dXJuIDAuNSooKDIqUDEpK1xuKCgwLVAwKStQMikqdCtcbigoMipQMC0oNSpQMSkrKDQqUDIpLVAzKSoodCp0KStcbigoMC1QMCkrKDMqUDEpLSgzKlAyKStQMykqKHQqdCp0KSkpO31cbnJldHVybiBjb29yZHNTcGxpbmU7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZighT2JqZWN0LmtleXModGhpcy5vcmlnaW5hbENvbG9ycykubGVuZ3RoKXt0aGlzLm9yaWdpbmFsQ29sb3JzPXtjb2xvcnM6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLGZpbGxlZENvbG9yczpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmZpbGxlZENvbG9ycyksYmFja2dyb3VuZEdyaWRDb2xvcjpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IpLGhpZ2hsaWdodEZpbGw6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKSxiYWNrZ3JvdW5kQ29sb3I6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpfX1cbnZhciBjb2xvcnM9cHJvcC5jb2xvcnM7aWYoY29sb3JzKXtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOmNvbG9yc1tpXX0pO319XG52YXIgZmlsbGVkQ29sb3JzPXByb3AuZmlsbGVkQ29sb3JzO2lmKGZpbGxlZENvbG9ycyl7Zm9yKHZhciBpPTA7aTxmaWxsZWRDb2xvcnMubGVuZ3RoOysraSl7ZmlsbGVkQ29sb3JzW2ldPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpmaWxsZWRDb2xvcnNbaV19KTt9fVxucHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmJhY2tncm91bmRHcmlkQ29sb3J9KTtwcm9wLmhpZ2hsaWdodEZpbGw9UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuaGlnaGxpZ2h0RmlsbH0pO3Byb3AuYmFja2dyb3VuZENvbG9yPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmJhY2tncm91bmRDb2xvcn0pO307dGhpcy5kcmF3TGFiZWxzQWJvdmU9ZnVuY3Rpb24oKVxue2lmKHByb3AubGFiZWxzQWJvdmUpe3ZhciBkYXRhX3NlcT1SRy5TVkcuYXJyYXlMaW5lYXJpemUodGhpcy5kYXRhKSxzZXE9MDtmb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuY29vcmRzLmxlbmd0aDsrK2RhdGFzZXQsc2VxKyspe2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHNbZGF0YXNldF0ubGVuZ3RoOysraSxzZXErKyl7dmFyIHN0cj1SRy5TVkcubnVtYmVyRm9ybWF0KHtvYmplY3Q6dGhpcyxudW06dGhpcy5kYXRhW2RhdGFzZXRdW2ldLnRvRml4ZWQocHJvcC5sYWJlbHNBYm92ZURlY2ltYWxzKSxwcmVwZW5kOnR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlVW5pdHNQcmU9PT0nc3RyaW5nJz9wcm9wLmxhYmVsc0Fib3ZlVW5pdHNQcmU6bnVsbCxhcHBlbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1Bvc3Q9PT0nc3RyaW5nJz9wcm9wLmxhYmVsc0Fib3ZlVW5pdHNQb3N0Om51bGwscG9pbnQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVQb2ludD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVQb2ludDpudWxsLHRob3VzYW5kOnR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlVGhvdXNhbmQ9PT0nc3RyaW5nJz9wcm9wLmxhYmVsc0Fib3ZlVGhvdXNhbmQ6bnVsbCxmb3JtYXR0ZXI6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVGb3JtYXR0ZXI9PT0nZnVuY3Rpb24nP3Byb3AubGFiZWxzQWJvdmVGb3JtYXR0ZXI6bnVsbH0pO2lmKHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyYmcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljLmxlbmd0aCYmKHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXT09PSdzdHJpbmcnfHx0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV09PT0nbnVtYmVyJykpe3N0cj1wcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXTt9ZWxzZSBpZihwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMmJnByb3AubGFiZWxzQWJvdmVTcGVjaWZpYy5sZW5ndGgmJnR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXSE9PSdzdHJpbmcnJiZ0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV0hPT0nbnVtYmVyJyl7Y29udGludWU7fVxuUkcuU1ZHLnRleHQoe29iamVjdDp0aGlzLHBhcmVudDp0aGlzLnN2Zy5hbGwsdGV4dDpzdHIseDpwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2RhdGFzZXRdW2ldWzBdKStwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eCx5OnBhcnNlRmxvYXQodGhpcy5jb29yZHNbZGF0YXNldF1baV1bMV0pK3Byb3AubGFiZWxzQWJvdmVPZmZzZXR5LGhhbGlnbjpwcm9wLmxhYmVsc0Fib3ZlSGFsaWduLHZhbGlnbjpwcm9wLmxhYmVsc0Fib3ZlVmFsaWduLGZvbnQ6cHJvcC5sYWJlbHNBYm92ZUZvbnR8fHByb3AudGV4dEZvbnQsc2l6ZTpwcm9wLmxhYmVsc0Fib3ZlU2l6ZXx8cHJvcC50ZXh0U2l6ZSxib2xkOnByb3AubGFiZWxzQWJvdmVCb2xkfHxwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLmxhYmVsc0Fib3ZlSXRhbGljfHxwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC5sYWJlbHNBYm92ZUNvbG9yfHxwcm9wLnRleHRDb2xvcixiYWNrZ3JvdW5kOnByb3AubGFiZWxzQWJvdmVCYWNrZ3JvdW5kfHxudWxsLHBhZGRpbmc6cHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nfHwwfSk7fVxuc2VxLS07fX19O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5SRy5TVkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy50cmFjZT1mdW5jdGlvbigpXG57dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9LGZyYW1lPTEsZnJhbWVzPW9wdC5mcmFtZXN8fDYwLG9iaj10aGlzO3RoaXMuaXNUcmFjZT10cnVlO3RoaXMuZHJhdygpO3ZhciBjbGlwUGF0aD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmRlZnMsdHlwZTonY2xpcFBhdGgnLGF0dHI6e2lkOid0cmFjZS1lZmZlY3QtY2xpcCd9fSk7dmFyIGNsaXBQYXRoUmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OmNsaXBQYXRoLHR5cGU6J3JlY3QnLGF0dHI6e3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6dGhpcy5oZWlnaHR9fSk7dmFyIGl0ZXJhdG9yPWZ1bmN0aW9uKClcbnt2YXIgd2lkdGg9KGZyYW1lKyspL2ZyYW1lcypvYmoud2lkdGg7Y2xpcFBhdGhSZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsd2lkdGgpO2lmKGZyYW1lPD1mcmFtZXMpe1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO31lbHNlIGlmKG9wdC5jYWxsYmFjayl7KG9wdC5jYWxsYmFjaykob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307Zm9yKGkgaW4gY29uZi5vcHRpb25zKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt0aGlzLnNldChpLGNvbmYub3B0aW9uc1tpXSk7fX19XG5yZXR1cm4gdGhpczt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5saW5lLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///243\n");

/***/ }),
/* 244 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Pie = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'pie';this.angles = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, colors: ['#f66', '#6f6', '#66f', '#ff6', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], strokestyle: 'rgba(0,0,0,0)', margin: 3, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], labelsSticks: true, labelsSticksHlength: 50, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, exploded: 0, roundRobinMultiplier: 1, donut: false, donutWidth: 75, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centery);RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.max = RG.SVG.arrayMax(this.data);this.total = RG.SVG.arraySum(this.data);if (typeof prop.exploded === 'number' && prop.exploded > 0) {\n        var val = prop.exploded;prop.exploded = [];for (var i = 0; i < this.data.length; ++i) {\n          prop.exploded[i] = val;\n        }\n      }\n      this.drawSegments({ shadow: true });RG.SVG.drawTitle(this);if (prop.labelsSticks) {\n        this.drawLabelsSticks();\n      } else {\n        this.drawLabels();\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawSegments = function (opt) {\n      var start = 0,\n          end = 0,\n          angle = 0,\n          sum = RG.SVG.arraySum(this.data),\n          segment = 0;for (var i = 0, len = this.data.length; i < len; ++i) {\n        var value = this.data[i] * prop.roundRobinMultiplier;start = angle;segment = value / sum * RG.SVG.TRIG.TWOPI;end = start + segment;var explosion = RG.SVG.TRIG.getRadiusEndPoint({ angle: start + segment / 2, r: prop.exploded[i] });var explosionX = explosion[1],\n            explosionY = explosion[0];this.angles[i] = { start: start, end: end, angle: end - start, halfway: (end - start) / 2 + start, cx: this.centerx + (parseFloat(explosionX) || 0), cy: this.centery - (parseFloat(explosionY) || 0), radius: this.radius };angle += end - start;\n      }\n      if (opt.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0; i < this.angles.length; ++i) {\n        var path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius, start: this.angles[i].start, end: this.angles[i].end });if (prop.donut) {\n          var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius - donutWidth, start: this.angles[i].end, end: this.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: this.angles[i].end - RG.SVG.TRIG.HALFPI, r: this.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + this.angles[i].cx, xy[1] + this.angles[i].cy) + donut_path + \" Z\";\n        } else {\n          path = path + \" L {1} {2} \".format(this.angles[i].cx, this.angles[i].cy) + \" Z\";\n        }\n        var arc = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, fill: prop.colors[i], stroke: prop.strokestyle, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-value': value, 'data-start-angle': this.angles[i].start, 'data-end-angle': this.angles[i].end, 'data-radius': this.radius, filter: prop.shadow && opt.shadow ? 'url(#dropShadow)' : '' } });if (prop.shadow && opt.shadow) {\n          this.shadowNodes[i] = arc;\n        } else {\n          this.nodes[i] = arc;\n        }\n        if (prop.tooltips && prop.tooltips[i] && (!opt.shadow || !prop.shadow)) {\n          if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          (function (index, obj) {\n            arc.addEventListener(prop.tooltipsEvent, function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: index, sequentialIndex: index, text: prop.tooltips[index], event: e });obj.highlight(e.target);var highlight = RG.SVG.REG.get('highlight');if (prop.tooltipsEvent === 'mousemove') {\n                highlight.style.cursor = 'pointer';\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              arc.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(i, this);\n        }\n      }\n      if (prop.shadow && opt.shadow) {\n        this.redrawSegments();\n      }\n    };this.redrawSegments = function () {\n      this.drawSegments({ shadow: false });\n    };this.drawLabels = function () {\n      var angles = this.angles,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0; i < angles.length; ++i) {\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: angles[i].halfway - RG.SVG.TRIG.HALFPI, r: angles[i].radius + 15 });var x = endpoint[0] + angles[i].cx,\n            y = endpoint[1] + angles[i].cy,\n            valign,\n            halign;if (angles[i].halfway > 0 && angles[i].halfway < RG.SVG.TRIG.HALFPI) {\n          halign = 'left';valign = 'bottom';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI && angles[i].halfway < RG.SVG.TRIG.PI) {\n          halign = 'left';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI) {\n          halign = 'right';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.TWOPI) {\n          halign = 'right';valign = 'top';\n        }\n        RG.SVG.text({ object: this, parent: this.svg.all, text: typeof labels[i] === 'string' ? labels[i] : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: valign, halign: halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });\n      }\n    };this.drawLabelsSticks = function () {\n      var labels_right = [],\n          labels_left = [],\n          labels_coords = [];for (var i = 0; i < this.angles.length; ++i) {\n        var angle = this.angles[i].start + (this.angles[i].end - this.angles[i].start) / 2 - RGraph.SVG.TRIG.HALFPI,\n            endpoint_inner = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 5 }),\n            endpoint_outer = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 20 }),\n            explosion = [typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i], ma.cos(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i]), ma.sin(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i])];labels_coords[i] = [];var labels = {};if (angle > RG.SVG.TRIG.HALFPI) {\n          var index = labels_left.length;labels_left[index] = [];labels_left[index].text = prop.labels[i];labels_left[index].halign = 'right';labels = labels_left;labels_coords[i].halign = 'right';\n        } else {\n          var index = labels_right.length;labels_right[index] = [];labels_right[index].text = prop.labels[i];labels_right[index].halign = 'right';labels = labels_right;labels_coords[i].halign = 'left';\n        }\n        endpoint_inner[0] += explosion[1] || 0;endpoint_inner[1] += explosion[2] || 0;endpoint_outer[0] += explosion[1] || 0;endpoint_outer[1] += explosion[2] || 0;var x, y;if (labels[index].text) {\n          var stick = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4}'.format(this.centerx + endpoint_inner[0], this.centery + endpoint_inner[1], this.centerx + endpoint_outer[0], this.centery + endpoint_outer[1]), stroke: '#999', fill: 'rgba(0,0,0,0)' } });\n        }\n        if (stick) {\n          labels[index].stick = stick;\n        }\n        x = this.centerx + endpoint_outer[0] + (angle > 1.57 ? -50 : 50);y = this.centery + endpoint_outer[1];labels_coords[i].x = x;labels_coords[i].y = y;labels_coords[i].text = prop.labels[i];\n      }\n      var vspace_right = (this.height - prop.gutterTop - prop.gutterBottom) / labels_right.length;var vspace_left = (this.height - prop.gutterTop - prop.gutterBottom) / labels_left.length;x = y = 0;for (var i = 0; i < labels_right.length; ++i) {\n        if (labels_right[i] && labels_right[i].text) {\n          x = this.centerx + this.radius + 100;y = prop.gutterTop + vspace_right * i + vspace_right / 2;RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_right[i].text === 'string' ? labels_right[i].text : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: 'center', halign: labels_right[i].text, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_right[i].stick.setAttribute('d', labels_right[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx + this.radius + prop.labelsSticksHlength));\n        }\n      }\n      for (var i = 0; i < labels_left.length; ++i) {\n        if (labels_left[i] && labels_left[i].text) {\n          x = this.centerx - this.radius - 100;y = this.height - (prop.gutterTop + vspace_left * i + vspace_left / 2);RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_left[i].text === 'string' ? labels_left[i].text : '', font: prop.textFont, size: prop.textSize, x: x - 7, y: y, valign: 'center', halign: labels_left[i].halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_left[i].stick.setAttribute('d', labels_left[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx - this.radius - prop.labelsSticksHlength));\n        }\n      }\n    };this.highlight = function (segment) {\n      var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: segment.getAttribute('d'), fill: prop.highlightFill, stroke: prop.highlightStroke, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {\n        highlight.addEventListener('mouseout', function (e) {\n          highlight.parentNode.removeChild(highlight);RG.SVG.hideTooltip();RG.SVG.REG.set('highlight', null);\n        }, false);\n      }\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.roundRobin = function () {\n      var obj = this,\n          opt = arguments[0] || {},\n          data = RG.SVG.arrayClone(this.data),\n          prop = this.properties,\n          frame = 1,\n          frames = opt.frames || 30,\n          callback = typeof opt.callback === 'function' ? opt.callback : function () {},\n          dataSum = RG.SVG.arraySum(this.data),\n          textColor = prop.textColor;this.properties.textColor = 'rgba(0,0,0,0)';obj.draw();angles = RG.SVG.arrayClone(obj.angles);function iterator() {\n        prop.roundRobinMultiplier = 1 / frames * frame++;for (var i = 0; i < obj.angles.length; ++i) {\n          var value = obj.data[i];obj.angles[i].start = angles[i].start * prop.roundRobinMultiplier;obj.angles[i].end = angles[i].end * prop.roundRobinMultiplier;var segment = (obj.angles[i].end - obj.angles[i].start) / 2;var explodedX = ma.cos(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var explodedY = ma.sin(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var path = RG.SVG.TRIG.getArcPath({ cx: obj.centerx + explodedX, cy: obj.centery + explodedY, r: obj.radius, start: obj.angles[i].start, end: obj.angles[i].end });if (prop.donut) {\n            var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: obj.angles[i].cx, cy: obj.angles[i].cy, r: obj.radius - donutWidth, start: obj.angles[i].end, end: obj.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: obj.angles[i].end - RG.SVG.TRIG.HALFPI, r: obj.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + obj.angles[i].cx, xy[1] + obj.angles[i].cy) + donut_path + \" Z\";\n          } else {\n            path = path + \" L {1} {2} \".format(obj.angles[i].cx, obj.angles[i].cy) + \" Z\";\n          }\n          path = path + \" L {1} {2} Z\".format(obj.centerx + explodedX, obj.centery + explodedY);if (obj.shadowNodes && obj.shadowNodes[i]) {\n            obj.shadowNodes[i].setAttribute('d', path);\n          }\n          obj.nodes[i].setAttribute('d', path);\n        }\n        if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else {\n          prop.textColor = textColor;RG.SVG.redraw(obj.svg);callback(obj);\n        }\n      }\n      iterator();return this;\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnBpZS5qcz9kNDBjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguU1ZHPVJHcmFwaC5TVkd8fHt9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aCx3aW49d2luZG93LGRvYz1kb2N1bWVudDtSRy5TVkcuUGllPWZ1bmN0aW9uKGNvbmYpXG57dGhpcy5zZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbntpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7Zm9yKGkgaW4gYXJndW1lbnRzWzBdKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt2YXIgcmV0PVJHLlNWRy5jb21tb25TZXR0ZXIoe29iamVjdDp0aGlzLG5hbWU6aSx2YWx1ZTphcmd1bWVudHNbMF1baV19KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnNldChuYW1lLHZhbHVlKTt9fX1lbHNle3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTpuYW1lLHZhbHVlOnZhbHVlfSk7bmFtZT1yZXQubmFtZTt2YWx1ZT1yZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdPXZhbHVlO31cbnJldHVybiB0aGlzO307dGhpcy5pZD1jb25mLmlkO3RoaXMudWlkPVJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLnN2Zz1SRy5TVkcuY3JlYXRlU1ZHKHtjb250YWluZXI6dGhpcy5jb250YWluZXJ9KTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy53aWR0aD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTt0aGlzLmhlaWdodD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7dGhpcy5kYXRhPWNvbmYuZGF0YTt0aGlzLnR5cGU9J3BpZSc7dGhpcy5hbmdsZXM9W107dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycz17fTt0aGlzLmdyYWRpZW50Q291bnRlcj0xO3RoaXMubm9kZXM9W107dGhpcy5zaGFkb3dOb2Rlcz1bXTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9J2lubGluZS1ibG9jayc7dGhpcy5wcm9wZXJ0aWVzPXtjZW50ZXJ4Om51bGwsY2VudGVyeTpudWxsLHJhZGl1czpudWxsLGd1dHRlckxlZnQ6MzUsZ3V0dGVyUmlnaHQ6MzUsZ3V0dGVyVG9wOjM1LGd1dHRlckJvdHRvbTozNSxjb2xvcnM6WycjZjY2JywnIzZmNicsJyM2NmYnLCcjZmY2JywnIzZmZicsJyNjY2MnLCdwaW5rJywnb3JhbmdlJywnY3lhbicsJ21hcm9vbicsJ29saXZlJywndGVhbCddLHN0cm9rZXN0eWxlOidyZ2JhKDAsMCwwLDApJyxtYXJnaW46Myx0ZXh0Q29sb3I6J2JsYWNrJyx0ZXh0Rm9udDonc2Fucy1zZXJpZicsdGV4dFNpemU6MTIsdGV4dEJvbGQ6ZmFsc2UsdGV4dEl0YWxpYzpmYWxzZSxsYWJlbHM6W10sbGFiZWxzU3RpY2tzOnRydWUsbGFiZWxzU3RpY2tzSGxlbmd0aDo1MCxsaW5ld2lkdGg6MSx0b29sdGlwczpudWxsLHRvb2x0aXBzT3ZlcnJpZGU6bnVsbCx0b29sdGlwc0VmZmVjdDonZmFkZScsdG9vbHRpcHNDc3NDbGFzczonUkdyYXBoX3Rvb2x0aXAnLHRvb2x0aXBzRXZlbnQ6J2NsaWNrJyxoaWdobGlnaHRTdHJva2U6J3JnYmEoMCwwLDAsMCknLGhpZ2hsaWdodEZpbGw6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsaGlnaGxpZ2h0TGluZXdpZHRoOjEsdGl0bGU6JycsdGl0bGVTaXplOjE2LHRpdGxlWDpudWxsLHRpdGxlWTpudWxsLHRpdGxlSGFsaWduOidjZW50ZXInLHRpdGxlVmFsaWduOm51bGwsdGl0bGVDb2xvcjonYmxhY2snLHRpdGxlRm9udDpudWxsLHRpdGxlQm9sZDpmYWxzZSx0aXRsZUl0YWxpYzpmYWxzZSx0aXRsZVN1YnRpdGxlOicnLHRpdGxlU3VidGl0bGVTaXplOjEwLHRpdGxlU3VidGl0bGVYOm51bGwsdGl0bGVTdWJ0aXRsZVk6bnVsbCx0aXRsZVN1YnRpdGxlSGFsaWduOidjZW50ZXInLHRpdGxlU3VidGl0bGVWYWxpZ246bnVsbCx0aXRsZVN1YnRpdGxlQ29sb3I6JyNhYWEnLHRpdGxlU3VidGl0bGVGb250Om51bGwsdGl0bGVTdWJ0aXRsZUJvbGQ6ZmFsc2UsdGl0bGVTdWJ0aXRsZUl0YWxpYzpmYWxzZSxzaGFkb3c6ZmFsc2Usc2hhZG93T2Zmc2V0eDoyLHNoYWRvd09mZnNldHk6MixzaGFkb3dCbHVyOjIsc2hhZG93T3BhY2l0eTowLjI1LGV4cGxvZGVkOjAscm91bmRSb2Jpbk11bHRpcGxpZXI6MSxkb251dDpmYWxzZSxkb251dFdpZHRoOjc1LGtleTpudWxsLGtleUNvbG9yczpudWxsLGtleU9mZnNldHg6MCxrZXlPZmZzZXR5OjAsa2V5VGV4dE9mZnNldHg6MCxrZXlUZXh0T2Zmc2V0eTotMSxrZXlUZXh0U2l6ZTpudWxsLGtleVRleHRCb2xkOm51bGwsa2V5VGV4dEl0YWxpYzpudWxsLGF0dHJpYnV0aW9uOnRydWUsYXR0cmlidXRpb25YOm51bGwsYXR0cmlidXRpb25ZOm51bGwsYXR0cmlidXRpb25IcmVmOm51bGwsYXR0cmlidXRpb25IYWxpZ246J3JpZ2h0JyxhdHRyaWJ1dGlvblZhbGlnbjonYm90dG9tJyxhdHRyaWJ1dGlvblNpemU6NyxhdHRyaWJ1dGlvbkNvbG9yOidncmF5JyxhdHRyaWJ1dGlvbkZvbnQ6J3NhbnMtc2VyaWYnLGF0dHJpYnV0aW9uSXRhbGljOmZhbHNlLGF0dHJpYnV0aW9uQm9sZDpmYWxzZX07aWYoUkcuU1ZHLkZYJiZ0eXBlb2YgUkcuU1ZHLkZYLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuU1ZHLkZYLmRlY29yYXRlKHRoaXMpO31cbnZhciBwcm9wPXRoaXMucHJvcGVydGllczt0aGlzLmRyYXc9ZnVuY3Rpb24oKVxue1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7UkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5ncmFwaFdpZHRoPXRoaXMud2lkdGgtcHJvcC5ndXR0ZXJMZWZ0LXByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodD10aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbTt0aGlzLmNlbnRlcng9KHRoaXMuZ3JhcGhXaWR0aC8yKStwcm9wLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5PSh0aGlzLmdyYXBoSGVpZ2h0LzIpK3Byb3AuZ3V0dGVyVG9wO3RoaXMucmFkaXVzPW1hLm1pbih0aGlzLmdyYXBoV2lkdGgsdGhpcy5ncmFwaEhlaWdodCkvMjt0aGlzLmNlbnRlcng9dHlwZW9mIHByb3AuY2VudGVyeD09PSdudW1iZXInP3Byb3AuY2VudGVyeDp0aGlzLmNlbnRlcng7dGhpcy5jZW50ZXJ5PXR5cGVvZiBwcm9wLmNlbnRlcnk9PT0nbnVtYmVyJz9wcm9wLmNlbnRlcnk6dGhpcy5jZW50ZXJ5O3RoaXMucmFkaXVzPXR5cGVvZiBwcm9wLnJhZGl1cz09PSdudW1iZXInP3Byb3AucmFkaXVzOnRoaXMucmFkaXVzO2lmKHR5cGVvZiBwcm9wLnJhZGl1cz09PSdzdHJpbmcnJiZwcm9wLnJhZGl1cy5tYXRjaCgvXlxcK3wtXFxkKyQvKSl0aGlzLnJhZGl1cys9cGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7aWYodHlwZW9mIHByb3AuY2VudGVyeD09PSdzdHJpbmcnJiZwcm9wLmNlbnRlcngubWF0Y2goL15cXCt8LVxcZCskLykpdGhpcy5jZW50ZXJ4Kz1wYXJzZUZsb2F0KHByb3AuY2VudGVyeCk7aWYodHlwZW9mIHByb3AuY2VudGVyeT09PSdzdHJpbmcnJiZwcm9wLmNlbnRlcnkubWF0Y2goL15cXCt8LVxcZCskLykpdGhpcy5jZW50ZXJ5Kz1wYXJzZUZsb2F0KHByb3AuY2VudGVyeSk7UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7b2JqZWN0OnRoaXN9KTt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5tYXg9UkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YSk7dGhpcy50b3RhbD1SRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhKTtpZih0eXBlb2YgcHJvcC5leHBsb2RlZD09PSdudW1iZXInJiZwcm9wLmV4cGxvZGVkPjApe3ZhciB2YWw9cHJvcC5leHBsb2RlZDtwcm9wLmV4cGxvZGVkPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe3Byb3AuZXhwbG9kZWRbaV09dmFsO319XG50aGlzLmRyYXdTZWdtZW50cyh7c2hhZG93OnRydWV9KTtSRy5TVkcuZHJhd1RpdGxlKHRoaXMpO2lmKHByb3AubGFiZWxzU3RpY2tzKXt0aGlzLmRyYXdMYWJlbHNTdGlja3MoKTt9ZWxzZXt0aGlzLmRyYXdMYWJlbHMoKTt9XG5pZih0eXBlb2YgcHJvcC5rZXkhPT1udWxsJiZSRy5TVkcuZHJhd0tleSl7UkcuU1ZHLmRyYXdLZXkodGhpcyk7fWVsc2UgaWYoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSl7YWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7fVxuUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO3ZhciBvYmo9dGhpcztkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsZnVuY3Rpb24oZSlcbntSRy5TVkcucmVtb3ZlSGlnaGxpZ2h0KG9iaik7fSxmYWxzZSk7UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd1NlZ21lbnRzPWZ1bmN0aW9uKG9wdClcbnt2YXIgc3RhcnQ9MCxlbmQ9MCxhbmdsZT0wLHN1bT1SRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhKSxzZWdtZW50PTA7Zm9yKHZhciBpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTxsZW47KytpKXt2YXIgdmFsdWU9dGhpcy5kYXRhW2ldKnByb3Aucm91bmRSb2Jpbk11bHRpcGxpZXI7c3RhcnQ9YW5nbGU7c2VnbWVudD0oKHZhbHVlL3N1bSkqUkcuU1ZHLlRSSUcuVFdPUEkpO2VuZD1zdGFydCtzZWdtZW50O3ZhciBleHBsb3Npb249UkcuU1ZHLlRSSUcuZ2V0UmFkaXVzRW5kUG9pbnQoe2FuZ2xlOnN0YXJ0KyhzZWdtZW50LzIpLHI6cHJvcC5leHBsb2RlZFtpXX0pO3ZhciBleHBsb3Npb25YPWV4cGxvc2lvblsxXSxleHBsb3Npb25ZPWV4cGxvc2lvblswXTt0aGlzLmFuZ2xlc1tpXT17c3RhcnQ6c3RhcnQsZW5kOmVuZCxhbmdsZTplbmQtc3RhcnQsaGFsZndheTooKGVuZC1zdGFydCkvMikrc3RhcnQsY3g6dGhpcy5jZW50ZXJ4KyhwYXJzZUZsb2F0KGV4cGxvc2lvblgpfHwwKSxjeTp0aGlzLmNlbnRlcnktKHBhcnNlRmxvYXQoZXhwbG9zaW9uWSl8fDApLHJhZGl1czp0aGlzLnJhZGl1c307YW5nbGUrPShlbmQtc3RhcnQpO31cbmlmKG9wdC5zaGFkb3cpe1JHLlNWRy5zZXRTaGFkb3coe29iamVjdDp0aGlzLG9mZnNldHg6cHJvcC5zaGFkb3dPZmZzZXR4LG9mZnNldHk6cHJvcC5zaGFkb3dPZmZzZXR5LGJsdXI6cHJvcC5zaGFkb3dCbHVyLG9wYWNpdHk6cHJvcC5zaGFkb3dPcGFjaXR5LGlkOidkcm9wU2hhZG93J30pO31cbmZvcih2YXIgaT0wO2k8dGhpcy5hbmdsZXMubGVuZ3RoOysraSl7dmFyIHBhdGg9UkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCh7Y3g6dGhpcy5hbmdsZXNbaV0uY3gsY3k6dGhpcy5hbmdsZXNbaV0uY3kscjp0aGlzLnJhZGl1cyxzdGFydDp0aGlzLmFuZ2xlc1tpXS5zdGFydCxlbmQ6dGhpcy5hbmdsZXNbaV0uZW5kfSk7aWYocHJvcC5kb251dCl7dmFyIGRvbnV0V2lkdGg9cHJvcC5kb251dFdpZHRoO3ZhciBkb251dF9wYXRoPVJHLlNWRy5UUklHLmdldEFyY1BhdGgoe2N4OnRoaXMuYW5nbGVzW2ldLmN4LGN5OnRoaXMuYW5nbGVzW2ldLmN5LHI6dGhpcy5yYWRpdXMtZG9udXRXaWR0aCxzdGFydDp0aGlzLmFuZ2xlc1tpXS5lbmQsZW5kOnRoaXMuYW5nbGVzW2ldLnN0YXJ0LG1vdmV0bzpmYWxzZSxhbnRpY2xvY2t3aXNlOnRydWV9KTt2YXIgeHk9UkcuU1ZHLlRSSUcuZ2V0UmFkaXVzRW5kUG9pbnQoe2FuZ2xlOnRoaXMuYW5nbGVzW2ldLmVuZC1SRy5TVkcuVFJJRy5IQUxGUEkscjp0aGlzLnJhZGl1cy1kb251dFdpZHRofSk7cGF0aD1wYXRoXG4rXCIgTCB7MX0gezJ9IFwiLmZvcm1hdCh4eVswXSt0aGlzLmFuZ2xlc1tpXS5jeCx4eVsxXSt0aGlzLmFuZ2xlc1tpXS5jeSlcbitkb251dF9wYXRoXG4rXCIgWlwiO31lbHNle3BhdGg9cGF0aCtcIiBMIHsxfSB7Mn0gXCIuZm9ybWF0KHRoaXMuYW5nbGVzW2ldLmN4LHRoaXMuYW5nbGVzW2ldLmN5KStcIiBaXCJ9XG52YXIgYXJjPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6cGF0aCxmaWxsOnByb3AuY29sb3JzW2ldLHN0cm9rZTpwcm9wLnN0cm9rZXN0eWxlLCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdkYXRhLXRvb2x0aXAnOighUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSYmcHJvcC50b29sdGlwcy5sZW5ndGgpP3Byb3AudG9vbHRpcHNbaV06JycsJ2RhdGEtaW5kZXgnOmksJ2RhdGEtdmFsdWUnOnZhbHVlLCdkYXRhLXN0YXJ0LWFuZ2xlJzp0aGlzLmFuZ2xlc1tpXS5zdGFydCwnZGF0YS1lbmQtYW5nbGUnOnRoaXMuYW5nbGVzW2ldLmVuZCwnZGF0YS1yYWRpdXMnOnRoaXMucmFkaXVzLGZpbHRlcjoocHJvcC5zaGFkb3cmJm9wdC5zaGFkb3cpPyd1cmwoI2Ryb3BTaGFkb3cpJzonJ319KTtpZihwcm9wLnNoYWRvdyYmb3B0LnNoYWRvdyl7dGhpcy5zaGFkb3dOb2Rlc1tpXT1hcmM7fWVsc2V7dGhpcy5ub2Rlc1tpXT1hcmM7fVxuaWYocHJvcC50b29sdGlwcyYmcHJvcC50b29sdGlwc1tpXSYmKCFvcHQuc2hhZG93fHwhcHJvcC5zaGFkb3cpKXtpZihwcm9wLnRvb2x0aXBzRXZlbnQhPT0nbW91c2Vtb3ZlJyl7cHJvcC50b29sdGlwc0V2ZW50PSdjbGljayc7fVxuKGZ1bmN0aW9uKGluZGV4LG9iailcbnthcmMuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsZnVuY3Rpb24oZSlcbntvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7UkcuU1ZHLnRvb2x0aXAoe29iamVjdDpvYmosaW5kZXg6aW5kZXgsc2VxdWVudGlhbEluZGV4OmluZGV4LHRleHQ6cHJvcC50b29sdGlwc1tpbmRleF0sZXZlbnQ6ZX0pO29iai5oaWdobGlnaHQoZS50YXJnZXQpO3ZhciBoaWdobGlnaHQ9UkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO2lmKHByb3AudG9vbHRpcHNFdmVudD09PSdtb3VzZW1vdmUnKXtoaWdobGlnaHQuc3R5bGUuY3Vyc29yPSdwb2ludGVyJzt9fSxmYWxzZSk7aWYocHJvcC50b29sdGlwc0V2ZW50PT09J2NsaWNrJyl7YXJjLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZnVuY3Rpb24oZSlcbntlLnRhcmdldC5zdHlsZS5jdXJzb3I9J3BvaW50ZXInO30sZmFsc2UpO319KGksdGhpcykpO319XG5pZihwcm9wLnNoYWRvdyYmb3B0LnNoYWRvdyl7dGhpcy5yZWRyYXdTZWdtZW50cygpO319O3RoaXMucmVkcmF3U2VnbWVudHM9ZnVuY3Rpb24oKVxue3RoaXMuZHJhd1NlZ21lbnRzKHtzaGFkb3c6ZmFsc2V9KTt9O3RoaXMuZHJhd0xhYmVscz1mdW5jdGlvbigpXG57dmFyIGFuZ2xlcz10aGlzLmFuZ2xlcyxwcm9wPXRoaXMucHJvcGVydGllcyxsYWJlbHM9cHJvcC5sYWJlbHM7Zm9yKHZhciBpPTA7aTxhbmdsZXMubGVuZ3RoOysraSl7dmFyIGVuZHBvaW50PVJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHthbmdsZTphbmdsZXNbaV0uaGFsZndheS1SRy5TVkcuVFJJRy5IQUxGUEkscjphbmdsZXNbaV0ucmFkaXVzKzE1fSk7dmFyIHg9ZW5kcG9pbnRbMF0rYW5nbGVzW2ldLmN4LHk9ZW5kcG9pbnRbMV0rYW5nbGVzW2ldLmN5LHZhbGlnbixoYWxpZ247aWYoYW5nbGVzW2ldLmhhbGZ3YXk+MCYmYW5nbGVzW2ldLmhhbGZ3YXk8UkcuU1ZHLlRSSUcuSEFMRlBJKXtoYWxpZ249J2xlZnQnO3ZhbGlnbj0nYm90dG9tJzt9ZWxzZSBpZihhbmdsZXNbaV0uaGFsZndheT5SRy5TVkcuVFJJRy5IQUxGUEkmJmFuZ2xlc1tpXS5oYWxmd2F5PFJHLlNWRy5UUklHLlBJKXtoYWxpZ249J2xlZnQnO3ZhbGlnbj0ndG9wJzt9ZWxzZSBpZihhbmdsZXNbaV0uaGFsZndheT5SRy5TVkcuVFJJRy5QSSYmYW5nbGVzW2ldLmhhbGZ3YXk8KFJHLlNWRy5UUklHLkhBTEZQSStSRy5TVkcuVFJJRy5QSSkpe2hhbGlnbj0ncmlnaHQnO3ZhbGlnbj0ndG9wJzt9ZWxzZSBpZihhbmdsZXNbaV0uaGFsZndheT4oUkcuU1ZHLlRSSUcuSEFMRlBJK1JHLlNWRy5UUklHLlBJKSYmYW5nbGVzW2ldLmhhbGZ3YXk8UkcuU1ZHLlRSSUcuVFdPUEkpe2hhbGlnbj0ncmlnaHQnO3ZhbGlnbj0ndG9wJzt9XG5SRy5TVkcudGV4dCh7b2JqZWN0OnRoaXMscGFyZW50OnRoaXMuc3ZnLmFsbCx0ZXh0OnR5cGVvZiBsYWJlbHNbaV09PT0nc3RyaW5nJz9sYWJlbHNbaV06JycsZm9udDpwcm9wLnRleHRGb250LHNpemU6cHJvcC50ZXh0U2l6ZSx4OngseTp5LHZhbGlnbjp2YWxpZ24saGFsaWduOmhhbGlnbixib2xkOnByb3AudGV4dEJvbGQsaXRhbGljOnByb3AudGV4dEl0YWxpYyxjb2xvcjpwcm9wLnRleHRDb2xvcn0pO319O3RoaXMuZHJhd0xhYmVsc1N0aWNrcz1mdW5jdGlvbigpXG57dmFyIGxhYmVsc19yaWdodD1bXSxsYWJlbHNfbGVmdD1bXSxsYWJlbHNfY29vcmRzPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5hbmdsZXMubGVuZ3RoOysraSl7dmFyIGFuZ2xlPSh0aGlzLmFuZ2xlc1tpXS5zdGFydCsoKHRoaXMuYW5nbGVzW2ldLmVuZC10aGlzLmFuZ2xlc1tpXS5zdGFydCkvMikpLVJHcmFwaC5TVkcuVFJJRy5IQUxGUEksZW5kcG9pbnRfaW5uZXI9UkcuU1ZHLlRSSUcuZ2V0UmFkaXVzRW5kUG9pbnQoe2FuZ2xlOmFuZ2xlLHI6dGhpcy5yYWRpdXMrNX0pLGVuZHBvaW50X291dGVyPVJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHthbmdsZTphbmdsZSxyOnRoaXMucmFkaXVzKzIwfSksZXhwbG9zaW9uPVsodHlwZW9mIHByb3AuZXhwbG9kZWQ9PT0nbnVtYmVyJz9wcm9wLmV4cGxvZGVkOnByb3AuZXhwbG9kZWRbaV0pLG1hLmNvcyhhbmdsZSkqKHR5cGVvZiBwcm9wLmV4cGxvZGVkPT09J251bWJlcic/cHJvcC5leHBsb2RlZDpwcm9wLmV4cGxvZGVkW2ldKSxtYS5zaW4oYW5nbGUpKih0eXBlb2YgcHJvcC5leHBsb2RlZD09PSdudW1iZXInP3Byb3AuZXhwbG9kZWQ6cHJvcC5leHBsb2RlZFtpXSldO2xhYmVsc19jb29yZHNbaV09W107dmFyIGxhYmVscz17fTtpZihhbmdsZT5SRy5TVkcuVFJJRy5IQUxGUEkpe3ZhciBpbmRleD1sYWJlbHNfbGVmdC5sZW5ndGg7bGFiZWxzX2xlZnRbaW5kZXhdPVtdO2xhYmVsc19sZWZ0W2luZGV4XS50ZXh0PXByb3AubGFiZWxzW2ldO2xhYmVsc19sZWZ0W2luZGV4XS5oYWxpZ249J3JpZ2h0JztsYWJlbHM9bGFiZWxzX2xlZnQ7bGFiZWxzX2Nvb3Jkc1tpXS5oYWxpZ249J3JpZ2h0Jzt9ZWxzZXt2YXIgaW5kZXg9bGFiZWxzX3JpZ2h0Lmxlbmd0aDtsYWJlbHNfcmlnaHRbaW5kZXhdPVtdO2xhYmVsc19yaWdodFtpbmRleF0udGV4dD1wcm9wLmxhYmVsc1tpXTtsYWJlbHNfcmlnaHRbaW5kZXhdLmhhbGlnbj0ncmlnaHQnO2xhYmVscz1sYWJlbHNfcmlnaHQ7bGFiZWxzX2Nvb3Jkc1tpXS5oYWxpZ249J2xlZnQnO31cbmVuZHBvaW50X2lubmVyWzBdKz0oZXhwbG9zaW9uWzFdfHwwKTtlbmRwb2ludF9pbm5lclsxXSs9KGV4cGxvc2lvblsyXXx8MCk7ZW5kcG9pbnRfb3V0ZXJbMF0rPShleHBsb3Npb25bMV18fDApO2VuZHBvaW50X291dGVyWzFdKz0oZXhwbG9zaW9uWzJdfHwwKTt2YXIgeCx5O2lmKGxhYmVsc1tpbmRleF0udGV4dCl7dmFyIHN0aWNrPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J3BhdGgnLGF0dHI6e2Q6J00gezF9IHsyfSBMIHszfSB7NH0nLmZvcm1hdCh0aGlzLmNlbnRlcngrZW5kcG9pbnRfaW5uZXJbMF0sdGhpcy5jZW50ZXJ5K2VuZHBvaW50X2lubmVyWzFdLHRoaXMuY2VudGVyeCtlbmRwb2ludF9vdXRlclswXSx0aGlzLmNlbnRlcnkrZW5kcG9pbnRfb3V0ZXJbMV0pLHN0cm9rZTonIzk5OScsZmlsbDoncmdiYSgwLDAsMCwwKSd9fSk7fVxuaWYoc3RpY2spe2xhYmVsc1tpbmRleF0uc3RpY2s9c3RpY2s7fVxueD0odGhpcy5jZW50ZXJ4K2VuZHBvaW50X291dGVyWzBdKyhhbmdsZT4xLjU3Py01MDo1MCkpO3k9KHRoaXMuY2VudGVyeStlbmRwb2ludF9vdXRlclsxXSk7bGFiZWxzX2Nvb3Jkc1tpXS54PXg7bGFiZWxzX2Nvb3Jkc1tpXS55PXk7bGFiZWxzX2Nvb3Jkc1tpXS50ZXh0PXByb3AubGFiZWxzW2ldO31cbnZhciB2c3BhY2VfcmlnaHQ9KHRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyVG9wLXByb3AuZ3V0dGVyQm90dG9tKS9sYWJlbHNfcmlnaHQubGVuZ3RoO3ZhciB2c3BhY2VfbGVmdD0odGhpcy5oZWlnaHQtcHJvcC5ndXR0ZXJUb3AtcHJvcC5ndXR0ZXJCb3R0b20pL2xhYmVsc19sZWZ0Lmxlbmd0aDt4PXk9MDtmb3IodmFyIGk9MDtpPGxhYmVsc19yaWdodC5sZW5ndGg7KytpKXtpZihsYWJlbHNfcmlnaHRbaV0mJmxhYmVsc19yaWdodFtpXS50ZXh0KXt4PXRoaXMuY2VudGVyeCt0aGlzLnJhZGl1cysxMDA7eT1wcm9wLmd1dHRlclRvcCsodnNwYWNlX3JpZ2h0KmkpKyh2c3BhY2VfcmlnaHQvMik7UkdyYXBoLlNWRy50ZXh0KHtvYmplY3Q6dGhpcyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHRleHQ6dHlwZW9mIGxhYmVsc19yaWdodFtpXS50ZXh0PT09J3N0cmluZyc/bGFiZWxzX3JpZ2h0W2ldLnRleHQ6JycsZm9udDpwcm9wLnRleHRGb250LHNpemU6cHJvcC50ZXh0U2l6ZSx4OngseTp5LHZhbGlnbjonY2VudGVyJyxoYWxpZ246bGFiZWxzX3JpZ2h0W2ldLnRleHQsYm9sZDpwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC50ZXh0Q29sb3J9KTtsYWJlbHNfcmlnaHRbaV0uc3RpY2suc2V0QXR0cmlidXRlKCdkJyxsYWJlbHNfcmlnaHRbaV0uc3RpY2suZ2V0QXR0cmlidXRlKCdkJykrJyBIIHszfSBMIHsxfSB7Mn0gJy5mb3JtYXQoeC01LHksdGhpcy5jZW50ZXJ4K3RoaXMucmFkaXVzK3Byb3AubGFiZWxzU3RpY2tzSGxlbmd0aCkpO319XG5mb3IodmFyIGk9MDtpPGxhYmVsc19sZWZ0Lmxlbmd0aDsrK2kpe2lmKGxhYmVsc19sZWZ0W2ldJiZsYWJlbHNfbGVmdFtpXS50ZXh0KXt4PXRoaXMuY2VudGVyeC10aGlzLnJhZGl1cy0xMDA7eT10aGlzLmhlaWdodC0ocHJvcC5ndXR0ZXJUb3ArKHZzcGFjZV9sZWZ0KmkpKyh2c3BhY2VfbGVmdC8yKSk7UkdyYXBoLlNWRy50ZXh0KHtvYmplY3Q6dGhpcyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHRleHQ6dHlwZW9mIGxhYmVsc19sZWZ0W2ldLnRleHQ9PT0nc3RyaW5nJz9sYWJlbHNfbGVmdFtpXS50ZXh0OicnLGZvbnQ6cHJvcC50ZXh0Rm9udCxzaXplOnByb3AudGV4dFNpemUseDp4LTcseTp5LHZhbGlnbjonY2VudGVyJyxoYWxpZ246bGFiZWxzX2xlZnRbaV0uaGFsaWduLGJvbGQ6cHJvcC50ZXh0Qm9sZCxpdGFsaWM6cHJvcC50ZXh0SXRhbGljLGNvbG9yOnByb3AudGV4dENvbG9yfSk7bGFiZWxzX2xlZnRbaV0uc3RpY2suc2V0QXR0cmlidXRlKCdkJyxsYWJlbHNfbGVmdFtpXS5zdGljay5nZXRBdHRyaWJ1dGUoJ2QnKSsnIEggezN9IEwgezF9IHsyfSAnLmZvcm1hdCh4LTUseSx0aGlzLmNlbnRlcngtdGhpcy5yYWRpdXMtcHJvcC5sYWJlbHNTdGlja3NIbGVuZ3RoKSk7fX19O3RoaXMuaGlnaGxpZ2h0PWZ1bmN0aW9uKHNlZ21lbnQpXG57dmFyIGhpZ2hsaWdodD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidwYXRoJyxhdHRyOntkOnNlZ21lbnQuZ2V0QXR0cmlidXRlKCdkJyksZmlsbDpwcm9wLmhpZ2hsaWdodEZpbGwsc3Ryb2tlOnByb3AuaGlnaGxpZ2h0U3Ryb2tlLCdzdHJva2Utd2lkdGgnOnByb3AuaGlnaGxpZ2h0TGluZXdpZHRofX0pO2lmKHByb3AudG9vbHRpcHNFdmVudD09PSdtb3VzZW1vdmUnKXtoaWdobGlnaHQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLGZ1bmN0aW9uKGUpXG57aGlnaGxpZ2h0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0KTtSRy5TVkcuaGlkZVRvb2x0aXAoKTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JyxudWxsKTt9LGZhbHNlKTt9XG5SRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JyxoaWdobGlnaHQpO307dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCl7dGhpcy5vcmlnaW5hbENvbG9ycz17Y29sb3JzOlJHLlNWRy5hcnJheUNsb25lKHByb3AuY29sb3JzKSxoaWdobGlnaHRGaWxsOlJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCl9fVxudmFyIGNvbG9ycz1wcm9wLmNvbG9ycztpZihjb2xvcnMpe2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT1SRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7b2JqZWN0OnRoaXMsY29sb3I6Y29sb3JzW2ldfSk7fX1cbnByb3AuaGlnaGxpZ2h0RmlsbD1SRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7b2JqZWN0OnRoaXMsY29sb3I6cHJvcC5oaWdobGlnaHRGaWxsfSk7fTt0aGlzLnJvdW5kUm9iaW49ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxvcHQ9YXJndW1lbnRzWzBdfHx7fSxkYXRhPVJHLlNWRy5hcnJheUNsb25lKHRoaXMuZGF0YSkscHJvcD10aGlzLnByb3BlcnRpZXMsZnJhbWU9MSxmcmFtZXM9b3B0LmZyYW1lc3x8MzAsY2FsbGJhY2s9dHlwZW9mIG9wdC5jYWxsYmFjaz09PSdmdW5jdGlvbic/b3B0LmNhbGxiYWNrOmZ1bmN0aW9uKCl7fSxkYXRhU3VtPVJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGEpLHRleHRDb2xvcj1wcm9wLnRleHRDb2xvcjt0aGlzLnByb3BlcnRpZXMudGV4dENvbG9yPSdyZ2JhKDAsMCwwLDApJztvYmouZHJhdygpO2FuZ2xlcz1SRy5TVkcuYXJyYXlDbG9uZShvYmouYW5nbGVzKTtmdW5jdGlvbiBpdGVyYXRvcigpXG57cHJvcC5yb3VuZFJvYmluTXVsdGlwbGllcj0xL2ZyYW1lcypmcmFtZSsrO2Zvcih2YXIgaT0wO2k8b2JqLmFuZ2xlcy5sZW5ndGg7KytpKXt2YXIgdmFsdWU9b2JqLmRhdGFbaV07b2JqLmFuZ2xlc1tpXS5zdGFydD1hbmdsZXNbaV0uc3RhcnQqcHJvcC5yb3VuZFJvYmluTXVsdGlwbGllcjtvYmouYW5nbGVzW2ldLmVuZD1hbmdsZXNbaV0uZW5kKnByb3Aucm91bmRSb2Jpbk11bHRpcGxpZXI7dmFyIHNlZ21lbnQ9KChvYmouYW5nbGVzW2ldLmVuZC1vYmouYW5nbGVzW2ldLnN0YXJ0KS8yKTt2YXIgZXhwbG9kZWRYPW1hLmNvcyhvYmouYW5nbGVzW2ldLnN0YXJ0K3NlZ21lbnQtUkcuU1ZHLlRSSUcuSEFMRlBJKSoocHJvcC5leHBsb2RlZFtpXXx8MCk7dmFyIGV4cGxvZGVkWT1tYS5zaW4ob2JqLmFuZ2xlc1tpXS5zdGFydCtzZWdtZW50LVJHLlNWRy5UUklHLkhBTEZQSSkqKHByb3AuZXhwbG9kZWRbaV18fDApO3ZhciBwYXRoPVJHLlNWRy5UUklHLmdldEFyY1BhdGgoe2N4Om9iai5jZW50ZXJ4K2V4cGxvZGVkWCxjeTpvYmouY2VudGVyeStleHBsb2RlZFkscjpvYmoucmFkaXVzLHN0YXJ0Om9iai5hbmdsZXNbaV0uc3RhcnQsZW5kOm9iai5hbmdsZXNbaV0uZW5kfSk7aWYocHJvcC5kb251dCl7dmFyIGRvbnV0V2lkdGg9cHJvcC5kb251dFdpZHRoO3ZhciBkb251dF9wYXRoPVJHLlNWRy5UUklHLmdldEFyY1BhdGgoe2N4Om9iai5hbmdsZXNbaV0uY3gsY3k6b2JqLmFuZ2xlc1tpXS5jeSxyOm9iai5yYWRpdXMtZG9udXRXaWR0aCxzdGFydDpvYmouYW5nbGVzW2ldLmVuZCxlbmQ6b2JqLmFuZ2xlc1tpXS5zdGFydCxtb3ZldG86ZmFsc2UsYW50aWNsb2Nrd2lzZTp0cnVlfSk7dmFyIHh5PVJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHthbmdsZTpvYmouYW5nbGVzW2ldLmVuZC1SRy5TVkcuVFJJRy5IQUxGUEkscjpvYmoucmFkaXVzLWRvbnV0V2lkdGh9KTtwYXRoPXBhdGhcbitcIiBMIHsxfSB7Mn0gXCIuZm9ybWF0KHh5WzBdK29iai5hbmdsZXNbaV0uY3gseHlbMV0rb2JqLmFuZ2xlc1tpXS5jeSlcbitkb251dF9wYXRoXG4rXCIgWlwiO31lbHNle3BhdGg9cGF0aCtcIiBMIHsxfSB7Mn0gXCIuZm9ybWF0KG9iai5hbmdsZXNbaV0uY3gsb2JqLmFuZ2xlc1tpXS5jeSkrXCIgWlwifVxucGF0aD1wYXRoK1wiIEwgezF9IHsyfSBaXCIuZm9ybWF0KG9iai5jZW50ZXJ4K2V4cGxvZGVkWCxvYmouY2VudGVyeStleHBsb2RlZFkpO2lmKG9iai5zaGFkb3dOb2RlcyYmb2JqLnNoYWRvd05vZGVzW2ldKXtvYmouc2hhZG93Tm9kZXNbaV0uc2V0QXR0cmlidXRlKCdkJyxwYXRoKTt9XG5vYmoubm9kZXNbaV0uc2V0QXR0cmlidXRlKCdkJyxwYXRoKTt9XG5pZihmcmFtZTw9ZnJhbWVzKXtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTt9ZWxzZXtwcm9wLnRleHRDb2xvcj10ZXh0Q29sb3I7UkcuU1ZHLnJlZHJhdyhvYmouc3ZnKTtjYWxsYmFjayhvYmopO319XG5pdGVyYXRvcigpO3JldHVybiB0aGlzO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cblJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLnJlbW92ZUhpZ2hsaWdodD1mdW5jdGlvbigpXG57dmFyIGhpZ2hsaWdodD1SRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYoaGlnaGxpZ2h0JiZoaWdobGlnaHQucGFyZW50Tm9kZSl7aGlnaGxpZ2h0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0KTt9XG5SRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JyxudWxsKTt9O2ZvcihpIGluIGNvbmYub3B0aW9ucyl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7dGhpcy5zZXQoaSxjb25mLm9wdGlvbnNbaV0pO319fTtyZXR1cm4gdGhpczt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5waWUuanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///244\n");

/***/ }),
/* 245 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Radar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = RG.SVG.arrayClone(conf.data);this.originalData = RG.SVG.arrayClone(conf.data);this.type = 'radar';this.coords = [];this.coords2 = [];this.angles = [];this.angles2 = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];this.max = 0;this.redraw = false;this.highlight_node = null;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridRadialsCount: null, backgroundGridConcentricsCount: 5, backgroundGridLinewidth: 1, backgroundGridPoly: true, colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], filled: false, filledOpacity: 0.25, filledAccumulative: true, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], scaleVisible: true, scaleUnitsPre: '', scaleUnitsPost: '', scaleMax: null, scaleMin: 0, scalePoint: '.', scaleThousand: ',', scaleRound: false, scaleDecimals: 0, scaleFormatter: null, scaleBold: null, scaleItalic: null, scaleColor: null, scaleSize: null, scaleFont: null, scaleLabelsCount: 5, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarks: 'circle', tickmarksLinewidth: 1, tickmarksSize: 6, tickmarksFill: 'white', title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, grouping: 'normal', shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');this.data = RG.SVG.arrayClone(this.originalData);if (this.data.length > 1) {\n        var len = this.data[0].length;for (var i = 1; i < this.data.length; ++i) {\n          if (this.data[i].length !== len) {\n            alert('[ERROR] The Radar chart datasets must have the same number of elements!');\n          }\n        }\n      }\n      this.angles = [];this.coords = [];this.coords2 = [];RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n        this.data = [this.data];\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        for (var j = 0; j < this.data[i].length; ++j) {\n          if (typeof this.data[i][j] === 'string') {\n            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n          }\n        }\n      }\n      if (prop.filled && prop.filledAccumulative) {\n        for (var dataset = 1; dataset < this.data.length; ++dataset) {\n          for (var i = 0; i < this.data[dataset].length; ++i) {\n            this.data[dataset][i] += this.data[dataset - 1][i];\n          }\n        }\n      }\n      this.getMaxValue();RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.scale = RG.SVG.getScale({ object: this, numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount, unitsPre: prop.scaleUnitsPre, unitsPost: prop.scaleUnitsPost, max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max, min: prop.scaleMin, point: prop.scalePoint, round: prop.scaleRound, thousand: prop.scaleThousand, decimals: prop.scaleDecimals, strict: typeof prop.scaleMax === 'number', formatter: prop.scaleFormatter });this.max = this.scale.max;this.drawBackground();this.drawRadar();this.drawTickmarks();this.drawLabels();RG.SVG.drawTitle(this);this.addTooltipHotspots();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      var obj = this;doc.body.addEventListener('mousedown', function (e) {\n        obj.hideHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBackground = function () {\n      if (prop.backgroundGrid) {\n        var grid = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_grid', fill: 'rgba(0,0,0,0)', stroke: prop.backgroundGridColor } });var origin = 0 - RG.SVG.TRIG.PI / 2,\n            radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data[0].length,\n            concentrics = prop.backgroundGridConcentricsCount,\n            step = RG.SVG.TRIG.TWOPI / radials;if (radials > 0) {\n          for (var i = 0, len = radials; i < len; ++i) {\n            var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius, angle: origin + i * step });var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: str, stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n          }\n        }\n        if (concentrics > 0) {\n          if (prop.backgroundGridPoly) {\n            for (var j = 1; j <= concentrics; j++) {\n              for (var i = 0, len = radials, path = []; i < len; ++i) {\n                var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), angle: origin + i * step });path.push('{1} {2} {3}'.format(i === 0 ? 'M' : 'L', coords.x, coords.y));\n              }\n              RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: path.join(' ') + ' z', fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          } else {\n            for (var j = 1; j <= concentrics; j++) {\n              RG.SVG.create({ svg: this.svg, type: 'circle', parent: grid, attr: { cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          }\n        }\n      }\n    };this.drawRadar = function (opt) {\n      for (var dataset = 0, len = this.data.length; dataset < len; ++dataset) {\n        this.coords2[dataset] = [];this.angles2[dataset] = [];var path = [];for (var i = 0, len2 = this.data[dataset].length; i < len2; ++i) {\n          var value = this.data[dataset][i];var xy = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.getRadius(this.data[dataset][i]), angle: RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI });xy.r = (value - prop.scaleMin) / (this.max - prop.scaleMin) * this.radius;xy.angle = RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI;path.push('{1}{2} {3}'.format(i === 0 ? 'M' : 'L', xy.x, xy.y));this.angles.push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.angles2[dataset].push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.coords.push([xy.x, xy.y]);this.coords2[dataset].push([xy.x, xy.y]);\n        }\n        if (dataset > 0 && prop.filled && prop.filledAccumulative) {\n          path.push('L {1} {2}'.format(this.coords2[dataset][0][0], this.coords2[dataset][0][1]));path.push('M {1} {2}'.format(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]));for (var i = this.coords2[dataset - 1].length - 1; i >= 0; --i) {\n            path.push('L {1} {2}'.format(this.coords2[dataset - 1][i][0], this.coords2[dataset - 1][i][1]));\n          }\n          this.redraw = true;\n        } else {\n          path.push('z');\n        }\n        var path = RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: prop.filled ? prop.colors[dataset] : 'transparent', 'fill-opacity': prop.filledOpacity, 'stroke-width': prop.linewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '', filter: prop.shadow ? 'url(#dropShadow)' : '' } });path.setAttribute('data-dataset', dataset);\n      }\n      this.redrawRadar();\n    };this.redrawRadar = function () {\n      if (this.redraw) {\n        this.redraw = false;for (var dataset = 0; dataset < this.coords2.length; ++dataset) {\n          var path = [];for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            if (i === 0) {\n              path.push('M {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            } else {\n              path.push('L {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            }\n          }\n          path.push('z');\n          RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: 'transparent', 'stroke-width': prop.linewidth } });\n        }\n      }\n    };this.drawTickmarks = function () {\n      var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_tickmarks' } });for (var i = 0; i < this.coords2.length; ++i) {\n        for (var j = 0; j < this.coords2[i].length; ++j) {\n          if (prop.tickmarks === 'circle' || prop.tickmarks === 'filledcircle') {\n            var c = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[i][j][0], cy: this.coords2[i][j][1], r: prop.tickmarksSize, fill: prop.tickmarks === 'filledcircle' ? prop.colors[i] : prop.tickmarksFill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });c.setAttribute('data-dataset', i);c.setAttribute('data-index', j);\n          } else if (prop.tickmarks === 'rect' || prop.tickmarks === 'filledrect') {\n            var halfTickmarkSize = prop.tickmarksSize / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && prop.tickmarksFill[i] ? prop.tickmarksFill[i] : prop.tickmarksFill;var s = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: this.coords2[i][j][0] - halfTickmarkSize, y: this.coords2[i][j][1] - halfTickmarkSize, width: prop.tickmarksSize, height: prop.tickmarksSize, fill: prop.tickmarks === 'filledrect' ? prop.colors[i] : fill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth } });s.setAttribute('data-dataset', i);s.setAttribute('data-index', j);\n          }\n        }\n      }\n    };this.drawLabels = function () {\n      var angles = this.angles2,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0, len = labels.length; i < len; ++i) {\n        if (!labels[i]) {\n          continue;\n        }\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: RG.SVG.TRIG.TWOPI / labels.length * i - RG.SVG.TRIG.HALFPI, r: this.radius + 15 });var x = endpoint[0] + this.centerx,\n            y = endpoint[1] + this.centery;if (i / len < 0.5) {\n          halign = 'left';\n        } else {\n          halign = 'right';\n        }\n        if (i / len < 0.25 || i / len > 0.75) {\n          valign = 'bottom';\n        } else {\n          valign = 'top';\n        }\n        if (i / len === 0) {\n          halign = 'center';\n        }\n        if (i / len === 0.25) {\n          valign = 'center';\n        }\n        if (i / len === 0.5) {\n          halign = 'center';\n        }\n        if (i / len === 0.75) {\n          valign = 'center';\n        }\n        RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: labels[i], size: typeof prop.labelsSize === 'number' ? prop.labelsSize : prop.textSize, x: x, y: y, halign: halign, valign: 'center', color: prop.labelsColor || prop.textColor, bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold, italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic, font: prop.labelsFont || prop.textFont });\n      }\n      if (prop.scaleVisible) {\n        for (var i = 0; i < this.scale.labels.length; ++i) {\n          var x = this.centerx;var y = this.centery - this.radius / this.scale.labels.length * (i + 1);RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: this.scale.labels[i], size: prop.scaleSize || prop.textSize - 2, x: x, y: y, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n        }\n        var str = RG.SVG.numberFormat({ object: this, num: this.scale.min.toFixed(prop.scaleDecimals), prepend: prop.scaleUnitsPre, append: prop.scaleUnitsPost, point: prop.scalePoint, thousand: prop.scaleThousand, formatter: prop.scaleFormatter });RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: str, size: prop.scaleSize || prop.textSize - 2, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n      }\n    };this.highlight = function (circle) {\n      circle.setAttribute('fill', prop.highlightFill);circle.setAttribute('stroke', prop.highlightStroke);circle.setAttribute('stroke-width', prop.highlightLinewidth);this.highlight_node = circle;RG.SVG.REG.set('highlight', circle);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.getMaxValue = function () {\n      var max = 0;if (prop.filled && prop.filledAccumulative) {\n        this.max = RG.SVG.arrayMax(this.data[this.data.length - 1]);\n      } else {\n        for (var dataset = 0, max = 0; dataset < this.data.length; ++dataset) {\n          this.max = ma.max(this.max, RG.SVG.arrayMax(this.data[dataset]));\n        }\n      }\n    };this.getRadius = function (value) {\n      return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n    };this.addTooltipHotspots = function () {\n      if (prop.tooltips && prop.tooltips.length > 0) {\n        if (prop.tooltipsEvent !== 'mousemove') {\n          prop.tooltipsEvent = 'click';\n        }\n        var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph-radar-tooltip-hotspots' } });for (var dataset = 0, seq = 0; dataset < this.coords2.length; ++dataset) {\n          for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            var circle = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[dataset][i][0], cy: this.coords2[dataset][i][1], r: prop.tickmarksSize, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0, 'data-sequential-index': seq }, style: { cursor: prop['tooltips'][seq] ? 'pointer' : 'default' } });(function (dataset, index, seq, obj) {\n              if (prop.tooltips[seq]) {\n                circle.addEventListener(prop.tooltipsEvent, function (e) {\n                  var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__sequentialIndex__ === seq) {\n                    return;\n                  }\n                  RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(this);\n                }, false);if (prop.tooltipsEvent === 'click') {\n                  circle.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                  }, false);\n                }\n              }\n            })(dataset, i, seq++, this);\n          }\n        }\n      }\n    };this.roundRobin = function () {};this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = this.hideHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && this.highlight_node) {\n        this.highlight_node.setAttribute('fill', 'transparent');this.highlight_node.setAttribute('stroke', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 120,\n          obj = this;\n      step = 360 / frames;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });clipPathArcPath = RG.SVG.TRIG.getArcPath2({ cx: this.angles[0].cx, cy: this.angles[0].cy, r: this.angles[0].r * 2, start: 0, end: 0 });var clipPathArc = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'path', attr: { d: clipPathArcPath } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;var deg = 360 / frames * frame++,\n            rad = RG.SVG.TRIG.TWOPI / 360 * deg;\n        clipPathArc.setAttribute('d', RG.SVG.TRIG.getArcPath2({ cx: obj.angles[0].cx, cy: obj.angles[0].cy, r: obj.angles[0].r * 2, start: 0, end: rad }));if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnJhZGFyLmpzPzc5YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5TVkc9UkdyYXBoLlNWR3x8e307KGZ1bmN0aW9uKHdpbixkb2MsdW5kZWZpbmVkKVxue3ZhciBSRz1SR3JhcGgsdWE9bmF2aWdhdG9yLnVzZXJBZ2VudCxtYT1NYXRoLHdpbj13aW5kb3csZG9jPWRvY3VtZW50O1JHLlNWRy5SYWRhcj1mdW5jdGlvbihjb25mKVxue3RoaXMuc2V0PWZ1bmN0aW9uKG5hbWUsdmFsdWUpXG57aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe2ZvcihpIGluIGFyZ3VtZW50c1swXSl7aWYodHlwZW9mIGk9PT0nc3RyaW5nJyl7dmFyIHJldD1SRy5TVkcuY29tbW9uU2V0dGVyKHtvYmplY3Q6dGhpcyxuYW1lOmksdmFsdWU6YXJndW1lbnRzWzBdW2ldfSk7bmFtZT1yZXQubmFtZTt2YWx1ZT1yZXQudmFsdWU7dGhpcy5zZXQobmFtZSx2YWx1ZSk7fX19ZWxzZXt2YXIgcmV0PVJHLlNWRy5jb21tb25TZXR0ZXIoe29iamVjdDp0aGlzLG5hbWU6bmFtZSx2YWx1ZTp2YWx1ZX0pO25hbWU9cmV0Lm5hbWU7dmFsdWU9cmV0LnZhbHVlO3RoaXMucHJvcGVydGllc1tuYW1lXT12YWx1ZTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuaWQ9Y29uZi5pZDt0aGlzLnVpZD1SRy5TVkcuY3JlYXRlVUlEKCk7dGhpcy5jb250YWluZXI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5zdmc9UkcuU1ZHLmNyZWF0ZVNWRyh7Y29udGFpbmVyOnRoaXMuY29udGFpbmVyfSk7dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMud2lkdGg9TnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7dGhpcy5oZWlnaHQ9TnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO3RoaXMuZGF0YT1SRy5TVkcuYXJyYXlDbG9uZShjb25mLmRhdGEpO3RoaXMub3JpZ2luYWxEYXRhPVJHLlNWRy5hcnJheUNsb25lKGNvbmYuZGF0YSk7dGhpcy50eXBlPSdyYWRhcic7dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO3RoaXMuYW5nbGVzPVtdO3RoaXMuYW5nbGVzMj1bXTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLm9yaWdpbmFsQ29sb3JzPXt9O3RoaXMuZ3JhZGllbnRDb3VudGVyPTE7dGhpcy5ub2Rlcz1bXTt0aGlzLnNoYWRvd05vZGVzPVtdO3RoaXMubWF4PTA7dGhpcy5yZWRyYXc9ZmFsc2U7dGhpcy5oaWdobGlnaHRfbm9kZT1udWxsO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheT0naW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXM9e2NlbnRlcng6bnVsbCxjZW50ZXJ5Om51bGwscmFkaXVzOm51bGwsZ3V0dGVyTGVmdDozNSxndXR0ZXJSaWdodDozNSxndXR0ZXJUb3A6MzUsZ3V0dGVyQm90dG9tOjM1LGJhY2tncm91bmRHcmlkOnRydWUsYmFja2dyb3VuZEdyaWRDb2xvcjonI2RkZCcsYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNzQ291bnQ6NSxiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDoxLGJhY2tncm91bmRHcmlkUG9seTp0cnVlLGNvbG9yczpbJ3JlZCcsJ2JsYWNrJywnb3JhbmdlJywnZ3JlZW4nLCcjNmZmJywnI2NjYycsJ3BpbmsnLCdvcmFuZ2UnLCdjeWFuJywnbWFyb29uJywnb2xpdmUnLCd0ZWFsJ10sZmlsbGVkOmZhbHNlLGZpbGxlZE9wYWNpdHk6MC4yNSxmaWxsZWRBY2N1bXVsYXRpdmU6dHJ1ZSx0ZXh0Q29sb3I6J2JsYWNrJyx0ZXh0Rm9udDonc2Fucy1zZXJpZicsdGV4dFNpemU6MTIsdGV4dEJvbGQ6ZmFsc2UsdGV4dEl0YWxpYzpmYWxzZSxsYWJlbHM6W10sc2NhbGVWaXNpYmxlOnRydWUsc2NhbGVVbml0c1ByZTonJyxzY2FsZVVuaXRzUG9zdDonJyxzY2FsZU1heDpudWxsLHNjYWxlTWluOjAsc2NhbGVQb2ludDonLicsc2NhbGVUaG91c2FuZDonLCcsc2NhbGVSb3VuZDpmYWxzZSxzY2FsZURlY2ltYWxzOjAsc2NhbGVGb3JtYXR0ZXI6bnVsbCxzY2FsZUJvbGQ6bnVsbCxzY2FsZUl0YWxpYzpudWxsLHNjYWxlQ29sb3I6bnVsbCxzY2FsZVNpemU6bnVsbCxzY2FsZUZvbnQ6bnVsbCxzY2FsZUxhYmVsc0NvdW50OjUsbGluZXdpZHRoOjEsdG9vbHRpcHM6bnVsbCx0b29sdGlwc092ZXJyaWRlOm51bGwsdG9vbHRpcHNFZmZlY3Q6J2ZhZGUnLHRvb2x0aXBzQ3NzQ2xhc3M6J1JHcmFwaF90b29sdGlwJyx0b29sdGlwc0V2ZW50Oidtb3VzZW1vdmUnLGhpZ2hsaWdodFN0cm9rZToncmdiYSgwLDAsMCwwKScsaGlnaGxpZ2h0RmlsbDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxoaWdobGlnaHRMaW5ld2lkdGg6MSx0aWNrbWFya3M6J2NpcmNsZScsdGlja21hcmtzTGluZXdpZHRoOjEsdGlja21hcmtzU2l6ZTo2LHRpY2ttYXJrc0ZpbGw6J3doaXRlJyx0aXRsZTonJyx0aXRsZVNpemU6MTYsdGl0bGVYOm51bGwsdGl0bGVZOm51bGwsdGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVWYWxpZ246bnVsbCx0aXRsZUNvbG9yOidibGFjaycsdGl0bGVGb250Om51bGwsdGl0bGVCb2xkOmZhbHNlLHRpdGxlSXRhbGljOmZhbHNlLHRpdGxlU3VidGl0bGU6JycsdGl0bGVTdWJ0aXRsZVNpemU6MTAsdGl0bGVTdWJ0aXRsZVg6bnVsbCx0aXRsZVN1YnRpdGxlWTpudWxsLHRpdGxlU3VidGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVTdWJ0aXRsZVZhbGlnbjpudWxsLHRpdGxlU3VidGl0bGVDb2xvcjonI2FhYScsdGl0bGVTdWJ0aXRsZUZvbnQ6bnVsbCx0aXRsZVN1YnRpdGxlQm9sZDpmYWxzZSx0aXRsZVN1YnRpdGxlSXRhbGljOmZhbHNlLGdyb3VwaW5nOidub3JtYWwnLHNoYWRvdzpmYWxzZSxzaGFkb3dPZmZzZXR4OjIsc2hhZG93T2Zmc2V0eToyLHNoYWRvd0JsdXI6MixzaGFkb3dPcGFjaXR5OjAuMjUsa2V5Om51bGwsa2V5Q29sb3JzOm51bGwsa2V5T2Zmc2V0eDowLGtleU9mZnNldHk6MCxrZXlUZXh0T2Zmc2V0eDowLGtleVRleHRPZmZzZXR5Oi0xLGtleVRleHRTaXplOm51bGwsa2V5VGV4dEJvbGQ6bnVsbCxrZXlUZXh0SXRhbGljOm51bGwsYXR0cmlidXRpb246dHJ1ZSxhdHRyaWJ1dGlvblg6bnVsbCxhdHRyaWJ1dGlvblk6bnVsbCxhdHRyaWJ1dGlvbkhyZWY6bnVsbCxhdHRyaWJ1dGlvbkhhbGlnbjoncmlnaHQnLGF0dHJpYnV0aW9uVmFsaWduOidib3R0b20nLGF0dHJpYnV0aW9uU2l6ZTo3LGF0dHJpYnV0aW9uQ29sb3I6J2dyYXknLGF0dHJpYnV0aW9uRm9udDonc2Fucy1zZXJpZicsYXR0cmlidXRpb25JdGFsaWM6ZmFsc2UsYXR0cmlidXRpb25Cb2xkOmZhbHNlfTtpZihSRy5TVkcuRlgmJnR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7fVxudmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO3RoaXMuZHJhdz1mdW5jdGlvbigpXG57UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLmRhdGE9UkcuU1ZHLmFycmF5Q2xvbmUodGhpcy5vcmlnaW5hbERhdGEpO2lmKHRoaXMuZGF0YS5sZW5ndGg+MSl7dmFyIGxlbj10aGlzLmRhdGFbMF0ubGVuZ3RoO2Zvcih2YXIgaT0xO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe2lmKHRoaXMuZGF0YVtpXS5sZW5ndGghPT1sZW4pe2FsZXJ0KCdbRVJST1JdIFRoZSBSYWRhciBjaGFydCBkYXRhc2V0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIScpO319fVxudGhpcy5hbmdsZXM9W107dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHMyPVtdO1JHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO3RoaXMuZ3JhcGhXaWR0aD10aGlzLndpZHRoLXByb3AuZ3V0dGVyTGVmdC1wcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQ9dGhpcy5oZWlnaHQtcHJvcC5ndXR0ZXJUb3AtcHJvcC5ndXR0ZXJCb3R0b207dGhpcy5jZW50ZXJ4PSh0aGlzLmdyYXBoV2lkdGgvMikrcHJvcC5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeT0odGhpcy5ncmFwaEhlaWdodC8yKStwcm9wLmd1dHRlclRvcDt0aGlzLnJhZGl1cz1tYS5taW4odGhpcy5ncmFwaFdpZHRoLHRoaXMuZ3JhcGhIZWlnaHQpLzI7dGhpcy5jZW50ZXJ4PXR5cGVvZiBwcm9wLmNlbnRlcng9PT0nbnVtYmVyJz9wcm9wLmNlbnRlcng6dGhpcy5jZW50ZXJ4O3RoaXMuY2VudGVyeT10eXBlb2YgcHJvcC5jZW50ZXJ5PT09J251bWJlcic/cHJvcC5jZW50ZXJ5OnRoaXMuY2VudGVyeTt0aGlzLnJhZGl1cz10eXBlb2YgcHJvcC5yYWRpdXM9PT0nbnVtYmVyJz9wcm9wLnJhZGl1czp0aGlzLnJhZGl1cztpZih0eXBlb2YgcHJvcC5yYWRpdXM9PT0nc3RyaW5nJyYmcHJvcC5yYWRpdXMubWF0Y2goL15cXCt8LVxcZCskLykpdGhpcy5yYWRpdXMrPXBhcnNlRmxvYXQocHJvcC5yYWRpdXMpO2lmKHR5cGVvZiBwcm9wLmNlbnRlcng9PT0nc3RyaW5nJyYmcHJvcC5jZW50ZXJ4Lm1hdGNoKC9eXFwrfC1cXGQrJC8pKXRoaXMuY2VudGVyeSs9cGFyc2VGbG9hdChwcm9wLmNlbnRlcngpO2lmKHR5cGVvZiBwcm9wLmNlbnRlcnk9PT0nc3RyaW5nJyYmcHJvcC5jZW50ZXJ5Lm1hdGNoKC9eXFwrfC1cXGQrJC8pKXRoaXMuY2VudGVyeCs9cGFyc2VGbG9hdChwcm9wLmNlbnRlcnkpO2lmKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YSkmJih0eXBlb2YgdGhpcy5kYXRhWzBdPT09J251bWJlcid8fHR5cGVvZiB0aGlzLmRhdGFbMF09PT0nc3RyaW5nJykpe3RoaXMuZGF0YT1bdGhpcy5kYXRhXTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtmb3IodmFyIGo9MDtqPHRoaXMuZGF0YVtpXS5sZW5ndGg7KytqKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdPT09J3N0cmluZycpe3RoaXMuZGF0YVtpXVtqXT1SRy5TVkcuc3RyaW5nc1RvTnVtYmVycyh0aGlzLmRhdGFbaV1bal0pO319fVxuaWYocHJvcC5maWxsZWQmJnByb3AuZmlsbGVkQWNjdW11bGF0aXZlKXtmb3IodmFyIGRhdGFzZXQ9MTtkYXRhc2V0PHRoaXMuZGF0YS5sZW5ndGg7KytkYXRhc2V0KXtmb3IodmFyIGk9MDtpPHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7KytpKXt0aGlzLmRhdGFbZGF0YXNldF1baV0rPXRoaXMuZGF0YVtkYXRhc2V0LTFdW2ldO319fVxudGhpcy5nZXRNYXhWYWx1ZSgpO1JHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoe29iamVjdDp0aGlzfSk7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuc2NhbGU9UkcuU1ZHLmdldFNjYWxlKHtvYmplY3Q6dGhpcyxudW1sYWJlbHM6dHlwZW9mIHByb3Auc2NhbGVMYWJlbHNDb3VudD09PSdudW1iZXInP3Byb3Auc2NhbGVMYWJlbHNDb3VudDpwcm9wLmJhY2tncm91bmRHcmlkQ29uY2VudHJpY0NvdW50LHVuaXRzUHJlOnByb3Auc2NhbGVVbml0c1ByZSx1bml0c1Bvc3Q6cHJvcC5zY2FsZVVuaXRzUG9zdCxtYXg6dHlwZW9mIHByb3Auc2NhbGVNYXg9PT0nbnVtYmVyJz9wcm9wLnNjYWxlTWF4OnRoaXMubWF4LG1pbjpwcm9wLnNjYWxlTWluLHBvaW50OnByb3Auc2NhbGVQb2ludCxyb3VuZDpwcm9wLnNjYWxlUm91bmQsdGhvdXNhbmQ6cHJvcC5zY2FsZVRob3VzYW5kLGRlY2ltYWxzOnByb3Auc2NhbGVEZWNpbWFscyxzdHJpY3Q6dHlwZW9mIHByb3Auc2NhbGVNYXg9PT0nbnVtYmVyJyxmb3JtYXR0ZXI6cHJvcC5zY2FsZUZvcm1hdHRlcn0pO3RoaXMubWF4PXRoaXMuc2NhbGUubWF4O3RoaXMuZHJhd0JhY2tncm91bmQoKTt0aGlzLmRyYXdSYWRhcigpO3RoaXMuZHJhd1RpY2ttYXJrcygpO3RoaXMuZHJhd0xhYmVscygpO1JHLlNWRy5kcmF3VGl0bGUodGhpcyk7dGhpcy5hZGRUb29sdGlwSG90c3BvdHMoKTtpZih0eXBlb2YgcHJvcC5rZXkhPT1udWxsJiZSRy5TVkcuZHJhd0tleSl7UkcuU1ZHLmRyYXdLZXkodGhpcyk7fWVsc2UgaWYoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSl7YWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7fVxuUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO2lmKHByb3Auc2hhZG93KXtSRy5TVkcuc2V0U2hhZG93KHtvYmplY3Q6dGhpcyxvZmZzZXR4OnByb3Auc2hhZG93T2Zmc2V0eCxvZmZzZXR5OnByb3Auc2hhZG93T2Zmc2V0eSxibHVyOnByb3Auc2hhZG93Qmx1cixvcGFjaXR5OnByb3Auc2hhZG93T3BhY2l0eSxpZDonZHJvcFNoYWRvdyd9KTt9XG52YXIgb2JqPXRoaXM7ZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxmdW5jdGlvbihlKVxue29iai5oaWRlSGlnaGxpZ2h0KG9iaik7fSxmYWxzZSk7UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0JhY2tncm91bmQ9ZnVuY3Rpb24oKVxue2lmKHByb3AuYmFja2dyb3VuZEdyaWQpe3ZhciBncmlkPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2ZyxwYXJlbnQ6dGhpcy5zdmcuYWxsLHR5cGU6J2cnLGF0dHI6e2NsYXNzTmFtZToncmdyYXBoX3JhZGFyX2dyaWQnLGZpbGw6J3JnYmEoMCwwLDAsMCknLHN0cm9rZTpwcm9wLmJhY2tncm91bmRHcmlkQ29sb3J9fSk7dmFyIG9yaWdpbj0wLShSRy5TVkcuVFJJRy5QSS8yKSxyYWRpYWxzPSh0eXBlb2YgcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNDb3VudD09PSdudW1iZXInP3Byb3AuYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQ6dGhpcy5kYXRhWzBdLmxlbmd0aCksY29uY2VudHJpY3M9cHJvcC5iYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNzQ291bnQsc3RlcD1SRy5TVkcuVFJJRy5UV09QSS9yYWRpYWxzO2lmKHJhZGlhbHM+MCl7Zm9yKHZhciBpPTAsbGVuPXJhZGlhbHM7aTxsZW47KytpKXt2YXIgY29vcmRzPVJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtjeDp0aGlzLmNlbnRlcngsY3k6dGhpcy5jZW50ZXJ5LHI6dGhpcy5yYWRpdXMsYW5nbGU6b3JpZ2luKyhpKnN0ZXApfSk7dmFyIHN0cj0nTSB7MX0gezJ9IEwgezN9IHs0fScuZm9ybWF0KHRoaXMuY2VudGVyeCx0aGlzLmNlbnRlcnksY29vcmRzLngsY29vcmRzLnkpO1JHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidwYXRoJyxwYXJlbnQ6Z3JpZCxhdHRyOntkOnN0cixzdHJva2U6cHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLCdzdHJva2Utd2lkdGgnOnByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGh9fSk7fX1cbmlmKGNvbmNlbnRyaWNzPjApe2lmKHByb3AuYmFja2dyb3VuZEdyaWRQb2x5KXtmb3IodmFyIGo9MTtqPD1jb25jZW50cmljcztqKyspe2Zvcih2YXIgaT0wLGxlbj1yYWRpYWxzLHBhdGg9W107aTxsZW47KytpKXt2YXIgY29vcmRzPVJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtjeDp0aGlzLmNlbnRlcngsY3k6dGhpcy5jZW50ZXJ5LHI6dGhpcy5yYWRpdXMqKGovY29uY2VudHJpY3MpLGFuZ2xlOm9yaWdpbisoaSpzdGVwKX0pO3BhdGgucHVzaCgnezF9IHsyfSB7M30nLmZvcm1hdChpPT09MD8nTSc6J0wnLGNvb3Jkcy54LGNvb3Jkcy55KSk7fVxuUkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3BhdGgnLHBhcmVudDpncmlkLGF0dHI6e2Q6cGF0aC5qb2luKCcgJykrJyB6JyxmaWxsOid0cmFuc3BhcmVudCcsc3Ryb2tlOnByb3AuYmFja2dyb3VuZEdyaWRDb2xvciwnc3Ryb2tlLXdpZHRoJzpwcm9wLmJhY2tncm91bmRHcmlkTGluZXdpZHRofX0pO319ZWxzZXtmb3IodmFyIGo9MTtqPD1jb25jZW50cmljcztqKyspe1JHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidjaXJjbGUnLHBhcmVudDpncmlkLGF0dHI6e2N4OnRoaXMuY2VudGVyeCxjeTp0aGlzLmNlbnRlcnkscjp0aGlzLnJhZGl1cyooai9jb25jZW50cmljcyksZmlsbDondHJhbnNwYXJlbnQnLHN0cm9rZTpwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IsJ3N0cm9rZS13aWR0aCc6cHJvcC5iYWNrZ3JvdW5kR3JpZExpbmV3aWR0aH19KTt9fX19fTt0aGlzLmRyYXdSYWRhcj1mdW5jdGlvbihvcHQpXG57Zm9yKHZhciBkYXRhc2V0PTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7ZGF0YXNldDxsZW47KytkYXRhc2V0KXt0aGlzLmNvb3JkczJbZGF0YXNldF09W107dGhpcy5hbmdsZXMyW2RhdGFzZXRdPVtdO3ZhciBwYXRoPVtdO2Zvcih2YXIgaT0wLGxlbjI9dGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDtpPGxlbjI7KytpKXt2YXIgdmFsdWU9dGhpcy5kYXRhW2RhdGFzZXRdW2ldO3ZhciB4eT1SRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7Y3g6dGhpcy5jZW50ZXJ4LGN5OnRoaXMuY2VudGVyeSxyOnRoaXMuZ2V0UmFkaXVzKHRoaXMuZGF0YVtkYXRhc2V0XVtpXSksYW5nbGU6KFJHLlNWRy5UUklHLlRXT1BJL2xlbjIpKmktUkcuU1ZHLlRSSUcuSEFMRlBJfSk7eHkucj0oKCh2YWx1ZS1wcm9wLnNjYWxlTWluKS8odGhpcy5tYXgtcHJvcC5zY2FsZU1pbikpKSp0aGlzLnJhZGl1czt4eS5hbmdsZT0oUkcuU1ZHLlRSSUcuVFdPUEkvbGVuMikqaS1SRy5TVkcuVFJJRy5IQUxGUEk7cGF0aC5wdXNoKCd7MX17Mn0gezN9Jy5mb3JtYXQoaT09PTA/J00nOidMJyx4eS54LHh5LnkpKTt0aGlzLmFuZ2xlcy5wdXNoKHtjeDp0aGlzLmNlbnRlcngsY3k6dGhpcy5jZW50ZXJ5LHI6eHkucixhbmdsZTp4eS5hbmdsZX0pO3RoaXMuYW5nbGVzMltkYXRhc2V0XS5wdXNoKHtjeDp0aGlzLmNlbnRlcngsY3k6dGhpcy5jZW50ZXJ5LHI6eHkucixhbmdsZTp4eS5hbmdsZX0pO3RoaXMuY29vcmRzLnB1c2goW3h5LngseHkueV0pO3RoaXMuY29vcmRzMltkYXRhc2V0XS5wdXNoKFt4eS54LHh5LnldKTt9XG5pZihkYXRhc2V0PjAmJnByb3AuZmlsbGVkJiZwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSl7cGF0aC5wdXNoKCdMIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldF1bMF1bMF0sdGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzFdKSk7cGF0aC5wdXNoKCdNIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldC0xXVswXVswXSx0aGlzLmNvb3JkczJbZGF0YXNldC0xXVswXVsxXSkpO2Zvcih2YXIgaT10aGlzLmNvb3JkczJbZGF0YXNldC0xXS5sZW5ndGgtMTtpPj0wOy0taSl7cGF0aC5wdXNoKCdMIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldC0xXVtpXVswXSx0aGlzLmNvb3JkczJbZGF0YXNldC0xXVtpXVsxXSkpO31cbnRoaXMucmVkcmF3PXRydWU7fWVsc2V7cGF0aC5wdXNoKCd6Jyk7fVxudmFyIHBhdGg9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3BhdGgnLHBhcmVudDp0aGlzLnN2Zy5hbGwsYXR0cjp7ZDpwYXRoLmpvaW4oXCIgXCIpLHN0cm9rZTpwcm9wLmNvbG9yc1tkYXRhc2V0XSxmaWxsOnByb3AuZmlsbGVkP3Byb3AuY29sb3JzW2RhdGFzZXRdOid0cmFuc3BhcmVudCcsJ2ZpbGwtb3BhY2l0eSc6cHJvcC5maWxsZWRPcGFjaXR5LCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdjbGlwLXBhdGgnOnRoaXMuaXNUcmFjZT8ndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknOicnLGZpbHRlcjpwcm9wLnNoYWRvdz8ndXJsKCNkcm9wU2hhZG93KSc6JycsfX0pO3BhdGguc2V0QXR0cmlidXRlKCdkYXRhLWRhdGFzZXQnLGRhdGFzZXQpO31cbnRoaXMucmVkcmF3UmFkYXIoKTt9O3RoaXMucmVkcmF3UmFkYXI9ZnVuY3Rpb24oKVxue2lmKHRoaXMucmVkcmF3KXt0aGlzLnJlZHJhdz1mYWxzZTtmb3IodmFyIGRhdGFzZXQ9MDtkYXRhc2V0PHRoaXMuY29vcmRzMi5sZW5ndGg7KytkYXRhc2V0KXt2YXIgcGF0aD1bXTtmb3IodmFyIGk9MDtpPHRoaXMuY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7KytpKXtpZihpPT09MCl7cGF0aC5wdXNoKCdNIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldF1baV1bMF0sdGhpcy5jb29yZHMyW2RhdGFzZXRdW2ldWzFdKSk7fWVsc2V7cGF0aC5wdXNoKCdMIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldF1baV1bMF0sdGhpcy5jb29yZHMyW2RhdGFzZXRdW2ldWzFdKSl9fVxucGF0aC5wdXNoKCd6JylcblJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidwYXRoJyxwYXJlbnQ6dGhpcy5zdmcuYWxsLGF0dHI6e2Q6cGF0aC5qb2luKFwiIFwiKSxzdHJva2U6cHJvcC5jb2xvcnNbZGF0YXNldF0sZmlsbDondHJhbnNwYXJlbnQnLCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRofX0pO319fTt0aGlzLmRyYXdUaWNrbWFya3M9ZnVuY3Rpb24oKVxue3ZhciBncm91cD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidnJyxhdHRyOntjbGFzc05hbWU6J3JncmFwaF9yYWRhcl90aWNrbWFya3MnfX0pO2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMyLmxlbmd0aDsrK2kpe2Zvcih2YXIgaj0wO2o8dGhpcy5jb29yZHMyW2ldLmxlbmd0aDsrK2ope2lmKHByb3AudGlja21hcmtzPT09J2NpcmNsZSd8fHByb3AudGlja21hcmtzPT09J2ZpbGxlZGNpcmNsZScpe3ZhciBjPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidjaXJjbGUnLHBhcmVudDpncm91cCxhdHRyOntjeDp0aGlzLmNvb3JkczJbaV1bal1bMF0sY3k6dGhpcy5jb29yZHMyW2ldW2pdWzFdLHI6cHJvcC50aWNrbWFya3NTaXplLGZpbGw6cHJvcC50aWNrbWFya3M9PT0nZmlsbGVkY2lyY2xlJz9wcm9wLmNvbG9yc1tpXTpwcm9wLnRpY2ttYXJrc0ZpbGwsc3Ryb2tlOnByb3AuY29sb3JzW2ldLCdzdHJva2Utd2lkdGgnOnByb3AudGlja21hcmtzTGluZXdpZHRoLCdjbGlwLXBhdGgnOnRoaXMuaXNUcmFjZT8ndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknOicnfX0pO2Muc2V0QXR0cmlidXRlKCdkYXRhLWRhdGFzZXQnLGkpO2Muc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyxqKTt9ZWxzZSBpZihwcm9wLnRpY2ttYXJrcz09PSdyZWN0J3x8cHJvcC50aWNrbWFya3M9PT0nZmlsbGVkcmVjdCcpe3ZhciBoYWxmVGlja21hcmtTaXplPXByb3AudGlja21hcmtzU2l6ZS8yO3ZhciBmaWxsPXR5cGVvZiBwcm9wLnRpY2ttYXJrc0ZpbGw9PT0nb2JqZWN0JyYmcHJvcC50aWNrbWFya3NGaWxsW2ldP3Byb3AudGlja21hcmtzRmlsbFtpXTpwcm9wLnRpY2ttYXJrc0ZpbGw7dmFyIHM9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3JlY3QnLHBhcmVudDpncm91cCxhdHRyOnt4OnRoaXMuY29vcmRzMltpXVtqXVswXS1oYWxmVGlja21hcmtTaXplLHk6dGhpcy5jb29yZHMyW2ldW2pdWzFdLWhhbGZUaWNrbWFya1NpemUsd2lkdGg6cHJvcC50aWNrbWFya3NTaXplLGhlaWdodDpwcm9wLnRpY2ttYXJrc1NpemUsZmlsbDpwcm9wLnRpY2ttYXJrcz09PSdmaWxsZWRyZWN0Jz9wcm9wLmNvbG9yc1tpXTpmaWxsLHN0cm9rZTpwcm9wLmNvbG9yc1tpXSwnc3Ryb2tlLXdpZHRoJzpwcm9wLnRpY2ttYXJrc0xpbmV3aWR0aH19KTtzLnNldEF0dHJpYnV0ZSgnZGF0YS1kYXRhc2V0JyxpKTtzLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsaik7fX19fTt0aGlzLmRyYXdMYWJlbHM9ZnVuY3Rpb24oKVxue3ZhciBhbmdsZXM9dGhpcy5hbmdsZXMyLHByb3A9dGhpcy5wcm9wZXJ0aWVzLGxhYmVscz1wcm9wLmxhYmVscztmb3IodmFyIGk9MCxsZW49bGFiZWxzLmxlbmd0aDtpPGxlbjsrK2kpe2lmKCFsYWJlbHNbaV0pe2NvbnRpbnVlO31cbnZhciBlbmRwb2ludD1SRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCh7YW5nbGU6UkcuU1ZHLlRSSUcuVFdPUEkvbGFiZWxzLmxlbmd0aCppLVJHLlNWRy5UUklHLkhBTEZQSSxyOnRoaXMucmFkaXVzKzE1fSk7dmFyIHg9ZW5kcG9pbnRbMF0rdGhpcy5jZW50ZXJ4LHk9ZW5kcG9pbnRbMV0rdGhpcy5jZW50ZXJ5O2lmKChpL2xlbik8MC41KXtoYWxpZ249J2xlZnQnO31lbHNle2hhbGlnbj0ncmlnaHQnO31cbmlmKChpL2xlbik8MC4yNXx8KGkvbGVuKT4wLjc1KXt2YWxpZ249J2JvdHRvbSc7fWVsc2V7dmFsaWduPSd0b3AnO31cbmlmKChpL2xlbik9PT0wKXtoYWxpZ249J2NlbnRlcic7fVxuaWYoKGkvbGVuKT09PTAuMjUpe3ZhbGlnbj0nY2VudGVyJzt9XG5pZigoaS9sZW4pPT09MC41KXtoYWxpZ249J2NlbnRlcic7fVxuaWYoKGkvbGVuKT09PTAuNzUpe3ZhbGlnbj0nY2VudGVyJzt9XG5SRy5TVkcudGV4dCh7b2JqZWN0OnRoaXMsc3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdGV4dDpsYWJlbHNbaV0sc2l6ZTp0eXBlb2YgcHJvcC5sYWJlbHNTaXplPT09J251bWJlcic/cHJvcC5sYWJlbHNTaXplOnByb3AudGV4dFNpemUseDp4LHk6eSxoYWxpZ246aGFsaWduLHZhbGlnbjonY2VudGVyJyxjb2xvcjpwcm9wLmxhYmVsc0NvbG9yfHxwcm9wLnRleHRDb2xvcixib2xkOnR5cGVvZiBwcm9wLmxhYmVsc0JvbGQ9PT0nYm9vbGVhbic/cHJvcC5sYWJlbHNCb2xkOnByb3AudGV4dEJvbGQsaXRhbGljOnR5cGVvZiBwcm9wLmxhYmVsc0l0YWxpYz09PSdib29sZWFuJz9wcm9wLmxhYmVsc0l0YWxpYzpwcm9wLnRleHRJdGFsaWMsZm9udDpwcm9wLmxhYmVsc0ZvbnR8fHByb3AudGV4dEZvbnR9KTt9XG5pZihwcm9wLnNjYWxlVmlzaWJsZSl7Zm9yKHZhciBpPTA7aTx0aGlzLnNjYWxlLmxhYmVscy5sZW5ndGg7KytpKXt2YXIgeD10aGlzLmNlbnRlcng7dmFyIHk9dGhpcy5jZW50ZXJ5LSh0aGlzLnJhZGl1cy90aGlzLnNjYWxlLmxhYmVscy5sZW5ndGgqKGkrMSkpO1JHLlNWRy50ZXh0KHtvYmplY3Q6dGhpcyxzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0ZXh0OnRoaXMuc2NhbGUubGFiZWxzW2ldLHNpemU6cHJvcC5zY2FsZVNpemV8fHByb3AudGV4dFNpemUtMix4OngseTp5LGhhbGlnbjonY2VudGVyJyx2YWxpZ246J2NlbnRlcicsYmFja2dyb3VuZDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxwYWRkaW5nOjIsY29sb3I6cHJvcC5zY2FsZUNvbG9yfHxwcm9wLnRleHRDb2xvcixib2xkOnR5cGVvZiBwcm9wLnNjYWxlQm9sZD09PSdib29sZWFuJz9wcm9wLnNjYWxlQm9sZDpwcm9wLnRleHRCb2xkLGl0YWxpYzp0eXBlb2YgcHJvcC5zY2FsZUl0YWxpYz09PSdib29sZWFuJz9wcm9wLnNjYWxlSXRhbGljOnByb3AudGV4dEl0YWxpYyxmb250OnByb3Auc2NhbGVGb250fHxwcm9wLnRleHRGb250fSk7fVxudmFyIHN0cj1SRy5TVkcubnVtYmVyRm9ybWF0KHtvYmplY3Q6dGhpcyxudW06dGhpcy5zY2FsZS5taW4udG9GaXhlZChwcm9wLnNjYWxlRGVjaW1hbHMpLHByZXBlbmQ6cHJvcC5zY2FsZVVuaXRzUHJlLGFwcGVuZDpwcm9wLnNjYWxlVW5pdHNQb3N0LHBvaW50OnByb3Auc2NhbGVQb2ludCx0aG91c2FuZDpwcm9wLnNjYWxlVGhvdXNhbmQsZm9ybWF0dGVyOnByb3Auc2NhbGVGb3JtYXR0ZXJ9KTtSRy5TVkcudGV4dCh7b2JqZWN0OnRoaXMsc3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdGV4dDpzdHIsc2l6ZTpwcm9wLnNjYWxlU2l6ZXx8cHJvcC50ZXh0U2l6ZS0yLHg6dGhpcy5jZW50ZXJ4LHk6dGhpcy5jZW50ZXJ5LGhhbGlnbjonY2VudGVyJyx2YWxpZ246J2NlbnRlcicsYmFja2dyb3VuZDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxwYWRkaW5nOjIsY29sb3I6cHJvcC5zY2FsZUNvbG9yfHxwcm9wLnRleHRDb2xvcixib2xkOnR5cGVvZiBwcm9wLnNjYWxlQm9sZD09PSdib29sZWFuJz9wcm9wLnNjYWxlQm9sZDpwcm9wLnRleHRCb2xkLGl0YWxpYzp0eXBlb2YgcHJvcC5zY2FsZUl0YWxpYz09PSdib29sZWFuJz9wcm9wLnNjYWxlSXRhbGljOnByb3AudGV4dEl0YWxpYyxmb250OnByb3Auc2NhbGVGb250fHxwcm9wLnRleHRGb250fSk7fX07dGhpcy5oaWdobGlnaHQ9ZnVuY3Rpb24oY2lyY2xlKVxue2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLHByb3AuaGlnaGxpZ2h0RmlsbCk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJyxwcm9wLmhpZ2hsaWdodFN0cm9rZSk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyxwcm9wLmhpZ2hsaWdodExpbmV3aWR0aCk7dGhpcy5oaWdobGlnaHRfbm9kZT1jaXJjbGU7UkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsY2lyY2xlKTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpe3RoaXMub3JpZ2luYWxDb2xvcnM9e2NvbG9yczpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksaGlnaGxpZ2h0RmlsbDpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmhpZ2hsaWdodEZpbGwpfX1cbnZhciBjb2xvcnM9cHJvcC5jb2xvcnM7aWYoY29sb3JzKXtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09UkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwoe29iamVjdDp0aGlzLGNvbG9yOmNvbG9yc1tpXX0pO319XG5wcm9wLmhpZ2hsaWdodEZpbGw9UkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuaGlnaGxpZ2h0RmlsbH0pO307dGhpcy5nZXRNYXhWYWx1ZT1mdW5jdGlvbigpXG57dmFyIG1heD0wO2lmKHByb3AuZmlsbGVkJiZwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSl7dGhpcy5tYXg9UkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTFdKTt9ZWxzZXtmb3IodmFyIGRhdGFzZXQ9MCxtYXg9MDtkYXRhc2V0PHRoaXMuZGF0YS5sZW5ndGg7KytkYXRhc2V0KXt0aGlzLm1heD1tYS5tYXgodGhpcy5tYXgsUkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YVtkYXRhc2V0XSkpO319fTt0aGlzLmdldFJhZGl1cz1mdW5jdGlvbih2YWx1ZSlcbntyZXR1cm4oKHZhbHVlLXByb3Auc2NhbGVNaW4pLyh0aGlzLnNjYWxlLm1heC1wcm9wLnNjYWxlTWluKSkqdGhpcy5yYWRpdXM7fTt0aGlzLmFkZFRvb2x0aXBIb3RzcG90cz1mdW5jdGlvbigpXG57aWYocHJvcC50b29sdGlwcyYmcHJvcC50b29sdGlwcy5sZW5ndGg+MCl7aWYocHJvcC50b29sdGlwc0V2ZW50IT09J21vdXNlbW92ZScpe3Byb3AudG9vbHRpcHNFdmVudD0nY2xpY2snO31cbnZhciBncm91cD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZTonZycscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntjbGFzc05hbWU6J3JncmFwaC1yYWRhci10b29sdGlwLWhvdHNwb3RzJ319KTtmb3IodmFyIGRhdGFzZXQ9MCxzZXE9MDtkYXRhc2V0PHRoaXMuY29vcmRzMi5sZW5ndGg7KytkYXRhc2V0KXtmb3IodmFyIGk9MDtpPHRoaXMuY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7KytpKXt2YXIgY2lyY2xlPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidjaXJjbGUnLHBhcmVudDpncm91cCxhdHRyOntjeDp0aGlzLmNvb3JkczJbZGF0YXNldF1baV1bMF0sY3k6dGhpcy5jb29yZHMyW2RhdGFzZXRdW2ldWzFdLHI6cHJvcC50aWNrbWFya3NTaXplLGZpbGw6J3RyYW5zcGFyZW50JyxzdHJva2U6J3RyYW5zcGFyZW50Jywnc3Ryb2tlLXdpZHRoJzowLCdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnOnNlcX0sc3R5bGU6e2N1cnNvcjpwcm9wWyd0b29sdGlwcyddW3NlcV0/J3BvaW50ZXInOidkZWZhdWx0J319KTsoZnVuY3Rpb24oZGF0YXNldCxpbmRleCxzZXEsb2JqKVxue2lmKHByb3AudG9vbHRpcHNbc2VxXSl7Y2lyY2xlLmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LGZ1bmN0aW9uKGUpXG57dmFyIHRvb2x0aXA9UkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAnKTtpZih0b29sdGlwJiZ0b29sdGlwLl9fc2VxdWVudGlhbEluZGV4X189PT1zZXEpe3JldHVybjt9XG5SRy5TVkcudG9vbHRpcCh7b2JqZWN0Om9iaixkYXRhc2V0OmRhdGFzZXQsaW5kZXg6aW5kZXgsc2VxdWVudGlhbEluZGV4OnNlcSx0ZXh0OnByb3AudG9vbHRpcHNbc2VxXSxldmVudDplfSk7b2JqLmhpZ2hsaWdodCh0aGlzKTt9LGZhbHNlKTtpZihwcm9wLnRvb2x0aXBzRXZlbnQ9PT0nY2xpY2snKXtjaXJjbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbihlKVxue2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fSxmYWxzZSk7fX19KGRhdGFzZXQsaSxzZXErKyx0aGlzKSk7fX19fTt0aGlzLnJvdW5kUm9iaW49ZnVuY3Rpb24oKVxue307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cblJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTtyZXR1cm4gdGhpczt9O3RoaXMuZXhlYz1mdW5jdGlvbihmdW5jKVxue2Z1bmModGhpcyk7cmV0dXJuIHRoaXM7fTt0aGlzLnJlbW92ZUhpZ2hsaWdodD10aGlzLmhpZGVIaWdobGlnaHQ9ZnVuY3Rpb24oKVxue3ZhciBoaWdobGlnaHQ9UkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO2lmKGhpZ2hsaWdodCYmdGhpcy5oaWdobGlnaHRfbm9kZSl7dGhpcy5oaWdobGlnaHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd0cmFuc3BhcmVudCcpO3RoaXMuaGlnaGxpZ2h0X25vZGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCd0cmFuc3BhcmVudCcpO1JHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLG51bGwpO319O3RoaXMudHJhY2U9ZnVuY3Rpb24oKVxue3ZhciBvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZT0xLGZyYW1lcz1vcHQuZnJhbWVzfHwxMjAsb2JqPXRoaXNcbnN0ZXA9MzYwL2ZyYW1lczt0aGlzLmlzVHJhY2U9dHJ1ZTt0aGlzLmRyYXcoKTt2YXIgY2xpcFBhdGg9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5kZWZzLHR5cGU6J2NsaXBQYXRoJyxhdHRyOntpZDondHJhY2UtZWZmZWN0LWNsaXAnfX0pO2NsaXBQYXRoQXJjUGF0aD1SRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7Y3g6dGhpcy5hbmdsZXNbMF0uY3gsY3k6dGhpcy5hbmdsZXNbMF0uY3kscjp0aGlzLmFuZ2xlc1swXS5yKjIsc3RhcnQ6MCxlbmQ6MH0pO3ZhciBjbGlwUGF0aEFyYz1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OmNsaXBQYXRoLHR5cGU6J3BhdGgnLGF0dHI6e2Q6Y2xpcFBhdGhBcmNQYXRofX0pO3ZhciBpdGVyYXRvcj1mdW5jdGlvbigpXG57dmFyIHdpZHRoPShmcmFtZSsrKS9mcmFtZXMqb2JqLndpZHRoO3ZhciBkZWc9KDM2MC9mcmFtZXMpKmZyYW1lKysscmFkPShSRy5TVkcuVFJJRy5UV09QSS8zNjApKmRlZ1xuY2xpcFBhdGhBcmMuc2V0QXR0cmlidXRlKCdkJyxSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7Y3g6b2JqLmFuZ2xlc1swXS5jeCxjeTpvYmouYW5nbGVzWzBdLmN5LHI6b2JqLmFuZ2xlc1swXS5yKjIsc3RhcnQ6MCxlbmQ6cmFkfSkpO2lmKGZyYW1lPD1mcmFtZXMpe1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO31lbHNlIGlmKG9wdC5jYWxsYmFjayl7KG9wdC5jYWxsYmFjaykob2JqKTt9fTtpdGVyYXRvcigpO3JldHVybiB0aGlzO307Zm9yKGkgaW4gY29uZi5vcHRpb25zKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt0aGlzLnNldChpLGNvbmYub3B0aW9uc1tpXSk7fX19O3JldHVybiB0aGlzO30pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnJhZGFyLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///245\n");

/***/ }),
/* 246 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.Rose = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = RG.SVG.arrayClone(conf.data);\n        this.originalData = RG.SVG.arrayClone(conf.data);\n        this.type = 'rose';\n        this.angles = [];\n        this.angles2 = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n        this.max = 0;\n        this.redraw = false;\n        this.highlight_node = null;\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundGrid: true,\n            backgroundGridColor: '#ddd',\n            backgroundGridRadialsCount: null,\n            backgroundGridRadialsAngleOffset: 0,\n            backgroundGridConcentricsCount: 5,\n            backgroundGridLinewidth: 1,\n\n            strokestyle: 'white',\n            colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'],\n            colorsOpacity: 1,\n\n            textColor: 'black',\n            textFont: 'sans-serif',\n            textSize: 12,\n            textBold: false,\n            textItalic: false,\n\n            labels: [],\n            labelsFont: null,\n            labelsSize: null,\n            labelsColor: null,\n            labelsBold: null,\n            labelsItalic: null,\n            labelsRadialMargin: 10,\n            labelsAngleOffset: 0,\n\n            scaleVisible: true,\n            scaleUnitsPre: '',\n            scaleUnitsPost: '',\n            scaleMax: null,\n            scaleMin: 0,\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleRound: false,\n            scaleDecimals: 0,\n            scaleFormatter: null,\n            scaleBold: null,\n            scaleItalic: null,\n            scaleColor: null,\n            scaleSize: null,\n            scaleFont: null,\n            scaleLabelsCount: 5,\n\n            linewidth: 1,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            shadow: false,\n            shadowOffsetx: 2,\n            shadowOffsety: 2,\n            shadowBlur: 2,\n            shadowOpacity: 0.25,\n\n            margin: 0,\n            exploded: 0,\n\n            key: null,\n            keyColors: null,\n            keyOffsetx: 0,\n            keyOffsety: 0,\n            keyTextOffsetx: 0,\n            keyTextOffsety: -1,\n            keyTextSize: null,\n            keyTextBold: null,\n            keyTextItalic: null,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false,\n\n            segmentsAngleOffset: 0,\n            variant: 'normal'\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Reset the data back to the original values\n            this.data = RG.SVG.arrayClone(this.originalData);\n\n            // Reset the angles array to stop it growing\n            this.angles = [];\n\n            // Create the arrays in the angles2 array based on\n            // the data that we've been passed\n            for (var i = 0; i < this.data.length; ++i) {\n                this.angles2[i] = [];\n            }\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.graphHeight / 2 + prop.gutterTop;\n            this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            //\n            // Convert the nargin from strings to a number\n            //\n            if (typeof prop.margin === 'string' && prop.margin.match(/([0-9.]+)deg/)) {\n                prop.margin = RegExp.$1 / (180 / ma.PI);\n            }\n\n            /**\n            * Add the data to the .originalData array and work out the max value\n            * \n            * 2/5/14 Now also use this loop to ensure that the data pieces\n            *        are numbers\n            * \n            * **Is this necessary **\n            */\n            //if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n            //    this.data = [this.data];\n            //}\n\n            // Convert strings to numbers\n            for (var i = 0; i < this.data.length; ++i) {\n                if (_typeof(this.data[i]) === 'object') {\n                    for (var j = 0; j < this.data[i].length; ++j) {\n                        if (typeof this.data[i][j] === 'string') {\n                            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n                        }\n                    }\n                } else if (typeof this.data[i] === 'string') {\n                    this.data[i] = RG.SVG.stringsToNumbers(this.data[i]);\n                }\n            }\n\n            // Get the max value. This sets the maximum value on the\n            // this.max variable\n            this.getMaxValue();\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            //\n            // Get the scale\n            //\n\n            this.scale = RG.SVG.getScale({\n                object: this,\n                numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount,\n                unitsPre: prop.scaleUnitsPre,\n                unitsPost: prop.scaleUnitsPost,\n                max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max,\n                min: prop.scaleMin,\n                point: prop.scalePoint,\n                round: prop.scaleRound,\n                thousand: prop.scaleThousand,\n                decimals: prop.scaleDecimals,\n                strict: typeof prop.scaleMax === 'number',\n                formatter: prop.scaleFormatter\n            });\n\n            this.max = this.scale.max;\n\n            // Draw the background 'grid'\n            this.drawBackground();\n\n            // Draw the chart\n            this.drawRose();\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the key\n            if (typeof prop.key !== null && RG.SVG.drawKey) {\n                RG.SVG.drawKey(this);\n            } else if (!RGraph.SVG.isNull(prop.key)) {\n                alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n            }\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Create the shadow definition if needed\n            if (prop.shadow) {\n                RG.SVG.setShadow({\n                    object: this,\n                    offsetx: prop.shadowOffsetx,\n                    offsety: prop.shadowOffsety,\n                    blur: prop.shadowBlur,\n                    opacity: prop.shadowOpacity,\n                    id: 'dropShadow'\n                });\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.hideHighlight(obj);\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draw the background grid\n        //\n        this.drawBackground = function () {\n            if (prop.backgroundGrid) {\n\n                // Create the background grid group tag\n                var grid = RG.SVG.create({\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    type: 'g',\n                    attr: {\n                        className: 'rgraph_radar_grid',\n                        fill: 'rgba(0,0,0,0)',\n                        stroke: prop.backgroundGridColor\n                    }\n                });\n\n                // Draw the concentric \"rings\" grid lines that are\n                // arranged around the centerx/centery along with\n                // the radials that eminate from the center outwards\n\n                var origin = 0 - RG.SVG.TRIG.PI / 2,\n                    radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data.length,\n                    concentrics = prop.backgroundGridConcentricsCount,\n                    step = RG.SVG.TRIG.TWOPI / radials;\n\n                // First draw the radial lines that emanate from the\n                // center outwards\n                if (radials > 0) {\n                    // This draws the radials for the non-equi-angular ONLY\n                    if (prop.variant === 'non-equi-angular') {\n\n                        // Number of radials always matches the number of data pieces\n                        var radials = this.data.length;\n\n                        // Work out the total of the second part of each data bit\n                        for (var i = 0, total = 0; i < this.data.length; ++i) {\n                            total += this.data[i][1];\n                        }\n\n                        for (var i = 0, sum = 0; i < this.data.length; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + sum / total * RG.SVG.TRIG.TWOPI + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n\n                            sum += this.data[i][1];\n                        }\n\n                        // This draws the radials for normal and STACKED Rose charts\n                    } else {\n                        for (var i = 0, len = radials; i < len; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + i * step + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n                        }\n                    }\n                }\n\n                // Draw the concentrics\n                if (concentrics > 0) {\n\n                    for (var j = 1; j <= concentrics; j++) {\n\n                        // Add circle to the scene\n                        RG.SVG.create({\n                            svg: this.svg,\n                            type: 'circle',\n                            parent: grid,\n                            attr: {\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius * (j / concentrics),\n                                fill: 'transparent',\n                                stroke: prop.backgroundGridColor,\n                                'stroke-width': prop.backgroundGridLinewidth\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar\n        //\n        this.drawRose = function (opt) {\n            // Jump to another function if we're drawing a non-equi-angular chart\n            if (prop.variant === 'non-equi-angular') {\n                return this.drawRoseNonEquiAngular(opt);\n            }\n\n            var radians = RG.SVG.TRIG.TWOPI / this.data.length;\n\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radius = this.data[i] / this.scale.max * this.radius,\n                    start = i / this.data.length * RG.SVG.TRIG.TWOPI,\n                    end = i / this.data.length * RG.SVG.TRIG.TWOPI + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // Is the data piece an array or a number?\n                if (_typeof(this.data[i]) === 'object' && !RG.SVG.isNull(this.data[i])) {\n\n                    // Create a group for the parts of this segment\n                    var segment_group = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'g',\n                        parent: group,\n                        attr: {\n                            id: 'rose_' + this.id + '_segment_group_' + i\n                        }\n                    });\n\n                    for (var j = 0, sum = 0, accRadius = 0; j < this.data[i].length; ++j, ++seq) {\n\n                        sum += this.data[i][j];\n\n                        var radius = sum / this.scale.max * this.radius;\n\n                        // This (I think is the OUTER curve in the segment\n                        var arcPath = RG.SVG.TRIG.getArcPath2({\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            r: radius,\n                            start: start + prop.margin + prop.segmentsAngleOffset,\n                            end: end - prop.margin + prop.segmentsAngleOffset,\n                            anticlockwise: false\n                        });\n\n                        // The inner most segment\n                        if (j === 0) {\n                            arcPath = '{1} z'.format(arcPath);\n                        } else {\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                            arcPath = '{1} L {2} {3} {4}'.format(arcPath, this.centerx + explosion[0], this.centery + explosion[1], arcPath2);\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: segment_group,\n                            attr: {\n                                d: arcPath,\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[seq] : '',\n                                'data-index': i,\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-group': i,\n                                'data-subindex': j,\n                                'data-value': this.data[i][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': typeof prevRadius === 'number' ? prevRadius : 0,\n                                'data-sequential-index': seq\n                            }\n                        });\n\n                        // Install the tooltip listener\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        group: group,\n                                        index: index,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n\n                        // Add the segment to the angles and angles2 array\n                        this.angles.push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        var prevRadius = radius;\n                    }\n\n                    seq--;\n\n                    // A regular number\n                } else {\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-index': i,\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': prevRadius,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: index,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, this);\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar, but only the non-equi-angular variant\n        //\n        this.drawRoseNonEquiAngular = function (opt) {\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            //Loop through the data summing the second data-pieces\n            for (var i = 0, total = 0; i < this.data.length; ++i) {\n                total += parseFloat(this.data[i][1]);\n            }\n\n            // The initial angles\n            var start = 0;\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radians = this.data[i][1] / total * RG.SVG.TRIG.TWOPI,\n                    end = start + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // A stacked non-equi-angular segment\n                if (_typeof(this.data[i][0]) === 'object' && !RG.SVG.isNull(this.data[i][0])) {\n\n                    // Loop thru the set of values for this segment\n                    for (var j = 0, sum = 0; j < this.data[i][0].length; ++j, ++seq) {\n\n                        sum += this.data[i][0][j];\n\n                        // First segment in the stack or not?\n                        if (j === 0) {\n\n                            var prevRadius = 0,\n                                radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = '';\n                        } else {\n\n                            var prevRadius = radius,\n                                // The previous iterations radius\n                            radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: group,\n                            attr: {\n                                d: '{1} {2} z'.format(arcPath, arcPath2),\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-index': '[{1},{2}]'.format(i, j),\n                                'data-value': this.data[i][0][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': prevRadius,\n                                'data-sequential': seq\n                            }\n                        });\n\n                        // Add the segment to the angles array\n                        this.angles.push({\n                            object: path,\n                            index: i,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][0]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        // Install tooltips listeners\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        index: index,\n                                        group: group,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n                        var prevRadius = radius;\n                    }\n                    seq--;\n\n                    // A regular non-equi-angular segment\n                } else {\n                    var radius = this.data[i][0] / this.scale.max * this.radius;\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-index': i,\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i][0]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': 0,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, group, seq, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: seq,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, i, seq, this);\n                    }\n                }\n\n                // Increment the start angle for the next iteration of the loop\n                start += radians;\n            }\n        };\n\n        //\n        // Redraws the chart if required\n        //\n        this.redrawRose = function () {};\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the scale if required\n            if (prop.scaleVisible) {\n                for (var i = 0; i < this.scale.labels.length; ++i) {\n\n                    var x = this.centerx;\n                    var y = this.centery - this.radius / this.scale.labels.length * (i + 1);\n\n                    RG.SVG.text({\n                        object: this,\n                        svg: this.svg,\n                        parent: this.svg.all,\n                        text: this.scale.labels[i],\n                        size: prop.scaleSize || prop.textSize - 2,\n                        x: x,\n                        y: y,\n                        halign: 'center',\n                        valign: 'center',\n                        background: 'rgba(255,255,255,0.7)',\n                        padding: 2,\n                        color: prop.scaleColor || prop.textColor,\n                        bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                        italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                        font: prop.scaleFont || prop.textFont\n                    });\n                }\n\n                // Draw the zero label\n                var str = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.scale.min.toFixed(prop.scaleDecimals),\n                    prepend: prop.scaleUnitsPre,\n                    append: prop.scaleUnitsPost,\n                    point: prop.scalePoint,\n                    thousand: prop.scaleThousand,\n                    formatter: prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: str,\n                    size: prop.scaleSize || prop.textSize - 2,\n                    x: this.centerx,\n                    y: this.centery,\n                    halign: 'center',\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.scaleColor || prop.textColor,\n                    bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                    italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                    font: prop.scaleFont || prop.textFont\n                });\n            }\n\n            // Used further down\n            var halign;\n\n            // Set a default size for the labels\n            if (typeof prop.labelsSize !== 'number') {\n                prop.labelsSize = prop.textSize + 4;\n            }\n\n            // Draw the circular labels if necessary\n            for (var i = 0; i < prop.labels.length; ++i) {\n\n                if (prop.variant === 'non-equi-angular') {\n                    var angle = (this.angles2[i][0].end - this.angles2[i][0].start) / 2 + this.angles2[i][0].start - RG.SVG.TRIG.HALFPI;\n                } else {\n                    var angle = RG.SVG.TRIG.TWOPI / prop.labels.length * i - RG.SVG.TRIG.HALFPI + prop.labelsAngleOffset + (this.angles2[i][0].end - this.angles2[i][0].start) / 2;\n                }\n\n                var endpoint = RG.SVG.TRIG.getRadiusEndPoint({\n                    r: this.radius + prop.labelsRadialMargin,\n                    angle: angle\n                });\n\n                // Accommodate the explosion for the label\n                var explosion = this.getExploded({\n                    index: i,\n                    start: this.angles2[i][0].start - RG.SVG.TRIG.HALFPI,\n                    end: this.angles2[i][0].end - RG.SVG.TRIG.HALFPI\n                });\n\n                endpoint[0] += this.centerx + explosion[0];\n                endpoint[1] += this.centery + explosion[1];\n\n                // Do the alignment based on which quadrant the label is in\n                if (ma.round(endpoint[0]) > this.centerx) {\n                    halign = 'left';\n                } else if (ma.round(endpoint[0]) === this.centerx) {\n                    halign = 'center';\n                } else {\n                    halign = 'right';\n                }\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: typeof prop.labels[i] === 'string' ? prop.labels[i] : '',\n                    size: prop.labelsSize,\n                    x: endpoint[0],\n                    y: endpoint[1],\n                    halign: halign,\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.labelsColor || prop.textColor,\n                    bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold,\n                    italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic,\n                    font: prop.labelsFont || prop.textFont\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        * \n        * @param object circle The circle to highlight\n        */\n        this.highlight = function (path) {\n            var path = path.getAttribute('d');\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                parent: this.svg.all,\n                type: 'path',\n                attr: {\n                    d: path,\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            if (prop.tooltipsEvent === 'mousemove') {\n                highlight.addEventListener('mouseout', function (e) {\n                    highlight.parentNode.removeChild(highlight);\n                    RG.SVG.hideTooltip();\n\n                    RG.SVG.REG.set('highlight', null);\n                }, false);\n            }\n\n            // Store the highlight rect in the registry so\n            // it can be cleared later\n            RG.SVG.REG.set('highlight', highlight);\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorRadial({\n                        object: this,\n                        color: colors[i]\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorRadial({\n                object: this,\n                color: prop.highlightFill\n            });\n        };\n\n        //\n        // Get the maximum value\n        //\n        this.getMaxValue = function () {\n            var max = 0;\n\n            if (prop.variant === 'non-equi-angular') {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i][0] === 'number') {\n                            max = ma.max(max, this.data[i][0]);\n                        } else if (_typeof(this.data[i][0]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i][0]));\n                        }\n                    }\n                }\n            } else {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i] === 'number') {\n                            max = ma.max(max, this.data[i]);\n                        } else if (_typeof(this.data[i]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i]));\n                        }\n                    }\n                }\n            }\n\n            this.max = max;\n        };\n\n        //\n        // Gets the radius of a value\n        //\n        //@param number The value to get the radius for\n        //\n        this.getRadius = function (value) {\n            return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n        };\n\n        //\n        // A roundRobin effect for the Pie chart\n        //\n        // @param object    Options for the effect\n        // @param function  An optional callback function to call when\n        //                  the effect is complete\n        //\n        this.roundRobin = function () {};\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        * \n        * @param string   type The type of even to add\n        * @param function func \n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        // \n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Removes the tooltip highlight from the chart\n        //\n        this.removeHighlight = this.hideHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight && this.highlight_node) {\n                this.highlight_node.setAttribute('fill', 'transparent');\n                this.highlight_node.setAttribute('stroke', 'transparent');\n\n                RG.SVG.REG.set('highlight', null);\n            }\n        };\n\n        //\n        // Returns the exploded X/Y for a given explosion\n        //\n        //TODO Needs updating to current coding style, including converting\n        //     arguments to an object\n        //\n        this.getExploded = function (opt) {\n            var index = opt.index,\n                start = opt.start,\n                end = opt.end,\n                exploded = prop.exploded,\n                explodedX,\n                explodedY;\n\n            /**\n            * Retrieve any exploded - the exploded can be an array of numbers or a single number\n            * (which is applied to all segments)\n            */\n            if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && typeof exploded[index] === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded[index];\n                explodedY = ma.sin((end - start) / 2 + start) * exploded[index];\n            } else if (typeof exploded === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded;\n                explodedY = ma.sin((end - start) / 2 + start) * exploded;\n            } else {\n                explodedX = 0;\n                explodedY = 0;\n            }\n\n            return [explodedX, explodedY];\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnJvc2UuanM/YmY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2ZXJzaW9uOiAyMDE3LTA1LTA4XG4gICAgLyoqXG4gICAgKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4gICAgKiB8IFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBSR3JhcGggcGFja2FnZSAtIHlvdSBjYW4gbGVhcm4gbW9yZSBhdDogICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnJncmFwaC5uZXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiB8IFJHcmFwaCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgT3BlbiBTb3VyY2UgTUlUIGxpY2Vuc2UuIFRoYXQgbWVhbnMgdGhhdCBpdCdzICAgICB8XG4gICAgKiB8IHRvdGFsbHkgZnJlZSB0byB1c2UhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4gICAgKi9cblxuICAgIFJHcmFwaCAgICAgPSB3aW5kb3cuUkdyYXBoIHx8IHtpc1JHcmFwaDogdHJ1ZX07XG4gICAgUkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307XG5cbi8vIE1vZHVsZSBwYXR0ZXJuXG4oZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpXG57XG4gICAgdmFyIFJHICA9IFJHcmFwaCxcbiAgICAgICAgdWEgID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgbWEgID0gTWF0aCxcbiAgICAgICAgd2luID0gd2luZG93LFxuICAgICAgICBkb2MgPSBkb2N1bWVudDtcblxuXG5cbiAgICBSRy5TVkcuUm9zZSA9IGZ1bmN0aW9uIChjb25mKVxuICAgIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSBzZXR0ZXIgdGhhdCB0aGUgY29uc3RydWN0b3IgdXNlcyAoYXQgdGhlIGVuZClcbiAgICAgICAgLy8gdG8gc2V0IGFsbCBvZiB0aGUgcHJvcGVydGllc1xuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gc3RyaW5nIG5hbWUgIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgLy8gQHBhcmFtIHN0cmluZyB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0b1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICBhcmd1bWVudHNbMF1baV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICA9IHJldC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuYW1lICA9IHJldC5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmV0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgPSBjb25mLmlkO1xuICAgICAgICB0aGlzLnVpZCAgICAgICAgICAgICA9IFJHLlNWRy5jcmVhdGVVSUQoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5zdmcgICAgICAgICAgICAgPSBSRy5TVkcuY3JlYXRlU1ZHKHtjb250YWluZXI6IHRoaXMuY29udGFpbmVyfSk7XG4gICAgICAgIHRoaXMuaXNSR3JhcGggICAgICAgID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53aWR0aCAgICAgICAgICAgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgICAgICAgICAgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgICAgIHRoaXMuZGF0YSAgICAgICAgICAgID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERhdGEgICAgPSBSRy5TVkcuYXJyYXlDbG9uZShjb25mLmRhdGEpO1xuICAgICAgICB0aGlzLnR5cGUgICAgICAgICAgICA9ICdyb3NlJztcbiAgICAgICAgdGhpcy5hbmdsZXMgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5hbmdsZXMyICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xvcnNQYXJzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyAgPSB7fTtcbiAgICAgICAgdGhpcy5ncmFkaWVudENvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLm5vZGVzICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnNoYWRvd05vZGVzICAgICA9IFtdO1xuICAgICAgICB0aGlzLm1heCAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMucmVkcmF3ICAgICAgICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0X25vZGUgID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0aGlzIG9iamVjdCB0byB0aGUgT2JqZWN0UmVnaXN0cnlcbiAgICAgICAgUkcuU1ZHLk9SLmFkZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgRElWIGNvbnRhaW5lciB0byBiZSBpbmxpbmUtYmxvY2tcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBcbiAgICAgICAgXG5cblxuXG5cblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPVxuICAgICAgICB7XG4gICAgICAgICAgICBjZW50ZXJ4OiBudWxsLFxuICAgICAgICAgICAgY2VudGVyeTogbnVsbCxcbiAgICAgICAgICAgIHJhZGl1czogIG51bGwsXG5cbiAgICAgICAgICAgIGd1dHRlckxlZnQ6ICAgIDM1LFxuICAgICAgICAgICAgZ3V0dGVyUmlnaHQ6ICAgMzUsXG4gICAgICAgICAgICBndXR0ZXJUb3A6ICAgICAzNSxcbiAgICAgICAgICAgIGd1dHRlckJvdHRvbTogIDM1LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBiYWNrZ3JvdW5kR3JpZDogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRHcmlkQ29sb3I6ICAgICAgICAgICAgJyNkZGQnLFxuICAgICAgICAgICAgYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQ6ICAgICBudWxsLFxuICAgICAgICAgICAgYmFja2dyb3VuZEdyaWRSYWRpYWxzQW5nbGVPZmZzZXQ6IDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNzQ291bnQ6IDUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDogICAgICAgIDEsXG5cbiAgICAgICAgICAgIHN0cm9rZXN0eWxlOiAnd2hpdGUnLFxuICAgICAgICAgICAgY29sb3JzOiBbXG4gICAgICAgICAgICAgICAgJ3JlZCcsICdibGFjaycsICdvcmFuZ2UnLCAnZ3JlZW4nLCAnIzZmZicsICcjY2NjJyxcbiAgICAgICAgICAgICAgICAncGluaycsICdvcmFuZ2UnLCAnY3lhbicsICdtYXJvb24nLCAnb2xpdmUnLCAndGVhbCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBjb2xvcnNPcGFjaXR5OiAxLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICAnYmxhY2snLFxuICAgICAgICAgICAgdGV4dEZvbnQ6ICAgJ3NhbnMtc2VyaWYnLFxuICAgICAgICAgICAgdGV4dFNpemU6ICAgMTIsXG4gICAgICAgICAgICB0ZXh0Qm9sZDogICBmYWxzZSxcbiAgICAgICAgICAgIHRleHRJdGFsaWM6IGZhbHNlLFxuXG4gICAgICAgICAgICBsYWJlbHM6ICAgICAgIFtdLFxuICAgICAgICAgICAgbGFiZWxzRm9udDogICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzU2l6ZTogICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ29sb3I6ICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQm9sZDogICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzSXRhbGljOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzUmFkaWFsTWFyZ2luOiAxMCxcbiAgICAgICAgICAgIGxhYmVsc0FuZ2xlT2Zmc2V0OiAwLFxuXG4gICAgICAgICAgICBzY2FsZVZpc2libGU6ICAgICB0cnVlLFxuICAgICAgICAgICAgc2NhbGVVbml0c1ByZTogICAgJycsXG4gICAgICAgICAgICBzY2FsZVVuaXRzUG9zdDogICAnJyxcbiAgICAgICAgICAgIHNjYWxlTWF4OiAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzY2FsZU1pbjogICAgICAgICAwLFxuICAgICAgICAgICAgc2NhbGVQb2ludDogICAgICAgJy4nLFxuICAgICAgICAgICAgc2NhbGVUaG91c2FuZDogICAgJywnLFxuICAgICAgICAgICAgc2NhbGVSb3VuZDogICAgICAgZmFsc2UsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWxzOiAgICAwLFxuICAgICAgICAgICAgc2NhbGVGb3JtYXR0ZXI6ICAgbnVsbCxcbiAgICAgICAgICAgIHNjYWxlQm9sZDogICAgICAgIG51bGwsXG4gICAgICAgICAgICBzY2FsZUl0YWxpYzogICAgICBudWxsLFxuICAgICAgICAgICAgc2NhbGVDb2xvcjogICAgICAgbnVsbCxcbiAgICAgICAgICAgIHNjYWxlU2l6ZTogICAgICAgIG51bGwsXG4gICAgICAgICAgICBzY2FsZUZvbnQ6ICAgICAgICBudWxsLFxuICAgICAgICAgICAgc2NhbGVMYWJlbHNDb3VudDogNSxcblxuICAgICAgICAgICAgbGluZXdpZHRoOiAxLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0b29sdGlwczogICAgICAgICBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcHNPdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBzRWZmZWN0OiAgICdmYWRlJyxcbiAgICAgICAgICAgIHRvb2x0aXBzQ3NzQ2xhc3M6ICdSR3JhcGhfdG9vbHRpcCcsXG4gICAgICAgICAgICB0b29sdGlwc0V2ZW50OiAgICAnY2xpY2snLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLFxuICAgICAgICAgICAgaGlnaGxpZ2h0TGluZXdpZHRoOiAxLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICB0aXRsZVNpemU6IDE2LFxuICAgICAgICAgICAgdGl0bGVYOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVZOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVIYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgdGl0bGVWYWxpZ246IG51bGwsXG4gICAgICAgICAgICB0aXRsZUNvbG9yOiAgJ2JsYWNrJyxcbiAgICAgICAgICAgIHRpdGxlRm9udDogICBudWxsLFxuICAgICAgICAgICAgdGl0bGVCb2xkOiAgIGZhbHNlLFxuICAgICAgICAgICAgdGl0bGVJdGFsaWM6IGZhbHNlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlOiAnJyxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVTaXplOiAxMCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVYOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZVk6IG51bGwsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlSGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVWYWxpZ246IG51bGwsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlQ29sb3I6ICAnI2FhYScsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlRm9udDogICBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZUJvbGQ6ICAgZmFsc2UsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlSXRhbGljOiBmYWxzZSxcblxuICAgICAgICAgICAgc2hhZG93OiBmYWxzZSxcbiAgICAgICAgICAgIHNoYWRvd09mZnNldHg6IDIsXG4gICAgICAgICAgICBzaGFkb3dPZmZzZXR5OiAyLFxuICAgICAgICAgICAgc2hhZG93Qmx1cjogMixcbiAgICAgICAgICAgIHNoYWRvd09wYWNpdHk6IDAuMjUsXG5cbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIGV4cGxvZGVkOiAwLFxuXG5cbiAgICAgICAgICAgIGtleTogICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAga2V5Q29sb3JzOiAgICAgIG51bGwsXG4gICAgICAgICAgICBrZXlPZmZzZXR4OiAgICAgMCxcbiAgICAgICAgICAgIGtleU9mZnNldHk6ICAgICAwLFxuICAgICAgICAgICAga2V5VGV4dE9mZnNldHg6IDAsXG4gICAgICAgICAgICBrZXlUZXh0T2Zmc2V0eTogLTEsXG4gICAgICAgICAgICBrZXlUZXh0U2l6ZTogICAgbnVsbCxcbiAgICAgICAgICAgIGtleVRleHRCb2xkOiAgICBudWxsLFxuICAgICAgICAgICAga2V5VGV4dEl0YWxpYzogIG51bGwsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uWDogICAgICAgbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uWTogICAgICAgbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uSHJlZjogICAgbnVsbCwvLyBEZWZhdWx0IGlzIHNldCBpbiBSR3JhcGguc3ZnLmNvbW1vbi5jb3JlLmpzXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkhhbGlnbjogICdyaWdodCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblZhbGlnbjogICdib3R0b20nLFxuICAgICAgICAgICAgYXR0cmlidXRpb25TaXplOiAgICA3LFxuICAgICAgICAgICAgYXR0cmlidXRpb25Db2xvcjogICAnZ3JheScsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkZvbnQ6ICAgICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uSXRhbGljOiAgZmFsc2UsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkJvbGQ6ICAgIGZhbHNlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZWdtZW50c0FuZ2xlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgdmFyaWFudDogJ25vcm1hbCdcbiAgICAgICAgfTtcblxuXG5cblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogXCJEZWNvcmF0ZVwiIHRoZSBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJpYyBlZmZlY3RzIGlmIHRoZSBlZmZlY3RzIGxpYnJhcnkgaGFzIGJlZW4gaW5jbHVkZWRcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKFJHLlNWRy5GWCAmJiB0eXBlb2YgUkcuU1ZHLkZYLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7XG4gICAgICAgIH1cblxuXG5cblxuICAgICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcztcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkcmF3IG1ldGhvZCBkcmF3cyB0aGUgQmFyIGNoYXJ0XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGJlZm9yZWRyYXcgZXZlbnRcbiAgICAgICAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRhdGEgYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBSRy5TVkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsRGF0YSk7XG5cblxuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgYW5nbGVzIGFycmF5IHRvIHN0b3AgaXQgZ3Jvd2luZ1xuICAgICAgICAgICAgdGhpcy5hbmdsZXMgID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBhcnJheXMgaW4gdGhlIGFuZ2xlczIgYXJyYXkgYmFzZWQgb25cbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIHRoYXQgd2UndmUgYmVlbiBwYXNzZWRcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlczJbaV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuXG5cblxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGRlZnMgdGFnIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7XG5cblxuXG5cbiAgICAgICAgICAgIHRoaXMuZ3JhcGhXaWR0aCAgPSB0aGlzLndpZHRoIC0gcHJvcC5ndXR0ZXJMZWZ0IC0gcHJvcC5ndXR0ZXJSaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207XG5cblxuXG4gICAgICAgICAgICAvLyBXb3JrIG91dCB0aGUgY2VudGVyIHBvaW50XG4gICAgICAgICAgICB0aGlzLmNlbnRlcnggPSAodGhpcy5ncmFwaFdpZHRoIC8gMikgKyBwcm9wLmd1dHRlckxlZnQ7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcnkgPSAodGhpcy5ncmFwaEhlaWdodCAvIDIpICsgcHJvcC5ndXR0ZXJUb3A7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyAgPSBtYS5taW4odGhpcy5ncmFwaFdpZHRoLCB0aGlzLmdyYXBoSGVpZ2h0KSAvIDI7XG5cblxuXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgY2FsY3VsYXRlZCBjZW50ZXJ4L3kvcmFkaXVzXG4gICAgICAgICAgICB0aGlzLmNlbnRlcnggPSB0eXBlb2YgcHJvcC5jZW50ZXJ4ID09PSAnbnVtYmVyJyA/IHByb3AuY2VudGVyeCA6IHRoaXMuY2VudGVyeDtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyeSA9IHR5cGVvZiBwcm9wLmNlbnRlcnkgPT09ICdudW1iZXInID8gcHJvcC5jZW50ZXJ5IDogdGhpcy5jZW50ZXJ5O1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgID0gdHlwZW9mIHByb3AucmFkaXVzICA9PT0gJ251bWJlcicgPyBwcm9wLnJhZGl1cyAgOiB0aGlzLnJhZGl1cztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBjZW50ZXJ4L2NlbnRlcnkvcmFkaXVzIHRvIGJlIGEgcGx1cy9taW51c1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcC5yYWRpdXMgID09PSAnc3RyaW5nJyAmJiBwcm9wLnJhZGl1cy5tYXRjaCgvXlxcK3wtXFxkKyQvKSApICB0aGlzLnJhZGl1cyAgKz0gcGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ3N0cmluZycgJiYgcHJvcC5jZW50ZXJ4Lm1hdGNoKC9eXFwrfC1cXGQrJC8pICkgdGhpcy5jZW50ZXJ5ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ4KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcC5jZW50ZXJ5ID09PSAnc3RyaW5nJyAmJiBwcm9wLmNlbnRlcnkubWF0Y2goL15cXCt8LVxcZCskLykgKSB0aGlzLmNlbnRlcnggKz0gcGFyc2VGbG9hdChwcm9wLmNlbnRlcnkpO1xuXG5cblxuXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBuYXJnaW4gZnJvbSBzdHJpbmdzIHRvIGEgbnVtYmVyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wLm1hcmdpbiA9PT0gJ3N0cmluZycgJiYgcHJvcC5tYXJnaW4ubWF0Y2goLyhbMC05Ll0rKWRlZy8pKSB7XG4gICAgICAgICAgICAgICAgcHJvcC5tYXJnaW4gPSBSZWdFeHAuJDEgLyAoMTgwIC8gbWEuUEkpO1xuICAgICAgICAgICAgfVxuXG5cblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQWRkIHRoZSBkYXRhIHRvIHRoZSAub3JpZ2luYWxEYXRhIGFycmF5IGFuZCB3b3JrIG91dCB0aGUgbWF4IHZhbHVlXG4gICAgICAgICAgICAqIFxuICAgICAgICAgICAgKiAyLzUvMTQgTm93IGFsc28gdXNlIHRoaXMgbG9vcCB0byBlbnN1cmUgdGhhdCB0aGUgZGF0YSBwaWVjZXNcbiAgICAgICAgICAgICogICAgICAgIGFyZSBudW1iZXJzXG4gICAgICAgICAgICAqIFxuICAgICAgICAgICAgKiAqKklzIHRoaXMgbmVjZXNzYXJ5ICoqXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy9pZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhKSAmJiAodHlwZW9mIHRoaXMuZGF0YVswXSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMuZGF0YVswXSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAvLyAgICB0aGlzLmRhdGEgPSBbdGhpcy5kYXRhXTtcbiAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgdG8gbnVtYmVyc1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8dGhpcy5kYXRhW2ldLmxlbmd0aDsgKytqKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV1bal0gPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyh0aGlzLmRhdGFbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyh0aGlzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgbWF4IHZhbHVlLiBUaGlzIHNldHMgdGhlIG1heGltdW0gdmFsdWUgb24gdGhlXG4gICAgICAgICAgICAvLyB0aGlzLm1heCB2YXJpYWJsZVxuICAgICAgICAgICAgdGhpcy5nZXRNYXhWYWx1ZSgpO1xuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgY29sb3JzIGZvciBncmFkaWVudHNcbiAgICAgICAgICAgIFJHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoe29iamVjdDp0aGlzfSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNjYWxlXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gUkcuU1ZHLmdldFNjYWxlKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6ICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgbnVtbGFiZWxzOiB0eXBlb2YgcHJvcC5zY2FsZUxhYmVsc0NvdW50ID09PSAnbnVtYmVyJyA/IHByb3Auc2NhbGVMYWJlbHNDb3VudCA6IHByb3AuYmFja2dyb3VuZEdyaWRDb25jZW50cmljQ291bnQsXG4gICAgICAgICAgICAgICAgdW5pdHNQcmU6ICBwcm9wLnNjYWxlVW5pdHNQcmUsXG4gICAgICAgICAgICAgICAgdW5pdHNQb3N0OiBwcm9wLnNjYWxlVW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgIG1heDogICAgICAgdHlwZW9mIHByb3Auc2NhbGVNYXggPT09ICdudW1iZXInID8gcHJvcC5zY2FsZU1heCA6IHRoaXMubWF4LFxuICAgICAgICAgICAgICAgIG1pbjogICAgICAgcHJvcC5zY2FsZU1pbixcbiAgICAgICAgICAgICAgICBwb2ludDogICAgIHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICByb3VuZDogICAgIHByb3Auc2NhbGVSb3VuZCxcbiAgICAgICAgICAgICAgICB0aG91c2FuZDogIHByb3Auc2NhbGVUaG91c2FuZCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogIHByb3Auc2NhbGVEZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6ICAgIHR5cGVvZiBwcm9wLnNjYWxlTWF4ID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHByb3Auc2NhbGVGb3JtYXR0ZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMuc2NhbGUubWF4O1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgYmFja2dyb3VuZCAnZ3JpZCdcbiAgICAgICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcblxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGNoYXJ0XG4gICAgICAgICAgICB0aGlzLmRyYXdSb3NlKCk7XG5cblxuXG5cblxuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBsYWJlbHNcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscygpO1xuXG5cblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgdGl0bGUgYW5kIHN1YnRpdGxlXG4gICAgICAgICAgICBSRy5TVkcuZHJhd1RpdGxlKHRoaXMpO1xuXG5cblxuXG5cblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUga2V5XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3Aua2V5ICE9PSBudWxsICYmIFJHLlNWRy5kcmF3S2V5KSB7XG4gICAgICAgICAgICAgICAgUkcuU1ZHLmRyYXdLZXkodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFSR3JhcGguU1ZHLmlzTnVsbChwcm9wLmtleSkpIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGF0dHJpYnV0aW9uIGxpbmsuIElmIHlvdSdyZSBhZGRpbmcgdGhpcyBlbHNld2hlcmUgb24geW91ciBwYWdlL3NpdGVcbiAgICAgICAgICAgIC8vIGFuZCB5b3UgZG9uJ3Qgd2FudCBpdCBkaXNwbGF5ZWQgdGhlbiB0aGVyZSBhcmUgb3B0aW9ucyBhdmFpbGFibGUgdG8gbm90XG4gICAgICAgICAgICAvLyBzaG93IGl0LlxuICAgICAgICAgICAgUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNoYWRvdyBkZWZpbml0aW9uIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHByb3Auc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgUkcuU1ZHLnNldFNoYWRvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldHg6IHByb3Auc2hhZG93T2Zmc2V0eCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0eTogcHJvcC5zaGFkb3dPZmZzZXR5LFxuICAgICAgICAgICAgICAgICAgICBibHVyOiAgICBwcm9wLnNoYWRvd0JsdXIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHByb3Auc2hhZG93T3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICAgICAgJ2Ryb3BTaGFkb3cnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2xlYXJzIHRoZSBoaWdobGlnaHQgaWZcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFueS4gTXVzdCBiZSBNT1VTRURPV04gKGllIGJlZm9yZSB0aGUgY2xpY2sgZXZlbnQpXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgICAgICAgIGRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iai5oaWRlSGlnaGxpZ2h0KG9iaik7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cblxuXG4gICAgICAgICAgICAvLyBGaXJlIHRoZSBkcmF3IGV2ZW50XG4gICAgICAgICAgICBSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtcblxuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRHJhdyB0aGUgYmFja2dyb3VuZCBncmlkXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocHJvcC5iYWNrZ3JvdW5kR3JpZCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBiYWNrZ3JvdW5kIGdyaWQgZ3JvdXAgdGFnXG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncmdyYXBoX3JhZGFyX2dyaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgY29uY2VudHJpYyBcInJpbmdzXCIgZ3JpZCBsaW5lcyB0aGF0IGFyZVxuICAgICAgICAgICAgICAgIC8vIGFycmFuZ2VkIGFyb3VuZCB0aGUgY2VudGVyeC9jZW50ZXJ5IGFsb25nIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmFkaWFscyB0aGF0IGVtaW5hdGUgZnJvbSB0aGUgY2VudGVyIG91dHdhcmRzXG5cbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luICAgICAgPSAwIC0gKFJHLlNWRy5UUklHLlBJIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIHJhZGlhbHMgICAgID0gKHR5cGVvZiBwcm9wLmJhY2tncm91bmRHcmlkUmFkaWFsc0NvdW50ID09PSAnbnVtYmVyJyA/IHByb3AuYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQgOiAgdGhpcy5kYXRhLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIGNvbmNlbnRyaWNzID0gcHJvcC5iYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNzQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgICAgICAgID0gUkcuU1ZHLlRSSUcuVFdPUEkgLyByYWRpYWxzO1xuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBkcmF3IHRoZSByYWRpYWwgbGluZXMgdGhhdCBlbWFuYXRlIGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2VudGVyIG91dHdhcmRzXG4gICAgICAgICAgICAgICAgaWYgKHJhZGlhbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZHJhd3MgdGhlIHJhZGlhbHMgZm9yIHRoZSBub24tZXF1aS1hbmd1bGFyIE9OTFlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiByYWRpYWxzIGFsd2F5cyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgZGF0YSBwaWVjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaWFscyA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIHRvdGFsIG9mIHRoZSBzZWNvbmQgcGFydCBvZiBlYWNoIGRhdGEgYml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLHRvdGFsPTA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuZGF0YVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsc3VtPTA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogb3JpZ2luICsgKCAoc3VtIC8gdG90YWwpICogUkcuU1ZHLlRSSUcuVFdPUEkpICsgcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNBbmdsZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gJ00gezF9IHsyfSBMIHszfSB7NH0nLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogc3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmJhY2tncm91bmRHcmlkTGluZXdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHRoaXMuZGF0YVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZHJhd3MgdGhlIHJhZGlhbHMgZm9yIG5vcm1hbCBhbmQgU1RBQ0tFRCBSb3NlIGNoYXJ0c1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLGxlbj1yYWRpYWxzOyBpPGxlbjsgKytpKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBSRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogb3JpZ2luICsgKGkgKiBzdGVwKSArIHByb3AuYmFja2dyb3VuZEdyaWRSYWRpYWxzQW5nbGVPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICdNIHsxfSB7Mn0gTCB7M30gezR9Jy5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBjb25jZW50cmljc1xuICAgICAgICAgICAgICAgIGlmIChjb25jZW50cmljcyA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTE7IGo8PWNvbmNlbnRyaWNzOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNpcmNsZSB0byB0aGUgc2NlbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMgKiAoai9jb25jZW50cmljcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcC5iYWNrZ3JvdW5kR3JpZExpbmV3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRHJhd3MgdGhlIHJhZGFyXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhd1Jvc2UgPSBmdW5jdGlvbiAob3B0KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBKdW1wIHRvIGFub3RoZXIgZnVuY3Rpb24gaWYgd2UncmUgZHJhd2luZyBhIG5vbi1lcXVpLWFuZ3VsYXIgY2hhcnRcbiAgICAgICAgICAgIGlmIChwcm9wLnZhcmlhbnQgPT09ICdub24tZXF1aS1hbmd1bGFyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdSb3NlTm9uRXF1aUFuZ3VsYXIob3B0KTtcbiAgICAgICAgICAgIH1cblxuXG5cblxuXG5cbiAgICAgICAgICAgIHZhciByYWRpYW5zID0gUkcuU1ZHLlRSSUcuVFdPUEkgLyB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgIHR5cGU6J2cnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZ3JhcGhfcm9zZV9zZWdtZW50c18nICsgdGhpcy5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIE5vdyBsb29wIHRocnUgdGhlIGRhdGFcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCxzZXE9MDsgaTx0aGlzLmRhdGEubGVuZ3RoOyArK2ksKytzZXEpIHtcblxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSAodGhpcy5kYXRhW2ldIC8gdGhpcy5zY2FsZS5tYXgpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICA9IChpIC8gdGhpcy5kYXRhLmxlbmd0aCkgKiBSRy5TVkcuVFJJRy5UV09QSSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgID0gKChpIC8gdGhpcy5kYXRhLmxlbmd0aCkgKiBSRy5TVkcuVFJJRy5UV09QSSkgKyByYWRpYW5zO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBleHBsb2RlZCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBleHBsb3Npb24gPSB0aGlzLmdldEV4cGxvZGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCAtIFJHLlNWRy5UUklHLkhBTEZQSSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQgLSBSRy5TVkcuVFJJRy5IQUxGUElcbiAgICAgICAgICAgICAgICB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBkYXRhIHBpZWNlIGFuIGFycmF5IG9yIGEgbnVtYmVyP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnb2JqZWN0JyAmJiAhUkcuU1ZHLmlzTnVsbCh0aGlzLmRhdGFbaV0pKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgcGFydHMgb2YgdGhpcyBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50X2dyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvc2VfJyArIHRoaXMuaWQgKyAnX3NlZ21lbnRfZ3JvdXBfJyArIGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MCxzdW09MCxhY2NSYWRpdXM9MDsgajx0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2osKytzZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5kYXRhW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gKHN1bSAvIHRoaXMuc2NhbGUubWF4KSAqIHRoaXMucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIChJIHRoaW5rIGlzIHRoZSBPVVRFUiBjdXJ2ZSBpbiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIG1vc3Qgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNQYXRoID0gJ3sxfSB6Jy5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmNQYXRoMiA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogcHJldlJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNQYXRoID0gJ3sxfSBMIHsyfSB7M30gezR9Jy5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1BhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNQYXRoMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBzZWdtZW50X2dyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogYXJjUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbc2VxXSAgOiBwcm9wLmNvbG9yc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuY29sb3JzT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10b29sdGlwJzogKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHMubGVuZ3RoKSA/IHByb3AudG9vbHRpcHNbc2VxXSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcngnOiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcnknOiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWdyb3VwJzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3ViaW5kZXgnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS12YWx1ZSc6IHRoaXMuZGF0YVtpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3RhcnQtYW5nbGUnOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZW5kLWFuZ2xlJzogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1yYWRpdXMnOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXJhZGl1cy1pbm5lcic6IHR5cGVvZiBwcmV2UmFkaXVzID09PSAnbnVtYmVyJyA/IHByZXZSYWRpdXMgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1zZXF1ZW50aWFsLWluZGV4Jzogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCB0aGUgdG9vbHRpcCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwc1tzZXFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSB0b29sdGlwc0V2ZW50IGRlZmF1bHQgdG8gY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ICE9PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnRvb2x0aXBzRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpbmRleCwgZ3JvdXAsIHNlcSwgb2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVIaWdobGlnaHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSByZWN0IHRoYXQgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YWxsIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNoYW5nZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShqLCBpLCBzZXEsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50IHRvIHRoZSBhbmdsZXMgYW5kIGFuZ2xlczIgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cy1pbm5lcic6IHByZXZSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGF0YVtpXVtqXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzMltpXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyYWRpdXMtaW5uZXInOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bal1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAgICAgc2VxLS07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBBIHJlZ3VsYXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJjUGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcjogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICsgcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAnezF9IHonLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJjUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbaV0gIDogcHJvcC5jb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuY29sb3JzT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHByb3Auc3Ryb2tlc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvb2x0aXAnOiAoIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGgpID8gcHJvcC50b29sdGlwc1tpXSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWluZGV4JzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jZW50ZXJ4JzogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcnknOiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3RhcnQtYW5nbGUnOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1lbmQtYW5nbGUnOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmFkaXVzJzogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwnOiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50IHRvIHRoZSBhbmdsZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMyW2ldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyYWRpdXMtaW5uZXInOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGF0YVtpXVtqXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwcyAmJiBwcm9wLnRvb2x0aXBzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgdG9vbHRpcHNFdmVudCBkZWZhdWx0IHRvIGNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ICE9PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AudG9vbHRpcHNFdmVudCA9ICdjbGljayc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGluZGV4LCBvYmopXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgcmVjdCB0aGF0IGhhcyBiZWVuIGNsaWNrZWQgb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgdGhlIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2hhbmdlcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9KGksIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERyYXdzIHRoZSByYWRhciwgYnV0IG9ubHkgdGhlIG5vbi1lcXVpLWFuZ3VsYXIgdmFyaWFudFxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmRyYXdSb3NlTm9uRXF1aUFuZ3VsYXIgPSBmdW5jdGlvbiAob3B0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgIHR5cGU6J2cnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZ3JhcGhfcm9zZV9zZWdtZW50c18nICsgdGhpcy5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL0xvb3AgdGhyb3VnaCB0aGUgZGF0YSBzdW1taW5nIHRoZSBzZWNvbmQgZGF0YS1waWVjZXNcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCx0b3RhbD0wOyBpPHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IHBhcnNlRmxvYXQodGhpcy5kYXRhW2ldWzFdKTtcbiAgICAgICAgICAgIH1cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAvLyBUaGUgaW5pdGlhbCBhbmdsZXNcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG5cblxuXG5cbiAgICAgICAgICAgIC8vIE5vdyBsb29wIHRocnUgdGhlIGRhdGFcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCxzZXE9MDsgaTx0aGlzLmRhdGEubGVuZ3RoOyArK2ksKytzZXEpIHtcblxuICAgICAgICAgICAgICAgIHZhciByYWRpYW5zID0gKHRoaXMuZGF0YVtpXVsxXSAvIHRvdGFsKSAqIFJHLlNWRy5UUklHLlRXT1BJLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICAgID0gc3RhcnQgKyByYWRpYW5zO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBleHBsb2RlZCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBleHBsb3Npb24gPSB0aGlzLmdldEV4cGxvZGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCAtIFJHLlNWRy5UUklHLkhBTEZQSSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQgLSBSRy5TVkcuVFJJRy5IQUxGUElcbiAgICAgICAgICAgICAgICB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBBIHN0YWNrZWQgbm9uLWVxdWktYW5ndWxhciBzZWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV1bMF0gPT09ICdvYmplY3QnICYmICFSRy5TVkcuaXNOdWxsKHRoaXMuZGF0YVtpXVswXSkpIHtcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJ1IHRoZSBzZXQgb2YgdmFsdWVzIGZvciB0aGlzIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wLHN1bT0wOyBqPHRoaXMuZGF0YVtpXVswXS5sZW5ndGg7ICsraiwrK3NlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5kYXRhW2ldWzBdW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBzZWdtZW50IGluIHRoZSBzdGFjayBvciBub3Q/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzICAgICA9IChzdW0gLyB0aGlzLnNjYWxlLm1heCkgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJjUGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQgLSBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJjUGF0aDIgICA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gcmFkaXVzLCAvLyBUaGUgcHJldmlvdXMgaXRlcmF0aW9ucyByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzICAgICA9IChzdW0gLyB0aGlzLnNjYWxlLm1heCkgKiB0aGlzLnJhZGl1cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmNQYXRoID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCArIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGgyID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZW5kIC0gcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAnezF9IHsyfSB6Jy5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJjUGF0aDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogICAgICAgICAgICAgICAgcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbc2VxXSAgOiBwcm9wLmNvbG9yc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgcHJvcC5jb2xvcnNPcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICAgICAgICAgICAgICBwcm9wLnN0cm9rZXN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogICAgICBwcm9wLmxpbmV3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdG9vbHRpcCc6ICAgICAgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHMubGVuZ3RoKSA/IHByb3AudG9vbHRpcHNbaV0gOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeCc6ICAgICAgdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jZW50ZXJ5JzogICAgICB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWluZGV4JzogICAgICAgICdbezF9LHsyfV0nLmZvcm1hdChpLCBqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdmFsdWUnOiAgICAgICAgdGhpcy5kYXRhW2ldWzBdW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1zdGFydC1hbmdsZSc6ICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZW5kLWFuZ2xlJzogICAgZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1yYWRpdXMnOiAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXJhZGl1cy1pbm5lcic6IHByZXZSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwnOiAgIHNlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50IHRvIHRoZSBhbmdsZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyYWRpdXMtaW5uZXInOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMyW2ldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cy1pbm5lcic6IHByZXZSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGF0YVtpXVtqXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgdG9vbHRpcHMgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwcyAmJiBwcm9wLnRvb2x0aXBzW3NlcV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHRvb2x0aXBzRXZlbnQgZGVmYXVsdCB0byBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgIT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AudG9vbHRpcHNFdmVudCA9ICdjbGljayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoaW5kZXgsZ3JvdXAsc2VxLG9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsIGZ1bmN0aW9uIChlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSByZWN0IHRoYXQgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YWxsIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNoYW5nZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShqLCBpLCBzZXEsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlcS0tXG5cblxuXG4gICAgICAgICAgICAgICAgICAgIFxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgLy8gQSByZWd1bGFyIG5vbi1lcXVpLWFuZ3VsYXIgc2VnbWVudFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSAodGhpcy5kYXRhW2ldWzBdIC8gdGhpcy5zY2FsZS5tYXgpICogdGhpcy5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCArIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQgLSBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAnezF9IHonLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJjUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbaV0gIDogcHJvcC5jb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuY29sb3JzT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHByb3Auc3Ryb2tlc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvb2x0aXAnOiAoIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGgpID8gcHJvcC50b29sdGlwc1tpXSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcngnOiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeSc6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3RhcnQtYW5nbGUnOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1lbmQtYW5nbGUnOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmFkaXVzJzogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwnOiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCB0byB0aGUgYW5nbGVzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhW2ldWzBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzMltpXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmFkaXVzLWlubmVyJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bal1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgXG4gICAgXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHRvb2x0aXBzRXZlbnQgZGVmYXVsdCB0byBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCAhPT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnRvb2x0aXBzRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpbmRleCwgZ3JvdXAsIHNlcSwgb2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsIGZ1bmN0aW9uIChlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJHLlNWRy50b29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcm9wLnRvb2x0aXBzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSByZWN0IHRoYXQgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCB0aGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjaGFuZ2VzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oaSwgaSwgc2VxLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBzdGFydCBhbmdsZSBmb3IgdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gcmFkaWFucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlZHJhd3MgdGhlIGNoYXJ0IGlmIHJlcXVpcmVkXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMucmVkcmF3Um9zZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERyYXcgdGhlIGxhYmVsc1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBzY2FsZSBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaWYgKHByb3Auc2NhbGVWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuc2NhbGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJ4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuY2VudGVyeSAtICh0aGlzLnJhZGl1cyAvIHRoaXMuc2NhbGUubGFiZWxzLmxlbmd0aCAqIChpKzEpICk7XG4gICAgXG5cbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiAgICB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogICB0aGlzLnNjYWxlLmxhYmVsc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6ICAgcHJvcC5zY2FsZVNpemUgfHwgcHJvcC50ZXh0U2l6ZSAtIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogIHByb3Auc2NhbGVDb2xvciAgfHwgcHJvcC50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2xkOiAgIHR5cGVvZiBwcm9wLnNjYWxlQm9sZCAgID09PSAnYm9vbGVhbicgPyBwcm9wLnNjYWxlQm9sZCAgIDogcHJvcC50ZXh0Qm9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0YWxpYzogdHlwZW9mIHByb3Auc2NhbGVJdGFsaWMgPT09ICdib29sZWFuJyA/IHByb3Auc2NhbGVJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250OiAgIHByb3Auc2NhbGVGb250ICB8fCBwcm9wLnRleHRGb250XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSB6ZXJvIGxhYmVsXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFJHLlNWRy5udW1iZXJGb3JtYXQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6ICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG51bTogICAgICAgdGhpcy5zY2FsZS5taW4udG9GaXhlZChwcm9wLnNjYWxlRGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kOiAgIHByb3Auc2NhbGVVbml0c1ByZSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kOiAgICBwcm9wLnNjYWxlVW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogICAgIHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdGhvdXNhbmQ6ICBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogcHJvcC5zY2FsZUZvcm1hdHRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgIFxuICAgICAgICAgICAgICAgIFJHLlNWRy50ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdmc6ICAgIHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogICBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6ICAgcHJvcC5zY2FsZVNpemUgfHwgcHJvcC50ZXh0U2l6ZSAtIDIsXG4gICAgICAgICAgICAgICAgICAgIHg6ICAgICAgdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgICAgICB5OiAgICAgIHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6MixcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICBwcm9wLnNjYWxlQ29sb3IgIHx8IHByb3AudGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib2xkOiAgIHR5cGVvZiBwcm9wLnNjYWxlQm9sZCAgID09PSAnYm9vbGVhbicgPyBwcm9wLnNjYWxlQm9sZCAgIDogcHJvcC50ZXh0Qm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljOiB0eXBlb2YgcHJvcC5zY2FsZUl0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5zY2FsZUl0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogICBwcm9wLnNjYWxlRm9udCAgfHwgcHJvcC50ZXh0Rm9udFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAvLyBVc2VkIGZ1cnRoZXIgZG93blxuICAgICAgICAgICAgdmFyIGhhbGlnbjtcblxuICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBzaXplIGZvciB0aGUgbGFiZWxzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AubGFiZWxzU2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBwcm9wLmxhYmVsc1NpemUgPSBwcm9wLnRleHRTaXplICsgNDtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGNpcmN1bGFyIGxhYmVscyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxwcm9wLmxhYmVscy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSAgPSAoKHRoaXMuYW5nbGVzMltpXVswXS5lbmQgLSB0aGlzLmFuZ2xlczJbaV1bMF0uc3RhcnQpIC8gMikgKyB0aGlzLmFuZ2xlczJbaV1bMF0uc3RhcnQgLSBSRy5TVkcuVFJJRy5IQUxGUEk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gKCgoUkcuU1ZHLlRSSUcuVFdPUEkgLyBwcm9wLmxhYmVscy5sZW5ndGgpKSAqIGkpIC0gUkcuU1ZHLlRSSUcuSEFMRlBJICsgcHJvcC5sYWJlbHNBbmdsZU9mZnNldCArICgodGhpcy5hbmdsZXMyW2ldWzBdLmVuZCAtIHRoaXMuYW5nbGVzMltpXVswXS5zdGFydCkgLyAyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSBSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHI6ICAgICB0aGlzLnJhZGl1cyArIHByb3AubGFiZWxzUmFkaWFsTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBhbmdsZTogYW5nbGVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFjY29tbW9kYXRlIHRoZSBleHBsb3Npb24gZm9yIHRoZSBsYWJlbFxuICAgICAgICAgICAgICAgIHZhciBleHBsb3Npb24gPSB0aGlzLmdldEV4cGxvZGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmFuZ2xlczJbaV1bMF0uc3RhcnQgLSBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogdGhpcy5hbmdsZXMyW2ldWzBdLmVuZCAtIFJHLlNWRy5UUklHLkhBTEZQSVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVuZHBvaW50WzBdICs9IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXTtcbiAgICAgICAgICAgICAgICBlbmRwb2ludFsxXSArPSB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV07XG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAvLyBEbyB0aGUgYWxpZ25tZW50IGJhc2VkIG9uIHdoaWNoIHF1YWRyYW50IHRoZSBsYWJlbCBpcyBpblxuICAgICAgICAgICAgICAgIGlmIChtYS5yb3VuZChlbmRwb2ludFswXSkgPiB0aGlzLmNlbnRlcngpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWEucm91bmQoZW5kcG9pbnRbMF0pID09PSB0aGlzLmNlbnRlcngpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9XG5cblxuXG5cblxuICAgICAgICAgICAgICAgIFJHLlNWRy50ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdmc6ICAgIHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogICB0eXBlb2YgcHJvcC5sYWJlbHNbaV0gPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNbaV0gOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogICBwcm9wLmxhYmVsc1NpemUsXG4gICAgICAgICAgICAgICAgICAgIHg6ICAgICAgZW5kcG9pbnRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6ICAgICAgZW5kcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbjogaGFsaWduLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoyLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogIHByb3AubGFiZWxzQ29sb3IgIHx8IHByb3AudGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib2xkOiAgIHR5cGVvZiBwcm9wLmxhYmVsc0JvbGQgICA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNCb2xkICAgOiBwcm9wLnRleHRCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWM6IHR5cGVvZiBwcm9wLmxhYmVsc0l0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6ICAgcHJvcC5sYWJlbHNGb250ICB8fCBwcm9wLnRleHRGb250XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGhpZ2hsaWdodCBhIHNlZ21lbnQgb24gdGhlIGNoYXJ0XG4gICAgICAgICogXG4gICAgICAgICogQHBhcmFtIG9iamVjdCBjaXJjbGUgVGhlIGNpcmNsZSB0byBoaWdobGlnaHRcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAocGF0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoLmdldEF0dHJpYnV0ZSgnZCcpO1xuXG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wLmhpZ2hsaWdodEZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5oaWdobGlnaHRTdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBSRy5TVkcuaGlkZVRvb2x0aXAoKTtcblxuICAgICAgICAgICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBoaWdobGlnaHQgcmVjdCBpbiB0aGUgcmVnaXN0cnkgc29cbiAgICAgICAgICAgIC8vIGl0IGNhbiBiZSBjbGVhcmVkIGxhdGVyXG4gICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0KTtcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFRoaXMgYWxsb3dzIGZvciBlYXN5IHNwZWNpZmljYXRpb24gb2YgZ3JhZGllbnRzXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgY29sb3JzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdG9yZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlc2V0XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogICAgICAgIFJHLlNWRy5hcnJheUNsb25lKHByb3AuY29sb3JzKSxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0RmlsbDogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb2xvcnNcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBwcm9wLmNvbG9ycztcblxuICAgICAgICAgICAgaWYgKGNvbG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzW2ldID0gUkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBmaWxsXG4gICAgICAgICAgICBwcm9wLmhpZ2hsaWdodEZpbGwgPSBSRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZ2V0TWF4VmFsdWUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVJHLlNWRy5pc051bGwodGhpcy5kYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWEubWF4KG1heCwgdGhpcy5kYXRhW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVswXSA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1hLm1heChtYXgsIFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGFbaV1bMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVJHLlNWRy5pc051bGwodGhpcy5kYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWEubWF4KG1heCwgdGhpcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBtYS5tYXgobWF4LCBSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0cyB0aGUgcmFkaXVzIG9mIGEgdmFsdWVcbiAgICAgICAgLy9cbiAgICAgICAgLy9AcGFyYW0gbnVtYmVyIFRoZSB2YWx1ZSB0byBnZXQgdGhlIHJhZGl1cyBmb3JcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5nZXRSYWRpdXMgPSBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAoICh2YWx1ZSAtIHByb3Auc2NhbGVNaW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gcHJvcC5zY2FsZU1pbikgKSAqIHRoaXMucmFkaXVzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSByb3VuZFJvYmluIGVmZmVjdCBmb3IgdGhlIFBpZSBjaGFydFxuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gb2JqZWN0ICAgIE9wdGlvbnMgZm9yIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gQHBhcmFtIGZ1bmN0aW9uICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICB0aGUgZWZmZWN0IGlzIGNvbXBsZXRlXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMucm91bmRSb2JpbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFVzaW5nIGEgZnVuY3Rpb24gdG8gYWRkIGV2ZW50cyBtYWtlcyBpdCBlYXNpZXIgdG8gZmFjaWxpdGF0ZSBtZXRob2RcbiAgICAgICAgKiBjaGFpbmluZ1xuICAgICAgICAqIFxuICAgICAgICAqIEBwYXJhbSBzdHJpbmcgICB0eXBlIFRoZSB0eXBlIG9mIGV2ZW4gdG8gYWRkXG4gICAgICAgICogQHBhcmFtIGZ1bmN0aW9uIGZ1bmMgXG4gICAgICAgICovXG4gICAgICAgIHRoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsMikgIT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBVc2VkIGluIGNoYWluaW5nLiBSdW5zIGEgZnVuY3Rpb24gdGhlcmUgYW5kIHRoZW4gLSBub3Qgd2FpdGluZyBmb3JcbiAgICAgICAgLy8gdGhlIGV2ZW50cyB0byBmaXJlIChlZyB0aGUgb25iZWZvcmVkcmF3IGV2ZW50KVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gQHBhcmFtIGZ1bmN0aW9uIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZ1bmModGhpcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBoaWdobGlnaHQgZnJvbSB0aGUgY2hhcnRcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yZW1vdmVIaWdobGlnaHQgPVxuICAgICAgICB0aGlzLmhpZGVIaWdobGlnaHQgICA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQgJiYgdGhpcy5oaWdobGlnaHRfbm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0X25vZGUuc2V0QXR0cmlidXRlKCdmaWxsJywndHJhbnNwYXJlbnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodF9ub2RlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywndHJhbnNwYXJlbnQnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSBleHBsb2RlZCBYL1kgZm9yIGEgZ2l2ZW4gZXhwbG9zaW9uXG4gICAgICAgIC8vXG4gICAgICAgIC8vVE9ETyBOZWVkcyB1cGRhdGluZyB0byBjdXJyZW50IGNvZGluZyBzdHlsZSwgaW5jbHVkaW5nIGNvbnZlcnRpbmdcbiAgICAgICAgLy8gICAgIGFyZ3VtZW50cyB0byBhbiBvYmplY3RcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5nZXRFeHBsb2RlZCA9IGZ1bmN0aW9uIChvcHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpbmRleCAgICA9IG9wdC5pbmRleCxcbiAgICAgICAgICAgICAgICBzdGFydCAgICA9IG9wdC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICA9IG9wdC5lbmQsXG4gICAgICAgICAgICAgICAgZXhwbG9kZWQgPSBwcm9wLmV4cGxvZGVkLFxuICAgICAgICAgICAgICAgIGV4cGxvZGVkWCxcbiAgICAgICAgICAgICAgICBleHBsb2RlZFk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBSZXRyaWV2ZSBhbnkgZXhwbG9kZWQgLSB0aGUgZXhwbG9kZWQgY2FuIGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb3IgYSBzaW5nbGUgbnVtYmVyXG4gICAgICAgICAgICAqICh3aGljaCBpcyBhcHBsaWVkIHRvIGFsbCBzZWdtZW50cylcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGxvZGVkID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwbG9kZWRbaW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGV4cGxvZGVkWCA9IG1hLmNvcygoKGVuZCAtIHN0YXJ0KSAvIDIpICsgc3RhcnQpICogZXhwbG9kZWRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGV4cGxvZGVkWSA9IChtYS5zaW4oKChlbmQgLSBzdGFydCkgLyAyKSArIHN0YXJ0KSAqIGV4cGxvZGVkW2luZGV4XSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cGxvZGVkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGV4cGxvZGVkWCA9IG1hLmNvcygoKGVuZCAtIHN0YXJ0KSAvIDIpICsgc3RhcnQpICogZXhwbG9kZWQ7XG4gICAgICAgICAgICAgICAgZXhwbG9kZWRZID0gbWEuc2luKCgoZW5kIC0gc3RhcnQpIC8gMikgKyBzdGFydCkgKiBleHBsb2RlZDtcbiAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwbG9kZWRYID0gMDtcbiAgICAgICAgICAgICAgICBleHBsb2RlZFkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gW2V4cGxvZGVkWCwgZXhwbG9kZWRZXTtcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNldCB0aGUgb3B0aW9ucyB0aGF0IHRoZSB1c2VyIGhhcyBwcm92aWRlZFxuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgaW4gY29uZi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgY29uZi5vcHRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgXG4gICAgXG4gICAgcmV0dXJuIHRoaXM7XG5cblxuXG5cbi8vIEVuZCBtb2R1bGUgcGF0dGVyblxufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnJvc2UuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0hBO0FBQ0E7QUFrSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUpBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFKQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFKQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFKQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQUpBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQVFBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBSkE7QUFDQTtBQVlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBOzs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///246\n");

/***/ }),
/* 247 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Scatter = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'scatter';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.sequential = 0;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, xmax: 0, tickmarksStyle: 'cross', tickmarksSize: 7, colors: ['black'], line: false, lineColors: 1, lineLinewidth: 'black', yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisMin: 0, xaxisMax: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n    if (this.data[0] && !RG.SVG.isArray(this.data[0])) {\n      this.data = [];this.data[0] = conf.data;\n    }\n    if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;if (typeof prop.xaxisMin === 'string') {\n      prop.xaxisMin = RG.SVG.parseDate(prop.xaxisMin);\n    }\n    if (typeof prop.xaxisMax === 'string') {\n      prop.xaxisMax = RG.SVG.parseDate(prop.xaxisMax);\n    }\n    for (var i = 0; i < this.data.length; ++i) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j].x === 'string') {\n          this.data[i][j].x = RG.SVG.parseDate(this.data[i][j].x);\n        }\n      }\n    }\n    this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();for (var ds = 0, max = 0; ds < this.data.length; ++ds) {\n        for (var dp = 0; dp < this.data[ds].length; ++dp) {\n          max = ma.max(max, this.data[ds][dp].y);\n        }\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);var dataset_group = RGraph.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'scatter_datasets_' + this.uid } });for (var i = 0; i < this.data.length; ++i) {\n        this.drawPoints({ index: i, data: this.data[i], group: dataset_group });if (prop.line == true || _typeof(prop.line) === 'object' && prop.line[i] == true) {\n          this.drawLine({ index: i, coords: this.coords[i] });\n        }\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawPoints = function (opt) {\n      var index = opt.index,\n          data = opt.data,\n          group = opt.group;this.coords[index] = [];var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: group, attr: { className: 'scatter_dataset_' + index + '_' + this.uid } });for (var i = 0; i < data.length; ++i) {\n        var point = data[i];if (typeof point.x === 'number' && typeof point.y === 'number') {\n          var ret = this.drawSinglePoint({ dataset: data, datasetIdx: index, point: point, index: i, group: group, sequential: this.sequential++ });this.coords[index][i] = [ret.x, ret.y];\n        }\n        if (typeof data[i].tooltip === 'string' && data[i].tooltip || typeof data[i].tooltip === 'number') {\n          var _RG$SVG$create;\n\n          data[i].tooltip = String(data[i].tooltip);if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          if (!group_tooltip_hotspots) {\n            var group_tooltip_hotspots = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph-scatter-tooltip-hotspots' } });\n          }\n          var rect = RG.SVG.create((_RG$SVG$create = { svg: this.svg, parent: this.svg.all, type: 'rect' }, _defineProperty(_RG$SVG$create, 'parent', group_tooltip_hotspots), _defineProperty(_RG$SVG$create, 'attr', { x: ret.x - ret.size / 2, y: ret.y - ret.size / 2, width: ret.size, height: ret.size, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0 }), _defineProperty(_RG$SVG$create, 'style', { cursor: 'pointer' }), _RG$SVG$create));ret.mark.hotspot = rect;(function (dataset, index, seq, obj) {\n            rect.addEventListener(prop.tooltipsEvent, function (e) {\n              var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__dataset__ === dataset && tooltip.__index__ === index) {\n                return;\n              }\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: obj.data[dataset][index].tooltip, event: e });if (RG.SVG.REG.get('tooltip')) {\n                obj.highlight(this);\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(index, i, this.sequential - 1, this);\n        }\n      }\n    };this.drawSinglePoint = function (opt) {\n      var dataset = opt.dataset,\n          datasetIdx = opt.datasetIdx,\n          seq = opt.sequential,\n          point = opt.point,\n          index = opt.index,\n          valueX = opt.point.x,\n          valueY = opt.point.y,\n          conf = opt.point || {},\n          group = opt.group,\n          coordX = opt.coordx = this.getXCoord(valueX),\n          coordY = opt.coordy = this.getYCoord(valueY);if (typeof conf.type === 'undefined' && typeof conf.shape !== 'undefined') {\n        conf.type = conf.shape;\n      }\n      if (typeof conf.type === 'string') {} else if (typeof prop.tickmarksStyle === 'string') {\n        conf.type = prop.tickmarksStyle;\n      } else if (_typeof(prop.tickmarksStyle) === 'object' && typeof prop.tickmarksStyle[datasetIdx] === 'string') {\n        conf.type = prop.tickmarksStyle[datasetIdx];\n      }\n      if (typeof conf.size !== 'number' && typeof prop.tickmarksSize === 'number') {\n        conf.size = prop.tickmarksSize;\n      } else if (typeof conf.size !== 'number' && _typeof(prop.tickmarksSize) === 'object' && typeof prop.tickmarksSize[datasetIdx] === 'number') {\n        conf.size = prop.tickmarksSize[datasetIdx];\n      }\n      if (typeof conf.color === 'string') {} else if (typeof prop.colors[datasetIdx] === 'string') {\n        conf.color = prop.colors[datasetIdx];\n      } else {\n        conf.color = 'black';\n      }\n      if (typeof conf.opacity === 'undefined') {\n        conf.opacity = 1;\n      } else if (typeof conf.opacity === 'number') {}\n      if (prop.bubble) {\n        return this.drawBubble(opt, conf);\n      }\n      switch (conf.type) {case 'image:' + conf.type.substr(6):\n          var src = conf.type.substr(6);var img = new Image();img.src = src;var mark = RG.SVG.create({ svg: this.svg, type: 'image', parent: group, attr: { preserveAspectRatio: 'xMidYMid meet', 'xlink:href': src } });img.onload = function () {\n            var x = coordX - img.width / 2,\n                y = coordY - img.height / 2,\n                w = img.width,\n                h = img.height;mark.setAttribute('x', x);mark.setAttribute('y', y);mark.setAttribute('width', w);mark.setAttribute('height', h);if (mark && mark.hotspot) {\n              mark.hotspot.setAttribute('x', x);mark.hotspot.setAttribute('y', y);mark.hotspot.setAttribute('width', w);mark.hotspot.setAttribute('height', h);\n            }\n          };break;case 'triangle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} L {5} {6}'.format(coordX - conf.size / 2, coordY + conf.size / 2, coordX, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2), fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'plus':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY, coordX + conf.size / 2, coordY, coordX, coordY - conf.size / 2, coordX, coordY + conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;case 'square':case 'rect':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: coordX - conf.size / 2, y: coordY - conf.size / 2, width: conf.size, height: conf.size, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'dot':case 'circle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: coordX, cy: coordY, r: conf.size / 2, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'cross':default:\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2, coordX - conf.size / 2, coordY + conf.size / 2, coordX + conf.size / 2, coordY - conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;}\n      mark.setAttribute('data-index', index);mark.setAttribute('data-dataset', datasetIdx);mark.setAttribute('data-original-opacity', conf.opacity);mark.setAttribute('data-original-color', conf.color);mark.setAttribute('data-original-coordx', coordX);mark.setAttribute('data-original-coordy', coordY);mark.setAttribute('data-size', conf.size);mark.setAttribute('data-sequential', seq);mark.setAttribute('data-type', conf.type);return { x: coordX, y: coordY, size: conf.type.substr(0, 6) === 'image:' ? img.width : conf.size, mark: mark, type: conf.type };\n    };this.drawBubble = function (opt, conf) {\n      var size = conf.z / prop.bubbleMaxValue * prop.bubbleMaxRadius;var color = RG.SVG.parseColorRadial({ object: this, color: prop.bubbleColorsSolid ? conf.color : 'Gradient(white:' + conf.color + ')', cx: opt.coordx + size / 4, cy: opt.coordy - size / 4, fx: opt.coordx + size / 4, fy: opt.coordy - size / 4, r: size * 1.5 });var circle = RG.SVG.create({ svg: this.svg, type: 'circle', attr: { cx: opt.coordx, cy: opt.coordy, r: size, fill: color, 'fill-opacity': conf.opacity } });circle.setAttribute('data-index', opt.index);circle.setAttribute('data-dataset', opt.datasetIdx);circle.setAttribute('data-original-opacity', conf.opacity);circle.setAttribute('data-original-color', conf.color);circle.setAttribute('data-original-coordx', opt.coordx);circle.setAttribute('data-original-coordy', opt.coordy);circle.setAttribute('data-size', size);circle.setAttribute('data-sequential', opt.sequential);circle.setAttribute('data-type', 'bubble');return { x: opt.coordx, y: opt.coordy, z: opt.coordz };\n    };this.drawLine = function (opt) {\n      var linewidth = 1,\n          color = 'black';if (_typeof(prop.lineLinewidth) === 'object' && typeof prop.lineLinewidth[opt.index] === 'number') {\n        linewidth = prop.lineLinewidth[opt.index];\n      } else if (typeof prop.lineLinewidth === 'number') {\n        linewidth = prop.lineLinewidth;\n      } else {\n        linewidth = 1;\n      }\n      if (_typeof(prop.lineColors) === 'object' && prop.lineColors[opt.index]) {\n        color = prop.lineColors[opt.index];\n      } else if (prop.colors[opt.index] === 'string') {\n        color = prop.colors[opt.index];\n      } else {\n        color = 'black';\n      }\n      for (var i = 0, path = ''; i < this.coords[opt.index].length; ++i) {\n        path += '{1} {2} {3} '.format(i === 0 ? 'M' : 'L', this.coords[opt.index][i][0], this.coords[opt.index][i][1]);\n      }\n      RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path, fill: 'transparent', stroke: color, 'stroke-width': linewidth, 'stroke-linecap': 'round', 'stroke-linejoin': 'round' } });\n    };this.getXCoord = function (value) {\n      var x;if (value > prop.xaxisMax) {\n        return null;\n      }\n      if (value < prop.xaxisMin) {\n        return null;\n      }\n      x = (value - prop.xaxisMin) / (prop.xaxisMax - prop.xaxisMin);x *= this.width - prop.gutterLeft - prop.gutterRight;x = prop.gutterLeft + x;return x;\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      rect.setAttribute('fill', prop.highlightFill);RG.SVG.REG.set('highlight', rect);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors && !prop.bubble) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight) {\n        highlight.setAttribute('fill', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnNjYXR0ZXIuanM/NmIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlNWRz1SR3JhcGguU1ZHfHx7fTsoZnVuY3Rpb24od2luLGRvYyx1bmRlZmluZWQpXG57dmFyIFJHPVJHcmFwaCx1YT1uYXZpZ2F0b3IudXNlckFnZW50LG1hPU1hdGgsd2luPXdpbmRvdyxkb2M9ZG9jdW1lbnQ7UkcuU1ZHLlNjYXR0ZXI9ZnVuY3Rpb24oY29uZilcbnt0aGlzLnNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtmb3IoaSBpbiBhcmd1bWVudHNbMF0pe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTppLHZhbHVlOmFyZ3VtZW50c1swXVtpXX0pO25hbWU9cmV0Lm5hbWU7dmFsdWU9cmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsdmFsdWUpO319fWVsc2V7dmFyIHJldD1SRy5TVkcuY29tbW9uU2V0dGVyKHtvYmplY3Q6dGhpcyxuYW1lOm5hbWUsdmFsdWU6dmFsdWV9KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnByb3BlcnRpZXNbbmFtZV09dmFsdWU7fVxucmV0dXJuIHRoaXM7fTt0aGlzLmlkPWNvbmYuaWQ7dGhpcy51aWQ9UkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnPVJHLlNWRy5jcmVhdGVTVkcoe2NvbnRhaW5lcjp0aGlzLmNvbnRhaW5lcn0pO3RoaXMuaXNSR3JhcGg9dHJ1ZTt0aGlzLndpZHRoPU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0PU51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTt0aGlzLmRhdGE9Y29uZi5kYXRhO3RoaXMudHlwZT0nc2NhdHRlcic7dGhpcy5jb29yZHM9W107dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycz17fTt0aGlzLmdyYWRpZW50Q291bnRlcj0xO3RoaXMuc2VxdWVudGlhbD0wO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheT0naW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXM9e2d1dHRlckxlZnQ6MzUsZ3V0dGVyUmlnaHQ6MzUsZ3V0dGVyVG9wOjM1LGd1dHRlckJvdHRvbTozNSxiYWNrZ3JvdW5kQ29sb3I6bnVsbCxiYWNrZ3JvdW5kSW1hZ2U6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VBc3BlY3Q6J25vbmUnLGJhY2tncm91bmRJbWFnZVN0cmV0Y2g6dHJ1ZSxiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5Om51bGwsYmFja2dyb3VuZEltYWdlWDpudWxsLGJhY2tncm91bmRJbWFnZVk6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VXOm51bGwsYmFja2dyb3VuZEltYWdlSDpudWxsLGJhY2tncm91bmRHcmlkOnRydWUsYmFja2dyb3VuZEdyaWRDb2xvcjonI2RkZCcsYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6MSxiYWNrZ3JvdW5kR3JpZEhsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZFZsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZEJvcmRlcjp0cnVlLHhtYXg6MCx0aWNrbWFya3NTdHlsZTonY3Jvc3MnLHRpY2ttYXJrc1NpemU6Nyxjb2xvcnM6WydibGFjayddLGxpbmU6ZmFsc2UsbGluZUNvbG9yczoxLGxpbmVMaW5ld2lkdGg6J2JsYWNrJyx5YXhpczp0cnVlLHlheGlzVGlja21hcmtzOnRydWUseWF4aXNUaWNrbWFya3NMZW5ndGg6Myx5YXhpc0NvbG9yOidibGFjaycseWF4aXNTY2FsZTp0cnVlLHlheGlzTGFiZWxzOm51bGwseWF4aXNMYWJlbHNPZmZzZXR4OjAseWF4aXNMYWJlbHNPZmZzZXR5OjAseWF4aXNMYWJlbHNDb3VudDo1LHlheGlzVW5pdHNQcmU6JycseWF4aXNVbml0c1Bvc3Q6JycseWF4aXNTdHJpY3Q6ZmFsc2UseWF4aXNEZWNpbWFsczowLHlheGlzUG9pbnQ6Jy4nLHlheGlzVGhvdXNhbmQ6JywnLHlheGlzUm91bmQ6ZmFsc2UseWF4aXNNYXg6bnVsbCx5YXhpc01pbjowLHlheGlzRm9ybWF0dGVyOm51bGwseGF4aXM6dHJ1ZSx4YXhpc1RpY2ttYXJrczp0cnVlLHhheGlzVGlja21hcmtzTGVuZ3RoOjUseGF4aXNMYWJlbHM6bnVsbCx4YXhpc0xhYmVsc1Bvc2l0aW9uOidzZWN0aW9uJyx4YXhpc0xhYmVsc1Bvc2l0aW9uRWRnZVRpY2ttYXJrc0NvdW50Om51bGwseGF4aXNDb2xvcjonYmxhY2snLHhheGlzTGFiZWxzT2Zmc2V0eDowLHhheGlzTGFiZWxzT2Zmc2V0eTowLHhheGlzTWluOjAseGF4aXNNYXg6bnVsbCx0ZXh0Q29sb3I6J2JsYWNrJyx0ZXh0Rm9udDonc2Fucy1zZXJpZicsdGV4dFNpemU6MTIsdGV4dEJvbGQ6ZmFsc2UsdGV4dEl0YWxpYzpmYWxzZSx0b29sdGlwc092ZXJyaWRlOm51bGwsdG9vbHRpcHNFZmZlY3Q6J2ZhZGUnLHRvb2x0aXBzQ3NzQ2xhc3M6J1JHcmFwaF90b29sdGlwJyx0b29sdGlwc0V2ZW50Oidtb3VzZW1vdmUnLGhpZ2hsaWdodFN0cm9rZToncmdiYSgwLDAsMCwwKScsaGlnaGxpZ2h0RmlsbDoncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxoaWdobGlnaHRMaW5ld2lkdGg6MSx0aXRsZTonJyx0aXRsZVNpemU6MTYsdGl0bGVYOm51bGwsdGl0bGVZOm51bGwsdGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVWYWxpZ246bnVsbCx0aXRsZUNvbG9yOidibGFjaycsdGl0bGVGb250Om51bGwsdGl0bGVCb2xkOmZhbHNlLHRpdGxlSXRhbGljOmZhbHNlLHRpdGxlU3VidGl0bGU6JycsdGl0bGVTdWJ0aXRsZVNpemU6MTAsdGl0bGVTdWJ0aXRsZVg6bnVsbCx0aXRsZVN1YnRpdGxlWTpudWxsLHRpdGxlU3VidGl0bGVIYWxpZ246J2NlbnRlcicsdGl0bGVTdWJ0aXRsZVZhbGlnbjpudWxsLHRpdGxlU3VidGl0bGVDb2xvcjonI2FhYScsdGl0bGVTdWJ0aXRsZUZvbnQ6bnVsbCx0aXRsZVN1YnRpdGxlQm9sZDpmYWxzZSx0aXRsZVN1YnRpdGxlSXRhbGljOmZhbHNlLGtleTpudWxsLGtleUNvbG9yczpudWxsLGtleU9mZnNldHg6MCxrZXlPZmZzZXR5OjAsa2V5VGV4dE9mZnNldHg6MCxrZXlUZXh0T2Zmc2V0eTotMSxrZXlUZXh0U2l6ZTpudWxsLGtleVRleHRCb2xkOm51bGwsa2V5VGV4dEl0YWxpYzpudWxsLGF0dHJpYnV0aW9uOnRydWUsYXR0cmlidXRpb25YOm51bGwsYXR0cmlidXRpb25ZOm51bGwsYXR0cmlidXRpb25IcmVmOm51bGwsYXR0cmlidXRpb25IYWxpZ246J3JpZ2h0JyxhdHRyaWJ1dGlvblZhbGlnbjonYm90dG9tJyxhdHRyaWJ1dGlvblNpemU6NyxhdHRyaWJ1dGlvbkNvbG9yOidncmF5JyxhdHRyaWJ1dGlvbkZvbnQ6J3NhbnMtc2VyaWYnLGF0dHJpYnV0aW9uSXRhbGljOmZhbHNlLGF0dHJpYnV0aW9uQm9sZDpmYWxzZX07Zm9yKGkgaW4gY29uZi5vcHRpb25zKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt0aGlzLnNldChpLGNvbmYub3B0aW9uc1tpXSk7fX1cbmlmKHRoaXMuZGF0YVswXSYmIVJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVswXSkpe3RoaXMuZGF0YT1bXTt0aGlzLmRhdGFbMF09Y29uZi5kYXRhO31cbmlmKFJHLlNWRy5GWCYmdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTt9XG52YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7aWYodHlwZW9mIHByb3AueGF4aXNNaW49PT0nc3RyaW5nJyl7cHJvcC54YXhpc01pbj1SRy5TVkcucGFyc2VEYXRlKHByb3AueGF4aXNNaW4pO31cbmlmKHR5cGVvZiBwcm9wLnhheGlzTWF4PT09J3N0cmluZycpe3Byb3AueGF4aXNNYXg9UkcuU1ZHLnBhcnNlRGF0ZShwcm9wLnhheGlzTWF4KTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7KytpKXtmb3IodmFyIGo9MDtqPHRoaXMuZGF0YVtpXS5sZW5ndGg7KytqKXtpZih0eXBlb2YgdGhpcy5kYXRhW2ldW2pdLng9PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldW2pdLng9UkcuU1ZHLnBhcnNlRGF0ZSh0aGlzLmRhdGFbaV1bal0ueCk7fX19XG50aGlzLmRyYXc9ZnVuY3Rpb24oKVxue1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7UkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5ncmFwaFdpZHRoPXRoaXMud2lkdGgtcHJvcC5ndXR0ZXJMZWZ0LXByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodD10aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbTtSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHtvYmplY3Q6dGhpc30pO3RoaXMucGFyc2VDb2xvcnMoKTtmb3IodmFyIGRzPTAsbWF4PTA7ZHM8dGhpcy5kYXRhLmxlbmd0aDsrK2RzKXtmb3IodmFyIGRwPTA7ZHA8dGhpcy5kYXRhW2RzXS5sZW5ndGg7KytkcCl7bWF4PW1hLm1heChtYXgsdGhpcy5kYXRhW2RzXVtkcF0ueSk7fX1cbmlmKHR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicpe21heD1wcm9wLnlheGlzTWF4O31cbmlmKHByb3AueWF4aXNNaW49PT0nbWlycm9yJ3x8cHJvcC55YXhpc01pbj09PSdtaWRkbGUnfHxwcm9wLnlheGlzTWluPT09J2NlbnRlcicpe3ZhciBtaXJyb3JTY2FsZT10cnVlO3Byb3AueWF4aXNNaW49MDt9XG50aGlzLnNjYWxlPVJHLlNWRy5nZXRTY2FsZSh7b2JqZWN0OnRoaXMsbnVtbGFiZWxzOnByb3AueWF4aXNMYWJlbHNDb3VudCx1bml0c1ByZTpwcm9wLnlheGlzVW5pdHNQcmUsdW5pdHNQb3N0OnByb3AueWF4aXNVbml0c1Bvc3QsbWF4Om1heCxtaW46cHJvcC55YXhpc01pbixwb2ludDpwcm9wLnlheGlzUG9pbnQscm91bmQ6cHJvcC55YXhpc1JvdW5kLHRob3VzYW5kOnByb3AueWF4aXNUaG91c2FuZCxkZWNpbWFsczpwcm9wLnlheGlzRGVjaW1hbHMsc3RyaWN0OnR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicsZm9ybWF0dGVyOnByb3AueWF4aXNGb3JtYXR0ZXJ9KTtpZihtaXJyb3JTY2FsZSl7dGhpcy5zY2FsZT1SRy5TVkcuZ2V0U2NhbGUoe29iamVjdDp0aGlzLG51bWxhYmVsczpwcm9wLnlheGlzTGFiZWxzQ291bnQsdW5pdHNQcmU6cHJvcC55YXhpc1VuaXRzUHJlLHVuaXRzUG9zdDpwcm9wLnlheGlzVW5pdHNQb3N0LG1heDp0aGlzLnNjYWxlLm1heCxtaW46dGhpcy5zY2FsZS5tYXgqIC0xLHBvaW50OnByb3AueWF4aXNQb2ludCxyb3VuZDpmYWxzZSx0aG91c2FuZDpwcm9wLnlheGlzVGhvdXNhbmQsZGVjaW1hbHM6cHJvcC55YXhpc0RlY2ltYWxzLHN0cmljdDp0eXBlb2YgcHJvcC55YXhpc01heD09PSdudW1iZXInLGZvcm1hdHRlcjpwcm9wLnlheGlzRm9ybWF0dGVyfSk7fVxudGhpcy5tYXg9dGhpcy5zY2FsZS5tYXg7dGhpcy5taW49dGhpcy5zY2FsZS5taW47cHJvcC55YXhpc01heD10aGlzLnNjYWxlLm1heDtwcm9wLnlheGlzTWluPXRoaXMuc2NhbGUubWluO1JHLlNWRy5kcmF3QmFja2dyb3VuZCh0aGlzKTtSRy5TVkcuZHJhd1hBeGlzKHRoaXMpO1JHLlNWRy5kcmF3WUF4aXModGhpcyk7dmFyIGRhdGFzZXRfZ3JvdXA9UkdyYXBoLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidnJyxwYXJlbnQ6dGhpcy5zdmcuYWxsLGF0dHI6e2NsYXNzTmFtZTonc2NhdHRlcl9kYXRhc2V0c18nK3RoaXMudWlkfX0pO2Zvcih2YXIgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDsrK2kpe3RoaXMuZHJhd1BvaW50cyh7aW5kZXg6aSxkYXRhOnRoaXMuZGF0YVtpXSxncm91cDpkYXRhc2V0X2dyb3VwfSk7aWYocHJvcC5saW5lPT10cnVlfHwodHlwZW9mIHByb3AubGluZT09PSdvYmplY3QnJiZwcm9wLmxpbmVbaV09PXRydWUpKXt0aGlzLmRyYXdMaW5lKHtpbmRleDppLGNvb3Jkczp0aGlzLmNvb3Jkc1tpXX0pO319XG5pZih0eXBlb2YgcHJvcC5rZXkhPT1udWxsJiZSRy5TVkcuZHJhd0tleSl7UkcuU1ZHLmRyYXdLZXkodGhpcyk7fWVsc2UgaWYoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSl7YWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7fVxuUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmRyYXdQb2ludHM9ZnVuY3Rpb24ob3B0KVxue3ZhciBpbmRleD1vcHQuaW5kZXgsZGF0YT1vcHQuZGF0YSxncm91cD1vcHQuZ3JvdXA7dGhpcy5jb29yZHNbaW5kZXhdPVtdO3ZhciBncm91cD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZTonZycscGFyZW50Omdyb3VwLGF0dHI6e2NsYXNzTmFtZTonc2NhdHRlcl9kYXRhc2V0XycraW5kZXgrJ18nK3RoaXMudWlkfX0pO2Zvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7KytpKXt2YXIgcG9pbnQ9ZGF0YVtpXTtpZih0eXBlb2YgcG9pbnQueD09PSdudW1iZXInJiZ0eXBlb2YgcG9pbnQueT09PSdudW1iZXInKXt2YXIgcmV0PXRoaXMuZHJhd1NpbmdsZVBvaW50KHtkYXRhc2V0OmRhdGEsZGF0YXNldElkeDppbmRleCxwb2ludDpwb2ludCxpbmRleDppLGdyb3VwOmdyb3VwLHNlcXVlbnRpYWw6dGhpcy5zZXF1ZW50aWFsKyt9KTt0aGlzLmNvb3Jkc1tpbmRleF1baV09W3JldC54LHJldC55XTt9XG5pZigodHlwZW9mIGRhdGFbaV0udG9vbHRpcD09PSdzdHJpbmcnJiZkYXRhW2ldLnRvb2x0aXApfHwodHlwZW9mIGRhdGFbaV0udG9vbHRpcD09PSdudW1iZXInKSl7ZGF0YVtpXS50b29sdGlwPVN0cmluZyhkYXRhW2ldLnRvb2x0aXApO2lmKHByb3AudG9vbHRpcHNFdmVudCE9PSdtb3VzZW1vdmUnKXtwcm9wLnRvb2x0aXBzRXZlbnQ9J2NsaWNrJzt9XG5pZighZ3JvdXBfdG9vbHRpcF9ob3RzcG90cyl7dmFyIGdyb3VwX3Rvb2x0aXBfaG90c3BvdHM9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHBhcmVudDp0aGlzLnN2Zy5hbGwsdHlwZTonZycsYXR0cjp7Y2xhc3NOYW1lOidyZ3JhcGgtc2NhdHRlci10b29sdGlwLWhvdHNwb3RzJ319KTt9XG52YXIgcmVjdD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcscGFyZW50OnRoaXMuc3ZnLmFsbCx0eXBlOidyZWN0JyxwYXJlbnQ6Z3JvdXBfdG9vbHRpcF9ob3RzcG90cyxhdHRyOnt4OnJldC54LShyZXQuc2l6ZS8yKSx5OnJldC55LShyZXQuc2l6ZS8yKSx3aWR0aDpyZXQuc2l6ZSxoZWlnaHQ6cmV0LnNpemUsZmlsbDondHJhbnNwYXJlbnQnLHN0cm9rZTondHJhbnNwYXJlbnQnLCdzdHJva2Utd2lkdGgnOjB9LHN0eWxlOntjdXJzb3I6J3BvaW50ZXInfX0pO3JldC5tYXJrLmhvdHNwb3Q9cmVjdDsoZnVuY3Rpb24oZGF0YXNldCxpbmRleCxzZXEsb2JqKVxue3JlY3QuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsZnVuY3Rpb24oZSlcbnt2YXIgdG9vbHRpcD1SRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpO2lmKHRvb2x0aXAmJnRvb2x0aXAuX19kYXRhc2V0X189PT1kYXRhc2V0JiZ0b29sdGlwLl9faW5kZXhfXz09PWluZGV4KXtyZXR1cm47fVxub2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHtvYmplY3Q6b2JqLGRhdGFzZXQ6ZGF0YXNldCxpbmRleDppbmRleCxzZXF1ZW50aWFsSW5kZXg6c2VxLHRleHQ6b2JqLmRhdGFbZGF0YXNldF1baW5kZXhdLnRvb2x0aXAsZXZlbnQ6ZX0pO2lmKFJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwJykpe29iai5oaWdobGlnaHQodGhpcyk7fX0sZmFsc2UpO2lmKHByb3AudG9vbHRpcHNFdmVudD09PSdjbGljaycpe3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbihlKVxue2UudGFyZ2V0LnN0eWxlLmN1cnNvcj0ncG9pbnRlcic7fSxmYWxzZSk7fX0oaW5kZXgsaSx0aGlzLnNlcXVlbnRpYWwtMSx0aGlzKSk7fX19O3RoaXMuZHJhd1NpbmdsZVBvaW50PWZ1bmN0aW9uKG9wdClcbnt2YXIgZGF0YXNldD1vcHQuZGF0YXNldCxkYXRhc2V0SWR4PW9wdC5kYXRhc2V0SWR4LHNlcT1vcHQuc2VxdWVudGlhbCxwb2ludD1vcHQucG9pbnQsaW5kZXg9b3B0LmluZGV4LHZhbHVlWD1vcHQucG9pbnQueCx2YWx1ZVk9b3B0LnBvaW50LnksY29uZj1vcHQucG9pbnR8fHt9LGdyb3VwPW9wdC5ncm91cCxjb29yZFg9b3B0LmNvb3JkeD10aGlzLmdldFhDb29yZCh2YWx1ZVgpLGNvb3JkWT1vcHQuY29vcmR5PXRoaXMuZ2V0WUNvb3JkKHZhbHVlWSk7aWYodHlwZW9mIGNvbmYudHlwZT09PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uZi5zaGFwZSE9PSd1bmRlZmluZWQnKXtjb25mLnR5cGU9Y29uZi5zaGFwZTt9XG5pZih0eXBlb2YgY29uZi50eXBlPT09J3N0cmluZycpe31lbHNlIGlmKHR5cGVvZiBwcm9wLnRpY2ttYXJrc1N0eWxlPT09J3N0cmluZycpe2NvbmYudHlwZT1wcm9wLnRpY2ttYXJrc1N0eWxlO31lbHNlIGlmKHR5cGVvZiBwcm9wLnRpY2ttYXJrc1N0eWxlPT09J29iamVjdCcmJnR5cGVvZiBwcm9wLnRpY2ttYXJrc1N0eWxlW2RhdGFzZXRJZHhdPT09J3N0cmluZycpe2NvbmYudHlwZT1wcm9wLnRpY2ttYXJrc1N0eWxlW2RhdGFzZXRJZHhdO31cbmlmKHR5cGVvZiBjb25mLnNpemUhPT0nbnVtYmVyJyYmdHlwZW9mIHByb3AudGlja21hcmtzU2l6ZT09PSdudW1iZXInKXtjb25mLnNpemU9cHJvcC50aWNrbWFya3NTaXplO31lbHNlIGlmKHR5cGVvZiBjb25mLnNpemUhPT0nbnVtYmVyJyYmdHlwZW9mIHByb3AudGlja21hcmtzU2l6ZT09PSdvYmplY3QnJiZ0eXBlb2YgcHJvcC50aWNrbWFya3NTaXplW2RhdGFzZXRJZHhdPT09J251bWJlcicpe2NvbmYuc2l6ZT1wcm9wLnRpY2ttYXJrc1NpemVbZGF0YXNldElkeF07fVxuaWYodHlwZW9mIGNvbmYuY29sb3I9PT0nc3RyaW5nJyl7fWVsc2UgaWYodHlwZW9mIHByb3AuY29sb3JzW2RhdGFzZXRJZHhdPT09J3N0cmluZycpe2NvbmYuY29sb3I9cHJvcC5jb2xvcnNbZGF0YXNldElkeF07fWVsc2V7Y29uZi5jb2xvcj0nYmxhY2snO31cbmlmKHR5cGVvZiBjb25mLm9wYWNpdHk9PT0ndW5kZWZpbmVkJyl7Y29uZi5vcGFjaXR5PTE7fWVsc2UgaWYodHlwZW9mIGNvbmYub3BhY2l0eT09PSdudW1iZXInKXt9XG5pZihwcm9wLmJ1YmJsZSl7cmV0dXJuIHRoaXMuZHJhd0J1YmJsZShvcHQsY29uZik7fVxuc3dpdGNoKGNvbmYudHlwZSl7Y2FzZSdpbWFnZTonK2NvbmYudHlwZS5zdWJzdHIoNik6dmFyIHNyYz1jb25mLnR5cGUuc3Vic3RyKDYpO3ZhciBpbWc9bmV3IEltYWdlKCk7aW1nLnNyYz1zcmM7dmFyIG1hcms9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J2ltYWdlJyxwYXJlbnQ6Z3JvdXAsYXR0cjp7cHJlc2VydmVBc3BlY3RSYXRpbzoneE1pZFlNaWQgbWVldCcsJ3hsaW5rOmhyZWYnOnNyY319KTtpbWcub25sb2FkPWZ1bmN0aW9uKClcbnt2YXIgeD1jb29yZFgtKGltZy53aWR0aC8yKSx5PWNvb3JkWS0oaW1nLmhlaWdodC8yKSx3PWltZy53aWR0aCxoPWltZy5oZWlnaHQ7bWFyay5zZXRBdHRyaWJ1dGUoJ3gnLHgpO21hcmsuc2V0QXR0cmlidXRlKCd5Jyx5KTttYXJrLnNldEF0dHJpYnV0ZSgnd2lkdGgnLHcpO21hcmsuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGgpO2lmKG1hcmsmJm1hcmsuaG90c3BvdCl7bWFyay5ob3RzcG90LnNldEF0dHJpYnV0ZSgneCcseCk7bWFyay5ob3RzcG90LnNldEF0dHJpYnV0ZSgneScseSk7bWFyay5ob3RzcG90LnNldEF0dHJpYnV0ZSgnd2lkdGgnLHcpO21hcmsuaG90c3BvdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaCk7fX07YnJlYWs7Y2FzZSd0cmlhbmdsZSc6dmFyIG1hcms9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3BhdGgnLHBhcmVudDpncm91cCxhdHRyOntkOidNIHsxfSB7Mn0gTCB7M30gezR9IEwgezV9IHs2fScuZm9ybWF0KGNvb3JkWC0oY29uZi5zaXplLzIpLGNvb3JkWSsoY29uZi5zaXplLzIpLGNvb3JkWCxjb29yZFktKGNvbmYuc2l6ZS8yKSxjb29yZFgrKGNvbmYuc2l6ZS8yKSxjb29yZFkrKGNvbmYuc2l6ZS8yKSksZmlsbDpjb25mLmNvbG9yLCdmaWxsLW9wYWNpdHknOmNvbmYub3BhY2l0eX19KTticmVhaztjYXNlJ3BsdXMnOnZhciBtYXJrPVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidwYXRoJyxwYXJlbnQ6Z3JvdXAsYXR0cjp7ZDonTSB7MX0gezJ9IEwgezN9IHs0fSBNIHs1fSB7Nn0gTCB7N30gezh9Jy5mb3JtYXQoY29vcmRYLShjb25mLnNpemUvMiksY29vcmRZLGNvb3JkWCsoY29uZi5zaXplLzIpLGNvb3JkWSxjb29yZFgsY29vcmRZLShjb25mLnNpemUvMiksY29vcmRYLGNvb3JkWSsoY29uZi5zaXplLzIpKSxzdHJva2U6Y29uZi5jb2xvciwnc3Ryb2tlLW9wYWNpdHknOmNvbmYub3BhY2l0eX19KTticmVhaztjYXNlJ3NxdWFyZSc6Y2FzZSdyZWN0Jzp2YXIgbWFyaz1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncmVjdCcscGFyZW50Omdyb3VwLGF0dHI6e3g6Y29vcmRYLShjb25mLnNpemUvMikseTpjb29yZFktKGNvbmYuc2l6ZS8yKSx3aWR0aDpjb25mLnNpemUsaGVpZ2h0OmNvbmYuc2l6ZSxmaWxsOmNvbmYuY29sb3IsJ2ZpbGwtb3BhY2l0eSc6Y29uZi5vcGFjaXR5fX0pO2JyZWFrO2Nhc2UnZG90JzpjYXNlJ2NpcmNsZSc6dmFyIG1hcms9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J2NpcmNsZScscGFyZW50Omdyb3VwLGF0dHI6e2N4OmNvb3JkWCxjeTpjb29yZFkscjpjb25mLnNpemUvMixmaWxsOmNvbmYuY29sb3IsJ2ZpbGwtb3BhY2l0eSc6Y29uZi5vcGFjaXR5fX0pO2JyZWFrO2Nhc2UnY3Jvc3MnOmRlZmF1bHQ6dmFyIG1hcms9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J3BhdGgnLHBhcmVudDpncm91cCxhdHRyOntkOidNIHsxfSB7Mn0gTCB7M30gezR9IE0gezV9IHs2fSBMIHs3fSB7OH0nLmZvcm1hdChjb29yZFgtKGNvbmYuc2l6ZS8yKSxjb29yZFktKGNvbmYuc2l6ZS8yKSxjb29yZFgrKGNvbmYuc2l6ZS8yKSxjb29yZFkrKGNvbmYuc2l6ZS8yKSxjb29yZFgtKGNvbmYuc2l6ZS8yKSxjb29yZFkrKGNvbmYuc2l6ZS8yKSxjb29yZFgrKGNvbmYuc2l6ZS8yKSxjb29yZFktKGNvbmYuc2l6ZS8yKSksc3Ryb2tlOmNvbmYuY29sb3IsJ3N0cm9rZS1vcGFjaXR5Jzpjb25mLm9wYWNpdHl9fSk7YnJlYWs7fVxubWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLGluZGV4KTttYXJrLnNldEF0dHJpYnV0ZSgnZGF0YS1kYXRhc2V0JyxkYXRhc2V0SWR4KTttYXJrLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1vcGFjaXR5Jyxjb25mLm9wYWNpdHkpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvbG9yJyxjb25mLmNvbG9yKTttYXJrLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1jb29yZHgnLGNvb3JkWCk7bWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtY29vcmR5Jyxjb29yZFkpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLXNpemUnLGNvbmYuc2l6ZSk7bWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VxdWVudGlhbCcsc2VxKTttYXJrLnNldEF0dHJpYnV0ZSgnZGF0YS10eXBlJyxjb25mLnR5cGUpO3JldHVybnt4OmNvb3JkWCx5OmNvb3JkWSxzaXplOmNvbmYudHlwZS5zdWJzdHIoMCw2KT09PSdpbWFnZTonP2ltZy53aWR0aDpjb25mLnNpemUsbWFyazptYXJrLHR5cGU6Y29uZi50eXBlfTt9O3RoaXMuZHJhd0J1YmJsZT1mdW5jdGlvbihvcHQsY29uZilcbnt2YXIgc2l6ZT0oY29uZi56L3Byb3AuYnViYmxlTWF4VmFsdWUpKnByb3AuYnViYmxlTWF4UmFkaXVzO3ZhciBjb2xvcj1SRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7b2JqZWN0OnRoaXMsY29sb3I6cHJvcC5idWJibGVDb2xvcnNTb2xpZD9jb25mLmNvbG9yOidHcmFkaWVudCh3aGl0ZTonK2NvbmYuY29sb3IrJyknLGN4Om9wdC5jb29yZHgrKHNpemUvNCksY3k6b3B0LmNvb3JkeS0oc2l6ZS80KSxmeDpvcHQuY29vcmR4KyhzaXplLzQpLGZ5Om9wdC5jb29yZHktKHNpemUvNCkscjpzaXplKjEuNX0pO3ZhciBjaXJjbGU9UkcuU1ZHLmNyZWF0ZSh7c3ZnOnRoaXMuc3ZnLHR5cGU6J2NpcmNsZScsYXR0cjp7Y3g6b3B0LmNvb3JkeCxjeTpvcHQuY29vcmR5LHI6c2l6ZSxmaWxsOmNvbG9yLCdmaWxsLW9wYWNpdHknOmNvbmYub3BhY2l0eX19KTtjaXJjbGUuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyxvcHQuaW5kZXgpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0YXNldCcsb3B0LmRhdGFzZXRJZHgpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtb3BhY2l0eScsY29uZi5vcGFjaXR5KTtjaXJjbGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvbG9yJyxjb25mLmNvbG9yKTtjaXJjbGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvb3JkeCcsb3B0LmNvb3JkeCk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1jb29yZHknLG9wdC5jb29yZHkpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2l6ZScsc2l6ZSk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnZGF0YS1zZXF1ZW50aWFsJyxvcHQuc2VxdWVudGlhbCk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnZGF0YS10eXBlJywnYnViYmxlJyk7cmV0dXJue3g6b3B0LmNvb3JkeCx5Om9wdC5jb29yZHksejpvcHQuY29vcmR6fTt9O3RoaXMuZHJhd0xpbmU9ZnVuY3Rpb24ob3B0KVxue3ZhciBsaW5ld2lkdGg9MSxjb2xvcj0nYmxhY2snO2lmKHR5cGVvZiBwcm9wLmxpbmVMaW5ld2lkdGg9PT0nb2JqZWN0JyYmdHlwZW9mIHByb3AubGluZUxpbmV3aWR0aFtvcHQuaW5kZXhdPT09J251bWJlcicpe2xpbmV3aWR0aD1wcm9wLmxpbmVMaW5ld2lkdGhbb3B0LmluZGV4XTt9ZWxzZSBpZih0eXBlb2YgcHJvcC5saW5lTGluZXdpZHRoPT09J251bWJlcicpe2xpbmV3aWR0aD1wcm9wLmxpbmVMaW5ld2lkdGg7fWVsc2V7bGluZXdpZHRoPTE7fVxuaWYodHlwZW9mIHByb3AubGluZUNvbG9ycz09PSdvYmplY3QnJiZwcm9wLmxpbmVDb2xvcnNbb3B0LmluZGV4XSl7Y29sb3I9cHJvcC5saW5lQ29sb3JzW29wdC5pbmRleF07fWVsc2UgaWYocHJvcC5jb2xvcnNbb3B0LmluZGV4XT09PSdzdHJpbmcnKXtjb2xvcj1wcm9wLmNvbG9yc1tvcHQuaW5kZXhdO31lbHNle2NvbG9yPSdibGFjayc7fVxuZm9yKHZhciBpPTAscGF0aD0nJztpPHRoaXMuY29vcmRzW29wdC5pbmRleF0ubGVuZ3RoOysraSl7cGF0aCs9J3sxfSB7Mn0gezN9ICcuZm9ybWF0KGk9PT0wPydNJzonTCcsdGhpcy5jb29yZHNbb3B0LmluZGV4XVtpXVswXSx0aGlzLmNvb3Jkc1tvcHQuaW5kZXhdW2ldWzFdKTt9XG5SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncGF0aCcscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntkOnBhdGgsZmlsbDondHJhbnNwYXJlbnQnLHN0cm9rZTpjb2xvciwnc3Ryb2tlLXdpZHRoJzpsaW5ld2lkdGgsJ3N0cm9rZS1saW5lY2FwJzoncm91bmQnLCdzdHJva2UtbGluZWpvaW4nOidyb3VuZCd9fSk7fTt0aGlzLmdldFhDb29yZD1mdW5jdGlvbih2YWx1ZSlcbnt2YXIgeDtpZih2YWx1ZT5wcm9wLnhheGlzTWF4KXtyZXR1cm4gbnVsbDt9XG5pZih2YWx1ZTxwcm9wLnhheGlzTWluKXtyZXR1cm4gbnVsbDt9XG54PSgodmFsdWUtcHJvcC54YXhpc01pbikvKHByb3AueGF4aXNNYXgtcHJvcC54YXhpc01pbikpO3gqPSh0aGlzLndpZHRoLXByb3AuZ3V0dGVyTGVmdC1wcm9wLmd1dHRlclJpZ2h0KTt4PXByb3AuZ3V0dGVyTGVmdCt4O3JldHVybiB4O307dGhpcy5nZXRZQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57dmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO2lmKHZhbHVlPnRoaXMuc2NhbGUubWF4KXtyZXR1cm4gbnVsbDt9XG52YXIgeSx4YXhpc3Bvcz1wcm9wLnhheGlzcG9zO2lmKHZhbHVlPHRoaXMuc2NhbGUubWluKXtyZXR1cm4gbnVsbDt9XG55PSgodmFsdWUtdGhpcy5zY2FsZS5taW4pLyh0aGlzLnNjYWxlLm1heC10aGlzLnNjYWxlLm1pbikpO3kqPSh0aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbSk7eT10aGlzLmhlaWdodC1wcm9wLmd1dHRlckJvdHRvbS15O3JldHVybiB5O307dGhpcy5oaWdobGlnaHQ9ZnVuY3Rpb24ocmVjdClcbntyZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcscHJvcC5oaWdobGlnaHRGaWxsKTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JyxyZWN0KTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpe3RoaXMub3JpZ2luYWxDb2xvcnM9e2NvbG9yczpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksYmFja2dyb3VuZEdyaWRDb2xvcjpSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IpLGhpZ2hsaWdodEZpbGw6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKSxiYWNrZ3JvdW5kQ29sb3I6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpfX1cbnZhciBjb2xvcnM9cHJvcC5jb2xvcnM7aWYoY29sb3JzJiYhcHJvcC5idWJibGUpe2Zvcih2YXIgaT0wO2k8Y29sb3JzLmxlbmd0aDsrK2kpe2NvbG9yc1tpXT1SRy5TVkcucGFyc2VDb2xvckxpbmVhcih7b2JqZWN0OnRoaXMsY29sb3I6Y29sb3JzW2ldfSk7fX1cbnByb3AuYmFja2dyb3VuZEdyaWRDb2xvcj1SRy5TVkcucGFyc2VDb2xvckxpbmVhcih7b2JqZWN0OnRoaXMsY29sb3I6cHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yfSk7cHJvcC5oaWdobGlnaHRGaWxsPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmhpZ2hsaWdodEZpbGx9KTtwcm9wLmJhY2tncm91bmRDb2xvcj1SRy5TVkcucGFyc2VDb2xvckxpbmVhcih7b2JqZWN0OnRoaXMsY29sb3I6cHJvcC5iYWNrZ3JvdW5kQ29sb3J9KTt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5SRy5TVkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLHR5cGUsZnVuYyk7cmV0dXJuIHRoaXM7fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5yZW1vdmVIaWdobGlnaHQ9ZnVuY3Rpb24oKVxue3ZhciBoaWdobGlnaHQ9UkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO2lmKGhpZ2hsaWdodCl7aGlnaGxpZ2h0LnNldEF0dHJpYnV0ZSgnZmlsbCcsJ3RyYW5zcGFyZW50Jyk7UkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsbnVsbCk7fX07fTtyZXR1cm4gdGhpczt9KSh3aW5kb3csZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5zY2F0dGVyLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///247\n");

/***/ }),
/* 248 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.SemiCircularProgress = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.min = RG.SVG.stringsToNumbers(conf.min);\n        this.max = RG.SVG.stringsToNumbers(conf.max);\n        this.value = RG.SVG.stringsToNumbers(conf.value);\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = conf.data;\n        this.type = 'semicircularprogress';\n        this.angles = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            width: 60,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundStrokeLinewidth: 0.25,\n            backgroundStroke: 'gray',\n            backgroundFill: 'Gradient(white:#aaa)',\n            backgroundFillOpacity: 0.25,\n\n            colors: ['#0c0'],\n            strokestyle: '#666',\n\n            textColor: 'gray',\n            textFont: 'sans-serif',\n            textSize: 10,\n            textBold: false,\n            textItalic: false,\n            unitsPre: '',\n            unitsPost: '',\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleDecimals: 0,\n            scaleFormatter: null,\n\n            labelsMin: true,\n            labelsMinSpecific: null,\n            labelsMinPoint: null,\n            labelsMinThousand: null,\n            labelsMinFormatter: null,\n            labelsMinFont: null,\n            labelsMinSize: null,\n            labelsMinBold: null,\n            labelsMinItalic: null,\n            labelsMinColor: null,\n            labelsMinDecimals: null,\n            labelsMinUnitsPre: null,\n            labelsMinUnitsPost: null,\n\n            labelsMax: true,\n            labelsMaxSpecific: null,\n            labelsMaxPoint: null,\n            labelsMaxThousand: null,\n            labelsMaxFormatter: null,\n            labelsMaxFont: null,\n            labelsMaxSize: null,\n            labelsMaxBold: null,\n            labelsMaxItalic: null,\n            labelsMaxColor: null,\n            labelsMaxDecimals: null,\n            labelsMaxUnitsPre: null,\n            labelsMaxUnitsPost: null,\n\n            labelsCenter: true,\n            labelsCenterSpecific: null,\n            labelsCenterPoint: null,\n            labelsCenterThousand: null,\n            labelsCenterFormatter: null,\n            labelsCenterFont: null,\n            labelsCenterSize: 40,\n            labelsCenterBold: true,\n            labelsCenterItalic: null,\n            labelsCenterColor: '#666',\n            labelsCenterDecimals: null,\n            labelsCenterUnitsPre: null,\n            labelsCenterUnitsPost: null,\n\n            linewidth: 0,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false\n\n            //shadow: false,\n            //shadowOffsetx: 2,\n            //shadowOffsety: 2,\n            //shadowBlur: 2,\n            //shadowOpacity: 0.25\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            // Add these\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.height - prop.gutterBottom;\n            this.radius = ma.min(this.graphWidth / 2, this.graphHeight);\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            // Set the width of the meter\n            this.progressWidth = prop.width || this.radius / 3;\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            // Draw the segments\n            this.path = this.drawMeter();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Add the tooltip event listener\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[0]) {\n\n                var obj = this;\n\n                //\n                // Add tooltip event listeners\n                //\n                this.path.addEventListener(prop.tooltipsEvent, function (e) {\n                    obj.removeHighlight();\n\n                    // Show the tooltip\n                    RG.SVG.tooltip({\n                        object: obj,\n                        index: 0,\n                        group: null,\n                        sequentialIndex: 0,\n                        text: prop.tooltips[0],\n                        event: e\n                    });\n\n                    // Highlight the rect that has been clicked on\n                    obj.highlight(e.target);\n                }, false);\n\n                this.path.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                }, false);\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draws the meter\n        //\n        this.drawMeter = function () {\n            //\n            // Draw the background to the meter\n            //\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: RG.SVG.TRIG.HALFPI,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                start: RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L \" + (this.centerx + this.radius - this.progressWidth) + \" \" + this.centery + path2 + \" L \" + (this.centerx - this.radius) + \" \" + this.centery,\n                    fill: prop.backgroundFill || prop.colors[0],\n                    stroke: prop.backgroundStroke,\n                    'stroke-width': prop.backgroundStrokeLinewidth,\n                    'fill-opacity': prop.backgroundFillOpacity\n                }\n            });\n\n            //\n            // This draws the bar that indicates the value\n            //\n            var angle = (this.value - this.min) / (this.max - this.min) * RG.SVG.TRIG.PI; // Because the Meter is always a semi-circle\n\n            // Take off half a pi because our origin is the noth axis\n            angle -= RG.SVG.TRIG.HALFPI;\n\n            // Now get the path of the inner indicator bar\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: angle,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: angle,\n                anticlockwise: false,\n                array: true\n            });\n\n            var path3 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            // Now draw the path\n            var path = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L{1} {2} \".format(path2[1], path2[2]) + path3 + ' z',\n                    fill: prop.colors[0],\n                    stroke: 'black',\n                    'stroke-width': prop.linewidth\n                }\n            });\n\n            return path;\n        };\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the min label\n            if (prop.labelsMin) {\n\n                var min = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.min.toFixed(typeof prop.labelsMinDecimals === 'number' ? prop.labelsMinDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMinUnitsPre === 'string' ? prop.labelsMinUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMinUnitsPost === 'string' ? prop.labelsMinUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMinPoint === 'string' ? prop.labelsMinPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMinThousand === 'string' ? prop.labelsMinThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMinFormatter === 'function' ? prop.labelsMinFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMinSpecific === 'string' ? prop.labelsMinSpecific : min,\n                    x: this.centerx - this.radius + this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMinFont || prop.textFont,\n                    size: prop.labelsMinSize || prop.textSize,\n                    bold: typeof prop.labelsMinBold === 'boolean' ? prop.labelsMinBold : prop.textBold,\n                    italic: typeof prop.labelsMinItalic === 'boolean' ? prop.labelsMinItalic : prop.textItalic,\n                    color: prop.labelsMinColor || prop.textColor\n                });\n            }\n\n            // Draw the max label\n            if (prop.labelsMax) {\n\n                var max = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.max.toFixed(typeof prop.labelsMaxDecimals === 'number' ? prop.labelsMaxDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMaxUnitsPre === 'string' ? prop.labelsMaxUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMaxUnitsPost === 'string' ? prop.labelsMaxUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMaxPoint === 'string' ? prop.labelsMaxPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMaxThousand === 'string' ? prop.labelsMaxThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMaxFormatter === 'function' ? prop.labelsMaxFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMaxSpecific === 'string' ? prop.labelsMaxSpecific : max,\n                    x: this.centerx + this.radius - this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMaxFont || prop.textFont,\n                    size: prop.labelsMaxSize || prop.textSize,\n                    bold: typeof prop.labelsMaxBold === 'boolean' ? prop.labelsMaxBold : prop.textBold,\n                    italic: typeof prop.labelsMaxItalic === 'boolean' ? prop.labelsMaxItalic : prop.textItalic,\n                    color: prop.labelsMaxColor || prop.textColor\n                });\n            }\n\n            // Draw the center label\n            if (prop.labelsCenter) {\n\n                var center = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.value.toFixed(typeof prop.labelsCenterDecimals === 'number' ? prop.labelsCenterDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsCenterUnitsPre === 'string' ? prop.labelsCenterUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsCenterUnitsPost === 'string' ? prop.labelsCenterUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsCenterPoint === 'string' ? prop.labelsCenterPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsCenterThousand === 'string' ? prop.labelsCenterThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsCenterFormatter === 'function' ? prop.labelsCenterFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsCenterSpecific === 'string' ? prop.labelsCenterSpecific : center,\n                    x: this.centerx,\n                    y: this.centery,\n                    valign: 'bottom',\n                    halign: 'center',\n                    font: prop.labelsCenterFont || prop.textFont,\n                    size: prop.labelsCenterSize || prop.textSize,\n                    bold: typeof prop.labelsCenterBold === 'boolean' ? prop.labelsCenterBold : prop.textBold,\n                    italic: typeof prop.labelsCenterItalic === 'boolean' ? prop.labelsCenterItalic : prop.textItalic,\n                    color: prop.labelsCenterColor || prop.textColor\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        *\n        * @param object segment The segment to highlight\n        */\n        this.highlight = function (segment) {\n            // Remove any highlight that's already been\n            // installed\n            this.removeHighlight();\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: this.path.getAttribute('d'),\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            // Store the highlight node in the registry\n            RG.SVG.REG.set('highlight', highlight);\n\n            // Add the event listener that clears the highlight path if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n        };\n\n        /**\n        * This function can be used to remove the highlight that is added\n        * by tooltips\n        */\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight) {\n                highlight.parentNode.removeChild(highlight);\n                highlight = null;\n            }\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill),\n                    backgroundColor: RG.SVG.arrayClone(prop.backgroundColor)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorLinear({\n                        object: this,\n                        color: colors[i],\n                        start: this.centerx - this.radius,\n                        end: this.centerx + this.radius,\n                        direction: 'horizontal'\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.highlightFill,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n\n            // Background color\n\n            // Background color\n            prop.backgroundColor = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.backgroundColor,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n        };\n\n        //\n        // The Bar chart grow effect\n        //\n        this.grow = function () {\n            var opt = arguments[0] || {},\n                frames = opt.frames || 30,\n                frame = 0,\n                obj = this,\n                value = opt.value;\n\n            //\n            // Copy the data\n            //\n            value = this.value;\n\n            this.draw();\n\n            var iterate = function iterate() {\n                var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);\n\n                obj.value = value * multiplier;\n\n                RG.SVG.redraw();\n\n                if (frame++ < frames) {\n                    RG.SVG.FX.update(iterate);\n                } else if (opt.callback) {\n                    obj.value = value;\n                    RG.SVG.redraw();\n                    opt.callback(obj);\n                }\n            };\n\n            iterate();\n\n            return this;\n        };\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        *\n        * @param string   type The type of even to add\n        * @param function func\n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        //\n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Remove highlight from the chart (tooltips)\n        //\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n            if (highlight && highlight.parentNode) {\n                highlight.parentNode.removeChild(highlight);\n            }\n\n            RG.SVG.REG.set('highlight', null);\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLnNlbWljaXJjdWxhcnByb2dyZXNzLmpzPzllMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmVyc2lvbjogMjAxNy0wNS0wOFxuICAgIC8qKlxuICAgICogby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tb1xuICAgICogfCBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgUkdyYXBoIHBhY2thZ2UgLSB5b3UgY2FuIGxlYXJuIG1vcmUgYXQ6ICAgICAgICAgICAgICAgfFxuICAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy5yZ3JhcGgubmV0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogfCBSR3JhcGggaXMgbGljZW5zZWQgdW5kZXIgdGhlIE9wZW4gU291cmNlIE1JVCBsaWNlbnNlLiBUaGF0IG1lYW5zIHRoYXQgaXQncyAgICAgfFxuICAgICogfCB0b3RhbGx5IGZyZWUgdG8gdXNlISAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tb1xuICAgICovXG5cbiAgICBSR3JhcGggICAgID0gd2luZG93LlJHcmFwaCB8fCB7aXNSR3JhcGg6IHRydWV9O1xuICAgIFJHcmFwaC5TVkcgPSBSR3JhcGguU1ZHIHx8IHt9O1xuXG4vLyBNb2R1bGUgcGF0dGVyblxuKGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKVxue1xuICAgIHZhciBSRyAgPSBSR3JhcGgsXG4gICAgICAgIHVhICA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIG1hICA9IE1hdGgsXG4gICAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgICAgZG9jID0gZG9jdW1lbnQ7XG5cblxuXG4gICAgUkcuU1ZHLlNlbWlDaXJjdWxhclByb2dyZXNzID0gZnVuY3Rpb24gKGNvbmYpXG4gICAge1xuICAgICAgICAvL1xuICAgICAgICAvLyBBIHNldHRlciB0aGF0IHRoZSBjb25zdHJ1Y3RvciB1c2VzIChhdCB0aGUgZW5kKVxuICAgICAgICAvLyB0byBzZXQgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEBwYXJhbSBzdHJpbmcgbmFtZSAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAgICAvLyBAcGFyYW0gc3RyaW5nIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIGFyZ3VtZW50c1swXVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgID0gcmV0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJldC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmFtZSAgPSByZXQubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJldC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIHRoaXMubWluICAgICAgICAgICAgID0gUkcuU1ZHLnN0cmluZ3NUb051bWJlcnMoY29uZi5taW4pO1xuICAgICAgICB0aGlzLm1heCAgICAgICAgICAgICA9IFJHLlNWRy5zdHJpbmdzVG9OdW1iZXJzKGNvbmYubWF4KTtcbiAgICAgICAgdGhpcy52YWx1ZSAgICAgICAgICAgPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyhjb25mLnZhbHVlKTtcbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgPSBjb25mLmlkO1xuICAgICAgICB0aGlzLnVpZCAgICAgICAgICAgICA9IFJHLlNWRy5jcmVhdGVVSUQoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5zdmcgICAgICAgICAgICAgPSBSRy5TVkcuY3JlYXRlU1ZHKHtjb250YWluZXI6IHRoaXMuY29udGFpbmVyfSk7XG4gICAgICAgIHRoaXMuaXNSR3JhcGggICAgICAgID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53aWR0aCAgICAgICAgICAgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgICAgICAgICAgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgICAgIHRoaXMuZGF0YSAgICAgICAgICAgID0gY29uZi5kYXRhO1xuICAgICAgICB0aGlzLnR5cGUgICAgICAgICAgICA9ICdzZW1pY2lyY3VsYXJwcm9ncmVzcyc7XG4gICAgICAgIHRoaXMuYW5nbGVzICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuY29sb3JzUGFyc2VkICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgID0ge307XG4gICAgICAgIHRoaXMuZ3JhZGllbnRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5ub2RlcyAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5zaGFkb3dOb2RlcyAgICAgPSBbXTtcblxuICAgICAgICAvLyBBZGQgdGhpcyBvYmplY3QgdG8gdGhlIE9iamVjdFJlZ2lzdHJ5XG4gICAgICAgIFJHLlNWRy5PUi5hZGQodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBESVYgY29udGFpbmVyIHRvIGJlIGlubGluZS1ibG9ja1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG5cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID1cbiAgICAgICAge1xuICAgICAgICAgICAgY2VudGVyeDogbnVsbCxcbiAgICAgICAgICAgIGNlbnRlcnk6IG51bGwsXG4gICAgICAgICAgICByYWRpdXM6ICBudWxsLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB3aWR0aDogNjAsXG5cbiAgICAgICAgICAgIGd1dHRlckxlZnQ6ICAgIDM1LFxuICAgICAgICAgICAgZ3V0dGVyUmlnaHQ6ICAgMzUsXG4gICAgICAgICAgICBndXR0ZXJUb3A6ICAgICAzNSxcbiAgICAgICAgICAgIGd1dHRlckJvdHRvbTogIDM1LFxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlTGluZXdpZHRoOiAwLjI1LFxuICAgICAgICAgICAgYmFja2dyb3VuZFN0cm9rZTogICAgICAgICAgJ2dyYXknLFxuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGw6ICAgICAgICAgICAgJ0dyYWRpZW50KHdoaXRlOiNhYWEpJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWxsT3BhY2l0eTogICAgIDAuMjUsXG5cbiAgICAgICAgICAgIGNvbG9yczogWycjMGMwJ10sXG4gICAgICAgICAgICBzdHJva2VzdHlsZTogJyM2NjYnLFxuXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICAgICAgJ2dyYXknLFxuICAgICAgICAgICAgdGV4dEZvbnQ6ICAgICAgICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIHRleHRTaXplOiAgICAgICAxMCxcbiAgICAgICAgICAgIHRleHRCb2xkOiAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHRleHRJdGFsaWM6ICAgICBmYWxzZSxcbiAgICAgICAgICAgIHVuaXRzUHJlOiAgICAgICAnJyxcbiAgICAgICAgICAgIHVuaXRzUG9zdDogICAgICAnJyxcbiAgICAgICAgICAgIHNjYWxlUG9pbnQ6ICAgICAnLicsXG4gICAgICAgICAgICBzY2FsZVRob3VzYW5kOiAgJywnLFxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsczogIDAsXG4gICAgICAgICAgICBzY2FsZUZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGFiZWxzTWluOiAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgbGFiZWxzTWluU3BlY2lmaWM6ICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluUG9pbnQ6ICAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluVGhvdXNhbmQ6ICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluRm9udDogICAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluU2l6ZTogICAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluQm9sZDogICAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluSXRhbGljOiAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluQ29sb3I6ICAgICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluRGVjaW1hbHM6ICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluVW5pdHNQcmU6ICBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluVW5pdHNQb3N0OiBudWxsLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsYWJlbHNNYXg6ICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBsYWJlbHNNYXhTcGVjaWZpYzogIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhQb2ludDogICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhUaG91c2FuZDogIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhGb250OiAgICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhTaXplOiAgICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhCb2xkOiAgICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhJdGFsaWM6ICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhDb2xvcjogICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhEZWNpbWFsczogIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhVbml0c1ByZTogIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhVbml0c1Bvc3Q6IG51bGwsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlcjogICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclNwZWNpZmljOiAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclBvaW50OiAgICAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclRob3VzYW5kOiAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlckZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlckZvbnQ6ICAgICAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclNpemU6ICAgICAgNDAsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJCb2xkOiAgICAgIHRydWUsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJJdGFsaWM6ICAgIG51bGwsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJDb2xvcjogICAgICcjNjY2JyxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlckRlY2ltYWxzOiAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclVuaXRzUHJlOiAgbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclVuaXRzUG9zdDogbnVsbCxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGluZXdpZHRoOiAwLFxuXG4gICAgICAgICAgICB0b29sdGlwczogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBzT3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwc0VmZmVjdDogJ2ZhZGUnLFxuICAgICAgICAgICAgdG9vbHRpcHNDc3NDbGFzczogJ1JHcmFwaF90b29sdGlwJyxcbiAgICAgICAgICAgIHRvb2x0aXBzRXZlbnQ6ICdjbGljaycsXG5cbiAgICAgICAgICAgIGhpZ2hsaWdodFN0cm9rZTogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgaGlnaGxpZ2h0RmlsbDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsXG4gICAgICAgICAgICBoaWdobGlnaHRMaW5ld2lkdGg6IDEsXG5cbiAgICAgICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgICAgIHRpdGxlU2l6ZTogMTYsXG4gICAgICAgICAgICB0aXRsZVg6IG51bGwsXG4gICAgICAgICAgICB0aXRsZVk6IG51bGwsXG4gICAgICAgICAgICB0aXRsZUhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB0aXRsZVZhbGlnbjogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlQ29sb3I6ICAnYmxhY2snLFxuICAgICAgICAgICAgdGl0bGVGb250OiAgIG51bGwsXG4gICAgICAgICAgICB0aXRsZUJvbGQ6ICAgZmFsc2UsXG4gICAgICAgICAgICB0aXRsZUl0YWxpYzogZmFsc2UsXG5cbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGU6ICcnLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZVNpemU6IDEwLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZVg6IG51bGwsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlWTogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVIYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZVZhbGlnbjogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVDb2xvcjogICcjYWFhJyxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVGb250OiAgIG51bGwsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlQm9sZDogICBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVJdGFsaWM6IGZhbHNlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogICAgICAgIHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblg6ICAgICAgIG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblk6ICAgICAgIG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkhyZWY6ICAgIG51bGwsLy8gRGVmYXVsdCBpcyBzZXQgaW4gUkdyYXBoLnN2Zy5jb21tb24uY29yZS5qc1xuICAgICAgICAgICAgYXR0cmlidXRpb25IYWxpZ246ICAncmlnaHQnLFxuICAgICAgICAgICAgYXR0cmlidXRpb25WYWxpZ246ICAnYm90dG9tJyxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uU2l6ZTogICAgNyxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uQ29sb3I6ICAgJ2dyYXknLFxuICAgICAgICAgICAgYXR0cmlidXRpb25Gb250OiAgICAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkl0YWxpYzogIGZhbHNlLFxuICAgICAgICAgICAgYXR0cmlidXRpb25Cb2xkOiAgICBmYWxzZVxuXG4gICAgICAgICAgICAvL3NoYWRvdzogZmFsc2UsXG4gICAgICAgICAgICAvL3NoYWRvd09mZnNldHg6IDIsXG4gICAgICAgICAgICAvL3NoYWRvd09mZnNldHk6IDIsXG4gICAgICAgICAgICAvL3NoYWRvd0JsdXI6IDIsXG4gICAgICAgICAgICAvL3NoYWRvd09wYWNpdHk6IDAuMjVcbiAgICAgICAgfTtcblxuXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFwiRGVjb3JhdGVcIiB0aGUgb2JqZWN0IHdpdGggdGhlIGdlbmVyaWMgZWZmZWN0cyBpZiB0aGUgZWZmZWN0cyBsaWJyYXJ5IGhhcyBiZWVuIGluY2x1ZGVkXG4gICAgICAgICovXG4gICAgICAgIGlmIChSRy5TVkcuRlggJiYgdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgUkcuU1ZHLkZYLmRlY29yYXRlKHRoaXMpO1xuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZHJhdyBtZXRob2QgZHJhd3MgdGhlIEJhciBjaGFydFxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBGaXJlIHRoZSBiZWZvcmVkcmF3IGV2ZW50XG4gICAgICAgICAgICBSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtcblxuXG5cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBkZWZzIHRhZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIFJHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO1xuXG5cblxuICAgICAgICAgICAgLy8gQWRkIHRoZXNlXG4gICAgICAgICAgICB0aGlzLmdyYXBoV2lkdGggID0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyTGVmdCAtIHByb3AuZ3V0dGVyUmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmdyYXBoSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tO1xuXG5cblxuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGNlbnRlciBwb2ludFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJ4ID0gKHRoaXMuZ3JhcGhXaWR0aCAvIDIpICsgcHJvcC5ndXR0ZXJMZWZ0O1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJ5ID0gdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzICA9IG1hLm1pbih0aGlzLmdyYXBoV2lkdGggLyAyLCB0aGlzLmdyYXBoSGVpZ2h0KTtcblxuXG5cbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBjYWxjdWxhdGVkIGNlbnRlcngveS9yYWRpdXNcbiAgICAgICAgICAgIHRoaXMuY2VudGVyeCA9IHR5cGVvZiBwcm9wLmNlbnRlcnggPT09ICdudW1iZXInID8gcHJvcC5jZW50ZXJ4IDogdGhpcy5jZW50ZXJ4O1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJ5ID0gdHlwZW9mIHByb3AuY2VudGVyeSA9PT0gJ251bWJlcicgPyBwcm9wLmNlbnRlcnkgOiB0aGlzLmNlbnRlcnk7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyAgPSB0eXBlb2YgcHJvcC5yYWRpdXMgID09PSAnbnVtYmVyJyA/IHByb3AucmFkaXVzICA6IHRoaXMucmFkaXVzO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGNlbnRlcngvY2VudGVyeS9yYWRpdXMgdG8gYmUgYSBwbHVzL21pbnVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wLnJhZGl1cyAgPT09ICdzdHJpbmcnICYmIHByb3AucmFkaXVzLm1hdGNoKC9eXFwrfC1cXGQrJC8pICkgICB0aGlzLnJhZGl1cyAgKz0gcGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ3N0cmluZycgJiYgcHJvcC5jZW50ZXJ4Lm1hdGNoKC9eXFwrfC1cXGQrJC8pICkgdGhpcy5jZW50ZXJ5ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ4KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcC5jZW50ZXJ5ID09PSAnc3RyaW5nJyAmJiBwcm9wLmNlbnRlcnkubWF0Y2goL15cXCt8LVxcZCskLykgKSB0aGlzLmNlbnRlcnggKz0gcGFyc2VGbG9hdChwcm9wLmNlbnRlcnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHdpZHRoIG9mIHRoZSBtZXRlclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc1dpZHRoID0gcHJvcC53aWR0aCB8fCAodGhpcy5yYWRpdXMgLyAzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb2xvcnMgZm9yIGdyYWRpZW50c1xuICAgICAgICAgICAgUkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7b2JqZWN0OnRoaXN9KTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTtcblxuXG5cblxuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBzZWdtZW50c1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5kcmF3TWV0ZXIoKTtcblxuXG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHRpdGxlIGFuZCBzdWJ0aXRsZVxuICAgICAgICAgICAgUkcuU1ZHLmRyYXdUaXRsZSh0aGlzKTtcblxuXG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGxhYmVsc1xuICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWxzKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGlvbiBsaW5rLiBJZiB5b3UncmUgYWRkaW5nIHRoaXMgZWxzZXdoZXJlIG9uIHlvdXIgcGFnZS9zaXRlXG4gICAgICAgICAgICAvLyBhbmQgeW91IGRvbid0IHdhbnQgaXQgZGlzcGxheWVkIHRoZW4gdGhlcmUgYXJlIG9wdGlvbnMgYXZhaWxhYmxlIHRvIG5vdFxuICAgICAgICAgICAgLy8gc2hvdyBpdC5cbiAgICAgICAgICAgIFJHLlNWRy5hdHRyaWJ1dGlvbih0aGlzKTtcblxuXG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdG9vbHRpcCBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgaWYgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHNbMF0pIHtcblxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG9vbHRpcCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSByZWN0IHRoYXQgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAgICAgICAgICAgICAgICBvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjbGVhcnMgdGhlIGhpZ2hsaWdodCBpZlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYW55LiBNdXN0IGJlIE1PVVNFRE9XTiAoaWUgYmVmb3JlIHRoZSBjbGljayBldmVudClcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzO1xuICAgICAgICAgICAgZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG5cblxuICAgICAgICAgICAgLy8gRmlyZSB0aGUgZHJhdyBldmVudFxuICAgICAgICAgICAgUkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7XG5cblxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERyYXdzIHRoZSBtZXRlclxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmRyYXdNZXRlciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBiYWNrZ3JvdW5kIHRvIHRoZSBtZXRlclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCh7XG4gICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgIHI6ICB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICBzdGFydDogUkcuU1ZHLlRSSUcuUEkgKyBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgZW5kOiBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBhdGgyID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCh7XG4gICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgIHI6ICB0aGlzLnJhZGl1cyAtIHRoaXMucHJvZ3Jlc3NXaWR0aCxcbiAgICAgICAgICAgICAgICBlbmQ6IFJHLlNWRy5UUklHLlBJICsgUkcuU1ZHLlRSSUcuSEFMRlBJLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb3ZldG86IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBkOiBwYXRoICsgXCIgTCBcIiArICh0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyAtIHRoaXMucHJvZ3Jlc3NXaWR0aCkgICsgXCIgXCIgKyB0aGlzLmNlbnRlcnkgKyBwYXRoMiArIFwiIEwgXCIgKyAodGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMpICsgXCIgXCIgKyB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICAgICAgICAgICBwcm9wLmJhY2tncm91bmRGaWxsIHx8IHByb3AuY29sb3JzWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICAgICAgICAgcHJvcC5iYWNrZ3JvdW5kU3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcC5iYWNrZ3JvdW5kU3Ryb2tlTGluZXdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogcHJvcC5iYWNrZ3JvdW5kRmlsbE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGRyYXdzIHRoZSBiYXIgdGhhdCBpbmRpY2F0ZXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gKCh0aGlzLnZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKSAqIFJHLlNWRy5UUklHLlBJOyAvLyBCZWNhdXNlIHRoZSBNZXRlciBpcyBhbHdheXMgYSBzZW1pLWNpcmNsZVxuXG4gICAgICAgICAgICAvLyBUYWtlIG9mZiBoYWxmIGEgcGkgYmVjYXVzZSBvdXIgb3JpZ2luIGlzIHRoZSBub3RoIGF4aXNcbiAgICAgICAgICAgIGFuZ2xlIC09IFJHLlNWRy5UUklHLkhBTEZQSTtcblxuXG4gICAgICAgICAgICAvLyBOb3cgZ2V0IHRoZSBwYXRoIG9mIHRoZSBpbm5lciBpbmRpY2F0b3IgYmFyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgoe1xuICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICByOiAgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IFJHLlNWRy5UUklHLlBJICsgUkcuU1ZHLlRSSUcuSEFMRlBJLFxuICAgICAgICAgICAgICAgIGVuZDogYW5nbGUsXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGF0aDIgPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHtcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgcjogIHRoaXMucmFkaXVzIC0gdGhpcy5wcm9ncmVzc1dpZHRoLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBhbmdsZSxcbiAgICAgICAgICAgICAgICBlbmQ6IGFuZ2xlLFxuICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFycmF5OiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHBhdGgzID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCh7XG4gICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgIHI6ICB0aGlzLnJhZGl1cyAtIHRoaXMucHJvZ3Jlc3NXaWR0aCxcbiAgICAgICAgICAgICAgICBzdGFydDogYW5nbGUsXG4gICAgICAgICAgICAgICAgZW5kOiBSRy5TVkcuVFJJRy5QSSArIFJHLlNWRy5UUklHLkhBTEZQSSxcbiAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1vdmV0bzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5vdyBkcmF3IHRoZSBwYXRoXG4gICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgZDogcGF0aCArIFwiIEx7MX0gezJ9IFwiLmZvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgyWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDJbMl1cbiAgICAgICAgICAgICAgICAgICAgKSArIHBhdGgzICsgJyB6JyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcC5jb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRHJhdyB0aGUgbGFiZWxzXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIG1pbiBsYWJlbFxuICAgICAgICAgICAgaWYgKHByb3AubGFiZWxzTWluKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWluID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbnVtOiAgICAgICB0aGlzLm1pbi50b0ZpeGVkKHR5cGVvZiBwcm9wLmxhYmVsc01pbkRlY2ltYWxzID09PSAnbnVtYmVyJyA/IHByb3AubGFiZWxzTWluRGVjaW1hbHMgOiBwcm9wLnNjYWxlRGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kOiAgIHR5cGVvZiBwcm9wLmxhYmVsc01pblVuaXRzUHJlICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWluVW5pdHNQcmUgIDogcHJvcC51bml0c1ByZSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kOiAgICB0eXBlb2YgcHJvcC5sYWJlbHNNaW5Vbml0c1Bvc3QgPT09ICdzdHJpbmcnICAgPyBwcm9wLmxhYmVsc01pblVuaXRzUG9zdCA6IHByb3AudW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogICAgIHR5cGVvZiBwcm9wLmxhYmVsc01pblBvaW50ICAgICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWluUG9pbnQgICAgIDogcHJvcC5zY2FsZVBvaW50LFxuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogIHR5cGVvZiBwcm9wLmxhYmVsc01pblRob3VzYW5kICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWluVGhvdXNhbmQgIDogcHJvcC5zY2FsZVRob3VzYW5kLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHR5cGVvZiBwcm9wLmxhYmVsc01pbkZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3AubGFiZWxzTWluRm9ybWF0dGVyIDogcHJvcC5zY2FsZUZvcm1hdHRlclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2YgcHJvcC5sYWJlbHNNaW5TcGVjaWZpYyA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc01pblNwZWNpZmljIDogbWluLFxuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyArICh0aGlzLnByb2dyZXNzV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIDUsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6ICAgcHJvcC5sYWJlbHNNaW5Gb250ICAgfHwgcHJvcC50ZXh0Rm9udCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogICBwcm9wLmxhYmVsc01pblNpemUgICB8fCBwcm9wLnRleHRTaXplLFxuICAgICAgICAgICAgICAgICAgICBib2xkOiAgIHR5cGVvZiBwcm9wLmxhYmVsc01pbkJvbGQgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzTWluQm9sZCA6IHByb3AudGV4dEJvbGQsXG4gICAgICAgICAgICAgICAgICAgIGl0YWxpYzogdHlwZW9mIHByb3AubGFiZWxzTWluSXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc01pbkl0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICBwcm9wLmxhYmVsc01pbkNvbG9yICB8fCBwcm9wLnRleHRDb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIG1heCBsYWJlbFxuICAgICAgICAgICAgaWYgKHByb3AubGFiZWxzTWF4KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbnVtOiAgICAgICB0aGlzLm1heC50b0ZpeGVkKHR5cGVvZiBwcm9wLmxhYmVsc01heERlY2ltYWxzID09PSAnbnVtYmVyJyA/IHByb3AubGFiZWxzTWF4RGVjaW1hbHMgOiBwcm9wLnNjYWxlRGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kOiAgIHR5cGVvZiBwcm9wLmxhYmVsc01heFVuaXRzUHJlICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWF4VW5pdHNQcmUgIDogcHJvcC51bml0c1ByZSxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kOiAgICB0eXBlb2YgcHJvcC5sYWJlbHNNYXhVbml0c1Bvc3QgPT09ICdzdHJpbmcnICAgPyBwcm9wLmxhYmVsc01heFVuaXRzUG9zdCA6IHByb3AudW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogICAgIHR5cGVvZiBwcm9wLmxhYmVsc01heFBvaW50ICAgICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWF4UG9pbnQgICAgIDogcHJvcC5zY2FsZVBvaW50LFxuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogIHR5cGVvZiBwcm9wLmxhYmVsc01heFRob3VzYW5kICA9PT0gJ3N0cmluZycgICA/IHByb3AubGFiZWxzTWF4VGhvdXNhbmQgIDogcHJvcC5zY2FsZVRob3VzYW5kLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHR5cGVvZiBwcm9wLmxhYmVsc01heEZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3AubGFiZWxzTWF4Rm9ybWF0dGVyIDogcHJvcC5zY2FsZUZvcm1hdHRlclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2YgcHJvcC5sYWJlbHNNYXhTcGVjaWZpYyA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc01heFNwZWNpZmljIDogbWF4LFxuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyAtICh0aGlzLnByb2dyZXNzV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIDUsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6ICAgcHJvcC5sYWJlbHNNYXhGb250ICAgfHwgcHJvcC50ZXh0Rm9udCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogICBwcm9wLmxhYmVsc01heFNpemUgICB8fCBwcm9wLnRleHRTaXplLFxuICAgICAgICAgICAgICAgICAgICBib2xkOiAgIHR5cGVvZiBwcm9wLmxhYmVsc01heEJvbGQgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzTWF4Qm9sZCA6IHByb3AudGV4dEJvbGQsXG4gICAgICAgICAgICAgICAgICAgIGl0YWxpYzogdHlwZW9mIHByb3AubGFiZWxzTWF4SXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc01heEl0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICBwcm9wLmxhYmVsc01heENvbG9yICB8fCBwcm9wLnRleHRDb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgLy8gRHJhdyB0aGUgY2VudGVyIGxhYmVsXG4gICAgICAgICAgICBpZiAocHJvcC5sYWJlbHNDZW50ZXIpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBSRy5TVkcubnVtYmVyRm9ybWF0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBudW06ICAgICAgIHRoaXMudmFsdWUudG9GaXhlZCh0eXBlb2YgcHJvcC5sYWJlbHNDZW50ZXJEZWNpbWFscyA9PT0gJ251bWJlcicgPyBwcm9wLmxhYmVsc0NlbnRlckRlY2ltYWxzIDogcHJvcC5zY2FsZURlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZDogICB0eXBlb2YgcHJvcC5sYWJlbHNDZW50ZXJVbml0c1ByZSAgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNDZW50ZXJVbml0c1ByZSAgOiBwcm9wLnVuaXRzUHJlLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmQ6ICAgIHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclVuaXRzUG9zdCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0NlbnRlclVuaXRzUG9zdCA6IHByb3AudW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogICAgIHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclBvaW50ICAgICA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0NlbnRlclBvaW50ICAgICA6IHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdGhvdXNhbmQ6ICB0eXBlb2YgcHJvcC5sYWJlbHNDZW50ZXJUaG91c2FuZCAgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNDZW50ZXJUaG91c2FuZCAgOiBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdHlwZW9mIHByb3AubGFiZWxzQ2VudGVyRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nID8gcHJvcC5sYWJlbHNDZW50ZXJGb3JtYXR0ZXIgOiBwcm9wLnNjYWxlRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBSRy5TVkcudGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICAgdHlwZW9mIHByb3AubGFiZWxzQ2VudGVyU3BlY2lmaWMgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNDZW50ZXJTcGVjaWZpYyA6IGNlbnRlcixcbiAgICAgICAgICAgICAgICAgICAgeDogICAgICB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgICAgIHk6ICAgICAgdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdib3R0b20nLFxuICAgICAgICAgICAgICAgICAgICBoYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBmb250OiAgIHByb3AubGFiZWxzQ2VudGVyRm9udCAgIHx8IHByb3AudGV4dEZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6ICAgcHJvcC5sYWJlbHNDZW50ZXJTaXplICAgfHwgcHJvcC50ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogICB0eXBlb2YgcHJvcC5sYWJlbHNDZW50ZXJCb2xkID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc0NlbnRlckJvbGQgOiBwcm9wLnRleHRCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWM6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlckl0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNDZW50ZXJJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAgcHJvcC5sYWJlbHNDZW50ZXJDb2xvciAgfHwgcHJvcC50ZXh0Q29sb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaGlnaGxpZ2h0IGEgc2VnbWVudCBvbiB0aGUgY2hhcnRcbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBvYmplY3Qgc2VnbWVudCBUaGUgc2VnbWVudCB0byBoaWdobGlnaHRcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAoc2VnbWVudClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBoaWdobGlnaHQgdGhhdCdzIGFscmVhZHkgYmVlblxuICAgICAgICAgICAgLy8gaW5zdGFsbGVkXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBkOiB0aGlzLnBhdGguZ2V0QXR0cmlidXRlKCdkJyksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHByb3AuaGlnaGxpZ2h0RmlsbCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwcm9wLmhpZ2hsaWdodFN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AuaGlnaGxpZ2h0TGluZXdpZHRoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBoaWdobGlnaHQgbm9kZSBpbiB0aGUgcmVnaXN0cnlcbiAgICAgICAgICAgIFJHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLCBoaWdobGlnaHQpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2xlYXJzIHRoZSBoaWdobGlnaHQgcGF0aCBpZlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYW55LiBNdXN0IGJlIE1PVVNFRE9XTiAoaWUgYmVmb3JlIHRoZSBjbGljayBldmVudClcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzO1xuICAgICAgICAgICAgZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgaGlnaGxpZ2h0IHRoYXQgaXMgYWRkZWRcbiAgICAgICAgKiBieSB0b29sdGlwc1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGFsbG93cyBmb3IgZWFzeSBzcGVjaWZpY2F0aW9uIG9mIGdyYWRpZW50c1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgY29sb3JzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdG9yZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlc2V0XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogICAgICAgICAgUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLFxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRGaWxsOiAgIFJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGNvbG9yc1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IHByb3AuY29sb3JzO1xuXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgZmlsbFxuICAgICAgICAgICAgcHJvcC5oaWdobGlnaHRGaWxsID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe1xuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICBjb2xvcjogcHJvcC5oaWdobGlnaHRGaWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wLmd1dHRlckxlZnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0LFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBjb2xvclxuXG4gICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICBwcm9wLmJhY2tncm91bmRDb2xvciA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgY29sb3I6IHByb3AuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wLmd1dHRlckxlZnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0LFxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIEJhciBjaGFydCBncm93IGVmZmVjdFxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0ICAgICAgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgICAgICAgZnJhbWVzICAgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICAgICAgICAgIGZyYW1lICAgID0gMCxcbiAgICAgICAgICAgICAgICBvYmogICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgPSBvcHQudmFsdWU7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBkYXRhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcblxuICAgICAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciAgIG11bHRpcGxpZXIgPSBmcmFtZSAvIGZyYW1lc1xuICAgICAgICAgICAgICAgICAgICAqIFJHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcywgZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICogUkcuU1ZHLkZYLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLCBmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICBvYmoudmFsdWUgPSB2YWx1ZSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnJlZHJhdygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBvYmoudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAob3B0LmNhbGxiYWNrKShvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgKiBVc2luZyBhIGZ1bmN0aW9uIHRvIGFkZCBldmVudHMgbWFrZXMgaXQgZWFzaWVyIHRvIGZhY2lsaXRhdGUgbWV0aG9kXG4gICAgICAgICogY2hhaW5pbmdcbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBzdHJpbmcgICB0eXBlIFRoZSB0eXBlIG9mIGV2ZW4gdG8gYWRkXG4gICAgICAgICogQHBhcmFtIGZ1bmN0aW9uIGZ1bmNcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZS5zdWJzdHIoMCwyKSAhPT0gJ29uJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVXNlZCBpbiBjaGFpbmluZy4gUnVucyBhIGZ1bmN0aW9uIHRoZXJlIGFuZCB0aGVuIC0gbm90IHdhaXRpbmcgZm9yXG4gICAgICAgIC8vIHRoZSBldmVudHMgdG8gZmlyZSAoZWcgdGhlIG9uYmVmb3JlZHJhdyBldmVudClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQHBhcmFtIGZ1bmN0aW9uIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZ1bmModGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVtb3ZlIGhpZ2hsaWdodCBmcm9tIHRoZSBjaGFydCAodG9vbHRpcHMpXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHQgJiYgaGlnaGxpZ2h0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICAgIH07XG5cblxuXG5cblxuXG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBTZXQgdGhlIG9wdGlvbnMgdGhhdCB0aGUgdXNlciBoYXMgcHJvdmlkZWRcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpIGluIGNvbmYub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIFxuICAgIFxuICAgIHJldHVybiB0aGlzO1xuXG5cblxuXG4vLyBFbmQgbW9kdWxlIHBhdHRlcm5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5zZW1pY2lyY3VsYXJwcm9ncmVzcy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1SEE7QUFDQTtBQWtJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBSkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQVBBO0FBSkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFRQTs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFKQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQVFBOzs7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBOzs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///248\n");

/***/ }),
/* 249 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Waterfall = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'waterfall';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['black', 'red', 'blue'], colorsSequential: false, strokestyle: '#aaa', strokestyleConnector: null, total: true, hmargin: 5, linewidth: 1, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 5, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, yaxisTextFont: null, yaxisTextSize: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.5)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();if (prop.total) {\n        var sum = RG.SVG.arraySum(this.data);this.data.push(sum);if (prop.xaxisLabels && prop.xaxisLabels.length === this.data.length - 1) {\n          prop.xaxisLabels.push('');\n        }\n      }\n      for (var i = 0, max = 0, runningTotal = 0; i < this.data.length - (prop.total ? 1 : 0); ++i) {\n        runningTotal += this.data[i];\n        max = ma.max(max, runningTotal);\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawBars();this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;var innerWidth = this.graphWidth / this.data.length - 2 * prop.hmargin,\n          outerWidth = this.graphWidth / this.data.length;var y = this.getYCoord(0),\n          total = 0;for (var i = 0; i < this.data.length; ++i) {\n        var prevValue = this.data[i - 1],\n            nextValue = this.data[i + 1],\n            currentValue = this.data[i],\n            prevTotal = total;total += parseFloat(this.data[i]) || 0;var height = ma.abs(this.data[i] / (this.scale.max - this.scale.min) * this.graphHeight);if (prevValue === null) {\n          if (currentValue > 0) {\n            y = this.getYCoord(prevTotal) - height;\n          } else {\n            y = this.getYCoord(prevTotal);\n          }\n        } else {\n          if (i == 0 && this.data[i] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight - height;\n          } else if (this.data[i] < 0 && this.data[i - 1] > 0) {} else if (this.data[i] < 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight;\n          }\n        }\n        var fill = this.data[i] > 0 ? prop.colors[0] : prop.colors[1];if (prop.colorsSequential) {\n          fill = prop.colors[i];\n        }\n        if (i === this.data.length - 1 && this.data[this.data.length - 1] >= 0) {\n          y = this.getYCoord(0) - height;if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        } else if (i === this.data.length - 1 && this.data[this.data.length - 1] < 0) {\n          y = this.getYCoord(0);if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        }\n        var x = prop.gutterLeft + outerWidth * i + prop.hmargin;if (this.data[i] === null || typeof this.data[i] === 'undefined') {\n          var axisY = this.getYCoord(0);if (prevValue < 0) {\n            y = prevY + prevHeight;\n          } else {\n            y = prevY;\n          }\n          height = this.getYCoord(0) - this.getYCoord(total);if (!prop.colorsSequential) {\n            fill = prop.colors[3] || prop.colors[2];\n          }\n          if (height < 0) {\n            y += height;height *= -1;\n          }\n        }\n        var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { x: x, y: y, width: innerWidth, height: height, stroke: prop.strokestyle, fill: fill, 'stroke-width': prop.linewidth, 'shape-rendering': 'crispEdges', 'data-index': i, 'data-original-x': x, 'data-original-y': y, 'data-original-width': innerWidth, 'data-original-height': height, 'data-original-stroke': prop.strokestyle, 'data-original-fill': fill, 'data-value': String(this.data[i]) } });this.coords[i] = { object: rect, x: x, y: y, width: innerWidth, height: height };if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[i]) {\n          var obj = this;(function (idx) {\n            rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, text: prop.tooltips[idx], event: e });obj.highlight(e.target);\n            }, false);rect.addEventListener('mousemove', function (e) {\n              e.target.style.cursor = 'pointer';\n            }, false);\n          })(i);\n        }\n        var prevX = x,\n            prevY = y,\n            prevWidth = innerWidth,\n            prevHeight = height,\n            prevValue = this.data[i];\n      }\n      for (var i = 0; i < this.coords.length; ++i) {\n        if (this.coords[i + 1] && this.coords[i + 1].object) {\n          var x1 = Number(this.coords[i].object.getAttribute('x')) + Number(this.coords[i].object.getAttribute('width')),\n              y1 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height'))),\n              x2 = x1 + 2 * prop.hmargin,\n              y2 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height')));if (this.coords[i].object.getAttribute('data-value') === 'null') {\n            y1 = parseFloat(this.coords[i].object.getAttribute('y'));y2 = parseFloat(y1);\n          }\n          var line = RG.SVG.create({ svg: this.svg, type: 'line', parent: this.svg.all, attr: { x1: x1, y1: y1 + 0.5, x2: x2, y2: y2 + 0.5, stroke: prop.strokestyleConnector || prop.strokestyle, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-x1': x1, 'data-original-y1': y1 + 0.5, 'data-original-x2': x2, 'data-original-y2': y2 + 0.5 } });\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var total = 0;for (var i = 0; i < this.coords.length; ++i) {\n          var num = this.data[i],\n              total = total + num;if (typeof num === 'number' || RG.SVG.isNull(num)) {\n            if (RG.SVG.isNull(num)) {\n              num = total;\n            }\n            var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[i] === 'string' || typeof prop.labelsAboveSpecific[i] === 'number')) {\n              str = prop.labelsAboveSpecific[i];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[i] !== 'string' && typeof prop.labelsAboveSpecific[i] !== 'number') {\n              continue;\n            }\n            var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (this.data[i] >= 0) {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n            } else {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;return this;\n    };this.wave = function () {\n      return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLndhdGVyZmFsbC5qcz80ZjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoPXdpbmRvdy5SR3JhcGh8fHtpc1JHcmFwaDp0cnVlfTtSR3JhcGguU1ZHPVJHcmFwaC5TVkd8fHt9OyhmdW5jdGlvbih3aW4sZG9jLHVuZGVmaW5lZClcbnt2YXIgUkc9UkdyYXBoLHVhPW5hdmlnYXRvci51c2VyQWdlbnQsbWE9TWF0aCx3aW49d2luZG93LGRvYz1kb2N1bWVudDtSRy5TVkcuV2F0ZXJmYWxsPWZ1bmN0aW9uKGNvbmYpXG57dGhpcy5zZXQ9ZnVuY3Rpb24obmFtZSx2YWx1ZSlcbntpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdHlwZW9mIG5hbWU9PT0nb2JqZWN0Jyl7Zm9yKGkgaW4gYXJndW1lbnRzWzBdKXtpZih0eXBlb2YgaT09PSdzdHJpbmcnKXt2YXIgcmV0PVJHLlNWRy5jb21tb25TZXR0ZXIoe29iamVjdDp0aGlzLG5hbWU6aSx2YWx1ZTphcmd1bWVudHNbMF1baV19KTtuYW1lPXJldC5uYW1lO3ZhbHVlPXJldC52YWx1ZTt0aGlzLnNldChuYW1lLHZhbHVlKTt9fX1lbHNle3ZhciByZXQ9UkcuU1ZHLmNvbW1vblNldHRlcih7b2JqZWN0OnRoaXMsbmFtZTpuYW1lLHZhbHVlOnZhbHVlfSk7bmFtZT1yZXQubmFtZTt2YWx1ZT1yZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdPXZhbHVlO31cbnJldHVybiB0aGlzO307dGhpcy5pZD1jb25mLmlkO3RoaXMudWlkPVJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLnN2Zz1SRy5TVkcuY3JlYXRlU1ZHKHtjb250YWluZXI6dGhpcy5jb250YWluZXJ9KTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy53aWR0aD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTt0aGlzLmhlaWdodD1OdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7dGhpcy5kYXRhPWNvbmYuZGF0YTt0aGlzLnR5cGU9J3dhdGVyZmFsbCc7dGhpcy5jb29yZHM9W107dGhpcy5jb2xvcnNQYXJzZWQ9ZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycz17fTt0aGlzLmdyYWRpZW50Q291bnRlcj0xO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheT0naW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXM9e2d1dHRlckxlZnQ6MzUsZ3V0dGVyUmlnaHQ6MzUsZ3V0dGVyVG9wOjM1LGd1dHRlckJvdHRvbTozNSxiYWNrZ3JvdW5kQ29sb3I6bnVsbCxiYWNrZ3JvdW5kSW1hZ2U6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VBc3BlY3Q6J25vbmUnLGJhY2tncm91bmRJbWFnZVN0cmV0Y2g6dHJ1ZSxiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5Om51bGwsYmFja2dyb3VuZEltYWdlWDpudWxsLGJhY2tncm91bmRJbWFnZVk6bnVsbCxiYWNrZ3JvdW5kSW1hZ2VXOm51bGwsYmFja2dyb3VuZEltYWdlSDpudWxsLGJhY2tncm91bmRHcmlkOnRydWUsYmFja2dyb3VuZEdyaWRDb2xvcjonI2RkZCcsYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6MSxiYWNrZ3JvdW5kR3JpZEhsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZFZsaW5lczp0cnVlLGJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQ6bnVsbCxiYWNrZ3JvdW5kR3JpZEJvcmRlcjp0cnVlLGNvbG9yczpbJ2JsYWNrJywncmVkJywnYmx1ZSddLGNvbG9yc1NlcXVlbnRpYWw6ZmFsc2Usc3Ryb2tlc3R5bGU6JyNhYWEnLHN0cm9rZXN0eWxlQ29ubmVjdG9yOm51bGwsdG90YWw6dHJ1ZSxobWFyZ2luOjUsbGluZXdpZHRoOjEseWF4aXM6dHJ1ZSx5YXhpc1RpY2ttYXJrczp0cnVlLHlheGlzVGlja21hcmtzTGVuZ3RoOjUseWF4aXNDb2xvcjonYmxhY2snLHlheGlzU2NhbGU6dHJ1ZSx5YXhpc0xhYmVsczpudWxsLHlheGlzTGFiZWxzT2Zmc2V0eDowLHlheGlzTGFiZWxzT2Zmc2V0eTowLHlheGlzTGFiZWxzQ291bnQ6NSx5YXhpc1VuaXRzUHJlOicnLHlheGlzVW5pdHNQb3N0OicnLHlheGlzU3RyaWN0OmZhbHNlLHlheGlzRGVjaW1hbHM6MCx5YXhpc1BvaW50OicuJyx5YXhpc1Rob3VzYW5kOicsJyx5YXhpc1JvdW5kOmZhbHNlLHlheGlzTWF4Om51bGwseWF4aXNNaW46MCx5YXhpc0Zvcm1hdHRlcjpudWxsLHlheGlzVGV4dENvbG9yOm51bGwseWF4aXNUZXh0Qm9sZDpudWxsLHlheGlzVGV4dEl0YWxpYzpudWxsLHlheGlzVGV4dEZvbnQ6bnVsbCx5YXhpc1RleHRTaXplOm51bGwseGF4aXM6dHJ1ZSx4YXhpc1RpY2ttYXJrczp0cnVlLHhheGlzVGlja21hcmtzTGVuZ3RoOjUseGF4aXNMYWJlbHM6bnVsbCx4YXhpc0xhYmVsc1Bvc2l0aW9uOidzZWN0aW9uJyx4YXhpc0xhYmVsc1Bvc2l0aW9uRWRnZVRpY2ttYXJrc0NvdW50Om51bGwseGF4aXNDb2xvcjonYmxhY2snLHhheGlzTGFiZWxzT2Zmc2V0eDowLHhheGlzTGFiZWxzT2Zmc2V0eTowLGxhYmVsc0Fib3ZlOmZhbHNlLGxhYmVsc0Fib3ZlRm9udDpudWxsLGxhYmVsc0Fib3ZlU2l6ZTpudWxsLGxhYmVsc0Fib3ZlQm9sZDpudWxsLGxhYmVsc0Fib3ZlSXRhbGljOm51bGwsbGFiZWxzQWJvdmVDb2xvcjpudWxsLGxhYmVsc0Fib3ZlQmFja2dyb3VuZDoncmdiYSgyNTUsMjU1LDI1NSwwLjUpJyxsYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nOjIsbGFiZWxzQWJvdmVVbml0c1ByZTpudWxsLGxhYmVsc0Fib3ZlVW5pdHNQb3N0Om51bGwsbGFiZWxzQWJvdmVQb2ludDpudWxsLGxhYmVsc0Fib3ZlVGhvdXNhbmQ6bnVsbCxsYWJlbHNBYm92ZUZvcm1hdHRlcjpudWxsLGxhYmVsc0Fib3ZlRGVjaW1hbHM6bnVsbCxsYWJlbHNBYm92ZU9mZnNldHg6MCxsYWJlbHNBYm92ZU9mZnNldHk6MCxsYWJlbHNBYm92ZUhhbGlnbjonY2VudGVyJyxsYWJlbHNBYm92ZVZhbGlnbjonYm90dG9tJyxsYWJlbHNBYm92ZVNwZWNpZmljOm51bGwsdGV4dENvbG9yOidibGFjaycsdGV4dEZvbnQ6J3NhbnMtc2VyaWYnLHRleHRTaXplOjEyLHRleHRCb2xkOmZhbHNlLHRleHRJdGFsaWM6ZmFsc2UsdG9vbHRpcHM6bnVsbCx0b29sdGlwc092ZXJyaWRlOm51bGwsdG9vbHRpcHNFZmZlY3Q6J2ZhZGUnLHRvb2x0aXBzQ3NzQ2xhc3M6J1JHcmFwaF90b29sdGlwJyx0b29sdGlwc0V2ZW50OidjbGljaycsaGlnaGxpZ2h0U3Ryb2tlOidyZ2JhKDAsMCwwLDApJyxoaWdobGlnaHRGaWxsOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLGhpZ2hsaWdodExpbmV3aWR0aDoxLHRpdGxlOicnLHRpdGxlU2l6ZToxNix0aXRsZVg6bnVsbCx0aXRsZVk6bnVsbCx0aXRsZUhhbGlnbjonY2VudGVyJyx0aXRsZVZhbGlnbjpudWxsLHRpdGxlQ29sb3I6J2JsYWNrJyx0aXRsZUZvbnQ6bnVsbCx0aXRsZUJvbGQ6ZmFsc2UsdGl0bGVJdGFsaWM6ZmFsc2UsdGl0bGVTdWJ0aXRsZTonJyx0aXRsZVN1YnRpdGxlU2l6ZToxMCx0aXRsZVN1YnRpdGxlWDpudWxsLHRpdGxlU3VidGl0bGVZOm51bGwsdGl0bGVTdWJ0aXRsZUhhbGlnbjonY2VudGVyJyx0aXRsZVN1YnRpdGxlVmFsaWduOm51bGwsdGl0bGVTdWJ0aXRsZUNvbG9yOicjYWFhJyx0aXRsZVN1YnRpdGxlRm9udDpudWxsLHRpdGxlU3VidGl0bGVCb2xkOmZhbHNlLHRpdGxlU3VidGl0bGVJdGFsaWM6ZmFsc2Usa2V5Om51bGwsa2V5Q29sb3JzOm51bGwsa2V5T2Zmc2V0eDowLGtleU9mZnNldHk6MCxrZXlUZXh0T2Zmc2V0eDowLGtleVRleHRPZmZzZXR5Oi0xLGtleVRleHRTaXplOm51bGwsa2V5VGV4dEJvbGQ6bnVsbCxrZXlUZXh0SXRhbGljOm51bGwsYXR0cmlidXRpb246dHJ1ZSxhdHRyaWJ1dGlvblg6bnVsbCxhdHRyaWJ1dGlvblk6bnVsbCxhdHRyaWJ1dGlvbkhyZWY6bnVsbCxhdHRyaWJ1dGlvbkhhbGlnbjoncmlnaHQnLGF0dHJpYnV0aW9uVmFsaWduOidib3R0b20nLGF0dHJpYnV0aW9uU2l6ZTo3LGF0dHJpYnV0aW9uQ29sb3I6J2dyYXknLGF0dHJpYnV0aW9uRm9udDonc2Fucy1zZXJpZicsYXR0cmlidXRpb25JdGFsaWM6ZmFsc2UsYXR0cmlidXRpb25Cb2xkOmZhbHNlfTtpZihSRy5TVkcuRlgmJnR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGU9PT0nZnVuY3Rpb24nKXtSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7fVxudmFyIHByb3A9dGhpcy5wcm9wZXJ0aWVzO3RoaXMuZHJhdz1mdW5jdGlvbigpXG57UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTtSRy5TVkcuY3JlYXRlRGVmcyh0aGlzKTt0aGlzLmdyYXBoV2lkdGg9dGhpcy53aWR0aC1wcm9wLmd1dHRlckxlZnQtcHJvcC5ndXR0ZXJSaWdodDt0aGlzLmdyYXBoSGVpZ2h0PXRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyVG9wLXByb3AuZ3V0dGVyQm90dG9tO1JHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoe29iamVjdDp0aGlzfSk7dGhpcy5wYXJzZUNvbG9ycygpO2lmKHByb3AudG90YWwpe3ZhciBzdW09UkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YSk7dGhpcy5kYXRhLnB1c2goc3VtKTtpZihwcm9wLnhheGlzTGFiZWxzJiZwcm9wLnhheGlzTGFiZWxzLmxlbmd0aD09PSh0aGlzLmRhdGEubGVuZ3RoLTEpKXtwcm9wLnhheGlzTGFiZWxzLnB1c2goJycpO319XG5mb3IodmFyIGk9MCxtYXg9MCxydW5uaW5nVG90YWw9MDtpPHRoaXMuZGF0YS5sZW5ndGgtKHByb3AudG90YWw/MTowKTsrK2kpe3J1bm5pbmdUb3RhbCs9dGhpcy5kYXRhW2ldXG5tYXg9bWEubWF4KG1heCxydW5uaW5nVG90YWwpO31cbmlmKHR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicpe21heD1wcm9wLnlheGlzTWF4O31cbmlmKHByb3AueWF4aXNNaW49PT0nbWlycm9yJ3x8cHJvcC55YXhpc01pbj09PSdtaWRkbGUnfHxwcm9wLnlheGlzTWluPT09J2NlbnRlcicpe3ZhciBtaXJyb3JTY2FsZT10cnVlO3Byb3AueWF4aXNNaW49MDt9XG50aGlzLnNjYWxlPVJHLlNWRy5nZXRTY2FsZSh7b2JqZWN0OnRoaXMsbnVtbGFiZWxzOnByb3AueWF4aXNMYWJlbHNDb3VudCx1bml0c1ByZTpwcm9wLnlheGlzVW5pdHNQcmUsdW5pdHNQb3N0OnByb3AueWF4aXNVbml0c1Bvc3QsbWF4Om1heCxtaW46cHJvcC55YXhpc01pbixwb2ludDpwcm9wLnlheGlzUG9pbnQscm91bmQ6cHJvcC55YXhpc1JvdW5kLHRob3VzYW5kOnByb3AueWF4aXNUaG91c2FuZCxkZWNpbWFsczpwcm9wLnlheGlzRGVjaW1hbHMsc3RyaWN0OnR5cGVvZiBwcm9wLnlheGlzTWF4PT09J251bWJlcicsZm9ybWF0dGVyOnByb3AueWF4aXNGb3JtYXR0ZXJ9KTtpZihtaXJyb3JTY2FsZSl7dGhpcy5zY2FsZT1SRy5TVkcuZ2V0U2NhbGUoe29iamVjdDp0aGlzLG51bWxhYmVsczpwcm9wLnlheGlzTGFiZWxzQ291bnQsdW5pdHNQcmU6cHJvcC55YXhpc1VuaXRzUHJlLHVuaXRzUG9zdDpwcm9wLnlheGlzVW5pdHNQb3N0LG1heDp0aGlzLnNjYWxlLm1heCxtaW46dGhpcy5zY2FsZS5tYXgqIC0xLHBvaW50OnByb3AueWF4aXNQb2ludCxyb3VuZDpmYWxzZSx0aG91c2FuZDpwcm9wLnlheGlzVGhvdXNhbmQsZGVjaW1hbHM6cHJvcC55YXhpc0RlY2ltYWxzLHN0cmljdDp0eXBlb2YgcHJvcC55YXhpc01heD09PSdudW1iZXInLGZvcm1hdHRlcjpwcm9wLnlheGlzRm9ybWF0dGVyfSk7fVxudGhpcy5tYXg9dGhpcy5zY2FsZS5tYXg7dGhpcy5taW49dGhpcy5zY2FsZS5taW47cHJvcC55YXhpc01heD10aGlzLnNjYWxlLm1heDtwcm9wLnlheGlzTWluPXRoaXMuc2NhbGUubWluO1JHLlNWRy5kcmF3QmFja2dyb3VuZCh0aGlzKTtSRy5TVkcuZHJhd1hBeGlzKHRoaXMpO1JHLlNWRy5kcmF3WUF4aXModGhpcyk7dGhpcy5kcmF3QmFycygpO3RoaXMuZHJhd0xhYmVsc0Fib3ZlKCk7aWYodHlwZW9mIHByb3Aua2V5IT09bnVsbCYmUkcuU1ZHLmRyYXdLZXkpe1JHLlNWRy5kcmF3S2V5KHRoaXMpO31lbHNlIGlmKCFSR3JhcGguU1ZHLmlzTnVsbChwcm9wLmtleSkpe2FsZXJ0KCdUaGUgZHJhd0tleSgpIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0IC0gaGF2ZSB5b3UgZm9yZ290dGVuIHRvIGluY2x1ZGUgdGhlIGtleSBsaWJyYXJ5PycpO31cblJHLlNWRy5hdHRyaWJ1dGlvbih0aGlzKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFycz1mdW5jdGlvbigpXG57dGhpcy5ncmFwaFdpZHRoPXRoaXMud2lkdGgtcHJvcC5ndXR0ZXJMZWZ0LXByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodD10aGlzLmhlaWdodC1wcm9wLmd1dHRlclRvcC1wcm9wLmd1dHRlckJvdHRvbTt2YXIgaW5uZXJXaWR0aD0odGhpcy5ncmFwaFdpZHRoL3RoaXMuZGF0YS5sZW5ndGgpLSgyKnByb3AuaG1hcmdpbiksb3V0ZXJXaWR0aD0odGhpcy5ncmFwaFdpZHRoL3RoaXMuZGF0YS5sZW5ndGgpO3ZhciB5PXRoaXMuZ2V0WUNvb3JkKDApLHRvdGFsPTA7Zm9yKHZhciBpPTA7aTwodGhpcy5kYXRhLmxlbmd0aCk7KytpKXt2YXIgcHJldlZhbHVlPXRoaXMuZGF0YVtpLTFdLG5leHRWYWx1ZT10aGlzLmRhdGFbaSsxXSxjdXJyZW50VmFsdWU9dGhpcy5kYXRhW2ldLHByZXZUb3RhbD10b3RhbDt0b3RhbCs9cGFyc2VGbG9hdCh0aGlzLmRhdGFbaV0pfHwwO3ZhciBoZWlnaHQ9bWEuYWJzKCh0aGlzLmRhdGFbaV0vKHRoaXMuc2NhbGUubWF4LXRoaXMuc2NhbGUubWluKSkqdGhpcy5ncmFwaEhlaWdodCk7aWYocHJldlZhbHVlPT09bnVsbCl7aWYoY3VycmVudFZhbHVlPjApe3k9dGhpcy5nZXRZQ29vcmQocHJldlRvdGFsKS1oZWlnaHQ7fWVsc2V7eT10aGlzLmdldFlDb29yZChwcmV2VG90YWwpO319ZWxzZXtpZihpPT0wJiZ0aGlzLmRhdGFbaV0+MCl7eT15LWhlaWdodDt9ZWxzZSBpZih0aGlzLmRhdGFbaV0+MCYmdGhpcy5kYXRhW2ktMV0+MCl7eT15LWhlaWdodDt9ZWxzZSBpZih0aGlzLmRhdGFbaV0+MCYmdGhpcy5kYXRhW2ktMV08MCl7eT15K3ByZXZIZWlnaHQtaGVpZ2h0O31lbHNlIGlmKHRoaXMuZGF0YVtpXTwwJiZ0aGlzLmRhdGFbaS0xXT4wKXt9ZWxzZSBpZih0aGlzLmRhdGFbaV08MCYmdGhpcy5kYXRhW2ktMV08MCl7eT15K3ByZXZIZWlnaHQ7fX1cbnZhciBmaWxsPXRoaXMuZGF0YVtpXT4wP3Byb3AuY29sb3JzWzBdOnByb3AuY29sb3JzWzFdO2lmKHByb3AuY29sb3JzU2VxdWVudGlhbCl7ZmlsbD1wcm9wLmNvbG9yc1tpXTt9XG5pZihpPT09KHRoaXMuZGF0YS5sZW5ndGgtMSkmJnRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTFdPj0wKXt5PXRoaXMuZ2V0WUNvb3JkKDApLWhlaWdodDtpZighcHJvcC5jb2xvcnNTZXF1ZW50aWFsKXtmaWxsPXByb3AuY29sb3JzWzJdO319ZWxzZSBpZihpPT09KHRoaXMuZGF0YS5sZW5ndGgtMSkmJnRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoLTFdPDApe3k9dGhpcy5nZXRZQ29vcmQoMCk7aWYoIXByb3AuY29sb3JzU2VxdWVudGlhbCl7ZmlsbD1wcm9wLmNvbG9yc1syXTt9fVxudmFyIHg9cHJvcC5ndXR0ZXJMZWZ0KyhvdXRlcldpZHRoKmkpK3Byb3AuaG1hcmdpbjtpZih0aGlzLmRhdGFbaV09PT1udWxsfHx0eXBlb2YgdGhpcy5kYXRhW2ldPT09J3VuZGVmaW5lZCcpe3ZhciBheGlzWT10aGlzLmdldFlDb29yZCgwKTtpZihwcmV2VmFsdWU8MCl7eT1wcmV2WStwcmV2SGVpZ2h0O31lbHNle3k9cHJldlk7fVxuaGVpZ2h0PXRoaXMuZ2V0WUNvb3JkKDApLXRoaXMuZ2V0WUNvb3JkKHRvdGFsKTtpZighcHJvcC5jb2xvcnNTZXF1ZW50aWFsKXtmaWxsPXByb3AuY29sb3JzWzNdfHxwcm9wLmNvbG9yc1syXTt9XG5pZihoZWlnaHQ8MCl7eSs9aGVpZ2h0O2hlaWdodCo9LTE7fX1cbnZhciByZWN0PVJHLlNWRy5jcmVhdGUoe3N2Zzp0aGlzLnN2Zyx0eXBlOidyZWN0JyxwYXJlbnQ6dGhpcy5zdmcuYWxsLGF0dHI6e3g6eCx5Onksd2lkdGg6aW5uZXJXaWR0aCxoZWlnaHQ6aGVpZ2h0LHN0cm9rZTpwcm9wLnN0cm9rZXN0eWxlLGZpbGw6ZmlsbCwnc3Ryb2tlLXdpZHRoJzpwcm9wLmxpbmV3aWR0aCwnc2hhcGUtcmVuZGVyaW5nJzonY3Jpc3BFZGdlcycsJ2RhdGEtaW5kZXgnOmksJ2RhdGEtb3JpZ2luYWwteCc6eCwnZGF0YS1vcmlnaW5hbC15Jzp5LCdkYXRhLW9yaWdpbmFsLXdpZHRoJzppbm5lcldpZHRoLCdkYXRhLW9yaWdpbmFsLWhlaWdodCc6aGVpZ2h0LCdkYXRhLW9yaWdpbmFsLXN0cm9rZSc6cHJvcC5zdHJva2VzdHlsZSwnZGF0YS1vcmlnaW5hbC1maWxsJzpmaWxsLCdkYXRhLXZhbHVlJzpTdHJpbmcodGhpcy5kYXRhW2ldKX19KTt0aGlzLmNvb3Jkc1tpXT17b2JqZWN0OnJlY3QseDp4LHk6eSx3aWR0aDppbm5lcldpZHRoLGhlaWdodDpoZWlnaHR9O2lmKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpJiZwcm9wLnRvb2x0aXBzW2ldKXt2YXIgb2JqPXRoaXM7KGZ1bmN0aW9uKGlkeClcbntyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sJycpLGZ1bmN0aW9uKGUpXG57b2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHtvYmplY3Q6b2JqLGluZGV4OmlkeCx0ZXh0OnByb3AudG9vbHRpcHNbaWR4XSxldmVudDplfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7fSxmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGUpXG57ZS50YXJnZXQuc3R5bGUuY3Vyc29yPSdwb2ludGVyJ30sZmFsc2UpO30pKGkpO31cbnZhciBwcmV2WD14LHByZXZZPXkscHJldldpZHRoPWlubmVyV2lkdGgscHJldkhlaWdodD1oZWlnaHQscHJldlZhbHVlPXRoaXMuZGF0YVtpXTt9XG5mb3IodmFyIGk9MDtpPHRoaXMuY29vcmRzLmxlbmd0aDsrK2kpe2lmKHRoaXMuY29vcmRzW2krMV0mJnRoaXMuY29vcmRzW2krMV0ub2JqZWN0KXt2YXIgeDE9TnVtYmVyKHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSkrTnVtYmVyKHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpLHkxPXBhcnNlSW50KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSkrKHRoaXMuZGF0YVtpXT4wPzA6cGFyc2VJbnQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKSx4Mj14MSsoMipwcm9wLmhtYXJnaW4pLHkyPXBhcnNlSW50KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSkrKHRoaXMuZGF0YVtpXT4wPzA6cGFyc2VJbnQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKTtpZih0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJyk9PT0nbnVsbCcpe3kxPXBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneScpKTt5Mj1wYXJzZUZsb2F0KHkxKTt9XG52YXIgbGluZT1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZTonbGluZScscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOnt4MTp4MSx5MTp5MSswLjUseDI6eDIseTI6eTIrMC41LHN0cm9rZTpwcm9wLnN0cm9rZXN0eWxlQ29ubmVjdG9yfHxwcm9wLnN0cm9rZXN0eWxlLCdzdHJva2Utd2lkdGgnOnByb3AubGluZXdpZHRoLCdkYXRhLWluZGV4JzppLCdkYXRhLW9yaWdpbmFsLXgxJzp4MSwnZGF0YS1vcmlnaW5hbC15MSc6eTErMC41LCdkYXRhLW9yaWdpbmFsLXgyJzp4MiwnZGF0YS1vcmlnaW5hbC15Mic6eTIrMC41fX0pO319fTt0aGlzLmdldFlDb29yZD1mdW5jdGlvbih2YWx1ZSlcbnt2YXIgcHJvcD10aGlzLnByb3BlcnRpZXM7aWYodmFsdWU+dGhpcy5zY2FsZS5tYXgpe3JldHVybiBudWxsO31cbnZhciB5LHhheGlzcG9zPXByb3AueGF4aXNwb3M7aWYodmFsdWU8dGhpcy5zY2FsZS5taW4pe3JldHVybiBudWxsO31cbnk9KCh2YWx1ZS10aGlzLnNjYWxlLm1pbikvKHRoaXMuc2NhbGUubWF4LXRoaXMuc2NhbGUubWluKSk7eSo9KHRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyVG9wLXByb3AuZ3V0dGVyQm90dG9tKTt5PXRoaXMuaGVpZ2h0LXByb3AuZ3V0dGVyQm90dG9tLXk7cmV0dXJuIHk7fTt0aGlzLmhpZ2hsaWdodD1mdW5jdGlvbihyZWN0KVxue3ZhciB4PXJlY3QuZ2V0QXR0cmlidXRlKCd4JykseT1yZWN0LmdldEF0dHJpYnV0ZSgneScpLHdpZHRoPXJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLGhlaWdodD1yZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7dmFyIGhpZ2hsaWdodD1SRy5TVkcuY3JlYXRlKHtzdmc6dGhpcy5zdmcsdHlwZToncmVjdCcscGFyZW50OnRoaXMuc3ZnLmFsbCxhdHRyOntzdHJva2U6cHJvcC5oaWdobGlnaHRTdHJva2UsZmlsbDpwcm9wLmhpZ2hsaWdodEZpbGwseDp4LHk6eSx3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0LCdzdHJva2Utd2lkdGgnOnByb3AuaGlnaGxpZ2h0TGluZXdpZHRofX0pO1JHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLGhpZ2hsaWdodCk7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZighT2JqZWN0LmtleXModGhpcy5vcmlnaW5hbENvbG9ycykubGVuZ3RoKXt0aGlzLm9yaWdpbmFsQ29sb3JzPXtjb2xvcnM6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLGJhY2tncm91bmRHcmlkQ29sb3I6UkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yKSxoaWdobGlnaHRGaWxsOlJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksYmFja2dyb3VuZENvbG9yOlJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZENvbG9yKX19XG52YXIgY29sb3JzPXByb3AuY29sb3JzO2lmKGNvbG9ycyl7Zm9yKHZhciBpPTA7aTxjb2xvcnMubGVuZ3RoOysraSl7Y29sb3JzW2ldPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpjb2xvcnNbaV19KTt9fVxucHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmJhY2tncm91bmRHcmlkQ29sb3J9KTtwcm9wLmhpZ2hsaWdodEZpbGw9UkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe29iamVjdDp0aGlzLGNvbG9yOnByb3AuaGlnaGxpZ2h0RmlsbH0pO3Byb3AuYmFja2dyb3VuZENvbG9yPVJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtvYmplY3Q6dGhpcyxjb2xvcjpwcm9wLmJhY2tncm91bmRDb2xvcn0pO307dGhpcy5kcmF3TGFiZWxzQWJvdmU9ZnVuY3Rpb24oKVxue2lmKHByb3AubGFiZWxzQWJvdmUpe3ZhciB0b3RhbD0wO2Zvcih2YXIgaT0wO2k8dGhpcy5jb29yZHMubGVuZ3RoOysraSl7dmFyIG51bT10aGlzLmRhdGFbaV0sdG90YWw9dG90YWwrbnVtO2lmKHR5cGVvZiBudW09PT0nbnVtYmVyJ3x8UkcuU1ZHLmlzTnVsbChudW0pKXtpZihSRy5TVkcuaXNOdWxsKG51bSkpe251bT10b3RhbDt9XG52YXIgc3RyPVJHLlNWRy5udW1iZXJGb3JtYXQoe29iamVjdDp0aGlzLG51bTpudW0udG9GaXhlZChwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHMpLHByZXBlbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1ByZT09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1ByZTpudWxsLGFwcGVuZDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVVbml0c1Bvc3Q6bnVsbCxwb2ludDp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVBvaW50PT09J3N0cmluZyc/cHJvcC5sYWJlbHNBYm92ZVBvaW50Om51bGwsdGhvdXNhbmQ6dHlwZW9mIHByb3AubGFiZWxzQWJvdmVUaG91c2FuZD09PSdzdHJpbmcnP3Byb3AubGFiZWxzQWJvdmVUaG91c2FuZDpudWxsLGZvcm1hdHRlcjp0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcj09PSdmdW5jdGlvbic/cHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlcjpudWxsfSk7aWYocHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljJiZwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMubGVuZ3RoJiYodHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tpXT09PSdzdHJpbmcnfHx0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW2ldPT09J251bWJlcicpKXtzdHI9cHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW2ldO31lbHNlIGlmKHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyYmcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljLmxlbmd0aCYmdHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tpXSE9PSdzdHJpbmcnJiZ0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW2ldIT09J251bWJlcicpe2NvbnRpbnVlO31cbnZhciB4PXBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneCcpKStwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykvMikrcHJvcC5sYWJlbHNBYm92ZU9mZnNldHg7aWYodGhpcy5kYXRhW2ldPj0wKXt2YXIgeT1wYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSktNytwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eTt2YXIgdmFsaWduPXByb3AubGFiZWxzQWJvdmVWYWxpZ247fWVsc2V7dmFyIHk9cGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpK3BhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKzctcHJvcC5sYWJlbHNBYm92ZU9mZnNldHk7dmFyIHZhbGlnbj1wcm9wLmxhYmVsc0Fib3ZlVmFsaWduPT09J3RvcCc/J2JvdHRvbSc6J3RvcCc7fVxuUkcuU1ZHLnRleHQoe29iamVjdDp0aGlzLHBhcmVudDp0aGlzLnN2Zy5hbGwsdGV4dDpzdHIseDp4LHk6eSxoYWxpZ246cHJvcC5sYWJlbHNBYm92ZUhhbGlnbix2YWxpZ246dmFsaWduLGZvbnQ6cHJvcC5sYWJlbHNBYm92ZUZvbnR8fHByb3AudGV4dEZvbnQsc2l6ZTpwcm9wLmxhYmVsc0Fib3ZlU2l6ZXx8cHJvcC50ZXh0U2l6ZSxib2xkOnByb3AubGFiZWxzQWJvdmVCb2xkfHxwcm9wLnRleHRCb2xkLGl0YWxpYzpwcm9wLmxhYmVsc0Fib3ZlSXRhbGljfHxwcm9wLnRleHRJdGFsaWMsY29sb3I6cHJvcC5sYWJlbHNBYm92ZUNvbG9yfHxwcm9wLnRleHRDb2xvcixiYWNrZ3JvdW5kOnByb3AubGFiZWxzQWJvdmVCYWNrZ3JvdW5kfHxudWxsLHBhZGRpbmc6cHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nfHwwfSk7fX19fTt0aGlzLm9uPWZ1bmN0aW9uKHR5cGUsZnVuYylcbntpZih0eXBlLnN1YnN0cigwLDIpIT09J29uJyl7dHlwZT0nb24nK3R5cGU7fVxuUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO3JldHVybiB0aGlzO307dGhpcy5leGVjPWZ1bmN0aW9uKGZ1bmMpXG57ZnVuYyh0aGlzKTtyZXR1cm4gdGhpczt9O3RoaXMucmVtb3ZlSGlnaGxpZ2h0PWZ1bmN0aW9uKClcbnt2YXIgaGlnaGxpZ2h0PVJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtpZihoaWdobGlnaHQmJmhpZ2hsaWdodC5wYXJlbnROb2RlKXtoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO31cblJHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLG51bGwpO307dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb3B0PWFyZ3VtZW50c1swXXx8e30sZnJhbWVzPW9wdC5mcmFtZXN8fDMwLGZyYW1lPTAsb2JqPXRoaXMsZGF0YT1bXSxoZWlnaHQ9bnVsbCxzZXE9MDtyZXR1cm4gdGhpczt9O3RoaXMud2F2ZT1mdW5jdGlvbigpXG57cmV0dXJuIHRoaXM7fTtmb3IoaSBpbiBjb25mLm9wdGlvbnMpe2lmKHR5cGVvZiBpPT09J3N0cmluZycpe3RoaXMuc2V0KGksY29uZi5vcHRpb25zW2ldKTt9fX07cmV0dXJuIHRoaXM7fSkod2luZG93LGRvY3VtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcud2F0ZXJmYWxsLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///249\n");

/***/ }),
/* 250 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Thermometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.canvas.__object__ = this;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.type = 'thermometer';this.isRGraph = true;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.coords = [];this.graphArea = [];this.currentValue = null;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.linewidth': 1, 'chart.background.color': 'white', 'chart.strokestyle': 'black', 'chart.colors': ['Gradient(#c00:red:#f66:#fcc)'], 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.ticksize': 2, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.numticks': 10, 'chart.units.pre': '', 'chart.units.post': '', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.title': '', 'chart.title.side': '', 'chart.title.side.bold': true, 'chart.title.side.font': null, 'chart.shadow': true, 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.shadow.color': '#ddd', 'chart.resizable': false, 'chart.contextmenu': null, 'chart.adjustable': false, 'chart.value.label': true, 'chart.value.label.decimals': null, 'chart.value.label.thousand': ',', 'chart.value.label.point': '.', 'chart.labels.count': 5, 'chart.scale.visible': false, 'chart.scale.decimals': 0, 'chart.annotatable': false, 'chart.annotate.color': 'black' }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.bulb.bottom.radius.adjust', 0), _defineProperty(_properties, 'chart.bulb.bottom.radius', null), _properties);\n  if (!this.canvas) {\n    alert('[THERMOMETER] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.ylabels.count') {\n      name = 'chart.labels.count';\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.value = ma.min(this.max, this.value);this.value = ma.max(this.min, this.value);if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.scale2 = RG.getScale2(this, { max: this.max, min: this.min, strict: true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.x = this.gutterLeft;this.width = ca.width - this.gutterLeft - this.gutterRight;this.y = this.gutterTop + this.width / 2;this.halfWidth = this.width / 2;this.bulbTopCenterx = this.gutterLeft + this.width / 2;this.bulbTopCentery = this.gutterTop + this.width / 2;this.bulbTopRadius = this.width / 2;this.bulbBottomCenterx = this.gutterLeft + this.width / 2;this.bulbBottomRadius = typeof prop['chart.bulb.bottom.radius'] === 'number' ? prop['chart.bulb.bottom.radius'] : this.width * 0.75 + prop['chart.bulb.bottom.radius.adjust'];this.bulbBottomCentery = ca.height - this.gutterBottom - this.bulbBottomRadius;this.scaleTopY = this.bulbTopCentery;this.scaleBottomY = this.bulbBottomCentery - this.bulbBottomRadius;this.scaleHeight = this.scaleBottomY - this.scaleTopY;this.height = this.getYCoord(this.min) - this.getYCoord(this.value);this.coords[0] = [this.x, this.getYCoord(this.value), this.width, this.height];this.drawBackground();this.drawBar();this.drawTickMarks();this.drawLabels();if (prop['chart.title']) {\n      this.drawTitle();\n    }\n    if (prop['chart.title.side']) {\n      this.drawSideTitle();\n    }\n    if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.pathBackground();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.background.color'];co.lineWidth = 1 + prop['chart.linewidth'];co.stroke();co.fill();co.lineWidth = 1;\n  };this.drawBar = this.DrawBar = function () {\n    this.pathBar();pa2(co, 'f %', prop['chart.colors'][0]);\n  };this.pathBar = function () {\n    var barHeight = this.coords[0][3],\n        y = this.coords[0][1] + this.coords[0][3] - barHeight;\n    RG.noShadow(this);pa2(co, 'b r % % % % a % % % 0 6.28 false', this.coords[0][0], y, this.coords[0][2], this.bulbBottomCentery - y, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.pathBackground = function () {\n    pa2(this.context, 'b   r % % % %   a % % % 0 6.28 false   m % %   a % % % 0 6.28 false', this.x, this.scaleTopY, this.coords[0][2], this.bulbBottomCentery - this.scaleTopY, this.bulbTopCenterx, this.bulbTopCentery, this.bulbTopRadius, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    if (prop['chart.numticks']) {\n      var ticksize = prop['chart.ticksize'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] / 2;co.beginPath();for (var i = 0; i <= prop['chart.numticks']; ++i) {\n        var y = this.scaleBottomY - this.scaleHeight / prop['chart.numticks'] * i;co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft + ticksize, ma.round(y));co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight - ticksize, ma.round(y));\n      }\n      co.stroke();co.lineWidth = 1;\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.value.label']) {\n      co.fillStyle = prop['chart.text.color'];var text = prop['chart.scale.visible'] ? RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals'])) : RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']);RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] + this.coords[0][2] / 2, y: this.coords[0][1] + 7, text: text, valign: 'top', halign: 'center', bounding: true, boundingFill: 'white', tag: 'value.label' });\n    }\n    if (prop['chart.scale.visible']) {\n      this.drawScale();\n    }\n  };this.drawTitle = this.DrawTitle = function () {\n    co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'] + 2, x: this.gutterLeft + this.width / 2, y: this.gutterTop - 3, text: String(prop['chart.title']), valign: 'bottom', halign: 'center', bold: true, tag: 'title' });\n  };this.drawSideTitle = this.DrawSideTitle = function () {\n    var font = prop['chart.title.side.font'] ? prop['chart.title.side.font'] : prop['chart.text.font'];var size = prop['chart.title.side.size'] ? prop['chart.title.side.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: font, size: size + 2, x: this.gutterLeft - 3, y: this.scaleHeight / 2 + this.gutterTop + this.bulbTopRadius, text: String(prop['chart.title.side']), valign: 'bottom', halign: 'center', angle: 270, bold: prop['chart.title.side.bold'], tag: 'title.side', accessible: false });\n  };this.drawScale = this.DrawScale = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        step = (this.max - this.min) / numLabels;for (var i = 1; i <= numLabels; ++i) {\n      var x = ca.width - this.gutterRight + prop['chart.linewidth'] / 2,\n          y = ca.height - this.gutterBottom - 2 * this.bulbBottomRadius - this.scaleHeight / numLabels * i,\n          text = RG.numberFormat(this, String((this.min + i * step).toFixed(decimals)), units_pre, units_post);RG.text2(this, { font: font, size: size, x: x + 6, y: y, text: text, valign: 'center', tag: 'scale' });\n    }\n    RG.text2(this, { font: font, size: size, x: x + 6, y: this.bulbBottomCentery - this.bulbBottomRadius, text: RG.numberFormat(this, this.min.toFixed(decimals), units_pre, units_post), valign: 'center', tag: 'scale' });\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0; i < this.coords.length; i++) {\n      var coords = this.coords[i],\n          left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];this.pathBar();if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : '';return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    if (arg.length === 2) {\n      var mouseX = arg[0],\n          mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n    }\n    var value = (this.scaleHeight - (mouseY - this.scaleTopY)) / this.scaleHeight;value *= this.max - this.min;value += this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      this.pathBar();pa2(co, 's % f %', prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    this.pathBackground();if (co.isPointInPath(mouseX, mouseY)) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e),\n          value = this.getValue(e);if (typeof value == 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var y = ma.abs(value - this.min) / ma.abs(this.max - this.min);\n    y = y * (this.scaleBottomY - this.scaleTopY);return this.scaleBottomY - y;\n  };this.overChartArea = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];this.pathBackground();return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        callback = arguments[1] || function () {},\n        opt = arguments[0] || {},\n        frames = opt.frames ? opt.frames : 30,\n        origValue = Number(obj.currentValue),\n        newValue = obj.value;newValue = ma.min(newValue, this.max);newValue = ma.max(newValue, this.min);var diff = newValue - origValue,\n        step = diff / frames,\n        frame = 0;function iterate() {\n      obj.value = step * frame + origValue;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterate);\n      } else {\n        callback(obj);\n      }\n    }\n    iterate();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgudGhlcm1vbWV0ZXIuanM/MjMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaD13aW5kb3cuUkdyYXBofHx7aXNSR3JhcGg6dHJ1ZX07UkdyYXBoLlRoZXJtb21ldGVyPWZ1bmN0aW9uKGNvbmYpXG57aWYodHlwZW9mIGNvbmY9PT0nb2JqZWN0JyYmdHlwZW9mIGNvbmYuaWQ9PT0nc3RyaW5nJyl7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnM9dHJ1ZTt9ZWxzZXt2YXIgY29uZj17aWQ6YXJndW1lbnRzWzBdLG1pbjphcmd1bWVudHNbMV0sbWF4OmFyZ3VtZW50c1syXSx2YWx1ZTphcmd1bWVudHNbM119fVxudGhpcy5pZD1jb25mLmlkO3RoaXMuY2FudmFzPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0P3RoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLnR5cGU9J3RoZXJtb21ldGVyJzt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy5taW49UkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5taW4pO3RoaXMubWF4PVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKGNvbmYubWF4KTt0aGlzLnZhbHVlPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKGNvbmYudmFsdWUpO3RoaXMuY29vcmRzPVtdO3RoaXMuZ3JhcGhBcmVhPVtdO3RoaXMuY3VycmVudFZhbHVlPW51bGw7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMub3JpZ2luYWxfY29sb3JzPVtdO3RoaXMuZmlyc3REcmF3PXRydWU7dGhpcy5wcm9wZXJ0aWVzPXsnY2hhcnQubGluZXdpZHRoJzoxLCdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzond2hpdGUnLCdjaGFydC5zdHJva2VzdHlsZSc6J2JsYWNrJywnY2hhcnQuY29sb3JzJzpbJ0dyYWRpZW50KCNjMDA6cmVkOiNmNjY6I2ZjYyknXSwnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LnRpY2tzaXplJzoyLCdjaGFydC50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC50ZXh0LmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50ZXh0LnNpemUnOjEyLCdjaGFydC50ZXh0LmFjY2Vzc2libGUnOnRydWUsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6J3Zpc2libGUnLCdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6dHJ1ZSwnY2hhcnQubnVtdGlja3MnOjEwLCdjaGFydC51bml0cy5wcmUnOicnLCdjaGFydC51bml0cy5wb3N0JzonJywnY2hhcnQuem9vbS5mYWN0b3InOjEuNSwnY2hhcnQuem9vbS5mYWRlLmluJzp0cnVlLCdjaGFydC56b29tLmZhZGUub3V0Jzp0cnVlLCdjaGFydC56b29tLmhkaXInOidyaWdodCcsJ2NoYXJ0Lnpvb20udmRpcic6J2Rvd24nLCdjaGFydC56b29tLmZyYW1lcyc6MjUsJ2NoYXJ0Lnpvb20uZGVsYXknOjE2LjY2NiwnY2hhcnQuem9vbS5zaGFkb3cnOnRydWUsJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6dHJ1ZSwnY2hhcnQudGl0bGUnOicnLCdjaGFydC50aXRsZS5zaWRlJzonJywnY2hhcnQudGl0bGUuc2lkZS5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS5zaWRlLmZvbnQnOm51bGwsJ2NoYXJ0LnNoYWRvdyc6dHJ1ZSwnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjAsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzowLCdjaGFydC5zaGFkb3cuYmx1cic6MTUsJ2NoYXJ0LnNoYWRvdy5jb2xvcic6JyNkZGQnLCdjaGFydC5yZXNpemFibGUnOmZhbHNlLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQuYWRqdXN0YWJsZSc6ZmFsc2UsJ2NoYXJ0LnZhbHVlLmxhYmVsJzp0cnVlLCdjaGFydC52YWx1ZS5sYWJlbC5kZWNpbWFscyc6bnVsbCwnY2hhcnQudmFsdWUubGFiZWwudGhvdXNhbmQnOicsJywnY2hhcnQudmFsdWUubGFiZWwucG9pbnQnOicuJywnY2hhcnQubGFiZWxzLmNvdW50Jzo1LCdjaGFydC5zY2FsZS52aXNpYmxlJzpmYWxzZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC50b29sdGlwcyc6bnVsbCwnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0Jzp0cnVlLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuZXZlbnQnOidvbmNsaWNrJywnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5oaWdobGlnaHQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmNsZWFydG8nOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuYnVsYi5ib3R0b20ucmFkaXVzLmFkanVzdCc6MCwnY2hhcnQuYnVsYi5ib3R0b20ucmFkaXVzJzpudWxsfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW1RIRVJNT01FVEVSXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG50aGlzLiQwPXt9O2lmKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pe3RoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fPXRydWU7fVxudmFyIFJHPVJHcmFwaCxjYT10aGlzLmNhbnZhcyxjbz1jYS5nZXRDb250ZXh0KCcyZCcpLHByb3A9dGhpcy5wcm9wZXJ0aWVzLHBhMj1SRy5wYXRoMix3aW49d2luZG93LGRvYz1kb2N1bWVudCxtYT1NYXRoXG5pZihSRy5FZmZlY3RzJiZ0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZT09PSdmdW5jdGlvbicpe1JHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7fVxudGhpcy5zZXQ9dGhpcy5TZXQ9ZnVuY3Rpb24obmFtZSlcbnt2YXIgdmFsdWU9dHlwZW9mIGFyZ3VtZW50c1sxXT09PSd1bmRlZmluZWQnP251bGw6YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZ0eXBlb2YgbmFtZT09PSdvYmplY3QnKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsbmFtZSk7cmV0dXJuIHRoaXM7fVxuaWYobmFtZS5zdWJzdHIoMCw2KSE9J2NoYXJ0Licpe25hbWU9J2NoYXJ0LicrbmFtZTt9XG53aGlsZShuYW1lLm1hdGNoKC8oW0EtWl0pLykpe25hbWU9bmFtZS5yZXBsYWNlKC8oW0EtWl0pLywnLicrUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO31cbmlmKG5hbWU9PSdjaGFydC55bGFiZWxzLmNvdW50Jyl7bmFtZT0nY2hhcnQubGFiZWxzLmNvdW50Jzt9XG5wcm9wW25hbWUudG9Mb3dlckNhc2UoKV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmJlZm9yZWRyYXcnKTt0aGlzLnZhbHVlPW1hLm1pbih0aGlzLm1heCx0aGlzLnZhbHVlKTt0aGlzLnZhbHVlPW1hLm1heCh0aGlzLm1pbix0aGlzLnZhbHVlKTtpZighdGhpcy5jb2xvcnNQYXJzZWQpe3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZD10cnVlO31cbnRoaXMuY3VycmVudFZhbHVlPXRoaXMudmFsdWU7dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuZ3V0dGVyTGVmdD1wcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQ9cHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3A9cHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tPXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7bWF4OnRoaXMubWF4LG1pbjp0aGlzLm1pbixzdHJpY3Q6dHJ1ZSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnBvaW50Jzpwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCdzY2FsZS5kZWNpbWFscyc6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwneWxhYmVscy5jb3VudCc6cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTt0aGlzLng9dGhpcy5ndXR0ZXJMZWZ0O3RoaXMud2lkdGg9Y2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQ7dGhpcy55PXRoaXMuZ3V0dGVyVG9wKyh0aGlzLndpZHRoLzIpO3RoaXMuaGFsZldpZHRoPXRoaXMud2lkdGgvMjt0aGlzLmJ1bGJUb3BDZW50ZXJ4PXRoaXMuZ3V0dGVyTGVmdCsodGhpcy53aWR0aC8yKTt0aGlzLmJ1bGJUb3BDZW50ZXJ5PXRoaXMuZ3V0dGVyVG9wKyh0aGlzLndpZHRoLzIpO3RoaXMuYnVsYlRvcFJhZGl1cz10aGlzLndpZHRoLzI7dGhpcy5idWxiQm90dG9tQ2VudGVyeD10aGlzLmd1dHRlckxlZnQrKHRoaXMud2lkdGgvMik7dGhpcy5idWxiQm90dG9tUmFkaXVzPXR5cGVvZiBwcm9wWydjaGFydC5idWxiLmJvdHRvbS5yYWRpdXMnXT09PSdudW1iZXInP3Byb3BbJ2NoYXJ0LmJ1bGIuYm90dG9tLnJhZGl1cyddOnRoaXMud2lkdGgqMC43NStwcm9wWydjaGFydC5idWxiLmJvdHRvbS5yYWRpdXMuYWRqdXN0J107dGhpcy5idWxiQm90dG9tQ2VudGVyeT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20tdGhpcy5idWxiQm90dG9tUmFkaXVzO3RoaXMuc2NhbGVUb3BZPXRoaXMuYnVsYlRvcENlbnRlcnk7dGhpcy5zY2FsZUJvdHRvbVk9dGhpcy5idWxiQm90dG9tQ2VudGVyeS10aGlzLmJ1bGJCb3R0b21SYWRpdXM7dGhpcy5zY2FsZUhlaWdodD10aGlzLnNjYWxlQm90dG9tWS10aGlzLnNjYWxlVG9wWTt0aGlzLmhlaWdodD10aGlzLmdldFlDb29yZCh0aGlzLm1pbiktdGhpcy5nZXRZQ29vcmQodGhpcy52YWx1ZSk7dGhpcy5jb29yZHNbMF09W3RoaXMueCx0aGlzLmdldFlDb29yZCh0aGlzLnZhbHVlKSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XTt0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7dGhpcy5kcmF3QmFyKCk7dGhpcy5kcmF3VGlja01hcmtzKCk7dGhpcy5kcmF3TGFiZWxzKCk7aWYocHJvcFsnY2hhcnQudGl0bGUnXSl7dGhpcy5kcmF3VGl0bGUoKTt9XG5pZihwcm9wWydjaGFydC50aXRsZS5zaWRlJ10pe3RoaXMuZHJhd1NpZGVUaXRsZSgpO31cbmlmKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKXtSRy5hbGxvd1Jlc2l6aW5nKHRoaXMpO31cbmlmKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pe1JHLnNob3dDb250ZXh0KHRoaXMpO31cblJHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZih0aGlzLmZpcnN0RHJhdyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXc9ZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7fVxuUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uZHJhdycpO3JldHVybiB0aGlzO307dGhpcy5kcmF3QmFja2dyb3VuZD10aGlzLkRyYXdCYWNrZ3JvdW5kPWZ1bmN0aW9uKClcbntpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31cbnRoaXMucGF0aEJhY2tncm91bmQoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28ubGluZVdpZHRoPTErcHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmxpbmVXaWR0aD0xO307dGhpcy5kcmF3QmFyPXRoaXMuRHJhd0Jhcj1mdW5jdGlvbigpXG57dGhpcy5wYXRoQmFyKCk7cGEyKGNvLCdmICUnLHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdKTt9O3RoaXMucGF0aEJhcj1mdW5jdGlvbigpXG57dmFyIGJhckhlaWdodD10aGlzLmNvb3Jkc1swXVszXSx5PSh0aGlzLmNvb3Jkc1swXVsxXSt0aGlzLmNvb3Jkc1swXVszXSktYmFySGVpZ2h0XG5SRy5ub1NoYWRvdyh0aGlzKTtwYTIoY28sJ2IgciAlICUgJSAlIGEgJSAlICUgMCA2LjI4IGZhbHNlJyx0aGlzLmNvb3Jkc1swXVswXSx5LHRoaXMuY29vcmRzWzBdWzJdLHRoaXMuYnVsYkJvdHRvbUNlbnRlcnkteSx0aGlzLmJ1bGJCb3R0b21DZW50ZXJ4LHRoaXMuYnVsYkJvdHRvbUNlbnRlcnksdGhpcy5idWxiQm90dG9tUmFkaXVzKTt9O3RoaXMucGF0aEJhY2tncm91bmQ9ZnVuY3Rpb24oKVxue3BhMih0aGlzLmNvbnRleHQsJ2IgICByICUgJSAlICUgICBhICUgJSAlIDAgNi4yOCBmYWxzZSAgIG0gJSAlICAgYSAlICUgJSAwIDYuMjggZmFsc2UnLHRoaXMueCx0aGlzLnNjYWxlVG9wWSx0aGlzLmNvb3Jkc1swXVsyXSx0aGlzLmJ1bGJCb3R0b21DZW50ZXJ5LXRoaXMuc2NhbGVUb3BZLHRoaXMuYnVsYlRvcENlbnRlcngsdGhpcy5idWxiVG9wQ2VudGVyeSx0aGlzLmJ1bGJUb3BSYWRpdXMsdGhpcy5idWxiQm90dG9tQ2VudGVyeCx0aGlzLmJ1bGJCb3R0b21DZW50ZXJ5LHRoaXMuYnVsYkJvdHRvbUNlbnRlcngsdGhpcy5idWxiQm90dG9tQ2VudGVyeSx0aGlzLmJ1bGJCb3R0b21SYWRpdXMpO307dGhpcy5kcmF3VGlja01hcmtzPXRoaXMuRHJhd1RpY2tNYXJrcz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQubnVtdGlja3MnXSl7dmFyIHRpY2tzaXplPXByb3BbJ2NoYXJ0LnRpY2tzaXplJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGg9cHJvcFsnY2hhcnQubGluZXdpZHRoJ10vMjtjby5iZWdpblBhdGgoKTtmb3IodmFyIGk9MDtpPD1wcm9wWydjaGFydC5udW10aWNrcyddOysraSl7dmFyIHk9dGhpcy5zY2FsZUJvdHRvbVktKCh0aGlzLnNjYWxlSGVpZ2h0L3Byb3BbJ2NoYXJ0Lm51bXRpY2tzJ10pKmkpO2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQrdGlja3NpemUsbWEucm91bmQoeSkpO2NvLm1vdmVUbyhjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0LG1hLnJvdW5kKHkpKTtjby5saW5lVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC10aWNrc2l6ZSxtYS5yb3VuZCh5KSk7fVxuY28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoPTE7fX07dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQudmFsdWUubGFiZWwnXSl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgdGV4dD1wcm9wWydjaGFydC5zY2FsZS52aXNpYmxlJ10/UkcubnVtYmVyRm9ybWF0KHRoaXMsdGhpcy52YWx1ZS50b0ZpeGVkKHR5cGVvZiBwcm9wWydjaGFydC52YWx1ZS5sYWJlbC5kZWNpbWFscyddPT0nbnVtYmVyJz9wcm9wWydjaGFydC52YWx1ZS5sYWJlbC5kZWNpbWFscyddOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKTpSRy5udW1iZXJGb3JtYXQodGhpcyx0aGlzLnZhbHVlLnRvRml4ZWQodHlwZW9mIHByb3BbJ2NoYXJ0LnZhbHVlLmxhYmVsLmRlY2ltYWxzJ109PSdudW1iZXInP3Byb3BbJ2NoYXJ0LnZhbHVlLmxhYmVsLmRlY2ltYWxzJ106cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkscHJvcFsnY2hhcnQudW5pdHMucHJlJ10scHJvcFsnY2hhcnQudW5pdHMucG9zdCddKTtSRy50ZXh0Mih0aGlzLHtmb250OnByb3BbJ2NoYXJ0LnRleHQuZm9udCddLHNpemU6cHJvcFsnY2hhcnQudGV4dC5zaXplJ10seDp0aGlzLmNvb3Jkc1swXVswXSsodGhpcy5jb29yZHNbMF1bMl0vMikseTp0aGlzLmNvb3Jkc1swXVsxXSs3LHRleHQ6dGV4dCx2YWxpZ246J3RvcCcsaGFsaWduOidjZW50ZXInLGJvdW5kaW5nOnRydWUsYm91bmRpbmdGaWxsOid3aGl0ZScsdGFnOid2YWx1ZS5sYWJlbCd9KTt9XG5pZihwcm9wWydjaGFydC5zY2FsZS52aXNpYmxlJ10pe3RoaXMuZHJhd1NjYWxlKCk7fX07dGhpcy5kcmF3VGl0bGU9dGhpcy5EcmF3VGl0bGU9ZnVuY3Rpb24oKVxue2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcudGV4dDIodGhpcyx7Zm9udDpwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxzaXplOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddKzIseDp0aGlzLmd1dHRlckxlZnQrKHRoaXMud2lkdGgvMikseTp0aGlzLmd1dHRlclRvcC0zLHRleHQ6U3RyaW5nKHByb3BbJ2NoYXJ0LnRpdGxlJ10pLHZhbGlnbjonYm90dG9tJyxoYWxpZ246J2NlbnRlcicsYm9sZDp0cnVlLHRhZzondGl0bGUnfSk7fTt0aGlzLmRyYXdTaWRlVGl0bGU9dGhpcy5EcmF3U2lkZVRpdGxlPWZ1bmN0aW9uKClcbnt2YXIgZm9udD1wcm9wWydjaGFydC50aXRsZS5zaWRlLmZvbnQnXT9wcm9wWydjaGFydC50aXRsZS5zaWRlLmZvbnQnXTpwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZT1wcm9wWydjaGFydC50aXRsZS5zaWRlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaWRlLnNpemUnXTpwcm9wWydjaGFydC50ZXh0LnNpemUnXSsyO2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcudGV4dDIodGhpcyx7Zm9udDpmb250LHNpemU6c2l6ZSsyLHg6dGhpcy5ndXR0ZXJMZWZ0LTMseToodGhpcy5zY2FsZUhlaWdodC8yKSt0aGlzLmd1dHRlclRvcCt0aGlzLmJ1bGJUb3BSYWRpdXMsdGV4dDpTdHJpbmcocHJvcFsnY2hhcnQudGl0bGUuc2lkZSddKSx2YWxpZ246J2JvdHRvbScsaGFsaWduOidjZW50ZXInLGFuZ2xlOjI3MCxib2xkOnByb3BbJ2NoYXJ0LnRpdGxlLnNpZGUuYm9sZCddLHRhZzondGl0bGUuc2lkZScsYWNjZXNzaWJsZTpmYWxzZX0pO307dGhpcy5kcmF3U2NhbGU9dGhpcy5EcmF3U2NhbGU9ZnVuY3Rpb24oKVxue2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSx1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ10sdW5pdHNfcG9zdD1wcm9wWydjaGFydC51bml0cy5wb3N0J10sZGVjaW1hbHM9cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSxudW1MYWJlbHM9cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sc3RlcD0odGhpcy5tYXgtdGhpcy5taW4pL251bUxhYmVscztmb3IodmFyIGk9MTtpPD1udW1MYWJlbHM7KytpKXt2YXIgeD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0Kyhwcm9wWydjaGFydC5saW5ld2lkdGgnXS8yKSx5PWNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS0oMip0aGlzLmJ1bGJCb3R0b21SYWRpdXMpLSgodGhpcy5zY2FsZUhlaWdodC9udW1MYWJlbHMpKmkpLHRleHQ9UkcubnVtYmVyRm9ybWF0KHRoaXMsU3RyaW5nKCh0aGlzLm1pbisoaSpzdGVwKSkudG9GaXhlZChkZWNpbWFscykpLHVuaXRzX3ByZSx1bml0c19wb3N0KTtSRy50ZXh0Mih0aGlzLHtmb250OmZvbnQsc2l6ZTpzaXplLHg6eCs2LHk6eSx0ZXh0OnRleHQsdmFsaWduOidjZW50ZXInLHRhZzonc2NhbGUnfSk7fVxuUkcudGV4dDIodGhpcyx7Zm9udDpmb250LHNpemU6c2l6ZSx4OngrNix5OnRoaXMuYnVsYkJvdHRvbUNlbnRlcnktdGhpcy5idWxiQm90dG9tUmFkaXVzLHRleHQ6UkcubnVtYmVyRm9ybWF0KHRoaXMsdGhpcy5taW4udG9GaXhlZChkZWNpbWFscyksdW5pdHNfcHJlLHVuaXRzX3Bvc3QpLHZhbGlnbjonY2VudGVyJyx0YWc6J3NjYWxlJ30pO307dGhpcy5nZXRTaGFwZT10aGlzLmdldEJhcj1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSksbW91c2VYPW1vdXNlWFlbMF0sbW91c2VZPW1vdXNlWFlbMV07Zm9yKHZhciBpPTA7aTx0aGlzLmNvb3Jkcy5sZW5ndGg7aSsrKXt2YXIgY29vcmRzPXRoaXMuY29vcmRzW2ldLGxlZnQ9Y29vcmRzWzBdLHRvcD1jb29yZHNbMV0sd2lkdGg9Y29vcmRzWzJdLGhlaWdodD1jb29yZHNbM107dGhpcy5wYXRoQmFyKCk7aWYoY28uaXNQb2ludEluUGF0aChtb3VzZVgsbW91c2VZKSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dD9SRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10saSk6Jyc7cmV0dXJuezA6dGhpcyxvYmplY3Q6dGhpcywxOmxlZnQseDpsZWZ0LDI6dG9wLHk6dG9wLDM6d2lkdGgsd2lkdGg6d2lkdGgsNDpoZWlnaHQsaGVpZ2h0OmhlaWdodCw1OmksaW5kZXg6aSx0b29sdGlwOnRvb2x0aXB9O319XG5yZXR1cm4gbnVsbDt9O3RoaXMuZ2V0VmFsdWU9ZnVuY3Rpb24oYXJnKVxue2lmKGFyZy5sZW5ndGg9PT0yKXt2YXIgbW91c2VYPWFyZ1swXSxtb3VzZVk9YXJnWzFdO31lbHNle3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoYXJnKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTt9XG52YXIgdmFsdWU9KHRoaXMuc2NhbGVIZWlnaHQtKG1vdXNlWS10aGlzLnNjYWxlVG9wWSkpL3RoaXMuc2NhbGVIZWlnaHQ7dmFsdWUqPSh0aGlzLm1heC10aGlzLm1pbik7dmFsdWUrPXRoaXMubWluO3ZhbHVlPW1hLm1heCh2YWx1ZSx0aGlzLm1pbik7dmFsdWU9bWEubWluKHZhbHVlLHRoaXMubWF4KTtyZXR1cm4gdmFsdWU7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZihwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSl7aWYodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddPT09J2Z1bmN0aW9uJyl7KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKShzaGFwZSk7cmV0dXJuO31cbnRoaXMucGF0aEJhcigpO3BhMihjbywncyAlIGYgJScscHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddLHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO319O3RoaXMuZ2V0T2JqZWN0QnlYWT1mdW5jdGlvbihlKVxue3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSksbW91c2VYPW1vdXNlWFlbMF0sbW91c2VZPW1vdXNlWFlbMV1cbnRoaXMucGF0aEJhY2tncm91bmQoKTtpZihjby5pc1BvaW50SW5QYXRoKG1vdXNlWCxtb3VzZVkpKXtyZXR1cm4gdGhpczt9fTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmU9dGhpcy5BZGp1c3RpbmdfbW91c2Vtb3ZlPWZ1bmN0aW9uKGUpXG57aWYocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddJiZSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZycpJiZSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZD09dGhpcy51aWQpe3ZhciBtb3VzZVhZPVJHLmdldE1vdXNlWFkoZSksdmFsdWU9dGhpcy5nZXRWYWx1ZShlKTtpZih0eXBlb2YodmFsdWUpPT0nbnVtYmVyJyl7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYWRqdXN0Jyk7dGhpcy52YWx1ZT1OdW1iZXIodmFsdWUudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSk7UkcucmVkcmF3Q2FudmFzKGNhKTt9fX07dGhpcy5nZXRZQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57aWYodmFsdWU+dGhpcy5tYXh8fHZhbHVlPHRoaXMubWluKXtyZXR1cm4gbnVsbDt9XG52YXIgeT1tYS5hYnModmFsdWUtdGhpcy5taW4pL21hLmFicyh0aGlzLm1heC10aGlzLm1pbilcbnk9eSoodGhpcy5zY2FsZUJvdHRvbVktdGhpcy5zY2FsZVRvcFkpO3JldHVybiB0aGlzLnNjYWxlQm90dG9tWS15O307dGhpcy5vdmVyQ2hhcnRBcmVhPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXTt0aGlzLnBhdGhCYWNrZ3JvdW5kKCk7cmV0dXJuIGNvLmlzUG9pbnRJblBhdGgobW91c2VYLG1vdXNlWSk7fTt0aGlzLnBhcnNlQ29sb3JzPWZ1bmN0aW9uKClcbntpZih0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGg9PT0wKXt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ109UkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7fVxudmFyIGNvbG9ycz1wcm9wWydjaGFydC5jb2xvcnMnXTtmb3IodmFyIGk9MDtpPGNvbG9ycy5sZW5ndGg7KytpKXtjb2xvcnNbaV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTt9fTt0aGlzLnJlc2V0PWZ1bmN0aW9uKClcbnt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50PWZ1bmN0aW9uKGNvbG9yKVxue2lmKCFjb2xvcil7cmV0dXJuIGNvbG9yO31cbmlmKHR5cGVvZiBjb2xvcj09PSdzdHJpbmcnJiZjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLDAsY2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sMCk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xO2o8cGFydHMubGVuZ3RoOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9fVxucmV0dXJuIGdyYWQ/Z3JhZDpjb2xvcjt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmdyb3c9ZnVuY3Rpb24oKVxue3ZhciBvYmo9dGhpcyxjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fSxvcHQ9YXJndW1lbnRzWzBdfHx7fSxmcmFtZXM9b3B0LmZyYW1lcz9vcHQuZnJhbWVzOjMwLG9yaWdWYWx1ZT1OdW1iZXIob2JqLmN1cnJlbnRWYWx1ZSksbmV3VmFsdWU9b2JqLnZhbHVlO25ld1ZhbHVlPW1hLm1pbihuZXdWYWx1ZSx0aGlzLm1heCk7bmV3VmFsdWU9bWEubWF4KG5ld1ZhbHVlLHRoaXMubWluKTt2YXIgZGlmZj1uZXdWYWx1ZS1vcmlnVmFsdWUsc3RlcD0oZGlmZi9mcmFtZXMpLGZyYW1lPTA7ZnVuY3Rpb24gaXRlcmF0ZSgpXG57b2JqLnZhbHVlPShzdGVwKmZyYW1lKStvcmlnVmFsdWU7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKGZyYW1lPGZyYW1lcyl7ZnJhbWUrKztSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRlKTt9ZWxzZXtjYWxsYmFjayhvYmopO319XG5pdGVyYXRlKCk7cmV0dXJuIHRoaXM7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZihwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKXtSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsY29uZi5vcHRpb25zKTt9fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC50aGVybW9tZXRlci5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///250\n");

/***/ }),
/* 251 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.VProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'vprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.zerostart': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.title.side': null, 'chart.title.side.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.side.size': 12, 'chart.title.side.color': 'black', 'chart.title.side.bold': true, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.label.inner': false, 'chart.labels.count': 10, 'chart.labels.position': 'right', 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.thousand': ',', 'chart.scale.point': '.', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': '#000', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.border.inner': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[PROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.arrayLinearize(this.value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    if (name == 'chart.strokestyle') {\n      prop['chart.strokestyle.inner'] = value;prop['chart.strokestyle.outer'] = value;return;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.Drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitles();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    this.AllowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle.outer'];co.fillStyle = prop['chart.colors'][0];var margin = prop['chart.margin'];var barHeight = (ca.height - this.gutterTop - this.gutterBottom) * ((RG.arraySum(this.value) - this.min) / (this.max - this.min));if (typeof this.value === 'number') {\n      co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.inner'];if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, fill: prop['chart.colors'][0] });\n    } else if (_typeof(this.value) == 'object') {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];var startPoint = ca.height - this.gutterBottom;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentHeight = (this.value[i] - this.min) / (this.max - this.min) * (ca.height - this.gutterBottom - this.gutterTop);co.fillStyle = prop['chart.colors'][i];co.beginPath();if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, stroke: co.strokeStyle });\n        }\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, fill: co.fillStyle });this.coords.push([this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight]);startPoint -= segmentHeight;\n      }\n      co.fill();\n    }\n    if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var y = this.gutterTop; y < ca.height - this.gutterBottom; y += spacing) {\n        co.moveTo(this.gutterLeft, Math.round(y));co.lineTo(this.gutterLeft + 3, Math.round(y));co.moveTo(ca.width - this.gutterRight, Math.round(y));co.lineTo(ca.width - this.gutterRight - 3, Math.round(y));\n      }\n      co.stroke();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];if (typeof this.value == 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });this.coords.push([this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight]);\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft - 4;var y = ca.height - this.gutterBottom - barHeight;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y);co.lineTo(x - 4, y - 2);co.lineTo(x - 4, y + 2);co.closePath();co.stroke();co.fill();x += this.width + 8;co.beginPath();co.moveTo(x, y);co.lineTo(x + 4, y - 2);co.lineTo(x + 4, y + 2);co.closePath();co.stroke();co.fill();pa2(co, 'b');\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': this.coords[this.coords.length - 1][1] - 5, 'text': RGraph.number_format(this, (typeof this.value == 'number' ? this.value : RG.array_sum(this.value)).toFixed(prop['chart.scale.decimals'])), 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();for (var i = 0; prop['chart.tickmarks.zerostart'] ? i <= prop['chart.numticks'] : i < prop['chart.numticks']; i++) {\n        var startX = prop['chart.labels.position'] == 'left' ? this.gutterLeft : ca.width - prop['chart.gutter.right'];var endX = prop['chart.labels.position'] == 'left' ? startX - 4 : startX + 4;var yPos = this.height * (i / prop['chart.numticks']) + this.gutterTop;\n        co.moveTo(startX, ma.round(yPos));co.lineTo(endX, ma.round(yPos));\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var position = prop['chart.labels.position'].toLowerCase();var xAlignment = position == 'left' ? 'right' : 'left';var yAlignment = 'center';var count = prop['chart.labels.count'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var decimals = prop['chart.scale.decimals'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];if (prop['chart.tickmarks']) {\n      for (var i = 0; i < count; ++i) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 7 + offsetx : ca.width - this.gutterRight + 7 + offsetx, y: (ca.height - this.gutterTop - this.gutterBottom) / count * i + this.gutterTop + offsety, text: this.scale2.labels[this.scale2.labels.length - (i + 1)], valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (prop['chart.tickmarks.zerostart'] && this.min == 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, this.min.toFixed(this.min === 0 ? 0 : decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (this.min != 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var title_size = prop['chart.title.size'] ? prop['chart.title.size'] : text_size + 2;if (prop['chart.title'].length > 0) {\n      co.fillStyle = prop['chart.title.color'];RG.text2(this, { 'font': prop['chart.title.font'] ? prop['chart.title.font'] : text_font, 'size': title_size, 'x': this.gutterLeft + (ca.width - this.gutterLeft - this.gutterRight) / 2, 'y': this.gutterTop - 5, 'text': prop['chart.title'], 'valign': 'bottom', 'halign': 'center', 'bold': prop['chart.title.bold'], 'tag': 'title' });\n    }\n    if (typeof prop['chart.title.side'] == 'string') {\n      co.fillStyle = prop['chart.title.side.color'];RG.Text2(this, { 'font': prop['chart.title.side.font'], 'size': prop['chart.title.side.size'], 'x': prop['chart.labels.position'] == 'right' ? this.gutterLeft - 10 : ca.width - this.gutterRight + 10, 'y': this.gutterTop + this.height / 2, 'text': prop['chart.title.side'], 'valign': 'bottom', 'halign': 'center', 'angle': prop['chart.labels.position'] == 'right' ? 270 : 90, 'bold': prop['chart.title.side.bold'], 'tag': 'title.side' });\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, width: w, height: h });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: w, 'width': w, 4: h, 'height': h, 5: i, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var value = (this.height - (mouseY - this.gutterTop)) / this.height;value *= this.max - this.min;value += this.min;if (value > this.max) value = this.max;if (value < this.min) value = this.min;return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      var last = shape.index === this.coords.length - 1;this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.allowAdjusting = this.AllowAdjusting = function () {\n    return;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value === 'number') {\n        RG.FireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.RedrawCanvas(this.canvas);\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var halign = prop['chart.labels.position'] == 'right' ? 'left' : 'right';var step = this.height / (labels.length - 1);co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': prop['chart.labels.position'] == 'right' ? ca.width - this.gutterRight + 7 : this.gutterLeft - 7, 'y': this.height + this.gutterTop - step * i, 'text': labels[i], 'valign': 'center', 'halign': halign, 'tag': 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var barHeight = ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'];var coord = (value - this.min) / (this.max - this.min) * barHeight;coord = ca.height - coord - prop['chart.gutter.bottom'];return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0, len = colors.length; i < len; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, height = 0; i < this.coords.length; ++i) {\n      height += this.coords[i][3];\n    }\n    co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[this.coords.length - 1][1] - 1, this.coords[0][2], height);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2], height: height });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 1, y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2] + 2, height: height + 2 + 100 });co.stroke();co.restore();co.restore();\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.exec = function (func) {\n    func(this);return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RGraph.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0; i < obj.value.length; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0; i < obj.value.length; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0; i < initial_value.length; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgudnByb2dyZXNzLmpzP2ViMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5WUHJvZ3Jlc3M9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5pZD09PSdzdHJpbmcnKXt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucz10cnVlO31lbHNle3ZhciBjb25mPXtpZDphcmd1bWVudHNbMF0sbWluOmFyZ3VtZW50c1sxXSxtYXg6YXJndW1lbnRzWzJdLHZhbHVlOmFyZ3VtZW50c1szXX19XG50aGlzLmlkPWNvbmYuaWQ7dGhpcy5jYW52YXM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXz10aGlzO3RoaXMubWluPVJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKGNvbmYubWluKTt0aGlzLm1heD1SR3JhcGguc3RyaW5nc1RvTnVtYmVycyhjb25mLm1heCk7dGhpcy52YWx1ZT1SR3JhcGguc3RyaW5nc1RvTnVtYmVycyhjb25mLnZhbHVlKTt0aGlzLnR5cGU9J3Zwcm9ncmVzcyc7dGhpcy5jb29yZHM9W107dGhpcy5pc1JHcmFwaD10cnVlO3RoaXMuY3VycmVudFZhbHVlPW51bGw7dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5jb2xvcnMnOlsnR3JhZGllbnQod2hpdGU6IzBjMCknLCdHcmFkaWVudCh3aGl0ZTpyZWQpJywnR3JhZGllbnQod2hpdGU6Z3JlZW4pJywneWVsbG93JywncGluaycsJ2N5YW4nLCdibGFjaycsJ3doaXRlJywnZ3JheSddLCdjaGFydC5zdHJva2VzdHlsZS5pbm5lcic6JyM5OTknLCdjaGFydC5zdHJva2VzdHlsZS5vdXRlcic6JyM5OTknLCdjaGFydC50aWNrbWFya3MnOnRydWUsJ2NoYXJ0LnRpY2ttYXJrcy56ZXJvc3RhcnQnOnRydWUsJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvcic6JyM5OTknLCdjaGFydC50aWNrbWFya3MuaW5uZXInOmZhbHNlLCdjaGFydC5ndXR0ZXIubGVmdCc6MjUsJ2NoYXJ0Lmd1dHRlci5yaWdodCc6MjUsJ2NoYXJ0Lmd1dHRlci50b3AnOjI1LCdjaGFydC5ndXR0ZXIuYm90dG9tJzoyNSwnY2hhcnQubnVtdGlja3MnOjEwLCdjaGFydC5udW10aWNrcy5pbm5lcic6NTAsJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOidHcmFkaWVudCgjY2NjOiNlZWU6I2VmZWZlZiknLCdjaGFydC5zaGFkb3cnOmZhbHNlLCdjaGFydC5zaGFkb3cuY29sb3InOidyZ2JhKDAsMCwwLDAuNSknLCdjaGFydC5zaGFkb3cuYmx1cic6MywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzozLCdjaGFydC50aXRsZSc6JycsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLmNvbG9yJzonYmxhY2snLCdjaGFydC50aXRsZS5zaWRlJzpudWxsLCdjaGFydC50aXRsZS5zaWRlLmZvbnQnOidTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCdjaGFydC50aXRsZS5zaWRlLnNpemUnOjEyLCdjaGFydC50aXRsZS5zaWRlLmNvbG9yJzonYmxhY2snLCdjaGFydC50aXRsZS5zaWRlLmJvbGQnOnRydWUsJ2NoYXJ0LnRleHQuc2l6ZSc6MTIsJ2NoYXJ0LnRleHQuY29sb3InOidibGFjaycsJ2NoYXJ0LnRleHQuZm9udCc6J1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6dHJ1ZSwnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzondmlzaWJsZScsJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzp0cnVlLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQudW5pdHMucHJlJzonJywnY2hhcnQudW5pdHMucG9zdCc6JycsJ2NoYXJ0LnRvb2x0aXBzJzpudWxsLCdjaGFydC50b29sdGlwcy5lZmZlY3QnOidmYWRlJywnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzonUkdyYXBoX3Rvb2x0aXAnLCdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOnRydWUsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5hbm5vdGF0YWJsZSc6ZmFsc2UsJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzonYmxhY2snLCdjaGFydC56b29tLmZhY3Rvcic6MS41LCdjaGFydC56b29tLmZhZGUuaW4nOnRydWUsJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOnRydWUsJ2NoYXJ0Lnpvb20uaGRpcic6J3JpZ2h0JywnY2hhcnQuem9vbS52ZGlyJzonZG93bicsJ2NoYXJ0Lnpvb20uZnJhbWVzJzoyNSwnY2hhcnQuem9vbS5kZWxheSc6MTYuNjY2LCdjaGFydC56b29tLnNoYWRvdyc6dHJ1ZSwnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzp0cnVlLCdjaGFydC56b29tLmFjdGlvbic6J3pvb20nLCdjaGFydC5hcnJvd3MnOmZhbHNlLCdjaGFydC5tYXJnaW4nOjAsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzpbMCwwXSwnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzpudWxsLCdjaGFydC5sYWJlbC5pbm5lcic6ZmFsc2UsJ2NoYXJ0LmxhYmVscy5jb3VudCc6MTAsJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbic6J3JpZ2h0JywnY2hhcnQubGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzowLCdjaGFydC5hZGp1c3RhYmxlJzpmYWxzZSwnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOjAsJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzonLCcsJ2NoYXJ0LnNjYWxlLnBvaW50JzonLicsJ2NoYXJ0LmtleSc6bnVsbCwnY2hhcnQua2V5LmJhY2tncm91bmQnOid3aGl0ZScsJ2NoYXJ0LmtleS5wb3NpdGlvbic6J2dyYXBoJywnY2hhcnQua2V5LmhhbGlnbic6J3JpZ2h0JywnY2hhcnQua2V5LnNoYWRvdyc6ZmFsc2UsJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzozLCdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOjIsJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6MiwnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6ZmFsc2UsJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzpudWxsLCdjaGFydC5rZXkucG9zaXRpb24ueSc6bnVsbCwnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzonc3F1YXJlJywnY2hhcnQua2V5LnJvdW5kZWQnOnRydWUsJ2NoYXJ0LmtleS5saW5ld2lkdGgnOjEsJ2NoYXJ0LmtleS5jb2xvcnMnOm51bGwsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6ZmFsc2UsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzonIzAwMCcsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCc6J3JnYmEoMjU1LDI1NSwyNTUsMC43KScsJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOidyZ2JhKDI1NSwwLDAsMC4yKScsJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzonYmxhY2snLCdjaGFydC5ldmVudHMuY2xpY2snOm51bGwsJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOm51bGwsJ2NoYXJ0LmJvcmRlci5pbm5lcic6dHJ1ZSwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW1BST0dSRVNTXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjt9XG52YXIgbGluZWFyX2RhdGE9UkdyYXBoLmFycmF5TGluZWFyaXplKHRoaXMudmFsdWUpO2Zvcih2YXIgaT0wO2k8bGluZWFyX2RhdGEubGVuZ3RoOysraSl7dGhpc1snJCcraV09e307fVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbmlmKG5hbWU9PSdjaGFydC5zdHJva2VzdHlsZScpe3Byb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ109dmFsdWU7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXT12YWx1ZTtyZXR1cm47fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5wcm9wW25hbWUudG9Mb3dlckNhc2UoKV09dmFsdWU7cmV0dXJuIHRoaXM7fTt0aGlzLmdldD10aGlzLkdldD1mdW5jdGlvbihuYW1lKVxue2lmKG5hbWUuc3Vic3RyKDAsNikhPSdjaGFydC4nKXtuYW1lPSdjaGFydC4nK25hbWU7fVxud2hpbGUobmFtZS5tYXRjaCgvKFtBLVpdKS8pKXtuYW1lPW5hbWUucmVwbGFjZSgvKFtBLVpdKS8sJy4nK1JlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTt9XG5yZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO307dGhpcy5kcmF3PXRoaXMuRHJhdz1mdW5jdGlvbigpXG57UkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsJ29uYmVmb3JlZHJhdycpO2lmKCF0aGlzLmNvbG9yc1BhcnNlZCl7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkPXRydWU7fVxudGhpcy5jdXJyZW50VmFsdWU9dGhpcy52YWx1ZTt0aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy53aWR0aD1jYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodDt0aGlzLmhlaWdodD1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuRHJhd2JhcigpO3RoaXMuRHJhd1RpY2tNYXJrcygpO3RoaXMuRHJhd0xhYmVscygpO3RoaXMuRHJhd1RpdGxlcygpO2lmKHByb3BbJ2NoYXJ0LmJldmVsJ10pe3RoaXMuRHJhd0JldmVsKCk7fVxuaWYocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSl7UkcuU2hvd0NvbnRleHQodGhpcyk7fVxuUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmKHByb3BbJ2NoYXJ0LmtleSddJiZwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpe1JHLkRyYXdLZXkodGhpcyxwcm9wWydjaGFydC5rZXknXSxwcm9wWydjaGFydC5jb2xvcnMnXSk7fVxuaWYocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pe1JHLkFsbG93UmVzaXppbmcodGhpcyk7fVxudGhpcy5BbGxvd0FkanVzdGluZygpO2lmKHRoaXMuZmlyc3REcmF3KXtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdz1mYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTt9XG5SRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25kcmF3Jyk7cmV0dXJuIHRoaXM7fTt0aGlzLmRyYXdiYXI9dGhpcy5EcmF3YmFyPWZ1bmN0aW9uKClcbnt0aGlzLnNjYWxlMj1SRy5nZXRTY2FsZTIodGhpcyx7J21heCc6dGhpcy5tYXgsJ21pbic6dGhpcy5taW4sJ3N0cmljdCc6dHJ1ZSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnBvaW50Jzpwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCdzY2FsZS5kZWNpbWFscyc6cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwneWxhYmVscy5jb3VudCc6cHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J119KTtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31cbmNvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXTtjby5zdHJva2VSZWN0KHRoaXMuZ3V0dGVyTGVmdCx0aGlzLmd1dHRlclRvcCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KTtjby5maWxsUmVjdCh0aGlzLmd1dHRlckxlZnQsdGhpcy5ndXR0ZXJUb3AsdGhpcy53aWR0aCx0aGlzLmhlaWdodCk7Ukcubm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXTtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQuY29sb3JzJ11bMF07dmFyIG1hcmdpbj1wcm9wWydjaGFydC5tYXJnaW4nXTt2YXIgYmFySGVpZ2h0PShjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pKigoUkcuYXJyYXlTdW0odGhpcy52YWx1ZSktdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikpO2lmKHR5cGVvZiB0aGlzLnZhbHVlPT09J251bWJlcicpe2NvLmxpbmVXaWR0aD0xO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ107aWYocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pe3RoaXMuZHJhd0N1cnZlZEJhcih7eDp0aGlzLmd1dHRlckxlZnQrbWFyZ2luLHk6dGhpcy5ndXR0ZXJUb3ArKHRoaXMuaGVpZ2h0LWJhckhlaWdodCksd2lkdGg6dGhpcy53aWR0aC1tYXJnaW4tbWFyZ2luLGhlaWdodDpiYXJIZWlnaHQsc3Ryb2tlOnByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ119KTt9XG50aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5ndXR0ZXJMZWZ0K21hcmdpbix5OnRoaXMuZ3V0dGVyVG9wKyh0aGlzLmhlaWdodC1iYXJIZWlnaHQpLHdpZHRoOnRoaXMud2lkdGgtbWFyZ2luLW1hcmdpbixoZWlnaHQ6YmFySGVpZ2h0LGZpbGw6cHJvcFsnY2hhcnQuY29sb3JzJ11bMF19KTt9ZWxzZSBpZih0eXBlb2YgdGhpcy52YWx1ZT09J29iamVjdCcpe2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ107dmFyIHN0YXJ0UG9pbnQ9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tO2Zvcih2YXIgaT0wLGxlbj10aGlzLnZhbHVlLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciBzZWdtZW50SGVpZ2h0PSgodGhpcy52YWx1ZVtpXS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS10aGlzLmd1dHRlclRvcCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO2NvLmJlZ2luUGF0aCgpO2lmKHByb3BbJ2NoYXJ0LmJvcmRlci5pbm5lciddKXt0aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5ndXR0ZXJMZWZ0K21hcmdpbix5OnN0YXJ0UG9pbnQtc2VnbWVudEhlaWdodCx3aWR0aDp0aGlzLndpZHRoLW1hcmdpbi1tYXJnaW4saGVpZ2h0OnNlZ21lbnRIZWlnaHQsc3Ryb2tlOmNvLnN0cm9rZVN0eWxlfSk7fVxudGhpcy5kcmF3Q3VydmVkQmFyKHt4OnRoaXMuZ3V0dGVyTGVmdCttYXJnaW4seTpzdGFydFBvaW50LXNlZ21lbnRIZWlnaHQsd2lkdGg6dGhpcy53aWR0aC1tYXJnaW4tbWFyZ2luLGhlaWdodDpzZWdtZW50SGVpZ2h0LGZpbGw6Y28uZmlsbFN0eWxlfSk7dGhpcy5jb29yZHMucHVzaChbdGhpcy5ndXR0ZXJMZWZ0K21hcmdpbixzdGFydFBvaW50LXNlZ21lbnRIZWlnaHQsdGhpcy53aWR0aC1tYXJnaW4tbWFyZ2luLHNlZ21lbnRIZWlnaHRdKTtzdGFydFBvaW50LT1zZWdtZW50SGVpZ2h0O31cbmNvLmZpbGwoKTt9XG5pZihwcm9wWydjaGFydC50aWNrbWFya3MuaW5uZXInXSl7dmFyIHNwYWNpbmc9KGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvcHJvcFsnY2hhcnQubnVtdGlja3MuaW5uZXInXTtjby5saW5lV2lkdGg9MTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgeT10aGlzLmd1dHRlclRvcDt5PGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbTt5Kz1zcGFjaW5nKXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQrMyxNYXRoLnJvdW5kKHkpKTtjby5tb3ZlVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCxNYXRoLnJvdW5kKHkpKTtjby5saW5lVG8oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodC0zLE1hdGgucm91bmQoeSkpO31cbmNvLnN0cm9rZSgpO31cbmNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ107aWYodHlwZW9mIHRoaXMudmFsdWU9PSdudW1iZXInKXtpZihwcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXSl7dGhpcy5kcmF3Q3VydmVkQmFyKHt4OnRoaXMuZ3V0dGVyTGVmdCttYXJnaW4seTp0aGlzLmd1dHRlclRvcCt0aGlzLmhlaWdodC1iYXJIZWlnaHQsd2lkdGg6dGhpcy53aWR0aC1tYXJnaW4tbWFyZ2luLGhlaWdodDpiYXJIZWlnaHR9KTt9XG50aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5ndXR0ZXJMZWZ0K21hcmdpbix5OnRoaXMuZ3V0dGVyVG9wK3RoaXMuaGVpZ2h0LWJhckhlaWdodCx3aWR0aDp0aGlzLndpZHRoLW1hcmdpbi1tYXJnaW4saGVpZ2h0OmJhckhlaWdodH0pO3RoaXMuY29vcmRzLnB1c2goW3RoaXMuZ3V0dGVyTGVmdCttYXJnaW4sdGhpcy5ndXR0ZXJUb3ArdGhpcy5oZWlnaHQtYmFySGVpZ2h0LHRoaXMud2lkdGgtbWFyZ2luLW1hcmdpbixiYXJIZWlnaHRdKTt9XG5pZihwcm9wWydjaGFydC5hcnJvd3MnXSl7dmFyIHg9dGhpcy5ndXR0ZXJMZWZ0LTQ7dmFyIHk9Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tLWJhckhlaWdodDtjby5saW5lV2lkdGg9MTtjby5maWxsU3R5bGU9J2JsYWNrJztjby5zdHJva2VTdHlsZT0nYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LHkpO2NvLmxpbmVUbyh4LTQseS0yKTtjby5saW5lVG8oeC00LHkrMik7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO3grPXRoaXMud2lkdGgrODtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCx5KTtjby5saW5lVG8oeCs0LHktMik7Y28ubGluZVRvKHgrNCx5KzIpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtwYTIoY28sJ2InKTt9XG5pZihwcm9wWydjaGFydC5sYWJlbC5pbm5lciddKXtjby5maWxsU3R5bGU9J2JsYWNrJztSRy50ZXh0Mih0aGlzLHsnZm9udCc6cHJvcFsnY2hhcnQudGV4dC5mb250J10sJ3NpemUnOnByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCd4JzooKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8yKSt0aGlzLmd1dHRlckxlZnQsJ3knOnRoaXMuY29vcmRzW3RoaXMuY29vcmRzLmxlbmd0aC0xXVsxXS01LCd0ZXh0JzpSR3JhcGgubnVtYmVyX2Zvcm1hdCh0aGlzLCh0eXBlb2YodGhpcy52YWx1ZSk9PSdudW1iZXInP3RoaXMudmFsdWU6UkcuYXJyYXlfc3VtKHRoaXMudmFsdWUpKS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKSwndmFsaWduJzonYm90dG9tJywnaGFsaWduJzonY2VudGVyJywnYm91bmRpbmcnOnRydWUsJ2JvdW5kaW5nRmlsbCc6J3doaXRlJywndGFnJzonbGFiZWwuaW5uZXInfSk7fX07dGhpcy5kcmF3VGlja01hcmtzPXRoaXMuRHJhd1RpY2tNYXJrcz1mdW5jdGlvbigpXG57Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ107aWYocHJvcFsnY2hhcnQudGlja21hcmtzJ10pe2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0wO3Byb3BbJ2NoYXJ0LnRpY2ttYXJrcy56ZXJvc3RhcnQnXT9pPD1wcm9wWydjaGFydC5udW10aWNrcyddOmk8cHJvcFsnY2hhcnQubnVtdGlja3MnXTtpKyspe3ZhciBzdGFydFg9cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSdsZWZ0Jz90aGlzLmd1dHRlckxlZnQ6Y2Eud2lkdGgtcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dmFyIGVuZFg9cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSdsZWZ0Jz9zdGFydFgtNDpzdGFydFgrNDt2YXIgeVBvcz0odGhpcy5oZWlnaHQqKGkvcHJvcFsnY2hhcnQubnVtdGlja3MnXSkpK3RoaXMuZ3V0dGVyVG9wXG5jby5tb3ZlVG8oc3RhcnRYLG1hLnJvdW5kKHlQb3MpKTtjby5saW5lVG8oZW5kWCxtYS5yb3VuZCh5UG9zKSk7fVxuY28uc3Ryb2tlKCk7fX07dGhpcy5kcmF3TGFiZWxzPXRoaXMuRHJhd0xhYmVscz1mdW5jdGlvbigpXG57aWYoIVJHLmlzX251bGwocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10pKXtyZXR1cm4gdGhpcy5EcmF3U3BlY2lmaWNMYWJlbHMoKTt9XG5jby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBwb3NpdGlvbj1wcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXS50b0xvd2VyQ2FzZSgpO3ZhciB4QWxpZ25tZW50PXBvc2l0aW9uPT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7dmFyIHlBbGlnbm1lbnQ9J2NlbnRlcic7dmFyIGNvdW50PXByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO3ZhciB1bml0c19wcmU9cHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciB0ZXh0X3NpemU9cHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIHRleHRfZm9udD1wcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgZGVjaW1hbHM9cHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTt2YXIgb2Zmc2V0eD1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddO3ZhciBvZmZzZXR5PXByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J107aWYocHJvcFsnY2hhcnQudGlja21hcmtzJ10pe2Zvcih2YXIgaT0wO2k8Y291bnQ7KytpKXtSRy50ZXh0Mih0aGlzLHtmb250OnRleHRfZm9udCxzaXplOnRleHRfc2l6ZSx4OnBvc2l0aW9uPT0nbGVmdCc/KHRoaXMuZ3V0dGVyTGVmdC03K29mZnNldHgpOihjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzcpK29mZnNldHgseTooKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pL2NvdW50KSppKSt0aGlzLmd1dHRlclRvcCtvZmZzZXR5LHRleHQ6dGhpcy5zY2FsZTIubGFiZWxzW3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgtKGkrMSldLHZhbGlnbjp5QWxpZ25tZW50LGhhbGlnbjp4QWxpZ25tZW50LHRhZzonc2NhbGUnfSk7fVxuaWYocHJvcFsnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCddJiZ0aGlzLm1pbj09MCl7UkcudGV4dDIodGhpcyx7Zm9udDp0ZXh0X2ZvbnQsc2l6ZTp0ZXh0X3NpemUseDpwb3NpdGlvbj09J2xlZnQnPyh0aGlzLmd1dHRlckxlZnQtNStvZmZzZXR4KTooY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs1K29mZnNldHgpLHk6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tK29mZnNldHksJ3RleHQnOlJHLm51bWJlckZvcm1hdCh0aGlzLHRoaXMubWluLnRvRml4ZWQodGhpcy5taW49PT0wPzA6ZGVjaW1hbHMpLHVuaXRzX3ByZSx1bml0c19wb3N0KSx2YWxpZ246eUFsaWdubWVudCxoYWxpZ246eEFsaWdubWVudCx0YWc6J3NjYWxlJ30pO31cbmlmKHRoaXMubWluIT0wKXtSRy50ZXh0Mih0aGlzLHtmb250OnRleHRfZm9udCxzaXplOnRleHRfc2l6ZSx4OnBvc2l0aW9uPT0nbGVmdCc/KHRoaXMuZ3V0dGVyTGVmdC01K29mZnNldHgpOihjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzUrb2Zmc2V0eCkseTpjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20rb2Zmc2V0eSx0ZXh0OlJHLm51bWJlcl9mb3JtYXQodGhpcyx0aGlzLm1pbi50b0ZpeGVkKGRlY2ltYWxzKSx1bml0c19wcmUsdW5pdHNfcG9zdCksdmFsaWduOnlBbGlnbm1lbnQsaGFsaWduOnhBbGlnbm1lbnQsdGFnOidzY2FsZSd9KTt9fX07dGhpcy5kcmF3VGl0bGVzPXRoaXMuRHJhd1RpdGxlcz1mdW5jdGlvbigpXG57dmFyIHRleHRfc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgdGV4dF9mb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciB0aXRsZV9zaXplPXByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXT9wcm9wWydjaGFydC50aXRsZS5zaXplJ106dGV4dF9zaXplKzI7aWYocHJvcFsnY2hhcnQudGl0bGUnXS5sZW5ndGg+MCl7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ107UkcudGV4dDIodGhpcyx7J2ZvbnQnOnByb3BbJ2NoYXJ0LnRpdGxlLmZvbnQnXT9wcm9wWydjaGFydC50aXRsZS5mb250J106dGV4dF9mb250LCdzaXplJzp0aXRsZV9zaXplLCd4Jzp0aGlzLmd1dHRlckxlZnQrKChjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCkvMiksJ3knOnRoaXMuZ3V0dGVyVG9wLTUsJ3RleHQnOnByb3BbJ2NoYXJ0LnRpdGxlJ10sJ3ZhbGlnbic6J2JvdHRvbScsJ2hhbGlnbic6J2NlbnRlcicsJ2JvbGQnOnByb3BbJ2NoYXJ0LnRpdGxlLmJvbGQnXSwndGFnJzondGl0bGUnfSk7fVxuaWYodHlwZW9mKHByb3BbJ2NoYXJ0LnRpdGxlLnNpZGUnXSk9PSdzdHJpbmcnKXtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQudGl0bGUuc2lkZS5jb2xvciddO1JHLlRleHQyKHRoaXMseydmb250Jzpwcm9wWydjaGFydC50aXRsZS5zaWRlLmZvbnQnXSwnc2l6ZSc6cHJvcFsnY2hhcnQudGl0bGUuc2lkZS5zaXplJ10sJ3gnOnByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddPT0ncmlnaHQnP3RoaXMuZ3V0dGVyTGVmdC0xMDooY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkrMTAsJ3knOnRoaXMuZ3V0dGVyVG9wKyh0aGlzLmhlaWdodC8yKSwndGV4dCc6cHJvcFsnY2hhcnQudGl0bGUuc2lkZSddLCd2YWxpZ24nOidib3R0b20nLCdoYWxpZ24nOidjZW50ZXInLCdhbmdsZSc6cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSdyaWdodCc/MjcwOjkwLCdib2xkJzpwcm9wWydjaGFydC50aXRsZS5zaWRlLmJvbGQnXSwndGFnJzondGl0bGUuc2lkZSd9KTt9fTt0aGlzLmdldFNoYXBlPXRoaXMuZ2V0QmFyPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKSxtb3VzZVg9bW91c2VYWVswXSxtb3VzZVk9bW91c2VYWVsxXVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuY29vcmRzLmxlbmd0aDtpPGxlbjtpKyspe3ZhciB4PXRoaXMuY29vcmRzW2ldWzBdLHk9dGhpcy5jb29yZHNbaV1bMV0sdz10aGlzLmNvb3Jkc1tpXVsyXSxoPXRoaXMuY29vcmRzW2ldWzNdLGlkeD1pO2NvLmJlZ2luUGF0aCgpO3RoaXMuZHJhd0N1cnZlZEJhcih7eDp4LHk6eSx3aWR0aDp3LGhlaWdodDpofSk7aWYoY28uaXNQb2ludEluUGF0aChtb3VzZVgsbW91c2VZKSl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO3JldHVybnswOnRoaXMsJ29iamVjdCc6dGhpcywxOngsJ3gnOngsMjp5LCd5Jzp5LDM6dywnd2lkdGgnOncsNDpoLCdoZWlnaHQnOmgsNTppLCdpbmRleCc6aSwndG9vbHRpcCc6dG9vbHRpcH07fX19O3RoaXMuZ2V0VmFsdWU9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VDb29yZHM9UkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYPW1vdXNlQ29vcmRzWzBdO3ZhciBtb3VzZVk9bW91c2VDb29yZHNbMV07dmFyIHZhbHVlPSh0aGlzLmhlaWdodC0obW91c2VZLXRoaXMuZ3V0dGVyVG9wKSkvdGhpcy5oZWlnaHQ7dmFsdWUqPXRoaXMubWF4LXRoaXMubWluO3ZhbHVlKz10aGlzLm1pbjtpZih2YWx1ZT50aGlzLm1heCl2YWx1ZT10aGlzLm1heDtpZih2YWx1ZTx0aGlzLm1pbil2YWx1ZT10aGlzLm1pbjtyZXR1cm4gdmFsdWU7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXt2YXIgbGFzdD1zaGFwZS5pbmRleD09PXRoaXMuY29vcmRzLmxlbmd0aC0xO3RoaXMuZHJhd0N1cnZlZEJhcih7eDpzaGFwZS54LHk6c2hhcGUueSx3aWR0aDpzaGFwZS53aWR0aCxoZWlnaHQ6c2hhcGUuaGVpZ2h0LHN0cm9rZTpwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10sZmlsbDpwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddfSk7fX07dGhpcy5nZXRPYmplY3RCeVhZPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkcuZ2V0TW91c2VYWShlKTtpZihtb3VzZVhZWzBdPnRoaXMuZ3V0dGVyTGVmdCYmbW91c2VYWVswXTwoY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJm1vdXNlWFlbMV0+PXRoaXMuZ3V0dGVyVG9wJiZtb3VzZVhZWzFdPD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5hbGxvd0FkanVzdGluZz10aGlzLkFsbG93QWRqdXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuO307dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlPXRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZT1mdW5jdGlvbihlKVxue2lmKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSYmUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQ9PXRoaXMudWlkKXt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO3ZhciB2YWx1ZT10aGlzLmdldFZhbHVlKGUpO2lmKHR5cGVvZiB2YWx1ZT09PSdudW1iZXInKXtSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywnb25hZGp1c3QnKTt0aGlzLnZhbHVlPU51bWJlcih2YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKTtSRy5SZWRyYXdDYW52YXModGhpcy5jYW52YXMpO319fTt0aGlzLmRyYXdTcGVjaWZpY0xhYmVscz10aGlzLkRyYXdTcGVjaWZpY0xhYmVscz1mdW5jdGlvbigpXG57dmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMnXTtpZihsYWJlbHMpe3ZhciBmb250PXByb3BbJ2NoYXJ0LnRleHQuZm9udCddO3ZhciBzaXplPXByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciBoYWxpZ249cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSdyaWdodCc/J2xlZnQnOidyaWdodCc7dmFyIHN0ZXA9dGhpcy5oZWlnaHQvKGxhYmVscy5sZW5ndGgtMSk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlPXByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IodmFyIGk9MDtpPGxhYmVscy5sZW5ndGg7KytpKXtSRy5UZXh0Mih0aGlzLHsnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwneCc6cHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ109PSdyaWdodCc/Y2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCs3OnRoaXMuZ3V0dGVyTGVmdC03LCd5JzoodGhpcy5oZWlnaHQrdGhpcy5ndXR0ZXJUb3ApLShzdGVwKmkpLCd0ZXh0JzpsYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6aGFsaWduLCd0YWcnOidsYWJlbHMuc3BlY2lmaWMnfSk7fVxuY28uZmlsbCgpO319O3RoaXMuZ2V0WUNvb3JkPWZ1bmN0aW9uKHZhbHVlKVxue2lmKHZhbHVlPnRoaXMubWF4fHx2YWx1ZTx0aGlzLm1pbil7cmV0dXJuIG51bGw7fVxudmFyIGJhckhlaWdodD1jYS5oZWlnaHQtcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddLXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt2YXIgY29vcmQ9KCh2YWx1ZS10aGlzLm1pbikvKHRoaXMubWF4LXRoaXMubWluKSkqYmFySGVpZ2h0O2Nvb3JkPWNhLmhlaWdodC1jb29yZC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107cmV0dXJuIGNvb3JkO307dGhpcy5vdmVyQ2hhcnRBcmVhPWZ1bmN0aW9uKGUpXG57dmFyIG1vdXNlWFk9UkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWD1tb3VzZVhZWzBdO3ZhciBtb3VzZVk9bW91c2VYWVsxXTtpZihtb3VzZVg+PXRoaXMuZ3V0dGVyTGVmdCYmbW91c2VYPD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJSaWdodCkmJm1vdXNlWT49dGhpcy5ndXR0ZXJUb3AmJm1vdXNlWTw9KGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSkpe3JldHVybiB0cnVlO31cbnJldHVybiBmYWxzZTt9O3RoaXMucGFyc2VDb2xvcnM9ZnVuY3Rpb24oKVxue2lmKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aD09PTApe3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5jb2xvciddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5jb2xvciddKTt9XG52YXIgY29sb3JzPXByb3BbJ2NoYXJ0LmNvbG9ycyddO2Zvcih2YXIgaT0wLGxlbj1jb2xvcnMubGVuZ3RoO2k8bGVuOysraSl7Y29sb3JzW2ldPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7fVxucHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO307dGhpcy5yZXNldD1mdW5jdGlvbigpXG57fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudD1mdW5jdGlvbihjb2xvcilcbntpZighY29sb3J8fHR5cGVvZiBjb2xvciE9J3N0cmluZycpe3JldHVybiBjb2xvcjt9XG5pZihjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpe3ZhciBwYXJ0cz1SZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZD1jby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLGNhLmhlaWdodC1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sMCxwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pO3ZhciBkaWZmPTEvKHBhcnRzLmxlbmd0aC0xKTtncmFkLmFkZENvbG9yU3RvcCgwLFJHLnRyaW0ocGFydHNbMF0pKTtmb3IodmFyIGo9MSxsZW49cGFydHMubGVuZ3RoO2o8bGVuOysrail7Z3JhZC5hZGRDb2xvclN0b3AoaipkaWZmLFJHLnRyaW0ocGFydHNbal0pKTt9XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO31cbnJldHVybiBncmFkP2dyYWQ6Y29sb3I7fTt0aGlzLmRyYXdCZXZlbD10aGlzLkRyYXdCZXZlbD1mdW5jdGlvbigpXG57Zm9yKHZhciBpPTAsaGVpZ2h0PTA7aTx0aGlzLmNvb3Jkcy5sZW5ndGg7KytpKXtoZWlnaHQrPXRoaXMuY29vcmRzW2ldWzNdO31cbmNvLnNhdmUoKTtjby5iZWdpblBhdGgoKTtjby5yZWN0KHRoaXMuY29vcmRzWzBdWzBdLHRoaXMuY29vcmRzW3RoaXMuY29vcmRzLmxlbmd0aC0xXVsxXS0xLHRoaXMuY29vcmRzWzBdWzJdLGhlaWdodCk7Y28uY2xpcCgpO2NvLnNhdmUoKTtjby5iZWdpblBhdGgoKTt0aGlzLmRyYXdDdXJ2ZWRCYXIoe3g6dGhpcy5jb29yZHNbMF1bMF0seTp0aGlzLmNvb3Jkc1t0aGlzLmNvb3Jkcy5sZW5ndGgtMV1bMV0tMSx3aWR0aDp0aGlzLmNvb3Jkc1swXVsyXSxoZWlnaHQ6aGVpZ2h0fSk7Y28uY2xpcCgpO2NvLmJlZ2luUGF0aCgpO2NvLnNoYWRvd0NvbG9yPSdibGFjayc7Y28uc2hhZG93T2Zmc2V0WD0wO2NvLnNoYWRvd09mZnNldFk9MDtjby5zaGFkb3dCbHVyPTE1O2NvLmxpbmVXaWR0aD0yO3RoaXMuZHJhd0N1cnZlZEJhcih7eDp0aGlzLmNvb3Jkc1swXVswXS0xLHk6dGhpcy5jb29yZHNbdGhpcy5jb29yZHMubGVuZ3RoLTFdWzFdLTEsd2lkdGg6dGhpcy5jb29yZHNbMF1bMl0rMixoZWlnaHQ6aGVpZ2h0KzIrMTAwfSk7Y28uc3Ryb2tlKCk7Y28ucmVzdG9yZSgpO2NvLnJlc3RvcmUoKTt9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQ9ZnVuY3Rpb24oaW5kZXgpXG57dmFyIGNvb3Jkcz10aGlzLmNvb3Jkc1tpbmRleF07Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5saW5lV2lkdGg9Mjtjby5maWxsU3R5bGU9cHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28ucmVjdChjb29yZHNbMF0sY29vcmRzWzFdLGNvb3Jkc1syXSxjb29yZHNbM10pO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGg9MTt9O3RoaXMub249ZnVuY3Rpb24odHlwZSxmdW5jKVxue2lmKHR5cGUuc3Vic3RyKDAsMikhPT0nb24nKXt0eXBlPSdvbicrdHlwZTt9XG5pZih0eXBlb2YgdGhpc1t0eXBlXSE9PSdmdW5jdGlvbicpe3RoaXNbdHlwZV09ZnVuYzt9ZWxzZXtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsdHlwZSxmdW5jKTt9XG5yZXR1cm4gdGhpczt9O3RoaXMuZHJhd0N1cnZlZEJhcj1mdW5jdGlvbihvcHQpXG57cGEyKGNvLCdiIHIgJSAlICUgJScsb3B0Lngsb3B0Lnksb3B0LndpZHRoLG9wdC5oZWlnaHQpO2lmKG9wdC5zdHJva2Upe2NvLnN0cm9rZVN0eWxlPW9wdC5zdHJva2U7Y28uc3Ryb2tlKCk7fVxuaWYob3B0LmZpbGwpe2NvLmZpbGxTdHlsZT1vcHQuZmlsbDtjby5maWxsKCk7fX1cbnRoaXMuZmlyc3REcmF3RnVuYz1mdW5jdGlvbigpXG57fTt0aGlzLmV4ZWM9ZnVuY3Rpb24oZnVuYylcbntmdW5jKHRoaXMpO3JldHVybiB0aGlzO307dGhpcy5ncm93PWZ1bmN0aW9uKClcbnt2YXIgb2JqPXRoaXM7dmFyIGNhbnZhcz1vYmouY2FudmFzO3ZhciBjb250ZXh0PW9iai5jb250ZXh0O3ZhciBpbml0aWFsX3ZhbHVlPW9iai5jdXJyZW50VmFsdWU7dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBudW1GcmFtZXM9b3B0LmZyYW1lc3x8MzA7dmFyIGZyYW1lPTBcbnZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTtpZih0eXBlb2Ygb2JqLnZhbHVlPT09J29iamVjdCcpe2lmKFJHcmFwaC5pc19udWxsKG9iai5jdXJyZW50VmFsdWUpKXtvYmouY3VycmVudFZhbHVlPVtdO2Zvcih2YXIgaT0wO2k8b2JqLnZhbHVlLmxlbmd0aDsrK2kpe29iai5jdXJyZW50VmFsdWVbaV09MDt9fVxudmFyIGRpZmY9W107dmFyIGluY3JlbWVudD1bXTtmb3IodmFyIGk9MDtpPG9iai52YWx1ZS5sZW5ndGg7KytpKXtkaWZmW2ldPW9iai52YWx1ZVtpXS1OdW1iZXIob2JqLmN1cnJlbnRWYWx1ZVtpXSk7aW5jcmVtZW50W2ldPWRpZmZbaV0vbnVtRnJhbWVzO31cbmlmKGluaXRpYWxfdmFsdWU9PW51bGwpe2luaXRpYWxfdmFsdWU9W107Zm9yKHZhciBpPTA7aTxvYmoudmFsdWUubGVuZ3RoOysraSl7aW5pdGlhbF92YWx1ZVtpXT0wO319fWVsc2V7dmFyIGRpZmY9b2JqLnZhbHVlLU51bWJlcihvYmouY3VycmVudFZhbHVlKTt2YXIgaW5jcmVtZW50PWRpZmYvbnVtRnJhbWVzO31cbmZ1bmN0aW9uIGl0ZXJhdG9yKClcbntmcmFtZSsrO2lmKGZyYW1lPD1udW1GcmFtZXMpe2lmKHR5cGVvZiBvYmoudmFsdWU9PSdvYmplY3QnKXtvYmoudmFsdWU9W107Zm9yKHZhciBpPTA7aTxpbml0aWFsX3ZhbHVlLmxlbmd0aDsrK2kpe29iai52YWx1ZVtpXT1pbml0aWFsX3ZhbHVlW2ldKyhpbmNyZW1lbnRbaV0qZnJhbWUpO319ZWxzZXtvYmoudmFsdWU9aW5pdGlhbF92YWx1ZSsoaW5jcmVtZW50KmZyYW1lKTt9XG5SR3JhcGguY2xlYXIob2JqLmNhbnZhcyk7UkdyYXBoLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKCk7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO319O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBvdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnZwcm9ncmVzcy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///251\n");

/***/ }),
/* 252 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Waterfall = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf, data: arguments[1] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'waterfall';this.max = 0;this.data = conf.data;this.isRGraph = true;this.coords = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.hbars': null, 'chart.linewidth': 1, 'chart.axis.linewidth': 1, 'chart.xaxispos': 'bottom', 'chart.numxticks': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.strokestyle': '#666', 'chart.axis.color': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymax': null, 'chart.title': '', 'chart.title.color': 'black', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.align': 'left', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['green', 'red', 'blue'], 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.override': null, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false }, _defineProperty(_properties, 'chart.axis.color', 'black'), _defineProperty(_properties, 'chart.total', true), _defineProperty(_properties, 'chart.multiplier.x', 1), _defineProperty(_properties, 'chart.multiplier.w', 1), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.ylabels.count', 5), _defineProperty(_properties, 'chart.ymin', 0), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[WATERFALL] No canvas support');return;\n  }\n  for (var i = 0, len = this.data.length; i <= len; ++i) {\n    this['$' + i] = {};\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.total' && prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RGraph.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RGraph.DrawBackgroundImage(this);this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.halfTextHeight = prop['chart.text.size'] / 2;this.max = this.getMax(this.data);var decimals = prop['chart.scale.decimals'];this.scale2 = RG.getScale2(this, { max: typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, min: prop['chart.ymin'], strict: typeof prop['chart.ymax'] === 'number' ? true : false, 'scale.decimals': Number(decimals), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.ylabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;RG.drawBars(this);\n    RG.Background.draw(this);this.DrawAxes();this.Drawbars();this.DrawLabels();if (prop['chart.xaxispos'] === 'bottom' && prop['chart.noaxes'] === false && prop['chart.noxaxis'] === false && prop['chart.ymin'] === 0) {\n      co.strokeStyle = prop['chart.axis.color'];co.strokeRect(prop['chart.gutter.left'], ca.height - prop['chart.gutter.bottom'], ca.width - this.gutterLeft - this.gutterRight, 0);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (prop['chart.noyaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.gutterTop);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));co.lineTo(ca.width - this.gutterRight, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));\n      } else {\n        var y = ma.floor(this.getYCoord(0));co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] === false && prop['chart.numyticks'] > 0) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;for (y = this.gutterTop; y < ca.height - this.gutterBottom; y += yTickGap) {\n        if (prop['chart.xaxispos'] == 'bottom' || y != (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop) {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] || prop['chart.xaxispos'] == 'center' || prop['chart.ymin'] !== 0) {\n        co.moveTo(this.gutterLeft - 3, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));\n      }\n    }\n    if (prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length + (prop['chart.total'] ? 1 : 0);\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (prop['chart.xaxispos'] == 'center') {\n        yStart = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop - 3;yEnd = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop + 3;\n      } else {\n        yStart = this.getYCoord(0) - (this.scale2.min < 0 ? 3 : 0);yEnd = this.getYCoord(0) + 3;\n      }\n      for (x = this.gutterLeft + xTickGap; x <= ca.width - this.gutterRight + 1; x += xTickGap) {\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.noyaxis']) {\n        co.moveTo(ma.round(this.gutterLeft), yStart);co.lineTo(ma.round(this.gutterLeft), yEnd);\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.getYCoord(0));co.lineTo(ma.round(this.gutterLeft), this.getYCoord(0));\n    }\n    co.stroke();\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co,\n        numYLabels = 5,\n        interval = this.grapharea / numYLabels,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];co.beginPath();co.fillStyle = color;if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        var halfInterval = interval / 2;var halfWay = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n          RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: this.gutterTop + this.grapharea / 2 / len * i + offsety, text: this.scale2.labels[len - i - 1], valign: 'center', halign: 'right', tag: 'scale' });RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: halfWay + this.grapharea / 2 / len * (i + 1) + offsety, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart']) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: halfWay, text: '0', font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      } else {\n        for (var i = 0, len = this.scale2.values.length; i < len; ++i) {\n          var y = this.getYCoord(this.scale2.values[i]) + offsety;RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: y, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart'] || prop['chart.ymin'] !== 0) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: this.getYCoord(prop['chart.ymin'] || 0), text: RG.numberFormat(this, String(Number(prop['chart.ymin'] || 0).toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals'])), prop['chart.units.pre'], prop['chart.units.post']), font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      }\n    }\n    if (prop['chart.labels'].length > 0) {\n      interval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length;var halign = 'center';var angle = prop['chart.text.angle'];if (angle) {\n        halign = 'right';angle *= -1;\n      }\n      var labels = prop['chart.labels'],\n          labelsColor = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      for (var i = 0, len = labels.length; i < len; i += 1) {\n        RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'bold': bold, 'x': this.gutterLeft + i * interval + interval / 2 + offsetx, 'y': ca.height - this.gutterBottom + 5 + this.halfTextHeight + offsety, 'text': labels[i], 'valign': 'center', 'halign': halign, 'angle': angle, 'tag': 'labels' });\n      }\n    }\n    co.stroke();co.fill();\n  };this.drawbars = this.Drawbars = function () {\n    var context = co,\n        canvas = ca,\n        hmargin = prop['chart.hmargin'],\n        runningTotal = 0;co.lineWidth = prop['chart.linewidth'] + 0.001;for (var i = 0, len = this.data.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle'];var x = ma.round(this.gutterLeft + hmargin + this.graphwidth / (this.data.length + (prop['chart.total'] ? 1 : 0)) * i * prop['chart.multiplier.x']);var h = this.getYCoord(0) - this.getYCoord(ma.abs(this.data[i]));if (i === 0) {\n        y = this.getYCoord(0) - h;\n      } else {\n        y = this.getYCoord(runningTotal) - h;\n      }\n      y = ma.round(y);var w = (ca.width - this.gutterLeft - this.gutterRight) / (this.data.length + (prop['chart.total'] ? 1 : 0)) - 2 * prop['chart.hmargin'];w = w * prop['chart.multiplier.w'];if (this.data[i] < 0) {\n        y += h;\n      }\n      co.fillStyle = this.data[i] >= 0 ? prop['chart.colors'][0] : prop['chart.colors'][1];if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      } else {\n        RG.noShadow(this);\n      }\n      co.rect(x, ma.floor(y), w, ma.floor(h));this.coords.push([x, y, w, h]);runningTotal += this.data[i];co.stroke();co.fill();\n    }\n    this.total = runningTotal;if (prop['chart.total']) {\n      h = this.getYCoord(0) - this.getYCoord(ma.abs(runningTotal));if (prop['chart.xaxispos'] == 'center') {\n        y = runningTotal > 0 ? this.getYCoord(0) - h : this.getYCoord(0);\n      } else {\n        if (runningTotal > 0) {\n          y = this.getYCoord(0) - h;\n        } else {\n          y = this.getYCoord(0);\n        }\n      }\n      x = x + prop['chart.hmargin'] * 2 + w;co.fillStyle = prop['chart.colors'][2];pa2(co, 'b r % % % % s % f %', x, y, w, h, co.strokeStyle, co.fillStyle);var previousCoords = [x, y, w, ma.abs(h)];this.coords.push(previousCoords);\n    }\n    RG.noShadow(this);co.lineWidth = 1;co.strokeStyle = '#666';co.beginPath();for (var i = 1, len = this.coords.length; i < len; i += 1) {\n      var prev = this.coords[i - 1],\n          curr = this.coords[i],\n          prevData = this.data[i - 1];\n      var y = prevData > 0 ? prev[1] : prev[1] + prev[3];co.moveTo(prev[0] + prev[2], y);co.lineTo(curr[0], prevData > 0 ? prev[1] : prev[1] + prev[3]);\n    }\n    co.stroke();\n  };this.getShape = this.getBar = function (e) {\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getMax = function (data) {\n    var runningTotal = 0,\n        max = 0;for (var i = 0, len = data.length; i < len; i += 1) {\n      runningTotal += data[i];max = ma.max(ma.abs(runningTotal), max);\n    }\n    return ma.abs(max);\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getYCoord = function (value) {\n    if (prop['chart.xaxispos'] == 'center') {\n      if (value < -1 * this.max) {\n        return null;\n      }\n      var coord = value / this.max * (this.grapharea / 2);return this.gutterTop + this.grapharea / 2 - coord;\n    } else {\n      var coord = (value - this.scale2.min) / (this.max - this.scale2.min) * this.grapharea;coord = coord + this.gutterBottom;return ca.height - coord;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var numFrame = 0;var obj = this;var data = RG.array_clone(obj.data);for (var i = 0, len = obj.data.length; i < len; ++i) {\n      obj.data[i] /= frames;\n    }\n    if (obj.Get('chart.ymax') == null) {\n      var max = obj.getMax(data);var scale2 = RG.getScale2(obj, { 'max': max });obj.Set('chart.ymax', scale2.max);\n    }\n    function iterator() {\n      for (var i = 0; i < obj.data.length; ++i) {\n        obj.data[i] = data[i] * RG.Effects.getEasingMultiplier(frames, numFrame);\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (++numFrame < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgud2F0ZXJmYWxsLmpzPzFlY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGg9d2luZG93LlJHcmFwaHx8e2lzUkdyYXBoOnRydWV9O1JHcmFwaC5XYXRlcmZhbGw9ZnVuY3Rpb24oY29uZilcbntpZih0eXBlb2YgY29uZj09PSdvYmplY3QnJiZ0eXBlb2YgY29uZi5kYXRhPT09J29iamVjdCcmJnR5cGVvZiBjb25mLmlkPT09J3N0cmluZycpe3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zPXRydWU7fWVsc2V7dmFyIGNvbmY9e2lkOmNvbmYsZGF0YTphcmd1bWVudHNbMV19O31cbnRoaXMuaWQ9Y29uZi5pZDt0aGlzLmNhbnZhcz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dD90aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fPXRoaXM7dGhpcy50eXBlPSd3YXRlcmZhbGwnO3RoaXMubWF4PTA7dGhpcy5kYXRhPWNvbmYuZGF0YTt0aGlzLmlzUkdyYXBoPXRydWU7dGhpcy5jb29yZHM9W107dGhpcy51aWQ9UkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZD10aGlzLmNhbnZhcy51aWQ/dGhpcy5jYW52YXMudWlkOlJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZD1mYWxzZTt0aGlzLmNvb3Jkc1RleHQ9W107dGhpcy5vcmlnaW5hbF9jb2xvcnM9W107dGhpcy5maXJzdERyYXc9dHJ1ZTt0aGlzLnByb3BlcnRpZXM9eydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6J3JnYmEoMCwwLDAsMCknLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6JyNkZGQnLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQud2lkdGgnOjEsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6MjAsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOnRydWUsJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Jzp0cnVlLCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbic6dHJ1ZSwnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzo1LCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOjIwLCdjaGFydC5iYWNrZ3JvdW5kLmltYWdlJzpudWxsLCdjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJzpudWxsLCdjaGFydC5saW5ld2lkdGgnOjEsJ2NoYXJ0LmF4aXMubGluZXdpZHRoJzoxLCdjaGFydC54YXhpc3Bvcyc6J2JvdHRvbScsJ2NoYXJ0Lm51bXh0aWNrcyc6bnVsbCwnY2hhcnQubnVteXRpY2tzJzoxMCwnY2hhcnQuaG1hcmdpbic6NSwnY2hhcnQuc3Ryb2tlc3R5bGUnOicjNjY2JywnY2hhcnQuYXhpcy5jb2xvcic6J2JsYWNrJywnY2hhcnQuZ3V0dGVyLmxlZnQnOjI1LCdjaGFydC5ndXR0ZXIucmlnaHQnOjI1LCdjaGFydC5ndXR0ZXIudG9wJzoyNSwnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6MjUsJ2NoYXJ0LmxhYmVscyc6W10sJ2NoYXJ0LmxhYmVscy5ib2xkJzpmYWxzZSwnY2hhcnQubGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzowLCdjaGFydC55bGFiZWxzLm9mZnNldHgnOjAsJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSc6MCwnY2hhcnQueWxhYmVscyc6dHJ1ZSwnY2hhcnQudGV4dC5jb2xvcic6J2JsYWNrJywnY2hhcnQudGV4dC5zaXplJzoxMiwnY2hhcnQudGV4dC5hbmdsZSc6MCwnY2hhcnQudGV4dC5mb250JzonU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzp0cnVlLCdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOid2aXNpYmxlJywnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOnRydWUsJ2NoYXJ0LnltYXgnOm51bGwsJ2NoYXJ0LnRpdGxlJzonJywnY2hhcnQudGl0bGUuY29sb3InOidibGFjaycsJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOm51bGwsJ2NoYXJ0LnRpdGxlLmhwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnZwb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzJzonJywnY2hhcnQudGl0bGUueWF4aXMnOicnLCdjaGFydC50aXRsZS55YXhpcy5ib2xkJzp0cnVlLCdjaGFydC50aXRsZS55YXhpcy5zaXplJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5mb250JzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6bnVsbCwnY2hhcnQudGl0bGUueGF4aXMucG9zJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy5wb3MnOm51bGwsJ2NoYXJ0LnRpdGxlLnlheGlzLmFsaWduJzonbGVmdCcsJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOnRydWUsJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOm51bGwsJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzpudWxsLCdjaGFydC50aXRsZS55YXhpcy54JzpudWxsLCdjaGFydC50aXRsZS55YXhpcy55JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy54JzpudWxsLCdjaGFydC50aXRsZS54YXhpcy55JzpudWxsLCdjaGFydC50aXRsZS54JzpudWxsLCdjaGFydC50aXRsZS55JzpudWxsLCdjaGFydC50aXRsZS5oYWxpZ24nOm51bGwsJ2NoYXJ0LnRpdGxlLnZhbGlnbic6bnVsbCwnY2hhcnQuY29sb3JzJzpbJ2dyZWVuJywncmVkJywnYmx1ZSddLCdjaGFydC5zaGFkb3cnOmZhbHNlLCdjaGFydC5zaGFkb3cuY29sb3InOicjNjY2JywnY2hhcnQuc2hhZG93Lm9mZnNldHgnOjMsJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzozLCdjaGFydC5zaGFkb3cuYmx1cic6MywnY2hhcnQudG9vbHRpcHMnOm51bGwsJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6J2ZhZGUnLCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOidSR3JhcGhfdG9vbHRpcCcsJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50Jzonb25jbGljaycsJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6dHJ1ZSwnY2hhcnQudG9vbHRpcHMub3ZlcnJpZGUnOm51bGwsJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOidyZ2JhKDAsMCwwLDApJywnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOidyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCdjaGFydC5jb250ZXh0bWVudSc6bnVsbCwnY2hhcnQudW5pdHMucHJlJzonJywnY2hhcnQudW5pdHMucG9zdCc6JycsJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzowLCdjaGFydC5zY2FsZS5wb2ludCc6Jy4nLCdjaGFydC5zY2FsZS50aG91c2FuZCc6JywnLCdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOnRydWUsJ2NoYXJ0LmNyb3NzaGFpcnMnOmZhbHNlLCdjaGFydC5jcm9zc2hhaXJzLmNvbG9yJzonIzMzMycsJ2NoYXJ0LmNyb3NzaGFpcnMuaGxpbmUnOnRydWUsJ2NoYXJ0LmNyb3NzaGFpcnMudmxpbmUnOnRydWUsJ2NoYXJ0LmFubm90YXRhYmxlJzpmYWxzZSwnY2hhcnQuYW5ub3RhdGUuY29sb3InOidibGFjaycsJ2NoYXJ0Lnpvb20uZmFjdG9yJzoxLjUsJ2NoYXJ0Lnpvb20uZmFkZS5pbic6dHJ1ZSwnY2hhcnQuem9vbS5mYWRlLm91dCc6dHJ1ZSwnY2hhcnQuem9vbS5oZGlyJzoncmlnaHQnLCdjaGFydC56b29tLnZkaXInOidkb3duJywnY2hhcnQuem9vbS5mcmFtZXMnOjI1LCdjaGFydC56b29tLmRlbGF5JzoxNi42NjYsJ2NoYXJ0Lnpvb20uc2hhZG93Jzp0cnVlLCdjaGFydC56b29tLmJhY2tncm91bmQnOnRydWUsJ2NoYXJ0LnJlc2l6YWJsZSc6ZmFsc2UsJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6bnVsbCwnY2hhcnQubm9heGVzJzpmYWxzZSwnY2hhcnQubm94YXhpcyc6ZmFsc2UsJ2NoYXJ0Lm5veWF4aXMnOmZhbHNlLCdjaGFydC5heGlzLmNvbG9yJzonYmxhY2snLCdjaGFydC50b3RhbCc6dHJ1ZSwnY2hhcnQubXVsdGlwbGllci54JzoxLCdjaGFydC5tdWx0aXBsaWVyLncnOjEsJ2NoYXJ0LmV2ZW50cy5jbGljayc6bnVsbCwnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6bnVsbCwnY2hhcnQueWxhYmVscy5jb3VudCc6NSwnY2hhcnQueW1pbic6MCwnY2hhcnQuY2xlYXJ0byc6J3JnYmEoMCwwLDAsMCknfVxuaWYoIXRoaXMuY2FudmFzKXthbGVydCgnW1dBVEVSRkFMTF0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47fVxuZm9yKHZhciBpPTAsbGVuPXRoaXMuZGF0YS5sZW5ndGg7aTw9bGVuOysraSl7dGhpc1snJCcraV09e31cbmlmKHR5cGVvZiB0aGlzLmRhdGFbaV09PT0nc3RyaW5nJyl7dGhpcy5kYXRhW2ldPXBhcnNlRmxvYXQodGhpcy5kYXRhW2ldKTt9fVxuaWYoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyl7dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX189dHJ1ZTt9XG52YXIgUkc9UkdyYXBoLGNhPXRoaXMuY2FudmFzLGNvPWNhLmdldENvbnRleHQoJzJkJykscHJvcD10aGlzLnByb3BlcnRpZXMscGEyPVJHLnBhdGgyLHdpbj13aW5kb3csZG9jPWRvY3VtZW50LG1hPU1hdGhcbmlmKFJHLkVmZmVjdHMmJnR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlPT09J2Z1bmN0aW9uJyl7UkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTt9XG50aGlzLnNldD10aGlzLlNldD1mdW5jdGlvbihuYW1lLHZhbHVlKVxue3ZhciB2YWx1ZT10eXBlb2YgYXJndW1lbnRzWzFdPT09J3VuZGVmaW5lZCc/bnVsbDphcmd1bWVudHNbMV07aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnR5cGVvZiBuYW1lPT09J29iamVjdCcpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxuYW1lKTtyZXR1cm4gdGhpczt9XG5pZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxuaWYobmFtZT09J2NoYXJ0LnRvdGFsJyYmcHJvcFsnY2hhcnQubnVteHRpY2tzJ109PW51bGwpe3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPXRoaXMuZGF0YS5sZW5ndGg7fVxucHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldPXZhbHVlO3JldHVybiB0aGlzO307dGhpcy5nZXQ9dGhpcy5HZXQ9ZnVuY3Rpb24obmFtZSlcbntpZihuYW1lLnN1YnN0cigwLDYpIT0nY2hhcnQuJyl7bmFtZT0nY2hhcnQuJytuYW1lO31cbndoaWxlKG5hbWUubWF0Y2goLyhbQS1aXSkvKSl7bmFtZT1uYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCcuJytSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7fVxucmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTt9O3RoaXMuZHJhdz10aGlzLkRyYXc9ZnVuY3Rpb24oKVxue1JHcmFwaC5maXJlQ3VzdG9tRXZlbnQodGhpcywnb25iZWZvcmVkcmF3Jyk7aWYoIXRoaXMuY29sb3JzUGFyc2VkKXt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQ9dHJ1ZTt9XG5SR3JhcGguRHJhd0JhY2tncm91bmRJbWFnZSh0aGlzKTt0aGlzLmd1dHRlckxlZnQ9cHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0PXByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wPXByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbT1wcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jb29yZHM9W107dGhpcy5jb29yZHNUZXh0PVtdO3RoaXMuY2VudGVyeT0oKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikrdGhpcy5ndXR0ZXJUb3A7dGhpcy5tYXg9MDt0aGlzLmdyYXBoYXJlYT1jYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5ncmFwaHdpZHRoPWNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0O3RoaXMuaGFsZlRleHRIZWlnaHQ9cHJvcFsnY2hhcnQudGV4dC5zaXplJ10vMjt0aGlzLm1heD10aGlzLmdldE1heCh0aGlzLmRhdGEpO3ZhciBkZWNpbWFscz1wcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddO3RoaXMuc2NhbGUyPVJHLmdldFNjYWxlMih0aGlzLHttYXg6dHlwZW9mKHByb3BbJ2NoYXJ0LnltYXgnXSk9PSdudW1iZXInP3Byb3BbJ2NoYXJ0LnltYXgnXTp0aGlzLm1heCxtaW46cHJvcFsnY2hhcnQueW1pbiddLHN0cmljdDp0eXBlb2YocHJvcFsnY2hhcnQueW1heCddKT09PSdudW1iZXInP3RydWU6ZmFsc2UsJ3NjYWxlLmRlY2ltYWxzJzpOdW1iZXIoZGVjaW1hbHMpLCdzY2FsZS5wb2ludCc6cHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwnc2NhbGUudGhvdXNhbmQnOnByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sJ3NjYWxlLnJvdW5kJzpwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCd1bml0cy5wcmUnOnByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCd1bml0cy5wb3N0Jzpwcm9wWydjaGFydC51bml0cy5wb3N0J10sJ3lsYWJlbHMuY291bnQnOnByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXX0pO3RoaXMubWF4PXRoaXMuc2NhbGUyLm1heDt0aGlzLm1pbj10aGlzLnNjYWxlMi5taW47UkcuZHJhd0JhcnModGhpcylcblJHLkJhY2tncm91bmQuZHJhdyh0aGlzKTt0aGlzLkRyYXdBeGVzKCk7dGhpcy5EcmF3YmFycygpO3RoaXMuRHJhd0xhYmVscygpO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PT0nYm90dG9tJyYmcHJvcFsnY2hhcnQubm9heGVzJ109PT1mYWxzZSYmcHJvcFsnY2hhcnQubm94YXhpcyddPT09ZmFsc2UmJnByb3BbJ2NoYXJ0LnltaW4nXT09PTApe2NvLnN0cm9rZVN0eWxlPXByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXTtjby5zdHJva2VSZWN0KHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10sY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSxjYS53aWR0aC10aGlzLmd1dHRlckxlZnQtdGhpcy5ndXR0ZXJSaWdodCwwKTt9XG5pZihwcm9wWydjaGFydC5jb250ZXh0bWVudSddKXtSRy5TaG93Q29udGV4dCh0aGlzKTt9XG5pZihwcm9wWydjaGFydC5yZXNpemFibGUnXSl7UkcuQWxsb3dSZXNpemluZyh0aGlzKTt9XG5SRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYodGhpcy5maXJzdERyYXcpe1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3PWZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO31cblJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCdvbmRyYXcnKTtyZXR1cm4gdGhpczt9O3RoaXMuZHJhd0F4ZXM9dGhpcy5EcmF3QXhlcz1mdW5jdGlvbigpXG57aWYocHJvcFsnY2hhcnQubm9heGVzJ10pe3JldHVybjt9XG5jby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZT1wcm9wWydjaGFydC5heGlzLmNvbG9yJ107Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmF4aXMubGluZXdpZHRoJ10rMC4wMDE7aWYocHJvcFsnY2hhcnQubm95YXhpcyddPT1mYWxzZSl7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksdGhpcy5ndXR0ZXJUb3ApO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbSk7fVxuaWYocHJvcFsnY2hhcnQubm94YXhpcyddPT1mYWxzZSl7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsbWEucm91bmQoKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wKSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQsbWEucm91bmQoKChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJUb3AtdGhpcy5ndXR0ZXJCb3R0b20pLzIpK3RoaXMuZ3V0dGVyVG9wKSk7fWVsc2V7dmFyIHk9bWEuZmxvb3IodGhpcy5nZXRZQ29vcmQoMCkpO2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQseSk7Y28ubGluZVRvKGNhLndpZHRoLXRoaXMuZ3V0dGVyUmlnaHQseSk7fX1cbnZhciBudW1ZVGlja3M9cHJvcFsnY2hhcnQubnVteXRpY2tzJ107aWYocHJvcFsnY2hhcnQubm95YXhpcyddPT09ZmFsc2UmJnByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddPjApe3ZhciB5VGlja0dhcD0oY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS9udW1ZVGlja3M7Zm9yKHk9dGhpcy5ndXR0ZXJUb3A7eTwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKTt5Kz15VGlja0dhcCl7aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2JvdHRvbSd8fCh5IT0oKGNhLmhlaWdodC10aGlzLmd1dHRlclRvcC10aGlzLmd1dHRlckJvdHRvbSkvMikrdGhpcy5ndXR0ZXJUb3ApKXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LG1hLnJvdW5kKHkpKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LTMsbWEucm91bmQoeSkpO319XG5pZihwcm9wWydjaGFydC5ub3hheGlzJ118fHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInfHxwcm9wWydjaGFydC55bWluJ10hPT0wKXtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LTMsTWF0aC5yb3VuZChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LE1hdGgucm91bmQoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSk7fX1cbmlmKHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddPT1udWxsKXtwcm9wWydjaGFydC5udW14dGlja3MnXT10aGlzLmRhdGEubGVuZ3RoKyhwcm9wWydjaGFydC50b3RhbCddPzE6MCl9XG5pZihwcm9wWydjaGFydC5ub3hheGlzJ109PWZhbHNlJiZwcm9wWydjaGFydC5udW14dGlja3MnXT4wKXt4VGlja0dhcD0oY2Eud2lkdGgtdGhpcy5ndXR0ZXJMZWZ0LXRoaXMuZ3V0dGVyUmlnaHQpL3Byb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXt5U3RhcnQ9KChjYS5oZWlnaHQtdGhpcy5ndXR0ZXJCb3R0b20tdGhpcy5ndXR0ZXJUb3ApLzIpK3RoaXMuZ3V0dGVyVG9wLTM7eUVuZD0oKGNhLmhlaWdodC10aGlzLmd1dHRlckJvdHRvbS10aGlzLmd1dHRlclRvcCkvMikrdGhpcy5ndXR0ZXJUb3ArMzt9ZWxzZXt5U3RhcnQ9dGhpcy5nZXRZQ29vcmQoMCktKHRoaXMuc2NhbGUyLm1pbjwwPzM6MCk7eUVuZD10aGlzLmdldFlDb29yZCgwKSszO31cbmZvcih4PXRoaXMuZ3V0dGVyTGVmdCt4VGlja0dhcDt4PD1jYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KzE7eCs9eFRpY2tHYXApe2NvLm1vdmVUbyhtYS5yb3VuZCh4KSx5U3RhcnQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSx5RW5kKTt9XG5pZihwcm9wWydjaGFydC5ub3lheGlzJ10pe2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCkseUVuZCk7fX1cbmlmKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSYmcHJvcFsnY2hhcnQubm94YXhpcyddPT1mYWxzZSl7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksdGhpcy5nZXRZQ29vcmQoMCkpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLHRoaXMuZ2V0WUNvb3JkKDApKTt9XG5jby5zdHJva2UoKTt9O3RoaXMuZHJhd0xhYmVscz10aGlzLkRyYXdMYWJlbHM9ZnVuY3Rpb24oKVxue3ZhciBjb250ZXh0PWNvLG51bVlMYWJlbHM9NSxpbnRlcnZhbD10aGlzLmdyYXBoYXJlYS9udW1ZTGFiZWxzLGZvbnQ9cHJvcFsnY2hhcnQudGV4dC5mb250J10sc2l6ZT1wcm9wWydjaGFydC50ZXh0LnNpemUnXSxjb2xvcj1wcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sdW5pdHNfcHJlPXByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLHVuaXRzX3Bvc3Q9cHJvcFsnY2hhcnQudW5pdHMucG9zdCddLG9mZnNldHg9cHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J10sb2Zmc2V0eT1wcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHknXTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGU9Y29sb3I7aWYocHJvcFsnY2hhcnQueWxhYmVscyddKXtpZihwcm9wWydjaGFydC54YXhpc3BvcyddPT0nY2VudGVyJyl7dmFyIGhhbGZJbnRlcnZhbD1pbnRlcnZhbC8yO3ZhciBoYWxmV2F5PSgoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyVG9wLXRoaXMuZ3V0dGVyQm90dG9tKS8yKSt0aGlzLmd1dHRlclRvcDtmb3IodmFyIGk9MCxsZW49dGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDtpPGxlbjsrK2kpe1JHLnRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUseDp0aGlzLmd1dHRlckxlZnQtNStvZmZzZXR4LHk6dGhpcy5ndXR0ZXJUb3ArKCgodGhpcy5ncmFwaGFyZWEvMikvbGVuKSppKStvZmZzZXR5LHRleHQ6dGhpcy5zY2FsZTIubGFiZWxzW2xlbi1pLTFdLHZhbGlnbjonY2VudGVyJyxoYWxpZ246J3JpZ2h0Jyx0YWc6J3NjYWxlJ30pO1JHLnRleHQyKHRoaXMse2ZvbnQ6Zm9udCxzaXplOnNpemUseDp0aGlzLmd1dHRlckxlZnQtNStvZmZzZXR4LHk6aGFsZldheSsoKCh0aGlzLmdyYXBoYXJlYS8yKS9sZW4pKihpKzEpKStvZmZzZXR5LHRleHQ6dGhpcy5zY2FsZTIubGFiZWxzW2ldLHZhbGlnbjonY2VudGVyJyxoYWxpZ246J3JpZ2h0Jyx0YWc6J3NjYWxlJ30pO31cbmlmKHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKXtSRy50ZXh0Mihjbyx7eDp0aGlzLmd1dHRlckxlZnQtNStvZmZzZXR4LHk6aGFsZldheSx0ZXh0OicwJyxmb250OmZvbnQsc2l6ZTpzaXplLHZhbGlnbjonY2VudGVyJyxoYWxpZ246J3JpZ2h0Jyx0YWc6J3NjYWxlJ30pO319ZWxzZXtmb3IodmFyIGk9MCxsZW49dGhpcy5zY2FsZTIudmFsdWVzLmxlbmd0aDtpPGxlbjsrK2kpe3ZhciB5PXRoaXMuZ2V0WUNvb3JkKHRoaXMuc2NhbGUyLnZhbHVlc1tpXSkrb2Zmc2V0eTtSRy50ZXh0Mih0aGlzLHtmb250OmZvbnQsc2l6ZTpzaXplLHg6dGhpcy5ndXR0ZXJMZWZ0LTUrb2Zmc2V0eCx5OnksdGV4dDp0aGlzLnNjYWxlMi5sYWJlbHNbaV0sdmFsaWduOidjZW50ZXInLGhhbGlnbjoncmlnaHQnLHRhZzonc2NhbGUnfSk7fVxuaWYocHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J118fHByb3BbJ2NoYXJ0LnltaW4nXSE9PTApe1JHLnRleHQyKGNvLHt4OnRoaXMuZ3V0dGVyTGVmdC01K29mZnNldHgseTp0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ118fDApLHRleHQ6UkcubnVtYmVyRm9ybWF0KHRoaXMsU3RyaW5nKE51bWJlcihwcm9wWydjaGFydC55bWluJ118fDApLnRvRml4ZWQocHJvcFsnY2hhcnQueW1pbiddPT09MD8wOnByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKSxwcm9wWydjaGFydC51bml0cy5wcmUnXSxwcm9wWydjaGFydC51bml0cy5wb3N0J10pLGZvbnQ6Zm9udCxzaXplOnNpemUsdmFsaWduOidjZW50ZXInLGhhbGlnbjoncmlnaHQnLHRhZzonc2NhbGUnfSk7fX19XG5pZihwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg+MCl7aW50ZXJ2YWw9KGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS9wcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGg7dmFyIGhhbGlnbj0nY2VudGVyJzt2YXIgYW5nbGU9cHJvcFsnY2hhcnQudGV4dC5hbmdsZSddO2lmKGFuZ2xlKXtoYWxpZ249J3JpZ2h0JzthbmdsZSo9LTE7fVxudmFyIGxhYmVscz1wcm9wWydjaGFydC5sYWJlbHMnXSxsYWJlbHNDb2xvcj1wcm9wWydjaGFydC5sYWJlbHMuY29sb3InXSxib2xkPXByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ10sb2Zmc2V0eD1wcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddLG9mZnNldHk9cHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHknXVxuZm9yKHZhciBpPTAsbGVuPWxhYmVscy5sZW5ndGg7aTxsZW47aSs9MSl7UkcudGV4dDIodGhpcyx7J2NvbG9yJzpsYWJlbHNDb2xvciwnZm9udCc6Zm9udCwnc2l6ZSc6c2l6ZSwnYm9sZCc6Ym9sZCwneCc6dGhpcy5ndXR0ZXJMZWZ0KyhpKmludGVydmFsKSsoaW50ZXJ2YWwvMikrb2Zmc2V0eCwneSc6Y2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKzUrdGhpcy5oYWxmVGV4dEhlaWdodCtvZmZzZXR5LCd0ZXh0JzpsYWJlbHNbaV0sJ3ZhbGlnbic6J2NlbnRlcicsJ2hhbGlnbic6aGFsaWduLCdhbmdsZSc6YW5nbGUsJ3RhZyc6J2xhYmVscyd9KTt9fVxuY28uc3Ryb2tlKCk7Y28uZmlsbCgpO307dGhpcy5kcmF3YmFycz10aGlzLkRyYXdiYXJzPWZ1bmN0aW9uKClcbnt2YXIgY29udGV4dD1jbyxjYW52YXM9Y2EsaG1hcmdpbj1wcm9wWydjaGFydC5obWFyZ2luJ10scnVubmluZ1RvdGFsPTA7Y28ubGluZVdpZHRoPXByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddKzAuMDAxO2Zvcih2YXIgaT0wLGxlbj10aGlzLmRhdGEubGVuZ3RoO2k8bGVuOysraSl7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGU9cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTt2YXIgeD1tYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQraG1hcmdpbisoKCh0aGlzLmdyYXBod2lkdGgvKHRoaXMuZGF0YS5sZW5ndGgrKHByb3BbJ2NoYXJ0LnRvdGFsJ10/MTowKSkpKmkpKnByb3BbJ2NoYXJ0Lm11bHRpcGxpZXIueCddKSk7dmFyIGg9dGhpcy5nZXRZQ29vcmQoMCktdGhpcy5nZXRZQ29vcmQobWEuYWJzKHRoaXMuZGF0YVtpXSkpO2lmKGk9PT0wKXt5PXRoaXMuZ2V0WUNvb3JkKDApLWg7fWVsc2V7eT10aGlzLmdldFlDb29yZChydW5uaW5nVG90YWwpLWg7fVxueT1tYS5yb3VuZCh5KTt2YXIgdz0oKGNhLndpZHRoLXRoaXMuZ3V0dGVyTGVmdC10aGlzLmd1dHRlclJpZ2h0KS8odGhpcy5kYXRhLmxlbmd0aCsocHJvcFsnY2hhcnQudG90YWwnXT8xOjApKSktKDIqcHJvcFsnY2hhcnQuaG1hcmdpbiddKTt3PXcqcHJvcFsnY2hhcnQubXVsdGlwbGllci53J107aWYodGhpcy5kYXRhW2ldPDApe3krPWg7fVxuY28uZmlsbFN0eWxlPXRoaXMuZGF0YVtpXT49MD9wcm9wWydjaGFydC5jb2xvcnMnXVswXTpwcm9wWydjaGFydC5jb2xvcnMnXVsxXTtpZihwcm9wWydjaGFydC5zaGFkb3cnXSl7Ukcuc2V0U2hhZG93KHRoaXMscHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10scHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSxwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO31lbHNle1JHLm5vU2hhZG93KHRoaXMpO31cbmNvLnJlY3QoeCxtYS5mbG9vcih5KSx3LG1hLmZsb29yKGgpKTt0aGlzLmNvb3Jkcy5wdXNoKFt4LHksdyxoXSk7cnVubmluZ1RvdGFsKz10aGlzLmRhdGFbaV07Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO31cbnRoaXMudG90YWw9cnVubmluZ1RvdGFsO2lmKHByb3BbJ2NoYXJ0LnRvdGFsJ10pe2g9dGhpcy5nZXRZQ29vcmQoMCktdGhpcy5nZXRZQ29vcmQobWEuYWJzKHJ1bm5pbmdUb3RhbCkpO2lmKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ109PSdjZW50ZXInKXt5PXJ1bm5pbmdUb3RhbD4wP3RoaXMuZ2V0WUNvb3JkKDApLWg6dGhpcy5nZXRZQ29vcmQoMCk7fWVsc2V7aWYocnVubmluZ1RvdGFsPjApe3k9dGhpcy5nZXRZQ29vcmQoMCktaDt9ZWxzZXt5PXRoaXMuZ2V0WUNvb3JkKDApO319XG54PXgrKHByb3BbJ2NoYXJ0LmhtYXJnaW4nXSoyKSt3O2NvLmZpbGxTdHlsZT1wcm9wWydjaGFydC5jb2xvcnMnXVsyXTtwYTIoY28sJ2IgciAlICUgJSAlIHMgJSBmICUnLHgseSx3LGgsY28uc3Ryb2tlU3R5bGUsY28uZmlsbFN0eWxlKTt2YXIgcHJldmlvdXNDb29yZHM9W3gseSx3LG1hLmFicyhoKV07dGhpcy5jb29yZHMucHVzaChwcmV2aW91c0Nvb3Jkcyk7fVxuUkcubm9TaGFkb3codGhpcyk7Y28ubGluZVdpZHRoPTE7Y28uc3Ryb2tlU3R5bGU9JyM2NjYnO2NvLmJlZ2luUGF0aCgpO2Zvcih2YXIgaT0xLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSs9MSl7dmFyIHByZXY9dGhpcy5jb29yZHNbaS0xXSxjdXJyPXRoaXMuY29vcmRzW2ldLHByZXZEYXRhPXRoaXMuZGF0YVtpLTFdXG52YXIgeT0ocHJldkRhdGE+MD9wcmV2WzFdOnByZXZbMV0rcHJldlszXSk7Y28ubW92ZVRvKHByZXZbMF0rcHJldlsyXSx5KTtjby5saW5lVG8oY3VyclswXSwocHJldkRhdGE+MD9wcmV2WzFdOnByZXZbMV0rcHJldlszXSkpO31cbmNvLnN0cm9rZSgpO307dGhpcy5nZXRTaGFwZT10aGlzLmdldEJhcj1mdW5jdGlvbihlKVxue2Zvcih2YXIgaT0wLGxlbj10aGlzLmNvb3Jkcy5sZW5ndGg7aTxsZW47aSsrKXt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpLG1vdXNlWD1tb3VzZVhZWzBdLG1vdXNlWT1tb3VzZVhZWzFdO3ZhciBsZWZ0PXRoaXMuY29vcmRzW2ldWzBdLHRvcD10aGlzLmNvb3Jkc1tpXVsxXSx3aWR0aD10aGlzLmNvb3Jkc1tpXVsyXSxoZWlnaHQ9dGhpcy5jb29yZHNbaV1bM107aWYobW91c2VYPj1sZWZ0JiZtb3VzZVg8PShsZWZ0K3dpZHRoKSYmbW91c2VZPj10b3AmJm1vdXNlWTw9dG9wK2hlaWdodCl7dmFyIHRvb2x0aXA9UkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLGkpO3JldHVybnswOnRoaXMsb2JqZWN0OnRoaXMsMTpsZWZ0LHg6bGVmdCwyOnRvcCx5OnRvcCwzOndpZHRoLHdpZHRoOndpZHRoLDQ6aGVpZ2h0LGhlaWdodDpoZWlnaHQsNTppLGluZGV4OmksdG9vbHRpcDp0b29sdGlwfTt9fVxucmV0dXJuIG51bGw7fTt0aGlzLmdldE1heD1mdW5jdGlvbihkYXRhKVxue3ZhciBydW5uaW5nVG90YWw9MCxtYXg9MDtmb3IodmFyIGk9MCxsZW49ZGF0YS5sZW5ndGg7aTxsZW47aSs9MSl7cnVubmluZ1RvdGFsKz1kYXRhW2ldO21heD1tYS5tYXgobWEuYWJzKHJ1bm5pbmdUb3RhbCksbWF4KTt9XG5yZXR1cm4gbWEuYWJzKG1heCk7fTt0aGlzLmFsbG93VG9vbHRpcHM9dGhpcy5BbGxvd1Rvb2x0aXBzPWZ1bmN0aW9uKClcbntSRy5QcmVMb2FkVG9vbHRpcEltYWdlcyh0aGlzKTtSRy5JbnN0YWxsV2luZG93TW91c2Vkb3duVG9vbHRpcExpc3RlbmVyKHRoaXMpO1JHLkluc3RhbGxDYW52YXNNb3VzZW1vdmVUb29sdGlwTGlzdGVuZXIodGhpcyk7UkcuSW5zdGFsbENhbnZhc01vdXNldXBUb29sdGlwTGlzdGVuZXIodGhpcyk7fTt0aGlzLmhpZ2hsaWdodD10aGlzLkhpZ2hsaWdodD1mdW5jdGlvbihzaGFwZSlcbntpZih0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ109PT0nZnVuY3Rpb24nKXsocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10pKHNoYXBlKTt9ZWxzZXtSRy5IaWdobGlnaHQuUmVjdCh0aGlzLHNoYXBlKTt9fTt0aGlzLmdldE9iamVjdEJ5WFk9ZnVuY3Rpb24oZSlcbnt2YXIgbW91c2VYWT1SRy5nZXRNb3VzZVhZKGUpO2lmKG1vdXNlWFlbMF0+dGhpcy5ndXR0ZXJMZWZ0JiZtb3VzZVhZWzBdPChjYS53aWR0aC10aGlzLmd1dHRlclJpZ2h0KSYmbW91c2VYWVsxXT50aGlzLmd1dHRlclRvcCYmbW91c2VYWVsxXTwoY2EuaGVpZ2h0LXRoaXMuZ3V0dGVyQm90dG9tKSl7cmV0dXJuIHRoaXM7fX07dGhpcy5nZXRZQ29vcmQ9ZnVuY3Rpb24odmFsdWUpXG57aWYocHJvcFsnY2hhcnQueGF4aXNwb3MnXT09J2NlbnRlcicpe2lmKHZhbHVlPCgtMSp0aGlzLm1heCkpe3JldHVybiBudWxsO31cbnZhciBjb29yZD0odmFsdWUvdGhpcy5tYXgpKih0aGlzLmdyYXBoYXJlYS8yKTtyZXR1cm4gdGhpcy5ndXR0ZXJUb3ArKHRoaXMuZ3JhcGhhcmVhLzIpLWNvb3JkO31lbHNle3ZhciBjb29yZD0oKHZhbHVlLXRoaXMuc2NhbGUyLm1pbikvKHRoaXMubWF4LXRoaXMuc2NhbGUyLm1pbikpKnRoaXMuZ3JhcGhhcmVhO2Nvb3JkPWNvb3JkK3RoaXMuZ3V0dGVyQm90dG9tO3JldHVybiBjYS5oZWlnaHQtY29vcmQ7fX07dGhpcy5wYXJzZUNvbG9ycz1mdW5jdGlvbigpXG57aWYodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoPT09MCl7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQua2V5LmNvbG9ycyddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT1SRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddPVJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5heGlzLmNvbG9yJ109UkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTt9XG52YXIgY29sb3JzPXByb3BbJ2NoYXJ0LmNvbG9ycyddO2lmKGNvbG9ycyl7Zm9yKHZhciBpPTAsbGVuPWNvbG9ycy5sZW5ndGg7aTxsZW47KytpKXtjb2xvcnNbaV09dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTt9fVxudmFyIGNvbG9ycz1wcm9wWydjaGFydC5rZXkuY29sb3JzJ107aWYoY29sb3JzKXtmb3IodmFyIGk9MCxsZW49Y29sb3JzLmxlbmd0aDtpPGxlbjsrK2kpe2NvbG9yc1tpXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO319XG5wcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddPXRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXT10aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTtwcm9wWydjaGFydC5heGlzLmNvbG9yJ109dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTt9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKVxue307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ9ZnVuY3Rpb24oY29sb3IpXG57aWYoIWNvbG9yfHx0eXBlb2YgY29sb3IhPSdzdHJpbmcnKXtyZXR1cm4gY29sb3I7fVxuaWYodHlwZW9mIGNvbG9yPT09J3N0cmluZycmJmNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSl7dmFyIHBhcnRzPVJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkPWNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsY2EuaGVpZ2h0LXByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSwwLHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7dmFyIGRpZmY9MS8ocGFydHMubGVuZ3RoLTEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsUkcudHJpbShwYXJ0c1swXSkpO2Zvcih2YXIgaj0xLGxlbj1wYXJ0cy5sZW5ndGg7ajxsZW47KytqKXtncmFkLmFkZENvbG9yU3RvcChqKmRpZmYsUkcudHJpbShwYXJ0c1tqXSkpO319XG5yZXR1cm4gZ3JhZD9ncmFkOmNvbG9yO307dGhpcy5vbj1mdW5jdGlvbih0eXBlLGZ1bmMpXG57aWYodHlwZS5zdWJzdHIoMCwyKSE9PSdvbicpe3R5cGU9J29uJyt0eXBlO31cbmlmKHR5cGVvZiB0aGlzW3R5cGVdIT09J2Z1bmN0aW9uJyl7dGhpc1t0eXBlXT1mdW5jO31lbHNle1JHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcyx0eXBlLGZ1bmMpO31cbnJldHVybiB0aGlzO307dGhpcy5maXJzdERyYXdGdW5jPWZ1bmN0aW9uKClcbnt9O3RoaXMuZ3Jvdz1mdW5jdGlvbigpXG57dmFyIG9wdD1hcmd1bWVudHNbMF18fHt9O3ZhciBjYWxsYmFjaz1hcmd1bWVudHNbMV18fGZ1bmN0aW9uKCl7fTt2YXIgZnJhbWVzPW9wdC5mcmFtZXN8fDMwO3ZhciBudW1GcmFtZT0wO3ZhciBvYmo9dGhpczt2YXIgZGF0YT1SRy5hcnJheV9jbG9uZShvYmouZGF0YSk7Zm9yKHZhciBpPTAsbGVuPW9iai5kYXRhLmxlbmd0aDtpPGxlbjsrK2kpe29iai5kYXRhW2ldLz1mcmFtZXM7fVxuaWYob2JqLkdldCgnY2hhcnQueW1heCcpPT1udWxsKXt2YXIgbWF4PW9iai5nZXRNYXgoZGF0YSk7dmFyIHNjYWxlMj1SRy5nZXRTY2FsZTIob2JqLHsnbWF4JzptYXh9KTtvYmouU2V0KCdjaGFydC55bWF4JyxzY2FsZTIubWF4KTt9XG5mdW5jdGlvbiBpdGVyYXRvcigpXG57Zm9yKHZhciBpPTA7aTxvYmouZGF0YS5sZW5ndGg7KytpKXtvYmouZGF0YVtpXT1kYXRhW2ldKlJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsbnVtRnJhbWUpO31cblJHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmKCsrbnVtRnJhbWU8ZnJhbWVzKXtSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO31lbHNle2NhbGxiYWNrKG9iaik7fX1cbml0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpe1JHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcyxjb25mLm9wdGlvbnMpO31cbnJldHVybiB0aGlzO307XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG90aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgud2F0ZXJmYWxsLmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///252\n");

/***/ })
/******/ ]));