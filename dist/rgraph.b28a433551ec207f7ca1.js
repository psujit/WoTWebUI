webpackJsonp([1],Array(161).concat([function(g,t,c){c(162),c(163),c(164),c(165),c(166),c(167),c(168),c(169),c(170),c(171),c(172),c(173),c(174),c(175),c(176),c(177),c(178),c(179),c(180),c(181),c(182),c(183),c(184),c(185),c(186),c(187),c(188),c(189),c(190),c(191),c(192),c(193),c(194),c(195),c(196),c(197),c(198),c(199),c(200),c(201),c(202),c(203),c(204),c(205),c(206),c(207),c(208),c(209),c(210),c(211),c(212),c(213),c(214),c(215),c(216),c(217),c(218),c(219),c(220),c(221),g.exports=c(222)},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bar';this.max = 0;this.stackedOrGrouped = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.cachedBackgroundCanvas = null;this.firstDraw = true;this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.background.hbars': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.hmargin.grouped': 1, 'chart.strokecolor': 'rgba(0,0,0,0)', 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.size': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'rgba(0,0,0,0)', 'chart.labels.above.angle': null, 'chart.labels.above.offset': 4, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['red', '#0f0', 'blue', 'pink', 'orange', 'cyan', 'black', 'white', 'green', 'magenta'], 'chart.colors.sequential': false, 'chart.colors.reverse': false, 'chart.grouping': 'grouped', 'chart.variant': 'bar', 'chart.variant.sketch.verticals': true, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot.xonly': false, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.halign': 'right', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.text.size': 10, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.linewidth': 1, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.adjustable.only': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.numxticks': null, 'chart.bevel': false, 'chart.errorbars': false, 'chart.errorbars.color': 'black', 'chart.errorbars.capped': true, 'chart.errorbars.capped.width': 14, 'chart.errorbars.linewidth': 1, 'chart.combinedchart.effect': null, 'chart.combinedchart.effect.options': null, 'chart.combinedchart.effect.callback': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[BAR] No canvas support');return;\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (typeof data[i] === 'string') {\n      data[i] = parseFloat(data[i]);\n    } else if (_typeof(data[i]) === 'object' && data[i]) {\n      for (var j = 0; j < data[i].length; ++j) {\n        if (typeof data[i][j] === 'string') {\n          data[i][j] = parseFloat(data[i][j]);\n        }\n      }\n    } else if (typeof data[i] === 'undefined') {\n      data[i] = null;\n    }\n  }\n  for (var i = 0; i < data.length; ++i) {\n    if (_typeof(data[i]) === 'object' && !RGraph.is_null(data[i])) {\n      this.stackedOrGrouped = true;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  this.data = data;this.original_data = RGraph.arrayClone(data);this.coords = [];this.coords2 = [];this.coordsText = [];this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.xlabels.offset') {\n      name = 'chart.labels.offsety';\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    if (name == 'chart.strokestyle') {\n      name = 'chart.strokecolor';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n      if (value == 'top') {\n        for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] == 'number' && this.data[i] > 0) {\n            alert('[BAR] The data element with index ' + i + ' should be negative');\n          }\n        }\n      }\n    }\n    if (name.toLowerCase() == 'chart.linewidth' && value == 0) {\n      value = 0.0001;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if ((prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot') && _typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips'] && prop['chart.tooltips'].length > 0) {\n      alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');\n    }\n    this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;RG.background.Draw(this);this.drawbars();this.drawAxes();this.DrawLabels();if (prop['chart.bevel'] || prop['chart.bevelled']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.errorbars']) {\n      this.drawErrorbars();\n    }\n    if (prop['chart.labels.ingraph']) {\n      RG.DrawInGraphLabels(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    var xaxispos = prop['chart.xaxispos'];var yaxispos = prop['chart.yaxispos'];var isSketch = prop['chart.variant'] == 'sketch';co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (RG.ISSAFARI == -1) {\n      co.lineCap = 'square';\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (yaxispos == 'right') {\n        co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));\n      }\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (xaxispos == 'center') {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - (isSketch ? 2 : 0)));\n      } else if (xaxispos == 'top') {\n        co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));\n      } else {\n        co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ma.round(this.getYCoord(0) - (isSketch ? 2 : 0)));co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ma.round(this.getYCoord(0) + (isSketch ? 2 : 0)));\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && !isSketch) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;var xpos = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;if (this.properties['chart.numyticks'] > 0) {\n        for (y = this.gutterTop; xaxispos == 'center' ? y <= ca.height - this.gutterBottom : y < ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0); y += yTickGap) {\n          if (xaxispos == 'center' && y == this.gutterTop + this.grapharea / 2) {\n            continue;\n          }\n          if (xaxispos == 'top' && y == this.gutterTop) {\n            continue;\n          }\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(y));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(y));\n        }\n        if (xaxispos === 'bottom' && prop['chart.ymin'] !== 0) {\n          co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(ca.height - prop['chart.gutter.bottom']));co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(ca.height - prop['chart.gutter.bottom']));\n        }\n      }\n      if (prop['chart.noxaxis']) {\n        if (xaxispos == 'center') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));co.lineTo(xpos, Math.round(ca.height / 2));\n        } else if (xaxispos == 'top') {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));co.lineTo(xpos, Math.round(this.gutterTop));\n        } else {\n          co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    if (prop['chart.noxaxis'] == false && !isSketch) {\n      if (typeof prop['chart.numxticks'] == 'number') {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      } else {\n        var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;\n      }\n      if (xaxispos == 'bottom') {\n        yStart = prop['chart.ymin'] < 0 ? this.getYCoord(0) - 3 : this.getYCoord(0);yEnd = this.getYCoord(0) + 3;\n      } else if (xaxispos == 'top') {\n        yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n      } else if (xaxispos == 'center') {\n        yStart = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + 3;yEnd = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - 3;\n      }\n      var noEndXTick = prop['chart.noendxtick'];for (x = this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0), len = ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0); x < len; x += xTickGap) {\n        if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < ca.width - this.gutterRight) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && !noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && x > this.gutterLeft && noEndXTick) {\n          co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {\n        if (typeof prop['chart.numxticks'] == 'number' && prop['chart.numxticks'] > 0) {\n          co.moveTo(Math.round(this.gutterLeft), yStart);co.lineTo(Math.round(this.gutterLeft), yEnd);\n        }\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {\n      if (xaxispos == 'center') {\n        co.moveTo(ma.round(this.gutterLeft), ca.height / 2 - 3);co.lineTo(ma.round(this.gutterLeft), ca.height / 2 + 3);\n      } else {\n        co.moveTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom + 3);\n      }\n    }\n    co.stroke();\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokecolor'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0,\n        decimals = prop['chart.scale.decimals'];if (prop['chart.ymax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.ymax'], 'strict': prop['chart.scale.round'] ? false : true, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });\n    } else {\n      var errorbars = prop['chart.errorbars'];if (typeof errorbars === 'number') {\n        var value = errorbars;prop['chart.errorbars'] = [];for (var i = 0; i < this.data.length; ++i) {\n          if (typeof this.data[i] === 'number') {\n            prop['chart.errorbars'].push([value, null]);\n          } else if (_typeof(this.data[i]) === 'object' && !RG.isNull(this.data[i])) {\n            for (var j = 0; j < this.data[i].length; ++j) {\n              prop['chart.errorbars'].push([value, null]);\n            }\n          }\n        }\n        errorbars = prop['chart.errorbars'];\n      }\n      for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = prop['chart.grouping'] === 'grouped' ? Number(RG.arrayMax(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(this.data[i]);\n        }\n        this.max = ma.max(ma.abs(this.max), ma.abs(value) + Number(_typeof(prop['chart.errorbars']) === 'object' && _typeof(prop['chart.errorbars'][i]) === 'object' && !RG.isNull(prop['chart.errorbars'][i]) && typeof prop['chart.errorbars'][i][0] === 'number' ? prop['chart.errorbars'][i][0] : 0));\n      }\n      this.scale2 = RGraph.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.adjustable'] && !prop['chart.ymax']) {\n      this.Set('chart.ymax', this.scale2.max);\n    }\n    if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RGraph.DrawBars(this);\n    }\n    var variant = prop['chart.variant'];if (variant === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var xaxispos = prop['chart.xaxispos'],\n        width = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length,\n        orig_height = height,\n        hmargin = prop['chart.hmargin'],\n        shadow = prop['chart.shadow'],\n        shadowColor = prop['chart.shadow.color'],\n        shadowBlur = prop['chart.shadow.blur'],\n        shadowOffsetX = prop['chart.shadow.offsetx'],\n        shadowOffsetY = prop['chart.shadow.offsety'],\n        strokeStyle = prop['chart.strokecolor'],\n        colors = prop['chart.colors'],\n        sequentialColorIndex = 0;\n    var height;for (i = 0, len = this.data.length; i < len; i += 1) {\n      if (RG.arraySum(this.data[i]) < 0) {\n        var height = (RG.arraySum(this.data[i]) + this.scale2.min) / (this.scale2.max - this.scale2.min);\n      } else {\n        var height = (RG.arraySum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min);\n      }\n      height *= ma.abs(this.getYCoord(this.scale2.max) - this.getYCoord(this.scale2.min));var x = i * width + this.gutterLeft;var y = xaxispos == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - height : ca.height - height - this.gutterBottom;if (xaxispos == 'top') {\n        y = this.gutterTop + ma.abs(height);\n      }\n      if (height < 0) {\n        y += height;height = ma.abs(height);\n      }\n      if (shadow) {\n        co.shadowColor = shadowColor;co.shadowBlur = shadowBlur;co.shadowOffsetX = shadowOffsetX;co.shadowOffsetY = shadowOffsetY;\n      }\n      co.beginPath();if (typeof this.data[i] == 'number') {\n        if (xaxispos === 'bottom' && prop['chart.ymin'] < 0) {\n          if (this.data[i] >= 0) {\n            height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          } else {\n            y = this.getYCoord(0);height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));\n          }\n        }\n        var barWidth = width - 2 * hmargin;if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        co.strokeStyle = strokeStyle;co.fillStyle = colors[0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = colors[i];\n        }\n        if (variant == 'sketch') {\n          co.lineCap = 'round';var sketchOffset = 3;co.beginPath();co.strokeStyle = colors[0];if (prop['chart.colors.sequential']) {\n            co.strokeStyle = colors[i];\n          }\n          co.moveTo(x + hmargin + 2, y + height - 2);co.lineTo(x + hmargin - 1, y - 4);co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));co.bezierCurveTo(x + (hmargin + width) * 0.33, y + 15 + (this.data[i] < 0 ? height - 10 : 0), x + (hmargin + width) * 0.66, y + 5 + (this.data[i] < 0 ? height - 10 : 0), x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0));co.moveTo(x + hmargin + width - 5, y - 5);co.lineTo(x + hmargin + width - 3, y + height - 3);if (prop['chart.variant.sketch.verticals']) {\n            for (var r = 0.2; r <= 0.8; r += 0.2) {\n              co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - r * width, y - 1);co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - r * width, y + height + (r == 0.2 ? 1 : -2));\n            }\n          }\n          co.stroke();\n        } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {\n          if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, barWidth, height]);\n          }\n          if (variant == 'glass') {\n            RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);\n          } else {\n            co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.fill();RG.NoShadow(this);co.beginPath();co.rect(x + hmargin, y, barWidth, height);co.stroke();\n          }\n          if (variant == '3d') {\n            var prevStrokeStyle = co.strokeStyle;var prevFillStyle = co.fillStyle;if (this.data[i] >= 0) {\n              co.beginPath();co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.gutterTop + this.getYCoord(0) ? this.getYCoord(this.data[i]) - prop['chart.variant.threed.offsety'] : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.closePath();co.stroke();co.fill();if (this.data[i] > 0) {\n              co.beginPath();co.fillStyle = 'rgba(255,255,255,0.5)';co.moveTo(x + hmargin, y);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin, y);co.closePath();co.stroke();co.fill();\n            }\n            co.beginPath();co.fillStyle = 'rgba(0,0,0,0.4)';co.moveTo(x + hmargin + barWidth, y);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.getYCoord(0) ? this.getYCoord(0) : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));co.lineTo(x + hmargin + barWidth, y + height);co.lineTo(x + hmargin + barWidth, y);co.closePath();co.stroke();co.fill();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          } else if (variant == 'glass') {\n            var grad = co.createLinearGradient(x + hmargin, y, x + hmargin + barWidth / 2, y);grad.addColorStop(0, 'rgba(255,255,255,0.9)');grad.addColorStop(1, 'rgba(255,255,255,0.5)');co.beginPath();co.fillStyle = grad;co.fillRect(x + hmargin + 2, y + (this.data[i] > 0 ? 2 : 0), barWidth / 2 - 2, height - 2);co.fill();\n          }\n        } else if (variant == 'dot') {\n          co.beginPath();co.moveTo(x + width / 2, y);co.lineTo(x + width / 2, y + height);co.stroke();co.beginPath();co.fillStyle = this.properties['chart.colors'][i];co.arc(x + width / 2, y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[i];\n          }\n          co.stroke();co.fill();\n        } else {\n          alert('[BAR] Warning! Unknown chart.variant: ' + variant);\n        }\n        this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (this.scale2.min) {\n          alert(\"[ERROR] Stacked Bar charts with a Y min are not supported\");\n        }\n        var barWidth = width - 2 * hmargin;var redrawCoords = [];var startY = 0;var dataset = this.data[i];if (barWidth < 0) {\n          alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n        }\n        for (j = 0; j < dataset.length; ++j) {\n          if (xaxispos == 'center') {\n            alert(\"[BAR] It's pointless having the X axis position at the center on a stacked bar chart.\");return;\n          }\n          if (this.data[i][j] < 0) {\n            alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');return;\n          }\n          co.strokeStyle = strokeStyle;\n          co.fillStyle = colors[j];if (prop['chart.colors.reverse']) {\n            co.fillStyle = colors[this.data[i].length - j - 1];\n          }\n          if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var height = dataset[j] / this.scale2.max * (ca.height - this.gutterTop - this.gutterBottom);if (xaxispos == 'center') {\n            height /= 2;\n          }\n          var totalHeight = RGraph.array_sum(dataset) / this.scale2.max * (ca.height - hmargin - this.gutterTop - this.gutterBottom);this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);if (RGraph.ISOLD && shadow) {\n            this.DrawIEShadow([x + hmargin, y, width - 2 * hmargin, height + 1]);\n          }\n          if (height > 0) {\n            co.strokeRect(x + hmargin, y, width - 2 * hmargin, height);co.fillRect(x + hmargin, y, width - 2 * hmargin, height);\n          }\n          if (j == 0) {\n            var startY = y;var startX = x;\n          }\n          if (shadow) {\n            redrawCoords.push([x + hmargin, y, width - 2 * hmargin, height, co.fillStyle]);\n          }\n          if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;if (j == 0) {\n              co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();if (j == 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmargin, y);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin, y);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + barWidth + hmargin, y);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);co.lineTo(startX + barWidth + hmargin, y + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          y += height;\n        }\n        if (shadow) {\n          RGraph.NoShadow(this);for (k = 0; k < redrawCoords.length; ++k) {\n            co.strokeStyle = strokeStyle;co.fillStyle = redrawCoords[k][4];co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);co.stroke();co.fill();\n          }\n          redrawCoords = [];\n        }\n      } else if (this.data[i] && _typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var redrawCoords = [];co.lineWidth = prop['chart.linewidth'];for (j = 0; j < this.data[i].length; ++j) {\n          co.strokeStyle = strokeStyle;co.fillStyle = colors[j];if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {\n            co.fillStyle = colors[sequentialColorIndex++];\n          } else if (prop['chart.colors.sequential']) {\n            co.fillStyle = colors[sequentialColorIndex - 1];\n          }\n          var individualBarWidth = (width - 2 * hmargin) / this.data[i].length;var height = (this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : -1 * this.scale2.min)) / (this.scale2.max - this.scale2.min) * (ca.height - this.gutterTop - this.gutterBottom);var groupedMargin = prop['chart.hmargin.grouped'];var startX = x + hmargin + j * individualBarWidth;if (individualBarWidth < 0) {\n            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');\n          }\n          if (xaxispos == 'center') {\n            height /= 2;\n          }\n          if (xaxispos == 'top') {\n            var startY = this.gutterTop;var height = Math.abs(height);\n          } else if (xaxispos == 'center') {\n            var startY = this.gutterTop + this.grapharea / 2 - height;\n          } else {\n            var startY = this.getYCoord(0);var height = ma.abs(ma.abs(this.getYCoord(this.data[i][j])) - this.getYCoord(0));if (this.data[i][j] >= 0) {\n              startY -= height;\n            }\n          }\n          co.strokeRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);co.fillRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);y += height;if (variant == '3d') {\n            var prevFillStyle = co.fillStyle;var prevStrokeStyle = co.strokeStyle;var hmarginGrouped = prop['chart.hmargin.grouped'];if (this.data[i][j] >= 0) {\n              co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped - 1, startY);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 && startY + height - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped - 1, startY + height);co.closePath();co.fill();co.stroke();if (this.data[i][j] >= 0) {\n              co.fillStyle = 'rgba(255,255,255,0.5)';co.beginPath();co.moveTo(startX + hmarginGrouped, startY);co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);co.closePath();co.fill();co.stroke();\n            }\n            co.fillStyle = 'rgba(0,0,0,0.4)';co.beginPath();co.moveTo(startX + individualBarWidth - hmarginGrouped, startY);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 && startY + height - 5 < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);co.lineTo(startX + individualBarWidth - hmarginGrouped, startY + height);co.closePath();co.fill();co.stroke();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (height < 0) {\n            height = Math.abs(height);startY = startY - height;\n          }\n          this.coords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (typeof this.coords2[i] == 'undefined') {\n            this.coords2[i] = [];\n          }\n          this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);if (prop['chart.shadow']) {\n            redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height, co.fillStyle]);\n          }\n        }\n        if (redrawCoords.length) {\n          RGraph.NoShadow(this);co.lineWidth = prop['chart.linewidth'];co.beginPath();for (var j = 0; j < redrawCoords.length; ++j) {\n            co.fillStyle = redrawCoords[j][4];co.strokeStyle = prop['chart.strokecolor'];co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);\n          }\n          co.fill();co.stroke();redrawCoords = [];\n        }\n      } else {\n        this.coords.push([]);\n      }\n      co.closePath();\n    }\n    if (prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right') {\n      RG.draw3DYAxis(this);\n    }\n    RGraph.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co;var text_angle = prop['chart.text.angle'],\n        text_size = prop['chart.text.size'],\n        labels = prop['chart.labels'];\n    if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'top') this.Drawlabels_top();if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();\n    }\n    if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) == 'object' && labels) {\n      var yOffset = Number(prop['chart.labels.offsety']),\n          xOffset = Number(prop['chart.labels.offsetx']),\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.text.angle'] != 0) {\n        var valign = 'center';var halign = 'right';var angle = 0 - prop['chart.text.angle'];\n      } else {\n        var valign = 'top';var halign = 'center';var angle = 0;\n      }\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;\n      var i = 0;var font = prop['chart.text.font'];for (x = this.gutterLeft + xTickGap / 2; x <= ca.width - this.gutterRight; x += xTickGap) {\n        RG.text2(this, _defineProperty({ 'font': font, 'size': text_size, 'x': x + xOffset, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + yOffset - 5 : ca.height - this.gutterBottom + yOffset + 3, 'bold': bold, 'text': String(labels[i++]), 'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign, 'halign': halign, 'tag': 'label', 'marker': false, 'angle': angle }, 'tag', 'labels'));\n      }\n    }\n    this.drawAboveLabels();\n  };this.drawlabels_top = this.Drawlabels_top = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.xaxispos'] == 'top') {\n      var context = co;var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea * (i / labels.length) + grapharea / labels.length;RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      var labels = this.scale2.labels;for (var i = 0; i < labels.length; ++i) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea / labels.length * (i + 1) + offsety, 'text': '-' + labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n        RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'text': (this.scale2.min != 0 ? '-' : '') + RGraph.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n    }\n    co.fill();\n  };this.drawlabels_center = this.Drawlabels_center = function () {\n    var ca = this.canvas;var co = this.context;var prop = this.properties;var font = prop['chart.text.font'];var numYLabels = prop['chart.ylabels.count'];co.fillStyle = prop['chart.text.color'];if (prop['chart.xaxispos'] == 'center') {\n      var text_size = prop['chart.text.size'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var context = co;var align = '';var xpos = 0;var boxed = false;var ymin = prop['chart.ymin'];var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n      } else {\n        var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var boxed = false;\n      }\n      if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n        var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n          var y = this.gutterTop + grapharea / 2 / (labels.length - 1) * i;RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[i]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        for (var i = labels.length - 1; i >= 1; --i) {\n          var y = this.gutterTop + grapharea * (i / ((labels.length - 1) * 2)) + grapharea / 2;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': String(labels[labels.length - i - 1]), 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n        }\n        return;\n      }\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        var y = this.gutterTop + this.halfgrapharea - this.halfgrapharea / numYLabels * (i + 1);var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      for (var i = this.scale2.labels.length - 1; i >= 0; --i) {\n        var y = this.gutterTop + this.halfgrapharea / numYLabels * (i + 1) + this.halfgrapharea;var text = this.scale2.labels[i];RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': '-' + text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {\n        var _RG$Text;\n\n        RG.Text2(this, (_RG$Text = { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.halfgrapharea + offsety, 'text': RG.number_format(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center' }, _defineProperty(_RG$Text, 'valign', 'center'), _defineProperty(_RG$Text, 'halign', align), _defineProperty(_RG$Text, 'bordered', boxed), _defineProperty(_RG$Text, 'tag', 'scale'), _RG$Text));\n      }\n    }\n  };this.drawlabels_bottom = this.Drawlabels_bottom = function () {\n    var text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        context = this.context,\n        align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left',\n        font = prop['chart.text.font'],\n        numYLabels = prop['chart.ylabels.count'],\n        ymin = prop['chart.ymin'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';if (prop['chart.ylabels.inside'] == true) {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';var boxed = true;\n    } else {\n      var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var boxed = false;\n    }\n    if (prop['chart.ylabels.specific'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var labels = prop['chart.ylabels.specific'];var grapharea = ca.height - this.gutterTop - this.gutterBottom;for (var i = 0; i < labels.length; ++i) {\n        var y = this.gutterTop + grapharea * (i / (labels.length - 1));RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n      }\n      return;\n    }\n    var gutterTop = this.gutterTop;var halfTextHeight = this.halfTextHeight;var scale = this.scale;for (var i = 0; i < numYLabels; ++i) {\n      var text = this.scale2.labels[i];RGraph.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + this.grapharea - this.grapharea / numYLabels * (i + 1) + offsety, 'text': text, 'valign': 'center', 'halign': align, 'bordered': boxed, 'tag': 'scale' });\n    }\n    if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {\n      RG.text2(this, { font: font, size: text_size, x: xpos + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), valign: 'center', halign: align, bordered: boxed, tag: 'scale' });\n    }\n    co.fill();\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };this.getShape = this.getBar = function (e) {\n    var obj = arguments[1] ? arguments[1] : this;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        canvas = obj.canvas,\n        context = obj.context,\n        coords = obj.coords;\n    for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var left = coords[i][0],\n          top = coords[i][1],\n          width = coords[i][2],\n          height = coords[i][3],\n          prop = obj.properties;\n      if (prop['chart.tooltips.hotspot.xonly']) {\n        pa2(co, 'b r % % % %', left, this.gutterTop, width, ca.height - this.gutterBottom);\n      } else {\n        pa2(co, 'b r % % % %', left, top, width, height);\n      }\n      if (co.isPointInPath(mouseX, mouseY)) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        var dataset = 0,\n            idx = i;\n        while (idx >= (_typeof(obj.data[dataset]) === 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {\n          if (typeof obj.data[dataset] === 'number') {\n            idx -= 1;\n          } else if (obj.data[dataset]) {\n            idx -= obj.data[dataset].length;\n          } else {\n            idx -= 1;\n          }\n          dataset++;\n        }\n        if (typeof obj.data[dataset] == 'number') {\n          idx = null;\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset };\n      }\n    }\n    return null;\n  };this.getShapeByX = function (e) {\n    var canvas = e.target;var mouseCoords = RGraph.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var left = obj.coords[i][0];var top = obj.coords[i][1];var width = obj.coords[i][2];var height = obj.coords[i][3];var prop = obj.properties;if (mouseX >= left && mouseX <= left + width) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    var co = this.context;var ca = this.canvas;var prop = this.properties;if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < prop['chart.gutter.top'] || mouseY > ca.height - prop['chart.gutter.bottom'] || mouseX < prop['chart.gutter.left'] || mouseX > ca.width - prop['chart.gutter.right']) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value *= 2;if (value >= 0) {\n        value += this.scale2.min;\n      } else {\n        value -= this.scale2.min;\n      }\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value = this.scale2.max - value;value = ma.abs(value) * -1;\n    } else {\n      var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);\n      value += this.scale2.min;\n    }\n    return value;\n  };this.getYCoord = function (value) {\n    if (value > this.scale2.max) {\n      return null;\n    }\n    var co = this.context,\n        ca = this.canvas,\n        prop = this.properties;var y,\n        xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      if (value < 0) {\n        value = ma.abs(value);\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * this.grapharea;y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if (value < this.scale2.min) {\n        value = this.scale2.min;\n      }\n      y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min);y *= ca.height - this.gutterTop - this.gutterBottom;y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= prop['chart.gutter.left'] && mouseXY[0] <= ca.width - prop['chart.gutter.right'] && mouseXY[1] >= prop['chart.gutter.top'] && mouseXY[1] <= ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');\n      if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.isNull(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.highlight.stroke'] = prop['chart.highlight.stroke'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.strokecolor'] = prop['chart.strokecolor'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.strokecolor'] = this.parseSingleColorForGradient(prop['chart.strokecolor']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RGraph.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    var coords = this.coords;var coords2 = this.coords2;var prop = this.properties;var co = this.context;var ca = this.canvas;if (prop['chart.grouping'] == 'stacked') {\n      for (var i = 0; i < coords2.length; ++i) {\n        if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {\n          var x = coords2[i][0][0];var y = coords2[i][0][1];var w = coords2[i][0][2];var arr = [];for (var j = 0; j < coords2[i].length; ++j) {\n            arr.push(coords2[i][j][3]);\n          }\n          var h = RGraph.array_sum(arr);co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 100);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    } else {\n      for (var i = 0; i < coords.length; ++i) {\n        if (coords[i]) {\n          var x = coords[i][0];var y = coords[i][1];var w = coords[i][2];var h = coords[i][3];var xaxispos = prop['chart.xaxispos'];var xaxis_ycoord = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;co.save();co.strokeStyle = 'black';co.beginPath();co.rect(x, y, w, h);co.clip();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 20;if (xaxispos == 'top' || xaxispos == 'center' && y + h > xaxis_ycoord) {\n            y = y - 100;h = h + 100;\n          } else {\n            y = y;h = h + 100;\n          }\n          co.beginPath();co.rect(x - 3, y - 3, w + 6, h + 6);co.lineWidth = 5;co.stroke();co.restore();\n        }\n      }\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    this.coords2.forEach(function (value, idx, arr) {\n      if (_typeof(value[index]) == 'object' && value[index]) {\n        var x = value[index][0];\n        var y = value[index][1];\n        var w = value[index][2];\n        var h = value[index][3];\n        co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.strokeRect(x, y, w, h);co.fillRect(x, y, w, h);\n      }\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawAboveLabels = function () {\n    var labels = prop['chart.labels.above'],\n        specific = prop['chart.labels.above.specific'],\n        color = prop['chart.labels.above.color'],\n        background = prop['chart.labels.above.background'],\n        decimals = prop['chart.labels.above.decimals'],\n        size = prop['chart.labels.above.size'],\n        angle = -1 * prop['chart.labels.above.angle'],\n        unitsPre = prop['chart.labels.above.units.pre'],\n        unitsPost = prop['chart.labels.above.units.post'],\n        coords = this.coords,\n        coords2 = this.coords2,\n        data = this.data,\n        ldata = RG.arrayLinearize(this.data),\n        offset = prop['chart.labels.above.offset'],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        grouping = prop['chart.grouping'];\n    RG.noShadow(this);co.fillStyle = typeof color === 'string' ? color : prop['chart.text.color'];if (labels && grouping === 'grouped') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (typeof data[i] === 'number' && data[i] >= 0) {\n          var angle = angle;var halign = angle ? 'left' : 'center';var valign = angle !== 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'marker': false, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'tag': 'labels.above' });sequentialIndex++;\n        } else if (typeof data[i] === 'number' && data[i] < 0) {\n          var angle = angle;var halign = angle ? 'right' : 'center';var valign = angle !== 0 ? 'center' : 'top';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + coords2[i][0][3] + offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(_typeof(data[i]) === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        } else if (_typeof(data[i]) === 'object') {\n          for (var j = 0, len2 = data[i].length; j < len2; j += 1) {\n            var angle = angle;var halign = data[i][j] < 0 ? 'right' : 'left';halign = angle === 0 ? 'center' : halign;var valign = data[i][j] < 0 ? 'top' : 'bottom';valign = angle != 0 ? 'center' : valign;RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][j][0] + coords2[i][j][2] / 2, 'y': coords2[i][j][1] + (data[i][j] < 0 ? coords2[i][j][3] + offset : -offset), 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i][j]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n          }\n        }\n      }\n    } else if (labels && grouping === 'stacked') {\n      for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {\n        if (_typeof(data[i]) === 'object') {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(RG.arraySum(data[i])).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex += data[i].length;\n        } else {\n          var angle = angle;var halign = angle != 0 ? 'left' : 'center';var valign = angle != 0 ? 'center' : 'bottom';RG.text2(this, { 'font': text_font, 'size': typeof size === 'number' ? size : text_size - 3, 'x': coords2[i][0][0] + coords2[i][0][2] / 2, 'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset, 'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i]).toFixed(decimals), unitsPre, unitsPost), 'halign': halign, 'valign': valign, 'angle': angle, 'bounding': true, 'bounding.fill': background, 'bounding.stroke': 'rgba(0,0,0,0)', 'marker': false, 'tag': 'labels.above' });sequentialIndex++;\n        }\n      }\n    }\n  };this.firstDrawFunc = function () {};this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        labelsAbove = this.get('labelsAbove');opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(this.original_data);this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('ymax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.colorWave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [], colors = obj.properties['chart.colors'];if (colors.length <= obj.data.length) {\n      obj.set('chart.colors.sequential', true);colors = RG.arrayPad(colors, obj.data.length, colors[colors.length - 1]);\n    }\n    var framesperbar = opt.frames / 2,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        originalColors = RG.arrayClone(obj.properties['chart.colors']);for (var i = 0, len = originalColors.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (originalColors.length - 1) * i;opt.counters[i] = 0;\n    }\n    function iterator() {\n      ++frame;for (var i = 0, len = colors.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i] && colors[i].match(/^rgba?\\(([0-9 ]+),([0-9 ]+),([0-9 ]+)(,([ 0-9.]+)?)\\)/)) {\n          colors[i] = 'rgba({1},{2},{3},{4})'.format(RegExp.$1, RegExp.$2, RegExp.$3, (frame - opt.startFrames[i]) / framesperbar);\n        } else {\n          colors[i] = colors[i].replace(/,[0-9. ]+\\)/, ',0)');\n        }\n      }\n      if (frame >= opt.frames) {\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    if (RG.isArray(opt.data)) {\n      var ymax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            ymax = ma.max(ymax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseInt(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseInt(RegExp.$2);\n          }\n          ymax = ma.max(ymax, opt.data[i]);\n        } else {\n          ymax = ma.max(ymax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    this.set('labelsAbove', false);if (prop['chart.ymax'] == null) {\n      var ymax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          ymax = ma.max(ymax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          ymax = ma.max(ymax, ma.abs(RG.arrayMax(group)));\n        } else {\n          ymax = ma.max(ymax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': ymax });this.Set('chart.ymax', scale.max);\n    }\n    if (typeof opt.ymax === 'number') {\n      obj.set('ymax', opt.ymax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.drawErrorbars = function () {\n    var coords = this.coords,\n        color = prop['chart.errorbars.color'] || 'black',\n        default_halfwidth = ma.min(prop['chart.errorbars.capped.width'], coords[0][2]) / 2,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0;halfwidth = 0;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      }\n      var halfwidth = errorbars[i] && typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n        halfwidth = 0;\n      }\n      if (typeof errorbars[i] === 'number') {\n        length = ma.abs(this.getYCoord(errorbars[i]) - this.getYCoord(0));if (length) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - length, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - length), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - length), color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = ma.abs(this.getYCoord(errorbars[i][0]) - this.getYCoord(0));if (typeof errorbars[i][1] === 'string') {\n          color = errorbars[i][1];\n        } else if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;if (!prop['chart.errorbars.capped']) {\n          halfwidth = 0;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - positiveLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] + negativeLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n      if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      }\n    }\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only']) || !RG.isArray(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};RGraph.CombinedChart = function () {\n  this.objects = [];var objects = [];if (RGraph.isArray(arguments[0])) {\n    objects = arguments[0];\n  } else {\n    for (var i = 0; i < arguments.length; i += 1) {\n      objects[i] = arguments[i];\n    }\n  }\n  for (var i = 0; i < objects.length; ++i) {\n    this.objects[i] = objects[i];this.objects[i].set({ gutterLeft: this.objects[0].get('gutter.left'), gutterRight: this.objects[0].get('gutter.right'), gutterTop: this.objects[0].get('gutter.top'), gutterBottom: this.objects[0].get('gutter.bottom') });if (this.objects[i].type == 'line') {\n      var obj = this.objects[i];obj.set('hmargin', (this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length / 2);obj.set('noaxes', true);obj.set('backgroundGrid', false);obj.set('ylabels', false);\n    }\n    if (this.objects[i].get('chart.resizable')) {\n      var resizable_object = obj;\n    }\n  }\n  if (resizable_object) {\n    var myOnresizebeforedraw = function myOnresizebeforedraw(obj) {\n      var gutterLeft = obj.get('gutterLeft');var gutterRight = obj.get('gutterRight');obj.set('hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));\n    };\n\n    RGraph.AddCustomEventListener(resizable_object, 'onresizebeforedraw', myOnresizebeforedraw);\n  }\n};RGraph.CombinedChart.prototype.add = RGraph.CombinedChart.prototype.Add = function (obj) {\n  this.objects.push(obj);\n};RGraph.CombinedChart.prototype.draw = RGraph.CombinedChart.prototype.Draw = function () {\n  for (var i = 0; i < this.objects.length; ++i) {\n    if (this.objects[i].properties['chart.combinedchart.effect']) {\n      var options = this.objects[i].properties['chart.combinedchart.effect.options'] ? eval('(' + this.objects[i].properties['chart.combinedchart.effect.options'] + ')') : null,\n          callback = this.objects[i].properties['chart.combinedchart.effect.callback'],\n          func = this.objects[i].properties['chart.combinedchart.effect'];this.objects[i][func](options, callback);\n    } else {\n      this.objects[i].draw();\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5iYXIuanM/YjQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5CYXIgPSBmdW5jdGlvbiAoY29uZikge1xuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBkYXRhID0gY29uZi5kYXRhLFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ2Jhcic7dGhpcy5tYXggPSAwO3RoaXMuc3RhY2tlZE9yR3JvdXBlZCA9IGZhbHNlO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5jYWNoZWRCYWNrZ3JvdW5kQ2FudmFzID0gbnVsbDt0aGlzLmZpcnN0RHJhdyA9IHRydWU7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOiAnI2RkZCcsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQud2lkdGgnOiAxLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhzaXplJzogMjAsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudnNpemUnOiAyMCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52bGluZXMnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYm9yZGVyJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0JzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0LmFsaWduJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyc6IDUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOiAyMCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kYXNoZWQnOiBmYWxzZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kb3R0ZWQnOiBmYWxzZSwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLngnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS55JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uudyc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5hbGlnbic6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnOiBudWxsLCAnY2hhcnQubnVteXRpY2tzJzogMTAsICdjaGFydC5obWFyZ2luJzogNSwgJ2NoYXJ0LmhtYXJnaW4uZ3JvdXBlZCc6IDEsICdjaGFydC5zdHJva2Vjb2xvcic6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmF4aXMuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuYXhpcy5saW5ld2lkdGgnOiAxLCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDM1LCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQubGFiZWxzJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5ib2xkJzogZmFsc2UsICdjaGFydC5sYWJlbHMuY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzLmluZ3JhcGgnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlJzogZmFsc2UsICdjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnOiAwLCAnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5iYWNrZ3JvdW5kJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQubGFiZWxzLmFib3ZlLmFuZ2xlJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5vZmZzZXQnOiA0LCAnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSc6ICcnLCAnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnlsYWJlbHMnOiB0cnVlLCAnY2hhcnQueWxhYmVscy5jb3VudCc6IDUsICdjaGFydC55bGFiZWxzLmluc2lkZSc6IGZhbHNlLCAnY2hhcnQueWxhYmVscy5vZmZzZXR4JzogMCwgJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSc6IDAsICdjaGFydC5sYWJlbHMub2Zmc2V0eCc6IDAsICdjaGFydC5sYWJlbHMub2Zmc2V0eSc6IDAsICdjaGFydC54YXhpc3Bvcyc6ICdib3R0b20nLCAnY2hhcnQueWF4aXNwb3MnOiAnbGVmdCcsICdjaGFydC50ZXh0LmFuZ2xlJzogMCwgJ2NoYXJ0LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC55bWluJzogMCwgJ2NoYXJ0LnltYXgnOiBudWxsLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC50aXRsZS5ocG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS54YXhpcyc6ICcnLCAnY2hhcnQudGl0bGUueGF4aXMuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS54YXhpcy5zaXplJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMuY29sb3InOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMnOiAnJywgJ2NoYXJ0LnRpdGxlLnlheGlzLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueWF4aXMuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLnBvcyc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5wb3MnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMueCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5jb2xvcnMnOiBbJ3JlZCcsICcjMGYwJywgJ2JsdWUnLCAncGluaycsICdvcmFuZ2UnLCAnY3lhbicsICdibGFjaycsICd3aGl0ZScsICdncmVlbicsICdtYWdlbnRhJ10sICdjaGFydC5jb2xvcnMuc2VxdWVudGlhbCc6IGZhbHNlLCAnY2hhcnQuY29sb3JzLnJldmVyc2UnOiBmYWxzZSwgJ2NoYXJ0Lmdyb3VwaW5nJzogJ2dyb3VwZWQnLCAnY2hhcnQudmFyaWFudCc6ICdiYXInLCAnY2hhcnQudmFyaWFudC5za2V0Y2gudmVydGljYWxzJzogdHJ1ZSwgJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLnhheGlzJzogdHJ1ZSwgJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLnlheGlzJzogdHJ1ZSwgJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJzogMC4xLCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCc6IDEwLCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSc6IDUsICdjaGFydC5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICcjYWFhJywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMCwgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMCwgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogMTUsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQudG9vbHRpcHMuaG90c3BvdC54b25seSc6IGZhbHNlLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InOiAnIzY2NicsICdjaGFydC5rZXkuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4JzogMiwgJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eSc6IDIsICdjaGFydC5rZXkucG9zaXRpb24uZ3V0dGVyLmJveGVkJzogZmFsc2UsICdjaGFydC5rZXkucG9zaXRpb24ueCc6IG51bGwsICdjaGFydC5rZXkucG9zaXRpb24ueSc6IG51bGwsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUnOiBmYWxzZSwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJzogJ2JsYWNrJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5sYWJlbCc6ICdyZ2JhKDI1NSwwLDAsMC4yKScsICdjaGFydC5rZXkuaGFsaWduJzogJ3JpZ2h0JywgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LnRleHQuc2l6ZSc6IDEwLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LnVuaXRzLnByZSc6ICcnLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiAwLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5zY2FsZS50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LnNjYWxlLnJvdW5kJzogZmFsc2UsICdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOiB0cnVlLCAnY2hhcnQuY3Jvc3NoYWlycyc6IGZhbHNlLCAnY2hhcnQuY3Jvc3NoYWlycy5jb2xvcic6ICcjMzMzJywgJ2NoYXJ0LmNyb3NzaGFpcnMuaGxpbmUnOiB0cnVlLCAnY2hhcnQuY3Jvc3NoYWlycy52bGluZSc6IHRydWUsICdjaGFydC5saW5ld2lkdGgnOiAxLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0Lnpvb20uZmFjdG9yJzogMS41LCAnY2hhcnQuem9vbS5mYWRlLmluJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOiB0cnVlLCAnY2hhcnQuem9vbS5oZGlyJzogJ3JpZ2h0JywgJ2NoYXJ0Lnpvb20udmRpcic6ICdkb3duJywgJ2NoYXJ0Lnpvb20uZnJhbWVzJzogMjUsICdjaGFydC56b29tLmRlbGF5JzogMTYuNjY2LCAnY2hhcnQuem9vbS5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzogdHJ1ZSwgJ2NoYXJ0LnJlc2l6YWJsZSc6IGZhbHNlLCAnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LmFkanVzdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFkanVzdGFibGUub25seSc6IG51bGwsICdjaGFydC5ub2F4ZXMnOiBmYWxzZSwgJ2NoYXJ0Lm5veGF4aXMnOiBmYWxzZSwgJ2NoYXJ0Lm5veWF4aXMnOiBmYWxzZSwgJ2NoYXJ0LmV2ZW50cy5jbGljayc6IG51bGwsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzogbnVsbCwgJ2NoYXJ0Lm51bXh0aWNrcyc6IG51bGwsICdjaGFydC5iZXZlbCc6IGZhbHNlLCAnY2hhcnQuZXJyb3JiYXJzJzogZmFsc2UsICdjaGFydC5lcnJvcmJhcnMuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZCc6IHRydWUsICdjaGFydC5lcnJvcmJhcnMuY2FwcGVkLndpZHRoJzogMTQsICdjaGFydC5lcnJvcmJhcnMubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0JzogbnVsbCwgJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0Lm9wdGlvbnMnOiBudWxsLCAnY2hhcnQuY29tYmluZWRjaGFydC5lZmZlY3QuY2FsbGJhY2snOiBudWxsLCAnY2hhcnQuY2xlYXJ0byc6ICdyZ2JhKDAsMCwwLDApJyB9O1xuICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgYWxlcnQoJ1tCQVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgZGF0YVtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGFbaV0gPSBwYXJzZUZsb2F0KGRhdGFbaV0pO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkYXRhW2ldKSA9PT0gJ29iamVjdCcgJiYgZGF0YVtpXSkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBkYXRhW2ldW2pdID0gcGFyc2VGbG9hdChkYXRhW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhW2ldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKF90eXBlb2YoZGF0YVtpXSkgPT09ICdvYmplY3QnICYmICFSR3JhcGguaXNfbnVsbChkYXRhW2ldKSkge1xuICAgICAgdGhpcy5zdGFja2VkT3JHcm91cGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdmFyIGxpbmVhcl9kYXRhID0gUkdyYXBoLmFycmF5TGluZWFyaXplKGRhdGEpO2ZvciAodmFyIGkgPSAwOyBpIDwgbGluZWFyX2RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzWyckJyArIGldID0ge307XG4gIH1cbiAgdGhpcy5kYXRhID0gZGF0YTt0aGlzLm9yaWdpbmFsX2RhdGEgPSBSR3JhcGguYXJyYXlDbG9uZShkYXRhKTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMuZGF0YV9hcnIgPSBSR3JhcGguYXJyYXlMaW5lYXJpemUodGhpcy5kYXRhKTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgYXJndW1lbnRzWzBdKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NoYXJ0LnhsYWJlbHMub2Zmc2V0Jykge1xuICAgICAgbmFtZSA9ICdjaGFydC5sYWJlbHMub2Zmc2V0eSc7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5sYWJlbHMuYWJvdmViYXInKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LmxhYmVscy5hYm92ZSc7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5zdHJva2VzdHlsZScpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuc3Ryb2tlY29sb3InO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQueGF4aXNwb3MnKSB7XG4gICAgICBpZiAodmFsdWUgIT0gJ2JvdHRvbScgJiYgdmFsdWUgIT0gJ2NlbnRlcicgJiYgdmFsdWUgIT0gJ3RvcCcpIHtcbiAgICAgICAgYWxlcnQoJ1tCQVJdICgnICsgdGhpcy5pZCArICcpIGNoYXJ0LnhheGlzcG9zIHNob3VsZCBiZSB0b3AsIGNlbnRlciBvciBib3R0b20uIFRyaWVkIHRvIHNldCBpdCB0bzogJyArIHZhbHVlICsgJyBDaGFuZ2luZyBpdCB0byBjZW50ZXInKTt2YWx1ZSA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09ICd0b3AnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT0gJ251bWJlcicgJiYgdGhpcy5kYXRhW2ldID4gMCkge1xuICAgICAgICAgICAgYWxlcnQoJ1tCQVJdIFRoZSBkYXRhIGVsZW1lbnQgd2l0aCBpbmRleCAnICsgaSArICcgc2hvdWxkIGJlIG5lZ2F0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2NoYXJ0LmxpbmV3aWR0aCcgJiYgdmFsdWUgPT0gMCkge1xuICAgICAgdmFsdWUgPSAwLjAwMDE7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UnXSA9PSAnc3RyaW5nJykge1xuICAgICAgUkcuRHJhd0JhY2tncm91bmRJbWFnZSh0aGlzKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAocHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJ10pIHt9IGVsc2Uge1xuICAgICAgICBjby5zZXRUcmFuc2Zvcm0oMSwgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSwgMCwgMSwgMC41LCAwLjUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTtpZiAoKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAncHlyYW1pZCcgfHwgcHJvcFsnY2hhcnQudmFyaWFudCddID09ICdkb3QnKSAmJiBfdHlwZW9mKHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10gJiYgcHJvcFsnY2hhcnQudG9vbHRpcHMnXS5sZW5ndGggPiAwKSB7XG4gICAgICBhbGVydCgnW0JBUl0gKCcgKyB0aGlzLmlkICsgJykgU29ycnksIHRvb2x0aXBzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggZG90IG9yIHB5cmFtaWQgY2hhcnRzJyk7XG4gICAgfVxuICAgIHRoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHMyID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5tYXggPSAwO3RoaXMuZ3JhcGhhcmVhID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbTt0aGlzLmhhbGZncmFwaGFyZWEgPSB0aGlzLmdyYXBoYXJlYSAvIDI7dGhpcy5oYWxmVGV4dEhlaWdodCA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddIC8gMjtSRy5iYWNrZ3JvdW5kLkRyYXcodGhpcyk7dGhpcy5kcmF3YmFycygpO3RoaXMuZHJhd0F4ZXMoKTt0aGlzLkRyYXdMYWJlbHMoKTtpZiAocHJvcFsnY2hhcnQuYmV2ZWwnXSB8fCBwcm9wWydjaGFydC5iZXZlbGxlZCddKSB7XG4gICAgICB0aGlzLkRyYXdCZXZlbCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQua2V5J10gJiYgcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoKSB7XG4gICAgICBSRy5EcmF3S2V5KHRoaXMsIHByb3BbJ2NoYXJ0LmtleSddLCBwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmVycm9yYmFycyddKSB7XG4gICAgICB0aGlzLmRyYXdFcnJvcmJhcnMoKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoJ10pIHtcbiAgICAgIFJHLkRyYXdJbkdyYXBoTGFiZWxzKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdBeGVzID0gdGhpcy5EcmF3QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQubm9heGVzJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHhheGlzcG9zID0gcHJvcFsnY2hhcnQueGF4aXNwb3MnXTt2YXIgeWF4aXNwb3MgPSBwcm9wWydjaGFydC55YXhpc3BvcyddO3ZhciBpc1NrZXRjaCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnc2tldGNoJztjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddICsgMC4wMDE7aWYgKFJHLklTU0FGQVJJID09IC0xKSB7XG4gICAgICBjby5saW5lQ2FwID0gJ3NxdWFyZSc7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UpIHtcbiAgICAgIGlmICh5YXhpc3BvcyA9PSAncmlnaHQnKSB7XG4gICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyAoaXNTa2V0Y2ggPyAzIDogMCksIHRoaXMuZ3V0dGVyVG9wIC0gKGlzU2tldGNoID8gMyA6IDApKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gKGlzU2tldGNoID8gMiA6IDApLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIChpc1NrZXRjaCA/IDUgOiAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0IC0gKGlzU2tldGNoID8gMiA6IDApLCB0aGlzLmd1dHRlclRvcCAtIChpc1NrZXRjaCA/IDUgOiAwKSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCAtIChpc1NrZXRjaCA/IDEgOiAwKSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyAoaXNTa2V0Y2ggPyA1IDogMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlKSB7XG4gICAgICBpZiAoeGF4aXNwb3MgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCAtIChpc1NrZXRjaCA/IDUgOiAwKSwgTWF0aC5yb3VuZCgoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3AgKyAoaXNTa2V0Y2ggPyAyIDogMCkpKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgKGlzU2tldGNoID8gNSA6IDApLCBNYXRoLnJvdW5kKChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDIgKyB0aGlzLmd1dHRlclRvcCAtIChpc1NrZXRjaCA/IDIgOiAwKSkpO1xuICAgICAgfSBlbHNlIGlmICh4YXhpc3BvcyA9PSAndG9wJykge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0IC0gKGlzU2tldGNoID8gMyA6IDApLCB0aGlzLmd1dHRlclRvcCAtIChpc1NrZXRjaCA/IDMgOiAwKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIChpc1NrZXRjaCA/IDUgOiAwKSwgdGhpcy5ndXR0ZXJUb3AgKyAoaXNTa2V0Y2ggPyAyIDogMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCAtIChpc1NrZXRjaCA/IDUgOiAwKSwgbWEucm91bmQodGhpcy5nZXRZQ29vcmQoMCkgLSAoaXNTa2V0Y2ggPyAyIDogMCkpKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgKGlzU2tldGNoID8gOCA6IDApLCBtYS5yb3VuZCh0aGlzLmdldFlDb29yZCgwKSArIChpc1NrZXRjaCA/IDIgOiAwKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbnVtWVRpY2tzID0gcHJvcFsnY2hhcnQubnVteXRpY2tzJ107aWYgKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSA9PSBmYWxzZSAmJiAhaXNTa2V0Y2gpIHtcbiAgICAgIHZhciB5VGlja0dhcCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIG51bVlUaWNrczt2YXIgeHBvcyA9IHlheGlzcG9zID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodDtpZiAodGhpcy5wcm9wZXJ0aWVzWydjaGFydC5udW15dGlja3MnXSA+IDApIHtcbiAgICAgICAgZm9yICh5ID0gdGhpcy5ndXR0ZXJUb3A7IHhheGlzcG9zID09ICdjZW50ZXInID8geSA8PSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSA6IHkgPCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArICh4YXhpc3BvcyA9PSAndG9wJyA/IDEgOiAwKTsgeSArPSB5VGlja0dhcCkge1xuICAgICAgICAgIGlmICh4YXhpc3BvcyA9PSAnY2VudGVyJyAmJiB5ID09IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHhheGlzcG9zID09ICd0b3AnICYmIHkgPT0gdGhpcy5ndXR0ZXJUb3ApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5tb3ZlVG8oeHBvcyArICh5YXhpc3BvcyA9PSAnbGVmdCcgPyAwIDogMCksIG1hLnJvdW5kKHkpKTtjby5saW5lVG8oeHBvcyArICh5YXhpc3BvcyA9PSAnbGVmdCcgPyAtMyA6IDMpLCBtYS5yb3VuZCh5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhheGlzcG9zID09PSAnYm90dG9tJyAmJiBwcm9wWydjaGFydC55bWluJ10gIT09IDApIHtcbiAgICAgICAgICBjby5tb3ZlVG8oeHBvcyArICh5YXhpc3BvcyA9PSAnbGVmdCcgPyAwIDogMCksIG1hLnJvdW5kKGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpO2NvLmxpbmVUbyh4cG9zICsgKHlheGlzcG9zID09ICdsZWZ0JyA/IC0zIDogMyksIG1hLnJvdW5kKGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddKSB7XG4gICAgICAgIGlmICh4YXhpc3BvcyA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGNvLm1vdmVUbyh4cG9zICsgKHlheGlzcG9zID09ICdsZWZ0JyA/IC0zIDogMyksIE1hdGgucm91bmQoY2EuaGVpZ2h0IC8gMikpO2NvLmxpbmVUbyh4cG9zLCBNYXRoLnJvdW5kKGNhLmhlaWdodCAvIDIpKTtcbiAgICAgICAgfSBlbHNlIGlmICh4YXhpc3BvcyA9PSAndG9wJykge1xuICAgICAgICAgIGNvLm1vdmVUbyh4cG9zICsgKHlheGlzcG9zID09ICdsZWZ0JyA/IC0zIDogMyksIE1hdGgucm91bmQodGhpcy5ndXR0ZXJUb3ApKTtjby5saW5lVG8oeHBvcywgTWF0aC5yb3VuZCh0aGlzLmd1dHRlclRvcCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLm1vdmVUbyh4cG9zICsgKHlheGlzcG9zID09ICdsZWZ0JyA/IC0zIDogMyksIE1hdGgucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8oeHBvcywgTWF0aC5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ub3hheGlzJ10gPT0gZmFsc2UgJiYgIWlzU2tldGNoKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB4VGlja0dhcCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gcHJvcFsnY2hhcnQubnVteHRpY2tzJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeFRpY2tHYXAgPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoeGF4aXNwb3MgPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeVN0YXJ0ID0gcHJvcFsnY2hhcnQueW1pbiddIDwgMCA/IHRoaXMuZ2V0WUNvb3JkKDApIC0gMyA6IHRoaXMuZ2V0WUNvb3JkKDApO3lFbmQgPSB0aGlzLmdldFlDb29yZCgwKSArIDM7XG4gICAgICB9IGVsc2UgaWYgKHhheGlzcG9zID09ICd0b3AnKSB7XG4gICAgICAgIHlTdGFydCA9IHRoaXMuZ3V0dGVyVG9wIC0gMzt5RW5kID0gdGhpcy5ndXR0ZXJUb3A7XG4gICAgICB9IGVsc2UgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgIHlTdGFydCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDIgKyB0aGlzLmd1dHRlclRvcCArIDM7eUVuZCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDIgKyB0aGlzLmd1dHRlclRvcCAtIDM7XG4gICAgICB9XG4gICAgICB2YXIgbm9FbmRYVGljayA9IHByb3BbJ2NoYXJ0Lm5vZW5keHRpY2snXTtmb3IgKHggPSB0aGlzLmd1dHRlckxlZnQgKyAoeWF4aXNwb3MgPT0gJ2xlZnQnID8geFRpY2tHYXAgOiAwKSwgbGVuID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgKHlheGlzcG9zID09ICdsZWZ0JyA/IDUgOiAwKTsgeCA8IGxlbjsgeCArPSB4VGlja0dhcCkge1xuICAgICAgICBpZiAoeWF4aXNwb3MgPT0gJ2xlZnQnICYmICFub0VuZFhUaWNrICYmIHggPiB0aGlzLmd1dHRlckxlZnQpIHtcbiAgICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCB5RW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh5YXhpc3BvcyA9PSAnbGVmdCcgJiYgbm9FbmRYVGljayAmJiB4ID4gdGhpcy5ndXR0ZXJMZWZ0ICYmIHggPCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQpIHtcbiAgICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCB5RW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh5YXhpc3BvcyA9PSAncmlnaHQnICYmIHggPCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgJiYgIW5vRW5kWFRpY2spIHtcbiAgICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIHlTdGFydCk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCB5RW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh5YXhpc3BvcyA9PSAncmlnaHQnICYmIHggPCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgJiYgeCA+IHRoaXMuZ3V0dGVyTGVmdCAmJiBub0VuZFhUaWNrKSB7XG4gICAgICAgICAgY28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5U3RhcnQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSwgeUVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5ub3lheGlzJ10gfHwgcHJvcFsnY2hhcnQubnVteHRpY2tzJ10gPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID09ICdudW1iZXInICYmIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID4gMCkge1xuICAgICAgICAgIGNvLm1vdmVUbyhNYXRoLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksIHlTdGFydCk7Y28ubGluZVRvKE1hdGgucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSwgeUVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSAmJiBwcm9wWydjaGFydC5ub3hheGlzJ10gPT0gZmFsc2UgJiYgcHJvcFsnY2hhcnQubnVteHRpY2tzJ10gPT0gbnVsbCkge1xuICAgICAgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLCBjYS5oZWlnaHQgLyAyIC0gMyk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksIGNhLmhlaWdodCAvIDIgKyAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1xuICB9O3RoaXMuZHJhd2JhcnMgPSB0aGlzLkRyYXdiYXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVswXTt2YXIgcHJldlggPSAwLFxuICAgICAgICBwcmV2WSA9IDAsXG4gICAgICAgIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTtpZiAocHJvcFsnY2hhcnQueW1heCddKSB7XG4gICAgICB0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiBwcm9wWydjaGFydC55bWF4J10sICdzdHJpY3QnOiBwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddID8gZmFsc2UgOiB0cnVlLCAnbWluJzogcHJvcFsnY2hhcnQueW1pbiddLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUuZGVjaW1hbHMnOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCAneWxhYmVscy5jb3VudCc6IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yYmFycyA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycyddO2lmICh0eXBlb2YgZXJyb3JiYXJzID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdmFsdWUgPSBlcnJvcmJhcnM7cHJvcFsnY2hhcnQuZXJyb3JiYXJzJ10gPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcHJvcFsnY2hhcnQuZXJyb3JiYXJzJ10ucHVzaChbdmFsdWUsIG51bGxdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldKSA9PT0gJ29iamVjdCcgJiYgIVJHLmlzTnVsbCh0aGlzLmRhdGFbaV0pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBwcm9wWydjaGFydC5lcnJvcmJhcnMnXS5wdXNoKFt2YWx1ZSwgbnVsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcmJhcnMgPSBwcm9wWydjaGFydC5lcnJvcmJhcnMnXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ10gPT09ICdncm91cGVkJyA/IE51bWJlcihSRy5hcnJheU1heCh0aGlzLmRhdGFbaV0sIHRydWUpKSA6IE51bWJlcihSRy5hcnJheV9zdW0odGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRoaXMuZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXggPSBtYS5tYXgobWEuYWJzKHRoaXMubWF4KSwgbWEuYWJzKHZhbHVlKSArIE51bWJlcihfdHlwZW9mKHByb3BbJ2NoYXJ0LmVycm9yYmFycyddKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihwcm9wWydjaGFydC5lcnJvcmJhcnMnXVtpXSkgPT09ICdvYmplY3QnICYmICFSRy5pc051bGwocHJvcFsnY2hhcnQuZXJyb3JiYXJzJ11baV0pICYmIHR5cGVvZiBwcm9wWydjaGFydC5lcnJvcmJhcnMnXVtpXVswXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5lcnJvcmJhcnMnXVtpXVswXSA6IDApKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NhbGUyID0gUkdyYXBoLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiB0aGlzLm1heCwgJ21pbic6IHByb3BbJ2NoYXJ0LnltaW4nXSwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLmRlY2ltYWxzJzogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgIXByb3BbJ2NoYXJ0LnltYXgnXSkge1xuICAgICAgdGhpcy5TZXQoJ2NoYXJ0LnltYXgnLCB0aGlzLnNjYWxlMi5tYXgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5oYmFycyddICYmIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXS5sZW5ndGggPiAwKSB7XG4gICAgICBSR3JhcGguRHJhd0JhcnModGhpcyk7XG4gICAgfVxuICAgIHZhciB2YXJpYW50ID0gcHJvcFsnY2hhcnQudmFyaWFudCddO2lmICh2YXJpYW50ID09PSAnM2QnKSB7XG4gICAgICBSRy5kcmF3M0RBeGVzKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgeGF4aXNwb3MgPSBwcm9wWydjaGFydC54YXhpc3BvcyddLFxuICAgICAgICB3aWR0aCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gdGhpcy5kYXRhLmxlbmd0aCxcbiAgICAgICAgb3JpZ19oZWlnaHQgPSBoZWlnaHQsXG4gICAgICAgIGhtYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luJ10sXG4gICAgICAgIHNoYWRvdyA9IHByb3BbJ2NoYXJ0LnNoYWRvdyddLFxuICAgICAgICBzaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLFxuICAgICAgICBzaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSxcbiAgICAgICAgc2hhZG93T2Zmc2V0WCA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sXG4gICAgICAgIHNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLFxuICAgICAgICBzdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZWNvbG9yJ10sXG4gICAgICAgIGNvbG9ycyA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddLFxuICAgICAgICBzZXF1ZW50aWFsQ29sb3JJbmRleCA9IDA7XG4gICAgdmFyIGhlaWdodDtmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChSRy5hcnJheVN1bSh0aGlzLmRhdGFbaV0pIDwgMCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKFJHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkgKyB0aGlzLnNjYWxlMi5taW4pIC8gKHRoaXMuc2NhbGUyLm1heCAtIHRoaXMuc2NhbGUyLm1pbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKFJHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkgLSB0aGlzLnNjYWxlMi5taW4pIC8gKHRoaXMuc2NhbGUyLm1heCAtIHRoaXMuc2NhbGUyLm1pbik7XG4gICAgICB9XG4gICAgICBoZWlnaHQgKj0gbWEuYWJzKHRoaXMuZ2V0WUNvb3JkKHRoaXMuc2NhbGUyLm1heCkgLSB0aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlMi5taW4pKTt2YXIgeCA9IGkgKiB3aWR0aCArIHRoaXMuZ3V0dGVyTGVmdDt2YXIgeSA9IHhheGlzcG9zID09ICdjZW50ZXInID8gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiArIHRoaXMuZ3V0dGVyVG9wIC0gaGVpZ2h0IDogY2EuaGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b207aWYgKHhheGlzcG9zID09ICd0b3AnKSB7XG4gICAgICAgIHkgPSB0aGlzLmd1dHRlclRvcCArIG1hLmFicyhoZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSArPSBoZWlnaHQ7aGVpZ2h0ID0gbWEuYWJzKGhlaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIGNvLnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7Y28uc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7Y28uc2hhZG93T2Zmc2V0WCA9IHNoYWRvd09mZnNldFg7Y28uc2hhZG93T2Zmc2V0WSA9IHNoYWRvd09mZnNldFk7XG4gICAgICB9XG4gICAgICBjby5iZWdpblBhdGgoKTtpZiAodHlwZW9mIHRoaXMuZGF0YVtpXSA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoeGF4aXNwb3MgPT09ICdib3R0b20nICYmIHByb3BbJ2NoYXJ0LnltaW4nXSA8IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID49IDApIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG1hLmFicyh0aGlzLmdldFlDb29yZCgwKSAtIHRoaXMuZ2V0WUNvb3JkKHRoaXMuZGF0YVtpXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQoMCk7aGVpZ2h0ID0gbWEuYWJzKHRoaXMuZ2V0WUNvb3JkKDApIC0gdGhpcy5nZXRZQ29vcmQodGhpcy5kYXRhW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IHdpZHRoIC0gMiAqIGhtYXJnaW47aWYgKGJhcldpZHRoIDwgMCkge1xuICAgICAgICAgIGFsZXJ0KCdbUkdSQVBIXSBXYXJuaW5nOiB5b3UgaGF2ZSBhIG5lZ2F0aXZlIGJhciB3aWR0aC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHRoZSBjaGFydC5obWFyZ2luIGJlaW5nIHRvbyBoaWdoIG9yIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIG5vdCBiZWluZyBzdWZmaWNpZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7Y28uZmlsbFN0eWxlID0gY29sb3JzWzBdO2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gY29sb3JzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYW50ID09ICdza2V0Y2gnKSB7XG4gICAgICAgICAgY28ubGluZUNhcCA9ICdyb3VuZCc7dmFyIHNrZXRjaE9mZnNldCA9IDM7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcnNbMF07aWYgKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10pIHtcbiAgICAgICAgICAgIGNvLnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5tb3ZlVG8oeCArIGhtYXJnaW4gKyAyLCB5ICsgaGVpZ2h0IC0gMik7Y28ubGluZVRvKHggKyBobWFyZ2luIC0gMSwgeSAtIDQpO2NvLm1vdmVUbyh4ICsgaG1hcmdpbiAtIDMsIHkgKyAtMiArICh0aGlzLmRhdGFbaV0gPCAwID8gaGVpZ2h0IDogMCkpO2NvLmJlemllckN1cnZlVG8oeCArIChobWFyZ2luICsgd2lkdGgpICogMC4zMywgeSArIDE1ICsgKHRoaXMuZGF0YVtpXSA8IDAgPyBoZWlnaHQgLSAxMCA6IDApLCB4ICsgKGhtYXJnaW4gKyB3aWR0aCkgKiAwLjY2LCB5ICsgNSArICh0aGlzLmRhdGFbaV0gPCAwID8gaGVpZ2h0IC0gMTAgOiAwKSwgeCArIGhtYXJnaW4gKyB3aWR0aCArIC0xLCB5ICsgMCArICh0aGlzLmRhdGFbaV0gPCAwID8gaGVpZ2h0IDogMCkpO2NvLm1vdmVUbyh4ICsgaG1hcmdpbiArIHdpZHRoIC0gNSwgeSAtIDUpO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiArIHdpZHRoIC0gMywgeSArIGhlaWdodCAtIDMpO2lmIChwcm9wWydjaGFydC52YXJpYW50LnNrZXRjaC52ZXJ0aWNhbHMnXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDAuMjsgciA8PSAwLjg7IHIgKz0gMC4yKSB7XG4gICAgICAgICAgICAgIGNvLm1vdmVUbyh4ICsgaG1hcmdpbiArIHdpZHRoICsgKHIgPiAwLjQgPyAtMSA6IDMpIC0gciAqIHdpZHRoLCB5IC0gMSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgd2lkdGggLSAociA+IDAuNCA/IDEgOiAtMSkgLSByICogd2lkdGgsIHkgKyBoZWlnaHQgKyAociA9PSAwLjIgPyAxIDogLTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY28uc3Ryb2tlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFyaWFudCA9PSAnYmFyJyB8fCB2YXJpYW50ID09ICczZCcgfHwgdmFyaWFudCA9PSAnZ2xhc3MnIHx8IHZhcmlhbnQgPT0gJ2JldmVsJykge1xuICAgICAgICAgIGlmIChSR3JhcGguSVNPTEQgJiYgc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLkRyYXdJRVNoYWRvdyhbeCArIGhtYXJnaW4sIHksIGJhcldpZHRoLCBoZWlnaHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhcmlhbnQgPT0gJ2dsYXNzJykge1xuICAgICAgICAgICAgUkdyYXBoLmZpbGxlZEN1cnZ5UmVjdChjbywgeCArIGhtYXJnaW4sIHksIGJhcldpZHRoLCBoZWlnaHQsIDMsIHRoaXMuZGF0YVtpXSA+IDAsIHRoaXMuZGF0YVtpXSA+IDAsIHRoaXMuZGF0YVtpXSA8IDAsIHRoaXMuZGF0YVtpXSA8IDApO1JHcmFwaC5zdHJva2VkQ3VydnlSZWN0KGNvLCB4ICsgaG1hcmdpbiwgeSwgYmFyV2lkdGgsIGhlaWdodCwgMywgdGhpcy5kYXRhW2ldID4gMCwgdGhpcy5kYXRhW2ldID4gMCwgdGhpcy5kYXRhW2ldIDwgMCwgdGhpcy5kYXRhW2ldIDwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCArIGhtYXJnaW4sIHksIGJhcldpZHRoLCBoZWlnaHQpO2NvLmZpbGwoKTtSRy5Ob1NoYWRvdyh0aGlzKTtjby5iZWdpblBhdGgoKTtjby5yZWN0KHggKyBobWFyZ2luLCB5LCBiYXJXaWR0aCwgaGVpZ2h0KTtjby5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhcmlhbnQgPT0gJzNkJykge1xuICAgICAgICAgICAgdmFyIHByZXZTdHJva2VTdHlsZSA9IGNvLnN0cm9rZVN0eWxlO3ZhciBwcmV2RmlsbFN0eWxlID0gY28uZmlsbFN0eWxlO2lmICh0aGlzLmRhdGFbaV0gPj0gMCkge1xuICAgICAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCArIGhtYXJnaW4sIHkpO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddICsgYmFyV2lkdGgsIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiArIGJhcldpZHRoLCB5KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCArIGhtYXJnaW4gKyBiYXJXaWR0aCwgeSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgYmFyV2lkdGggKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHRoaXMuZGF0YVtpXSA8IDAgJiYgeGF4aXNwb3MgPT09ICdib3R0b20nID8gdGhpcy5nZXRZQ29vcmQoMCkgOiB0aGlzLmRhdGFbaV0gPCAwICYmIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gPCB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZmdyYXBoYXJlYSA/IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmZ3JhcGhhcmVhIDogeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgYmFyV2lkdGggKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHRoaXMuZGF0YVtpXSA8IDAgJiYgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSArIGhlaWdodCA8IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5nZXRZQ29vcmQoMCkgPyB0aGlzLmdldFlDb29yZCh0aGlzLmRhdGFbaV0pIC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddIDogdGhpcy5kYXRhW2ldID4gMCA/IHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gKyBoZWlnaHQgOiBtYS5taW4oeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSArIGhlaWdodCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8oeCArIGhtYXJnaW4gKyBiYXJXaWR0aCwgeSArIGhlaWdodCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2lmICh0aGlzLmRhdGFbaV0gPiAwKSB7XG4gICAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO2NvLm1vdmVUbyh4ICsgaG1hcmdpbiwgeSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLCB5IC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oeCArIGhtYXJnaW4gKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10gKyBiYXJXaWR0aCwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgYmFyV2lkdGgsIHkpO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiwgeSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC40KSc7Y28ubW92ZVRvKHggKyBobWFyZ2luICsgYmFyV2lkdGgsIHkpO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiArIGJhcldpZHRoICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLCB0aGlzLmRhdGFbaV0gPCAwICYmIHhheGlzcG9zID09PSAnYm90dG9tJyA/IHRoaXMuZ2V0WUNvb3JkKDApIDogdGhpcy5kYXRhW2ldIDwgMCAmJiB5IC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddIDwgdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZncmFwaGFyZWEgPyB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZmdyYXBoYXJlYSA6IHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyh4ICsgaG1hcmdpbiArIGJhcldpZHRoICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLCB0aGlzLmRhdGFbaV0gPCAwICYmIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gKyBoZWlnaHQgPCB0aGlzLmdldFlDb29yZCgwKSA/IHRoaXMuZ2V0WUNvb3JkKDApIDogdGhpcy5kYXRhW2ldID4gMCA/IHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gKyBoZWlnaHQgOiBtYS5taW4oeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSArIGhlaWdodCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8oeCArIGhtYXJnaW4gKyBiYXJXaWR0aCwgeSArIGhlaWdodCk7Y28ubGluZVRvKHggKyBobWFyZ2luICsgYmFyV2lkdGgsIHkpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZSA9IHByZXZTdHJva2VTdHlsZTtjby5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFyaWFudCA9PSAnZ2xhc3MnKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KHggKyBobWFyZ2luLCB5LCB4ICsgaG1hcmdpbiArIGJhcldpZHRoIC8gMiwgeSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgJ3JnYmEoMjU1LDI1NSwyNTUsMC45KScpO2dyYWQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBncmFkO2NvLmZpbGxSZWN0KHggKyBobWFyZ2luICsgMiwgeSArICh0aGlzLmRhdGFbaV0gPiAwID8gMiA6IDApLCBiYXJXaWR0aCAvIDIgLSAyLCBoZWlnaHQgLSAyKTtjby5maWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhcmlhbnQgPT0gJ2RvdCcpIHtcbiAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCArIHdpZHRoIC8gMiwgeSk7Y28ubGluZVRvKHggKyB3aWR0aCAvIDIsIHkgKyBoZWlnaHQpO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHRoaXMucHJvcGVydGllc1snY2hhcnQuY29sb3JzJ11baV07Y28uYXJjKHggKyB3aWR0aCAvIDIsIHkgKyAodGhpcy5kYXRhW2ldID4gMCA/IDAgOiBoZWlnaHQpLCAyLCAwLCA2LjI4LCAwKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVswXTtpZiAocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSkge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gY29sb3JzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxlcnQoJ1tCQVJdIFdhcm5pbmchIFVua25vd24gY2hhcnQudmFyaWFudDogJyArIHZhcmlhbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29vcmRzLnB1c2goW3ggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHRdKTtpZiAodHlwZW9mIHRoaXMuY29vcmRzMltpXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29vcmRzMltpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29vcmRzMltpXS5wdXNoKFt4ICsgaG1hcmdpbiwgeSwgd2lkdGggLSAyICogaG1hcmdpbiwgaGVpZ2h0XSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVtpXSAmJiBfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGUyLm1pbikge1xuICAgICAgICAgIGFsZXJ0KFwiW0VSUk9SXSBTdGFja2VkIEJhciBjaGFydHMgd2l0aCBhIFkgbWluIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IHdpZHRoIC0gMiAqIGhtYXJnaW47dmFyIHJlZHJhd0Nvb3JkcyA9IFtdO3ZhciBzdGFydFkgPSAwO3ZhciBkYXRhc2V0ID0gdGhpcy5kYXRhW2ldO2lmIChiYXJXaWR0aCA8IDApIHtcbiAgICAgICAgICBhbGVydCgnW1JHUkFQSF0gV2FybmluZzogeW91IGhhdmUgYSBuZWdhdGl2ZSBiYXIgd2lkdGguIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB0aGUgY2hhcnQuaG1hcmdpbiBiZWluZyB0b28gaGlnaCBvciB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyBub3QgYmVpbmcgc3VmZmljaWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZGF0YXNldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmICh4YXhpc3BvcyA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYWxlcnQoXCJbQkFSXSBJdCdzIHBvaW50bGVzcyBoYXZpbmcgdGhlIFggYXhpcyBwb3NpdGlvbiBhdCB0aGUgY2VudGVyIG9uIGEgc3RhY2tlZCBiYXIgY2hhcnQuXCIpO3JldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXVtqXSA8IDApIHtcbiAgICAgICAgICAgIGFsZXJ0KCdbQkFSXSBOZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCBwZXJtaXR0ZWQgd2l0aCBhIHN0YWNrZWQgYmFyIGNoYXJ0LiBUcnkgYSBncm91cGVkIG9uZSBpbnN0ZWFkLicpO3JldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY28uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICBjby5maWxsU3R5bGUgPSBjb2xvcnNbal07aWYgKHByb3BbJ2NoYXJ0LmNvbG9ycy5yZXZlcnNlJ10pIHtcbiAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IGNvbG9yc1t0aGlzLmRhdGFbaV0ubGVuZ3RoIC0gaiAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSAmJiBjb2xvcnNbc2VxdWVudGlhbENvbG9ySW5kZXhdKSB7XG4gICAgICAgICAgICBjby5maWxsU3R5bGUgPSBjb2xvcnNbc2VxdWVudGlhbENvbG9ySW5kZXgrK107XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgICAgICBjby5maWxsU3R5bGUgPSBjb2xvcnNbc2VxdWVudGlhbENvbG9ySW5kZXggLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFzZXRbal0gLyB0aGlzLnNjYWxlMi5tYXggKiAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSk7aWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBoZWlnaHQgLz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gUkdyYXBoLmFycmF5X3N1bShkYXRhc2V0KSAvIHRoaXMuc2NhbGUyLm1heCAqIChjYS5oZWlnaHQgLSBobWFyZ2luIC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSk7dGhpcy5jb29yZHMucHVzaChbeCArIGhtYXJnaW4sIHksIHdpZHRoIC0gMiAqIGhtYXJnaW4sIGhlaWdodF0pO2lmICh0eXBlb2YgdGhpcy5jb29yZHMyW2ldID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNvb3JkczJbaV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb29yZHMyW2ldLnB1c2goW3ggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHRdKTtpZiAoUkdyYXBoLklTT0xEICYmIHNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5EcmF3SUVTaGFkb3coW3ggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHQgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBjby5zdHJva2VSZWN0KHggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHQpO2NvLmZpbGxSZWN0KHggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0geTt2YXIgc3RhcnRYID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgcmVkcmF3Q29vcmRzLnB1c2goW3ggKyBobWFyZ2luLCB5LCB3aWR0aCAtIDIgKiBobWFyZ2luLCBoZWlnaHQsIGNvLmZpbGxTdHlsZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFyaWFudCA9PSAnM2QnKSB7XG4gICAgICAgICAgICB2YXIgcHJldkZpbGxTdHlsZSA9IGNvLmZpbGxTdHlsZTt2YXIgcHJldlN0cm9rZVN0eWxlID0gY28uc3Ryb2tlU3R5bGU7aWYgKGogPT0gMCkge1xuICAgICAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oc3RhcnRYICsgaG1hcmdpbiwgeSk7Y28ubGluZVRvKHN0YXJ0WCArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSArIGhtYXJnaW4sIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFggKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10gKyBiYXJXaWR0aCArIGhtYXJnaW4sIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFggKyBiYXJXaWR0aCArIGhtYXJnaW4sIHkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzdGFydFggKyBiYXJXaWR0aCArIGhtYXJnaW4sIHkpO2NvLmxpbmVUbyhzdGFydFggKyBiYXJXaWR0aCArIGhtYXJnaW4gKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFggKyBiYXJXaWR0aCArIGhtYXJnaW4gKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gKyBoZWlnaHQpO2NvLmxpbmVUbyhzdGFydFggKyBiYXJXaWR0aCArIGhtYXJnaW4sIHkgKyBoZWlnaHQpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzdGFydFggKyBobWFyZ2luLCB5KTtjby5saW5lVG8oc3RhcnRYICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddICsgaG1hcmdpbiwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSArIGJhcldpZHRoICsgaG1hcmdpbiwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIGJhcldpZHRoICsgaG1hcmdpbiwgeSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC40KSc7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCArIGJhcldpZHRoICsgaG1hcmdpbiwgeSk7Y28ubGluZVRvKHN0YXJ0WCArIGJhcldpZHRoICsgaG1hcmdpbiArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIGJhcldpZHRoICsgaG1hcmdpbiArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSwgeSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSArIGhlaWdodCk7Y28ubGluZVRvKHN0YXJ0WCArIGJhcldpZHRoICsgaG1hcmdpbiwgeSArIGhlaWdodCk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO2NvLnN0cm9rZVN0eWxlID0gcHJldlN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZSA9IHByZXZGaWxsU3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgICBSR3JhcGguTm9TaGFkb3codGhpcyk7Zm9yIChrID0gMDsgayA8IHJlZHJhd0Nvb3Jkcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgY28uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtjby5maWxsU3R5bGUgPSByZWRyYXdDb29yZHNba11bNF07Y28uc3Ryb2tlUmVjdChyZWRyYXdDb29yZHNba11bMF0sIHJlZHJhd0Nvb3Jkc1trXVsxXSwgcmVkcmF3Q29vcmRzW2tdWzJdLCByZWRyYXdDb29yZHNba11bM10pO2NvLmZpbGxSZWN0KHJlZHJhd0Nvb3Jkc1trXVswXSwgcmVkcmF3Q29vcmRzW2tdWzFdLCByZWRyYXdDb29yZHNba11bMl0sIHJlZHJhd0Nvb3Jkc1trXVszXSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWRyYXdDb29yZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbaV0gJiYgX3R5cGVvZih0aGlzLmRhdGFbaV0pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ10gPT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgIHZhciByZWRyYXdDb29yZHMgPSBbXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtmb3IgKGogPSAwOyBqIDwgdGhpcy5kYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgY28uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtjby5maWxsU3R5bGUgPSBjb2xvcnNbal07aWYgKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10gJiYgY29sb3JzW3NlcXVlbnRpYWxDb2xvckluZGV4XSkge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gY29sb3JzW3NlcXVlbnRpYWxDb2xvckluZGV4KytdO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuY29sb3JzLnNlcXVlbnRpYWwnXSkge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gY29sb3JzW3NlcXVlbnRpYWxDb2xvckluZGV4IC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRpdmlkdWFsQmFyV2lkdGggPSAod2lkdGggLSAyICogaG1hcmdpbikgLyB0aGlzLmRhdGFbaV0ubGVuZ3RoO3ZhciBoZWlnaHQgPSAodGhpcy5kYXRhW2ldW2pdICsgKHRoaXMuZGF0YVtpXVtqXSA8IDAgPyB0aGlzLnNjYWxlMi5taW4gOiAtMSAqIHRoaXMuc2NhbGUyLm1pbikpIC8gKHRoaXMuc2NhbGUyLm1heCAtIHRoaXMuc2NhbGUyLm1pbikgKiAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSk7dmFyIGdyb3VwZWRNYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luLmdyb3VwZWQnXTt2YXIgc3RhcnRYID0geCArIGhtYXJnaW4gKyBqICogaW5kaXZpZHVhbEJhcldpZHRoO2lmIChpbmRpdmlkdWFsQmFyV2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhbGVydCgnW1JHUkFQSF0gV2FybmluZzogeW91IGhhdmUgYSBuZWdhdGl2ZSBiYXIgd2lkdGguIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB0aGUgY2hhcnQuaG1hcmdpbiBiZWluZyB0b28gaGlnaCBvciB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyBub3QgYmVpbmcgc3VmZmljaWVudC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBoZWlnaHQgLz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHhheGlzcG9zID09ICd0b3AnKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gdGhpcy5ndXR0ZXJUb3A7dmFyIGhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh4YXhpc3BvcyA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyIC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gdGhpcy5nZXRZQ29vcmQoMCk7dmFyIGhlaWdodCA9IG1hLmFicyhtYS5hYnModGhpcy5nZXRZQ29vcmQodGhpcy5kYXRhW2ldW2pdKSkgLSB0aGlzLmdldFlDb29yZCgwKSk7aWYgKHRoaXMuZGF0YVtpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0YXJ0WSAtPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvLnN0cm9rZVJlY3Qoc3RhcnRYICsgZ3JvdXBlZE1hcmdpbiwgc3RhcnRZLCBpbmRpdmlkdWFsQmFyV2lkdGggLSAyICogZ3JvdXBlZE1hcmdpbiwgaGVpZ2h0KTtjby5maWxsUmVjdChzdGFydFggKyBncm91cGVkTWFyZ2luLCBzdGFydFksIGluZGl2aWR1YWxCYXJXaWR0aCAtIDIgKiBncm91cGVkTWFyZ2luLCBoZWlnaHQpO3kgKz0gaGVpZ2h0O2lmICh2YXJpYW50ID09ICczZCcpIHtcbiAgICAgICAgICAgIHZhciBwcmV2RmlsbFN0eWxlID0gY28uZmlsbFN0eWxlO3ZhciBwcmV2U3Ryb2tlU3R5bGUgPSBjby5zdHJva2VTdHlsZTt2YXIgaG1hcmdpbkdyb3VwZWQgPSBwcm9wWydjaGFydC5obWFyZ2luLmdyb3VwZWQnXTtpZiAodGhpcy5kYXRhW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHN0YXJ0WCArIGhtYXJnaW5Hcm91cGVkLCBzdGFydFkpO2NvLmxpbmVUbyhzdGFydFggKyBobWFyZ2luR3JvdXBlZCArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSwgc3RhcnRZIC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddICsgaW5kaXZpZHVhbEJhcldpZHRoIC0gaG1hcmdpbkdyb3VwZWQsIHN0YXJ0WSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIGluZGl2aWR1YWxCYXJXaWR0aCAtIGhtYXJnaW5Hcm91cGVkLCBzdGFydFkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzdGFydFggKyBpbmRpdmlkdWFsQmFyV2lkdGggLSBobWFyZ2luR3JvdXBlZCAtIDEsIHN0YXJ0WSk7Y28ubGluZVRvKHN0YXJ0WCArIGluZGl2aWR1YWxCYXJXaWR0aCAtIGhtYXJnaW5Hcm91cGVkICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLCB0aGlzLmRhdGFbaV1bal0gPCAwID8gdGhpcy5nZXRZQ29vcmQoMCkgKyBtYS5hYnMoaGVpZ2h0KSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSA6IHRoaXMuZ2V0WUNvb3JkKDApIC0gaGVpZ2h0IC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYICsgaW5kaXZpZHVhbEJhcldpZHRoIC0gaG1hcmdpbkdyb3VwZWQgKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHRoaXMuZGF0YVtpXVtqXSA8IDAgJiYgc3RhcnRZICsgaGVpZ2h0IC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddIDwgdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZncmFwaGFyZWEgPyB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZmdyYXBoYXJlYSA6IHN0YXJ0WSArIGhlaWdodCAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIGluZGl2aWR1YWxCYXJXaWR0aCAtIGhtYXJnaW5Hcm91cGVkIC0gMSwgc3RhcnRZICsgaGVpZ2h0KTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7aWYgKHRoaXMuZGF0YVtpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhzdGFydFggKyBobWFyZ2luR3JvdXBlZCwgc3RhcnRZKTtjby5saW5lVG8oc3RhcnRYICsgaG1hcmdpbkdyb3VwZWQgKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIHN0YXJ0WSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7Y28ubGluZVRvKHN0YXJ0WCArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSArIGluZGl2aWR1YWxCYXJXaWR0aCAtIGhtYXJnaW5Hcm91cGVkLCBzdGFydFkgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFggKyBpbmRpdmlkdWFsQmFyV2lkdGggLSBobWFyZ2luR3JvdXBlZCwgc3RhcnRZKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjby5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjQpJztjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oc3RhcnRYICsgaW5kaXZpZHVhbEJhcldpZHRoIC0gaG1hcmdpbkdyb3VwZWQsIHN0YXJ0WSk7Y28ubGluZVRvKHN0YXJ0WCArIGluZGl2aWR1YWxCYXJXaWR0aCArIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSAtIGhtYXJnaW5Hcm91cGVkLCB0aGlzLmRhdGFbaV1bal0gPCAwID8gdGhpcy5nZXRZQ29vcmQoMCkgKyBtYS5hYnMoaGVpZ2h0KSAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSA6IHRoaXMuZ2V0WUNvb3JkKDApIC0gaGVpZ2h0IC0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtjby5saW5lVG8oc3RhcnRYICsgaW5kaXZpZHVhbEJhcldpZHRoICsgcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddIC0gaG1hcmdpbkdyb3VwZWQsIHRoaXMuZGF0YVtpXVtqXSA8IDAgJiYgc3RhcnRZICsgaGVpZ2h0IC0gNSA8IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmZ3JhcGhhcmVhID8gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZncmFwaGFyZWEgOiBzdGFydFkgKyBoZWlnaHQgLSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10pO2NvLmxpbmVUbyhzdGFydFggKyBpbmRpdmlkdWFsQmFyV2lkdGggLSBobWFyZ2luR3JvdXBlZCwgc3RhcnRZICsgaGVpZ2h0KTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcmV2U3Ryb2tlU3R5bGU7Y28uZmlsbFN0eWxlID0gcHJldkZpbGxTdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7c3RhcnRZID0gc3RhcnRZIC0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvb3Jkcy5wdXNoKFtzdGFydFggKyBncm91cGVkTWFyZ2luLCBzdGFydFksIGluZGl2aWR1YWxCYXJXaWR0aCAtIDIgKiBncm91cGVkTWFyZ2luLCBoZWlnaHRdKTtpZiAodHlwZW9mIHRoaXMuY29vcmRzMltpXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5jb29yZHMyW2ldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY29vcmRzMltpXS5wdXNoKFtzdGFydFggKyBncm91cGVkTWFyZ2luLCBzdGFydFksIGluZGl2aWR1YWxCYXJXaWR0aCAtIDIgKiBncm91cGVkTWFyZ2luLCBoZWlnaHRdKTtpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgICAgIHJlZHJhd0Nvb3Jkcy5wdXNoKFtzdGFydFggKyBncm91cGVkTWFyZ2luLCBzdGFydFksIGluZGl2aWR1YWxCYXJXaWR0aCAtIDIgKiBncm91cGVkTWFyZ2luLCBoZWlnaHQsIGNvLmZpbGxTdHlsZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVkcmF3Q29vcmRzLmxlbmd0aCkge1xuICAgICAgICAgIFJHcmFwaC5Ob1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5iZWdpblBhdGgoKTtmb3IgKHZhciBqID0gMDsgaiA8IHJlZHJhd0Nvb3Jkcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcmVkcmF3Q29vcmRzW2pdWzRdO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXTtjby5maWxsUmVjdChyZWRyYXdDb29yZHNbal1bMF0sIHJlZHJhd0Nvb3Jkc1tqXVsxXSwgcmVkcmF3Q29vcmRzW2pdWzJdLCByZWRyYXdDb29yZHNbal1bM10pO2NvLnN0cm9rZVJlY3QocmVkcmF3Q29vcmRzW2pdWzBdLCByZWRyYXdDb29yZHNbal1bMV0sIHJlZHJhd0Nvb3Jkc1tqXVsyXSwgcmVkcmF3Q29vcmRzW2pdWzNdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY28uZmlsbCgpO2NvLnN0cm9rZSgpO3JlZHJhd0Nvb3JkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvb3Jkcy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGNvLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcpIHtcbiAgICAgIFJHLmRyYXczRFlBeGlzKHRoaXMpO1xuICAgIH1cbiAgICBSR3JhcGgubm9TaGFkb3codGhpcyk7XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0ID0gY287dmFyIHRleHRfYW5nbGUgPSBwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ10sXG4gICAgICAgIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICBsYWJlbHMgPSBwcm9wWydjaGFydC5sYWJlbHMnXTtcbiAgICBpZiAocHJvcFsnY2hhcnQueWxhYmVscyddKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAndG9wJykgdGhpcy5EcmF3bGFiZWxzX3RvcCgpO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB0aGlzLkRyYXdsYWJlbHNfY2VudGVyKCk7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2JvdHRvbScpIHRoaXMuRHJhd2xhYmVsc19ib3R0b20oKTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgbGFiZWxzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihsYWJlbHMpKSA9PSAnb2JqZWN0JyAmJiBsYWJlbHMpIHtcbiAgICAgIHZhciB5T2Zmc2V0ID0gTnVtYmVyKHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J10pLFxuICAgICAgICAgIHhPZmZzZXQgPSBOdW1iZXIocHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSksXG4gICAgICAgICAgYm9sZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ107XG4gICAgICBpZiAocHJvcFsnY2hhcnQudGV4dC5hbmdsZSddICE9IDApIHtcbiAgICAgICAgdmFyIHZhbGlnbiA9ICdjZW50ZXInO3ZhciBoYWxpZ24gPSAncmlnaHQnO3ZhciBhbmdsZSA9IDAgLSBwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsaWduID0gJ3RvcCc7dmFyIGhhbGlnbiA9ICdjZW50ZXInO3ZhciBhbmdsZSA9IDA7XG4gICAgICB9XG4gICAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3InXSB8fCBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGJhcldpZHRoID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIHRoaXMuZ3V0dGVyTGVmdCkgLyBsYWJlbHMubGVuZ3RoO3hUaWNrR2FwID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIHRoaXMuZ3V0dGVyTGVmdCkgLyBsYWJlbHMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107Zm9yICh4ID0gdGhpcy5ndXR0ZXJMZWZ0ICsgeFRpY2tHYXAgLyAyOyB4IDw9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodDsgeCArPSB4VGlja0dhcCkge1xuICAgICAgICBSRy50ZXh0Mih0aGlzLCBfZGVmaW5lUHJvcGVydHkoeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHggKyB4T2Zmc2V0LCAneSc6IHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcgPyB0aGlzLmd1dHRlclRvcCArIHlPZmZzZXQgLSA1IDogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyB5T2Zmc2V0ICsgMywgJ2JvbGQnOiBib2xkLCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaSsrXSksICd2YWxpZ24nOiBwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnID8gJ2JvdHRvbScgOiB2YWxpZ24sICdoYWxpZ24nOiBoYWxpZ24sICd0YWcnOiAnbGFiZWwnLCAnbWFya2VyJzogZmFsc2UsICdhbmdsZSc6IGFuZ2xlIH0sICd0YWcnLCAnbGFiZWxzJykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRyYXdBYm92ZUxhYmVscygpO1xuICB9O3RoaXMuZHJhd2xhYmVsc190b3AgPSB0aGlzLkRyYXdsYWJlbHNfdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYSA9IHRoaXMuY2FudmFzO3ZhciBjbyA9IHRoaXMuY29udGV4dDt2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcztjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNvO3ZhciB0ZXh0X3NpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGFsaWduID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIG51bVlMYWJlbHMgPSBwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J107dmFyIHltaW4gPSBwcm9wWydjaGFydC55bWluJ107dmFyIG9mZnNldHggPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXTt2YXIgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddO2lmIChwcm9wWydjaGFydC55bGFiZWxzLmluc2lkZSddID09IHRydWUpIHtcbiAgICAgICAgdmFyIHhwb3MgPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCArIDUgOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSA1O3ZhciBhbGlnbiA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0Jzt2YXIgYm94ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhwb3MgPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCAtIDUgOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyA1O3ZhciBib3hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKF90eXBlb2YocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKSA9PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IFJHcmFwaC5hcnJheV9yZXZlcnNlKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk7dmFyIGdyYXBoYXJlYSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMuZ3V0dGVyVG9wICsgZ3JhcGhhcmVhICogKGkgLyBsYWJlbHMubGVuZ3RoKSArIGdyYXBoYXJlYSAvIGxhYmVscy5sZW5ndGg7UkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHkgKyBvZmZzZXR5LCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaV0pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvcmRlcmVkJzogYm94ZWQsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbHMgPSB0aGlzLnNjYWxlMi5sYWJlbHM7Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgUkdyYXBoLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB0aGlzLmd1dHRlclRvcCArIHRoaXMuZ3JhcGhhcmVhIC8gbGFiZWxzLmxlbmd0aCAqIChpICsgMSkgKyBvZmZzZXR5LCAndGV4dCc6ICctJyArIGxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3JkZXJlZCc6IGJveGVkLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC55bWluJ10gIT0gMCB8fCBwcm9wWydjaGFydC5ub3hheGlzJ10gfHwgcHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pIHtcbiAgICAgICAgUkdyYXBoLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB0aGlzLmd1dHRlclRvcCArIG9mZnNldHksICd0ZXh0JzogKHRoaXMuc2NhbGUyLm1pbiAhPSAwID8gJy0nIDogJycpICsgUkdyYXBoLm51bWJlckZvcm1hdCh0aGlzLCB0aGlzLnNjYWxlMi5taW4udG9GaXhlZCh0aGlzLnNjYWxlMi5taW4gPT09IDAgPyAwIDogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm9yZGVyZWQnOiBib3hlZCwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLmZpbGwoKTtcbiAgfTt0aGlzLmRyYXdsYWJlbHNfY2VudGVyID0gdGhpcy5EcmF3bGFiZWxzX2NlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2EgPSB0aGlzLmNhbnZhczt2YXIgY28gPSB0aGlzLmNvbnRleHQ7dmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7dmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgbnVtWUxhYmVscyA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIHZhciB0ZXh0X3NpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGNvbnRleHQgPSBjbzt2YXIgYWxpZ24gPSAnJzt2YXIgeHBvcyA9IDA7dmFyIGJveGVkID0gZmFsc2U7dmFyIHltaW4gPSBwcm9wWydjaGFydC55bWluJ107dmFyIG9mZnNldHggPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXTt2YXIgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5zdHJva2VTdHlsZSA9ICdibGFjayc7aWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10gPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgeHBvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0ICsgNSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIDU7dmFyIGFsaWduID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO3ZhciBib3hlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeHBvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0IC0gNSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDU7dmFyIGFsaWduID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO3ZhciBib3hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKF90eXBlb2YocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKSA9PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXTt2YXIgZ3JhcGhhcmVhID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbTtmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyBncmFwaGFyZWEgLyAyIC8gKGxhYmVscy5sZW5ndGggLSAxKSAqIGk7UkdyYXBoLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBTdHJpbmcobGFiZWxzW2ldKSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3JkZXJlZCc6IGJveGVkLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLmd1dHRlclRvcCArIGdyYXBoYXJlYSAqIChpIC8gKChsYWJlbHMubGVuZ3RoIC0gMSkgKiAyKSkgKyBncmFwaGFyZWEgLyAyO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBTdHJpbmcobGFiZWxzW2xhYmVscy5sZW5ndGggLSBpIC0gMV0pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvcmRlcmVkJzogYm94ZWQsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZncmFwaGFyZWEgLSB0aGlzLmhhbGZncmFwaGFyZWEgLyBudW1ZTGFiZWxzICogKGkgKyAxKTt2YXIgdGV4dCA9IHRoaXMuc2NhbGUyLmxhYmVsc1tpXTtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeHBvcyArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd0ZXh0JzogdGV4dCwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3JkZXJlZCc6IGJveGVkLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZmdyYXBoYXJlYSAvIG51bVlMYWJlbHMgKiAoaSArIDEpICsgdGhpcy5oYWxmZ3JhcGhhcmVhO3ZhciB0ZXh0ID0gdGhpcy5zY2FsZTIubGFiZWxzW2ldO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiAnLScgKyB0ZXh0LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvcmRlcmVkJzogYm94ZWQsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2NhbGUyLm1pbiAhPSAwIHx8IHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKSB7XG4gICAgICAgIHZhciBfUkckVGV4dDtcblxuICAgICAgICBSRy5UZXh0Mih0aGlzLCAoX1JHJFRleHQgPSB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeHBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZncmFwaGFyZWEgKyBvZmZzZXR5LCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgdGhpcy5zY2FsZTIubWluLnRvRml4ZWQodGhpcy5zY2FsZTIubWluID09PSAwID8gMCA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAndmFsaWduJzogJ2NlbnRlcicgfSwgX2RlZmluZVByb3BlcnR5KF9SRyRUZXh0LCAndmFsaWduJywgJ2NlbnRlcicpLCBfZGVmaW5lUHJvcGVydHkoX1JHJFRleHQsICdoYWxpZ24nLCBhbGlnbiksIF9kZWZpbmVQcm9wZXJ0eShfUkckVGV4dCwgJ2JvcmRlcmVkJywgYm94ZWQpLCBfZGVmaW5lUHJvcGVydHkoX1JHJFRleHQsICd0YWcnLCAnc2NhbGUnKSwgX1JHJFRleHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3bGFiZWxzX2JvdHRvbSA9IHRoaXMuRHJhd2xhYmVsc19ib3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSxcbiAgICAgICAgdW5pdHNfcG9zdCA9IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxcbiAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgYWxpZ24gPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgbnVtWUxhYmVscyA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSxcbiAgICAgICAgeW1pbiA9IHByb3BbJ2NoYXJ0LnltaW4nXSxcbiAgICAgICAgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eCddLFxuICAgICAgICBvZmZzZXR5ID0gcHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR5J107XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2NvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztpZiAocHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXSA9PSB0cnVlKSB7XG4gICAgICB2YXIgeHBvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0ICsgNSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIDU7dmFyIGFsaWduID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO3ZhciBib3hlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4cG9zID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSA1IDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgNTt2YXIgYm94ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSAmJiBfdHlwZW9mKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsYWJlbHMgPSBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ107dmFyIGdyYXBoYXJlYSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmd1dHRlclRvcCArIGdyYXBoYXJlYSAqIChpIC8gKGxhYmVscy5sZW5ndGggLSAxKSk7UkdyYXBoLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBsYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm9yZGVyZWQnOiBib3hlZCwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBndXR0ZXJUb3AgPSB0aGlzLmd1dHRlclRvcDt2YXIgaGFsZlRleHRIZWlnaHQgPSB0aGlzLmhhbGZUZXh0SGVpZ2h0O3ZhciBzY2FsZSA9IHRoaXMuc2NhbGU7Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1ZTGFiZWxzOyArK2kpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5zY2FsZTIubGFiZWxzW2ldO1JHcmFwaC5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeHBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmdyYXBoYXJlYSAtIHRoaXMuZ3JhcGhhcmVhIC8gbnVtWUxhYmVscyAqIChpICsgMSkgKyBvZmZzZXR5LCAndGV4dCc6IHRleHQsICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm9yZGVyZWQnOiBib3hlZCwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC55bWluJ10gIT0gMCB8fCBwcm9wWydjaGFydC5ub3hheGlzJ10gfHwgcHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pIHtcbiAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogdGV4dF9zaXplLCB4OiB4cG9zICsgb2Zmc2V0eCwgeTogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBvZmZzZXR5LCB0ZXh0OiBSRy5udW1iZXJGb3JtYXQodGhpcywgdGhpcy5zY2FsZTIubWluLnRvRml4ZWQodGhpcy5zY2FsZTIubWluID09PSAwID8gMCA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCB2YWxpZ246ICdjZW50ZXInLCBoYWxpZ246IGFsaWduLCBib3JkZXJlZDogYm94ZWQsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICB9XG4gICAgY28uZmlsbCgpO1xuICB9O3RoaXMuZHJhd0lFU2hhZG93ID0gdGhpcy5EcmF3SUVTaGFkb3cgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgdmFyIGNvID0gdGhpcy5jb250ZXh0O3ZhciBjYSA9IHRoaXMuY2FudmFzO3ZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3ZhciBwcmV2RmlsbFN0eWxlID0gY28uZmlsbFN0eWxlO3ZhciBvZmZzZXR4ID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTt2YXIgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFJlY3QoY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdICsgb2Zmc2V0eSwgY29vcmRzWzJdLCBjb29yZHNbM10pO2NvLmZpbGwoKTtjby5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlO1xuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldEJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHRoaXM7dmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdLFxuICAgICAgICBjYW52YXMgPSBvYmouY2FudmFzLFxuICAgICAgICBjb250ZXh0ID0gb2JqLmNvbnRleHQsXG4gICAgICAgIGNvb3JkcyA9IG9iai5jb29yZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKG9iai5jb29yZHNbaV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbGVmdCA9IGNvb3Jkc1tpXVswXSxcbiAgICAgICAgICB0b3AgPSBjb29yZHNbaV1bMV0sXG4gICAgICAgICAgd2lkdGggPSBjb29yZHNbaV1bMl0sXG4gICAgICAgICAgaGVpZ2h0ID0gY29vcmRzW2ldWzNdLFxuICAgICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcztcbiAgICAgIGlmIChwcm9wWydjaGFydC50b29sdGlwcy5ob3RzcG90Lnhvbmx5J10pIHtcbiAgICAgICAgcGEyKGNvLCAnYiByICUgJSAlICUnLCBsZWZ0LCB0aGlzLmd1dHRlclRvcCwgd2lkdGgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhMihjbywgJ2IgciAlICUgJSAlJywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjby5pc1BvaW50SW5QYXRoKG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMnXSkge1xuICAgICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dCA/IFJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSwgaSkgOiBwcm9wWydjaGFydC50b29sdGlwcyddW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhc2V0ID0gMCxcbiAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgIHdoaWxlIChpZHggPj0gKF90eXBlb2Yob2JqLmRhdGFbZGF0YXNldF0pID09PSAnb2JqZWN0JyAmJiBvYmouZGF0YVtkYXRhc2V0XSA/IG9iai5kYXRhW2RhdGFzZXRdLmxlbmd0aCA6IDEpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmouZGF0YVtkYXRhc2V0XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqLmRhdGFbZGF0YXNldF0pIHtcbiAgICAgICAgICAgIGlkeCAtPSBvYmouZGF0YVtkYXRhc2V0XS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmouZGF0YVtkYXRhc2V0XSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlkeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgMDogb2JqLCAxOiBsZWZ0LCAyOiB0b3AsIDM6IHdpZHRoLCA0OiBoZWlnaHQsIDU6IGksICdvYmplY3QnOiBvYmosICd4JzogbGVmdCwgJ3knOiB0b3AsICd3aWR0aCc6IHdpZHRoLCAnaGVpZ2h0JzogaGVpZ2h0LCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAsICdpbmRleF9hZGp1c3RlZCc6IGlkeCwgJ2RhdGFzZXQnOiBkYXRhc2V0IH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuZ2V0U2hhcGVCeVggPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBjYW52YXMgPSBlLnRhcmdldDt2YXIgbW91c2VDb29yZHMgPSBSR3JhcGguZ2V0TW91c2VYWShlKTt2YXIgb2JqID0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogdGhpcztmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG9iai5jb29yZHNbaV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbW91c2VYID0gbW91c2VDb29yZHNbMF07dmFyIG1vdXNlWSA9IG1vdXNlQ29vcmRzWzFdO3ZhciBsZWZ0ID0gb2JqLmNvb3Jkc1tpXVswXTt2YXIgdG9wID0gb2JqLmNvb3Jkc1tpXVsxXTt2YXIgd2lkdGggPSBvYmouY29vcmRzW2ldWzJdO3ZhciBoZWlnaHQgPSBvYmouY29vcmRzW2ldWzNdO3ZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7aWYgKG1vdXNlWCA+PSBsZWZ0ICYmIG1vdXNlWCA8PSBsZWZ0ICsgd2lkdGgpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10pIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcCA9IFJHcmFwaC5wYXJzZVRvb2x0aXBUZXh0ID8gUkdyYXBoLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSwgaSkgOiBwcm9wWydjaGFydC50b29sdGlwcyddW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IDA6IG9iaiwgMTogbGVmdCwgMjogdG9wLCAzOiB3aWR0aCwgNDogaGVpZ2h0LCA1OiBpLCAnb2JqZWN0Jzogb2JqLCAneCc6IGxlZnQsICd5JzogdG9wLCAnd2lkdGgnOiB3aWR0aCwgJ2hlaWdodCc6IGhlaWdodCwgJ2luZGV4JzogaSwgJ3Rvb2x0aXAnOiB0b29sdGlwIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGNvID0gdGhpcy5jb250ZXh0O3ZhciBjYSA9IHRoaXMuY2FudmFzO3ZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO2lmIChhcmcubGVuZ3RoID09IDIpIHtcbiAgICAgIHZhciBtb3VzZVggPSBhcmdbMF07dmFyIG1vdXNlWSA9IGFyZ1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gUkcuZ2V0TW91c2VYWShhcmcpO3ZhciBtb3VzZVggPSBtb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZID0gbW91c2VDb29yZHNbMV07XG4gICAgfVxuICAgIGlmIChtb3VzZVkgPCBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gfHwgbW91c2VZID4gY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddIHx8IG1vdXNlWCA8IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gfHwgbW91c2VYID4gY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICB2YXIgdmFsdWUgPSAodGhpcy5ncmFwaGFyZWEgLyAyIC0gKG1vdXNlWSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpIC8gdGhpcy5ncmFwaGFyZWEgKiAodGhpcy5zY2FsZTIubWF4IC0gdGhpcy5zY2FsZTIubWluKTtcbiAgICAgIHZhbHVlICo9IDI7aWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgdmFsdWUgKz0gdGhpcy5zY2FsZTIubWluO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgLT0gdGhpcy5zY2FsZTIubWluO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAndG9wJykge1xuICAgICAgdmFyIHZhbHVlID0gKHRoaXMuZ3JhcGhhcmVhIC0gKG1vdXNlWSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpIC8gdGhpcy5ncmFwaGFyZWEgKiAodGhpcy5zY2FsZTIubWF4IC0gdGhpcy5zY2FsZTIubWluKTtcbiAgICAgIHZhbHVlID0gdGhpcy5zY2FsZTIubWF4IC0gdmFsdWU7dmFsdWUgPSBtYS5hYnModmFsdWUpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLmdyYXBoYXJlYSAtIChtb3VzZVkgLSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pKSAvIHRoaXMuZ3JhcGhhcmVhICogKHRoaXMuc2NhbGUyLm1heCAtIHRoaXMuc2NhbGUyLm1pbik7XG4gICAgICB2YWx1ZSArPSB0aGlzLnNjYWxlMi5taW47XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTt0aGlzLmdldFlDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA+IHRoaXMuc2NhbGUyLm1heCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjbyA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllczt2YXIgeSxcbiAgICAgICAgeGF4aXNwb3MgPSBwcm9wWydjaGFydC54YXhpc3BvcyddO2lmICh4YXhpc3BvcyA9PSAndG9wJykge1xuICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICB2YWx1ZSA9IG1hLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5zY2FsZTIubWluKSAvICh0aGlzLnNjYWxlMi5tYXggLSB0aGlzLnNjYWxlMi5taW4pICogdGhpcy5ncmFwaGFyZWE7eSA9IHkgKyB0aGlzLmd1dHRlclRvcDtcbiAgICB9IGVsc2UgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5zY2FsZTIubWluKSAvICh0aGlzLnNjYWxlMi5tYXggLSB0aGlzLnNjYWxlMi5taW4pICogKHRoaXMuZ3JhcGhhcmVhIC8gMik7eSA9IHRoaXMuZ3JhcGhhcmVhIC8gMiAtIHk7eSArPSB0aGlzLmd1dHRlclRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDwgdGhpcy5zY2FsZTIubWluKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zY2FsZTIubWluO1xuICAgICAgfVxuICAgICAgeSA9ICh2YWx1ZSAtIHRoaXMuc2NhbGUyLm1pbikgLyAodGhpcy5zY2FsZTIubWF4IC0gdGhpcy5zY2FsZTIubWluKTt5ICo9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207eSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0geTtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlJlY3QodGhpcywgc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTtpZiAocHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnKSB7XG4gICAgICB2YXIgYWRqdXN0bWVudCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10gKiBtb3VzZVhZWzBdO21vdXNlWFlbMV0gLT0gYWRqdXN0bWVudDtcbiAgICB9XG4gICAgaWYgKG1vdXNlWFlbMF0gPj0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAmJiBtb3VzZVhZWzBdIDw9IGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10gJiYgbW91c2VYWVsxXSA+PSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gJiYgbW91c2VYWVsxXSA8PSBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRoaXMuZ2V0VmFsdWUoZSkpO3ZhciBzaGFwZSA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyk7XG4gICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgUkcuUmVnaXN0cnkuU2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnLCBzaGFwZSk7aWYgKHRoaXMuc3RhY2tlZE9yR3JvdXBlZCAmJiBwcm9wWydjaGFydC5ncm91cGluZyddID09ICdncm91cGVkJykge1xuICAgICAgICAgIHZhciBpbmRleGVzID0gUkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNoYXBlWydpbmRleCddLCB0aGlzLmRhdGEpO2lmICh0eXBlb2YgdGhpcy5kYXRhW2luZGV4ZXNbMF1dID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhlc1swXV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIVJHLmlzTnVsbCh0aGlzLmRhdGFbaW5kZXhlc1swXV0pKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhlc1swXV1baW5kZXhlc1sxXV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kYXRhW3NoYXBlWydpbmRleCddXSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuZGF0YVtzaGFwZVsnaW5kZXgnXV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFJHLnJlZHJhd0NhbnZhcyhlLnRhcmdldCk7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmFkanVzdCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHcmFwaC5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmtleS5jb2xvcnMnXSA9IFJHcmFwaC5hcnJheV9jbG9uZShwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10gPSBwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10gPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZWNvbG9yJ10gPSBwcm9wWydjaGFydC5zdHJva2Vjb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5heGlzLmNvbG9yJ10gPSBwcm9wWydjaGFydC5heGlzLmNvbG9yJ107XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5jb2xvcnMnXTtpZiAoY29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29sb3JzID0gcHJvcFsnY2hhcnQua2V5LmNvbG9ycyddO2lmIChjb2xvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbG9yc1tpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQudGV4dC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7cHJvcFsnY2hhcnQuc3Ryb2tlY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZWNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIDAsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMSwgbGVuID0gcGFydHMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHcmFwaC50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMuZHJhd0JldmVsID0gdGhpcy5EcmF3QmV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzO3ZhciBjb29yZHMyID0gdGhpcy5jb29yZHMyO3ZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3ZhciBjbyA9IHRoaXMuY29udGV4dDt2YXIgY2EgPSB0aGlzLmNhbnZhcztpZiAocHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnc3RhY2tlZCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzMi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoY29vcmRzMltpXSAmJiBjb29yZHMyW2ldWzBdICYmIGNvb3JkczJbaV1bMF1bMF0pIHtcbiAgICAgICAgICB2YXIgeCA9IGNvb3JkczJbaV1bMF1bMF07dmFyIHkgPSBjb29yZHMyW2ldWzBdWzFdO3ZhciB3ID0gY29vcmRzMltpXVswXVsyXTt2YXIgYXJyID0gW107Zm9yICh2YXIgaiA9IDA7IGogPCBjb29yZHMyW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBhcnIucHVzaChjb29yZHMyW2ldW2pdWzNdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGggPSBSR3JhcGguYXJyYXlfc3VtKGFycik7Y28uc2F2ZSgpO2NvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztjby5iZWdpblBhdGgoKTtjby5yZWN0KHgsIHksIHcsIGgpO2NvLmNsaXAoKTtjby5zaGFkb3dDb2xvciA9ICdibGFjayc7Y28uc2hhZG93T2Zmc2V0WCA9IDA7Y28uc2hhZG93T2Zmc2V0WSA9IDA7Y28uc2hhZG93Qmx1ciA9IDIwO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCAtIDMsIHkgLSAzLCB3ICsgNiwgaCArIDEwMCk7Y28ubGluZVdpZHRoID0gNTtjby5zdHJva2UoKTtjby5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNvb3Jkc1tpXSkge1xuICAgICAgICAgIHZhciB4ID0gY29vcmRzW2ldWzBdO3ZhciB5ID0gY29vcmRzW2ldWzFdO3ZhciB3ID0gY29vcmRzW2ldWzJdO3ZhciBoID0gY29vcmRzW2ldWzNdO3ZhciB4YXhpc3BvcyA9IHByb3BbJ2NoYXJ0LnhheGlzcG9zJ107dmFyIHhheGlzX3ljb29yZCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDIgKyB0aGlzLmd1dHRlclRvcDtjby5zYXZlKCk7Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCwgeSwgdywgaCk7Y28uY2xpcCgpO2NvLnNoYWRvd0NvbG9yID0gJ2JsYWNrJztjby5zaGFkb3dPZmZzZXRYID0gMDtjby5zaGFkb3dPZmZzZXRZID0gMDtjby5zaGFkb3dCbHVyID0gMjA7aWYgKHhheGlzcG9zID09ICd0b3AnIHx8IHhheGlzcG9zID09ICdjZW50ZXInICYmIHkgKyBoID4geGF4aXNfeWNvb3JkKSB7XG4gICAgICAgICAgICB5ID0geSAtIDEwMDtoID0gaCArIDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHk7aCA9IGggKyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnJlY3QoeCAtIDMsIHkgLSAzLCB3ICsgNiwgaCArIDYpO2NvLmxpbmVXaWR0aCA9IDU7Y28uc3Ryb2tlKCk7Y28ucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB0aGlzLmNvb3JkczIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCwgYXJyKSB7XG4gICAgICBpZiAoX3R5cGVvZih2YWx1ZVtpbmRleF0pID09ICdvYmplY3QnICYmIHZhbHVlW2luZGV4XSkge1xuICAgICAgICB2YXIgeCA9IHZhbHVlW2luZGV4XVswXTtcbiAgICAgICAgdmFyIHkgPSB2YWx1ZVtpbmRleF1bMV07XG4gICAgICAgIHZhciB3ID0gdmFsdWVbaW5kZXhdWzJdO1xuICAgICAgICB2YXIgaCA9IHZhbHVlW2luZGV4XVszXTtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmxpbmVXaWR0aCA9IDI7Y28uc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtjby5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3QWJvdmVMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddLFxuICAgICAgICBzcGVjaWZpYyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zcGVjaWZpYyddLFxuICAgICAgICBjb2xvciA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvciddLFxuICAgICAgICBiYWNrZ3JvdW5kID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmJhY2tncm91bmQnXSxcbiAgICAgICAgZGVjaW1hbHMgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnXSxcbiAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zaXplJ10sXG4gICAgICAgIGFuZ2xlID0gLTEgKiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuYW5nbGUnXSxcbiAgICAgICAgdW5pdHNQcmUgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucHJlJ10sXG4gICAgICAgIHVuaXRzUG9zdCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wb3N0J10sXG4gICAgICAgIGNvb3JkcyA9IHRoaXMuY29vcmRzLFxuICAgICAgICBjb29yZHMyID0gdGhpcy5jb29yZHMyLFxuICAgICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBsZGF0YSA9IFJHLmFycmF5TGluZWFyaXplKHRoaXMuZGF0YSksXG4gICAgICAgIG9mZnNldCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5vZmZzZXQnXSxcbiAgICAgICAgdGV4dF9mb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICBncm91cGluZyA9IHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ107XG4gICAgUkcubm9TaGFkb3codGhpcyk7Y28uZmlsbFN0eWxlID0gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyA/IGNvbG9yIDogcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmIChsYWJlbHMgJiYgZ3JvdXBpbmcgPT09ICdncm91cGVkJykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoLCBzZXF1ZW50aWFsSW5kZXggPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldID09PSAnbnVtYmVyJyAmJiBkYXRhW2ldID49IDApIHtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBhbmdsZTt2YXIgaGFsaWduID0gYW5nbGUgPyAnbGVmdCcgOiAnY2VudGVyJzt2YXIgdmFsaWduID0gYW5nbGUgIT09IDAgPyAnY2VudGVyJyA6ICdib3R0b20nO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiB0ZXh0X2ZvbnQsICdzaXplJzogdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHRleHRfc2l6ZSAtIDMsICd4JzogY29vcmRzMltpXVswXVswXSArIGNvb3JkczJbaV1bMF1bMl0gLyAyLCAneSc6IGNvb3JkczJbaV1bMF1bMV0gLSBvZmZzZXQsICd0ZXh0Jzogc3BlY2lmaWMgPyBzcGVjaWZpY1tzZXF1ZW50aWFsSW5kZXhdIHx8ICcnIDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIE51bWJlcihfdHlwZW9mKGRhdGFbaV0pID09PSAnb2JqZWN0JyA/IGRhdGFbaV1bMF0gOiBkYXRhW2ldKS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNQcmUsIHVuaXRzUG9zdCksICdoYWxpZ24nOiBoYWxpZ24sICd2YWxpZ24nOiB2YWxpZ24sICdhbmdsZSc6IGFuZ2xlLCAnbWFya2VyJzogZmFsc2UsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZy5maWxsJzogYmFja2dyb3VuZCwgJ2JvdW5kaW5nLnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ3RhZyc6ICdsYWJlbHMuYWJvdmUnIH0pO3NlcXVlbnRpYWxJbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2ldID09PSAnbnVtYmVyJyAmJiBkYXRhW2ldIDwgMCkge1xuICAgICAgICAgIHZhciBhbmdsZSA9IGFuZ2xlO3ZhciBoYWxpZ24gPSBhbmdsZSA/ICdyaWdodCcgOiAnY2VudGVyJzt2YXIgdmFsaWduID0gYW5nbGUgIT09IDAgPyAnY2VudGVyJyA6ICd0b3AnO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiB0ZXh0X2ZvbnQsICdzaXplJzogdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHRleHRfc2l6ZSAtIDMsICd4JzogY29vcmRzMltpXVswXVswXSArIGNvb3JkczJbaV1bMF1bMl0gLyAyLCAneSc6IGNvb3JkczJbaV1bMF1bMV0gKyBjb29yZHMyW2ldWzBdWzNdICsgb2Zmc2V0LCAndGV4dCc6IHNwZWNpZmljID8gc3BlY2lmaWNbc2VxdWVudGlhbEluZGV4XSB8fCAnJyA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBOdW1iZXIoX3R5cGVvZihkYXRhW2ldKSA9PT0gJ29iamVjdCcgPyBkYXRhW2ldWzBdIDogZGF0YVtpXSkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzUHJlLCB1bml0c1Bvc3QpLCAnaGFsaWduJzogaGFsaWduLCAndmFsaWduJzogdmFsaWduLCAnYW5nbGUnOiBhbmdsZSwgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nLmZpbGwnOiBiYWNrZ3JvdW5kLCAnYm91bmRpbmcuc3Ryb2tlJzogJ3JnYmEoMCwwLDAsMCknLCAnbWFya2VyJzogZmFsc2UsICd0YWcnOiAnbGFiZWxzLmFib3ZlJyB9KTtzZXF1ZW50aWFsSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGRhdGFbaV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gZGF0YVtpXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGFuZ2xlO3ZhciBoYWxpZ24gPSBkYXRhW2ldW2pdIDwgMCA/ICdyaWdodCcgOiAnbGVmdCc7aGFsaWduID0gYW5nbGUgPT09IDAgPyAnY2VudGVyJyA6IGhhbGlnbjt2YXIgdmFsaWduID0gZGF0YVtpXVtqXSA8IDAgPyAndG9wJyA6ICdib3R0b20nO3ZhbGlnbiA9IGFuZ2xlICE9IDAgPyAnY2VudGVyJyA6IHZhbGlnbjtSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogdGV4dF9mb250LCAnc2l6ZSc6IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiB0ZXh0X3NpemUgLSAzLCAneCc6IGNvb3JkczJbaV1bal1bMF0gKyBjb29yZHMyW2ldW2pdWzJdIC8gMiwgJ3knOiBjb29yZHMyW2ldW2pdWzFdICsgKGRhdGFbaV1bal0gPCAwID8gY29vcmRzMltpXVtqXVszXSArIG9mZnNldCA6IC1vZmZzZXQpLCAndGV4dCc6IHNwZWNpZmljID8gc3BlY2lmaWNbc2VxdWVudGlhbEluZGV4XSB8fCAnJyA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBOdW1iZXIoZGF0YVtpXVtqXSkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzUHJlLCB1bml0c1Bvc3QpLCAnaGFsaWduJzogaGFsaWduLCAndmFsaWduJzogdmFsaWduLCAnYW5nbGUnOiBhbmdsZSwgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nLmZpbGwnOiBiYWNrZ3JvdW5kLCAnYm91bmRpbmcuc3Ryb2tlJzogJ3JnYmEoMCwwLDAsMCknLCAnbWFya2VyJzogZmFsc2UsICd0YWcnOiAnbGFiZWxzLmFib3ZlJyB9KTtzZXF1ZW50aWFsSW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhYmVscyAmJiBncm91cGluZyA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGgsIHNlcXVlbnRpYWxJbmRleCA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoX3R5cGVvZihkYXRhW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBhbmdsZTt2YXIgaGFsaWduID0gYW5nbGUgIT0gMCA/ICdsZWZ0JyA6ICdjZW50ZXInO3ZhciB2YWxpZ24gPSBhbmdsZSAhPSAwID8gJ2NlbnRlcicgOiAnYm90dG9tJztSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogdGV4dF9mb250LCAnc2l6ZSc6IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiB0ZXh0X3NpemUgLSAzLCAneCc6IGNvb3JkczJbaV1bMF1bMF0gKyBjb29yZHMyW2ldWzBdWzJdIC8gMiwgJ3knOiBjb29yZHMyW2ldWzBdWzFdICsgKGRhdGFbaV1bMF0gPCAwID8gY29vcmRzMltpXVswXVszXSA6IDApIC0gb2Zmc2V0LCAndGV4dCc6IHNwZWNpZmljID8gc3BlY2lmaWNbc2VxdWVudGlhbEluZGV4XSB8fCAnJyA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBOdW1iZXIoUkcuYXJyYXlTdW0oZGF0YVtpXSkpLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c1ByZSwgdW5pdHNQb3N0KSwgJ2hhbGlnbic6IGhhbGlnbiwgJ3ZhbGlnbic6IHZhbGlnbiwgJ2FuZ2xlJzogYW5nbGUsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZy5maWxsJzogYmFja2dyb3VuZCwgJ2JvdW5kaW5nLnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ21hcmtlcic6IGZhbHNlLCAndGFnJzogJ2xhYmVscy5hYm92ZScgfSk7c2VxdWVudGlhbEluZGV4ICs9IGRhdGFbaV0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhbmdsZSA9IGFuZ2xlO3ZhciBoYWxpZ24gPSBhbmdsZSAhPSAwID8gJ2xlZnQnIDogJ2NlbnRlcic7dmFyIHZhbGlnbiA9IGFuZ2xlICE9IDAgPyAnY2VudGVyJyA6ICdib3R0b20nO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiB0ZXh0X2ZvbnQsICdzaXplJzogdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHRleHRfc2l6ZSAtIDMsICd4JzogY29vcmRzMltpXVswXVswXSArIGNvb3JkczJbaV1bMF1bMl0gLyAyLCAneSc6IGNvb3JkczJbaV1bMF1bMV0gKyAoZGF0YVtpXVswXSA8IDAgPyBjb29yZHMyW2ldWzBdWzNdIDogMCkgLSBvZmZzZXQsICd0ZXh0Jzogc3BlY2lmaWMgPyBzcGVjaWZpY1tzZXF1ZW50aWFsSW5kZXhdIHx8ICcnIDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIE51bWJlcihkYXRhW2ldKS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNQcmUsIHVuaXRzUG9zdCksICdoYWxpZ24nOiBoYWxpZ24sICd2YWxpZ24nOiB2YWxpZ24sICdhbmdsZSc6IGFuZ2xlLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmcuZmlsbCc6IGJhY2tncm91bmQsICdib3VuZGluZy5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdtYXJrZXInOiBmYWxzZSwgJ3RhZyc6ICdsYWJlbHMuYWJvdmUnIH0pO3NlcXVlbnRpYWxJbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMud2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBsYWJlbHNBYm92ZSA9IHRoaXMuZ2V0KCdsYWJlbHNBYm92ZScpO29wdC5mcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO29wdC5zdGFydEZyYW1lcyA9IFtdO29wdC5jb3VudGVycyA9IFtdO3ZhciBmcmFtZXNwZXJiYXIgPSBvcHQuZnJhbWVzIC8gMyxcbiAgICAgICAgZnJhbWUgPSAtMSxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9yaWdpbmFsID0gUkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsX2RhdGEpO3RoaXMuc2V0KCdsYWJlbHNBYm92ZScsIGZhbHNlKTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG9wdC5zdGFydEZyYW1lc1tpXSA9IG9wdC5mcmFtZXMgLyAyIC8gKG9iai5kYXRhLmxlbmd0aCAtIDEpICogaTtpZiAoX3R5cGVvZihvYmouZGF0YVtpXSkgPT09ICdvYmplY3QnICYmIG9iai5kYXRhW2ldKSB7XG4gICAgICAgIG9wdC5jb3VudGVyc1tpXSA9IFtdO2ZvciAodmFyIGogPSAwOyBqIDwgb2JqLmRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBvcHQuY291bnRlcnNbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuY291bnRlcnNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBvYmouZHJhdygpO29iai5TZXQoJ3ltYXgnLCBvYmouc2NhbGUyLm1heCk7UkcuY2xlYXIob2JqLmNhbnZhcyk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICArK2ZyYW1lO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmouZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZnJhbWUgPiBvcHQuc3RhcnRGcmFtZXNbaV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iai5kYXRhW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb2JqLmRhdGFbaV0gPSBtYS5taW4obWEuYWJzKG9yaWdpbmFsW2ldKSwgbWEuYWJzKG9yaWdpbmFsW2ldICogKG9wdC5jb3VudGVyc1tpXSsrIC8gZnJhbWVzcGVyYmFyKSkpO2lmIChvcmlnaW5hbFtpXSA8IDApIHtcbiAgICAgICAgICAgICAgb2JqLmRhdGFbaV0gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghUkcuaXNOdWxsKG9iai5kYXRhW2ldKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBvYmouZGF0YVtpXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgb2JqLmRhdGFbaV1bal0gPSBtYS5taW4obWEuYWJzKG9yaWdpbmFsW2ldW2pdKSwgbWEuYWJzKG9yaWdpbmFsW2ldW2pdICogKG9wdC5jb3VudGVyc1tpXVtqXSsrIC8gZnJhbWVzcGVyYmFyKSkpO2lmIChvcmlnaW5hbFtpXVtqXSA8IDApIHtcbiAgICAgICAgICAgICAgICBvYmouZGF0YVtpXVtqXSAqPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmouZGF0YVtpXSA9IF90eXBlb2Yob2JqLmRhdGFbaV0pID09PSAnb2JqZWN0JyAmJiBvYmouZGF0YVtpXSA/IFJHLmFycmF5UGFkKFtdLCBvYmouZGF0YVtpXS5sZW5ndGgsIDApIDogUkcuaXNOdWxsKG9iai5kYXRhW2ldKSA/IG51bGwgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWUgPj0gb3B0LmZyYW1lcykge1xuICAgICAgICBpZiAobGFiZWxzQWJvdmUpIHtcbiAgICAgICAgICBvYmouc2V0KCdsYWJlbHNBYm92ZScsIHRydWUpO1JHLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuY29sb3JXYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307b3B0LmZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgNjA7b3B0LnN0YXJ0RnJhbWVzID0gW107b3B0LmNvdW50ZXJzID0gW10sIGNvbG9ycyA9IG9iai5wcm9wZXJ0aWVzWydjaGFydC5jb2xvcnMnXTtpZiAoY29sb3JzLmxlbmd0aCA8PSBvYmouZGF0YS5sZW5ndGgpIHtcbiAgICAgIG9iai5zZXQoJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJywgdHJ1ZSk7Y29sb3JzID0gUkcuYXJyYXlQYWQoY29sb3JzLCBvYmouZGF0YS5sZW5ndGgsIGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgICB2YXIgZnJhbWVzcGVyYmFyID0gb3B0LmZyYW1lcyAvIDIsXG4gICAgICAgIGZyYW1lID0gLTEsXG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvcmlnaW5hbENvbG9ycyA9IFJHLmFycmF5Q2xvbmUob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbG9ycyddKTtmb3IgKHZhciBpID0gMCwgbGVuID0gb3JpZ2luYWxDb2xvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG9wdC5zdGFydEZyYW1lc1tpXSA9IG9wdC5mcmFtZXMgLyAyIC8gKG9yaWdpbmFsQ29sb3JzLmxlbmd0aCAtIDEpICogaTtvcHQuY291bnRlcnNbaV0gPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICsrZnJhbWU7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZnJhbWUgPiBvcHQuc3RhcnRGcmFtZXNbaV0gJiYgY29sb3JzW2ldLm1hdGNoKC9ecmdiYT9cXCgoWzAtOSBdKyksKFswLTkgXSspLChbMC05IF0rKSgsKFsgMC05Ll0rKT8pXFwpLykpIHtcbiAgICAgICAgICBjb2xvcnNbaV0gPSAncmdiYSh7MX0sezJ9LHszfSx7NH0pJy5mb3JtYXQoUmVnRXhwLiQxLCBSZWdFeHAuJDIsIFJlZ0V4cC4kMywgKGZyYW1lIC0gb3B0LnN0YXJ0RnJhbWVzW2ldKSAvIGZyYW1lc3BlcmJhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sb3JzW2ldID0gY29sb3JzW2ldLnJlcGxhY2UoLyxbMC05LiBdK1xcKS8sICcsMCknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZyYW1lID49IG9wdC5mcmFtZXMpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9iaiA9IHRoaXMsXG4gICAgICAgIGxhYmVsc0Fib3ZlID0gdGhpcy5nZXQoJ2xhYmVsc0Fib3ZlJyk7XG4gICAgaWYgKFJHLmlzQXJyYXkob3B0LmRhdGEpKSB7XG4gICAgICB2YXIgeW1heCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHQuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoX3R5cGVvZihvcHQuZGF0YVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHQuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycgJiYgb3B0LmRhdGFbaV1bal0ubWF0Y2goLyhcXCt8XFwtKShbMC05XSspLykpIHtcbiAgICAgICAgICAgICAgaWYgKFJlZ0V4cC4kMSA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgb3B0LmRhdGFbaV1bal0gPSB0aGlzLm9yaWdpbmFsX2RhdGFbaV1bal0gKyBwYXJzZUludChSZWdFeHAuJDIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdC5kYXRhW2ldW2pdID0gdGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdIC0gcGFyc2VJbnQoUmVnRXhwLiQyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeW1heCA9IG1hLm1heCh5bWF4LCBvcHQuZGF0YVtpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHQuZGF0YVtpXSA9PT0gJ3N0cmluZycgJiYgb3B0LmRhdGFbaV0ubWF0Y2goLyhcXCt8XFwtKShbMC05XSspLykpIHtcbiAgICAgICAgICBpZiAoUmVnRXhwLiQxID09PSAnKycpIHtcbiAgICAgICAgICAgIG9wdC5kYXRhW2ldID0gdGhpcy5vcmlnaW5hbF9kYXRhW2ldICsgcGFyc2VJbnQoUmVnRXhwLiQyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0LmRhdGFbaV0gPSB0aGlzLm9yaWdpbmFsX2RhdGFbaV0gLSBwYXJzZUludChSZWdFeHAuJDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5bWF4ID0gbWEubWF4KHltYXgsIG9wdC5kYXRhW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5bWF4ID0gbWEubWF4KHltYXgsIG9wdC5kYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNjYWxlID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHltYXggfSk7dGhpcy5TZXQoJ2NoYXJ0LnltYXgnLCBzY2FsZS5tYXgpO1xuICAgIH1cbiAgICB0aGlzLnNldCgnbGFiZWxzQWJvdmUnLCBmYWxzZSk7aWYgKHByb3BbJ2NoYXJ0LnltYXgnXSA9PSBudWxsKSB7XG4gICAgICB2YXIgeW1heCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoUkcuaXNBcnJheSh0aGlzLmRhdGFbaV0pICYmIHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ10gPT09ICdzdGFja2VkJykge1xuICAgICAgICAgIHltYXggPSBtYS5tYXgoeW1heCwgbWEuYWJzKFJHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChSRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGdyb3VwID0gW107IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdyb3VwLnB1c2gobWEuYWJzKHRoaXMuZGF0YVtpXVtqXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5bWF4ID0gbWEubWF4KHltYXgsIG1hLmFicyhSRy5hcnJheU1heChncm91cCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5bWF4ID0gbWEubWF4KHltYXgsIG1hLmFicyh0aGlzLmRhdGFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNjYWxlID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHltYXggfSk7dGhpcy5TZXQoJ2NoYXJ0LnltYXgnLCBzY2FsZS5tYXgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdC55bWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgb2JqLnNldCgneW1heCcsIG9wdC55bWF4KTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICB2YXIgZWFzaW5nTXVsdGlwbGllciA9IFJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKTtmb3IgKHZhciBqID0gMCwgbGVuID0gb2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgaWYgKF90eXBlb2Yob2JqLmRhdGFbal0pID09PSAnb2JqZWN0JyAmJiAhUkcuaXNOdWxsKG9iai5kYXRhW2pdKSkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBsZW4yID0gb2JqLmRhdGFbal0ubGVuZ3RoOyBrIDwgbGVuMjsgKytrKSB7XG4gICAgICAgICAgICBpZiAob2JqLmZpcnN0RHJhdyB8fCAhb3B0LmRhdGEpIHtcbiAgICAgICAgICAgICAgb2JqLmRhdGFbal1ba10gPSBlYXNpbmdNdWx0aXBsaWVyICogb2JqLm9yaWdpbmFsX2RhdGFbal1ba107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdC5kYXRhICYmIG9wdC5kYXRhLmxlbmd0aCA9PT0gb2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gb3B0LmRhdGFbal1ba10gLSBvYmoub3JpZ2luYWxfZGF0YVtqXVtrXTtvYmouZGF0YVtqXVtrXSA9IGVhc2luZ011bHRpcGxpZXIgKiBkaWZmICsgb2JqLm9yaWdpbmFsX2RhdGFbal1ba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvYmouZmlyc3REcmF3IHx8ICFvcHQuZGF0YSkge1xuICAgICAgICAgICAgb2JqLmRhdGFbal0gPSBlYXNpbmdNdWx0aXBsaWVyICogb2JqLm9yaWdpbmFsX2RhdGFbal07XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHQuZGF0YSAmJiBvcHQuZGF0YS5sZW5ndGggPT09IG9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBvcHQuZGF0YVtqXSAtIG9iai5vcmlnaW5hbF9kYXRhW2pdO29iai5kYXRhW2pdID0gZWFzaW5nTXVsdGlwbGllciAqIGRpZmYgKyBvYmoub3JpZ2luYWxfZGF0YVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgZnJhbWUgKz0gMTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUkcuaXNBcnJheShvcHQuZGF0YSkpIHtcbiAgICAgICAgICB2YXIgbGluZWFyX2RhdGEgPSBSRy5hcnJheUxpbmVhcml6ZShkYXRhKTtmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVhcl9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW9ialsnJCcgKyBpXSkge1xuICAgICAgICAgICAgICBvYmpbJyQnICsgaV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLmRhdGEgPSBkYXRhO29iai5vcmlnaW5hbF9kYXRhID0gUkcuYXJyYXlDbG9uZShkYXRhKTtpZiAobGFiZWxzQWJvdmUpIHtcbiAgICAgICAgICBvYmouc2V0KCdsYWJlbHNBYm92ZScsIHRydWUpO1JHLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfTtpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0Vycm9yYmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHMsXG4gICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNvbG9yJ10gfHwgJ2JsYWNrJyxcbiAgICAgICAgZGVmYXVsdF9oYWxmd2lkdGggPSBtYS5taW4ocHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZC53aWR0aCddLCBjb29yZHNbMF1bMl0pIC8gMixcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIGVycm9yYmFycyA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycyddLFxuICAgICAgICBsZW5ndGggPSAwO2lmICghcHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZCddKSB7XG4gICAgICBwcm9wWydjaGFydC5lcnJvcmJhcnMuY2FwcGVkLndpZHRoJ10gPSAwO2hhbGZ3aWR0aCA9IDA7XG4gICAgfVxuICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29sb3IgPSBwcm9wWydjaGFydC5lcnJvcmJhcnMuY29sb3InXSB8fCAnYmxhY2snO2lmIChlcnJvcmJhcnNbaV0gJiYgdHlwZW9mIGVycm9yYmFyc1tpXVszXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY28ubGluZVdpZHRoID0gZXJyb3JiYXJzW2ldWzNdO1xuICAgICAgfVxuICAgICAgdmFyIGhhbGZ3aWR0aCA9IGVycm9yYmFyc1tpXSAmJiB0eXBlb2YgZXJyb3JiYXJzW2ldWzRdID09PSAnbnVtYmVyJyA/IGVycm9yYmFyc1tpXVs0XSAvIDIgOiBkZWZhdWx0X2hhbGZ3aWR0aDtpZiAoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSkge1xuICAgICAgICBoYWxmd2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcnJvcmJhcnNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxlbmd0aCA9IG1hLmFicyh0aGlzLmdldFlDb29yZChlcnJvcmJhcnNbaV0pIC0gdGhpcy5nZXRZQ29vcmQoMCkpO2lmIChsZW5ndGgpIHtcbiAgICAgICAgICBwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsIGNvb3Jkc1tpXVswXSArIGNvb3Jkc1tpXVsyXSAvIDIsIGNvb3Jkc1tpXVsxXSwgY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdIC8gMiwgY29vcmRzW2ldWzFdIC0gbGVuZ3RoLCBjb29yZHNbaV1bMF0gKyBjb29yZHNbaV1bMl0gLyAyIC0gaGFsZndpZHRoLCBtYS5yb3VuZChjb29yZHNbaV1bMV0gLSBsZW5ndGgpLCBjb29yZHNbaV1bMF0gKyBjb29yZHNbaV1bMl0gLyAyICsgaGFsZndpZHRoLCBtYS5yb3VuZChjb29yZHNbaV1bMV0gLSBsZW5ndGgpLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihlcnJvcmJhcnNbaV0pID09PSAnb2JqZWN0JyAmJiAhUkcuaXNOdWxsKGVycm9yYmFyc1tpXSkpIHtcbiAgICAgICAgdmFyIHBvc2l0aXZlTGVuZ3RoID0gbWEuYWJzKHRoaXMuZ2V0WUNvb3JkKGVycm9yYmFyc1tpXVswXSkgLSB0aGlzLmdldFlDb29yZCgwKSk7aWYgKHR5cGVvZiBlcnJvcmJhcnNbaV1bMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29sb3IgPSBlcnJvcmJhcnNbaV1bMV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yYmFyc1tpXVsyXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb2xvciA9IGVycm9yYmFyc1tpXVsyXTtcbiAgICAgICAgfVxuICAgICAgICBoYWxmd2lkdGggPSB0eXBlb2YgZXJyb3JiYXJzW2ldWzRdID09PSAnbnVtYmVyJyA/IGVycm9yYmFyc1tpXVs0XSAvIDIgOiBkZWZhdWx0X2hhbGZ3aWR0aDtpZiAoIXByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnXSkge1xuICAgICAgICAgIGhhbGZ3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFSRy5pc051bGwoZXJyb3JiYXJzW2ldWzBdKSkge1xuICAgICAgICAgIHBhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAlJywgY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdIC8gMiwgY29vcmRzW2ldWzFdLCBjb29yZHNbaV1bMF0gKyBjb29yZHNbaV1bMl0gLyAyLCBjb29yZHNbaV1bMV0gLSBwb3NpdGl2ZUxlbmd0aCwgY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdIC8gMiAtIGhhbGZ3aWR0aCwgbWEucm91bmQoY29vcmRzW2ldWzFdIC0gcG9zaXRpdmVMZW5ndGgpLCBjb29yZHNbaV1bMF0gKyBjb29yZHNbaV1bMl0gLyAyICsgaGFsZndpZHRoLCBtYS5yb3VuZChjb29yZHNbaV1bMV0gLSBwb3NpdGl2ZUxlbmd0aCksIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yYmFyc1tpXVsxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgbmVnYXRpdmVMZW5ndGggPSBtYS5hYnModGhpcy5nZXRZQ29vcmQoZXJyb3JiYXJzW2ldWzFdKSAtIHRoaXMuZ2V0WUNvb3JkKDApKTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsIGNvb3Jkc1tpXVswXSArIGNvb3Jkc1tpXVsyXSAvIDIsIGNvb3Jkc1tpXVsxXSwgY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdIC8gMiwgY29vcmRzW2ldWzFdICsgbmVnYXRpdmVMZW5ndGgsIGNvb3Jkc1tpXVswXSArIGNvb3Jkc1tpXVsyXSAvIDIgLSBoYWxmd2lkdGgsIG1hLnJvdW5kKGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoKSwgY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdIC8gMiArIGhhbGZ3aWR0aCwgbWEucm91bmQoY29vcmRzW2ldWzFdICsgbmVnYXRpdmVMZW5ndGgpLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcmJhcnNbaV0gJiYgdHlwZW9mIGVycm9yYmFyc1tpXVszXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuZXJyb3JiYXJzLmxpbmV3aWR0aCddO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmlzQWRqdXN0YWJsZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmIChSRy5pc051bGwocHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J10pIHx8ICFSRy5pc0FycmF5KHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChSRy5pc0FycmF5KHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSAmJiBwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXVtzaGFwZS5pbmRleF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07UkcucmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07UkdyYXBoLkNvbWJpbmVkQ2hhcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub2JqZWN0cyA9IFtdO3ZhciBvYmplY3RzID0gW107aWYgKFJHcmFwaC5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICBvYmplY3RzID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmplY3RzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLm9iamVjdHNbaV0gPSBvYmplY3RzW2ldO3RoaXMub2JqZWN0c1tpXS5zZXQoeyBndXR0ZXJMZWZ0OiB0aGlzLm9iamVjdHNbMF0uZ2V0KCdndXR0ZXIubGVmdCcpLCBndXR0ZXJSaWdodDogdGhpcy5vYmplY3RzWzBdLmdldCgnZ3V0dGVyLnJpZ2h0JyksIGd1dHRlclRvcDogdGhpcy5vYmplY3RzWzBdLmdldCgnZ3V0dGVyLnRvcCcpLCBndXR0ZXJCb3R0b206IHRoaXMub2JqZWN0c1swXS5nZXQoJ2d1dHRlci5ib3R0b20nKSB9KTtpZiAodGhpcy5vYmplY3RzW2ldLnR5cGUgPT0gJ2xpbmUnKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5vYmplY3RzW2ldO29iai5zZXQoJ2htYXJnaW4nLCAodGhpcy5vYmplY3RzWzBdLmNhbnZhcy53aWR0aCAtIHRoaXMub2JqZWN0c1swXS5HZXQoJ2NoYXJ0Lmd1dHRlci5yaWdodCcpIC0gdGhpcy5vYmplY3RzWzBdLkdldCgnY2hhcnQuZ3V0dGVyLmxlZnQnKSkgLyB0aGlzLm9iamVjdHNbMF0uZGF0YS5sZW5ndGggLyAyKTtvYmouc2V0KCdub2F4ZXMnLCB0cnVlKTtvYmouc2V0KCdiYWNrZ3JvdW5kR3JpZCcsIGZhbHNlKTtvYmouc2V0KCd5bGFiZWxzJywgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYmplY3RzW2ldLmdldCgnY2hhcnQucmVzaXphYmxlJykpIHtcbiAgICAgIHZhciByZXNpemFibGVfb2JqZWN0ID0gb2JqO1xuICAgIH1cbiAgfVxuICBpZiAocmVzaXphYmxlX29iamVjdCkge1xuICAgIHZhciBteU9ucmVzaXplYmVmb3JlZHJhdyA9IGZ1bmN0aW9uIG15T25yZXNpemViZWZvcmVkcmF3KG9iaikge1xuICAgICAgdmFyIGd1dHRlckxlZnQgPSBvYmouZ2V0KCdndXR0ZXJMZWZ0Jyk7dmFyIGd1dHRlclJpZ2h0ID0gb2JqLmdldCgnZ3V0dGVyUmlnaHQnKTtvYmouc2V0KCdobWFyZ2luJywgKG9iai5jYW52YXMud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQpIC8gKG9iai5vcmlnaW5hbF9kYXRhWzBdLmxlbmd0aCAqIDIpKTtcbiAgICB9O1xuXG4gICAgUkdyYXBoLkFkZEN1c3RvbUV2ZW50TGlzdGVuZXIocmVzaXphYmxlX29iamVjdCwgJ29ucmVzaXplYmVmb3JlZHJhdycsIG15T25yZXNpemViZWZvcmVkcmF3KTtcbiAgfVxufTtSR3JhcGguQ29tYmluZWRDaGFydC5wcm90b3R5cGUuYWRkID0gUkdyYXBoLkNvbWJpbmVkQ2hhcnQucHJvdG90eXBlLkFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdGhpcy5vYmplY3RzLnB1c2gob2JqKTtcbn07UkdyYXBoLkNvbWJpbmVkQ2hhcnQucHJvdG90eXBlLmRyYXcgPSBSR3JhcGguQ29tYmluZWRDaGFydC5wcm90b3R5cGUuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0J10pIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0Lm9wdGlvbnMnXSA/IGV2YWwoJygnICsgdGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0Lm9wdGlvbnMnXSArICcpJykgOiBudWxsLFxuICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5vYmplY3RzW2ldLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0LmNhbGxiYWNrJ10sXG4gICAgICAgICAgZnVuYyA9IHRoaXMub2JqZWN0c1tpXS5wcm9wZXJ0aWVzWydjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdCddO3RoaXMub2JqZWN0c1tpXVtmdW5jXShvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2JqZWN0c1tpXS5kcmF3KCk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5iYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///162\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Bipolar = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.left) === 'object' && _typeof(conf.right) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        left = conf.left,\n        right = conf.right,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        left = arguments[1],\n        right = arguments[2];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'bipolar';this.coords = [];this.coordsLeft = [];this.coordsRight = [];this.max = 0;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;for (var i = 0; i < left.length; ++i) {\n    left[i] = parseFloat(left[i]);\n  }for (var i = 0; i < right.length; ++i) {\n    right[i] = parseFloat(right[i]);\n  }this.left = left;this.right = right;this.data = [left, right];this.properties = { 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.linewidth': 1, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.autofit.numhlines': null, 'chart.margin': 2, 'chart.xtickinterval': null, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.above': false, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title.left': '', 'chart.title.right': '', 'chart.gutter.center': 60, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['#0f0'], 'chart.colors.sequential': false, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.units.pre': '', 'chart.units.post': '', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.xmax': null, 'chart.xmin': 0, 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.linewidth': 1, 'chart.noaxes': false, 'chart.xlabels': true, 'chart.numyticks': null, 'chart.numxticks': 5, 'chart.axis.linewidth': 1, 'chart.labels.count': 5, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.angle': 0.1, 'chart.clearto': 'rgba(0,0,0,0)' };\n  while (this.left.length < this.right.length) {\n    this.left.push(null);\n  }while (this.left.length > this.right.length) {\n    this.right.push(null);\n  }this.properties['chart.numyticks'] = this.left.length;var linear_data = RGraph.arrayLinearize(this.left, this.right);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return this.properties[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.gutterCenter = prop['chart.gutter.center'];this.left = this.data[0];this.right = this.data[1];this.coords = [];this.coordsText = [];if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n    }\n    this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;this.sequentialFullIndex = 0;this.getMax();this.drawBackgroundGrid();this.draw3DAxes();this.drawAxes();this.drawTicks();co.save();co.beginPath();co.rect(this.gutterLeft, this.gutterTop - (prop['chart.variant.threed.offsety'] || 0), ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom + 2 * (prop['chart.variant.threed.offsety'] || 0));co.clip();this.drawLeftBars();this.drawRightBars();this.drawLeftBars({ shadow: false });this.drawRightBars({ shadow: false });co.restore();this.drawAxes();this.drawLabels();this.drawTitles();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.draw3DAxes = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft, ma.round(ca.height - this.gutterBottom), this.gutterLeft + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + offsetx + this.axisWidth, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.axisWidth, ma.round(ca.height - this.gutterBottom));this.draw3DLeftVerticalAxis();pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ma.round(ca.height - this.gutterBottom), this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth + offsetx, ma.round(ca.height - this.gutterBottom - offsety), this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth, ma.round(ca.height - this.gutterBottom));pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom, this.gutterLeft + this.gutterCenter + this.axisWidth, ca.height - this.gutterBottom - this.axisHeight, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - this.axisHeight - offsety, this.gutterLeft + this.gutterCenter + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety);\n    }\n  };\n  this.draw3DLeftVerticalAxis = function () {\n    if (prop['chart.variant'] === '3d') {\n      var offsetx = prop['chart.variant.threed.offsetx'],\n          offsety = prop['chart.variant.threed.offsety'];pa2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', this.gutterLeft + this.axisWidth, this.gutterTop, this.gutterLeft + this.axisWidth + offsetx, this.gutterTop - offsety, this.gutterLeft + this.axisWidth + offsetx, ca.height - this.gutterBottom - offsety, this.gutterLeft + this.axisWidth, ca.height - this.gutterBottom);\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.beginPath();co.strokeStyle = prop['chart.axis.color'];this.axisWidth = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;if (prop['chart.noaxes']) {\n      return;\n    }\n    co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft + this.axisWidth, Math.round(ca.height - this.gutterBottom));co.moveTo(ma.round(this.gutterLeft + this.axisWidth), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + this.axisWidth), this.gutterTop);co.stroke();co.beginPath();var x = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'];co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), ca.height - this.gutterBottom);co.moveTo(Math.round(x), Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.stroke();\n  };this.drawTicks = this.DrawTicks = function () {\n    co.lineWidth = prop['chart.axis.linewidth'] + 0.001;var numDataPoints = this.left.length;var barHeight = (ca.height - this.gutterTop - this.gutterBottom - this.left.length * (prop['chart.margin'] * 2)) / numDataPoints;this.barHeight = barHeight;if (prop['chart.noaxes']) {\n      return;\n    }\n    if (prop['chart.numyticks'] > 0) {\n      co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth, y);co.lineTo(this.gutterLeft + this.axisWidth + 3, y);\n      }\n      co.stroke();co.beginPath();for (var i = 0; i < prop['chart.numyticks']; ++i) {\n        var y = prop['chart.gutter.top'] + (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks'] * i;co.moveTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'], y);co.lineTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] - 3, y);\n      }\n      co.stroke();\n    }\n    if (prop['chart.numxticks'] > 0) {\n      var xInterval = this.axisWidth / prop['chart.numxticks'];if (typeof prop['chart.xtickinterval'] == 'number') {\n        xInterval = prop['chart.xtickinterval'];\n      }\n      for (i = this.gutterLeft; i < this.gutterLeft + this.axisWidth; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n      var stoppingPoint = ca.width - this.gutterRight;for (i = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] + xInterval; i <= stoppingPoint; i += xInterval) {\n        co.beginPath();co.moveTo(Math.round(i), ca.height - this.gutterBottom);co.lineTo(Math.round(i), ca.height - this.gutterBottom + 4);co.closePath();co.stroke();\n      }\n    }\n  };this.getMax = this.GetMax = function () {\n    var dec = prop['chart.scale.decimals'];if (prop['chart.xmax']) {\n      var max = prop['chart.xmax'];var min = prop['chart.xmin'];this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    } else {\n      var max = Math.max(RG.array_max(this.left), RG.array_max(this.right));this.scale2 = RG.getScale2(this, { 'max': max, 'min': prop['chart.xmin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n  };this.drawLeftBars = this.DrawLeftBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];for (var i = this.left.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.left[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth - width), ma.round(this.gutterTop + i * (this.axisHeight / this.left.length) + prop['chart.margin']), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.drawIEShadow(coords);\n      }\n      if (this.left[i] !== null) {\n        co.strokeRect(coords[0], coords[1], coords[2], coords[3]);co.fillRect(coords[0], coords[1], coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.left[i] !== null) {\n        if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        } else {\n          co.fillStyle = prop['chart.colors'][0];\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.4)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);\n      }\n      this.draw3DLeftVerticalAxis();this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsLeft.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.noShadow(this);co.lineWidth = 1;\n  };this.drawRightBars = this.DrawRightBars = function () {\n    var opt = {};if (_typeof(arguments[0]) === 'object') {\n      opt.shadow = arguments[0].shadow;\n    } else {\n      opt.shadow = true;\n    }\n    var offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow'] && prop['chart.variant'] !== '3d' && opt.shadow) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (var i = this.right.length - 1; i >= 0; i -= 1) {\n      if (prop['chart.colors.sequential']) {\n        co.fillStyle = prop['chart.colors'][i];\n      } else {\n        co.fillStyle = prop['chart.colors'][0];\n      }\n      var width = (this.right[i] - this.min) / (this.max - this.min) * this.axisWidth;var coords = [ma.round(this.gutterLeft + this.axisWidth + prop['chart.gutter.center']), ma.round(prop['chart.margin'] + i * (this.axisHeight / this.right.length) + this.gutterTop), width, this.barHeight];if (RG.ISOLD && prop['chart.shadow']) {\n        this.DrawIEShadow(coords);\n      }\n      if (this.right[i] !== null) {\n        co.strokeRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);co.fillRect(ma.round(coords[0]), Math.round(coords[1]), coords[2], coords[3]);\n      }\n      if (prop['chart.variant'] === '3d' && this.right[i] !== null) {\n        var color = co.fillStyle;if (prop['chart.shadow'] && opt.shadow) {\n          co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];pa2(co, 'b m % % l % % l % % l % % f black sc rgba(0,0,0,0) sx 0 sy 0 sb 0', coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety + coords[3], coords[0] + offsetx, coords[1] - offsety + coords[3]);\n        }\n        pa2(co, 'b m % % l % % l % % l % % f %', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1], color);pa2(co, 'b m % % l % % l % % l % % f %', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3], color);pa2(co, 'b m % % l % % l % % l % % f rgba(255,255,255,0.6)', coords[0], coords[1], coords[0] + offsetx, coords[1] - offsety, coords[0] + offsetx + coords[2], coords[1] - offsety, coords[0] + coords[2], coords[1]);pa2(co, 'b m % % l % % l % % l % % f rgba(0,0,0,0.3)', coords[0] + coords[2], coords[1], coords[0] + coords[2] + offsetx, coords[1] - offsety, coords[0] + coords[2] + offsetx, coords[1] - offsety + coords[3], coords[0] + coords[2], coords[1] + coords[3]);\n      }\n      this.coords.push([coords[0], coords[1], coords[2], coords[3]]);this.coordsRight.push([coords[0], coords[1], coords[2], coords[3]]);\n    }\n    RG.NoShadow(this);co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var font = prop['chart.text.font'],\n        color = prop['chart.labels.color'] || prop['chart.text.color'],\n        size = prop['chart.text.size'],\n        labels = prop['chart.labels'],\n        barAreaHeight = ca.height - this.gutterTop - this.gutterBottom;\n    co.fillStyle = color;for (var i = 0, len = labels.length; i < len; i += 1) {\n      RG.Text2(this, { 'color': color, 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] / 2, 'y': this.gutterTop + barAreaHeight / labels.length * i + barAreaHeight / labels.length / 2, 'text': String(labels[i] ? String(labels[i]) : ''), 'halign': 'center', 'valign': 'center', 'marker': false, 'tag': 'labels' });\n    }\n    co.fillStyle = prop['chart.text.color'];if (prop['chart.xlabels']) {\n      var grapharea = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea / this.scale2.labels.length * i, 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[this.scale2.labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + grapharea + prop['chart.gutter.center'] + grapharea / this.scale2.labels.length * (i + 1), 'y': ca.height - this.gutterBottom + 3, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (prop['chart.scale.zerostart']) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + this.axisWidth + this.gutterCenter, 'y': ca.height - this.gutterBottom + 3, 'text': '0', 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n    if (prop['chart.labels.above']) {\n      var coordsLeft = RG.arrayReverse(this.coordsLeft);for (var i = 0; i < coordsLeft.length; ++i) {\n        if (typeof this.left[i] !== 'number') {\n          continue;\n        }\n        var coords = coordsLeft[i];RG.text2(this, { font: font, size: size, x: coords[0] - 5, y: coords[1] + coords[3] / 2, text: RG.numberFormat(this, this.left[i], prop['chart.units.pre'], prop['chart.units.post']), valign: 'center', halign: 'right', tag: 'labels.above' });\n      }\n      var coordsRight = RG.arrayReverse(this.coordsRight);for (i = 0; i < coordsRight.length; ++i) {\n        if (typeof this.right[i] != 'number') {\n          continue;\n        }\n        var coords = coordsRight[i];RG.Text2(this, { 'font': font, 'size': size, 'x': coords[0] + coords[2] + 5, 'y': coords[1] + coords[3] / 2, 'text': RG.number_format(this, this.right[i], prop['chart.units.pre'], prop['chart.units.post']), 'valign': 'center', 'halign': 'left', 'tag': 'labels.above' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.gutterLeft + 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.left']), 'halign': 'left', 'valign': 'bottom', 'tag': 'title.left' });RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': ca.width - this.gutterRight - 5, 'y': this.gutterTop - 5, 'text': String(prop['chart.title.right']), 'halign': 'right', 'valign': 'bottom', 'tag': 'title.right' });RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : null);\n  };this.drawIEShadow = this.DrawIEShadow = function (coords) {\n    var prevFillStyle = co.fillStyle;var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.fillStyle = prop['chart.shadow.color'];co.beginPath();co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);co.fill();co.fillStyle = prevFillStyle;\n  };\n  this.getShape = this.getBar = function (e) {\n    var canvas = this.canvas,\n        context = this.context,\n        mouseCoords = RG.getMouseXY(e);\n    for (var i = 0; i < this.coords.length; i++) {\n      var mouseX = mouseCoords[0],\n          mouseY = mouseCoords[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];\n      pa2(co, 'b r % % % %', left, top, width, height);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: i, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getValue = function (e) {\n    var obj = e.target.__object__;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];if (mouseX > this.gutterLeft && mouseX < ca.width / 2 - prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left']) / this.axisWidth;value = this.max - value * this.max;\n    }\n    if (mouseX < ca.width - this.gutterRight && mouseX > ca.width / 2 + prop['chart.gutter.center'] / 2) {\n      var value = (mouseX - prop['chart.gutter.left'] - this.axisWidth - prop['chart.gutter.center']) / this.axisWidth;value = value * this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (value > this.max || value < 0) {\n      return null;\n    }\n    var ret = [];var offset = value / this.max * this.axisWidth;ret[0] = this.gutterLeft + this.axisWidth - offset;ret[1] = ca.width - this.gutterRight - this.axisWidth + offset;return ret;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    props['chart.highlight.stroke'] = this.parseSingleColorForGradient(props['chart.highlight.stroke']);props['chart.highlight.fill'] = this.parseSingleColorForGradient(props['chart.highlight.fill']);props['chart.axis.color'] = this.parseSingleColorForGradient(props['chart.axis.color']);props['chart.strokestyle'] = this.parseSingleColorForGradient(props['chart.strokestyle']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawBackgroundGrid = function () {\n    if (prop['chart.background.grid']) {\n      var variant = prop['chart.variant'],\n          color = prop['chart.background.grid.color'],\n          numvlines = prop['chart.labels.count'],\n          numhlines = this.left.length,\n          vlines = prop['chart.background.grid.vlines'],\n          hlines = prop['chart.background.grid.hlines'],\n          linewidth = prop['chart.background.grid.linewidth'];if (typeof prop['chart.background.grid.autofit.numhlines'] === 'number') {\n        numhlines = prop['chart.background.grid.autofit.numhlines'];\n      }\n      if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {\n        numvlines = prop['chart.background.grid.autofit.numvlines'];\n      }\n      co.lineWidth = linewidth;if (variant == '3d') {\n        co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (vlines) {\n        for (var i = 0; i <= numvlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop, this.gutterLeft + this.gutterCenter + this.axisWidth + this.axisWidth / numvlines * i, this.gutterTop + this.axisHeight, color);\n        }\n      }\n      if (hlines) {\n        for (var i = 0; i <= numhlines; i += 1) {\n          pa2(co, 'b m % % l % % s %', this.gutterLeft + this.axisWidth + this.gutterCenter, this.gutterTop + this.axisHeight / numhlines * i, this.gutterLeft + this.axisWidth + this.gutterCenter + this.axisWidth, this.gutterTop + this.axisHeight / numhlines * i, color);\n        }\n      }\n      if (variant == '3d') {\n        co.restore();\n      }\n    }\n  };this.firstDrawFunc = function () {\n    if (prop['chart.tooltips']) {\n      prop['chart.tooltips'] = RG.arrayReverse(prop['chart.tooltips']);\n    }\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  this.grow = function () {\n    var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var obj = this;var originalLeft = RG.arrayClone(this.left);var originalRight = RG.arrayClone(this.right);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < this.left.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.left[i]));\n      }\n      for (var i = 0; i < this.right.length; i += 1) {\n        xmax = ma.max(xmax, ma.abs(this.right[i]));\n      }\n      var scale = RG.getScale2(obj, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var i = 0; i < obj.left.length; i += 1) {\n        obj.left[i] = easingMultiplier * originalLeft[i];\n      }\n      for (var i = 0; i < obj.right.length; i += 1) {\n        obj.right[i] = easingMultiplier * originalRight[i];\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames_left = [];opt.startFrames_right = [];opt.counters_left = [];opt.counters_right = [];var framesperbar = opt.frames / 3,\n        frame_left = -1,\n        frame_right = -1,\n        callback = arguments[1] || function () {},\n        original_left = RG.arrayClone(obj.left),\n        original_right = RG.arrayClone(obj.right);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      opt.startFrames_left[i] = opt.frames / 2 / (obj.left.length - 1) * i;opt.startFrames_right[i] = opt.frames / 2 / (obj.right.length - 1) * i;opt.counters_left[i] = 0;opt.counters_right[i] = 0;\n    }\n    obj.draw();obj.set('xmax', obj.scale2.max);RG.clear(obj.canvas);for (var i = 0, len = obj.left.length; i < len; i += 1) {\n      if (typeof obj.left[i] === 'number') obj.left[i] = 0;if (typeof obj.right[i] === 'number') obj.right[i] = 0;\n    }\n    function iteratorLeft() {\n      ++frame_left;for (var i = 0, len = obj.left.length; i < len; i += 1) {\n        if (frame_left > opt.startFrames_left[i]) {\n          var isNull = RG.isNull(obj.left[i]);obj.left[i] = ma.min(ma.abs(original_left[i]), ma.abs(original_left[i] * (opt.counters_left[i]++ / framesperbar)));if (original_left[i] < 0) {\n            obj.left[i] *= -1;\n          }\n          if (isNull) {\n            obj.left[i] = null;\n          }\n        } else {\n          obj.left[i] = _typeof(obj.left[i]) === 'object' && obj.left[i] ? RG.arrayPad([], obj.left[i].length, 0) : RG.isNull(obj.left[i]) ? null : 0;\n        }\n      }\n      if (frame_left < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorLeft);\n      }\n    }\n    function iteratorRight() {\n      ++frame_right;for (var i = 0, len = obj.right.length; i < len; i += 1) {\n        if (frame_right > opt.startFrames_right[i]) {\n          var isNull = RG.isNull(obj.right[i]);obj.right[i] = ma.min(ma.abs(original_right[i]), ma.abs(original_right[i] * (opt.counters_right[i]++ / framesperbar)));if (original_right[i] < 0) {\n            obj.right[i] *= -1;\n          }\n          if (isNull) {\n            obj.right[i] = null;\n          }\n        } else {\n          obj.right[i] = _typeof(obj.right[i]) === 'object' && obj.right[i] ? RG.arrayPad([], obj.right[i].length, 0) : RG.isNull(obj.right[i]) ? null : 0;\n        }\n      }\n      if (frame_right < opt.frames) {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iteratorRight);\n      } else {\n        callback(this);\n      }\n    }\n    iteratorLeft();iteratorRight();return this;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5iaXBvbGFyLmpzPzNlYmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguQmlwb2xhciA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihjb25mLmxlZnQpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYucmlnaHQpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIGxlZnQgPSBjb25mLmxlZnQsXG4gICAgICAgIHJpZ2h0ID0gY29uZi5yaWdodCxcbiAgICAgICAgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZixcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBsZWZ0ID0gYXJndW1lbnRzWzFdLFxuICAgICAgICByaWdodCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBjYW52YXM7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnR5cGUgPSAnYmlwb2xhcic7dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc0xlZnQgPSBbXTt0aGlzLmNvb3Jkc1JpZ2h0ID0gW107dGhpcy5tYXggPSAwO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTtmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyArK2kpIHtcbiAgICBsZWZ0W2ldID0gcGFyc2VGbG9hdChsZWZ0W2ldKTtcbiAgfWZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHQubGVuZ3RoOyArK2kpIHtcbiAgICByaWdodFtpXSA9IHBhcnNlRmxvYXQocmlnaHRbaV0pO1xuICB9dGhpcy5sZWZ0ID0gbGVmdDt0aGlzLnJpZ2h0ID0gcmlnaHQ7dGhpcy5kYXRhID0gW2xlZnQsIHJpZ2h0XTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzogJyNkZGQnLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5saW5ld2lkdGgnOiAxLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyc6IG51bGwsICdjaGFydC5tYXJnaW4nOiAyLCAnY2hhcnQueHRpY2tpbnRlcnZhbCc6IG51bGwsICdjaGFydC5sYWJlbHMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5jb2xvcic6IG51bGwsICdjaGFydC5sYWJlbHMuYWJvdmUnOiBmYWxzZSwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC50aXRsZS5sZWZ0JzogJycsICdjaGFydC50aXRsZS5yaWdodCc6ICcnLCAnY2hhcnQuZ3V0dGVyLmNlbnRlcic6IDYwLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDMwLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5jb2xvcnMnOiBbJyMwZjAnXSwgJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJzogZmFsc2UsICdjaGFydC5jb250ZXh0bWVudSc6IG51bGwsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJyM2NjYnLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnhtYXgnOiBudWxsLCAnY2hhcnQueG1pbic6IDAsICdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOiB0cnVlLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiBudWxsLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5zY2FsZS50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LmF4aXMuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQuem9vbS5hY3Rpb24nOiAnem9vbScsICdjaGFydC5yZXNpemFibGUnOiBmYWxzZSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC5zdHJva2VzdHlsZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LmxpbmV3aWR0aCc6IDEsICdjaGFydC5ub2F4ZXMnOiBmYWxzZSwgJ2NoYXJ0LnhsYWJlbHMnOiB0cnVlLCAnY2hhcnQubnVteXRpY2tzJzogbnVsbCwgJ2NoYXJ0Lm51bXh0aWNrcyc6IDUsICdjaGFydC5heGlzLmxpbmV3aWR0aCc6IDEsICdjaGFydC5sYWJlbHMuY291bnQnOiA1LCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCc6IDEwLCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSc6IDUsICdjaGFydC52YXJpYW50LnRocmVlZC5hbmdsZSc6IDAuMSwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgd2hpbGUgKHRoaXMubGVmdC5sZW5ndGggPCB0aGlzLnJpZ2h0Lmxlbmd0aCkge1xuICAgIHRoaXMubGVmdC5wdXNoKG51bGwpO1xuICB9d2hpbGUgKHRoaXMubGVmdC5sZW5ndGggPiB0aGlzLnJpZ2h0Lmxlbmd0aCkge1xuICAgIHRoaXMucmlnaHQucHVzaChudWxsKTtcbiAgfXRoaXMucHJvcGVydGllc1snY2hhcnQubnVteXRpY2tzJ10gPSB0aGlzLmxlZnQubGVuZ3RoO3ZhciBsaW5lYXJfZGF0YSA9IFJHcmFwaC5hcnJheUxpbmVhcml6ZSh0aGlzLmxlZnQsIHRoaXMucmlnaHQpO2ZvciAodmFyIGkgPSAwOyBpIDwgbGluZWFyX2RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzWyckJyArIGldID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuZ3V0dGVyQ2VudGVyID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddO3RoaXMubGVmdCA9IHRoaXMuZGF0YVswXTt0aGlzLnJpZ2h0ID0gdGhpcy5kYXRhWzFdO3RoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107aWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddKSB7fSBlbHNlIHtcbiAgICAgICAgY28uc2V0VHJhbnNmb3JtKDEsIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10sIDAsIDEsIDAuNSwgMC41KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5heGlzV2lkdGggPSAoY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10gLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDI7dGhpcy5heGlzSGVpZ2h0ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbTt0aGlzLnNlcXVlbnRpYWxGdWxsSW5kZXggPSAwO3RoaXMuZ2V0TWF4KCk7dGhpcy5kcmF3QmFja2dyb3VuZEdyaWQoKTt0aGlzLmRyYXczREF4ZXMoKTt0aGlzLmRyYXdBeGVzKCk7dGhpcy5kcmF3VGlja3MoKTtjby5zYXZlKCk7Y28uYmVnaW5QYXRoKCk7Y28ucmVjdCh0aGlzLmd1dHRlckxlZnQsIHRoaXMuZ3V0dGVyVG9wIC0gKHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSB8fCAwKSwgY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMiAqIChwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10gfHwgMCkpO2NvLmNsaXAoKTt0aGlzLmRyYXdMZWZ0QmFycygpO3RoaXMuZHJhd1JpZ2h0QmFycygpO3RoaXMuZHJhd0xlZnRCYXJzKHsgc2hhZG93OiBmYWxzZSB9KTt0aGlzLmRyYXdSaWdodEJhcnMoeyBzaGFkb3c6IGZhbHNlIH0pO2NvLnJlc3RvcmUoKTt0aGlzLmRyYXdBeGVzKCk7dGhpcy5kcmF3TGFiZWxzKCk7dGhpcy5kcmF3VGl0bGVzKCk7aWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXczREF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgdmFyIG9mZnNldHggPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sXG4gICAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddICsgMC4wMDE7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5heGlzLmNvbG9yJ107cGEyKGNvLCAnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBzICNhYWEgZiAjZGRkJywgdGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSksIHRoaXMuZ3V0dGVyTGVmdCArIG9mZnNldHgsIG1hLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gb2Zmc2V0eSksIHRoaXMuZ3V0dGVyTGVmdCArIG9mZnNldHggKyB0aGlzLmF4aXNXaWR0aCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSBvZmZzZXR5KSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGgsIG1hLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7dGhpcy5kcmF3M0RMZWZ0VmVydGljYWxBeGlzKCk7cGEyKGNvLCAnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBzICNhYWEgZiAjZGRkJywgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pLCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmd1dHRlckNlbnRlciArIHRoaXMuYXhpc1dpZHRoICsgb2Zmc2V0eCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSBvZmZzZXR5KSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCArIHRoaXMuYXhpc1dpZHRoICsgb2Zmc2V0eCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSBvZmZzZXR5KSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCArIHRoaXMuYXhpc1dpZHRoLCBtYS5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO3BhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAjYWFhIGYgI2RkZCcsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuZ3V0dGVyQ2VudGVyICsgdGhpcy5heGlzV2lkdGgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tLCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmd1dHRlckNlbnRlciArIHRoaXMuYXhpc1dpZHRoLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSAtIHRoaXMuYXhpc0hlaWdodCwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCArIG9mZnNldHgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gdGhpcy5heGlzSGVpZ2h0IC0gb2Zmc2V0eSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCArIG9mZnNldHgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gb2Zmc2V0eSk7XG4gICAgfVxuICB9O1xuICB0aGlzLmRyYXczRExlZnRWZXJ0aWNhbEF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgdmFyIG9mZnNldHggPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sXG4gICAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgI2FhYSBmICNkZGQnLCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aCwgdGhpcy5ndXR0ZXJUb3AsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgb2Zmc2V0eCwgdGhpcy5ndXR0ZXJUb3AgLSBvZmZzZXR5LCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aCArIG9mZnNldHgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gb2Zmc2V0eSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICB9XG4gIH07dGhpcy5kcmF3QXhlcyA9IHRoaXMuRHJhd0F4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSArIDAuMDAxO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO3RoaXMuYXhpc1dpZHRoID0gKGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyO3RoaXMuYXhpc0hlaWdodCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207aWYgKHByb3BbJ2NoYXJ0Lm5vYXhlcyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsIE1hdGgucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGgsIE1hdGgucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5tb3ZlVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGgpLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoKSwgdGhpcy5ndXR0ZXJUb3ApO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO3ZhciB4ID0gdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGggKyBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ107Y28ubW92ZVRvKE1hdGgucm91bmQoeCksIHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4KSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHgpLCBNYXRoLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgTWF0aC5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO2NvLnN0cm9rZSgpO1xuICB9O3RoaXMuZHJhd1RpY2tzID0gdGhpcy5EcmF3VGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSArIDAuMDAxO3ZhciBudW1EYXRhUG9pbnRzID0gdGhpcy5sZWZ0Lmxlbmd0aDt2YXIgYmFySGVpZ2h0ID0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20gLSB0aGlzLmxlZnQubGVuZ3RoICogKHByb3BbJ2NoYXJ0Lm1hcmdpbiddICogMikpIC8gbnVtRGF0YVBvaW50czt0aGlzLmJhckhlaWdodCA9IGJhckhlaWdodDtpZiAocHJvcFsnY2hhcnQubm9heGVzJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddID4gMCkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5udW15dGlja3MnXTsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddICsgKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gcHJvcFsnY2hhcnQubnVteXRpY2tzJ10gKiBpO2NvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aCwgeSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgMywgeSk7XG4gICAgICB9XG4gICAgICBjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddOyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gKyAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyBwcm9wWydjaGFydC5udW15dGlja3MnXSAqIGk7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddLCB5KTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGggKyBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10gLSAzLCB5KTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubnVteHRpY2tzJ10gPiAwKSB7XG4gICAgICB2YXIgeEludGVydmFsID0gdGhpcy5heGlzV2lkdGggLyBwcm9wWydjaGFydC5udW14dGlja3MnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0Lnh0aWNraW50ZXJ2YWwnXSA9PSAnbnVtYmVyJykge1xuICAgICAgICB4SW50ZXJ2YWwgPSBwcm9wWydjaGFydC54dGlja2ludGVydmFsJ107XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSB0aGlzLmd1dHRlckxlZnQ7IGkgPCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aDsgaSArPSB4SW50ZXJ2YWwpIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoaSksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8oTWF0aC5yb3VuZChpKSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyA0KTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdG9wcGluZ1BvaW50ID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0O2ZvciAoaSA9IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddICsgeEludGVydmFsOyBpIDw9IHN0b3BwaW5nUG9pbnQ7IGkgKz0geEludGVydmFsKSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKGkpLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSk7Y28ubGluZVRvKE1hdGgucm91bmQoaSksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgNCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZ2V0TWF4ID0gdGhpcy5HZXRNYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlYyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107aWYgKHByb3BbJ2NoYXJ0LnhtYXgnXSkge1xuICAgICAgdmFyIG1heCA9IHByb3BbJ2NoYXJ0LnhtYXgnXTt2YXIgbWluID0gcHJvcFsnY2hhcnQueG1pbiddO3RoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IG1heCwgJ21pbic6IG1pbiwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlMi5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChSRy5hcnJheV9tYXgodGhpcy5sZWZ0KSwgUkcuYXJyYXlfbWF4KHRoaXMucmlnaHQpKTt0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiBtYXgsICdtaW4nOiBwcm9wWydjaGFydC54bWluJ10sICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlMi5taW47XG4gICAgfVxuICB9O3RoaXMuZHJhd0xlZnRCYXJzID0gdGhpcy5EcmF3TGVmdEJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IHt9O2lmIChfdHlwZW9mKGFyZ3VtZW50c1swXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHQuc2hhZG93ID0gYXJndW1lbnRzWzBdLnNoYWRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LnNoYWRvdyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBvZmZzZXR4ID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLFxuICAgICAgICBvZmZzZXR5ID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtmb3IgKHZhciBpID0gdGhpcy5sZWZ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10gJiYgcHJvcFsnY2hhcnQudmFyaWFudCddICE9PSAnM2QnICYmIG9wdC5zaGFkb3cpIHtcbiAgICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07XG4gICAgICB9XG4gICAgICB2YXIgd2lkdGggPSAodGhpcy5sZWZ0W2ldIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogdGhpcy5heGlzV2lkdGg7dmFyIGNvb3JkcyA9IFttYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aCAtIHdpZHRoKSwgbWEucm91bmQodGhpcy5ndXR0ZXJUb3AgKyBpICogKHRoaXMuYXhpc0hlaWdodCAvIHRoaXMubGVmdC5sZW5ndGgpICsgcHJvcFsnY2hhcnQubWFyZ2luJ10pLCB3aWR0aCwgdGhpcy5iYXJIZWlnaHRdO2lmIChSRy5JU09MRCAmJiBwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICB0aGlzLmRyYXdJRVNoYWRvdyhjb29yZHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGVmdFtpXSAhPT0gbnVsbCkge1xuICAgICAgICBjby5zdHJva2VSZWN0KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSk7Y28uZmlsbFJlY3QoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcgJiYgdGhpcy5sZWZ0W2ldICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSAmJiBvcHQuc2hhZG93KSB7XG4gICAgICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGYgYmxhY2sgc2MgcmdiYSgwLDAsMCwwKSBzeCAwIHN5IDAgc2IgMCcsIGNvb3Jkc1swXSArIG9mZnNldHgsIGNvb3Jkc1sxXSAtIG9mZnNldHksIGNvb3Jkc1swXSArIG9mZnNldHggKyBjb29yZHNbMl0sIGNvb3Jkc1sxXSAtIG9mZnNldHksIGNvb3Jkc1swXSArIG9mZnNldHggKyBjb29yZHNbMl0sIGNvb3Jkc1sxXSAtIG9mZnNldHkgKyBjb29yZHNbM10sIGNvb3Jkc1swXSArIG9mZnNldHgsIGNvb3Jkc1sxXSAtIG9mZnNldHkgKyBjb29yZHNbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11baV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07XG4gICAgICAgIH1cbiAgICAgICAgcGEyKGNvLCAnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmICUnLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgY29vcmRzWzJdLCBjb29yZHNbMV0pO3BhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiByZ2JhKDI1NSwyNTUsMjU1LDAuNCknLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgY29vcmRzWzJdLCBjb29yZHNbMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3M0RMZWZ0VmVydGljYWxBeGlzKCk7dGhpcy5jb29yZHMucHVzaChbY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdXSk7dGhpcy5jb29yZHNMZWZ0LnB1c2goW2Nvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXV0pO1xuICAgIH1cbiAgICBSRy5ub1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGggPSAxO1xuICB9O3RoaXMuZHJhd1JpZ2h0QmFycyA9IHRoaXMuRHJhd1JpZ2h0QmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0ID0ge307aWYgKF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdC5zaGFkb3cgPSBhcmd1bWVudHNbMF0uc2hhZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQuc2hhZG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9mZnNldHggPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sXG4gICAgICAgIG9mZnNldHkgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSAmJiBwcm9wWydjaGFydC52YXJpYW50J10gIT09ICczZCcgJiYgb3B0LnNoYWRvdykge1xuICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucmlnaHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07XG4gICAgICB9XG4gICAgICB2YXIgd2lkdGggPSAodGhpcy5yaWdodFtpXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMuYXhpc1dpZHRoO3ZhciBjb29yZHMgPSBbbWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGggKyBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10pLCBtYS5yb3VuZChwcm9wWydjaGFydC5tYXJnaW4nXSArIGkgKiAodGhpcy5heGlzSGVpZ2h0IC8gdGhpcy5yaWdodC5sZW5ndGgpICsgdGhpcy5ndXR0ZXJUb3ApLCB3aWR0aCwgdGhpcy5iYXJIZWlnaHRdO2lmIChSRy5JU09MRCAmJiBwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICB0aGlzLkRyYXdJRVNoYWRvdyhjb29yZHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmlnaHRbaV0gIT09IG51bGwpIHtcbiAgICAgICAgY28uc3Ryb2tlUmVjdChtYS5yb3VuZChjb29yZHNbMF0pLCBNYXRoLnJvdW5kKGNvb3Jkc1sxXSksIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtjby5maWxsUmVjdChtYS5yb3VuZChjb29yZHNbMF0pLCBNYXRoLnJvdW5kKGNvb3Jkc1sxXSksIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcgJiYgdGhpcy5yaWdodFtpXSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY29sb3IgPSBjby5maWxsU3R5bGU7aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddICYmIG9wdC5zaGFkb3cpIHtcbiAgICAgICAgICBjby5zaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddO2NvLnNoYWRvd0JsdXIgPSBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFggPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO3BhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiBibGFjayBzYyByZ2JhKDAsMCwwLDApIHN4IDAgc3kgMCBzYiAwJywgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSArIGNvb3Jkc1szXSwgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSArIGNvb3Jkc1szXSk7XG4gICAgICAgIH1cbiAgICAgICAgcGEyKGNvLCAnYiBtICUgJSBsICUgJSBsICUgJSBsICUgJSBmICUnLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgY29vcmRzWzJdLCBjb29yZHNbMV0sIGNvbG9yKTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGYgJScsIGNvb3Jkc1swXSArIGNvb3Jkc1syXSwgY29vcmRzWzFdLCBjb29yZHNbMF0gKyBjb29yZHNbMl0gKyBvZmZzZXR4LCBjb29yZHNbMV0gLSBvZmZzZXR5LCBjb29yZHNbMF0gKyBjb29yZHNbMl0gKyBvZmZzZXR4LCBjb29yZHNbMV0gLSBvZmZzZXR5ICsgY29vcmRzWzNdLCBjb29yZHNbMF0gKyBjb29yZHNbMl0sIGNvb3Jkc1sxXSArIGNvb3Jkc1szXSwgY29sb3IpO3BhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiByZ2JhKDI1NSwyNTUsMjU1LDAuNiknLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgb2Zmc2V0eCArIGNvb3Jkc1syXSwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgY29vcmRzWzJdLCBjb29yZHNbMV0pO3BhMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgZiByZ2JhKDAsMCwwLDAuMyknLCBjb29yZHNbMF0gKyBjb29yZHNbMl0sIGNvb3Jkc1sxXSwgY29vcmRzWzBdICsgY29vcmRzWzJdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSwgY29vcmRzWzBdICsgY29vcmRzWzJdICsgb2Zmc2V0eCwgY29vcmRzWzFdIC0gb2Zmc2V0eSArIGNvb3Jkc1szXSwgY29vcmRzWzBdICsgY29vcmRzWzJdLCBjb29yZHNbMV0gKyBjb29yZHNbM10pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb29yZHMucHVzaChbY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdXSk7dGhpcy5jb29yZHNSaWdodC5wdXNoKFtjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM11dKTtcbiAgICB9XG4gICAgUkcuTm9TaGFkb3codGhpcyk7Y28ubGluZVdpZHRoID0gMTtcbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3InXSB8fCBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgbGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzJ10sXG4gICAgICAgIGJhckFyZWFIZWlnaHQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tO1xuICAgIGNvLmZpbGxTdHlsZSA9IGNvbG9yO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2NvbG9yJzogY29sb3IsICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddIC8gMiwgJ3knOiB0aGlzLmd1dHRlclRvcCArIGJhckFyZWFIZWlnaHQgLyBsYWJlbHMubGVuZ3RoICogaSArIGJhckFyZWFIZWlnaHQgLyBsYWJlbHMubGVuZ3RoIC8gMiwgJ3RleHQnOiBTdHJpbmcobGFiZWxzW2ldID8gU3RyaW5nKGxhYmVsc1tpXSkgOiAnJyksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAnbWFya2VyJzogZmFsc2UsICd0YWcnOiAnbGFiZWxzJyB9KTtcbiAgICB9XG4gICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmIChwcm9wWydjaGFydC54bGFiZWxzJ10pIHtcbiAgICAgIHZhciBncmFwaGFyZWEgPSAoY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10gLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDI7Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB0aGlzLmd1dHRlckxlZnQgKyBncmFwaGFyZWEgLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoICogaSwgJ3knOiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIDMsICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggLSBpIC0gMV0sICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIGdyYXBoYXJlYSArIHByb3BbJ2NoYXJ0Lmd1dHRlci5jZW50ZXInXSArIGdyYXBoYXJlYSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggKiAoaSArIDEpLCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMywgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSkge1xuICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoLCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMywgJ3RleHQnOiAnMCcsICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgdGhpcy5ndXR0ZXJDZW50ZXIsICd5JzogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyAzLCAndGV4dCc6ICcwJywgJ3ZhbGlnbic6ICd0b3AnLCAnaGFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlJ10pIHtcbiAgICAgIHZhciBjb29yZHNMZWZ0ID0gUkcuYXJyYXlSZXZlcnNlKHRoaXMuY29vcmRzTGVmdCk7Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHNMZWZ0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZWZ0W2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb29yZHMgPSBjb29yZHNMZWZ0W2ldO1JHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogY29vcmRzWzBdIC0gNSwgeTogY29vcmRzWzFdICsgY29vcmRzWzNdIC8gMiwgdGV4dDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMubGVmdFtpXSwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSksIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogJ3JpZ2h0JywgdGFnOiAnbGFiZWxzLmFib3ZlJyB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29yZHNSaWdodCA9IFJHLmFycmF5UmV2ZXJzZSh0aGlzLmNvb3Jkc1JpZ2h0KTtmb3IgKGkgPSAwOyBpIDwgY29vcmRzUmlnaHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJpZ2h0W2ldICE9ICdudW1iZXInKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvb3JkcyA9IGNvb3Jkc1JpZ2h0W2ldO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY29vcmRzWzBdICsgY29vcmRzWzJdICsgNSwgJ3knOiBjb29yZHNbMV0gKyBjb29yZHNbM10gLyAyLCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgdGhpcy5yaWdodFtpXSwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdsZWZ0JywgJ3RhZyc6ICdsYWJlbHMuYWJvdmUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdUaXRsZXMgPSB0aGlzLkRyYXdUaXRsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIDUsICd5JzogdGhpcy5ndXR0ZXJUb3AgLSA1LCAndGV4dCc6IFN0cmluZyhwcm9wWydjaGFydC50aXRsZS5sZWZ0J10pLCAnaGFsaWduJzogJ2xlZnQnLCAndmFsaWduJzogJ2JvdHRvbScsICd0YWcnOiAndGl0bGUubGVmdCcgfSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIDUsICd5JzogdGhpcy5ndXR0ZXJUb3AgLSA1LCAndGV4dCc6IFN0cmluZyhwcm9wWydjaGFydC50aXRsZS5yaWdodCddKSwgJ2hhbGlnbic6ICdyaWdodCcsICd2YWxpZ24nOiAnYm90dG9tJywgJ3RhZyc6ICd0aXRsZS5yaWdodCcgfSk7UkcuZHJhd1RpdGxlKHRoaXMsIHByb3BbJ2NoYXJ0LnRpdGxlJ10sIHRoaXMuZ3V0dGVyVG9wLCBudWxsLCBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gPyBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gOiBudWxsKTtcbiAgfTt0aGlzLmRyYXdJRVNoYWRvdyA9IHRoaXMuRHJhd0lFU2hhZG93ID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHZhciBwcmV2RmlsbFN0eWxlID0gY28uZmlsbFN0eWxlO3ZhciBvZmZzZXR4ID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTt2YXIgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J107Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFJlY3QoY29vcmRzWzBdICsgb2Zmc2V0eCwgY29vcmRzWzFdICsgb2Zmc2V0eSwgY29vcmRzWzJdLCBjb29yZHNbM10pO2NvLmZpbGwoKTtjby5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlO1xuICB9O1xuICB0aGlzLmdldFNoYXBlID0gdGhpcy5nZXRCYXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgbW91c2VDb29yZHMgPSBSRy5nZXRNb3VzZVhZKGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtb3VzZVggPSBtb3VzZUNvb3Jkc1swXSxcbiAgICAgICAgICBtb3VzZVkgPSBtb3VzZUNvb3Jkc1sxXSxcbiAgICAgICAgICBsZWZ0ID0gdGhpcy5jb29yZHNbaV1bMF0sXG4gICAgICAgICAgdG9wID0gdGhpcy5jb29yZHNbaV1bMV0sXG4gICAgICAgICAgd2lkdGggPSB0aGlzLmNvb3Jkc1tpXVsyXSxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvb3Jkc1tpXVszXTtcbiAgICAgIHBhMihjbywgJ2IgciAlICUgJSAlJywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtpZiAoY28uaXNQb2ludEluUGF0aChtb3VzZVgsIG1vdXNlWSkpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGkpO3JldHVybiB7IDA6IHRoaXMsIDE6IGxlZnQsIDI6IHRvcCwgMzogd2lkdGgsIDQ6IGhlaWdodCwgNTogaSwgJ29iamVjdCc6IHRoaXMsICd4JzogbGVmdCwgJ3knOiB0b3AsICd3aWR0aCc6IHdpZHRoLCAnaGVpZ2h0JzogaGVpZ2h0LCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlJlY3QodGhpcywgc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgb2JqID0gZS50YXJnZXQuX19vYmplY3RfXzt2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07aWYgKG1vdXNlWCA+IHRoaXMuZ3V0dGVyTGVmdCAmJiBtb3VzZVggPCBjYS53aWR0aCAvIDIgLSBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10gLyAyKSB7XG4gICAgICB2YXIgdmFsdWUgPSAobW91c2VYIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSkgLyB0aGlzLmF4aXNXaWR0aDt2YWx1ZSA9IHRoaXMubWF4IC0gdmFsdWUgKiB0aGlzLm1heDtcbiAgICB9XG4gICAgaWYgKG1vdXNlWCA8IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAmJiBtb3VzZVggPiBjYS53aWR0aCAvIDIgKyBwcm9wWydjaGFydC5ndXR0ZXIuY2VudGVyJ10gLyAyKSB7XG4gICAgICB2YXIgdmFsdWUgPSAobW91c2VYIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAtIHRoaXMuYXhpc1dpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmNlbnRlciddKSAvIHRoaXMuYXhpc1dpZHRoO3ZhbHVlID0gdmFsdWUgKiB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcpIHtcbiAgICAgIHZhciBhZGp1c3RtZW50ID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuYW5nbGUnXSAqIG1vdXNlWFlbMF07bW91c2VYWVsxXSAtPSBhZGp1c3RtZW50O1xuICAgIH1cbiAgICBpZiAobW91c2VYWVswXSA+IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gJiYgbW91c2VYWVswXSA8IGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10gJiYgbW91c2VYWVsxXSA+IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSAmJiBtb3VzZVhZWzFdIDwgY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5nZXRYQ29vcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heCB8fCB2YWx1ZSA8IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107dmFyIG9mZnNldCA9IHZhbHVlIC8gdGhpcy5tYXggKiB0aGlzLmF4aXNXaWR0aDtyZXRbMF0gPSB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmF4aXNXaWR0aCAtIG9mZnNldDtyZXRbMV0gPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSB0aGlzLmF4aXNXaWR0aCArIG9mZnNldDtyZXR1cm4gcmV0O1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5heGlzLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5heGlzLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllczt2YXIgY29sb3JzID0gcHJvcHNbJ2NoYXJ0LmNvbG9ycyddO2ZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO1xuICAgIH1cbiAgICBwcm9wc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcHNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcHNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcHNbJ2NoYXJ0LmF4aXMuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BzWydjaGFydC5heGlzLmNvbG9yJ10pO3Byb3BzWydjaGFydC5zdHJva2VzdHlsZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcHNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQocHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSwgMCwgY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgMCk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdCYWNrZ3JvdW5kR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkJ10pIHtcbiAgICAgIHZhciB2YXJpYW50ID0gcHJvcFsnY2hhcnQudmFyaWFudCddLFxuICAgICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10sXG4gICAgICAgICAgbnVtdmxpbmVzID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sXG4gICAgICAgICAgbnVtaGxpbmVzID0gdGhpcy5sZWZ0Lmxlbmd0aCxcbiAgICAgICAgICB2bGluZXMgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJ10sXG4gICAgICAgICAgaGxpbmVzID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyddLFxuICAgICAgICAgIGxpbmV3aWR0aCA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5saW5ld2lkdGgnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyddID09PSAnbnVtYmVyJykge1xuICAgICAgICBudW1obGluZXMgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG51bXZsaW5lcyA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyddO1xuICAgICAgfVxuICAgICAgY28ubGluZVdpZHRoID0gbGluZXdpZHRoO2lmICh2YXJpYW50ID09ICczZCcpIHtcbiAgICAgICAgY28uc2F2ZSgpO2NvLnRyYW5zbGF0ZShwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sIC0xICogcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtdmxpbmVzOyBpICs9IDEpIHtcbiAgICAgICAgICBwYTIoY28sICdiIG0gJSAlIGwgJSAlIHMgJScsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoIC8gbnVtdmxpbmVzICogaSwgdGhpcy5ndXR0ZXJUb3AsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoIC8gbnVtdmxpbmVzICogaSwgdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmF4aXNIZWlnaHQsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhsaW5lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW1obGluZXM7IGkgKz0gMSkge1xuICAgICAgICAgIHBhMihjbywgJ2IgbSAlICUgbCAlICUgcyAlJywgdGhpcy5ndXR0ZXJMZWZ0LCB0aGlzLmd1dHRlclRvcCArIHRoaXMuYXhpc0hlaWdodCAvIG51bWhsaW5lcyAqIGksIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoLCB0aGlzLmd1dHRlclRvcCArIHRoaXMuYXhpc0hlaWdodCAvIG51bWhsaW5lcyAqIGksIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZsaW5lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW12bGluZXM7IGkgKz0gMSkge1xuICAgICAgICAgIHBhMihjbywgJ2IgbSAlICUgbCAlICUgcyAlJywgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ndXR0ZXJDZW50ZXIgKyB0aGlzLmF4aXNXaWR0aCArIHRoaXMuYXhpc1dpZHRoIC8gbnVtdmxpbmVzICogaSwgdGhpcy5ndXR0ZXJUb3AsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuZ3V0dGVyQ2VudGVyICsgdGhpcy5heGlzV2lkdGggKyB0aGlzLmF4aXNXaWR0aCAvIG51bXZsaW5lcyAqIGksIHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5heGlzSGVpZ2h0LCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChobGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtaGxpbmVzOyBpICs9IDEpIHtcbiAgICAgICAgICBwYTIoY28sICdiIG0gJSAlIGwgJSAlIHMgJScsIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuYXhpc1dpZHRoICsgdGhpcy5ndXR0ZXJDZW50ZXIsIHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5heGlzSGVpZ2h0IC8gbnVtaGxpbmVzICogaSwgdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5heGlzV2lkdGggKyB0aGlzLmd1dHRlckNlbnRlciArIHRoaXMuYXhpc1dpZHRoLCB0aGlzLmd1dHRlclRvcCArIHRoaXMuYXhpc0hlaWdodCAvIG51bWhsaW5lcyAqIGksIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhcmlhbnQgPT0gJzNkJykge1xuICAgICAgICBjby5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMnXSkge1xuICAgICAgcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA9IFJHLmFycmF5UmV2ZXJzZShwcm9wWydjaGFydC50b29sdGlwcyddKTtcbiAgICB9XG4gIH07UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbiAgdGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIG9iaiA9IHRoaXM7dmFyIG9yaWdpbmFsTGVmdCA9IFJHLmFycmF5Q2xvbmUodGhpcy5sZWZ0KTt2YXIgb3JpZ2luYWxSaWdodCA9IFJHLmFycmF5Q2xvbmUodGhpcy5yaWdodCk7aWYgKFJHLmlzTnVsbChwcm9wWydjaGFydC54bWF4J10pKSB7XG4gICAgICB2YXIgeG1heCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlZnQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgeG1heCA9IG1hLm1heCh4bWF4LCBtYS5hYnModGhpcy5sZWZ0W2ldKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmlnaHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgeG1heCA9IG1hLm1heCh4bWF4LCBtYS5hYnModGhpcy5yaWdodFtpXSkpO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlID0gUkcuZ2V0U2NhbGUyKG9iaiwgeyAnbWF4JzogeG1heCB9KTt0aGlzLlNldCgnY2hhcnQueG1heCcsIHNjYWxlLm1heCk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgdmFyIGVhc2luZ011bHRpcGxpZXIgPSBSRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLCBmcmFtZSk7Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVmdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvYmoubGVmdFtpXSA9IGVhc2luZ011bHRpcGxpZXIgKiBvcmlnaW5hbExlZnRbaV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5yaWdodC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvYmoucmlnaHRbaV0gPSBlYXNpbmdNdWx0aXBsaWVyICogb3JpZ2luYWxSaWdodFtpXTtcbiAgICAgIH1cbiAgICAgIFJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgZnJhbWUgKz0gMTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH07aXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLndhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTtvcHQuZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDtvcHQuc3RhcnRGcmFtZXNfbGVmdCA9IFtdO29wdC5zdGFydEZyYW1lc19yaWdodCA9IFtdO29wdC5jb3VudGVyc19sZWZ0ID0gW107b3B0LmNvdW50ZXJzX3JpZ2h0ID0gW107dmFyIGZyYW1lc3BlcmJhciA9IG9wdC5mcmFtZXMgLyAzLFxuICAgICAgICBmcmFtZV9sZWZ0ID0gLTEsXG4gICAgICAgIGZyYW1lX3JpZ2h0ID0gLTEsXG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvcmlnaW5hbF9sZWZ0ID0gUkcuYXJyYXlDbG9uZShvYmoubGVmdCksXG4gICAgICAgIG9yaWdpbmFsX3JpZ2h0ID0gUkcuYXJyYXlDbG9uZShvYmoucmlnaHQpO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3B0LnN0YXJ0RnJhbWVzX2xlZnRbaV0gPSBvcHQuZnJhbWVzIC8gMiAvIChvYmoubGVmdC5sZW5ndGggLSAxKSAqIGk7b3B0LnN0YXJ0RnJhbWVzX3JpZ2h0W2ldID0gb3B0LmZyYW1lcyAvIDIgLyAob2JqLnJpZ2h0Lmxlbmd0aCAtIDEpICogaTtvcHQuY291bnRlcnNfbGVmdFtpXSA9IDA7b3B0LmNvdW50ZXJzX3JpZ2h0W2ldID0gMDtcbiAgICB9XG4gICAgb2JqLmRyYXcoKTtvYmouc2V0KCd4bWF4Jywgb2JqLnNjYWxlMi5tYXgpO1JHLmNsZWFyKG9iai5jYW52YXMpO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVmdFtpXSA9PT0gJ251bWJlcicpIG9iai5sZWZ0W2ldID0gMDtpZiAodHlwZW9mIG9iai5yaWdodFtpXSA9PT0gJ251bWJlcicpIG9iai5yaWdodFtpXSA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yTGVmdCgpIHtcbiAgICAgICsrZnJhbWVfbGVmdDtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGZyYW1lX2xlZnQgPiBvcHQuc3RhcnRGcmFtZXNfbGVmdFtpXSkge1xuICAgICAgICAgIHZhciBpc051bGwgPSBSRy5pc051bGwob2JqLmxlZnRbaV0pO29iai5sZWZ0W2ldID0gbWEubWluKG1hLmFicyhvcmlnaW5hbF9sZWZ0W2ldKSwgbWEuYWJzKG9yaWdpbmFsX2xlZnRbaV0gKiAob3B0LmNvdW50ZXJzX2xlZnRbaV0rKyAvIGZyYW1lc3BlcmJhcikpKTtpZiAob3JpZ2luYWxfbGVmdFtpXSA8IDApIHtcbiAgICAgICAgICAgIG9iai5sZWZ0W2ldICo9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNOdWxsKSB7XG4gICAgICAgICAgICBvYmoubGVmdFtpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5sZWZ0W2ldID0gX3R5cGVvZihvYmoubGVmdFtpXSkgPT09ICdvYmplY3QnICYmIG9iai5sZWZ0W2ldID8gUkcuYXJyYXlQYWQoW10sIG9iai5sZWZ0W2ldLmxlbmd0aCwgMCkgOiBSRy5pc051bGwob2JqLmxlZnRbaV0pID8gbnVsbCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZV9sZWZ0IDwgb3B0LmZyYW1lcykge1xuICAgICAgICBSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3JMZWZ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0b3JSaWdodCgpIHtcbiAgICAgICsrZnJhbWVfcmlnaHQ7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZnJhbWVfcmlnaHQgPiBvcHQuc3RhcnRGcmFtZXNfcmlnaHRbaV0pIHtcbiAgICAgICAgICB2YXIgaXNOdWxsID0gUkcuaXNOdWxsKG9iai5yaWdodFtpXSk7b2JqLnJpZ2h0W2ldID0gbWEubWluKG1hLmFicyhvcmlnaW5hbF9yaWdodFtpXSksIG1hLmFicyhvcmlnaW5hbF9yaWdodFtpXSAqIChvcHQuY291bnRlcnNfcmlnaHRbaV0rKyAvIGZyYW1lc3BlcmJhcikpKTtpZiAob3JpZ2luYWxfcmlnaHRbaV0gPCAwKSB7XG4gICAgICAgICAgICBvYmoucmlnaHRbaV0gKj0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc051bGwpIHtcbiAgICAgICAgICAgIG9iai5yaWdodFtpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5yaWdodFtpXSA9IF90eXBlb2Yob2JqLnJpZ2h0W2ldKSA9PT0gJ29iamVjdCcgJiYgb2JqLnJpZ2h0W2ldID8gUkcuYXJyYXlQYWQoW10sIG9iai5yaWdodFtpXS5sZW5ndGgsIDApIDogUkcuaXNOdWxsKG9iai5yaWdodFtpXSkgPyBudWxsIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZyYW1lX3JpZ2h0IDwgb3B0LmZyYW1lcykge1xuICAgICAgICBSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3JSaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3JMZWZ0KCk7aXRlcmF0b3JSaWdodCgpO3JldHVybiB0aGlzO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguYmlwb2xhci5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///163\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.annotating_canvas_onmousedown = function (e) {\n    if (e.button === 0) {\n      e.target.__object__.Set('chart.mousedown', true);var obj = e.target.__object__,\n          prop = obj.properties;\n      obj.context.beginPath();obj.context.strokeStyle = obj.Get('chart.annotate.color');obj.context.lineWidth = obj.Get('chart.annotate.linewidth');var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      RG.Registry.Set('annotate.actions', [obj.Get('chart.annotate.color')]);obj.context.moveTo(mouseX, mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.Registry.Set('started.annotating', false);RG.Registry.Set('chart.annotating', obj);RG.FireCustomEvent(obj, 'onannotatebegin');\n    }\n    return false;\n  };RG.annotating_window_onmouseup = function (e) {\n    var obj = RG.Registry.Get('chart.annotating');var win = window;if (e.button != 0 || !obj) {\n      return;\n    }\n    var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n      if (tags[i].__object__) {\n        tags[i].__object__.Set('chart.mousedown', false);\n      }\n    }\n    if (RG.Registry.Get('annotate.actions') && RG.Registry.Get('annotate.actions').length > 0 && win.localStorage) {\n      var id = '__rgraph_annotations_' + e.target.id + '__';var annotations = win.localStorage[id] ? win.localStorage[id] + '|' : '';annotations += RG.Registry.Get('annotate.actions');win.localStorage[id] = annotations;\n    }\n    RG.Registry.Set('annotate.actions', []);RG.FireCustomEvent(obj, 'onannotateend');\n  };RGraph.annotating_canvas_onmousemove = function (e) {\n    var obj = e.target.__object__;var prop = obj.properties;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var lastXY = RG.Registry.Get('annotate.last.coordinates');if (obj.Get('chart.mousedown')) {\n      if (obj.type === 'bar' && prop['chart.variant'] === '3d') {\n        var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseY -= adjustment;\n      }\n      obj.context.beginPath();if (!lastXY) {\n        obj.context.moveTo(mouseX, mouseY);\n      } else {\n        obj.context.strokeStyle = obj.properties['chart.annotate.color'];obj.context.moveTo(lastXY[0], lastXY[1]);obj.context.lineTo(mouseX, mouseY);\n      }\n      RG.Registry.Set('annotate.actions', RG.Registry.Get('annotate.actions') + '|' + mouseX + ',' + mouseY);RG.Registry.Set('annotate.last.coordinates', [mouseX, mouseY]);RG.FireCustomEvent(obj, 'onannotate');obj.context.stroke();\n    }\n  };RG.ShowPalette = RG.Showpalette = function (e) {\n    var isSafari = navigator.userAgent.indexOf('Safari') ? true : false;e = RG.FixEventObject(e);var canvas = e.target.parentNode.__canvas__,\n        context = canvas.getContext('2d'),\n        obj = canvas.__object__,\n        div = document.createElement('DIV'),\n        coords = RG.getMouseXY(e);\n    div.__object__ = obj;div.className = 'RGraph_palette';div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.left = 0;div.style.top = 0;div.style.padding = '3px';div.style.paddingLeft = '5px';div.style.opacity = 0;div.style.boxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';div.style.MozBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';var colors = ['Black', 'Red', 'Yellow', 'Green', 'Orange', 'White', 'Magenta', 'Pink'];for (var i = 0, len = colors.length; i < len; i += 1) {\n      var div2 = doc.createElement('DIV');div2.cssClass = 'RGraph_palette_color';div2.style.fontSize = '12pt';div2.style.cursor = 'pointer';div2.style.padding = '1px';div2.style.paddingRight = '10px';div2.style.textAlign = 'left';var span = document.createElement('SPAN');span.style.display = 'inline-block';span.style.marginRight = '9px';span.style.width = '17px';span.style.height = '17px';span.style.top = '2px';span.style.position = 'relative';span.style.backgroundColor = colors[i];div2.appendChild(span);div2.innerHTML += colors[i];div2.onmouseover = function () {\n        this.style.backgroundColor = '#eee';\n      };\n      div2.onmouseout = function () {\n        this.style.backgroundColor = '';\n      };\n      div2.onclick = function (e) {\n        var color = this.childNodes[0].style.backgroundColor;obj.Set('chart.annotate.color', color);\n      };\n      div.appendChild(div2);\n    }\n    doc.body.appendChild(div);div.style.left = e.pageX + 'px';div.style.top = e.pageY + 'px';if (e.pageX + (div.offsetWidth + 5) > document.body.offsetWidth) {\n      div.style.left = e.pageX - div.offsetWidth + 'px';\n    }\n    RGraph.Registry.Set('chart.palette', div);setTimeout(function () {\n      div.style.opacity = 0.2;\n    }, 50);setTimeout(function () {\n      div.style.opacity = 0.4;\n    }, 100);setTimeout(function () {\n      div.style.opacity = 0.6;\n    }, 150);setTimeout(function () {\n      div.style.opacity = 0.8;\n    }, 200);setTimeout(function () {\n      div.style.opacity = 1;\n    }, 250);RGraph.hideContext();window.onclick = function () {\n      RG.hidePalette();\n    };\n    e.stopPropagation();return false;\n  };RG.clearAnnotations = RG.ClearAnnotations = function (canvas) {\n    if (typeof canvas === 'string') {\n      var id = canvas;canvas = doc.getElementById(id);\n    } else {\n      var id = canvas.id;\n    }\n    var obj = canvas.__object__;if (win.localStorage && win.localStorage['__rgraph_annotations_' + id + '__'] && win.localStorage['__rgraph_annotations_' + id + '__'].length) {\n      win.localStorage['__rgraph_annotations_' + id + '__'] = [];RGraph.FireCustomEvent(obj, 'onannotateclear');\n    }\n  };RG.replayAnnotations = RG.ReplayAnnotations = function (obj) {\n    if (!win.localStorage) {\n      return;\n    }\n    var context = obj.context;var annotations = win.localStorage['__rgraph_annotations_' + obj.id + '__'];var i, len, move, coords;context.beginPath();context.lineWidth = obj.Get('annotate.linewidth');if (annotations && annotations.length) {\n      annotations = annotations.split('|');\n    } else {\n      return;\n    }\n    for (i = 0, len = annotations.length; i < len; ++i) {\n      if (annotations[i].match(/[a-z]+/)) {\n        context.stroke();context.beginPath();context.strokeStyle = annotations[i];move = true;continue;\n      }\n      coords = annotations[i].split(',');coords[0] = Number(coords[0]);coords[1] = Number(coords[1]);if (move) {\n        context.moveTo(coords[0], coords[1]);move = false;\n      } else {\n        context.lineTo(coords[0], coords[1]);\n      }\n    }\n    context.stroke();\n  };window.addEventListener('load', function (e) {\n    setTimeout(function () {\n      var tags = doc.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n        if (tags[i].__object__ && tags[i].__object__.isRGraph && tags[i].__object__.Get('chart.annotatable')) {\n          RG.replayAnnotations(tags[i].__object__);\n        }\n      }\n    }, 100);\n  }, false);\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uYW5ub3RhdGUuanM/Zjk1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9OyhmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGg7UkcuYW5ub3RhdGluZ19jYW52YXNfb25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgZS50YXJnZXQuX19vYmplY3RfXy5TZXQoJ2NoYXJ0Lm1vdXNlZG93bicsIHRydWUpO3ZhciBvYmogPSBlLnRhcmdldC5fX29iamVjdF9fLFxuICAgICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcztcbiAgICAgIG9iai5jb250ZXh0LmJlZ2luUGF0aCgpO29iai5jb250ZXh0LnN0cm9rZVN0eWxlID0gb2JqLkdldCgnY2hhcnQuYW5ub3RhdGUuY29sb3InKTtvYmouY29udGV4dC5saW5lV2lkdGggPSBvYmouR2V0KCdjaGFydC5hbm5vdGF0ZS5saW5ld2lkdGgnKTt2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO1xuICAgICAgaWYgKG9iai50eXBlID09PSAnYmFyJyAmJiBwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcpIHtcbiAgICAgICAgdmFyIGFkanVzdG1lbnQgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5hbmdsZSddICogbW91c2VYWVswXTttb3VzZVkgLT0gYWRqdXN0bWVudDtcbiAgICAgIH1cbiAgICAgIFJHLlJlZ2lzdHJ5LlNldCgnYW5ub3RhdGUuYWN0aW9ucycsIFtvYmouR2V0KCdjaGFydC5hbm5vdGF0ZS5jb2xvcicpXSk7b2JqLmNvbnRleHQubW92ZVRvKG1vdXNlWCwgbW91c2VZKTtSRy5SZWdpc3RyeS5TZXQoJ2Fubm90YXRlLmxhc3QuY29vcmRpbmF0ZXMnLCBbbW91c2VYLCBtb3VzZVldKTtSRy5SZWdpc3RyeS5TZXQoJ3N0YXJ0ZWQuYW5ub3RhdGluZycsIGZhbHNlKTtSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LmFubm90YXRpbmcnLCBvYmopO1JHLkZpcmVDdXN0b21FdmVudChvYmosICdvbmFubm90YXRlYmVnaW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLmFubm90YXRpbmdfd2luZG93X29ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9iaiA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYW5ub3RhdGluZycpO3ZhciB3aW4gPSB3aW5kb3c7aWYgKGUuYnV0dG9uICE9IDAgfHwgIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGFncyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7Zm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGFnc1tpXS5fX29iamVjdF9fKSB7XG4gICAgICAgIHRhZ3NbaV0uX19vYmplY3RfXy5TZXQoJ2NoYXJ0Lm1vdXNlZG93bicsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUuYWN0aW9ucycpICYmIFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUuYWN0aW9ucycpLmxlbmd0aCA+IDAgJiYgd2luLmxvY2FsU3RvcmFnZSkge1xuICAgICAgdmFyIGlkID0gJ19fcmdyYXBoX2Fubm90YXRpb25zXycgKyBlLnRhcmdldC5pZCArICdfXyc7dmFyIGFubm90YXRpb25zID0gd2luLmxvY2FsU3RvcmFnZVtpZF0gPyB3aW4ubG9jYWxTdG9yYWdlW2lkXSArICd8JyA6ICcnO2Fubm90YXRpb25zICs9IFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUuYWN0aW9ucycpO3dpbi5sb2NhbFN0b3JhZ2VbaWRdID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIFJHLlJlZ2lzdHJ5LlNldCgnYW5ub3RhdGUuYWN0aW9ucycsIFtdKTtSRy5GaXJlQ3VzdG9tRXZlbnQob2JqLCAnb25hbm5vdGF0ZWVuZCcpO1xuICB9O1JHcmFwaC5hbm5vdGF0aW5nX2NhbnZhc19vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9iaiA9IGUudGFyZ2V0Ll9fb2JqZWN0X187dmFyIHByb3AgPSBvYmoucHJvcGVydGllczt2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07dmFyIGxhc3RYWSA9IFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUubGFzdC5jb29yZGluYXRlcycpO2lmIChvYmouR2V0KCdjaGFydC5tb3VzZWRvd24nKSkge1xuICAgICAgaWYgKG9iai50eXBlID09PSAnYmFyJyAmJiBwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcpIHtcbiAgICAgICAgdmFyIGFkanVzdG1lbnQgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5hbmdsZSddICogbW91c2VYWVswXTttb3VzZVkgLT0gYWRqdXN0bWVudDtcbiAgICAgIH1cbiAgICAgIG9iai5jb250ZXh0LmJlZ2luUGF0aCgpO2lmICghbGFzdFhZKSB7XG4gICAgICAgIG9iai5jb250ZXh0Lm1vdmVUbyhtb3VzZVgsIG1vdXNlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmouY29udGV4dC5zdHJva2VTdHlsZSA9IG9iai5wcm9wZXJ0aWVzWydjaGFydC5hbm5vdGF0ZS5jb2xvciddO29iai5jb250ZXh0Lm1vdmVUbyhsYXN0WFlbMF0sIGxhc3RYWVsxXSk7b2JqLmNvbnRleHQubGluZVRvKG1vdXNlWCwgbW91c2VZKTtcbiAgICAgIH1cbiAgICAgIFJHLlJlZ2lzdHJ5LlNldCgnYW5ub3RhdGUuYWN0aW9ucycsIFJHLlJlZ2lzdHJ5LkdldCgnYW5ub3RhdGUuYWN0aW9ucycpICsgJ3wnICsgbW91c2VYICsgJywnICsgbW91c2VZKTtSRy5SZWdpc3RyeS5TZXQoJ2Fubm90YXRlLmxhc3QuY29vcmRpbmF0ZXMnLCBbbW91c2VYLCBtb3VzZVldKTtSRy5GaXJlQ3VzdG9tRXZlbnQob2JqLCAnb25hbm5vdGF0ZScpO29iai5jb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfTtSRy5TaG93UGFsZXR0ZSA9IFJHLlNob3dwYWxldHRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaXNTYWZhcmkgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID8gdHJ1ZSA6IGZhbHNlO2UgPSBSRy5GaXhFdmVudE9iamVjdChlKTt2YXIgY2FudmFzID0gZS50YXJnZXQucGFyZW50Tm9kZS5fX2NhbnZhc19fLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgIG9iaiA9IGNhbnZhcy5fX29iamVjdF9fLFxuICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKSxcbiAgICAgICAgY29vcmRzID0gUkcuZ2V0TW91c2VYWShlKTtcbiAgICBkaXYuX19vYmplY3RfXyA9IG9iajtkaXYuY2xhc3NOYW1lID0gJ1JHcmFwaF9wYWxldHRlJztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO2Rpdi5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsYWNrJztkaXYuc3R5bGUubGVmdCA9IDA7ZGl2LnN0eWxlLnRvcCA9IDA7ZGl2LnN0eWxlLnBhZGRpbmcgPSAnM3B4JztkaXYuc3R5bGUucGFkZGluZ0xlZnQgPSAnNXB4JztkaXYuc3R5bGUub3BhY2l0eSA9IDA7ZGl2LnN0eWxlLmJveFNoYWRvdyA9ICdyZ2JhKDk2LDk2LDk2LDAuNSkgM3B4IDNweCAzcHgnO2Rpdi5zdHlsZS5XZWJraXRCb3hTaGFkb3cgPSAncmdiYSg5Niw5Niw5NiwwLjUpIDNweCAzcHggM3B4JztkaXYuc3R5bGUuTW96Qm94U2hhZG93ID0gJ3JnYmEoOTYsOTYsOTYsMC41KSAzcHggM3B4IDNweCc7dmFyIGNvbG9ycyA9IFsnQmxhY2snLCAnUmVkJywgJ1llbGxvdycsICdHcmVlbicsICdPcmFuZ2UnLCAnV2hpdGUnLCAnTWFnZW50YScsICdQaW5rJ107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdmFyIGRpdjIgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2Mi5jc3NDbGFzcyA9ICdSR3JhcGhfcGFsZXR0ZV9jb2xvcic7ZGl2Mi5zdHlsZS5mb250U2l6ZSA9ICcxMnB0JztkaXYyLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztkaXYyLnN0eWxlLnBhZGRpbmcgPSAnMXB4JztkaXYyLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcxMHB4JztkaXYyLnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0Jzt2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NQQU4nKTtzcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztzcGFuLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzlweCc7c3Bhbi5zdHlsZS53aWR0aCA9ICcxN3B4JztzcGFuLnN0eWxlLmhlaWdodCA9ICcxN3B4JztzcGFuLnN0eWxlLnRvcCA9ICcycHgnO3NwYW4uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO3NwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JzW2ldO2RpdjIuYXBwZW5kQ2hpbGQoc3Bhbik7ZGl2Mi5pbm5lckhUTUwgKz0gY29sb3JzW2ldO2RpdjIub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNlZWUnO1xuICAgICAgfTtcbiAgICAgIGRpdjIub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgIH07XG4gICAgICBkaXYyLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZENvbG9yO29iai5TZXQoJ2NoYXJ0LmFubm90YXRlLmNvbG9yJywgY29sb3IpO1xuICAgICAgfTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChkaXYyKTtcbiAgICB9XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtkaXYuc3R5bGUubGVmdCA9IGUucGFnZVggKyAncHgnO2Rpdi5zdHlsZS50b3AgPSBlLnBhZ2VZICsgJ3B4JztpZiAoZS5wYWdlWCArIChkaXYub2Zmc2V0V2lkdGggKyA1KSA+IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpIHtcbiAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gZS5wYWdlWCAtIGRpdi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgfVxuICAgIFJHcmFwaC5SZWdpc3RyeS5TZXQoJ2NoYXJ0LnBhbGV0dGUnLCBkaXYpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAwLjI7XG4gICAgfSwgNTApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAwLjQ7XG4gICAgfSwgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMC42O1xuICAgIH0sIDE1MCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkaXYuc3R5bGUub3BhY2l0eSA9IDAuODtcbiAgICB9LCAyMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgIH0sIDI1MCk7UkdyYXBoLmhpZGVDb250ZXh0KCk7d2luZG93Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5oaWRlUGFsZXR0ZSgpO1xuICAgIH07XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gZmFsc2U7XG4gIH07UkcuY2xlYXJBbm5vdGF0aW9ucyA9IFJHLkNsZWFyQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgaWYgKHR5cGVvZiBjYW52YXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgaWQgPSBjYW52YXM7Y2FudmFzID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkID0gY2FudmFzLmlkO1xuICAgIH1cbiAgICB2YXIgb2JqID0gY2FudmFzLl9fb2JqZWN0X187aWYgKHdpbi5sb2NhbFN0b3JhZ2UgJiYgd2luLmxvY2FsU3RvcmFnZVsnX19yZ3JhcGhfYW5ub3RhdGlvbnNfJyArIGlkICsgJ19fJ10gJiYgd2luLmxvY2FsU3RvcmFnZVsnX19yZ3JhcGhfYW5ub3RhdGlvbnNfJyArIGlkICsgJ19fJ10ubGVuZ3RoKSB7XG4gICAgICB3aW4ubG9jYWxTdG9yYWdlWydfX3JncmFwaF9hbm5vdGF0aW9uc18nICsgaWQgKyAnX18nXSA9IFtdO1JHcmFwaC5GaXJlQ3VzdG9tRXZlbnQob2JqLCAnb25hbm5vdGF0ZWNsZWFyJyk7XG4gICAgfVxuICB9O1JHLnJlcGxheUFubm90YXRpb25zID0gUkcuUmVwbGF5QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCF3aW4ubG9jYWxTdG9yYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gb2JqLmNvbnRleHQ7dmFyIGFubm90YXRpb25zID0gd2luLmxvY2FsU3RvcmFnZVsnX19yZ3JhcGhfYW5ub3RhdGlvbnNfJyArIG9iai5pZCArICdfXyddO3ZhciBpLCBsZW4sIG1vdmUsIGNvb3Jkcztjb250ZXh0LmJlZ2luUGF0aCgpO2NvbnRleHQubGluZVdpZHRoID0gb2JqLkdldCgnYW5ub3RhdGUubGluZXdpZHRoJyk7aWYgKGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5zcGxpdCgnfCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFubm90YXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoYW5ub3RhdGlvbnNbaV0ubWF0Y2goL1thLXpdKy8pKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7Y29udGV4dC5iZWdpblBhdGgoKTtjb250ZXh0LnN0cm9rZVN0eWxlID0gYW5ub3RhdGlvbnNbaV07bW92ZSA9IHRydWU7Y29udGludWU7XG4gICAgICB9XG4gICAgICBjb29yZHMgPSBhbm5vdGF0aW9uc1tpXS5zcGxpdCgnLCcpO2Nvb3Jkc1swXSA9IE51bWJlcihjb29yZHNbMF0pO2Nvb3Jkc1sxXSA9IE51bWJlcihjb29yZHNbMV0pO2lmIChtb3ZlKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGNvb3Jkc1swXSwgY29vcmRzWzFdKTttb3ZlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhZ3MgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpO2ZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGFnc1tpXS5fX29iamVjdF9fICYmIHRhZ3NbaV0uX19vYmplY3RfXy5pc1JHcmFwaCAmJiB0YWdzW2ldLl9fb2JqZWN0X18uR2V0KCdjaGFydC5hbm5vdGF0YWJsZScpKSB7XG4gICAgICAgICAgUkcucmVwbGF5QW5ub3RhdGlvbnModGFnc1tpXS5fX29iamVjdF9fKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH0sIGZhbHNlKTtcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uYW5ub3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///164\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.contextmenu = RG.Contextmenu = function (obj, menuitems, e) {\n    var canvas = obj.canvas;e = RG.FixEventObject(e);RG.FireCustomEvent(obj, 'onbeforecontextmenu');if (RG.Registry.Get('chart.contextmenu')) {\n      RG.HideContext();\n    }\n    RG.HideZoomedCanvas();RG.HidePalette();obj.Set('chart.mousedown', false);var x = e.pageX;var y = e.pageY;var div = document.createElement('div');var bg = document.createElement('div');div.className = 'RGraph_contextmenu';div.__canvas__ = canvas;div.style.position = 'absolute';div.style.left = 0;div.style.top = 0;div.style.border = '1px solid #666';div.style.backgroundColor = 'white';div.style.boxShadow = '1px 1px 3px #ddd';div.style.MozBoxShadow = '1px 1px 3px #ddd';div.style.WebkitBoxShadow = '1px 1px 3px #ddd';div.style.opacity = 0;bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg.style.opacity = 0;div = document.body.appendChild(div);bg = div.appendChild(bg);for (i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('div');menuitem.__object__ = obj;menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = div;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.textAlign = 'left';menuitem.style.fontWeight = 'normal';menuitem.innerHTML = menuitems[i][0];if (RG.is_array(menuitems[i][1])) {\n          menuitem.style.backgroundImage = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAQUlEQVQImY3NoQ2AMABE0ZewABMyGQ6mqWODzlAclBSFO8HZl8uf0FFxCHtwYkt4Y6ChYE44cGH9/fyae2p2LAleW9oVTQuVf6gAAAAASUVORK5CYII=)';menuitem.style.backgroundRepeat = 'no-repeat';menuitem.style.backgroundPosition = '97% center';\n        }\n        if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              RG.HideContextSubmenu();e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              RG.HideContextSubmenu();event.srcElement.style.backgroundColor = '#eee';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      div.appendChild(menuitem);if (menuitems[i] && menuitems[i][1] && typeof menuitems[i][1] == 'function') {\n        menuitem.addEventListener('click', menuitems[i][1], false);\n      } else if (menuitems[i] && menuitems[i][1] && RG.is_array(menuitems[i][1])) {\n        (function () {\n          var tmp = menuitems[i][1];menuitem.addEventListener('mouseover', function (e) {\n            RG.Contextmenu_submenu(obj, tmp, e.target);\n          }, false);\n        })();\n      }\n    }\n    div.style.width = div.offsetWidth + 10 + 'px';div.style.height = div.offsetHeight - 2 + 'px';if (x + div.offsetWidth > document.body.offsetWidth) {\n      x -= div.offsetWidth;\n    }\n    div.style.left = x + 'px';div.style.top = y + 'px';setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu')) obj.style.opacity = 1\", 250);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.2\", 50);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.4\", 100);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.6\", 150);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 0.8\", 200);setTimeout(\"if (obj = RGraph.Registry.Get('chart.contextmenu.bg')) obj.style.opacity = 1\", 250);RG.Registry.Set('chart.contextmenu', div);RG.Registry.Set('chart.contextmenu.bg', bg);RG.Registry.Get('chart.contextmenu').oncontextmenu = function () {\n      return false;\n    };RG.Registry.Get('chart.contextmenu.bg').oncontextmenu = function () {\n      return false;\n    };canvas.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('click', function () {\n      RG.HideContext();\n    }, false);window.addEventListener('resize', function () {\n      RG.HideContext();\n    }, false);if (typeof obj.getShape == 'function') {\n      RG.Registry.Get('chart.contextmenu').__shape__ = obj.getShape(e);\n    }\n    e.stopPropagation();RG.FireCustomEvent(obj, 'oncontextmenu');return false;\n  };RG.hideContext = RG.HideContext = function () {\n    var cm = RG.Registry.Get('chart.contextmenu');var cmbg = RG.Registry.Get('chart.contextmenu.bg');RG.HideContextSubmenu();if (cm) {\n      cm.parentNode.removeChild(cm);cmbg.parentNode.removeChild(cmbg);cm.style.visibility = 'hidden';cm.style.display = 'none';RG.Registry.Set('chart.contextmenu', null);cmbg.style.visibility = 'hidden';cmbg.style.display = 'none';RG.Registry.Set('chart.contextmenu.bg', null);\n    }\n  };RG.hideContextSubmenu = RG.HideContextSubmenu = function () {\n    var sub = RG.Registry.Get('chart.contextmenu.submenu');if (sub) {\n      sub.style.visibility = 'none';sub.style.display = 'none';RG.Registry.Set('chart.contextmenu.submenu', null);\n    }\n  };RG.showContext = RG.ShowContext = function (obj) {\n    RG.HidePalette();if (obj.Get('chart.contextmenu') && obj.Get('chart.contextmenu').length) {\n      var isOpera = navigator.userAgent.indexOf('Opera') >= 0;var isSafari = navigator.userAgent.indexOf('Safari') >= 0;var isChrome = navigator.userAgent.indexOf('Chrome') >= 0;var isMacFirefox = navigator.userAgent.indexOf('Firefox') > 0 && navigator.userAgent.indexOf('Mac') > 0;var isIE9 = navigator.userAgent.indexOf('MSIE 9') >= 0;if ((!isOpera && !isSafari || isChrome) && !isMacFirefox) {\n        obj.canvas.oncontextmenu = function (e) {\n          e = RG.FixEventObject(e);if (e.ctrlKey) return true;RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);return false;\n        };\n      } else {\n        obj.canvas.addEventListener('dblclick', function (e) {\n          if (e.ctrlKey) return true;if (!RG.Registry.Get('chart.contextmenu')) {\n            RG.Contextmenu(obj, obj.Get('chart.contextmenu'), e);\n          }\n        }, false);\n      }\n    }\n  };RG.contextmenu_submenu = RG.Contextmenu_submenu = function (obj, menuitems, parentMenuItem) {\n    RG.HideContextSubmenu();var canvas = obj.canvas;var context = obj.context;var menu = parentMenuItem.parentNode;var subMenu = document.createElement('DIV');subMenu.style.position = 'absolute';subMenu.style.width = '100px';subMenu.style.top = menu.offsetTop + parentMenuItem.offsetTop + 'px';subMenu.style.left = menu.offsetLeft + menu.offsetWidth - (RG.ISOLD ? 9 : 0) + 'px';subMenu.style.backgroundColor = 'white';subMenu.style.border = '1px solid black';subMenu.className = 'RGraph_contextmenu';subMenu.__contextmenu__ = menu;subMenu.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.WebkitBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';subMenu.style.filter = 'progid:DXImageTransform.Microsoft.Shadow(color=#aaaaaa,direction=135)';document.body.appendChild(subMenu);for (var i = 0; i < menuitems.length; ++i) {\n      var menuitem = document.createElement('DIV');menuitem.__canvas__ = canvas;menuitem.__contextmenu__ = menu;menuitem.className = 'RGraph_contextmenu_item';if (menuitems[i]) {\n        menuitem.style.padding = '2px 5px 2px 23px';menuitem.style.fontFamily = 'Arial';menuitem.style.fontSize = '10pt';menuitem.style.fontWeight = 'normal';menuitem.style.textAlign = 'left';menuitem.innerHTML = menuitems[i][0];if (menuitems[i][1]) {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.backgroundColor = 'rgba(0,0,0,0.2)';e.target.style.cursor = 'pointer';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.backgroundColor = 'inherit';e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.backgroundColor = 'rgba(0,0,0,0.2)';event.srcElement.style.cursor = 'pointer';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.backgroundColor = 'inherit';event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        } else {\n          if (menuitem.addEventListener) {\n            menuitem.addEventListener(\"mouseover\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);menuitem.addEventListener(\"mouseout\", function (e) {\n              e.target.style.cursor = 'default';\n            }, false);\n          } else {\n            menuitem.attachEvent(\"onmouseover\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);menuitem.attachEvent(\"onmouseout\", function () {\n              event.srcElement.style.cursor = 'default';\n            }, false);\n          }\n        }\n      } else {\n        menuitem.style.borderBottom = '1px solid #ddd';menuitem.style.marginLeft = '25px';\n      }\n      subMenu.appendChild(menuitem);if (menuitems[i] && menuitems[i][1]) {\n        if (document.all) {\n          menuitem.attachEvent('onclick', menuitems[i][1]);\n        } else {\n          menuitem.addEventListener('click', menuitems[i][1], false);\n        }\n      }\n    }\n    var bg = document.createElement('DIV');bg.className = 'RGraph_contextmenu_background';bg.style.position = 'absolute';bg.style.backgroundColor = '#ccc';bg.style.borderRight = '1px solid #aaa';bg.style.top = 0;bg.style.left = 0;bg.style.width = '18px';bg.style.height = '100%';bg = subMenu.appendChild(bg);RG.Registry.Set('chart.contextmenu.submenu', subMenu);\n  };RG.showPNG = function () {\n    if (RG.ISIE8) {\n      alert('[RGRAPH PNG] Sorry, showing a PNG is not supported on MSIE8.');return;\n    }\n    if (arguments[0] && arguments[0].id) {\n      var canvas = arguments[0];var event = arguments[1];\n    } else if (RG.Registry.Get('chart.contextmenu')) {\n      var canvas = RG.Registry.Get('chart.contextmenu').__canvas__;\n    } else {\n      alert('[RGRAPH SHOWPNG] Could not find canvas!');\n    }\n    var obj = canvas.__object__;var bg = document.createElement('DIV');bg.id = '__rgraph_image_bg__';bg.style.position = 'fixed';bg.style.top = '-10px';bg.style.left = '-10px';bg.style.width = '5000px';bg.style.height = '5000px';bg.style.backgroundColor = 'rgb(204,204,204)';bg.style.opacity = 0;document.body.appendChild(bg);var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.border = '1px solid black';div.style.position = 'fixed';div.style.top = '20%';div.style.width = canvas.width + 'px';div.style.height = canvas.height + 35 + 'px';div.style.left = document.body.clientWidth / 2 - canvas.width / 2 + 'px';div.style.padding = '5px';div.style.borderRadius = '10px';div.style.MozBorderRadius = '10px';div.style.WebkitBorderRadius = '10px';div.style.boxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.MozBoxShadow = '0 0 15px rgba(96,96,96,0.5)';div.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 0 0 15px';div.__canvas__ = canvas;div.__object__ = obj;div.id = '__rgraph_image_div__';document.body.appendChild(div);div.innerHTML += '<div style=\"position: absolute; margin-left: 10px; top: ' + canvas.height + 'px; width: ' + (canvas.width - 50) + 'px; height: 25px\"><span style=\"font-size: 12pt;display: inline; display: inline-block; width: 65px; text-align: right\">URL:</span><textarea style=\"float: right; overflow: hidden; height: 20px; width: ' + (canvas.width - obj.gutterLeft - obj.gutterRight - 80) + 'px\" onclick=\"this.select()\" readonly=\"readonly\" id=\"__rgraph_dataurl__\">' + canvas.toDataURL() + '</textarea></div>';div.innerHTML += '<div style=\"position: absolute; top: ' + (canvas.height + 25) + 'px; left: ' + (obj.gutterLeft - 65 + canvas.width / 2) + 'px; width: ' + (canvas.width - obj.gutterRight) + 'px; font-size: 65%\">A link using the URL: <a href=\"' + canvas.toDataURL() + '\">View</a></div>';\n    var img = document.createElement('IMG');RG.Registry.Set('chart.png', img);img.__canvas__ = canvas;img.__object__ = obj;img.id = '__rgraph_image_img__';img.className = 'RGraph_png';img.src = canvas.toDataURL();div.appendChild(img);setTimeout(function () {\n      document.getElementById(\"__rgraph_dataurl__\").select();\n    }, 50);window.addEventListener('resize', function (e) {\n      var img = RG.Registry.Get('chart.png');img.style.left = document.body.clientWidth / 2 - img.width / 2 + 'px';\n    }, false);bg.onclick = function (e) {\n      var div = document.getElementById(\"__rgraph_image_div__\");var bg = document.getElementById(\"__rgraph_image_bg__\");if (div) {\n        div.style.opacity = 0;div.parentNode.removeChild(div);div.id = '';div.style.display = 'none';div = null;\n      }\n      if (bg) {\n        bg.style.opacity = 0;bg.id = '';bg.style.display = 'none';bg = null;\n      }\n    };\n    window.addEventListener('resize', function (e) {\n      bg.onclick(e);\n    }, false);\n    RG.showpng_image_bg = bg;RG.showpng_image_div = div;setTimeout('RGraph.showpng_image_div.style.opacity = 0.2', 50);setTimeout('RGraph.showpng_image_div.style.opacity = 0.4', 100);setTimeout('RGraph.showpng_image_div.style.opacity = 0.6', 150);setTimeout('RGraph.showpng_image_div.style.opacity = 0.8', 200);setTimeout('RGraph.showpng_image_div.style.opacity = 1', 250);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.1', 50);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.2', 100);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.3', 150);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.4', 200);setTimeout('RGraph.showpng_image_bg.style.opacity = 0.5', 250);img.onclick = function (e) {\n      if (e.stopPropagation) e.stopPropagation();else event.cancelBubble = true;\n    };\n    if (event && event.stopPropagation) {\n      event.stopPropagation();\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uY29udGV4dC5qcz9hNWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy5jb250ZXh0bWVudSA9IFJHLkNvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9iaiwgbWVudWl0ZW1zLCBlKSB7XG4gICAgdmFyIGNhbnZhcyA9IG9iai5jYW52YXM7ZSA9IFJHLkZpeEV2ZW50T2JqZWN0KGUpO1JHLkZpcmVDdXN0b21FdmVudChvYmosICdvbmJlZm9yZWNvbnRleHRtZW51Jyk7aWYgKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUnKSkge1xuICAgICAgUkcuSGlkZUNvbnRleHQoKTtcbiAgICB9XG4gICAgUkcuSGlkZVpvb21lZENhbnZhcygpO1JHLkhpZGVQYWxldHRlKCk7b2JqLlNldCgnY2hhcnQubW91c2Vkb3duJywgZmFsc2UpO3ZhciB4ID0gZS5wYWdlWDt2YXIgeSA9IGUucGFnZVk7dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3ZhciBiZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO2Rpdi5jbGFzc05hbWUgPSAnUkdyYXBoX2NvbnRleHRtZW51JztkaXYuX19jYW52YXNfXyA9IGNhbnZhcztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5sZWZ0ID0gMDtkaXYuc3R5bGUudG9wID0gMDtkaXYuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjNjY2JztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztkaXYuc3R5bGUuYm94U2hhZG93ID0gJzFweCAxcHggM3B4ICNkZGQnO2Rpdi5zdHlsZS5Nb3pCb3hTaGFkb3cgPSAnMXB4IDFweCAzcHggI2RkZCc7ZGl2LnN0eWxlLldlYmtpdEJveFNoYWRvdyA9ICcxcHggMXB4IDNweCAjZGRkJztkaXYuc3R5bGUub3BhY2l0eSA9IDA7YmcuY2xhc3NOYW1lID0gJ1JHcmFwaF9jb250ZXh0bWVudV9iYWNrZ3JvdW5kJztiZy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7Ymcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNjY2MnO2JnLnN0eWxlLmJvcmRlclJpZ2h0ID0gJzFweCBzb2xpZCAjYWFhJztiZy5zdHlsZS50b3AgPSAwO2JnLnN0eWxlLmxlZnQgPSAwO2JnLnN0eWxlLndpZHRoID0gJzE4cHgnO2JnLnN0eWxlLmhlaWdodCA9ICcxMDAlJztiZy5zdHlsZS5vcGFjaXR5ID0gMDtkaXYgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7YmcgPSBkaXYuYXBwZW5kQ2hpbGQoYmcpO2ZvciAoaSA9IDA7IGkgPCBtZW51aXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBtZW51aXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO21lbnVpdGVtLl9fb2JqZWN0X18gPSBvYmo7bWVudWl0ZW0uX19jYW52YXNfXyA9IGNhbnZhczttZW51aXRlbS5fX2NvbnRleHRtZW51X18gPSBkaXY7bWVudWl0ZW0uY2xhc3NOYW1lID0gJ1JHcmFwaF9jb250ZXh0bWVudV9pdGVtJztpZiAobWVudWl0ZW1zW2ldKSB7XG4gICAgICAgIG1lbnVpdGVtLnN0eWxlLnBhZGRpbmcgPSAnMnB4IDVweCAycHggMjNweCc7bWVudWl0ZW0uc3R5bGUuZm9udEZhbWlseSA9ICdBcmlhbCc7bWVudWl0ZW0uc3R5bGUuZm9udFNpemUgPSAnMTBwdCc7bWVudWl0ZW0uc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO21lbnVpdGVtLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJzttZW51aXRlbS5pbm5lckhUTUwgPSBtZW51aXRlbXNbaV1bMF07aWYgKFJHLmlzX2FycmF5KG1lbnVpdGVtc1tpXVsxXSkpIHtcbiAgICAgICAgICBtZW51aXRlbS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWNBQUFBSENBWUFBQURFVWxmVEFBQUFRVWxFUVZRSW1ZM05vUTJBTUFCRTBaZXdBQk15R1E2bXFXT0R6bEFjbEJTRk84SFpsOHVmMEZGeENIdHdZa3Q0WTZDaFlFNDRjR0g5L2Z5YWUycDJMQWxlVzlvVlRRdVZmNmdBQUFBQVNVVk9SSzVDWUlJPSknO21lbnVpdGVtLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0JzttZW51aXRlbS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnOTclIGNlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbnVpdGVtc1tpXVsxXSkge1xuICAgICAgICAgIGlmIChtZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBtZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIFJHLkhpZGVDb250ZXh0U3VibWVudSgpO2UudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMiknO2UudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgIH0sIGZhbHNlKTttZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2luaGVyaXQnO2UudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVudWl0ZW0uYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIFJHLkhpZGVDb250ZXh0U3VibWVudSgpO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNlZWUnO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgfSwgZmFsc2UpO21lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2luaGVyaXQnO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgbWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9LCBmYWxzZSk7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVudWl0ZW0uYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO21lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVudWl0ZW0uc3R5bGUuYm9yZGVyQm90dG9tID0gJzFweCBzb2xpZCAjZGRkJzttZW51aXRlbS5zdHlsZS5tYXJnaW5MZWZ0ID0gJzI1cHgnO1xuICAgICAgfVxuICAgICAgZGl2LmFwcGVuZENoaWxkKG1lbnVpdGVtKTtpZiAobWVudWl0ZW1zW2ldICYmIG1lbnVpdGVtc1tpXVsxXSAmJiB0eXBlb2YgbWVudWl0ZW1zW2ldWzFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBtZW51aXRlbXNbaV1bMV0sIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVudWl0ZW1zW2ldICYmIG1lbnVpdGVtc1tpXVsxXSAmJiBSRy5pc19hcnJheShtZW51aXRlbXNbaV1bMV0pKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IG1lbnVpdGVtc1tpXVsxXTttZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgUkcuQ29udGV4dG1lbnVfc3VibWVudShvYmosIHRtcCwgZS50YXJnZXQpO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2Lm9mZnNldFdpZHRoICsgMTAgKyAncHgnO2Rpdi5zdHlsZS5oZWlnaHQgPSBkaXYub2Zmc2V0SGVpZ2h0IC0gMiArICdweCc7aWYgKHggKyBkaXYub2Zmc2V0V2lkdGggPiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKSB7XG4gICAgICB4IC09IGRpdi5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgZGl2LnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztkaXYuc3R5bGUudG9wID0geSArICdweCc7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSBvYmouc3R5bGUub3BhY2l0eSA9IDAuMlwiLCA1MCk7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSBvYmouc3R5bGUub3BhY2l0eSA9IDAuNFwiLCAxMDApO3NldFRpbWVvdXQoXCJpZiAob2JqID0gUkdyYXBoLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUnKSkgb2JqLnN0eWxlLm9wYWNpdHkgPSAwLjZcIiwgMTUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC44XCIsIDIwMCk7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSBvYmouc3R5bGUub3BhY2l0eSA9IDFcIiwgMjUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC4yXCIsIDUwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMC40XCIsIDEwMCk7c2V0VGltZW91dChcImlmIChvYmogPSBSR3JhcGguUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudS5iZycpKSBvYmouc3R5bGUub3BhY2l0eSA9IDAuNlwiLCAxNTApO3NldFRpbWVvdXQoXCJpZiAob2JqID0gUkdyYXBoLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUuYmcnKSkgb2JqLnN0eWxlLm9wYWNpdHkgPSAwLjhcIiwgMjAwKTtzZXRUaW1lb3V0KFwiaWYgKG9iaiA9IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykpIG9iai5zdHlsZS5vcGFjaXR5ID0gMVwiLCAyNTApO1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuY29udGV4dG1lbnUnLCBkaXYpO1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuY29udGV4dG1lbnUuYmcnLCBiZyk7UkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51LmJnJykub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLkhpZGVDb250ZXh0KCk7XG4gICAgfSwgZmFsc2UpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLkhpZGVDb250ZXh0KCk7XG4gICAgfSwgZmFsc2UpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5IaWRlQ29udGV4dCgpO1xuICAgIH0sIGZhbHNlKTtpZiAodHlwZW9mIG9iai5nZXRTaGFwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykuX19zaGFwZV9fID0gb2JqLmdldFNoYXBlKGUpO1xuICAgIH1cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1JHLkZpcmVDdXN0b21FdmVudChvYmosICdvbmNvbnRleHRtZW51Jyk7cmV0dXJuIGZhbHNlO1xuICB9O1JHLmhpZGVDb250ZXh0ID0gUkcuSGlkZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpO3ZhciBjbWJnID0gUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudS5iZycpO1JHLkhpZGVDb250ZXh0U3VibWVudSgpO2lmIChjbSkge1xuICAgICAgY20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbSk7Y21iZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtYmcpO2NtLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztjbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuY29udGV4dG1lbnUnLCBudWxsKTtjbWJnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztjbWJnLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5jb250ZXh0bWVudS5iZycsIG51bGwpO1xuICAgIH1cbiAgfTtSRy5oaWRlQ29udGV4dFN1Ym1lbnUgPSBSRy5IaWRlQ29udGV4dFN1Ym1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN1YiA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29udGV4dG1lbnUuc3VibWVudScpO2lmIChzdWIpIHtcbiAgICAgIHN1Yi5zdHlsZS52aXNpYmlsaXR5ID0gJ25vbmUnO3N1Yi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuY29udGV4dG1lbnUuc3VibWVudScsIG51bGwpO1xuICAgIH1cbiAgfTtSRy5zaG93Q29udGV4dCA9IFJHLlNob3dDb250ZXh0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIFJHLkhpZGVQYWxldHRlKCk7aWYgKG9iai5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykgJiYgb2JqLkdldCgnY2hhcnQuY29udGV4dG1lbnUnKS5sZW5ndGgpIHtcbiAgICAgIHZhciBpc09wZXJhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPcGVyYScpID49IDA7dmFyIGlzU2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+PSAwO3ZhciBpc0Nocm9tZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPj0gMDt2YXIgaXNNYWNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAwICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTWFjJykgPiAwO3ZhciBpc0lFOSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSA5JykgPj0gMDtpZiAoKCFpc09wZXJhICYmICFpc1NhZmFyaSB8fCBpc0Nocm9tZSkgJiYgIWlzTWFjRmlyZWZveCkge1xuICAgICAgICBvYmouY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUgPSBSRy5GaXhFdmVudE9iamVjdChlKTtpZiAoZS5jdHJsS2V5KSByZXR1cm4gdHJ1ZTtSRy5Db250ZXh0bWVudShvYmosIG9iai5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JyksIGUpO3JldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHJldHVybiB0cnVlO2lmICghUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSB7XG4gICAgICAgICAgICBSRy5Db250ZXh0bWVudShvYmosIG9iai5HZXQoJ2NoYXJ0LmNvbnRleHRtZW51JyksIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5jb250ZXh0bWVudV9zdWJtZW51ID0gUkcuQ29udGV4dG1lbnVfc3VibWVudSA9IGZ1bmN0aW9uIChvYmosIG1lbnVpdGVtcywgcGFyZW50TWVudUl0ZW0pIHtcbiAgICBSRy5IaWRlQ29udGV4dFN1Ym1lbnUoKTt2YXIgY2FudmFzID0gb2JqLmNhbnZhczt2YXIgY29udGV4dCA9IG9iai5jb250ZXh0O3ZhciBtZW51ID0gcGFyZW50TWVudUl0ZW0ucGFyZW50Tm9kZTt2YXIgc3ViTWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO3N1Yk1lbnUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO3N1Yk1lbnUuc3R5bGUud2lkdGggPSAnMTAwcHgnO3N1Yk1lbnUuc3R5bGUudG9wID0gbWVudS5vZmZzZXRUb3AgKyBwYXJlbnRNZW51SXRlbS5vZmZzZXRUb3AgKyAncHgnO3N1Yk1lbnUuc3R5bGUubGVmdCA9IG1lbnUub2Zmc2V0TGVmdCArIG1lbnUub2Zmc2V0V2lkdGggLSAoUkcuSVNPTEQgPyA5IDogMCkgKyAncHgnO3N1Yk1lbnUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztzdWJNZW51LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgYmxhY2snO3N1Yk1lbnUuY2xhc3NOYW1lID0gJ1JHcmFwaF9jb250ZXh0bWVudSc7c3ViTWVudS5fX2NvbnRleHRtZW51X18gPSBtZW51O3N1Yk1lbnUuc3R5bGUuYm94U2hhZG93ID0gJzNweCAzcHggM3B4IHJnYmEoOTYsOTYsOTYsMC41KSc7c3ViTWVudS5zdHlsZS5Nb3pCb3hTaGFkb3cgPSAnM3B4IDNweCAzcHggcmdiYSg5Niw5Niw5NiwwLjUpJztzdWJNZW51LnN0eWxlLldlYmtpdEJveFNoYWRvdyA9ICczcHggM3B4IDNweCByZ2JhKDk2LDk2LDk2LDAuNSknO3N1Yk1lbnUuc3R5bGUuZmlsdGVyID0gJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5TaGFkb3coY29sb3I9I2FhYWFhYSxkaXJlY3Rpb249MTM1KSc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdWJNZW51KTtmb3IgKHZhciBpID0gMDsgaSA8IG1lbnVpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG1lbnVpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7bWVudWl0ZW0uX19jYW52YXNfXyA9IGNhbnZhczttZW51aXRlbS5fX2NvbnRleHRtZW51X18gPSBtZW51O21lbnVpdGVtLmNsYXNzTmFtZSA9ICdSR3JhcGhfY29udGV4dG1lbnVfaXRlbSc7aWYgKG1lbnVpdGVtc1tpXSkge1xuICAgICAgICBtZW51aXRlbS5zdHlsZS5wYWRkaW5nID0gJzJweCA1cHggMnB4IDIzcHgnO21lbnVpdGVtLnN0eWxlLmZvbnRGYW1pbHkgPSAnQXJpYWwnO21lbnVpdGVtLnN0eWxlLmZvbnRTaXplID0gJzEwcHQnO21lbnVpdGVtLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJzttZW51aXRlbS5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7bWVudWl0ZW0uaW5uZXJIVE1MID0gbWVudWl0ZW1zW2ldWzBdO2lmIChtZW51aXRlbXNbaV1bMV0pIHtcbiAgICAgICAgICBpZiAobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgbWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjIpJztlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9LCBmYWxzZSk7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdpbmhlcml0JztlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBldmVudC5zcmNFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMiknO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgfSwgZmFsc2UpO21lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2luaGVyaXQnO2V2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgbWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9LCBmYWxzZSk7bWVudWl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVudWl0ZW0uYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO21lbnVpdGVtLmF0dGFjaEV2ZW50KFwib25tb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVudWl0ZW0uc3R5bGUuYm9yZGVyQm90dG9tID0gJzFweCBzb2xpZCAjZGRkJzttZW51aXRlbS5zdHlsZS5tYXJnaW5MZWZ0ID0gJzI1cHgnO1xuICAgICAgfVxuICAgICAgc3ViTWVudS5hcHBlbmRDaGlsZChtZW51aXRlbSk7aWYgKG1lbnVpdGVtc1tpXSAmJiBtZW51aXRlbXNbaV1bMV0pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFsbCkge1xuICAgICAgICAgIG1lbnVpdGVtLmF0dGFjaEV2ZW50KCdvbmNsaWNrJywgbWVudWl0ZW1zW2ldWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW51aXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG1lbnVpdGVtc1tpXVsxXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBiZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2JnLmNsYXNzTmFtZSA9ICdSR3JhcGhfY29udGV4dG1lbnVfYmFja2dyb3VuZCc7Ymcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2JnLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjY2NjJztiZy5zdHlsZS5ib3JkZXJSaWdodCA9ICcxcHggc29saWQgI2FhYSc7Ymcuc3R5bGUudG9wID0gMDtiZy5zdHlsZS5sZWZ0ID0gMDtiZy5zdHlsZS53aWR0aCA9ICcxOHB4JztiZy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7YmcgPSBzdWJNZW51LmFwcGVuZENoaWxkKGJnKTtSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LmNvbnRleHRtZW51LnN1Ym1lbnUnLCBzdWJNZW51KTtcbiAgfTtSRy5zaG93UE5HID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChSRy5JU0lFOCkge1xuICAgICAgYWxlcnQoJ1tSR1JBUEggUE5HXSBTb3JyeSwgc2hvd2luZyBhIFBORyBpcyBub3Qgc3VwcG9ydGVkIG9uIE1TSUU4LicpO3JldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uaWQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBhcmd1bWVudHNbMF07dmFyIGV2ZW50ID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSBpZiAoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpKSB7XG4gICAgICB2YXIgY2FudmFzID0gUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5jb250ZXh0bWVudScpLl9fY2FudmFzX187XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsZXJ0KCdbUkdSQVBIIFNIT1dQTkddIENvdWxkIG5vdCBmaW5kIGNhbnZhcyEnKTtcbiAgICB9XG4gICAgdmFyIG9iaiA9IGNhbnZhcy5fX29iamVjdF9fO3ZhciBiZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2JnLmlkID0gJ19fcmdyYXBoX2ltYWdlX2JnX18nO2JnLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztiZy5zdHlsZS50b3AgPSAnLTEwcHgnO2JnLnN0eWxlLmxlZnQgPSAnLTEwcHgnO2JnLnN0eWxlLndpZHRoID0gJzUwMDBweCc7Ymcuc3R5bGUuaGVpZ2h0ID0gJzUwMDBweCc7Ymcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYigyMDQsMjA0LDIwNCknO2JnLnN0eWxlLm9wYWNpdHkgPSAwO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmcpO3ZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztkaXYuc3R5bGUub3BhY2l0eSA9IDA7ZGl2LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgYmxhY2snO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7ZGl2LnN0eWxlLnRvcCA9ICcyMCUnO2Rpdi5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKyAzNSArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC8gMiAtIGNhbnZhcy53aWR0aCAvIDIgKyAncHgnO2Rpdi5zdHlsZS5wYWRkaW5nID0gJzVweCc7ZGl2LnN0eWxlLmJvcmRlclJhZGl1cyA9ICcxMHB4JztkaXYuc3R5bGUuTW96Qm9yZGVyUmFkaXVzID0gJzEwcHgnO2Rpdi5zdHlsZS5XZWJraXRCb3JkZXJSYWRpdXMgPSAnMTBweCc7ZGl2LnN0eWxlLmJveFNoYWRvdyA9ICcwIDAgMTVweCByZ2JhKDk2LDk2LDk2LDAuNSknO2Rpdi5zdHlsZS5Nb3pCb3hTaGFkb3cgPSAnMCAwIDE1cHggcmdiYSg5Niw5Niw5NiwwLjUpJztkaXYuc3R5bGUuV2Via2l0Qm94U2hhZG93ID0gJ3JnYmEoOTYsOTYsOTYsMC41KSAwIDAgMTVweCc7ZGl2Ll9fY2FudmFzX18gPSBjYW52YXM7ZGl2Ll9fb2JqZWN0X18gPSBvYmo7ZGl2LmlkID0gJ19fcmdyYXBoX2ltYWdlX2Rpdl9fJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7ZGl2LmlubmVySFRNTCArPSAnPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbWFyZ2luLWxlZnQ6IDEwcHg7IHRvcDogJyArIGNhbnZhcy5oZWlnaHQgKyAncHg7IHdpZHRoOiAnICsgKGNhbnZhcy53aWR0aCAtIDUwKSArICdweDsgaGVpZ2h0OiAyNXB4XCI+PHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEycHQ7ZGlzcGxheTogaW5saW5lOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiA2NXB4OyB0ZXh0LWFsaWduOiByaWdodFwiPlVSTDo8L3NwYW4+PHRleHRhcmVhIHN0eWxlPVwiZmxvYXQ6IHJpZ2h0OyBvdmVyZmxvdzogaGlkZGVuOyBoZWlnaHQ6IDIwcHg7IHdpZHRoOiAnICsgKGNhbnZhcy53aWR0aCAtIG9iai5ndXR0ZXJMZWZ0IC0gb2JqLmd1dHRlclJpZ2h0IC0gODApICsgJ3B4XCIgb25jbGljaz1cInRoaXMuc2VsZWN0KClcIiByZWFkb25seT1cInJlYWRvbmx5XCIgaWQ9XCJfX3JncmFwaF9kYXRhdXJsX19cIj4nICsgY2FudmFzLnRvRGF0YVVSTCgpICsgJzwvdGV4dGFyZWE+PC9kaXY+JztkaXYuaW5uZXJIVE1MICs9ICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyAoY2FudmFzLmhlaWdodCArIDI1KSArICdweDsgbGVmdDogJyArIChvYmouZ3V0dGVyTGVmdCAtIDY1ICsgY2FudmFzLndpZHRoIC8gMikgKyAncHg7IHdpZHRoOiAnICsgKGNhbnZhcy53aWR0aCAtIG9iai5ndXR0ZXJSaWdodCkgKyAncHg7IGZvbnQtc2l6ZTogNjUlXCI+QSBsaW5rIHVzaW5nIHRoZSBVUkw6IDxhIGhyZWY9XCInICsgY2FudmFzLnRvRGF0YVVSTCgpICsgJ1wiPlZpZXc8L2E+PC9kaXY+JztcbiAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7UkcuUmVnaXN0cnkuU2V0KCdjaGFydC5wbmcnLCBpbWcpO2ltZy5fX2NhbnZhc19fID0gY2FudmFzO2ltZy5fX29iamVjdF9fID0gb2JqO2ltZy5pZCA9ICdfX3JncmFwaF9pbWFnZV9pbWdfXyc7aW1nLmNsYXNzTmFtZSA9ICdSR3JhcGhfcG5nJztpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO2Rpdi5hcHBlbmRDaGlsZChpbWcpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX3JncmFwaF9kYXRhdXJsX19cIikuc2VsZWN0KCk7XG4gICAgfSwgNTApO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGltZyA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQucG5nJyk7aW1nLnN0eWxlLmxlZnQgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC8gMiAtIGltZy53aWR0aCAvIDIgKyAncHgnO1xuICAgIH0sIGZhbHNlKTtiZy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fcmdyYXBoX2ltYWdlX2Rpdl9fXCIpO3ZhciBiZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19yZ3JhcGhfaW1hZ2VfYmdfX1wiKTtpZiAoZGl2KSB7XG4gICAgICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO2Rpdi5pZCA9ICcnO2Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO2RpdiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYmcpIHtcbiAgICAgICAgYmcuc3R5bGUub3BhY2l0eSA9IDA7YmcuaWQgPSAnJztiZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO2JnID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgYmcub25jbGljayhlKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgUkcuc2hvd3BuZ19pbWFnZV9iZyA9IGJnO1JHLnNob3dwbmdfaW1hZ2VfZGl2ID0gZGl2O3NldFRpbWVvdXQoJ1JHcmFwaC5zaG93cG5nX2ltYWdlX2Rpdi5zdHlsZS5vcGFjaXR5ID0gMC4yJywgNTApO3NldFRpbWVvdXQoJ1JHcmFwaC5zaG93cG5nX2ltYWdlX2Rpdi5zdHlsZS5vcGFjaXR5ID0gMC40JywgMTAwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9kaXYuc3R5bGUub3BhY2l0eSA9IDAuNicsIDE1MCk7c2V0VGltZW91dCgnUkdyYXBoLnNob3dwbmdfaW1hZ2VfZGl2LnN0eWxlLm9wYWNpdHkgPSAwLjgnLCAyMDApO3NldFRpbWVvdXQoJ1JHcmFwaC5zaG93cG5nX2ltYWdlX2Rpdi5zdHlsZS5vcGFjaXR5ID0gMScsIDI1MCk7c2V0VGltZW91dCgnUkdyYXBoLnNob3dwbmdfaW1hZ2VfYmcuc3R5bGUub3BhY2l0eSA9IDAuMScsIDUwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9iZy5zdHlsZS5vcGFjaXR5ID0gMC4yJywgMTAwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9iZy5zdHlsZS5vcGFjaXR5ID0gMC4zJywgMTUwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9iZy5zdHlsZS5vcGFjaXR5ID0gMC40JywgMjAwKTtzZXRUaW1lb3V0KCdSR3JhcGguc2hvd3BuZ19pbWFnZV9iZy5zdHlsZS5vcGFjaXR5ID0gMC41JywgMjUwKTtpbWcub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7ZWxzZSBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH07XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5jb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///165\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Highlight = {};RG.Registry = {};RG.Registry.store = [];RG.Registry.store['chart.event.handlers'] = [];RG.Registry.store['__rgraph_event_listeners__'] = [];RG.Background = {};RG.background = {};RG.objects = [];RG.Resizing = {};RG.events = [];RG.cursor = [];RG.Effects = RG.Effects || {};RG.cache = [];RG.ObjectRegistry = {};RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];RG.OR = RG.ObjectRegistry;RG.PI = ma.PI;RG.HALFPI = RG.PI / 2;RG.TWOPI = RG.PI * 2;RG.ISFF = ua.indexOf('Firefox') != -1;RG.ISOPERA = ua.indexOf('Opera') != -1;RG.ISCHROME = ua.indexOf('Chrome') != -1;RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.ISOLD = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8;RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;RG.ISIE9UP = RG.ISIE9 || RG.ISIE10UP;RG.getScale = function (max, obj) {\n    if (max == 0) {\n      return ['0.2', '0.4', '0.6', '0.8', '1.0'];\n    }\n    var original_max = max;if (max <= 1) {\n      if (max > 0.5) {\n        return [0.2, 0.4, 0.6, 0.8, Number(1).toFixed(1)];\n      } else if (max >= 0.1) {\n        return obj.Get('chart.scale.round') ? [0.2, 0.4, 0.6, 0.8, 1] : [0.1, 0.2, 0.3, 0.4, 0.5];\n      } else {\n        var tmp = max;var exp = 0;while (tmp < 1.01) {\n          exp += 1;tmp *= 10;\n        }\n        var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];if (max <= '5e-' + exp) {\n          ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\n        }\n        return ret;\n      }\n    }\n    if (String(max).indexOf('.') > 0) {\n      max = String(max).replace(/\\.\\d+$/, '');\n    }\n    var interval = ma.pow(10, Number(String(Number(max)).length - 1));var topValue = interval;while (topValue < max) {\n      topValue += interval / 2;\n    }\n    if (Number(original_max) > Number(topValue)) {\n      topValue += interval / 2;\n    }\n    if (max < 10) {\n      topValue = Number(original_max) <= 5 ? 5 : 10;\n    }\n    if (obj && typeof obj.Get('chart.scale.round') == 'boolean' && obj.Get('chart.scale.round')) {\n      topValue = 10 * interval;\n    }\n    return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\n  };RG.getScale2 = function (obj, opt) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        numlabels = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,\n        units_pre = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',\n        units_post = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',\n        max = Number(opt['max']),\n        min = typeof opt['min'] == 'number' ? opt['min'] : 0,\n        strict = opt['strict'],\n        decimals = Number(opt['scale.decimals']),\n        point = opt['scale.point'],\n        thousand = opt['scale.thousand'],\n        original_max = max,\n        round = opt['scale.round'],\n        scale = { max: 1, labels: [], values: [] };\n    if (!max) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = (((max - min) / numlabels + min) * (i + 1)).toFixed(decimals);scale.labels.push(units_pre + label + units_post);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(original_max) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(original_max) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;var tmp_point = prop['chart.scale.point'];var tmp_thousand = prop['chart.scale.thousand'];obj.Set('chart.scale.thousand', thousand);obj.Set('chart.scale.point', point);for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.number_format(obj, ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n      obj.Set('chart.scale.thousand', tmp_thousand);obj.Set('chart.scale.point', tmp_point);\n    } else if (typeof max == 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.numberFormat(obj, ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), units_pre, units_post));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.units_pre = units_pre;scale.units_post = units_post;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.arrayReverse(out2);return out2;\n  };RG.arrayClone = RG.array_clone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n      if (typeof obj[i] === 'number') {\n        temp[i] = function (arg) {\n          return Number(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'string') {\n        temp[i] = function (arg) {\n          return String(arg);\n        }(obj[i]);\n      } else if (typeof obj[i] === 'function') {\n        temp[i] = obj[i];\n      } else {\n        temp[i] = RG.arrayClone(obj[i]);\n      }\n    }\n    return temp;\n  };RG.arrayMax = RG.array_max = function (arr) {\n    var max = null,\n        ma = Math;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.arrayPad = RG.array_pad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.arraySum = RG.array_sum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.is_null(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.arrayLinearize = RG.array_linearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.array_linearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.arrayShift = RG.array_shift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.arrayReverse = RG.array_reverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.clear = RG.Clear = function (ca) {\n    var obj = ca.__object__,\n        co = ca.getContext('2d'),\n        color = arguments[1] || obj && obj.get('clearto');\n    if (!ca) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforeclear');if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {\n      for (var i in RG.text2.domNodeCache[ca.id]) {\n        var el = RG.text2.domNodeCache[ca.id][i];if (el && el.style) {\n          el.style.display = 'none';\n        }\n      }\n    }\n    if (!color || color && color === 'rgba(0,0,0,0)' || color === 'transparent') {\n      co.clearRect(-100, -100, ca.width + 200, ca.height + 200);co.globalCompositeOperation = 'source-over';\n    } else if (color) {\n      RG.path2(co, 'fs % fr -100 -100 % %', color, ca.width + 200, ca.height + 200);\n    } else {\n      RG.path2(co, 'fs % fr -100 -100 % %', obj.get('clearto'), ca.width + 200, ca.height + 200);\n    }\n    if (RG.Registry.Get('chart.background.image.' + ca.id)) {\n      var img = RG.Registry.Get('chart.background.image.' + ca.id);img.style.position = 'absolute';img.style.left = '-10000px';img.style.top = '-10000px';\n    }\n    if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {\n      RG.HideTooltip(ca);\n    }\n    ca.style.cursor = 'default';RG.FireCustomEvent(obj, 'onclear');\n  };RG.drawTitle = RG.DrawTitle = function (obj, text, gutterTop) {\n    var ca = canvas = obj.canvas,\n        co = context = obj.context,\n        prop = obj.properties;\n    gutterLeft = prop['chart.gutter.left'], gutterRight = prop['chart.gutter.right'], gutterTop = gutterTop, gutterBottom = prop['chart.gutter.bottom'], size = arguments[4] ? arguments[4] : 12, bold = prop['chart.title.bold'], italic = prop['chart.title.italic'], centerx = arguments[3] ? arguments[3] : (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft, keypos = prop['chart.key.position'], vpos = prop['chart.title.vpos'], hpos = prop['chart.title.hpos'], bgcolor = prop['chart.title.background'], x = prop['chart.title.x'], y = prop['chart.title.y'], halign = 'center', valign = 'center';\n    if (obj.type == 'bar' && prop['chart.variant'] == '3d') {\n      keypos = 'gutter';\n    }\n    co.beginPath();co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';if (keypos && keypos != 'gutter') {\n      var valign = 'center';\n    } else if (!keypos) {\n      var valign = 'center';\n    } else {\n      var valign = 'bottom';\n    }\n    if (typeof prop['chart.title.vpos'] === 'number') {\n      vpos = prop['chart.title.vpos'] * gutterTop;if (prop['chart.xaxispos'] === 'top') {\n        vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);\n      }\n    } else {\n      vpos = gutterTop - size - 5;if (prop['chart.xaxispos'] === 'top') {\n        vpos = ca.height - gutterBottom + size + 5;\n      }\n    }\n    if (typeof hpos === 'number') {\n      centerx = hpos * ca.width;\n    }\n    if (typeof x === 'number') centerx = x;if (typeof y === 'number') vpos = y;if (typeof prop['chart.title.halign'] === 'string') {\n      halign = prop['chart.title.halign'];\n    }\n    if (typeof prop['chart.title.valign'] === 'string') {\n      valign = prop['chart.title.valign'];\n    }\n    if (typeof prop['chart.title.color'] !== null) {\n      var oldColor = co.fillStyle;\n      var newColor = prop['chart.title.color'];co.fillStyle = newColor ? newColor : 'black';\n    }\n    var font = prop['chart.text.font'];if (typeof prop['chart.title.font'] === 'string') {\n      font = prop['chart.title.font'];\n    }\n    var ret = RG.text2(obj, { font: font, size: size, x: centerx, y: vpos, text: text, valign: valign, halign: halign, bounding: bgcolor != null, 'bounding.fill': bgcolor, 'bold': bold, italic: italic, tag: 'title', marker: false });co.fillStyle = oldColor;\n  };RG.getMouseXY = function (e) {\n    if (!e.target) {\n      return;\n    }\n    var el = e.target;var ca = el;var caStyle = ca.style;var offsetX = 0;var offsetY = 0;var x;var y;var borderLeft = parseInt(caStyle.borderLeftWidth) || 0;var borderTop = parseInt(caStyle.borderTopWidth) || 0;var paddingLeft = parseInt(caStyle.paddingLeft) || 0;\n    var paddingTop = parseInt(caStyle.paddingTop) || 0;\n    var additionalX = borderLeft + paddingLeft;var additionalY = borderTop + paddingTop;if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\n      if (!RG.ISIE && !RG.ISOPERA) {\n        x = e.offsetX - borderLeft - paddingLeft;y = e.offsetY - borderTop - paddingTop;\n      } else if (RG.ISIE) {\n        x = e.offsetX - paddingLeft;y = e.offsetY - paddingTop;\n      } else {\n        x = e.offsetX;y = e.offsetY;\n      }\n    } else {\n      if (typeof el.offsetParent !== 'undefined') {\n        do {\n          offsetX += el.offsetLeft;offsetY += el.offsetTop;\n        } while (el = el.offsetParent);\n      }\n      x = e.pageX - offsetX - additionalX;y = e.pageY - offsetY - additionalY;x -= 2 * (parseInt(document.body.style.borderLeftWidth) || 0);y -= 2 * (parseInt(document.body.style.borderTopWidth) || 0);\n    }\n    return [x, y];\n  };RG.getCanvasXY = function (canvas) {\n    var x = 0;var y = 0;var el = canvas;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName.toLowerCase() != 'body');var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;var paddingTop = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;var borderLeft = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;var borderTop = canvas.style.borderTopWidth ? parseInt(canvas.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.isFixed = function (canvas) {\n    var obj = canvas;var i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position == 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.register = RG.Register = function (obj) {\n    if (!obj.Get('chart.noregister')) {\n      RGraph.ObjectRegistry.Add(obj);obj.Set('chart.noregister', true);\n    }\n  };RG.redraw = RG.Redraw = function () {\n    var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;var tags = document.getElementsByTagName('canvas');for (var i = 0, len = tags.length; i < len; ++i) {\n      if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n        if (!tags[i].noclear) {\n          RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);\n        }\n      }\n    }\n    for (var i = 0, len = objectRegistry.length; i < len; ++i) {\n      if (objectRegistry[i]) {\n        var id = objectRegistry[i][0];objectRegistry[i][1].Draw();\n      }\n    }\n  };RG.redrawCanvas = RG.RedrawCanvas = function (ca) {\n    var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);if (!arguments[1] || typeof arguments[1] === 'boolean' && !arguments[1] == false) {\n      var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';RG.clear(ca, color);\n    }\n    for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        if (objects[i] && objects[i].isRGraph) {\n          objects[i].Draw();\n        }\n      }\n    }\n  };RG.Background.draw = RG.background.draw = RG.background.Draw = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        height = 0,\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        variant = prop['chart.variant'];\n    co.fillStyle = prop['chart.text.color'];if (variant == '3d') {\n      co.save();co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\n    }\n    if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var bold = prop['chart.title.xaxis.bold'];if (typeof prop['chart.title.xaxis.size'] == 'number') {\n        size = prop['chart.title.xaxis.size'];\n      }\n      if (typeof prop['chart.title.xaxis.font'] == 'string') {\n        font = prop['chart.title.xaxis.font'];\n      }\n      var hpos = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;var vpos = ca.height - gutterBottom + 25;if (typeof prop['chart.title.xaxis.pos'] === 'number') {\n        vpos = ca.height - gutterBottom * prop['chart.title.xaxis.pos'];\n      }\n      if (typeof prop['chart.title.xaxis.x'] === 'number') {\n        hpos = prop['chart.title.xaxis.x'];\n      }\n      if (typeof prop['chart.title.xaxis.y'] === 'number') {\n        vpos = prop['chart.title.xaxis.y'];\n      }\n      RG.text2(prop['chart.text.accessible'] ? obj.context : co, { font: font, size: size, x: hpos, y: vpos, text: prop['chart.title.xaxis'], halign: 'center', valign: 'center', bold: bold, color: prop['chart.title.xaxis.color'] || 'black', tag: 'title xaxis' });\n    }\n    if (typeof prop['chart.title.yaxis'] == 'string' && prop['chart.title.yaxis'].length) {\n      var size = prop['chart.text.size'] + 2;var font = prop['chart.text.font'];var angle = 270;var bold = prop['chart.title.yaxis.bold'];var color = prop['chart.title.yaxis.color'];if (typeof prop['chart.title.yaxis.pos'] == 'number') {\n        var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;\n      } else {\n        var yaxis_title_pos = (gutterLeft - 25) / gutterLeft * gutterLeft;\n      }\n      if (typeof prop['chart.title.yaxis.size'] === 'number') {\n        size = prop['chart.title.yaxis.size'];\n      }\n      if (typeof prop['chart.title.yaxis.font'] === 'string') {\n        font = prop['chart.title.yaxis.font'];\n      }\n      if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined') {\n        angle = 90;yaxis_title_pos = prop['chart.title.yaxis.pos'] ? ca.width - gutterRight + prop['chart.title.yaxis.pos'] * gutterRight : ca.width - gutterRight + prop['chart.text.size'] + 5;\n      } else {\n        yaxis_title_pos = yaxis_title_pos;\n      }\n      var y = (ca.height - gutterTop - gutterBottom) / 2 + gutterTop;if (typeof prop['chart.title.yaxis.x'] === 'number') {\n        yaxis_title_pos = prop['chart.title.yaxis.x'];\n      }\n      if (typeof prop['chart.title.yaxis.y'] === 'number') {\n        y = prop['chart.title.yaxis.y'];\n      }\n      co.fillStyle = color;RG.text2(prop['chart.text.accessible'] ? obj.context : co, { 'font': font, 'size': size, 'x': yaxis_title_pos, 'y': y, 'valign': 'center', 'halign': 'center', 'angle': angle, 'bold': bold, 'text': prop['chart.title.yaxis'], 'tag': 'title yaxis', accessible: false });\n    }\n    var bgcolor = prop['chart.background.color'];if (bgcolor) {\n      co.fillStyle = bgcolor;co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n    }\n    var numbars = prop['chart.ylabels.count'] || 5;var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;co.beginPath();co.fillStyle = prop['chart.background.barcolor1'];co.strokeStyle = co.fillStyle;height = ca.height - gutterBottom;for (var i = 0; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();co.fillStyle = prop['chart.background.barcolor2'];co.strokeStyle = co.fillStyle;for (var i = 1; i < numbars; i += 2) {\n      co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);\n    }\n    co.fill();co.beginPath();var func = function func(obj, cacheCanvas, cacheContext) {\n      if (prop['chart.background.grid']) {\n        prop['chart.background.grid.autofit.numhlines'] += 0.0001;if (prop['chart.background.grid.autofit']) {\n          if (prop['chart.background.grid.autofit.align']) {\n            if (obj.type === 'hbar') {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n            if (obj.type === 'line') {\n              if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {} else if (prop['chart.labels'] && prop['chart.labels'].length) {\n                obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);\n              } else {\n                obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);\n              }\n            } else if (obj.type === 'waterfall') {\n              obj.set('backgroundGridAutofitNumvlines', obj.data.length + (prop['chart.total'] ? 1 : 0));\n            } else if ((obj.type === 'bar' || obj.type === 'scatter') && (prop['chart.labels'] && prop['chart.labels'].length || obj.type === 'bar')) {\n              var len = prop['chart.labels'] && prop['chart.labels'].length || obj.data.length;obj.set({ backgroundGridAutofitNumvlines: len });\n            } else if (obj.type === 'gantt') {\n              if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {} else {\n                obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);\n              }\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines'])) {\n              obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\n            }\n          }\n          var vsize = (cacheCanvas.width - gutterLeft - gutterRight) / prop['chart.background.grid.autofit.numvlines'];var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];obj.Set('chart.background.grid.vsize', vsize);obj.Set('chart.background.grid.hsize', hsize);\n        }\n        co.beginPath();cacheContext.lineWidth = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;cacheContext.strokeStyle = prop['chart.background.grid.color'];if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([3, 5]);\n        }\n        if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {\n          cacheContext.setLineDash([1, 3]);\n        }\n        co.beginPath();if (prop['chart.background.grid.hlines']) {\n          height = cacheCanvas.height - gutterBottom;\n          var hsize = prop['chart.background.grid.hsize'];for (y = gutterTop; y <= height; y += hsize) {\n            cacheContext.moveTo(gutterLeft, ma.round(y));cacheContext.lineTo(ca.width - gutterRight, ma.round(y));\n          }\n        }\n        if (prop['chart.background.grid.vlines']) {\n          var width = cacheCanvas.width - gutterRight;var vsize = prop['chart.background.grid.vsize'];for (x = gutterLeft; ma.round(x) <= width; x += vsize) {\n            cacheContext.moveTo(ma.round(x), gutterTop);cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);\n          }\n        }\n        if (prop['chart.background.grid.border']) {\n          cacheContext.strokeStyle = prop['chart.background.grid.color'];cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\n        }\n      }\n      cacheContext.stroke();cacheContext.beginPath();cacheContext.closePath();\n    };\n    RG.cachedDraw(obj, obj.uid + '_background', func);if (variant == '3d') {\n      co.restore();\n    }\n    if (typeof co.setLineDash == 'function') {\n      co.setLineDash([1, 0]);\n    }\n    co.stroke();if (typeof obj.properties['chart.title'] == 'string') {\n      var prop = obj.properties;RG.drawTitle(obj, prop['chart.title'], obj.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2, obj);\n    }\n  };RG.numberFormat = RG.number_format = function (obj, num) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var i;var prepend = arguments[2] ? String(arguments[2]) : '';var append = arguments[3] ? String(arguments[3]) : '';var output = '';var decimal = '';var decimal_seperator = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';RegExp.$1 = '';var i, j;if (typeof prop['chart.scale.formatter'] === 'function') {\n      return prop['chart.scale.formatter'](obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {\n      output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.drawBars = RG.DrawBars = function (obj) {\n    var prop = obj.properties;var co = obj.context;var ca = obj.canvas;var hbars = prop['chart.background.hbars'];if (hbars === null) {\n      return;\n    }\n    co.beginPath();for (i = 0, len = hbars.length; i < len; ++i) {\n      var start = hbars[i][0];var length = hbars[i][1];var color = hbars[i][2];if (RG.is_null(start)) start = obj.scale2.max;\n      if (start > obj.scale2.max) start = obj.scale2.max;if (RG.is_null(length)) length = obj.scale2.max - start;if (start + length > obj.scale2.max) length = obj.scale2.max - start;if (start + length < -1 * obj.scale2.max) length = -1 * obj.scale2.max - start;if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < obj.scale2.max * -2) {\n        length = obj.scale2.max * -2;\n      }\n      var x = prop['chart.gutter.left'];var y = obj.getYCoord(start);var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var h = obj.getYCoord(start + length) - y;if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {\n        h *= -1;y = y - h;\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        y = ca.height - y;h *= -1;\n      }\n      co.fillStyle = color;co.fillRect(x, y, w, h);\n    }\n  };RG.drawInGraphLabels = RG.DrawInGraphLabels = function (obj) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;var labels = prop['chart.labels.ingraph'];var labels_processed = [];var fgcolor = 'black';var bgcolor = 'white';var direction = 1;if (!labels) {\n      return;\n    }\n    for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] === 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] === 'string' || _typeof(labels[i]) === 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.noShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      for (var i = 0, len = labels_processed.length; i < len; i += 1) {\n        if (labels_processed[i]) {\n          var coords = obj.coords[i];if (coords && coords.length > 0) {\n            var x = obj.type == 'bar' ? coords[0] + coords[2] / 2 : coords[0];var y = obj.type == 'bar' ? coords[1] + coords[3] / 2 : coords[1];var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;co.beginPath();co.fillStyle = 'black';co.strokeStyle = 'black';if (obj.type === 'bar') {\n              if (obj.Get('chart.xaxispos') == 'top') {\n                length *= -1;\n              }\n              if (prop['chart.variant'] == 'dot') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else if (prop['chart.variant'] == 'arrow') {\n                co.moveTo(ma.round(x), obj.coords[i][1] - 5);co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);var text_x = ma.round(x);var text_y = obj.coords[i][1] - 5 - length;\n              } else {\n                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y - length);var text_x = ma.round(x);var text_y = y - length;\n              }\n              co.stroke();co.fill();\n            } else {\n              if (_typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][3] == 'number' && labels_processed[i][3] == -1) {\n                co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x), y + 5 + length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y + 5);co.lineTo(ma.round(x) - 3, y + 10);co.lineTo(ma.round(x) + 3, y + 10);co.closePath();var text_x = x;var text_y = y + 5 + length;\n              } else {\n                var text_x = x;var text_y = y - 5 - length;co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x), y - 5 - length);co.stroke();co.beginPath();co.moveTo(ma.round(x), y - 5);co.lineTo(ma.round(x) - 3, y - 10);co.lineTo(ma.round(x) + 3, y - 10);co.closePath();\n              }\n              co.fill();\n            }\n            co.beginPath();co.fillStyle = _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][1] === 'string' ? labels_processed[i][1] : 'black';RG.text2(obj, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': text_x, 'y': text_y + (obj.properties['chart.text.accessible'] ? 2 : 0), 'text': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][0] === 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) === 'object' && typeof labels_processed[i][2] === 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels ingraph' });co.fill();\n          }\n        }\n      }\n    }\n  };RG.fixEventObject = RG.FixEventObject = function (e) {\n    if (RG.ISOLD) {\n      var e = event;e.pageX = event.clientX + doc.body.scrollLeft;e.pageY = event.clientY + doc.body.scrollTop;e.target = event.srcElement;if (!doc.body.scrollTop && doc.documentElement.scrollTop) {\n        e.pageX += parseInt(doc.documentElement.scrollLeft);e.pageY += parseInt(doc.documentElement.scrollTop);\n      }\n    }\n    if (!e.stopPropagation) {\n      e.stopPropagation = function () {\n        window.event.cancelBubble = true;\n      };\n    }\n    return e;\n  };RG.hideCrosshairCoords = RG.HideCrosshairCoords = function () {\n    var div = RG.Registry.Get('chart.coordinates.coords.div');if (div && div.style.opacity == 1 && div.__object__.Get('chart.crosshairs.coords.fadeout')) {\n      var style = RG.Registry.Get('chart.coordinates.coords.div').style;setTimeout(function () {\n        style.opacity = 0.9;\n      }, 25);setTimeout(function () {\n        style.opacity = 0.8;\n      }, 50);setTimeout(function () {\n        style.opacity = 0.7;\n      }, 75);setTimeout(function () {\n        style.opacity = 0.6;\n      }, 100);setTimeout(function () {\n        style.opacity = 0.5;\n      }, 125);setTimeout(function () {\n        style.opacity = 0.4;\n      }, 150);setTimeout(function () {\n        style.opacity = 0.3;\n      }, 175);setTimeout(function () {\n        style.opacity = 0.2;\n      }, 200);setTimeout(function () {\n        style.opacity = 0.1;\n      }, 225);setTimeout(function () {\n        style.opacity = 0;\n      }, 250);setTimeout(function () {\n        style.display = 'none';\n      }, 275);\n    }\n  };RG.draw3DAxes = RG.Draw3DAxes = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'],\n        xaxis = prop['chart.variant.threed.xaxis'],\n        yaxis = prop['chart.variant.threed.yaxis'];\n    if (yaxis) {\n      RG.draw3DYAxis(obj);\n    }\n    if (xaxis) {\n      if (xaxispos === 'center') {\n        RG.path2(co, 'b m % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, gutterTop + halfGraphArea, gutterLeft + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight, gutterTop + halfGraphArea);\n      } else {\n        if (obj.type === 'hbar') {\n          var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];\n        } else {\n          var xaxisYCoord = obj.getYCoord(0);\n        }\n        RG.path2(co, 'm % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, xaxisYCoord, gutterLeft + offsetx, xaxisYCoord - offsety, ca.width - gutterRight + offsetx, xaxisYCoord - offsety, ca.width - gutterRight, xaxisYCoord);\n      }\n    }\n  };RG.draw3DYAxis = function (obj) {\n    var prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;var gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        xaxispos = prop['chart.xaxispos'],\n        graphArea = ca.height - gutterTop - gutterBottom,\n        halfGraphArea = graphArea / 2,\n        offsetx = prop['chart.variant.threed.offsetx'],\n        offsety = prop['chart.variant.threed.offsety'];\n    if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {\n      var x = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;\n    } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {\n      var x = ca.width - gutterRight;\n    } else {\n      var x = gutterLeft;\n    }\n    RG.path2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', x, gutterTop, x + offsetx, gutterTop - offsety, x + offsetx, ca.height - gutterBottom - offsety, x, ca.height - gutterBottom);\n  };RG.strokedCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();co.moveTo(x + (corner_tl ? r : 0), y);co.lineTo(x + w - (corner_tr ? r : 0), y);if (corner_tr) {\n      co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);\n    }\n    co.lineTo(x + w, y + h - (corner_br ? r : 0));if (corner_br) {\n      co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);\n    }\n    co.lineTo(x + (corner_bl ? r : 0), y + h);if (corner_bl) {\n      co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    }\n    co.lineTo(x, y + (corner_tl ? r : 0));if (corner_tl) {\n      co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    }\n    co.stroke();\n  };RG.filledCurvyRect = function (co, x, y, w, h) {\n    var r = arguments[5] ? arguments[5] : 3;var corner_tl = arguments[6] || arguments[6] == null ? true : false;var corner_tr = arguments[7] || arguments[7] == null ? true : false;var corner_br = arguments[8] || arguments[8] == null ? true : false;var corner_bl = arguments[9] || arguments[9] == null ? true : false;co.beginPath();if (corner_tl) {\n      co.moveTo(x + r, y + r);co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\n    } else {\n      co.fillRect(x, y, r, r);\n    }\n    if (corner_tr) {\n      co.moveTo(x + w - r, y + r);co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);\n    } else {\n      co.moveTo(x + w - r, y);co.fillRect(x + w - r, y, r, r);\n    }\n    if (corner_br) {\n      co.moveTo(x + w - r, y + h - r);co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);\n    } else {\n      co.moveTo(x + w - r, y + h - r);co.fillRect(x + w - r, y + h - r, r, r);\n    }\n    if (corner_bl) {\n      co.moveTo(x + r, y + h - r);co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\n    } else {\n      co.moveTo(x, y + h - r);co.fillRect(x, y + h - r, r, r);\n    }\n    co.fillRect(x + r, y, w - r - r, h);co.fillRect(x, y + r, r + 1, h - r - r);co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);co.fill();\n  };RG.hideZoomedCanvas = RG.HideZoomedCanvas = function () {\n    var interval = 10;var frames = 15;if (_typeof(RG.zoom_image) === 'object') {\n      var obj = RG.zoom_image.obj;var prop = obj.properties;\n    } else {\n      return;\n    }\n    if (prop['chart.zoom.fade.out']) {\n      for (var i = frames, j = 1; i >= 0; --i, ++j) {\n        if (_typeof(RG.zoom_image) === 'object') {\n          setTimeout(\"RGraph.zoom_image.style.opacity = \" + String(i / 10), j * interval);\n        }\n      }\n      if (_typeof(RG.zoom_background) === 'object') {\n        setTimeout(\"RGraph.zoom_background.style.opacity = \" + String(i / frames), j * interval);\n      }\n    }\n    if (_typeof(RG.zoom_image) === 'object') {\n      setTimeout(\"RGraph.zoom_image.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n    if (_typeof(RG.zoom_background) === 'object') {\n      setTimeout(\"RGraph.zoom_background.style.display = 'none'\", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);\n    }\n  };RG.addCustomEventListener = RG.AddCustomEventListener = function (obj, name, func) {\n    if (typeof RG.events[obj.uid] === 'undefined') {\n      RG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.events[obj.uid].push([obj, name, func]);return RG.events[obj.uid].length - 1;\n  };RG.fireCustomEvent = RG.FireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {\n        obj.properties['chart.events.mouseout'](obj);\n      }\n      if (obj[name]) {\n        obj[name](obj);\n      }\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.events) === 'object' && _typeof(RG.events[uid]) === 'object' && RG.events[uid].length > 0) {\n        for (var j = 0; j < RG.events[uid].length; ++j) {\n          if (RG.events[uid][j] && RG.events[uid][j][1] === name) {\n            RG.events[uid][j][2](obj);\n          }\n        }\n      }\n    }\n  };RGraph.removeAllCustomEventListeners = RGraph.RemoveAllCustomEventListeners = function () {\n    var id = arguments[0];if (id && RG.events[id]) {\n      RG.events[id] = [];\n    } else {\n      RG.events = [];\n    }\n  };RG.removeCustomEventListener = RG.RemoveCustomEventListener = function (obj, i) {\n    if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.id]) === 'object' && _typeof(RG.events[obj.id][i]) === 'object') {\n      RG.events[obj.id][i] = null;\n    }\n  };RG.drawBackgroundImage = RG.DrawBackgroundImage = function (obj) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (typeof prop['chart.background.image'] === 'string') {\n      if (typeof ca.__rgraph_background_image__ === 'undefined') {\n        var img = new Image();img.__object__ = obj;img.__canvas__ = ca;img.__context__ = co;img.src = obj.Get('chart.background.image');ca.__rgraph_background_image__ = img;\n      } else {\n        img = ca.__rgraph_background_image__;\n      }\n      img.onload = function () {\n        obj.__rgraph_background_image_loaded__ = true;RG.clear(ca);RG.redrawCanvas(ca);\n      };\n      var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var stretch = prop['chart.background.image.stretch'];var align = prop['chart.background.image.align'];if (typeof align === 'string') {\n        if (align.indexOf('right') != -1) {\n          var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;\n        } else {\n          var x = gutterLeft;\n        }\n        if (align.indexOf('bottom') != -1) {\n          var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;\n        } else {\n          var y = gutterTop;\n        }\n      } else {\n        var x = gutterLeft || 25;var y = gutterTop || 25;\n      }\n      var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;if (typeof prop['chart.background.image.w'] === 'number') w = prop['chart.background.image.w'];if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.background.image.alpha'];co.drawImage(img, x, y, w, h);co.globalAlpha = oldAlpha;\n    }\n  };RG.hasTooltips = function (obj) {\n    var prop = obj.properties;if (_typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips']) {\n      for (var i = 0, len = prop['chart.tooltips'].length; i < len; ++i) {\n        if (!RG.is_null(obj.Get('chart.tooltips')[i])) {\n          return true;\n        }\n      }\n    } else if (typeof prop['chart.tooltips'] === 'function') {\n      return true;\n    }\n    return false;\n  };RG.createUID = RG.CreateUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.OR.add = RG.OR.Add = function (obj) {\n    var uid = obj.uid;var id = obj.canvas.id;RG.ObjectRegistry.objects.byUID.push([uid, obj]);RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);\n  };RG.OR.remove = RG.OR.Remove = function (obj) {\n    var id = obj.id;var uid = obj.uid;for (var i = 0; i < RG.ObjectRegistry.objects.byUID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byUID[i] = null;\n      }\n    }\n    for (var i = 0; i < RG.ObjectRegistry.objects.byCanvasID.length; ++i) {\n      if (RG.ObjectRegistry.objects.byCanvasID[i] && RG.ObjectRegistry.objects.byCanvasID[i][1] && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\n        RG.ObjectRegistry.objects.byCanvasID[i] = null;\n      }\n    }\n  };RG.OR.clear = RG.OR.Clear = function () {\n    if (arguments[0]) {\n      var id = _typeof(arguments[0]) === 'object' ? arguments[0].id : arguments[0];var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.ObjectRegistry.remove(objects[i]);\n      }\n    } else {\n      RG.ObjectRegistry.objects = {};RG.ObjectRegistry.objects.byUID = [];RG.ObjectRegistry.objects.byCanvasID = [];\n    }\n  };RG.OR.list = RG.OR.List = function () {\n    var list = [];for (var i = 0, len = RG.ObjectRegistry.objects.byUID.length; i < len; ++i) {\n      if (RG.ObjectRegistry.objects.byUID[i]) {\n        list.push(RG.ObjectRegistry.objects.byUID[i][1].type);\n      }\n    }\n    if (arguments[0]) {\n      return list;\n    } else {\n      $p(list);\n    }\n  };RG.OR.clearByType = RG.OR.ClearByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i]) {\n        var uid = objects[i][0];var obj = objects[i][1];if (obj && obj.type == type) {\n          RG.ObjectRegistry.remove(obj);\n        }\n      }\n    }\n  };RG.OR.iterate = RG.OR.Iterate = function (func) {\n    var objects = RGraph.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (typeof arguments[1] === 'string') {\n        var types = arguments[1].split(/,/);for (var j = 0, len2 = types.length; j < len2; ++j) {\n          if (types[j] == objects[i][1].type) {\n            func(objects[i][1]);\n          }\n        }\n      } else {\n        func(objects[i][1]);\n      }\n    }\n  };RG.OR.getObjectsByCanvasID = function (id) {\n    var store = RG.ObjectRegistry.objects.byCanvasID;var ret = [];for (var i = 0, len = store.length; i < len; ++i) {\n      if (store[i] && store[i][0] == id) {\n        ret.push(store[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.firstbyxy = RG.OR.getFirstObjectByXY = RG.OR.getObjectByXY = function (e) {\n    var canvas = e.target;var ret = null;var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        return obj;\n      }\n    }\n  };RG.OR.getObjectsByXY = function (e) {\n    var canvas = e.target;var ret = [];var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);for (var i = objects.length - 1; i >= 0; --i) {\n      var obj = objects[i].getObjectByXY(e);if (obj) {\n        ret.push(obj);\n      }\n    }\n    return ret;\n  };RG.OR.get = RG.OR.getObjectByUID = function (uid) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1].uid == uid) {\n        return objects[i][1];\n      }\n    }\n  };RG.OR.bringToFront = function (obj) {\n    var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];RG.ObjectRegistry.remove(obj);RG.ObjectRegistry.add(obj);if (redraw) {\n      RG.redrawCanvas(obj.canvas);\n    }\n  };RG.OR.type = RG.OR.getObjectsByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;var ret = [];for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {\n        ret.push(objects[i][1]);\n      }\n    }\n    return ret;\n  };RG.OR.first = RG.OR.getFirstObjectByType = function (type) {\n    var objects = RG.ObjectRegistry.objects.byUID;for (var i = 0, len = objects.length; i < len; ++i) {\n      if (objects[i] && objects[i][1] && objects[i][1].type == type) {\n        return objects[i][1];\n      }\n    }\n    return null;\n  };RG.getAngleByXY = function (cx, cy, x, y) {\n    var angle = ma.atan((y - cy) / (x - cx));angle = ma.abs(angle);\n    if (x >= cx && y >= cy) {\n      angle += RG.TWOPI;\n    } else if (x >= cx && y < cy) {\n      angle = RG.HALFPI - angle + (RG.PI + RG.HALFPI);\n    } else if (x < cx && y < cy) {\n      angle += RG.PI;\n    } else {\n      angle = RG.PI - angle;\n    }\n    if (angle > RG.TWOPI) {\n      angle -= RG.TWOPI;\n    }\n    return angle;\n  };RG.getHypLength = function (x1, y1, x2, y2) {\n    var ret = ma.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));return ret;\n  };RG.getRadiusEndPoint = function (cx, cy, angle, radius) {\n    var x = cx + ma.cos(angle) * radius;var y = cy + ma.sin(angle) * radius;return [x, y];\n  };RG.installEventListeners = RG.InstallEventListeners = function (obj) {\n    var prop = obj.properties;if (RG.ISOLD) {\n      return;\n    }\n    if (RG.installCanvasClickListener) {\n      RG.installWindowMousedownListener(obj);RG.installWindowMouseupListener(obj);RG.installCanvasMousemoveListener(obj);RG.installCanvasMouseupListener(obj);RG.installCanvasMousedownListener(obj);RG.installCanvasClickListener(obj);\n    } else if (RG.hasTooltips(obj) || prop['chart.adjustable'] || prop['chart.annotatable'] || prop['chart.contextmenu'] || prop['chart.resizable'] || prop['chart.key.interactive'] || prop['chart.events.click'] || prop['chart.events.mousemove'] || typeof obj.onclick === 'function' || typeof obj.onmousemove === 'function') {\n      alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\n    }\n  };RG.pr = function (obj) {\n    var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n      return '';\n    }\n    switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n        str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n        str += 'function () {}';break;case 'undefined':\n        str += 'undefined';break;case 'null':\n        str += 'null';break;case 'object':\n        if (RGraph.is_null(obj)) {\n          str += indent + 'null\\n';\n        } else {\n          str += indent + 'Object {' + '\\n';\n          for (j in obj) {\n            str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\\n';\n          }\n          str += indent + '}';\n        }\n        break;default:\n        str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n    if (!arguments[1]) {\n      alert(str);\n    }\n    return str;\n  };RG.dashedLine = RG.DashedLine = function (co, x1, y1, x2, y2) {\n    var size = 5;if (typeof arguments[5] === 'number') {\n      size = arguments[5];\n    }\n    var dx = x2 - x1;var dy = y2 - y1;var num = ma.floor(ma.sqrt(dx * dx + dy * dy) / size);var xLen = dx / num;var yLen = dy / num;var count = 0;do {\n      count % 2 == 0 && count > 0 ? co.lineTo(x1, y1) : co.moveTo(x1, y1);x1 += xLen;y1 += yLen;\n    } while (count++ <= num);\n  };RG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.AJAX.getNumber = function (url, callback) {\n    RG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.AJAX.getString = function (url, callback) {\n    RG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.AJAX.getJSON = function (url, callback) {\n    RG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.AJAX.getCSV = function (url, callback) {\n    var seperator = arguments[2] ? arguments[2] : ',';RG.AJAX(url, function () {\n      var regexp = new RegExp(seperator);var arr = this.responseText.split(regexp);for (var i = 0, len = arr.length; i < len; ++i) {\n        arr[i] = parseFloat(arr[i]);\n      }\n      callback(arr);\n    });\n  };RG.rotateCanvas = RG.RotateCanvas = function (ca, x, y, angle) {\n    var co = ca.getContext('2d');co.translate(x, y);co.rotate(angle);co.translate(0 - x, 0 - y);\n  };RG.measureText = RG.MeasureText = function (text, bold, font, size) {\n    if (typeof RG.measuretext_cache === 'undefined') {\n      RG.measuretext_cache = [];\n    }\n    var str = text + ':' + bold + ':' + font + ':' + size;if (_typeof(RG.measuretext_cache) == 'object' && RG.measuretext_cache[str]) {\n      return RG.measuretext_cache[str];\n    }\n    if (!RG.measuretext_cache['text-div']) {\n      var div = document.createElement('DIV');div.style.position = 'absolute';div.style.top = '-100px';div.style.left = '-100px';document.body.appendChild(div);RG.measuretext_cache['text-div'] = div;\n    } else if (RG.measuretext_cache['text-div']) {\n      var div = RG.measuretext_cache['text-div'];\n    }\n    div.innerHTML = text.replace(/\\r\\n/g, '<br />');div.style.fontFamily = font;div.style.fontWeight = bold ? 'bold' : 'normal';div.style.fontSize = (size || 12) + 'pt';var size = [div.offsetWidth, div.offsetHeight];RG.measuretext_cache[str] = size;return size;\n  };RG.text2 = RG.Text2 = function (obj, opt) {\n    function domtext() {\n      if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {\n        opt.size = opt.size.replace(/ *italic +/, '');opt.italic = true;\n      }\n      var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;if (!ca.rgraph_domtext_wrapper) {\n        var wrapper = document.createElement('div');wrapper.id = ca.id + '_rgraph_domtext_wrapper';wrapper.className = 'rgraph_domtext_wrapper';wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';wrapper.style.width = ca.offsetWidth + 'px';wrapper.style.height = ca.offsetHeight + 'px';wrapper.style.cssFloat = ca.style.cssFloat;wrapper.style.display = ca.style.display || 'inline-block';wrapper.style.position = ca.style.position || 'relative';wrapper.style.left = ca.style.left;wrapper.style.top = ca.style.top;wrapper.style.width = ca.width + 'px';wrapper.style.height = ca.height + 'px';ca.style.position = 'absolute';ca.style.left = 0;ca.style.top = 0;ca.style.display = 'inline';ca.style.cssFloat = 'none';if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {\n          wrapper.style.transform = 'skewY(5.7deg)';\n        }\n        ca.parentNode.insertBefore(wrapper, ca);ca.parentNode.removeChild(ca);wrapper.appendChild(ca);ca.rgraph_domtext_wrapper = wrapper;\n      } else {\n        wrapper = ca.rgraph_domtext_wrapper;\n      }\n      var defaults = { size: 12, font: 'Arial', italic: 'normal', bold: 'normal', valign: 'bottom', halign: 'left', marker: true, color: co.fillStyle, bounding: { enabled: false, fill: 'rgba(255,255,255,0.7)', stroke: '#666' } };\n      opt.text = String(opt.text).replace(/\\r?\\n/g, '[[RETURN]]');if (typeof RG.text2.domNodeCache === 'undefined') {\n        RG.text2.domNodeCache = new Array();\n      }\n      if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {\n        RG.text2.domNodeCache[obj.id] = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache === 'undefined') {\n        RG.text2.domNodeDimensionCache = new Array();\n      }\n      if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {\n        RG.text2.domNodeDimensionCache[obj.id] = new Array();\n      }\n      if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {\n        var span = document.createElement('span');span.style.position = 'absolute';span.style.display = 'inline';span.style.left = opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width)) + 'px';span.style.top = opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)) + 'px';span.style.color = opt.color || defaults.color;span.style.fontFamily = opt.font || defaults.font;span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;span.style.fontStyle = opt.italic ? 'italic' : defaults.italic;span.style.fontSize = (opt.size || defaults.size) + 'pt';span.style.whiteSpace = 'nowrap';span.tag = opt.tag;if (typeof opt.angle === 'number' && opt.angle !== 0) {\n          var coords = RG.measureText(opt.text, opt.bold, opt.font, opt.size);span.style.transformOrigin = '100% 50%';span.style.transform = 'rotate(' + opt.angle + 'deg)';\n        }\n        span.style.textShadow = '{1}px {2}px {3}px {4}'.format(co.shadowOffsetX, co.shadowOffsetY, co.shadowBlur, co.shadowColor);if (opt.bounding) {\n          span.style.border = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;\n        }\n        if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' || obj.properties['chart.text.accessible.pointerevents']) && obj.properties['chart.text.accessible.pointerevents'] !== 'none') {\n          span.style.pointerEvents = 'auto';\n        } else {\n          span.style.pointerEvents = 'none';\n        }\n        span.style.padding = opt.bounding ? '2px' : null;span.__text__ = opt.text;\n        span.innerHTML = opt.text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');span.innerHTML = span.innerHTML.replace(/\\[\\[RETURN\\]\\]/g, '<br />');wrapper.appendChild(span);opt.halign = opt.halign || 'left';opt.valign = opt.valign || 'bottom';if (opt.halign === 'right') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth + 'px';span.style.textAlign = 'right';\n        } else if (opt.halign === 'center') {\n          span.style.left = parseFloat(span.style.left) - span.offsetWidth / 2 + 'px';span.style.textAlign = 'center';\n        }\n        if (opt.valign === 'top') {} else if (opt.valign === 'center') {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight / 2 + 'px';\n        } else {\n          span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\n        }\n        var offsetWidth = parseFloat(span.offsetWidth),\n            offsetHeight = parseFloat(span.offsetHeight),\n            top = parseFloat(span.style.top),\n            left = parseFloat(span.style.left);RG.text2.domNodeCache[obj.id][cacheKey] = span;RG.text2.domNodeDimensionCache[obj.id][cacheKey] = { left: left, top: top, width: offsetWidth, height: offsetHeight };span.id = cacheKey;\n      } else {\n        span = RG.text2.domNodeCache[obj.id][cacheKey];span.style.display = 'inline';var offsetWidth = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,\n            offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,\n            top = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,\n            left = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;\n      }\n      if (opt.marker) {\n        RG.path2(context, 'b m % % l % % m % % l % % s', opt.x - 5, opt.y, opt.x + 5, opt.y, opt.x, opt.y - 5, opt.x, opt.y + 5);\n      }\n      if (obj.type === 'drawing.text') {\n        if (obj.properties['chart.events.mousemove']) {\n          span.addEventListener('mousemove', function (e) {\n            obj.properties['chart.events.mousemove'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.events.click']) {\n          span.addEventListener('click', function (e) {\n            obj.properties['chart.events.click'](e, obj);\n          }, false);\n        }\n        if (obj.properties['chart.tooltips']) {\n          span.addEventListener(obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click', function (e) {\n            if (!RG.Registry.get('chart.tooltip') || RG.Registry.get('chart.tooltip').__index__ !== 0 || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid) {\n              RG.hideTooltip();RG.redraw();RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);\n            }\n          }, false);\n        }\n      }\n      var ret = {};ret.x = left;ret.y = top;ret.width = offsetWidth;ret.height = offsetHeight;ret.object = obj;ret.text = opt.text;ret.tag = opt.tag;RG.text2.domNodeCache.reset = function () {\n        if (arguments[0]) {\n          if (typeof arguments[0] === 'string') {\n            var ca = document.getElementById(arguments[0]);\n          } else {\n            var ca = arguments[0];\n          }\n          var nodes = RG.text2.domNodeCache[ca.id];for (j in nodes) {\n            var node = RG.text2.domNodeCache[ca.id][j];if (node && node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          }\n          RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n        } else {\n          for (i in RG.text2.domNodeCache) {\n            for (j in RG.text2.domNodeCache[i]) {\n              if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {\n                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);\n              }\n            }\n          }\n          RG.text2.domNodeCache = [];RG.text2.domNodeDimensionCache = [];\n        }\n      };RG.text2.find = function (opt) {\n        var span,\n            nodes = [];var id = typeof opt.id === 'string' ? opt.id : opt.object.id;for (i in RG.text2.domNodeCache[id]) {\n          span = RG.text2.domNodeCache[id][i];if (typeof opt.tag === 'string' && opt.tag === span.tag) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.tag) === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.tag);if (regexp.test(span.tag)) {\n              nodes.push(span);continue;\n            }\n          }\n          if (typeof opt.text === 'string' && opt.text === span.__text__) {\n            nodes.push(span);continue;\n          }\n          if (_typeof(opt.text) === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {\n            var regexp = new RegExp(opt.text);if (regexp.test(span.__text__)) {\n              nodes.push(span);continue;\n            }\n          }\n        }\n        return nodes;\n      };ret.node = span;if (obj && obj.isRGraph && obj.coordsText) {\n        obj.coordsText.push(ret);\n      }\n      return ret;\n    }\n    if (obj && obj.isRGraph) {\n      var obj = obj;var co = obj.context;var ca = obj.canvas;\n    } else if (typeof obj == 'string') {\n      var ca = document.getElementById(obj);var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (typeof obj.getContext === 'function') {\n      var ca = obj;var co = ca.getContext('2d');var obj = ca.__object__;\n    } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    } else if (RG.ISOLD && obj.fillText) {\n      var co = obj;var ca = obj.canvas;var obj = ca.__object__;\n    }\n    if (typeof opt.boundingFill === 'string') opt['bounding.fill'] = opt.boundingFill;if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {\n      return domtext();\n    }\n    var x = opt.x,\n        y = opt.y,\n        originalX = x,\n        originalY = y,\n        text = opt.text,\n        text_multiline = typeof text === 'string' ? text.split(/\\r?\\n/g) : '',\n        numlines = text_multiline.length,\n        font = opt.font ? opt.font : 'Arial',\n        size = opt.size ? opt.size : 10,\n        size_pixels = size * 1.5,\n        bold = opt.bold,\n        italic = opt.italic,\n        halign = opt.halign ? opt.halign : 'left',\n        valign = opt.valign ? opt.valign : 'bottom',\n        tag = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',\n        marker = opt.marker,\n        angle = opt.angle || 0;\n    var bounding = opt.bounding,\n        bounding_stroke = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',\n        bounding_fill = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',\n        bounding_shadow = opt['bounding.shadow'],\n        bounding_shadow_color = opt['bounding.shadow.color'] || '#ccc',\n        bounding_shadow_blur = opt['bounding.shadow.blur'] || 3,\n        bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,\n        bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,\n        bounding_linewidth = opt['bounding.linewidth'] || 1;var ret = {};if (typeof opt.color === 'string') {\n      var orig_fillstyle = co.fillStyle;co.fillStyle = opt.color;\n    }\n    if (typeof text == 'number') {\n      text = String(text);\n    }\n    if (typeof text !== 'string') {\n      return;\n    }\n    if (angle != 0) {\n      co.save();co.translate(x, y);co.rotate(ma.PI / 180 * angle);\n      x = 0;y = 0;\n    }\n    co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;var width = 0;for (var i = 0; i < numlines; ++i) {\n      width = ma.max(width, co.measureText(text_multiline[i]).width);\n    }\n    var height = size_pixels * numlines;if (opt.marker) {\n      var marker_size = 10;var strokestyle = co.strokeStyle;co.beginPath();co.strokeStyle = 'red';co.moveTo(x, y - marker_size);co.lineTo(x, y + marker_size);co.moveTo(x - marker_size, y);co.lineTo(x + marker_size, y);co.stroke();co.strokeStyle = strokestyle;\n    }\n    if (halign == 'center') {\n      co.textAlign = 'center';var boundingX = x - 2 - width / 2;\n    } else if (halign == 'right') {\n      co.textAlign = 'right';var boundingX = x - 2 - width;\n    } else {\n      co.textAlign = 'left';var boundingX = x - 2;\n    }\n    if (valign == 'center') {\n      co.textBaseline = 'middle';y -= 1;y -= (numlines - 1) / 2 * size_pixels;var boundingY = y - size_pixels / 2 - 2;\n    } else if (valign == 'top') {\n      co.textBaseline = 'top';var boundingY = y - 2;\n    } else {\n      co.textBaseline = 'bottom';if (numlines > 1) {\n        y -= (numlines - 1) * size_pixels;\n      }\n      var boundingY = y - size_pixels - 2;\n    }\n    var boundingW = width + 4;var boundingH = height + 4;if (bounding) {\n      var pre_bounding_linewidth = co.lineWidth;var pre_bounding_strokestyle = co.strokeStyle;var pre_bounding_fillstyle = co.fillStyle;var pre_bounding_shadowcolor = co.shadowColor;var pre_bounding_shadowblur = co.shadowBlur;var pre_bounding_shadowoffsetx = co.shadowOffsetX;var pre_bounding_shadowoffsety = co.shadowOffsetY;co.lineWidth = bounding_linewidth;co.strokeStyle = bounding_stroke;co.fillStyle = bounding_fill;if (bounding_shadow) {\n        co.shadowColor = bounding_shadow_color;co.shadowBlur = bounding_shadow_blur;co.shadowOffsetX = bounding_shadow_offsetx;co.shadowOffsetY = bounding_shadow_offsety;\n      }\n      co.strokeRect(boundingX, boundingY, boundingW, boundingH);co.fillRect(boundingX, boundingY, boundingW, boundingH);co.lineWidth = pre_bounding_linewidth;co.strokeStyle = pre_bounding_strokestyle;co.fillStyle = pre_bounding_fillstyle;co.shadowColor = pre_bounding_shadowcolor;\n      co.shadowBlur = pre_bounding_shadowblur;\n      co.shadowOffsetX = pre_bounding_shadowoffsetx;\n      co.shadowOffsetY = pre_bounding_shadowoffsety;\n    }\n    if (numlines > 1) {\n      for (var i = 0; i < numlines; ++i) {\n        co.fillText(text_multiline[i], x, y + size_pixels * i);\n      }\n    } else {\n      co.fillText(text, x + 0.5, y + 0.5);\n    }\n    if (angle != 0) {\n      if (angle == 90) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      } else if (angle == 180) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - width / 2 - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;\n          }\n        }\n      } else if (angle == 270) {\n        if (halign == 'left') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'center') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 4;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        } else if (halign == 'right') {\n          if (valign == 'bottom') {\n            boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'center') {\n            boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n          if (valign == 'top') {\n            boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;\n          }\n        }\n      }\n      co.restore();\n    }\n    co.textBaseline = 'alphabetic';co.textAlign = 'left';ret.x = boundingX;ret.y = boundingY;ret.width = boundingW;ret.height = boundingH;\n    ret.object = obj;ret.text = text;ret.tag = tag;if (obj && obj.isRGraph && obj.coordsText) {\n      obj.coordsText.push(ret);\n    }\n    if (typeof orig_fillstyle === 'string') {\n      co.fillStyle = orig_fillstyle;\n    }\n    return ret;\n  };RG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0;var grouped_index = 0;while (--index >= 0) {\n      if (RG.is_null(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.Highlight.rect = RG.Highlight.Rect = function (obj, shape) {\n    var ca = obj.canvas;var co = obj.context;var prop = obj.properties;if (prop['chart.tooltips.highlight']) {\n      co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.rect(shape['x'], shape['y'], shape['width'], shape['height']);co.stroke();co.fill();\n    }\n  };RG.Highlight.point = RG.Highlight.Point = function (obj, shape) {\n    var prop = obj.properties;var ca = obj.canvas;var co = obj.context;if (prop['chart.tooltips.highlight']) {\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];var radius = prop['chart.highlight.point.radius'] || 2;co.arc(shape['x'], shape['y'], radius, 0, RG.TWOPI, 0);co.stroke();co.fill();\n    }\n  };RG.parseDate = function (str) {\n    str = RG.trim(str);if (str === 'now') {\n      str = new Date().toString();\n    }\n    if (str.match(/^(\\d\\d)(?:-|\\/)(\\d\\d)(?:-|\\/)(\\d\\d\\d\\d)(.*)$/)) {\n      str = '{1}/{2}/{3}{4}'.format(RegExp.$3, RegExp.$2, RegExp.$1, RegExp.$4);\n    }\n    if (str.match(/^(\\d\\d\\d\\d)(-|\\/)(\\d\\d)(-|\\/)(\\d\\d)( |T)(\\d\\d):(\\d\\d):(\\d\\d)$/)) {\n      str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;\n    }\n    if (str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d$/)) {\n      str = str.replace(/-/g, '/');\n    }\n    if (str.match(/^\\d\\d:\\d\\d:\\d\\d$/)) {\n      var dateObj = new Date();var date = dateObj.getDate();var month = dateObj.getMonth() + 1;var year = dateObj.getFullYear();if (String(month).length === 1) month = '0' + month;if (String(date).length === 1) date = '0' + date;str = year + '/' + month + '/' + date + ' ' + str;\n    }\n    return Date.parse(str);\n  };RG.resetColorsToOriginalValues = function (obj) {\n    if (obj.original_colors) {\n      for (var j in obj.original_colors) {\n        if (typeof j === 'string' && j.substr(0, 6) === 'chart.') {\n          obj.properties[j] = RG.arrayClone(obj.original_colors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.colorsParsed = false;\n  };RG.linearGradient = RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2) {\n    var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);var numColors = arguments.length - 5;for (var i = 5; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 5) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.radialGradient = RG.RadialGradient = function (obj, x1, y1, r1, x2, y2, r2, color1, color2) {\n    var gradient = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);var numColors = arguments.length - 7;for (var i = 7; i < arguments.length; ++i) {\n      var color = arguments[i];var stop = (i - 7) / (numColors - 1);gradient.addColorStop(stop, color);\n    }\n    return gradient;\n  };RG.addEventListener = RG.AddEventListener = function (id, e, func) {\n    var type = arguments[3] ? arguments[3] : 'unknown';RG.Registry.get('chart.event.handlers').push([id, e, func, type]);\n  };RG.clearEventListeners = RG.ClearEventListeners = function (id) {\n    if (id && id == 'window') {\n      window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);\n    } else {\n      var canvas = document.getElementById(id);canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);\n    }\n  };RG.hidePalette = RG.HidePalette = function () {\n    var div = RG.Registry.get('palette');if ((typeof div === 'undefined' ? 'undefined' : _typeof(div)) == 'object' && div) {\n      div.style.visibility = 'hidden';div.style.display = 'none';RG.Registry.set('palette', null);\n    }\n  };RG.random = function (min, max) {\n    var dp = arguments[2] ? arguments[2] : 0;var r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.arrayRand = RG.arrayRandom = RG.random.array = function (num, min, max) {\n    for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.random(min, max, arguments[3]));\n    }\n    return arr;\n  };RG.noShadow = RG.NoShadow = function (obj) {\n    var co = obj.context;co.shadowColor = 'rgba(0,0,0,0)';co.shadowBlur = 0;co.shadowOffsetX = 0;co.shadowOffsetY = 0;\n  };RG.setShadow = RG.SetShadow = function (obj, color, offsetx, offsety, blur) {\n    var co = obj.context;co.shadowColor = color;co.shadowOffsetX = offsetx;co.shadowOffsetY = offsety;co.shadowBlur = blur;\n  };RG.Registry.set = RG.Registry.Set = function (name, value) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    RG.Registry.store[name] = value;return value;\n  };RG.Registry.get = RG.Registry.Get = function (name) {\n    name = name.replace(/([A-Z])/g, function (str) {\n      return '.' + String(RegExp.$1).toLowerCase();\n    });if (name.substr(0, 6) !== 'chart.') {\n      name = 'chart.' + name;\n    }\n    return RG.Registry.store[name];\n  };RG.degrees2Radians = function (deg) {\n    return deg * (RG.PI / 180);\n  };RG.log = function (n, base) {\n    return ma.log(n) / (base ? ma.log(base) : 1);\n  };RG.isArray = RG.is_array = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.trim = function (str) {\n    return RG.ltrim(RG.rtrim(str));\n  };RG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.isNull = RG.is_null = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.async = RG.Async = function (func) {\n    return setTimeout(func, arguments[1] ? arguments[1] : 1);\n  };RG.reset = RG.Reset = function (ca) {\n    ca.width = ca.width;RG.ObjectRegistry.clear(ca);ca.__rgraph_aa_translated__ = false;if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {\n      RG.text2.domNodeCache.reset(ca);\n    }\n    if (!RG.text2.domNodeCache) {\n      RG.text2.domNodeCache = [];\n    }\n    if (!RG.text2.domNodeDimensionCache) {\n      RG.text2.domNodeDimensionCache = [];\n    }\n    RG.text2.domNodeCache[ca.id] = [];RG.text2.domNodeDimensionCache[ca.id] = [];\n  };RG.att = RG.attribution = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties;if (!ca || !co) {\n      return;\n    }\n    var width = ca.width,\n        height = ca.height,\n        wrapper = document.getElementById('cvs').__object__.canvas.parentNode,\n        text = prop['chart.attribution.text'] || 'Free Charts with RGraph.net',\n        x = prop['chart.attribution.x'],\n        y = prop['chart.attribution.y'],\n        bold = prop['chart.attribution.bold'],\n        italic = prop['chart.attribution.italic'],\n        font = prop['chart.attribution.font'] || 'sans-serif',\n        size = prop['chart.attribution.size'] || 8,\n        underline = prop['chart.attribution.underline'] ? 'underline' : 'none',\n        color = typeof prop['chart.attribution.color'] === 'string' ? prop['chart.attribution.color'] : '',\n        href = typeof prop['chart.attribution.href'] === 'string' ? prop['chart.attribution.href'] : 'http://www.rgraph.net/canvas/index.html';if (wrapper.attribution_node) {\n      return;\n    }\n    var measurements = RG.measureText(text, bold, font, size);var a = document.createElement('A');a.href = href;a.innerHTML = text;a.target = '_blank';a.style.position = 'absolute';a.style.left = typeof x === 'number' ? x : wrapper.offsetWidth - measurements[0] - 5 + 'px';a.style.top = typeof y === 'number' ? y : wrapper.offsetHeight - measurements[1] + 'px';a.style.fontSize = size + 'pt';a.style.fontStyle = typeof italic === 'boolean' ? italic ? 'italic' : '' : 'italic', a.style.fontWeight = bold ? 'bold' : '', a.style.textDecoration = underline;a.style.fontFamily = font;a.style.color = color;wrapper.appendChild(a);wrapper.attribution_node = a;\n  };RG.getCanvasTag = function (id) {\n    id = (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' ? id.id : id;var canvas = doc.getElementById(id);return [id, canvas];\n  };RG.Effects.updateCanvas = RG.Effects.UpdateCanvas = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.Effects.getEasingMultiplier = function (frames, frame) {\n    return ma.pow(ma.sin(frame / frames * RG.HALFPI), 3);\n  };RG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.cachedDraw = function (obj, id, func) {\n    if (!RG.cache[id]) {\n      RG.cache[id] = {};RG.cache[id].object = obj;RG.cache[id].canvas = document.createElement('canvas');RG.cache[id].canvas.setAttribute('width', obj.canvas.width);RG.cache[id].canvas.setAttribute('height', obj.canvas.height);RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);RG.cache[id].canvas.__object__ = obj;RG.cache[id].context = RG.cache[id].canvas.getContext('2d');RG.cache[id].context.translate(0.5, 0.5);func(obj, RG.cache[id].canvas, RG.cache[id].context);\n    }\n    obj.context.drawImage(RG.cache[id].canvas, -0.5, -0.5);\n  };RG.parseObjectStyleConfig = function (obj, config) {\n    var recurse = function recurse(obj, config, name, settings) {\n      var i;for (key in config) {\n        if (key.match(/^exec[0-9]*$/)) {\n          config[key](obj, settings);continue;\n        }\n        var isObject = false;var isArray = false;var value = config[key];while (key.match(/([A-Z])/)) {\n          key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n        }\n        if (!RG.isNull(value) && value.constructor) {\n          isObject = value.constructor.toString().indexOf('Object') > 0;isArray = value.constructor.toString().indexOf('Array') > 0;\n        }\n        if (isObject && !isArray) {\n          recurse(obj, config[key], name + '.' + key, settings);\n        } else if (key === 'self') {\n          settings[name] = value;\n        } else {\n          settings[name + '.' + key] = value;\n        }\n      }\n      return settings;\n    };var settings = recurse(obj, config, 'chart', {});for (key in settings) {\n      if (typeof key === 'string') {\n        obj.set(key, settings[key]);\n      }\n    }\n  };RG.path2 = function (co, p) {\n    var args = arguments;if (typeof p === 'string') {\n      p = splitstring(p);\n    }\n    RG.path2.last = RG.arrayClone(p);for (var i = 0, len = p.length; i < len; i += 1) {\n      switch (p[i]) {case 'b':\n          co.beginPath();break;case 'c':\n          co.closePath();break;case 'm':\n          co.moveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'l':\n          co.lineTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 's':\n          if (p[i + 1]) co.strokeStyle = p[i + 1];co.stroke();i++;break;case 'f':\n          if (p[i + 1]) {\n            co.fillStyle = p[i + 1];\n          }co.fill();i++;break;case 'qc':\n          co.quadraticCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'bc':\n          co.bezierCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'r':\n          co.rect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'a':\n          co.arc(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), p[i + 6] === 'true' || p[i + 6] === true || p[i + 6] === 1 || p[i + 6] === '1' ? true : false);i += 6;break;case 'at':\n          co.arcTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]));i += 5;break;case 'lw':\n          co.lineWidth = parseFloat(p[i + 1]);i++;break;case 'e':\n          co.ellipse(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]), parseFloat(p[i + 7]), p[i + 8] === 'true' ? true : false);i += 8;break;case 'lj':\n          co.lineJoin = p[i + 1];i++;break;case 'lc':\n          co.lineCap = p[i + 1];i++;break;case 'sc':\n          co.shadowColor = p[i + 1];i++;break;case 'sb':\n          co.shadowBlur = parseFloat(p[i + 1]);i++;break;case 'sx':\n          co.shadowOffsetX = parseFloat(p[i + 1]);i++;break;case 'sy':\n          co.shadowOffsetY = parseFloat(p[i + 1]);i++;break;case 'fs':\n          co.fillStyle = p[i + 1];i++;break;case 'ss':\n          co.strokeStyle = p[i + 1];i++;break;case 'fr':\n          co.fillRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'sr':\n          co.strokeRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'cl':\n          co.clip();break;case 'sa':\n          co.save();break;case 'rs':\n          co.restore();break;case 'tr':\n          co.translate(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'sl':\n          co.scale(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;case 'ro':\n          co.rotate(parseFloat(p[i + 1]));i++;break;case 'tf':\n          co.transform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'stf':\n          co.setTransform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;case 'cr':\n          co.clearRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;case 'ld':\n          var parts = p[i + 1];co.setLineDash(parts);i += 1;break;case 'ldo':\n          co.lineDashOffset = p[i + 1];i++;break;case 'fo':\n          co.font = p[i + 1];i++;break;case 'ft':\n          co.fillText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'st':\n          co.strokeText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;case 'ta':\n          co.textAlign = p[i + 1];i++;break;case 'tbl':\n          co.textBaseline = p[i + 1];i++;break;case 'ga':\n          co.globalAlpha = parseFloat(p[i + 1]);i++;break;case 'gco':\n          co.globalCompositeOperation = p[i + 1];i++;break;case 'fu':\n          p[i + 1](co.canvas.__object__);i++;break;case '':\n          break;default:\n          alert('[ERROR] Unknown option: ' + p[i]);}\n    }\n    function splitstring(p) {\n      var ret = [],\n          buffer = '',\n          inquote = false,\n          quote = '',\n          substitutionIndex = 2;for (var i = 0; i < p.length; i += 1) {\n        var chr = p[i],\n            isWS = chr.match(/ /);if (isWS) {\n          if (!inquote) {\n            if (buffer[0] === '\"' || buffer[0] === \"'\") {\n              buffer = buffer.substr(1, buffer.length - 2);\n            }\n            if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\n              buffer = args[substitutionIndex++];\n            }\n            ret.push(buffer);buffer = '';\n          } else {\n            buffer += chr;\n          }\n        } else {\n          if (chr === \"'\" || chr === '\"') {\n            inquote = !inquote;\n          }\n          buffer += chr;\n        }\n      }\n      if (buffer.trim() === '%' && args[substitutionIndex]) {\n        buffer = args[substitutionIndex++];\n      }\n      ret.push(buffer);return ret;\n    }\n  };RG.wrap = function () {};\n})(window, document);window.$p = function (v) {\n  RGraph.pr(arguments[0], arguments[1], arguments[3]);\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uY29yZS5qcz9kZTdmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy5IaWdobGlnaHQgPSB7fTtSRy5SZWdpc3RyeSA9IHt9O1JHLlJlZ2lzdHJ5LnN0b3JlID0gW107UkcuUmVnaXN0cnkuc3RvcmVbJ2NoYXJ0LmV2ZW50LmhhbmRsZXJzJ10gPSBbXTtSRy5SZWdpc3RyeS5zdG9yZVsnX19yZ3JhcGhfZXZlbnRfbGlzdGVuZXJzX18nXSA9IFtdO1JHLkJhY2tncm91bmQgPSB7fTtSRy5iYWNrZ3JvdW5kID0ge307Ukcub2JqZWN0cyA9IFtdO1JHLlJlc2l6aW5nID0ge307UkcuZXZlbnRzID0gW107UkcuY3Vyc29yID0gW107UkcuRWZmZWN0cyA9IFJHLkVmZmVjdHMgfHwge307UkcuY2FjaGUgPSBbXTtSRy5PYmplY3RSZWdpc3RyeSA9IHt9O1JHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMgPSB7fTtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEID0gW107UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieUNhbnZhc0lEID0gW107UkcuT1IgPSBSRy5PYmplY3RSZWdpc3RyeTtSRy5QSSA9IG1hLlBJO1JHLkhBTEZQSSA9IFJHLlBJIC8gMjtSRy5UV09QSSA9IFJHLlBJICogMjtSRy5JU0ZGID0gdWEuaW5kZXhPZignRmlyZWZveCcpICE9IC0xO1JHLklTT1BFUkEgPSB1YS5pbmRleE9mKCdPcGVyYScpICE9IC0xO1JHLklTQ0hST01FID0gdWEuaW5kZXhPZignQ2hyb21lJykgIT0gLTE7UkcuSVNTQUZBUkkgPSB1YS5pbmRleE9mKCdTYWZhcmknKSAhPSAtMSAmJiAhUkcuSVNDSFJPTUU7UkcuSVNXRUJLSVQgPSB1YS5pbmRleE9mKCdXZWJLaXQnKSAhPSAtMTtSRy5JU0lFID0gdWEuaW5kZXhPZignVHJpZGVudCcpID4gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA+IDA7UkcuSVNJRTYgPSB1YS5pbmRleE9mKCdNU0lFIDYnKSA+IDA7UkcuSVNJRTcgPSB1YS5pbmRleE9mKCdNU0lFIDcnKSA+IDA7UkcuSVNJRTggPSB1YS5pbmRleE9mKCdNU0lFIDgnKSA+IDA7UkcuSVNJRTkgPSB1YS5pbmRleE9mKCdNU0lFIDknKSA+IDA7UkcuSVNJRTEwID0gdWEuaW5kZXhPZignTVNJRSAxMCcpID4gMDtSRy5JU09MRCA9IFJHcmFwaC5JU0lFNiB8fCBSR3JhcGguSVNJRTcgfHwgUkdyYXBoLklTSUU4O1JHLklTSUUxMVVQID0gdWEuaW5kZXhPZignTVNJRScpID09IC0xICYmIHVhLmluZGV4T2YoJ1RyaWRlbnQnKSA+IDA7UkcuSVNJRTEwVVAgPSBSRy5JU0lFMTAgfHwgUkcuSVNJRTExVVA7UkcuSVNJRTlVUCA9IFJHLklTSUU5IHx8IFJHLklTSUUxMFVQO1JHLmdldFNjYWxlID0gZnVuY3Rpb24gKG1heCwgb2JqKSB7XG4gICAgaWYgKG1heCA9PSAwKSB7XG4gICAgICByZXR1cm4gWycwLjInLCAnMC40JywgJzAuNicsICcwLjgnLCAnMS4wJ107XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbF9tYXggPSBtYXg7aWYgKG1heCA8PSAxKSB7XG4gICAgICBpZiAobWF4ID4gMC41KSB7XG4gICAgICAgIHJldHVybiBbMC4yLCAwLjQsIDAuNiwgMC44LCBOdW1iZXIoMSkudG9GaXhlZCgxKV07XG4gICAgICB9IGVsc2UgaWYgKG1heCA+PSAwLjEpIHtcbiAgICAgICAgcmV0dXJuIG9iai5HZXQoJ2NoYXJ0LnNjYWxlLnJvdW5kJykgPyBbMC4yLCAwLjQsIDAuNiwgMC44LCAxXSA6IFswLjEsIDAuMiwgMC4zLCAwLjQsIDAuNV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdG1wID0gbWF4O3ZhciBleHAgPSAwO3doaWxlICh0bXAgPCAxLjAxKSB7XG4gICAgICAgICAgZXhwICs9IDE7dG1wICo9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBbJzJlLScgKyBleHAsICc0ZS0nICsgZXhwLCAnNmUtJyArIGV4cCwgJzhlLScgKyBleHAsICcxMGUtJyArIGV4cF07aWYgKG1heCA8PSAnNWUtJyArIGV4cCkge1xuICAgICAgICAgIHJldCA9IFsnMWUtJyArIGV4cCwgJzJlLScgKyBleHAsICczZS0nICsgZXhwLCAnNGUtJyArIGV4cCwgJzVlLScgKyBleHBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChTdHJpbmcobWF4KS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICBtYXggPSBTdHJpbmcobWF4KS5yZXBsYWNlKC9cXC5cXGQrJC8sICcnKTtcbiAgICB9XG4gICAgdmFyIGludGVydmFsID0gbWEucG93KDEwLCBOdW1iZXIoU3RyaW5nKE51bWJlcihtYXgpKS5sZW5ndGggLSAxKSk7dmFyIHRvcFZhbHVlID0gaW50ZXJ2YWw7d2hpbGUgKHRvcFZhbHVlIDwgbWF4KSB7XG4gICAgICB0b3BWYWx1ZSArPSBpbnRlcnZhbCAvIDI7XG4gICAgfVxuICAgIGlmIChOdW1iZXIob3JpZ2luYWxfbWF4KSA+IE51bWJlcih0b3BWYWx1ZSkpIHtcbiAgICAgIHRvcFZhbHVlICs9IGludGVydmFsIC8gMjtcbiAgICB9XG4gICAgaWYgKG1heCA8IDEwKSB7XG4gICAgICB0b3BWYWx1ZSA9IE51bWJlcihvcmlnaW5hbF9tYXgpIDw9IDUgPyA1IDogMTA7XG4gICAgfVxuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai5HZXQoJ2NoYXJ0LnNjYWxlLnJvdW5kJykgPT0gJ2Jvb2xlYW4nICYmIG9iai5HZXQoJ2NoYXJ0LnNjYWxlLnJvdW5kJykpIHtcbiAgICAgIHRvcFZhbHVlID0gMTAgKiBpbnRlcnZhbDtcbiAgICB9XG4gICAgcmV0dXJuIFt0b3BWYWx1ZSAqIDAuMiwgdG9wVmFsdWUgKiAwLjQsIHRvcFZhbHVlICogMC42LCB0b3BWYWx1ZSAqIDAuOCwgdG9wVmFsdWVdO1xuICB9O1JHLmdldFNjYWxlMiA9IGZ1bmN0aW9uIChvYmosIG9wdCkge1xuICAgIHZhciBjYSA9IG9iai5jYW52YXMsXG4gICAgICAgIGNvID0gb2JqLmNvbnRleHQsXG4gICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcyxcbiAgICAgICAgbnVtbGFiZWxzID0gdHlwZW9mIG9wdFsneWxhYmVscy5jb3VudCddID09ICdudW1iZXInID8gb3B0Wyd5bGFiZWxzLmNvdW50J10gOiA1LFxuICAgICAgICB1bml0c19wcmUgPSB0eXBlb2Ygb3B0Wyd1bml0cy5wcmUnXSA9PSAnc3RyaW5nJyA/IG9wdFsndW5pdHMucHJlJ10gOiAnJyxcbiAgICAgICAgdW5pdHNfcG9zdCA9IHR5cGVvZiBvcHRbJ3VuaXRzLnBvc3QnXSA9PSAnc3RyaW5nJyA/IG9wdFsndW5pdHMucG9zdCddIDogJycsXG4gICAgICAgIG1heCA9IE51bWJlcihvcHRbJ21heCddKSxcbiAgICAgICAgbWluID0gdHlwZW9mIG9wdFsnbWluJ10gPT0gJ251bWJlcicgPyBvcHRbJ21pbiddIDogMCxcbiAgICAgICAgc3RyaWN0ID0gb3B0WydzdHJpY3QnXSxcbiAgICAgICAgZGVjaW1hbHMgPSBOdW1iZXIob3B0WydzY2FsZS5kZWNpbWFscyddKSxcbiAgICAgICAgcG9pbnQgPSBvcHRbJ3NjYWxlLnBvaW50J10sXG4gICAgICAgIHRob3VzYW5kID0gb3B0WydzY2FsZS50aG91c2FuZCddLFxuICAgICAgICBvcmlnaW5hbF9tYXggPSBtYXgsXG4gICAgICAgIHJvdW5kID0gb3B0WydzY2FsZS5yb3VuZCddLFxuICAgICAgICBzY2FsZSA9IHsgbWF4OiAxLCBsYWJlbHM6IFtdLCB2YWx1ZXM6IFtdIH07XG4gICAgaWYgKCFtYXgpIHtcbiAgICAgIHZhciBtYXggPSAxO2ZvciAodmFyIGkgPSAwOyBpIDwgbnVtbGFiZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gKCgobWF4IC0gbWluKSAvIG51bWxhYmVscyArIG1pbikgKiAoaSArIDEpKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS5sYWJlbHMucHVzaCh1bml0c19wcmUgKyBsYWJlbCArIHVuaXRzX3Bvc3QpO3NjYWxlLnZhbHVlcy5wdXNoKHBhcnNlRmxvYXQobGFiZWwpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heCA8PSAxICYmICFzdHJpY3QpIHtcbiAgICAgIHZhciBhcnIgPSBbMSwgMC41LCAwLjEwLCAwLjA1LCAwLjAxMCwgMC4wMDUsIDAuMDAxMCwgMC4wMDA1LCAwLjAwMDEwLCAwLjAwMDA1LCAwLjAwMDAxMCwgMC4wMDAwMDUsIDAuMDAwMDAxMCwgMC4wMDAwMDA1LCAwLjAwMDAwMDEwLCAwLjAwMDAwMDA1LCAwLjAwMDAwMDAxMCwgMC4wMDAwMDAwMDUsIDAuMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDA1LCAwLjAwMDAwMDAwMDEwLCAwLjAwMDAwMDAwMDA1LCAwLjAwMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDAwMDUsIDAuMDAwMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDAwMDA1XSxcbiAgICAgICAgICB2YWxzID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1heCA+IGFycltpXSkge1xuICAgICAgICAgIGktLTticmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2NhbGUubWF4ID0gYXJyW2ldO1xuICAgICAgc2NhbGUubGFiZWxzID0gW107c2NhbGUudmFsdWVzID0gW107Zm9yICh2YXIgaiA9IDA7IGogPCBudW1sYWJlbHM7ICsraikge1xuICAgICAgICB2YXIgdmFsdWUgPSAoKGFycltpXSAtIG1pbikgLyBudW1sYWJlbHMgKiAoaiArIDEpICsgbWluKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS52YWx1ZXMucHVzaCh2YWx1ZSk7c2NhbGUubGFiZWxzLnB1c2goUkcubnVtYmVyRm9ybWF0KG9iaiwgdmFsdWUsIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgbWF4ID0gbWEuY2VpbChtYXgpO3ZhciBpbnRlcnZhbCA9IG1hLnBvdygxMCwgbWEubWF4KDEsIE51bWJlcihTdHJpbmcoTnVtYmVyKG1heCkgLSBOdW1iZXIobWluKSkubGVuZ3RoIC0gMSkpKTt2YXIgdG9wVmFsdWUgPSBpbnRlcnZhbDt3aGlsZSAodG9wVmFsdWUgPCBtYXgpIHtcbiAgICAgICAgdG9wVmFsdWUgKz0gaW50ZXJ2YWwgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKE51bWJlcihvcmlnaW5hbF9tYXgpID4gTnVtYmVyKHRvcFZhbHVlKSkge1xuICAgICAgICB0b3BWYWx1ZSArPSBpbnRlcnZhbCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAobWF4IDw9IDEwKSB7XG4gICAgICAgIHRvcFZhbHVlID0gTnVtYmVyKG9yaWdpbmFsX21heCkgPD0gNSA/IDUgOiAxMDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogJiYgdHlwZW9mIHJvdW5kID09ICdib29sZWFuJyAmJiByb3VuZCkge1xuICAgICAgICB0b3BWYWx1ZSA9IDEwICogaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBzY2FsZS5tYXggPSB0b3BWYWx1ZTt2YXIgdG1wX3BvaW50ID0gcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXTt2YXIgdG1wX3Rob3VzYW5kID0gcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXTtvYmouU2V0KCdjaGFydC5zY2FsZS50aG91c2FuZCcsIHRob3VzYW5kKTtvYmouU2V0KCdjaGFydC5zY2FsZS5wb2ludCcsIHBvaW50KTtmb3IgKHZhciBpID0gMDsgaSA8IG51bWxhYmVsczsgKytpKSB7XG4gICAgICAgIHNjYWxlLmxhYmVscy5wdXNoKFJHLm51bWJlcl9mb3JtYXQob2JqLCAoKGkgKyAxKSAvIG51bWxhYmVscyAqICh0b3BWYWx1ZSAtIG1pbikgKyBtaW4pLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpKTtzY2FsZS52YWx1ZXMucHVzaCgoKGkgKyAxKSAvIG51bWxhYmVscyAqICh0b3BWYWx1ZSAtIG1pbikgKyBtaW4pLnRvRml4ZWQoZGVjaW1hbHMpKTtcbiAgICAgIH1cbiAgICAgIG9iai5TZXQoJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJywgdG1wX3Rob3VzYW5kKTtvYmouU2V0KCdjaGFydC5zY2FsZS5wb2ludCcsIHRtcF9wb2ludCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4ID09ICdudW1iZXInICYmIHN0cmljdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1sYWJlbHM7ICsraSkge1xuICAgICAgICBzY2FsZS5sYWJlbHMucHVzaChSRy5udW1iZXJGb3JtYXQob2JqLCAoKGkgKyAxKSAvIG51bWxhYmVscyAqIChtYXggLSBtaW4pICsgbWluKS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSk7c2NhbGUudmFsdWVzLnB1c2goKChpICsgMSkgLyBudW1sYWJlbHMgKiAobWF4IC0gbWluKSArIG1pbikudG9GaXhlZChkZWNpbWFscykpO1xuICAgICAgfVxuICAgICAgc2NhbGUubWF4ID0gbWF4O1xuICAgIH1cbiAgICBzY2FsZS51bml0c19wcmUgPSB1bml0c19wcmU7c2NhbGUudW5pdHNfcG9zdCA9IHVuaXRzX3Bvc3Q7c2NhbGUucG9pbnQgPSBwb2ludDtzY2FsZS5kZWNpbWFscyA9IGRlY2ltYWxzO3NjYWxlLnRob3VzYW5kID0gdGhvdXNhbmQ7c2NhbGUubnVtbGFiZWxzID0gbnVtbGFiZWxzO3NjYWxlLnJvdW5kID0gQm9vbGVhbihyb3VuZCk7c2NhbGUubWluID0gbWluO2ZvciAodmFyIGkgPSAwOyBpIDwgc2NhbGUudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzY2FsZS52YWx1ZXNbaV0gPSBwYXJzZUZsb2F0KHNjYWxlLnZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtSRy5hcnJheUludmVydCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJbaV0gPSAhYXJyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1JHLmFycmF5VHJpbSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNvbnRlbnQgPSBmYWxzZTtmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICBjb250ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIG91dC5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCA9IFJHLmFycmF5UmV2ZXJzZShvdXQpO3ZhciBvdXQyID0gW10sXG4gICAgICAgIGNvbnRlbnQgPSBmYWxzZTtmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG91dFtpXSkge1xuICAgICAgICBjb250ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIG91dDIucHVzaChvdXRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQyID0gUkcuYXJyYXlSZXZlcnNlKG91dDIpO3JldHVybiBvdXQyO1xuICB9O1JHLmFycmF5Q2xvbmUgPSBSRy5hcnJheV9jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8ICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gW107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRlbXBbaV0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgICAgICB9KG9ialtpXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRlbXBbaV0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgICAgICB9KG9ialtpXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGVtcFtpXSA9IG9ialtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBbaV0gPSBSRy5hcnJheUNsb25lKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wO1xuICB9O1JHLmFycmF5TWF4ID0gUkcuYXJyYXlfbWF4ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBtYXggPSBudWxsLFxuICAgICAgICBtYSA9IE1hdGg7XG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBpZiAoUkcuaXNOdWxsKGFycikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAodHlwZW9mIGFycltpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1sxXSA/IG1hLmFicyhhcnJbaV0pIDogYXJyW2ldO2lmICh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG1heCA9IG1hLm1heChtYXgsIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH07UkcuYXJyYXlNaW4gPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG1heCA9IG51bGwsXG4gICAgICAgIG1pbiA9IG51bGwsXG4gICAgICAgIG1hID0gTWF0aDtpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGlmIChSRy5pc051bGwoYXJyKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdmFsID0gYXJndW1lbnRzWzFdID8gbWEuYWJzKGFycltpXSkgOiBhcnJbaV07aWYgKHR5cGVvZiBtaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbWluID0gbWEubWluKG1pbiwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfTtSRy5hcnJheVBhZCA9IFJHLmFycmF5X3BhZCA9IGZ1bmN0aW9uIChhcnIsIGxlbikge1xuICAgIGlmIChhcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICB2YXIgdmFsID0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogbnVsbDtmb3IgKHZhciBpID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtSRy5hcnJheVN1bSA9IFJHLmFycmF5X3N1bSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICBpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGlmIChSRy5pc19udWxsKGFycikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgaSxcbiAgICAgICAgc3VtLFxuICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO2ZvciAoaSA9IDAsIHN1bSA9IDA7IGkgPCBsZW47IHN1bSArPSBhcnJbaSsrXSkge31yZXR1cm4gc3VtO1xuICB9O1JHLmFycmF5TGluZWFyaXplID0gUkcuYXJyYXlfbGluZWFyaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKF90eXBlb2YoYXJnc1tpXSkgPT09ICdvYmplY3QnICYmIGFyZ3NbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBhcmdzW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraikge1xuICAgICAgICAgIHZhciBzdWIgPSBSRy5hcnJheV9saW5lYXJpemUoYXJnc1tpXVtqXSk7Zm9yICh2YXIgayA9IDAsIGxlbjMgPSBzdWIubGVuZ3RoOyBrIDwgbGVuMzsgKytrKSB7XG4gICAgICAgICAgICBhcnIucHVzaChzdWJba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyLnB1c2goYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07UkcuYXJyYXlTaGlmdCA9IFJHLmFycmF5X3NoaWZ0ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciByZXQgPSBbXTtmb3IgKHZhciBpID0gMSwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByZXQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1JHLmFycmF5UmV2ZXJzZSA9IFJHLmFycmF5X3JldmVyc2UgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgaWYgKCFhcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld2FyciA9IFtdO2ZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIG5ld2Fyci5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdhcnI7XG4gIH07UkcuYWJzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBtYS5hYnModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoaSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpID09PSAnbnVtYmVyJyB8fCAodHlwZW9mIGkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGkpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YWx1ZVtpXSA9IFJHLmFicyh2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07UkcuY2xlYXIgPSBSRy5DbGVhciA9IGZ1bmN0aW9uIChjYSkge1xuICAgIHZhciBvYmogPSBjYS5fX29iamVjdF9fLFxuICAgICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgIGNvbG9yID0gYXJndW1lbnRzWzFdIHx8IG9iaiAmJiBvYmouZ2V0KCdjbGVhcnRvJyk7XG4gICAgaWYgKCFjYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQob2JqLCAnb25iZWZvcmVjbGVhcicpO2lmIChSRy50ZXh0Mi5kb21Ob2RlQ2FjaGUgJiYgUkcudGV4dDIuZG9tTm9kZUNhY2hlW2NhLmlkXSkge1xuICAgICAgZm9yICh2YXIgaSBpbiBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbY2EuaWRdKSB7XG4gICAgICAgIHZhciBlbCA9IFJHLnRleHQyLmRvbU5vZGVDYWNoZVtjYS5pZF1baV07aWYgKGVsICYmIGVsLnN0eWxlKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbG9yIHx8IGNvbG9yICYmIGNvbG9yID09PSAncmdiYSgwLDAsMCwwKScgfHwgY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgIGNvLmNsZWFyUmVjdCgtMTAwLCAtMTAwLCBjYS53aWR0aCArIDIwMCwgY2EuaGVpZ2h0ICsgMjAwKTtjby5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIH0gZWxzZSBpZiAoY29sb3IpIHtcbiAgICAgIFJHLnBhdGgyKGNvLCAnZnMgJSBmciAtMTAwIC0xMDAgJSAlJywgY29sb3IsIGNhLndpZHRoICsgMjAwLCBjYS5oZWlnaHQgKyAyMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5wYXRoMihjbywgJ2ZzICUgZnIgLTEwMCAtMTAwICUgJScsIG9iai5nZXQoJ2NsZWFydG8nKSwgY2Eud2lkdGggKyAyMDAsIGNhLmhlaWdodCArIDIwMCk7XG4gICAgfVxuICAgIGlmIChSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuJyArIGNhLmlkKSkge1xuICAgICAgdmFyIGltZyA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS4nICsgY2EuaWQpO2ltZy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7aW1nLnN0eWxlLmxlZnQgPSAnLTEwMDAwcHgnO2ltZy5zdHlsZS50b3AgPSAnLTEwMDAwcHgnO1xuICAgIH1cbiAgICBpZiAoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwJykgJiYgb2JqICYmICFvYmouZ2V0KCdjaGFydC50b29sdGlwcy5ub2hpZGVvbmNsZWFyJykpIHtcbiAgICAgIFJHLkhpZGVUb29sdGlwKGNhKTtcbiAgICB9XG4gICAgY2Euc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1JHLkZpcmVDdXN0b21FdmVudChvYmosICdvbmNsZWFyJyk7XG4gIH07UkcuZHJhd1RpdGxlID0gUkcuRHJhd1RpdGxlID0gZnVuY3Rpb24gKG9iaiwgdGV4dCwgZ3V0dGVyVG9wKSB7XG4gICAgdmFyIGNhID0gY2FudmFzID0gb2JqLmNhbnZhcyxcbiAgICAgICAgY28gPSBjb250ZXh0ID0gb2JqLmNvbnRleHQsXG4gICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcztcbiAgICBndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSwgZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgZ3V0dGVyVG9wID0gZ3V0dGVyVG9wLCBndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIHNpemUgPSBhcmd1bWVudHNbNF0gPyBhcmd1bWVudHNbNF0gOiAxMiwgYm9sZCA9IHByb3BbJ2NoYXJ0LnRpdGxlLmJvbGQnXSwgaXRhbGljID0gcHJvcFsnY2hhcnQudGl0bGUuaXRhbGljJ10sIGNlbnRlcnggPSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiAoY2Eud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQpIC8gMiArIGd1dHRlckxlZnQsIGtleXBvcyA9IHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbiddLCB2cG9zID0gcHJvcFsnY2hhcnQudGl0bGUudnBvcyddLCBocG9zID0gcHJvcFsnY2hhcnQudGl0bGUuaHBvcyddLCBiZ2NvbG9yID0gcHJvcFsnY2hhcnQudGl0bGUuYmFja2dyb3VuZCddLCB4ID0gcHJvcFsnY2hhcnQudGl0bGUueCddLCB5ID0gcHJvcFsnY2hhcnQudGl0bGUueSddLCBoYWxpZ24gPSAnY2VudGVyJywgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKG9iai50eXBlID09ICdiYXInICYmIHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnM2QnKSB7XG4gICAgICBrZXlwb3MgPSAnZ3V0dGVyJztcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddID8gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddIDogJ2JsYWNrJztpZiAoa2V5cG9zICYmIGtleXBvcyAhPSAnZ3V0dGVyJykge1xuICAgICAgdmFyIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSBpZiAoIWtleXBvcykge1xuICAgICAgdmFyIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsaWduID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUudnBvcyddID09PSAnbnVtYmVyJykge1xuICAgICAgdnBvcyA9IHByb3BbJ2NoYXJ0LnRpdGxlLnZwb3MnXSAqIGd1dHRlclRvcDtpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdnBvcyA9IHByb3BbJ2NoYXJ0LnRpdGxlLnZwb3MnXSAqIGd1dHRlckJvdHRvbSArIGd1dHRlclRvcCArIChjYS5oZWlnaHQgLSBndXR0ZXJUb3AgLSBndXR0ZXJCb3R0b20pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2cG9zID0gZ3V0dGVyVG9wIC0gc2l6ZSAtIDU7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT09ICd0b3AnKSB7XG4gICAgICAgIHZwb3MgPSBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b20gKyBzaXplICsgNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBocG9zID09PSAnbnVtYmVyJykge1xuICAgICAgY2VudGVyeCA9IGhwb3MgKiBjYS53aWR0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykgY2VudGVyeCA9IHg7aWYgKHR5cGVvZiB5ID09PSAnbnVtYmVyJykgdnBvcyA9IHk7aWYgKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS5oYWxpZ24nXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhhbGlnbiA9IHByb3BbJ2NoYXJ0LnRpdGxlLmhhbGlnbiddO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnZhbGlnbiddID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsaWduID0gcHJvcFsnY2hhcnQudGl0bGUudmFsaWduJ107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZENvbG9yID0gY28uZmlsbFN0eWxlO1xuICAgICAgdmFyIG5ld0NvbG9yID0gcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXTtjby5maWxsU3R5bGUgPSBuZXdDb2xvciA/IG5ld0NvbG9yIDogJ2JsYWNrJztcbiAgICB9XG4gICAgdmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLmZvbnQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50aXRsZS5mb250J107XG4gICAgfVxuICAgIHZhciByZXQgPSBSRy50ZXh0MihvYmosIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogY2VudGVyeCwgeTogdnBvcywgdGV4dDogdGV4dCwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogaGFsaWduLCBib3VuZGluZzogYmdjb2xvciAhPSBudWxsLCAnYm91bmRpbmcuZmlsbCc6IGJnY29sb3IsICdib2xkJzogYm9sZCwgaXRhbGljOiBpdGFsaWMsIHRhZzogJ3RpdGxlJywgbWFya2VyOiBmYWxzZSB9KTtjby5maWxsU3R5bGUgPSBvbGRDb2xvcjtcbiAgfTtSRy5nZXRNb3VzZVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbCA9IGUudGFyZ2V0O3ZhciBjYSA9IGVsO3ZhciBjYVN0eWxlID0gY2Euc3R5bGU7dmFyIG9mZnNldFggPSAwO3ZhciBvZmZzZXRZID0gMDt2YXIgeDt2YXIgeTt2YXIgYm9yZGVyTGVmdCA9IHBhcnNlSW50KGNhU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO3ZhciBib3JkZXJUb3AgPSBwYXJzZUludChjYVN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwO3ZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNhU3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUludChjYVN0eWxlLnBhZGRpbmdUb3ApIHx8IDA7XG4gICAgdmFyIGFkZGl0aW9uYWxYID0gYm9yZGVyTGVmdCArIHBhZGRpbmdMZWZ0O3ZhciBhZGRpdGlvbmFsWSA9IGJvcmRlclRvcCArIHBhZGRpbmdUb3A7aWYgKHR5cGVvZiBlLm9mZnNldFggPT09ICdudW1iZXInICYmIHR5cGVvZiBlLm9mZnNldFkgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoIVJHLklTSUUgJiYgIVJHLklTT1BFUkEpIHtcbiAgICAgICAgeCA9IGUub2Zmc2V0WCAtIGJvcmRlckxlZnQgLSBwYWRkaW5nTGVmdDt5ID0gZS5vZmZzZXRZIC0gYm9yZGVyVG9wIC0gcGFkZGluZ1RvcDtcbiAgICAgIH0gZWxzZSBpZiAoUkcuSVNJRSkge1xuICAgICAgICB4ID0gZS5vZmZzZXRYIC0gcGFkZGluZ0xlZnQ7eSA9IGUub2Zmc2V0WSAtIHBhZGRpbmdUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gZS5vZmZzZXRYO3kgPSBlLm9mZnNldFk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZWwub2Zmc2V0UGFyZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb2Zmc2V0WCArPSBlbC5vZmZzZXRMZWZ0O29mZnNldFkgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICB9IHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgICB4ID0gZS5wYWdlWCAtIG9mZnNldFggLSBhZGRpdGlvbmFsWDt5ID0gZS5wYWdlWSAtIG9mZnNldFkgLSBhZGRpdGlvbmFsWTt4IC09IDIgKiAocGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApO3kgLT0gMiAqIChwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtSRy5nZXRDYW52YXNYWSA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICB2YXIgeCA9IDA7dmFyIHkgPSAwO3ZhciBlbCA9IGNhbnZhcztkbyB7XG4gICAgICB4ICs9IGVsLm9mZnNldExlZnQ7eSArPSBlbC5vZmZzZXRUb3A7aWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAndGFibGUnICYmIChSRy5JU0NIUk9NRSB8fCBSRy5JU1NBRkFSSSkpIHtcbiAgICAgICAgeCArPSBwYXJzZUludChlbC5ib3JkZXIpIHx8IDA7eSArPSBwYXJzZUludChlbC5ib3JkZXIpIHx8IDA7XG4gICAgICB9XG4gICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB9IHdoaWxlIChlbCAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2JvZHknKTt2YXIgcGFkZGluZ0xlZnQgPSBjYW52YXMuc3R5bGUucGFkZGluZ0xlZnQgPyBwYXJzZUludChjYW52YXMuc3R5bGUucGFkZGluZ0xlZnQpIDogMDt2YXIgcGFkZGluZ1RvcCA9IGNhbnZhcy5zdHlsZS5wYWRkaW5nVG9wID8gcGFyc2VJbnQoY2FudmFzLnN0eWxlLnBhZGRpbmdUb3ApIDogMDt2YXIgYm9yZGVyTGVmdCA9IGNhbnZhcy5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPyBwYXJzZUludChjYW52YXMuc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSA6IDA7dmFyIGJvcmRlclRvcCA9IGNhbnZhcy5zdHlsZS5ib3JkZXJUb3BXaWR0aCA/IHBhcnNlSW50KGNhbnZhcy5zdHlsZS5ib3JkZXJUb3BXaWR0aCkgOiAwO2lmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IDApIHtcbiAgICAgIHggKz0gcGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7eSArPSBwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gW3ggKyBwYWRkaW5nTGVmdCArIGJvcmRlckxlZnQsIHkgKyBwYWRkaW5nVG9wICsgYm9yZGVyVG9wXTtcbiAgfTtSRy5pc0ZpeGVkID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgIHZhciBvYmogPSBjYW52YXM7dmFyIGkgPSAwO3doaWxlIChvYmogJiYgb2JqLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPSAnYm9keScgJiYgaSA8IDk5KSB7XG4gICAgICBpZiAob2JqLnN0eWxlLnBvc2l0aW9uID09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iai5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtSRy5yZWdpc3RlciA9IFJHLlJlZ2lzdGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLkdldCgnY2hhcnQubm9yZWdpc3RlcicpKSB7XG4gICAgICBSR3JhcGguT2JqZWN0UmVnaXN0cnkuQWRkKG9iaik7b2JqLlNldCgnY2hhcnQubm9yZWdpc3RlcicsIHRydWUpO1xuICAgIH1cbiAgfTtSRy5yZWRyYXcgPSBSRy5SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iamVjdFJlZ2lzdHJ5ID0gUkdyYXBoLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRDt2YXIgdGFncyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGFncy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHRhZ3NbaV0uX19vYmplY3RfXyAmJiB0YWdzW2ldLl9fb2JqZWN0X18uaXNSR3JhcGgpIHtcbiAgICAgICAgaWYgKCF0YWdzW2ldLm5vY2xlYXIpIHtcbiAgICAgICAgICBSR3JhcGguY2xlYXIodGFnc1tpXSwgYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdFJlZ2lzdHJ5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAob2JqZWN0UmVnaXN0cnlbaV0pIHtcbiAgICAgICAgdmFyIGlkID0gb2JqZWN0UmVnaXN0cnlbaV1bMF07b2JqZWN0UmVnaXN0cnlbaV1bMV0uRHJhdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5yZWRyYXdDYW52YXMgPSBSRy5SZWRyYXdDYW52YXMgPSBmdW5jdGlvbiAoY2EpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFJHLk9iamVjdFJlZ2lzdHJ5LmdldE9iamVjdHNCeUNhbnZhc0lEKGNhLmlkKTtpZiAoIWFyZ3VtZW50c1sxXSB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicgJiYgIWFyZ3VtZW50c1sxXSA9PSBmYWxzZSkge1xuICAgICAgdmFyIGNvbG9yID0gYXJndW1lbnRzWzJdIHx8IGNhLl9fb2JqZWN0X18uZ2V0KCdjbGVhcnRvJykgfHwgJ3RyYW5zcGFyZW50JztSRy5jbGVhcihjYSwgY29sb3IpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKG9iamVjdHNbaV0pIHtcbiAgICAgICAgaWYgKG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXS5pc1JHcmFwaCkge1xuICAgICAgICAgIG9iamVjdHNbaV0uRHJhdygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1JHLkJhY2tncm91bmQuZHJhdyA9IFJHLmJhY2tncm91bmQuZHJhdyA9IFJHLmJhY2tncm91bmQuRHJhdyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgY2EgPSBvYmouY2FudmFzLFxuICAgICAgICBjbyA9IG9iai5jb250ZXh0LFxuICAgICAgICBwcm9wID0gb2JqLnByb3BlcnRpZXMsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGd1dHRlckxlZnQgPSBvYmouZ3V0dGVyTGVmdCxcbiAgICAgICAgZ3V0dGVyUmlnaHQgPSBvYmouZ3V0dGVyUmlnaHQsXG4gICAgICAgIGd1dHRlclRvcCA9IG9iai5ndXR0ZXJUb3AsXG4gICAgICAgIGd1dHRlckJvdHRvbSA9IG9iai5ndXR0ZXJCb3R0b20sXG4gICAgICAgIHZhcmlhbnQgPSBwcm9wWydjaGFydC52YXJpYW50J107XG4gICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmICh2YXJpYW50ID09ICczZCcpIHtcbiAgICAgIGNvLnNhdmUoKTtjby50cmFuc2xhdGUocHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLCAtMSAqIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMnXSA9PT0gJ3N0cmluZycgJiYgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMnXS5sZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIGJvbGQgPSBwcm9wWydjaGFydC50aXRsZS54YXhpcy5ib2xkJ107aWYgKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS54YXhpcy5zaXplJ10gPT0gJ251bWJlcicpIHtcbiAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMuZm9udCddID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50aXRsZS54YXhpcy5mb250J107XG4gICAgICB9XG4gICAgICB2YXIgaHBvcyA9IChjYS53aWR0aCAtIGd1dHRlckxlZnQgLSBndXR0ZXJSaWdodCkgLyAyICsgZ3V0dGVyTGVmdDt2YXIgdnBvcyA9IGNhLmhlaWdodCAtIGd1dHRlckJvdHRvbSArIDI1O2lmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMucG9zJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZwb3MgPSBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b20gKiBwcm9wWydjaGFydC50aXRsZS54YXhpcy5wb3MnXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueGF4aXMueCddID09PSAnbnVtYmVyJykge1xuICAgICAgICBocG9zID0gcHJvcFsnY2hhcnQudGl0bGUueGF4aXMueCddO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS54YXhpcy55J10gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZwb3MgPSBwcm9wWydjaGFydC50aXRsZS54YXhpcy55J107XG4gICAgICB9XG4gICAgICBSRy50ZXh0Mihwcm9wWydjaGFydC50ZXh0LmFjY2Vzc2libGUnXSA/IG9iai5jb250ZXh0IDogY28sIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogaHBvcywgeTogdnBvcywgdGV4dDogcHJvcFsnY2hhcnQudGl0bGUueGF4aXMnXSwgaGFsaWduOiAnY2VudGVyJywgdmFsaWduOiAnY2VudGVyJywgYm9sZDogYm9sZCwgY29sb3I6IHByb3BbJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJ10gfHwgJ2JsYWNrJywgdGFnOiAndGl0bGUgeGF4aXMnIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzJ10gPT0gJ3N0cmluZycgJiYgcHJvcFsnY2hhcnQudGl0bGUueWF4aXMnXS5sZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIGFuZ2xlID0gMjcwO3ZhciBib2xkID0gcHJvcFsnY2hhcnQudGl0bGUueWF4aXMuYm9sZCddO3ZhciBjb2xvciA9IHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJ107aWYgKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3MnXSA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgeWF4aXNfdGl0bGVfcG9zID0gcHJvcFsnY2hhcnQudGl0bGUueWF4aXMucG9zJ10gKiBndXR0ZXJMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHlheGlzX3RpdGxlX3BvcyA9IChndXR0ZXJMZWZ0IC0gMjUpIC8gZ3V0dGVyTGVmdCAqIGd1dHRlckxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueWF4aXMuZm9udCddID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGl0bGUueWF4aXMuZm9udCddO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLmFsaWduJ10gPT0gJ3JpZ2h0JyB8fCBwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3NpdGlvbiddID09ICdyaWdodCcgfHwgb2JqLnR5cGUgPT09ICdoYmFyJyAmJiBwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAncmlnaHQnICYmIHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS55YXhpcy5hbGlnbiddID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueWF4aXMucG9zaXRpb24nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYW5nbGUgPSA5MDt5YXhpc190aXRsZV9wb3MgPSBwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3MnXSA/IGNhLndpZHRoIC0gZ3V0dGVyUmlnaHQgKyBwcm9wWydjaGFydC50aXRsZS55YXhpcy5wb3MnXSAqIGd1dHRlclJpZ2h0IDogY2Eud2lkdGggLSBndXR0ZXJSaWdodCArIHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICsgNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlheGlzX3RpdGxlX3BvcyA9IHlheGlzX3RpdGxlX3BvcztcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gKGNhLmhlaWdodCAtIGd1dHRlclRvcCAtIGd1dHRlckJvdHRvbSkgLyAyICsgZ3V0dGVyVG9wO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueWF4aXMueCddID09PSAnbnVtYmVyJykge1xuICAgICAgICB5YXhpc190aXRsZV9wb3MgPSBwcm9wWydjaGFydC50aXRsZS55YXhpcy54J107XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnknXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgeSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnlheGlzLnknXTtcbiAgICAgIH1cbiAgICAgIGNvLmZpbGxTdHlsZSA9IGNvbG9yO1JHLnRleHQyKHByb3BbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddID8gb2JqLmNvbnRleHQgOiBjbywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB5YXhpc190aXRsZV9wb3MsICd5JzogeSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICdhbmdsZSc6IGFuZ2xlLCAnYm9sZCc6IGJvbGQsICd0ZXh0JzogcHJvcFsnY2hhcnQudGl0bGUueWF4aXMnXSwgJ3RhZyc6ICd0aXRsZSB5YXhpcycsIGFjY2Vzc2libGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICB2YXIgYmdjb2xvciA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtpZiAoYmdjb2xvcikge1xuICAgICAgY28uZmlsbFN0eWxlID0gYmdjb2xvcjtjby5maWxsUmVjdChndXR0ZXJMZWZ0ICsgMC41LCBndXR0ZXJUb3AgKyAwLjUsIGNhLndpZHRoIC0gZ3V0dGVyTGVmdCAtIGd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSBndXR0ZXJUb3AgLSBndXR0ZXJCb3R0b20pO1xuICAgIH1cbiAgICB2YXIgbnVtYmFycyA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSB8fCA1O3ZhciBiYXJIZWlnaHQgPSAoY2EuaGVpZ2h0IC0gZ3V0dGVyQm90dG9tIC0gZ3V0dGVyVG9wKSAvIG51bWJhcnM7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXTtjby5zdHJva2VTdHlsZSA9IGNvLmZpbGxTdHlsZTtoZWlnaHQgPSBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b207Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1iYXJzOyBpICs9IDIpIHtcbiAgICAgIGNvLnJlY3QoZ3V0dGVyTGVmdCwgaSAqIGJhckhlaWdodCArIGd1dHRlclRvcCwgY2Eud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQsIGJhckhlaWdodCk7XG4gICAgfVxuICAgIGNvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddO2NvLnN0cm9rZVN0eWxlID0gY28uZmlsbFN0eWxlO2ZvciAodmFyIGkgPSAxOyBpIDwgbnVtYmFyczsgaSArPSAyKSB7XG4gICAgICBjby5yZWN0KGd1dHRlckxlZnQsIGkgKiBiYXJIZWlnaHQgKyBndXR0ZXJUb3AsIGNhLndpZHRoIC0gZ3V0dGVyTGVmdCAtIGd1dHRlclJpZ2h0LCBiYXJIZWlnaHQpO1xuICAgIH1cbiAgICBjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7dmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKG9iaiwgY2FjaGVDYW52YXMsIGNhY2hlQ29udGV4dCkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCddKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyddICs9IDAuMDAwMTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnXSkge1xuICAgICAgICAgIGlmIChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbiddKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdoYmFyJykge1xuICAgICAgICAgICAgICBvYmouc2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnLCBvYmouZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnXSA9PT0gJ251bWJlcicpIHt9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscyddICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iai5TZXQoJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcycsIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5TZXQoJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcycsIG9iai5kYXRhWzBdLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai50eXBlID09PSAnd2F0ZXJmYWxsJykge1xuICAgICAgICAgICAgICBvYmouc2V0KCdiYWNrZ3JvdW5kR3JpZEF1dG9maXROdW12bGluZXMnLCBvYmouZGF0YS5sZW5ndGggKyAocHJvcFsnY2hhcnQudG90YWwnXSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChvYmoudHlwZSA9PT0gJ2JhcicgfHwgb2JqLnR5cGUgPT09ICdzY2F0dGVyJykgJiYgKHByb3BbJ2NoYXJ0LmxhYmVscyddICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCB8fCBvYmoudHlwZSA9PT0gJ2JhcicpKSB7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBwcm9wWydjaGFydC5sYWJlbHMnXSAmJiBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggfHwgb2JqLmRhdGEubGVuZ3RoO29iai5zZXQoeyBiYWNrZ3JvdW5kR3JpZEF1dG9maXROdW12bGluZXM6IGxlbiB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdnYW50dCcpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouZ2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnKSA9PT0gJ251bWJlcicpIHt9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5zZXQoJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcycsIHByb3BbJ2NoYXJ0LnhtYXgnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqLnNldCgnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJywgb2JqLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdoYmFyJyAmJiBSRy5pc051bGwocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJ10pKSB7XG4gICAgICAgICAgICAgIG9iai5zZXQoJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcycsIG9iai5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2c2l6ZSA9IChjYWNoZUNhbnZhcy53aWR0aCAtIGd1dHRlckxlZnQgLSBndXR0ZXJSaWdodCkgLyBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnXTt2YXIgaHNpemUgPSAoY2FjaGVDYW52YXMuaGVpZ2h0IC0gZ3V0dGVyVG9wIC0gZ3V0dGVyQm90dG9tKSAvIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyddO29iai5TZXQoJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZScsIHZzaXplKTtvYmouU2V0KCdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnLCBoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y2FjaGVDb250ZXh0LmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCddID8gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLndpZHRoJ10gOiAxO2NhY2hlQ29udGV4dC5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO2lmIChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGFzaGVkJ10gJiYgdHlwZW9mIGNhY2hlQ29udGV4dC5zZXRMaW5lRGFzaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FjaGVDb250ZXh0LnNldExpbmVEYXNoKFszLCA1XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5kb3R0ZWQnXSAmJiB0eXBlb2YgY2FjaGVDb250ZXh0LnNldExpbmVEYXNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWNoZUNvbnRleHQuc2V0TGluZURhc2goWzEsIDNdKTtcbiAgICAgICAgfVxuICAgICAgICBjby5iZWdpblBhdGgoKTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyddKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gY2FjaGVDYW52YXMuaGVpZ2h0IC0gZ3V0dGVyQm90dG9tO1xuICAgICAgICAgIHZhciBoc2l6ZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSddO2ZvciAoeSA9IGd1dHRlclRvcDsgeSA8PSBoZWlnaHQ7IHkgKz0gaHNpemUpIHtcbiAgICAgICAgICAgIGNhY2hlQ29udGV4dC5tb3ZlVG8oZ3V0dGVyTGVmdCwgbWEucm91bmQoeSkpO2NhY2hlQ29udGV4dC5saW5lVG8oY2Eud2lkdGggLSBndXR0ZXJSaWdodCwgbWEucm91bmQoeSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyddKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gY2FjaGVDYW52YXMud2lkdGggLSBndXR0ZXJSaWdodDt2YXIgdnNpemUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQudnNpemUnXTtmb3IgKHggPSBndXR0ZXJMZWZ0OyBtYS5yb3VuZCh4KSA8PSB3aWR0aDsgeCArPSB2c2l6ZSkge1xuICAgICAgICAgICAgY2FjaGVDb250ZXh0Lm1vdmVUbyhtYS5yb3VuZCh4KSwgZ3V0dGVyVG9wKTtjYWNoZUNvbnRleHQubGluZVRvKG1hLnJvdW5kKHgpLCBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmJvcmRlciddKSB7XG4gICAgICAgICAgY2FjaGVDb250ZXh0LnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ107Y2FjaGVDb250ZXh0LnN0cm9rZVJlY3QobWEucm91bmQoZ3V0dGVyTGVmdCksIG1hLnJvdW5kKGd1dHRlclRvcCksIGNhLndpZHRoIC0gZ3V0dGVyTGVmdCAtIGd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSBndXR0ZXJUb3AgLSBndXR0ZXJCb3R0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZUNvbnRleHQuc3Ryb2tlKCk7Y2FjaGVDb250ZXh0LmJlZ2luUGF0aCgpO2NhY2hlQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9O1xuICAgIFJHLmNhY2hlZERyYXcob2JqLCBvYmoudWlkICsgJ19iYWNrZ3JvdW5kJywgZnVuYyk7aWYgKHZhcmlhbnQgPT0gJzNkJykge1xuICAgICAgY28ucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvLnNldExpbmVEYXNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvLnNldExpbmVEYXNoKFsxLCAwXSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO2lmICh0eXBlb2Ygb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRpdGxlJ10gPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7UkcuZHJhd1RpdGxlKG9iaiwgcHJvcFsnY2hhcnQudGl0bGUnXSwgb2JqLmd1dHRlclRvcCwgbnVsbCwgcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddID8gcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyLCBvYmopO1xuICAgIH1cbiAgfTtSRy5udW1iZXJGb3JtYXQgPSBSRy5udW1iZXJfZm9ybWF0ID0gZnVuY3Rpb24gKG9iaiwgbnVtKSB7XG4gICAgdmFyIGNhID0gb2JqLmNhbnZhczt2YXIgY28gPSBvYmouY29udGV4dDt2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO3ZhciBpO3ZhciBwcmVwZW5kID0gYXJndW1lbnRzWzJdID8gU3RyaW5nKGFyZ3VtZW50c1syXSkgOiAnJzt2YXIgYXBwZW5kID0gYXJndW1lbnRzWzNdID8gU3RyaW5nKGFyZ3VtZW50c1szXSkgOiAnJzt2YXIgb3V0cHV0ID0gJyc7dmFyIGRlY2ltYWwgPSAnJzt2YXIgZGVjaW1hbF9zZXBlcmF0b3IgPSB0eXBlb2YgcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSA9PSAnc3RyaW5nJyA/IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10gOiAnLic7dmFyIHRob3VzYW5kX3NlcGVyYXRvciA9IHR5cGVvZiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddID09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSA6ICcsJztSZWdFeHAuJDEgPSAnJzt2YXIgaSwgajtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnNjYWxlLmZvcm1hdHRlciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvcFsnY2hhcnQuc2NhbGUuZm9ybWF0dGVyJ10ob2JqLCBudW0pO1xuICAgIH1cbiAgICBpZiAoU3RyaW5nKG51bSkuaW5kZXhPZignZScpID4gMCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhwcmVwZW5kICsgU3RyaW5nKG51bSkgKyBhcHBlbmQpO1xuICAgIH1cbiAgICBudW0gPSBTdHJpbmcobnVtKTtpZiAobnVtLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgIHZhciB0bXAgPSBudW07bnVtID0gbnVtLnJlcGxhY2UoL1xcLiguKikvLCAnJyk7ZGVjaW1hbCA9IHRtcC5yZXBsYWNlKC8oLiopXFwuKC4qKS8sICckMicpO1xuICAgIH1cbiAgICB2YXIgc2VwZXJhdG9yID0gdGhvdXNhbmRfc2VwZXJhdG9yO3ZhciBmb3VuZFBvaW50O2ZvciAoaSA9IG51bS5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBqKyssIGktLSkge1xuICAgICAgdmFyIGNoYXJhY3RlciA9IG51bS5jaGFyQXQoaSk7aWYgKGogJSAzID09IDAgJiYgaiAhPSAwKSB7XG4gICAgICAgIG91dHB1dCArPSBzZXBlcmF0b3I7XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gY2hhcmFjdGVyO1xuICAgIH1cbiAgICB2YXIgcmV2ID0gb3V0cHV0O291dHB1dCA9ICcnO2ZvciAoaSA9IHJldi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgb3V0cHV0ICs9IHJldi5jaGFyQXQoaSk7XG4gICAgfVxuICAgIGlmIChvdXRwdXQuaW5kZXhPZignLScgKyBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddKSA9PSAwKSB7XG4gICAgICBvdXRwdXQgPSAnLScgKyBvdXRwdXQuc3Vic3RyKCgnLScgKyBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddKS5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoZGVjaW1hbC5sZW5ndGgpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dCArIGRlY2ltYWxfc2VwZXJhdG9yICsgZGVjaW1hbDtkZWNpbWFsID0gJyc7UmVnRXhwLiQxID0gJyc7XG4gICAgfVxuICAgIGlmIChvdXRwdXQuY2hhckF0KDApID09ICctJykge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLy0vLCAnJyk7cHJlcGVuZCA9ICctJyArIHByZXBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBwcmVwZW5kICsgb3V0cHV0ICsgYXBwZW5kO1xuICB9O1JHLmRyYXdCYXJzID0gUkcuRHJhd0JhcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHByb3AgPSBvYmoucHJvcGVydGllczt2YXIgY28gPSBvYmouY29udGV4dDt2YXIgY2EgPSBvYmouY2FudmFzO3ZhciBoYmFycyA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXTtpZiAoaGJhcnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Zm9yIChpID0gMCwgbGVuID0gaGJhcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBzdGFydCA9IGhiYXJzW2ldWzBdO3ZhciBsZW5ndGggPSBoYmFyc1tpXVsxXTt2YXIgY29sb3IgPSBoYmFyc1tpXVsyXTtpZiAoUkcuaXNfbnVsbChzdGFydCkpIHN0YXJ0ID0gb2JqLnNjYWxlMi5tYXg7XG4gICAgICBpZiAoc3RhcnQgPiBvYmouc2NhbGUyLm1heCkgc3RhcnQgPSBvYmouc2NhbGUyLm1heDtpZiAoUkcuaXNfbnVsbChsZW5ndGgpKSBsZW5ndGggPSBvYmouc2NhbGUyLm1heCAtIHN0YXJ0O2lmIChzdGFydCArIGxlbmd0aCA+IG9iai5zY2FsZTIubWF4KSBsZW5ndGggPSBvYmouc2NhbGUyLm1heCAtIHN0YXJ0O2lmIChzdGFydCArIGxlbmd0aCA8IC0xICogb2JqLnNjYWxlMi5tYXgpIGxlbmd0aCA9IC0xICogb2JqLnNjYWxlMi5tYXggLSBzdGFydDtpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnY2VudGVyJyAmJiBzdGFydCA9PSBvYmouc2NhbGUyLm1heCAmJiBsZW5ndGggPCBvYmouc2NhbGUyLm1heCAqIC0yKSB7XG4gICAgICAgIGxlbmd0aCA9IG9iai5zY2FsZTIubWF4ICogLTI7XG4gICAgICB9XG4gICAgICB2YXIgeCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dmFyIHkgPSBvYmouZ2V0WUNvb3JkKHN0YXJ0KTt2YXIgdyA9IGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3ZhciBoID0gb2JqLmdldFlDb29yZChzdGFydCArIGxlbmd0aCkgLSB5O2lmIChSRy5JU09QRVJBICE9IC0xICYmIHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicgJiYgaCA8IDApIHtcbiAgICAgICAgaCAqPSAtMTt5ID0geSAtIGg7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAndG9wJykge1xuICAgICAgICB5ID0gY2EuaGVpZ2h0IC0geTtoICo9IC0xO1xuICAgICAgfVxuICAgICAgY28uZmlsbFN0eWxlID0gY29sb3I7Y28uZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuICB9O1JHLmRyYXdJbkdyYXBoTGFiZWxzID0gUkcuRHJhd0luR3JhcGhMYWJlbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGNhID0gb2JqLmNhbnZhczt2YXIgY28gPSBvYmouY29udGV4dDt2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO3ZhciBsYWJlbHMgPSBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaCddO3ZhciBsYWJlbHNfcHJvY2Vzc2VkID0gW107dmFyIGZnY29sb3IgPSAnYmxhY2snO3ZhciBiZ2NvbG9yID0gJ3doaXRlJzt2YXIgZGlyZWN0aW9uID0gMTtpZiAoIWxhYmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGxhYmVsc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYWJlbHNbaV07ICsraikge1xuICAgICAgICAgIGxhYmVsc19wcm9jZXNzZWQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxzW2ldID09PSAnc3RyaW5nJyB8fCBfdHlwZW9mKGxhYmVsc1tpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxhYmVsc19wcm9jZXNzZWQucHVzaChsYWJlbHNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxzX3Byb2Nlc3NlZC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUkcubm9TaGFkb3cob2JqKTtpZiAobGFiZWxzX3Byb2Nlc3NlZCAmJiBsYWJlbHNfcHJvY2Vzc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHNfcHJvY2Vzc2VkLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChsYWJlbHNfcHJvY2Vzc2VkW2ldKSB7XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IG9iai5jb29yZHNbaV07aWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHggPSBvYmoudHlwZSA9PSAnYmFyJyA/IGNvb3Jkc1swXSArIGNvb3Jkc1syXSAvIDIgOiBjb29yZHNbMF07dmFyIHkgPSBvYmoudHlwZSA9PSAnYmFyJyA/IGNvb3Jkc1sxXSArIGNvb3Jkc1szXSAvIDIgOiBjb29yZHNbMV07dmFyIGxlbmd0aCA9IHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzRdID09PSAnbnVtYmVyJyA/IGxhYmVsc19wcm9jZXNzZWRbaV1bNF0gOiAyNTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSAnYmxhY2snO2NvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztpZiAob2JqLnR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgICAgIGlmIChvYmouR2V0KCdjaGFydC54YXhpc3BvcycpID09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICo9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwcm9wWydjaGFydC52YXJpYW50J10gPT0gJ2RvdCcpIHtcbiAgICAgICAgICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIG9iai5jb29yZHNbaV1bMV0gLSA1KTtjby5saW5lVG8obWEucm91bmQoeCksIG9iai5jb29yZHNbaV1bMV0gLSA1IC0gbGVuZ3RoKTt2YXIgdGV4dF94ID0gbWEucm91bmQoeCk7dmFyIHRleHRfeSA9IG9iai5jb29yZHNbaV1bMV0gLSA1IC0gbGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnYXJyb3cnKSB7XG4gICAgICAgICAgICAgICAgY28ubW92ZVRvKG1hLnJvdW5kKHgpLCBvYmouY29vcmRzW2ldWzFdIC0gNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCBvYmouY29vcmRzW2ldWzFdIC0gNSAtIGxlbmd0aCk7dmFyIHRleHRfeCA9IG1hLnJvdW5kKHgpO3ZhciB0ZXh0X3kgPSBvYmouY29vcmRzW2ldWzFdIC0gNSAtIGxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjby5hcmMobWEucm91bmQoeCksIHksIDIuNSwgMCwgNi4yOCwgMCk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5KTtjby5saW5lVG8obWEucm91bmQoeCksIHkgLSBsZW5ndGgpO3ZhciB0ZXh0X3ggPSBtYS5yb3VuZCh4KTt2YXIgdGV4dF95ID0geSAtIGxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoX3R5cGVvZihsYWJlbHNfcHJvY2Vzc2VkW2ldKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGFiZWxzX3Byb2Nlc3NlZFtpXVszXSA9PSAnbnVtYmVyJyAmJiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzNdID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5ICsgNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCB5ICsgNSArIGxlbmd0aCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5ICsgNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpIC0gMywgeSArIDEwKTtjby5saW5lVG8obWEucm91bmQoeCkgKyAzLCB5ICsgMTApO2NvLmNsb3NlUGF0aCgpO3ZhciB0ZXh0X3ggPSB4O3ZhciB0ZXh0X3kgPSB5ICsgNSArIGxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF94ID0geDt2YXIgdGV4dF95ID0geSAtIDUgLSBsZW5ndGg7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5IC0gNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpLCB5IC0gNSAtIGxlbmd0aCk7Y28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5IC0gNSk7Y28ubGluZVRvKG1hLnJvdW5kKHgpIC0gMywgeSAtIDEwKTtjby5saW5lVG8obWEucm91bmQoeCkgKyAzLCB5IC0gMTApO2NvLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvLmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IF90eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzFdID09PSAnc3RyaW5nJyA/IGxhYmVsc19wcm9jZXNzZWRbaV1bMV0gOiAnYmxhY2snO1JHLnRleHQyKG9iaiwgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IHRleHRfeCwgJ3knOiB0ZXh0X3kgKyAob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddID8gMiA6IDApLCAndGV4dCc6IF90eXBlb2YobGFiZWxzX3Byb2Nlc3NlZFtpXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzBdID09PSAnc3RyaW5nJyA/IGxhYmVsc19wcm9jZXNzZWRbaV1bMF0gOiBsYWJlbHNfcHJvY2Vzc2VkW2ldLCAndmFsaWduJzogJ2JvdHRvbScsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nLmZpbGwnOiBfdHlwZW9mKGxhYmVsc19wcm9jZXNzZWRbaV0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGFiZWxzX3Byb2Nlc3NlZFtpXVsyXSA9PT0gJ3N0cmluZycgPyBsYWJlbHNfcHJvY2Vzc2VkW2ldWzJdIDogJ3doaXRlJywgJ3RhZyc6ICdsYWJlbHMgaW5ncmFwaCcgfSk7Y28uZmlsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtSRy5maXhFdmVudE9iamVjdCA9IFJHLkZpeEV2ZW50T2JqZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoUkcuSVNPTEQpIHtcbiAgICAgIHZhciBlID0gZXZlbnQ7ZS5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyBkb2MuYm9keS5zY3JvbGxMZWZ0O2UucGFnZVkgPSBldmVudC5jbGllbnRZICsgZG9jLmJvZHkuc2Nyb2xsVG9wO2UudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtpZiAoIWRvYy5ib2R5LnNjcm9sbFRvcCAmJiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkge1xuICAgICAgICBlLnBhZ2VYICs9IHBhcnNlSW50KGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCk7ZS5wYWdlWSArPSBwYXJzZUludChkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9O1JHLmhpZGVDcm9zc2hhaXJDb29yZHMgPSBSRy5IaWRlQ3Jvc3NoYWlyQ29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXYgPSBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmNvb3JkaW5hdGVzLmNvb3Jkcy5kaXYnKTtpZiAoZGl2ICYmIGRpdi5zdHlsZS5vcGFjaXR5ID09IDEgJiYgZGl2Ll9fb2JqZWN0X18uR2V0KCdjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5mYWRlb3V0JykpIHtcbiAgICAgIHZhciBzdHlsZSA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuY29vcmRpbmF0ZXMuY29vcmRzLmRpdicpLnN0eWxlO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC45O1xuICAgICAgfSwgMjUpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC44O1xuICAgICAgfSwgNTApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC43O1xuICAgICAgfSwgNzUpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC42O1xuICAgICAgfSwgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuNTtcbiAgICAgIH0sIDEyNSk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0eWxlLm9wYWNpdHkgPSAwLjQ7XG4gICAgICB9LCAxNTApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC4zO1xuICAgICAgfSwgMTc1KTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuMjtcbiAgICAgIH0sIDIwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0eWxlLm9wYWNpdHkgPSAwLjE7XG4gICAgICB9LCAyMjUpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH0sIDI1MCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9LCAyNzUpO1xuICAgIH1cbiAgfTtSRy5kcmF3M0RBeGVzID0gUkcuRHJhdzNEQXhlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzLFxuICAgICAgICBjbyA9IG9iai5jb250ZXh0LFxuICAgICAgICBjYSA9IG9iai5jYW52YXM7dmFyIGd1dHRlckxlZnQgPSBvYmouZ3V0dGVyTGVmdCxcbiAgICAgICAgZ3V0dGVyUmlnaHQgPSBvYmouZ3V0dGVyUmlnaHQsXG4gICAgICAgIGd1dHRlclRvcCA9IG9iai5ndXR0ZXJUb3AsXG4gICAgICAgIGd1dHRlckJvdHRvbSA9IG9iai5ndXR0ZXJCb3R0b20sXG4gICAgICAgIHhheGlzcG9zID0gcHJvcFsnY2hhcnQueGF4aXNwb3MnXSxcbiAgICAgICAgZ3JhcGhBcmVhID0gY2EuaGVpZ2h0IC0gZ3V0dGVyVG9wIC0gZ3V0dGVyQm90dG9tLFxuICAgICAgICBoYWxmR3JhcGhBcmVhID0gZ3JhcGhBcmVhIC8gMixcbiAgICAgICAgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxcbiAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXSxcbiAgICAgICAgeGF4aXMgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC54YXhpcyddLFxuICAgICAgICB5YXhpcyA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLnlheGlzJ107XG4gICAgaWYgKHlheGlzKSB7XG4gICAgICBSRy5kcmF3M0RZQXhpcyhvYmopO1xuICAgIH1cbiAgICBpZiAoeGF4aXMpIHtcbiAgICAgIGlmICh4YXhpc3BvcyA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgUkcucGF0aDIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGMgcyAjYWFhIGYgI2RkZCcsIGd1dHRlckxlZnQsIGd1dHRlclRvcCArIGhhbGZHcmFwaEFyZWEsIGd1dHRlckxlZnQgKyBvZmZzZXR4LCBndXR0ZXJUb3AgKyBoYWxmR3JhcGhBcmVhIC0gb2Zmc2V0eSwgY2Eud2lkdGggLSBndXR0ZXJSaWdodCArIG9mZnNldHgsIGd1dHRlclRvcCArIGhhbGZHcmFwaEFyZWEgLSBvZmZzZXR5LCBjYS53aWR0aCAtIGd1dHRlclJpZ2h0LCBndXR0ZXJUb3AgKyBoYWxmR3JhcGhBcmVhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2hiYXInKSB7XG4gICAgICAgICAgdmFyIHhheGlzWUNvb3JkID0gb2JqLmNhbnZhcy5oZWlnaHQgLSBvYmoucHJvcGVydGllc1snY2hhcnQuZ3V0dGVyLmJvdHRvbSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4YXhpc1lDb29yZCA9IG9iai5nZXRZQ29vcmQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgUkcucGF0aDIoY28sICdtICUgJSBsICUgJSBsICUgJSBsICUgJSBjIHMgI2FhYSBmICNkZGQnLCBndXR0ZXJMZWZ0LCB4YXhpc1lDb29yZCwgZ3V0dGVyTGVmdCArIG9mZnNldHgsIHhheGlzWUNvb3JkIC0gb2Zmc2V0eSwgY2Eud2lkdGggLSBndXR0ZXJSaWdodCArIG9mZnNldHgsIHhheGlzWUNvb3JkIC0gb2Zmc2V0eSwgY2Eud2lkdGggLSBndXR0ZXJSaWdodCwgeGF4aXNZQ29vcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5kcmF3M0RZQXhpcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzLFxuICAgICAgICBjbyA9IG9iai5jb250ZXh0LFxuICAgICAgICBjYSA9IG9iai5jYW52YXM7dmFyIGd1dHRlckxlZnQgPSBvYmouZ3V0dGVyTGVmdCxcbiAgICAgICAgZ3V0dGVyUmlnaHQgPSBvYmouZ3V0dGVyUmlnaHQsXG4gICAgICAgIGd1dHRlclRvcCA9IG9iai5ndXR0ZXJUb3AsXG4gICAgICAgIGd1dHRlckJvdHRvbSA9IG9iai5ndXR0ZXJCb3R0b20sXG4gICAgICAgIHhheGlzcG9zID0gcHJvcFsnY2hhcnQueGF4aXNwb3MnXSxcbiAgICAgICAgZ3JhcGhBcmVhID0gY2EuaGVpZ2h0IC0gZ3V0dGVyVG9wIC0gZ3V0dGVyQm90dG9tLFxuICAgICAgICBoYWxmR3JhcGhBcmVhID0gZ3JhcGhBcmVhIC8gMixcbiAgICAgICAgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxcbiAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHknXTtcbiAgICBpZiAoKG9iai50eXBlID09PSAnaGJhcicgfHwgb2JqLnR5cGUgPT09ICdiYXInKSAmJiBwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAnY2VudGVyJykge1xuICAgICAgdmFyIHggPSAoY2Eud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQpIC8gMiArIGd1dHRlckxlZnQ7XG4gICAgfSBlbHNlIGlmICgob2JqLnR5cGUgPT09ICdoYmFyJyB8fCBvYmoudHlwZSA9PT0gJ2JhcicpICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcpIHtcbiAgICAgIHZhciB4ID0gY2Eud2lkdGggLSBndXR0ZXJSaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHggPSBndXR0ZXJMZWZ0O1xuICAgIH1cbiAgICBSRy5wYXRoMihjbywgJ2IgbSAlICUgbCAlICUgbCAlICUgbCAlICUgcyAjYWFhIGYgI2RkZCcsIHgsIGd1dHRlclRvcCwgeCArIG9mZnNldHgsIGd1dHRlclRvcCAtIG9mZnNldHksIHggKyBvZmZzZXR4LCBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b20gLSBvZmZzZXR5LCB4LCBjYS5oZWlnaHQgLSBndXR0ZXJCb3R0b20pO1xuICB9O1JHLnN0cm9rZWRDdXJ2eVJlY3QgPSBmdW5jdGlvbiAoY28sIHgsIHksIHcsIGgpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50c1s1XSA/IGFyZ3VtZW50c1s1XSA6IDM7dmFyIGNvcm5lcl90bCA9IGFyZ3VtZW50c1s2XSB8fCBhcmd1bWVudHNbNl0gPT0gbnVsbCA/IHRydWUgOiBmYWxzZTt2YXIgY29ybmVyX3RyID0gYXJndW1lbnRzWzddIHx8IGFyZ3VtZW50c1s3XSA9PSBudWxsID8gdHJ1ZSA6IGZhbHNlO3ZhciBjb3JuZXJfYnIgPSBhcmd1bWVudHNbOF0gfHwgYXJndW1lbnRzWzhdID09IG51bGwgPyB0cnVlIDogZmFsc2U7dmFyIGNvcm5lcl9ibCA9IGFyZ3VtZW50c1s5XSB8fCBhcmd1bWVudHNbOV0gPT0gbnVsbCA/IHRydWUgOiBmYWxzZTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCArIChjb3JuZXJfdGwgPyByIDogMCksIHkpO2NvLmxpbmVUbyh4ICsgdyAtIChjb3JuZXJfdHIgPyByIDogMCksIHkpO2lmIChjb3JuZXJfdHIpIHtcbiAgICAgIGNvLmFyYyh4ICsgdyAtIHIsIHkgKyByLCByLCBSRy5QSSArIFJHLkhBTEZQSSwgUkcuVFdPUEksIGZhbHNlKTtcbiAgICB9XG4gICAgY28ubGluZVRvKHggKyB3LCB5ICsgaCAtIChjb3JuZXJfYnIgPyByIDogMCkpO2lmIChjb3JuZXJfYnIpIHtcbiAgICAgIGNvLmFyYyh4ICsgdyAtIHIsIHkgLSByICsgaCwgciwgUkcuVFdPUEksIFJHLkhBTEZQSSwgZmFsc2UpO1xuICAgIH1cbiAgICBjby5saW5lVG8oeCArIChjb3JuZXJfYmwgPyByIDogMCksIHkgKyBoKTtpZiAoY29ybmVyX2JsKSB7XG4gICAgICBjby5hcmMoeCArIHIsIHkgLSByICsgaCwgciwgUkcuSEFMRlBJLCBSRy5QSSwgZmFsc2UpO1xuICAgIH1cbiAgICBjby5saW5lVG8oeCwgeSArIChjb3JuZXJfdGwgPyByIDogMCkpO2lmIChjb3JuZXJfdGwpIHtcbiAgICAgIGNvLmFyYyh4ICsgciwgeSArIHIsIHIsIFJHLlBJLCBSRy5QSSArIFJHLkhBTEZQSSwgZmFsc2UpO1xuICAgIH1cbiAgICBjby5zdHJva2UoKTtcbiAgfTtSRy5maWxsZWRDdXJ2eVJlY3QgPSBmdW5jdGlvbiAoY28sIHgsIHksIHcsIGgpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50c1s1XSA/IGFyZ3VtZW50c1s1XSA6IDM7dmFyIGNvcm5lcl90bCA9IGFyZ3VtZW50c1s2XSB8fCBhcmd1bWVudHNbNl0gPT0gbnVsbCA/IHRydWUgOiBmYWxzZTt2YXIgY29ybmVyX3RyID0gYXJndW1lbnRzWzddIHx8IGFyZ3VtZW50c1s3XSA9PSBudWxsID8gdHJ1ZSA6IGZhbHNlO3ZhciBjb3JuZXJfYnIgPSBhcmd1bWVudHNbOF0gfHwgYXJndW1lbnRzWzhdID09IG51bGwgPyB0cnVlIDogZmFsc2U7dmFyIGNvcm5lcl9ibCA9IGFyZ3VtZW50c1s5XSB8fCBhcmd1bWVudHNbOV0gPT0gbnVsbCA/IHRydWUgOiBmYWxzZTtjby5iZWdpblBhdGgoKTtpZiAoY29ybmVyX3RsKSB7XG4gICAgICBjby5tb3ZlVG8oeCArIHIsIHkgKyByKTtjby5hcmMoeCArIHIsIHkgKyByLCByLCBSRy5QSSwgUkcuUEkgKyBSRy5IQUxGUEksIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY28uZmlsbFJlY3QoeCwgeSwgciwgcik7XG4gICAgfVxuICAgIGlmIChjb3JuZXJfdHIpIHtcbiAgICAgIGNvLm1vdmVUbyh4ICsgdyAtIHIsIHkgKyByKTtjby5hcmMoeCArIHcgLSByLCB5ICsgciwgciwgUkcuUEkgKyBSRy5IQUxGUEksIDAsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY28ubW92ZVRvKHggKyB3IC0gciwgeSk7Y28uZmlsbFJlY3QoeCArIHcgLSByLCB5LCByLCByKTtcbiAgICB9XG4gICAgaWYgKGNvcm5lcl9icikge1xuICAgICAgY28ubW92ZVRvKHggKyB3IC0gciwgeSArIGggLSByKTtjby5hcmMoeCArIHcgLSByLCB5IC0gciArIGgsIHIsIDAsIFJHLkhBTEZQSSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby5tb3ZlVG8oeCArIHcgLSByLCB5ICsgaCAtIHIpO2NvLmZpbGxSZWN0KHggKyB3IC0gciwgeSArIGggLSByLCByLCByKTtcbiAgICB9XG4gICAgaWYgKGNvcm5lcl9ibCkge1xuICAgICAgY28ubW92ZVRvKHggKyByLCB5ICsgaCAtIHIpO2NvLmFyYyh4ICsgciwgeSAtIHIgKyBoLCByLCBSRy5IQUxGUEksIFJHLlBJLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvLm1vdmVUbyh4LCB5ICsgaCAtIHIpO2NvLmZpbGxSZWN0KHgsIHkgKyBoIC0gciwgciwgcik7XG4gICAgfVxuICAgIGNvLmZpbGxSZWN0KHggKyByLCB5LCB3IC0gciAtIHIsIGgpO2NvLmZpbGxSZWN0KHgsIHkgKyByLCByICsgMSwgaCAtIHIgLSByKTtjby5maWxsUmVjdCh4ICsgdyAtIHIgLSAxLCB5ICsgciwgciArIDEsIGggLSByIC0gcik7Y28uZmlsbCgpO1xuICB9O1JHLmhpZGVab29tZWRDYW52YXMgPSBSRy5IaWRlWm9vbWVkQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnRlcnZhbCA9IDEwO3ZhciBmcmFtZXMgPSAxNTtpZiAoX3R5cGVvZihSRy56b29tX2ltYWdlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBvYmogPSBSRy56b29tX2ltYWdlLm9iajt2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC56b29tLmZhZGUub3V0J10pIHtcbiAgICAgIGZvciAodmFyIGkgPSBmcmFtZXMsIGogPSAxOyBpID49IDA7IC0taSwgKytqKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKFJHLnpvb21faW1hZ2UpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHNldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5vcGFjaXR5ID0gXCIgKyBTdHJpbmcoaSAvIDEwKSwgaiAqIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF90eXBlb2YoUkcuem9vbV9iYWNrZ3JvdW5kKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2V0VGltZW91dChcIlJHcmFwaC56b29tX2JhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IFwiICsgU3RyaW5nKGkgLyBmcmFtZXMpLCBqICogaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3R5cGVvZihSRy56b29tX2ltYWdlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHNldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXCIsIHByb3BbJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnXSA/IGZyYW1lcyAqIGludGVydmFsICsgMTAgOiAwKTtcbiAgICB9XG4gICAgaWYgKF90eXBlb2YoUkcuem9vbV9iYWNrZ3JvdW5kKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHNldFRpbWVvdXQoXCJSR3JhcGguem9vbV9iYWNrZ3JvdW5kLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcIiwgcHJvcFsnY2hhcnQuem9vbS5mYWRlLm91dCddID8gZnJhbWVzICogaW50ZXJ2YWwgKyAxMCA6IDApO1xuICAgIH1cbiAgfTtSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyID0gUkcuQWRkQ3VzdG9tRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFJHLmV2ZW50c1tvYmoudWlkXSA9IFtdO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIG5hbWUgPSAnb24nICsgbmFtZTtcbiAgICB9XG4gICAgUkcuZXZlbnRzW29iai51aWRdLnB1c2goW29iaiwgbmFtZSwgZnVuY10pO3JldHVybiBSRy5ldmVudHNbb2JqLnVpZF0ubGVuZ3RoIC0gMTtcbiAgfTtSRy5maXJlQ3VzdG9tRXZlbnQgPSBSRy5GaXJlQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouaXNSR3JhcGgpIHtcbiAgICAgIGlmIChuYW1lLm1hdGNoKC8ob24pP21vdXNlb3V0LykgJiYgdHlwZW9mIG9iai5wcm9wZXJ0aWVzWydjaGFydC5ldmVudHMubW91c2VvdXQnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLm1vdXNlb3V0J10ob2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmpbbmFtZV0pIHtcbiAgICAgICAgb2JqW25hbWVdKG9iaik7XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gb2JqLnVpZDtpZiAodHlwZW9mIHVpZCA9PT0gJ3N0cmluZycgJiYgX3R5cGVvZihSRy5ldmVudHMpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKFJHLmV2ZW50c1t1aWRdKSA9PT0gJ29iamVjdCcgJiYgUkcuZXZlbnRzW3VpZF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IFJHLmV2ZW50c1t1aWRdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKFJHLmV2ZW50c1t1aWRdW2pdICYmIFJHLmV2ZW50c1t1aWRdW2pdWzFdID09PSBuYW1lKSB7XG4gICAgICAgICAgICBSRy5ldmVudHNbdWlkXVtqXVsyXShvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtSR3JhcGgucmVtb3ZlQWxsQ3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSBSR3JhcGguUmVtb3ZlQWxsQ3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkID0gYXJndW1lbnRzWzBdO2lmIChpZCAmJiBSRy5ldmVudHNbaWRdKSB7XG4gICAgICBSRy5ldmVudHNbaWRdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmV2ZW50cyA9IFtdO1xuICAgIH1cbiAgfTtSRy5yZW1vdmVDdXN0b21FdmVudExpc3RlbmVyID0gUkcuUmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmosIGkpIHtcbiAgICBpZiAoX3R5cGVvZihSRy5ldmVudHMpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKFJHLmV2ZW50c1tvYmouaWRdKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihSRy5ldmVudHNbb2JqLmlkXVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5ldmVudHNbb2JqLmlkXVtpXSA9IG51bGw7XG4gICAgfVxuICB9O1JHLmRyYXdCYWNrZ3JvdW5kSW1hZ2UgPSBSRy5EcmF3QmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7dmFyIGNhID0gb2JqLmNhbnZhczt2YXIgY28gPSBvYmouY29udGV4dDtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY2EuX19yZ3JhcGhfYmFja2dyb3VuZF9pbWFnZV9fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7aW1nLl9fb2JqZWN0X18gPSBvYmo7aW1nLl9fY2FudmFzX18gPSBjYTtpbWcuX19jb250ZXh0X18gPSBjbztpbWcuc3JjID0gb2JqLkdldCgnY2hhcnQuYmFja2dyb3VuZC5pbWFnZScpO2NhLl9fcmdyYXBoX2JhY2tncm91bmRfaW1hZ2VfXyA9IGltZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZyA9IGNhLl9fcmdyYXBoX2JhY2tncm91bmRfaW1hZ2VfXztcbiAgICAgIH1cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iai5fX3JncmFwaF9iYWNrZ3JvdW5kX2ltYWdlX2xvYWRlZF9fID0gdHJ1ZTtSRy5jbGVhcihjYSk7UkcucmVkcmF3Q2FudmFzKGNhKTtcbiAgICAgIH07XG4gICAgICB2YXIgZ3V0dGVyTGVmdCA9IG9iai5ndXR0ZXJMZWZ0O3ZhciBndXR0ZXJSaWdodCA9IG9iai5ndXR0ZXJSaWdodDt2YXIgZ3V0dGVyVG9wID0gb2JqLmd1dHRlclRvcDt2YXIgZ3V0dGVyQm90dG9tID0gb2JqLmd1dHRlckJvdHRvbTt2YXIgc3RyZXRjaCA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCddO3ZhciBhbGlnbiA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxpZ24nXTtpZiAodHlwZW9mIGFsaWduID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoYWxpZ24uaW5kZXhPZigncmlnaHQnKSAhPSAtMSkge1xuICAgICAgICAgIHZhciB4ID0gY2Eud2lkdGggLSAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53J10gfHwgaW1nLndpZHRoKSAtIGd1dHRlclJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4ID0gZ3V0dGVyTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ24uaW5kZXhPZignYm90dG9tJykgIT0gLTEpIHtcbiAgICAgICAgICB2YXIgeSA9IGNhLmhlaWdodCAtIChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnXSB8fCBpbWcuaGVpZ2h0KSAtIGd1dHRlckJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeSA9IGd1dHRlclRvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBndXR0ZXJMZWZ0IHx8IDI1O3ZhciB5ID0gZ3V0dGVyVG9wIHx8IDI1O1xuICAgICAgfVxuICAgICAgdmFyIHggPSB0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS54J10gPT09ICdudW1iZXInID8gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS54J10gOiB4O3ZhciB5ID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSddID09PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSddIDogeTt2YXIgdyA9IHN0cmV0Y2ggPyBjYS53aWR0aCAtIGd1dHRlckxlZnQgLSBndXR0ZXJSaWdodCA6IGltZy53aWR0aDt2YXIgaCA9IHN0cmV0Y2ggPyBjYS5oZWlnaHQgLSBndXR0ZXJUb3AgLSBndXR0ZXJCb3R0b20gOiBpbWcuaGVpZ2h0O2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53J10gPT09ICdudW1iZXInKSB3ID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnXSA9PT0gJ251bWJlcicpIGggPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmgnXTt2YXIgb2xkQWxwaGEgPSBjby5nbG9iYWxBbHBoYTtjby5nbG9iYWxBbHBoYSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxwaGEnXTtjby5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3LCBoKTtjby5nbG9iYWxBbHBoYSA9IG9sZEFscGhhO1xuICAgIH1cbiAgfTtSRy5oYXNUb29sdGlwcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO2lmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wWydjaGFydC50b29sdGlwcyddLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICghUkcuaXNfbnVsbChvYmouR2V0KCdjaGFydC50b29sdGlwcycpW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtSRy5jcmVhdGVVSUQgPSBSRy5DcmVhdGVVSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciByID0gbWEucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7cmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICB9O1JHLk9SLmFkZCA9IFJHLk9SLkFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdWlkID0gb2JqLnVpZDt2YXIgaWQgPSBvYmouY2FudmFzLmlkO1JHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQucHVzaChbdWlkLCBvYmpdKTtSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSUQucHVzaChbaWQsIG9ial0pO1xuICB9O1JHLk9SLnJlbW92ZSA9IFJHLk9SLlJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaWQgPSBvYmouaWQ7dmFyIHVpZCA9IG9iai51aWQ7Zm9yICh2YXIgaSA9IDA7IGkgPCBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlELmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXSAmJiBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEW2ldWzFdLnVpZCA9PSB1aWQpIHtcbiAgICAgICAgUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieUNhbnZhc0lELmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieUNhbnZhc0lEW2ldICYmIFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRFtpXVsxXSAmJiBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSURbaV1bMV0udWlkID09IHVpZCkge1xuICAgICAgICBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSURbaV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5PUi5jbGVhciA9IFJHLk9SLkNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0pIHtcbiAgICAgIHZhciBpZCA9IF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcgPyBhcmd1bWVudHNbMF0uaWQgOiBhcmd1bWVudHNbMF07dmFyIG9iamVjdHMgPSBSRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlDYW52YXNJRChpZCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgUkcuT2JqZWN0UmVnaXN0cnkucmVtb3ZlKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzID0ge307UkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRCA9IFtdO1JHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlDYW52YXNJRCA9IFtdO1xuICAgIH1cbiAgfTtSRy5PUi5saXN0ID0gUkcuT1IuTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlzdCA9IFtdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlELmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXSkge1xuICAgICAgICBsaXN0LnB1c2goUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRFtpXVsxXS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50c1swXSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwKGxpc3QpO1xuICAgIH1cbiAgfTtSRy5PUi5jbGVhckJ5VHlwZSA9IFJHLk9SLkNsZWFyQnlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQ7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChvYmplY3RzW2ldKSB7XG4gICAgICAgIHZhciB1aWQgPSBvYmplY3RzW2ldWzBdO3ZhciBvYmogPSBvYmplY3RzW2ldWzFdO2lmIChvYmogJiYgb2JqLnR5cGUgPT0gdHlwZSkge1xuICAgICAgICAgIFJHLk9iamVjdFJlZ2lzdHJ5LnJlbW92ZShvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1JHLk9SLml0ZXJhdGUgPSBSRy5PUi5JdGVyYXRlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFJHcmFwaC5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHR5cGVzID0gYXJndW1lbnRzWzFdLnNwbGl0KC8sLyk7Zm9yICh2YXIgaiA9IDAsIGxlbjIgPSB0eXBlcy5sZW5ndGg7IGogPCBsZW4yOyArK2opIHtcbiAgICAgICAgICBpZiAodHlwZXNbal0gPT0gb2JqZWN0c1tpXVsxXS50eXBlKSB7XG4gICAgICAgICAgICBmdW5jKG9iamVjdHNbaV1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuYyhvYmplY3RzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07UkcuT1IuZ2V0T2JqZWN0c0J5Q2FudmFzSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgc3RvcmUgPSBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5Q2FudmFzSUQ7dmFyIHJldCA9IFtdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBzdG9yZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHN0b3JlW2ldICYmIHN0b3JlW2ldWzBdID09IGlkKSB7XG4gICAgICAgIHJldC5wdXNoKHN0b3JlW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtSRy5PUi5maXJzdGJ5eHkgPSBSRy5PUi5nZXRGaXJzdE9iamVjdEJ5WFkgPSBSRy5PUi5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgY2FudmFzID0gZS50YXJnZXQ7dmFyIHJldCA9IG51bGw7dmFyIG9iamVjdHMgPSBSRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlDYW52YXNJRChjYW52YXMuaWQpO2ZvciAodmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXS5nZXRPYmplY3RCeVhZKGUpO2lmIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG4gIH07UkcuT1IuZ2V0T2JqZWN0c0J5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBjYW52YXMgPSBlLnRhcmdldDt2YXIgcmV0ID0gW107dmFyIG9iamVjdHMgPSBSRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlDYW52YXNJRChjYW52YXMuaWQpO2ZvciAodmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXS5nZXRPYmplY3RCeVhZKGUpO2lmIChvYmopIHtcbiAgICAgICAgcmV0LnB1c2gob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtSRy5PUi5nZXQgPSBSRy5PUi5nZXRPYmplY3RCeVVJRCA9IGZ1bmN0aW9uICh1aWQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFJHLk9iamVjdFJlZ2lzdHJ5Lm9iamVjdHMuYnlVSUQ7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChvYmplY3RzW2ldICYmIG9iamVjdHNbaV1bMV0udWlkID09IHVpZCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0c1tpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH07UkcuT1IuYnJpbmdUb0Zyb250ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZWRyYXcgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBhcmd1bWVudHNbMV07UkcuT2JqZWN0UmVnaXN0cnkucmVtb3ZlKG9iaik7UkcuT2JqZWN0UmVnaXN0cnkuYWRkKG9iaik7aWYgKHJlZHJhdykge1xuICAgICAgUkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1xuICAgIH1cbiAgfTtSRy5PUi50eXBlID0gUkcuT1IuZ2V0T2JqZWN0c0J5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIG9iamVjdHMgPSBSRy5PYmplY3RSZWdpc3RyeS5vYmplY3RzLmJ5VUlEO3ZhciByZXQgPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXVsxXSAmJiBvYmplY3RzW2ldWzFdLnR5cGUgJiYgb2JqZWN0c1tpXVsxXS50eXBlICYmIG9iamVjdHNbaV1bMV0udHlwZSA9PSB0eXBlKSB7XG4gICAgICAgIHJldC5wdXNoKG9iamVjdHNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1JHLk9SLmZpcnN0ID0gUkcuT1IuZ2V0Rmlyc3RPYmplY3RCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBvYmplY3RzID0gUkcuT2JqZWN0UmVnaXN0cnkub2JqZWN0cy5ieVVJRDtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXVsxXSAmJiBvYmplY3RzW2ldWzFdLnR5cGUgPT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0c1tpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07UkcuZ2V0QW5nbGVCeVhZID0gZnVuY3Rpb24gKGN4LCBjeSwgeCwgeSkge1xuICAgIHZhciBhbmdsZSA9IG1hLmF0YW4oKHkgLSBjeSkgLyAoeCAtIGN4KSk7YW5nbGUgPSBtYS5hYnMoYW5nbGUpO1xuICAgIGlmICh4ID49IGN4ICYmIHkgPj0gY3kpIHtcbiAgICAgIGFuZ2xlICs9IFJHLlRXT1BJO1xuICAgIH0gZWxzZSBpZiAoeCA+PSBjeCAmJiB5IDwgY3kpIHtcbiAgICAgIGFuZ2xlID0gUkcuSEFMRlBJIC0gYW5nbGUgKyAoUkcuUEkgKyBSRy5IQUxGUEkpO1xuICAgIH0gZWxzZSBpZiAoeCA8IGN4ICYmIHkgPCBjeSkge1xuICAgICAgYW5nbGUgKz0gUkcuUEk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gUkcuUEkgLSBhbmdsZTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlID4gUkcuVFdPUEkpIHtcbiAgICAgIGFuZ2xlIC09IFJHLlRXT1BJO1xuICAgIH1cbiAgICByZXR1cm4gYW5nbGU7XG4gIH07UkcuZ2V0SHlwTGVuZ3RoID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHJldCA9IG1hLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtyZXR1cm4gcmV0O1xuICB9O1JHLmdldFJhZGl1c0VuZFBvaW50ID0gZnVuY3Rpb24gKGN4LCBjeSwgYW5nbGUsIHJhZGl1cykge1xuICAgIHZhciB4ID0gY3ggKyBtYS5jb3MoYW5nbGUpICogcmFkaXVzO3ZhciB5ID0gY3kgKyBtYS5zaW4oYW5nbGUpICogcmFkaXVzO3JldHVybiBbeCwgeV07XG4gIH07UkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzID0gUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7aWYgKFJHLklTT0xEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSRy5pbnN0YWxsQ2FudmFzQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgUkcuaW5zdGFsbFdpbmRvd01vdXNlZG93bkxpc3RlbmVyKG9iaik7UkcuaW5zdGFsbFdpbmRvd01vdXNldXBMaXN0ZW5lcihvYmopO1JHLmluc3RhbGxDYW52YXNNb3VzZW1vdmVMaXN0ZW5lcihvYmopO1JHLmluc3RhbGxDYW52YXNNb3VzZXVwTGlzdGVuZXIob2JqKTtSRy5pbnN0YWxsQ2FudmFzTW91c2Vkb3duTGlzdGVuZXIob2JqKTtSRy5pbnN0YWxsQ2FudmFzQ2xpY2tMaXN0ZW5lcihvYmopO1xuICAgIH0gZWxzZSBpZiAoUkcuaGFzVG9vbHRpcHMob2JqKSB8fCBwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gfHwgcHJvcFsnY2hhcnQuYW5ub3RhdGFibGUnXSB8fCBwcm9wWydjaGFydC5jb250ZXh0bWVudSddIHx8IHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddIHx8IHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSddIHx8IHByb3BbJ2NoYXJ0LmV2ZW50cy5jbGljayddIHx8IHByb3BbJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnXSB8fCB0eXBlb2Ygb2JqLm9uY2xpY2sgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5vbm1vdXNlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWxlcnQoJ1tSR1JBUEhdIFlvdSBhcHBlYXIgdG8gaGF2ZSB1c2VkIGR5bmFtaWMgZmVhdHVyZXMgYnV0IG5vdCBpbmNsdWRlZCB0aGUgZmlsZTogUkdyYXBoLmNvbW1vbi5keW5hbWljLmpzJyk7XG4gICAgfVxuICB9O1JHLnByID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBpbmRlbnQgPSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAnICAgICc7dmFyIHN0ciA9ICcnO3ZhciBjb3VudGVyID0gdHlwZW9mIGFyZ3VtZW50c1szXSA9PSAnbnVtYmVyJyA/IGFyZ3VtZW50c1szXSA6IDA7aWYgKGNvdW50ZXIgPj0gNSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpIHtjYXNlICdzdHJpbmcnOlxuICAgICAgICBzdHIgKz0gb2JqICsgJyAoJyArICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSArICcsICcgKyBvYmoubGVuZ3RoICsgJyknO2JyZWFrO2Nhc2UgJ251bWJlcic6XG4gICAgICAgIHN0ciArPSBvYmogKyAnICgnICsgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpICsgJyknO2JyZWFrO2Nhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBzdHIgKz0gb2JqICsgJyAoJyArICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSArICcpJzticmVhaztjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHN0ciArPSAnZnVuY3Rpb24gKCkge30nO2JyZWFrO2Nhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHN0ciArPSAndW5kZWZpbmVkJzticmVhaztjYXNlICdudWxsJzpcbiAgICAgICAgc3RyICs9ICdudWxsJzticmVhaztjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoUkdyYXBoLmlzX251bGwob2JqKSkge1xuICAgICAgICAgIHN0ciArPSBpbmRlbnQgKyAnbnVsbFxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9IGluZGVudCArICdPYmplY3QgeycgKyAnXFxuJztcbiAgICAgICAgICBmb3IgKGogaW4gb2JqKSB7XG4gICAgICAgICAgICBzdHIgKz0gaW5kZW50ICsgJyAgICAnICsgaiArICcgPT4gJyArIFJHcmFwaC5wcihvYmpbal0sIHRydWUsIGluZGVudCArICcgICAgJywgY291bnRlciArIDEpICsgJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ZGVmYXVsdDpcbiAgICAgICAgc3RyICs9ICdVbmtub3duIHR5cGU6ICcgKyAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgKyAnJzticmVhazt9XG4gICAgaWYgKCFhcmd1bWVudHNbMV0pIHtcbiAgICAgIGFsZXJ0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07UkcuZGFzaGVkTGluZSA9IFJHLkRhc2hlZExpbmUgPSBmdW5jdGlvbiAoY28sIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHNpemUgPSA1O2lmICh0eXBlb2YgYXJndW1lbnRzWzVdID09PSAnbnVtYmVyJykge1xuICAgICAgc2l6ZSA9IGFyZ3VtZW50c1s1XTtcbiAgICB9XG4gICAgdmFyIGR4ID0geDIgLSB4MTt2YXIgZHkgPSB5MiAtIHkxO3ZhciBudW0gPSBtYS5mbG9vcihtYS5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIHNpemUpO3ZhciB4TGVuID0gZHggLyBudW07dmFyIHlMZW4gPSBkeSAvIG51bTt2YXIgY291bnQgPSAwO2RvIHtcbiAgICAgIGNvdW50ICUgMiA9PSAwICYmIGNvdW50ID4gMCA/IGNvLmxpbmVUbyh4MSwgeTEpIDogY28ubW92ZVRvKHgxLCB5MSk7eDEgKz0geExlbjt5MSArPSB5TGVuO1xuICAgIH0gd2hpbGUgKGNvdW50KysgPD0gbnVtKTtcbiAgfTtSRy5BSkFYID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICB2YXIgaHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICB2YXIgaHR0cFJlcXVlc3QgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgIH1cbiAgICBodHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgIHRoaXMuX191c2VyX2NhbGxiYWNrX18gPSBjYWxsYmFjazt0aGlzLl9fdXNlcl9jYWxsYmFja19fKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGh0dHBSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7aHR0cFJlcXVlc3Quc2VuZCgpO1xuICB9O1JHLkFKQVguUE9TVCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNydW1icyA9IFtdO2lmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgIHZhciBodHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgIHZhciBodHRwUmVxdWVzdCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgfVxuICAgIGh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgdGhpcy5fX3VzZXJfY2FsbGJhY2tfXyA9IGNhbGxiYWNrO3RoaXMuX191c2VyX2NhbGxiYWNrX18odGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaHR0cFJlcXVlc3Qub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7aHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtmb3IgKGkgaW4gZGF0YSkge1xuICAgICAgaWYgKHR5cGVvZiBpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNydW1icy5wdXNoKGkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBodHRwUmVxdWVzdC5zZW5kKGNydW1icy5qb2luKCcmJykpO1xuICB9O1JHLkFKQVguZ2V0TnVtYmVyID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgICBSRy5BSkFYKHVybCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQodGhpcy5yZXNwb25zZVRleHQpO2NhbGxiYWNrKG51bSk7XG4gICAgfSk7XG4gIH07UkcuQUpBWC5nZXRTdHJpbmcgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIFJHLkFKQVgodXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyID0gU3RyaW5nKHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhzdHIpO1xuICAgIH0pO1xuICB9O1JHLkFKQVguZ2V0SlNPTiA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgUkcuQUpBWCh1cmwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBqc29uID0gZXZhbCgnKCcgKyB0aGlzLnJlc3BvbnNlVGV4dCArICcpJyk7Y2FsbGJhY2soanNvbik7XG4gICAgfSk7XG4gIH07UkcuQUpBWC5nZXRDU1YgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBzZXBlcmF0b3IgPSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAnLCc7UkcuQUpBWCh1cmwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHNlcGVyYXRvcik7dmFyIGFyciA9IHRoaXMucmVzcG9uc2VUZXh0LnNwbGl0KHJlZ2V4cCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBwYXJzZUZsb2F0KGFycltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhhcnIpO1xuICAgIH0pO1xuICB9O1JHLnJvdGF0ZUNhbnZhcyA9IFJHLlJvdGF0ZUNhbnZhcyA9IGZ1bmN0aW9uIChjYSwgeCwgeSwgYW5nbGUpIHtcbiAgICB2YXIgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpO2NvLnRyYW5zbGF0ZSh4LCB5KTtjby5yb3RhdGUoYW5nbGUpO2NvLnRyYW5zbGF0ZSgwIC0geCwgMCAtIHkpO1xuICB9O1JHLm1lYXN1cmVUZXh0ID0gUkcuTWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgYm9sZCwgZm9udCwgc2l6ZSkge1xuICAgIGlmICh0eXBlb2YgUkcubWVhc3VyZXRleHRfY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBSRy5tZWFzdXJldGV4dF9jYWNoZSA9IFtdO1xuICAgIH1cbiAgICB2YXIgc3RyID0gdGV4dCArICc6JyArIGJvbGQgKyAnOicgKyBmb250ICsgJzonICsgc2l6ZTtpZiAoX3R5cGVvZihSRy5tZWFzdXJldGV4dF9jYWNoZSkgPT0gJ29iamVjdCcgJiYgUkcubWVhc3VyZXRleHRfY2FjaGVbc3RyXSkge1xuICAgICAgcmV0dXJuIFJHLm1lYXN1cmV0ZXh0X2NhY2hlW3N0cl07XG4gICAgfVxuICAgIGlmICghUkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtZGl2J10pIHtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS50b3AgPSAnLTEwMHB4JztkaXYuc3R5bGUubGVmdCA9ICctMTAwcHgnO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtSRy5tZWFzdXJldGV4dF9jYWNoZVsndGV4dC1kaXYnXSA9IGRpdjtcbiAgICB9IGVsc2UgaWYgKFJHLm1lYXN1cmV0ZXh0X2NhY2hlWyd0ZXh0LWRpdiddKSB7XG4gICAgICB2YXIgZGl2ID0gUkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtZGl2J107XG4gICAgfVxuICAgIGRpdi5pbm5lckhUTUwgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnPGJyIC8+Jyk7ZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBmb250O2Rpdi5zdHlsZS5mb250V2VpZ2h0ID0gYm9sZCA/ICdib2xkJyA6ICdub3JtYWwnO2Rpdi5zdHlsZS5mb250U2l6ZSA9IChzaXplIHx8IDEyKSArICdwdCc7dmFyIHNpemUgPSBbZGl2Lm9mZnNldFdpZHRoLCBkaXYub2Zmc2V0SGVpZ2h0XTtSRy5tZWFzdXJldGV4dF9jYWNoZVtzdHJdID0gc2l6ZTtyZXR1cm4gc2l6ZTtcbiAgfTtSRy50ZXh0MiA9IFJHLlRleHQyID0gZnVuY3Rpb24gKG9iaiwgb3B0KSB7XG4gICAgZnVuY3Rpb24gZG9tdGV4dCgpIHtcbiAgICAgIGlmIChTdHJpbmcob3B0LnNpemUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaXRhbGljJykgIT09IC0xKSB7XG4gICAgICAgIG9wdC5zaXplID0gb3B0LnNpemUucmVwbGFjZSgvICppdGFsaWMgKy8sICcnKTtvcHQuaXRhbGljID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZUtleSA9IG1hLmFicyhwYXJzZUludChvcHQueCkpICsgJ18nICsgbWEuYWJzKHBhcnNlSW50KG9wdC55KSkgKyAnXycgKyBTdHJpbmcob3B0LnRleHQpLnJlcGxhY2UoL1teYS16QS1aMC05XSsvZywgJ18nKSArICdfJyArIG9iai5jYW52YXMuaWQ7aWYgKCFjYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7d3JhcHBlci5pZCA9IGNhLmlkICsgJ19yZ3JhcGhfZG9tdGV4dF93cmFwcGVyJzt3cmFwcGVyLmNsYXNzTmFtZSA9ICdyZ3JhcGhfZG9tdGV4dF93cmFwcGVyJzt3cmFwcGVyLnN0eWxlLm92ZXJmbG93ID0gb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyddICE9IGZhbHNlICYmIG9iai5wcm9wZXJ0aWVzWydjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnXSAhPSAnaGlkZGVuJyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO3dyYXBwZXIuc3R5bGUud2lkdGggPSBjYS5vZmZzZXRXaWR0aCArICdweCc7d3JhcHBlci5zdHlsZS5oZWlnaHQgPSBjYS5vZmZzZXRIZWlnaHQgKyAncHgnO3dyYXBwZXIuc3R5bGUuY3NzRmxvYXQgPSBjYS5zdHlsZS5jc3NGbG9hdDt3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSBjYS5zdHlsZS5kaXNwbGF5IHx8ICdpbmxpbmUtYmxvY2snO3dyYXBwZXIuc3R5bGUucG9zaXRpb24gPSBjYS5zdHlsZS5wb3NpdGlvbiB8fCAncmVsYXRpdmUnO3dyYXBwZXIuc3R5bGUubGVmdCA9IGNhLnN0eWxlLmxlZnQ7d3JhcHBlci5zdHlsZS50b3AgPSBjYS5zdHlsZS50b3A7d3JhcHBlci5zdHlsZS53aWR0aCA9IGNhLndpZHRoICsgJ3B4Jzt3cmFwcGVyLnN0eWxlLmhlaWdodCA9IGNhLmhlaWdodCArICdweCc7Y2Euc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2NhLnN0eWxlLmxlZnQgPSAwO2NhLnN0eWxlLnRvcCA9IDA7Y2Euc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO2NhLnN0eWxlLmNzc0Zsb2F0ID0gJ25vbmUnO2lmICgob2JqLnR5cGUgPT09ICdiYXInIHx8IG9iai50eXBlID09PSAnYmlwb2xhcicgfHwgb2JqLnR5cGUgPT09ICdoYmFyJykgJiYgb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgICAgIHdyYXBwZXIuc3R5bGUudHJhbnNmb3JtID0gJ3NrZXdZKDUuN2RlZyknO1xuICAgICAgICB9XG4gICAgICAgIGNhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIGNhKTtjYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhKTt3cmFwcGVyLmFwcGVuZENoaWxkKGNhKTtjYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXIgPSBjYS5yZ3JhcGhfZG9tdGV4dF93cmFwcGVyO1xuICAgICAgfVxuICAgICAgdmFyIGRlZmF1bHRzID0geyBzaXplOiAxMiwgZm9udDogJ0FyaWFsJywgaXRhbGljOiAnbm9ybWFsJywgYm9sZDogJ25vcm1hbCcsIHZhbGlnbjogJ2JvdHRvbScsIGhhbGlnbjogJ2xlZnQnLCBtYXJrZXI6IHRydWUsIGNvbG9yOiBjby5maWxsU3R5bGUsIGJvdW5kaW5nOiB7IGVuYWJsZWQ6IGZhbHNlLCBmaWxsOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgc3Ryb2tlOiAnIzY2NicgfSB9O1xuICAgICAgb3B0LnRleHQgPSBTdHJpbmcob3B0LnRleHQpLnJlcGxhY2UoL1xccj9cXG4vZywgJ1tbUkVUVVJOXV0nKTtpZiAodHlwZW9mIFJHLnRleHQyLmRvbU5vZGVDYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUkcudGV4dDIuZG9tTm9kZUNhY2hlID0gbmV3IEFycmF5KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIFJHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbb2JqLmlkXSA9IG5ldyBBcnJheSgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFJHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZSA9IG5ldyBBcnJheSgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbb2JqLmlkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF0gPSBuZXcgQXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIGlmICghUkcudGV4dDIuZG9tTm9kZUNhY2hlW29iai5pZF0gfHwgIVJHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdW2NhY2hlS2V5XSkge1xuICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtzcGFuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztzcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztzcGFuLnN0eWxlLmxlZnQgPSBvcHQueCAqIChwYXJzZUludChjYS5vZmZzZXRXaWR0aCkgLyBwYXJzZUludChjYS53aWR0aCkpICsgJ3B4JztzcGFuLnN0eWxlLnRvcCA9IG9wdC55ICogKHBhcnNlSW50KGNhLm9mZnNldEhlaWdodCkgLyBwYXJzZUludChjYS5oZWlnaHQpKSArICdweCc7c3Bhbi5zdHlsZS5jb2xvciA9IG9wdC5jb2xvciB8fCBkZWZhdWx0cy5jb2xvcjtzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBvcHQuZm9udCB8fCBkZWZhdWx0cy5mb250O3NwYW4uc3R5bGUuZm9udFdlaWdodCA9IG9wdC5ib2xkID8gJ2JvbGQnIDogZGVmYXVsdHMuYm9sZDtzcGFuLnN0eWxlLmZvbnRTdHlsZSA9IG9wdC5pdGFsaWMgPyAnaXRhbGljJyA6IGRlZmF1bHRzLml0YWxpYztzcGFuLnN0eWxlLmZvbnRTaXplID0gKG9wdC5zaXplIHx8IGRlZmF1bHRzLnNpemUpICsgJ3B0JztzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztzcGFuLnRhZyA9IG9wdC50YWc7aWYgKHR5cGVvZiBvcHQuYW5nbGUgPT09ICdudW1iZXInICYmIG9wdC5hbmdsZSAhPT0gMCkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBSRy5tZWFzdXJlVGV4dChvcHQudGV4dCwgb3B0LmJvbGQsIG9wdC5mb250LCBvcHQuc2l6ZSk7c3Bhbi5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMTAwJSA1MCUnO3NwYW4uc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgb3B0LmFuZ2xlICsgJ2RlZyknO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uc3R5bGUudGV4dFNoYWRvdyA9ICd7MX1weCB7Mn1weCB7M31weCB7NH0nLmZvcm1hdChjby5zaGFkb3dPZmZzZXRYLCBjby5zaGFkb3dPZmZzZXRZLCBjby5zaGFkb3dCbHVyLCBjby5zaGFkb3dDb2xvcik7aWYgKG9wdC5ib3VuZGluZykge1xuICAgICAgICAgIHNwYW4uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAnICsgKG9wdFsnYm91bmRpbmcuc3Ryb2tlJ10gfHwgZGVmYXVsdHMuYm91bmRpbmcuc3Ryb2tlKTtzcGFuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdFsnYm91bmRpbmcuZmlsbCddIHx8IGRlZmF1bHRzLmJvdW5kaW5nLmZpbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJ10gPT09ICd1bmRlZmluZWQnIHx8IG9iai5wcm9wZXJ0aWVzWydjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyddKSAmJiBvYmoucHJvcGVydGllc1snY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnXSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgc3Bhbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBzcGFuLnN0eWxlLnBhZGRpbmcgPSBvcHQuYm91bmRpbmcgPyAnMnB4JyA6IG51bGw7c3Bhbi5fX3RleHRfXyA9IG9wdC50ZXh0O1xuICAgICAgICBzcGFuLmlubmVySFRNTCA9IG9wdC50ZXh0LnJlcGxhY2UoJyYnLCAnJmFtcDsnKS5yZXBsYWNlKCc8JywgJyZsdDsnKS5yZXBsYWNlKCc+JywgJyZndDsnKTtzcGFuLmlubmVySFRNTCA9IHNwYW4uaW5uZXJIVE1MLnJlcGxhY2UoL1xcW1xcW1JFVFVSTlxcXVxcXS9nLCAnPGJyIC8+Jyk7d3JhcHBlci5hcHBlbmRDaGlsZChzcGFuKTtvcHQuaGFsaWduID0gb3B0LmhhbGlnbiB8fCAnbGVmdCc7b3B0LnZhbGlnbiA9IG9wdC52YWxpZ24gfHwgJ2JvdHRvbSc7aWYgKG9wdC5oYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBzcGFuLnN0eWxlLmxlZnQgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUubGVmdCkgLSBzcGFuLm9mZnNldFdpZHRoICsgJ3B4JztzcGFuLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LmhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBzcGFuLnN0eWxlLmxlZnQgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUubGVmdCkgLSBzcGFuLm9mZnNldFdpZHRoIC8gMiArICdweCc7c3Bhbi5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnZhbGlnbiA9PT0gJ3RvcCcpIHt9IGVsc2UgaWYgKG9wdC52YWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgc3Bhbi5zdHlsZS50b3AgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUudG9wKSAtIHNwYW4ub2Zmc2V0SGVpZ2h0IC8gMiArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5zdHlsZS50b3AgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUudG9wKSAtIHNwYW4ub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSBwYXJzZUZsb2F0KHNwYW4ub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gcGFyc2VGbG9hdChzcGFuLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICB0b3AgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUudG9wKSxcbiAgICAgICAgICAgIGxlZnQgPSBwYXJzZUZsb2F0KHNwYW4uc3R5bGUubGVmdCk7UkcudGV4dDIuZG9tTm9kZUNhY2hlW29iai5pZF1bY2FjaGVLZXldID0gc3BhbjtSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbb2JqLmlkXVtjYWNoZUtleV0gPSB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wLCB3aWR0aDogb2Zmc2V0V2lkdGgsIGhlaWdodDogb2Zmc2V0SGVpZ2h0IH07c3Bhbi5pZCA9IGNhY2hlS2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhbiA9IFJHLnRleHQyLmRvbU5vZGVDYWNoZVtvYmouaWRdW2NhY2hlS2V5XTtzcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJzt2YXIgb2Zmc2V0V2lkdGggPSBSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbb2JqLmlkXVtjYWNoZUtleV0ud2lkdGgsXG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSBSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbb2JqLmlkXVtjYWNoZUtleV0uaGVpZ2h0LFxuICAgICAgICAgICAgdG9wID0gUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlW29iai5pZF1bY2FjaGVLZXldLnRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbb2JqLmlkXVtjYWNoZUtleV0ubGVmdDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHQubWFya2VyKSB7XG4gICAgICAgIFJHLnBhdGgyKGNvbnRleHQsICdiIG0gJSAlIGwgJSAlIG0gJSAlIGwgJSAlIHMnLCBvcHQueCAtIDUsIG9wdC55LCBvcHQueCArIDUsIG9wdC55LCBvcHQueCwgb3B0LnkgLSA1LCBvcHQueCwgb3B0LnkgKyA1KTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2RyYXdpbmcudGV4dCcpIHtcbiAgICAgICAgaWYgKG9iai5wcm9wZXJ0aWVzWydjaGFydC5ldmVudHMubW91c2Vtb3ZlJ10pIHtcbiAgICAgICAgICBzcGFuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSddKGUsIG9iaik7XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLmNsaWNrJ10pIHtcbiAgICAgICAgICBzcGFuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG9iai5wcm9wZXJ0aWVzWydjaGFydC5ldmVudHMuY2xpY2snXShlLCBvYmopO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRvb2x0aXBzJ10pIHtcbiAgICAgICAgICBzcGFuLmFkZEV2ZW50TGlzdGVuZXIob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50J10uaW5kZXhPZignbW91c2Vtb3ZlJykgIT09IC0xID8gJ21vdXNlbW92ZScgOiAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LnRvb2x0aXAnKSB8fCBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LnRvb2x0aXAnKS5fX2luZGV4X18gIT09IDAgfHwgUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJykuX19vYmplY3RfXy51aWQgIT0gb2JqLnVpZCkge1xuICAgICAgICAgICAgICBSRy5oaWRlVG9vbHRpcCgpO1JHLnJlZHJhdygpO1JHLnRvb2x0aXAob2JqLCBvYmoucHJvcGVydGllc1snY2hhcnQudG9vbHRpcHMnXVswXSwgb3B0LngsIG9wdC55LCAwLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZXQgPSB7fTtyZXQueCA9IGxlZnQ7cmV0LnkgPSB0b3A7cmV0LndpZHRoID0gb2Zmc2V0V2lkdGg7cmV0LmhlaWdodCA9IG9mZnNldEhlaWdodDtyZXQub2JqZWN0ID0gb2JqO3JldC50ZXh0ID0gb3B0LnRleHQ7cmV0LnRhZyA9IG9wdC50YWc7UkcudGV4dDIuZG9tTm9kZUNhY2hlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgY2EgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2EgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBub2RlcyA9IFJHLnRleHQyLmRvbU5vZGVDYWNoZVtjYS5pZF07Zm9yIChqIGluIG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IFJHLnRleHQyLmRvbU5vZGVDYWNoZVtjYS5pZF1bal07aWYgKG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgUkcudGV4dDIuZG9tTm9kZUNhY2hlW2NhLmlkXSA9IFtdO1JHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZVtjYS5pZF0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgaW4gUkcudGV4dDIuZG9tTm9kZUNhY2hlKSB7XG4gICAgICAgICAgICBmb3IgKGogaW4gUkcudGV4dDIuZG9tTm9kZUNhY2hlW2ldKSB7XG4gICAgICAgICAgICAgIGlmIChSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbaV1bal0gJiYgUkcudGV4dDIuZG9tTm9kZUNhY2hlW2ldW2pdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbaV1bal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChSRy50ZXh0Mi5kb21Ob2RlQ2FjaGVbaV1bal0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLnRleHQyLmRvbU5vZGVDYWNoZSA9IFtdO1JHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1JHLnRleHQyLmZpbmQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIHZhciBzcGFuLFxuICAgICAgICAgICAgbm9kZXMgPSBbXTt2YXIgaWQgPSB0eXBlb2Ygb3B0LmlkID09PSAnc3RyaW5nJyA/IG9wdC5pZCA6IG9wdC5vYmplY3QuaWQ7Zm9yIChpIGluIFJHLnRleHQyLmRvbU5vZGVDYWNoZVtpZF0pIHtcbiAgICAgICAgICBzcGFuID0gUkcudGV4dDIuZG9tTm9kZUNhY2hlW2lkXVtpXTtpZiAodHlwZW9mIG9wdC50YWcgPT09ICdzdHJpbmcnICYmIG9wdC50YWcgPT09IHNwYW4udGFnKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNwYW4pO2NvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3R5cGVvZihvcHQudGFnKSA9PT0gJ29iamVjdCcgJiYgb3B0LnRhZy5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoJ1JlZ0V4cCcpKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChvcHQudGFnKTtpZiAocmVnZXhwLnRlc3Qoc3Bhbi50YWcpKSB7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2goc3Bhbik7Y29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LnRleHQgPT09ICdzdHJpbmcnICYmIG9wdC50ZXh0ID09PSBzcGFuLl9fdGV4dF9fKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNwYW4pO2NvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3R5cGVvZihvcHQudGV4dCkgPT09ICdvYmplY3QnICYmIG9wdC50ZXh0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignUmVnRXhwJykpIHtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKG9wdC50ZXh0KTtpZiAocmVnZXhwLnRlc3Qoc3Bhbi5fX3RleHRfXykpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaChzcGFuKTtjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtyZXQubm9kZSA9IHNwYW47aWYgKG9iaiAmJiBvYmouaXNSR3JhcGggJiYgb2JqLmNvb3Jkc1RleHQpIHtcbiAgICAgICAgb2JqLmNvb3Jkc1RleHQucHVzaChyZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmouaXNSR3JhcGgpIHtcbiAgICAgIHZhciBvYmogPSBvYmo7dmFyIGNvID0gb2JqLmNvbnRleHQ7dmFyIGNhID0gb2JqLmNhbnZhcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iaik7dmFyIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKTt2YXIgb2JqID0gY2EuX19vYmplY3RfXztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmouZ2V0Q29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNhID0gb2JqO3ZhciBjbyA9IGNhLmdldENvbnRleHQoJzJkJyk7dmFyIG9iaiA9IGNhLl9fb2JqZWN0X187XG4gICAgfSBlbHNlIGlmIChvYmoudG9TdHJpbmcoKS5pbmRleE9mKCdDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQnKSAhPSAtMSB8fCBSR3JhcGguSVNJRTggJiYgb2JqLm1vdmVUbykge1xuICAgICAgdmFyIGNvID0gb2JqO3ZhciBjYSA9IG9iai5jYW52YXM7dmFyIG9iaiA9IGNhLl9fb2JqZWN0X187XG4gICAgfSBlbHNlIGlmIChSRy5JU09MRCAmJiBvYmouZmlsbFRleHQpIHtcbiAgICAgIHZhciBjbyA9IG9iajt2YXIgY2EgPSBvYmouY2FudmFzO3ZhciBvYmogPSBjYS5fX29iamVjdF9fO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdC5ib3VuZGluZ0ZpbGwgPT09ICdzdHJpbmcnKSBvcHRbJ2JvdW5kaW5nLmZpbGwnXSA9IG9wdC5ib3VuZGluZ0ZpbGw7aWYgKHR5cGVvZiBvcHQuYm91bmRpbmdTdHJva2UgPT09ICdzdHJpbmcnKSBvcHRbJ2JvdW5kaW5nLnN0cm9rZSddID0gb3B0LmJvdW5kaW5nU3Ryb2tlO2lmIChvYmogJiYgb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddICYmIG9wdC5hY2Nlc3NpYmxlICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRvbXRleHQoKTtcbiAgICB9XG4gICAgdmFyIHggPSBvcHQueCxcbiAgICAgICAgeSA9IG9wdC55LFxuICAgICAgICBvcmlnaW5hbFggPSB4LFxuICAgICAgICBvcmlnaW5hbFkgPSB5LFxuICAgICAgICB0ZXh0ID0gb3B0LnRleHQsXG4gICAgICAgIHRleHRfbXVsdGlsaW5lID0gdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnID8gdGV4dC5zcGxpdCgvXFxyP1xcbi9nKSA6ICcnLFxuICAgICAgICBudW1saW5lcyA9IHRleHRfbXVsdGlsaW5lLmxlbmd0aCxcbiAgICAgICAgZm9udCA9IG9wdC5mb250ID8gb3B0LmZvbnQgOiAnQXJpYWwnLFxuICAgICAgICBzaXplID0gb3B0LnNpemUgPyBvcHQuc2l6ZSA6IDEwLFxuICAgICAgICBzaXplX3BpeGVscyA9IHNpemUgKiAxLjUsXG4gICAgICAgIGJvbGQgPSBvcHQuYm9sZCxcbiAgICAgICAgaXRhbGljID0gb3B0Lml0YWxpYyxcbiAgICAgICAgaGFsaWduID0gb3B0LmhhbGlnbiA/IG9wdC5oYWxpZ24gOiAnbGVmdCcsXG4gICAgICAgIHZhbGlnbiA9IG9wdC52YWxpZ24gPyBvcHQudmFsaWduIDogJ2JvdHRvbScsXG4gICAgICAgIHRhZyA9IHR5cGVvZiBvcHQudGFnID09ICdzdHJpbmcnICYmIG9wdC50YWcubGVuZ3RoID4gMCA/IG9wdC50YWcgOiAnJyxcbiAgICAgICAgbWFya2VyID0gb3B0Lm1hcmtlcixcbiAgICAgICAgYW5nbGUgPSBvcHQuYW5nbGUgfHwgMDtcbiAgICB2YXIgYm91bmRpbmcgPSBvcHQuYm91bmRpbmcsXG4gICAgICAgIGJvdW5kaW5nX3N0cm9rZSA9IG9wdFsnYm91bmRpbmcuc3Ryb2tlJ10gPyBvcHRbJ2JvdW5kaW5nLnN0cm9rZSddIDogJ2JsYWNrJyxcbiAgICAgICAgYm91bmRpbmdfZmlsbCA9IG9wdFsnYm91bmRpbmcuZmlsbCddID8gb3B0Wydib3VuZGluZy5maWxsJ10gOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxcbiAgICAgICAgYm91bmRpbmdfc2hhZG93ID0gb3B0Wydib3VuZGluZy5zaGFkb3cnXSxcbiAgICAgICAgYm91bmRpbmdfc2hhZG93X2NvbG9yID0gb3B0Wydib3VuZGluZy5zaGFkb3cuY29sb3InXSB8fCAnI2NjYycsXG4gICAgICAgIGJvdW5kaW5nX3NoYWRvd19ibHVyID0gb3B0Wydib3VuZGluZy5zaGFkb3cuYmx1ciddIHx8IDMsXG4gICAgICAgIGJvdW5kaW5nX3NoYWRvd19vZmZzZXR4ID0gb3B0Wydib3VuZGluZy5zaGFkb3cub2Zmc2V0eCddIHx8IDMsXG4gICAgICAgIGJvdW5kaW5nX3NoYWRvd19vZmZzZXR5ID0gb3B0Wydib3VuZGluZy5zaGFkb3cub2Zmc2V0eSddIHx8IDMsXG4gICAgICAgIGJvdW5kaW5nX2xpbmV3aWR0aCA9IG9wdFsnYm91bmRpbmcubGluZXdpZHRoJ10gfHwgMTt2YXIgcmV0ID0ge307aWYgKHR5cGVvZiBvcHQuY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgb3JpZ19maWxsc3R5bGUgPSBjby5maWxsU3R5bGU7Y28uZmlsbFN0eWxlID0gb3B0LmNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRleHQgPT0gJ251bWJlcicpIHtcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFuZ2xlICE9IDApIHtcbiAgICAgIGNvLnNhdmUoKTtjby50cmFuc2xhdGUoeCwgeSk7Y28ucm90YXRlKG1hLlBJIC8gMTgwICogYW5nbGUpO1xuICAgICAgeCA9IDA7eSA9IDA7XG4gICAgfVxuICAgIGNvLmZvbnQgPSAob3B0Lml0YWxpYyA/ICdpdGFsaWMgJyA6ICcnKSArIChvcHQuYm9sZCA/ICdib2xkICcgOiAnJykgKyBzaXplICsgJ3B0ICcgKyBmb250O3ZhciB3aWR0aCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1saW5lczsgKytpKSB7XG4gICAgICB3aWR0aCA9IG1hLm1heCh3aWR0aCwgY28ubWVhc3VyZVRleHQodGV4dF9tdWx0aWxpbmVbaV0pLndpZHRoKTtcbiAgICB9XG4gICAgdmFyIGhlaWdodCA9IHNpemVfcGl4ZWxzICogbnVtbGluZXM7aWYgKG9wdC5tYXJrZXIpIHtcbiAgICAgIHZhciBtYXJrZXJfc2l6ZSA9IDEwO3ZhciBzdHJva2VzdHlsZSA9IGNvLnN0cm9rZVN0eWxlO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ3JlZCc7Y28ubW92ZVRvKHgsIHkgLSBtYXJrZXJfc2l6ZSk7Y28ubGluZVRvKHgsIHkgKyBtYXJrZXJfc2l6ZSk7Y28ubW92ZVRvKHggLSBtYXJrZXJfc2l6ZSwgeSk7Y28ubGluZVRvKHggKyBtYXJrZXJfc2l6ZSwgeSk7Y28uc3Ryb2tlKCk7Y28uc3Ryb2tlU3R5bGUgPSBzdHJva2VzdHlsZTtcbiAgICB9XG4gICAgaWYgKGhhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgY28udGV4dEFsaWduID0gJ2NlbnRlcic7dmFyIGJvdW5kaW5nWCA9IHggLSAyIC0gd2lkdGggLyAyO1xuICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdyaWdodCcpIHtcbiAgICAgIGNvLnRleHRBbGlnbiA9ICdyaWdodCc7dmFyIGJvdW5kaW5nWCA9IHggLSAyIC0gd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvLnRleHRBbGlnbiA9ICdsZWZ0Jzt2YXIgYm91bmRpbmdYID0geCAtIDI7XG4gICAgfVxuICAgIGlmICh2YWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgIGNvLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO3kgLT0gMTt5IC09IChudW1saW5lcyAtIDEpIC8gMiAqIHNpemVfcGl4ZWxzO3ZhciBib3VuZGluZ1kgPSB5IC0gc2l6ZV9waXhlbHMgLyAyIC0gMjtcbiAgICB9IGVsc2UgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgY28udGV4dEJhc2VsaW5lID0gJ3RvcCc7dmFyIGJvdW5kaW5nWSA9IHkgLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztpZiAobnVtbGluZXMgPiAxKSB7XG4gICAgICAgIHkgLT0gKG51bWxpbmVzIC0gMSkgKiBzaXplX3BpeGVscztcbiAgICAgIH1cbiAgICAgIHZhciBib3VuZGluZ1kgPSB5IC0gc2l6ZV9waXhlbHMgLSAyO1xuICAgIH1cbiAgICB2YXIgYm91bmRpbmdXID0gd2lkdGggKyA0O3ZhciBib3VuZGluZ0ggPSBoZWlnaHQgKyA0O2lmIChib3VuZGluZykge1xuICAgICAgdmFyIHByZV9ib3VuZGluZ19saW5ld2lkdGggPSBjby5saW5lV2lkdGg7dmFyIHByZV9ib3VuZGluZ19zdHJva2VzdHlsZSA9IGNvLnN0cm9rZVN0eWxlO3ZhciBwcmVfYm91bmRpbmdfZmlsbHN0eWxlID0gY28uZmlsbFN0eWxlO3ZhciBwcmVfYm91bmRpbmdfc2hhZG93Y29sb3IgPSBjby5zaGFkb3dDb2xvcjt2YXIgcHJlX2JvdW5kaW5nX3NoYWRvd2JsdXIgPSBjby5zaGFkb3dCbHVyO3ZhciBwcmVfYm91bmRpbmdfc2hhZG93b2Zmc2V0eCA9IGNvLnNoYWRvd09mZnNldFg7dmFyIHByZV9ib3VuZGluZ19zaGFkb3dvZmZzZXR5ID0gY28uc2hhZG93T2Zmc2V0WTtjby5saW5lV2lkdGggPSBib3VuZGluZ19saW5ld2lkdGg7Y28uc3Ryb2tlU3R5bGUgPSBib3VuZGluZ19zdHJva2U7Y28uZmlsbFN0eWxlID0gYm91bmRpbmdfZmlsbDtpZiAoYm91bmRpbmdfc2hhZG93KSB7XG4gICAgICAgIGNvLnNoYWRvd0NvbG9yID0gYm91bmRpbmdfc2hhZG93X2NvbG9yO2NvLnNoYWRvd0JsdXIgPSBib3VuZGluZ19zaGFkb3dfYmx1cjtjby5zaGFkb3dPZmZzZXRYID0gYm91bmRpbmdfc2hhZG93X29mZnNldHg7Y28uc2hhZG93T2Zmc2V0WSA9IGJvdW5kaW5nX3NoYWRvd19vZmZzZXR5O1xuICAgICAgfVxuICAgICAgY28uc3Ryb2tlUmVjdChib3VuZGluZ1gsIGJvdW5kaW5nWSwgYm91bmRpbmdXLCBib3VuZGluZ0gpO2NvLmZpbGxSZWN0KGJvdW5kaW5nWCwgYm91bmRpbmdZLCBib3VuZGluZ1csIGJvdW5kaW5nSCk7Y28ubGluZVdpZHRoID0gcHJlX2JvdW5kaW5nX2xpbmV3aWR0aDtjby5zdHJva2VTdHlsZSA9IHByZV9ib3VuZGluZ19zdHJva2VzdHlsZTtjby5maWxsU3R5bGUgPSBwcmVfYm91bmRpbmdfZmlsbHN0eWxlO2NvLnNoYWRvd0NvbG9yID0gcHJlX2JvdW5kaW5nX3NoYWRvd2NvbG9yO1xuICAgICAgY28uc2hhZG93Qmx1ciA9IHByZV9ib3VuZGluZ19zaGFkb3dibHVyO1xuICAgICAgY28uc2hhZG93T2Zmc2V0WCA9IHByZV9ib3VuZGluZ19zaGFkb3dvZmZzZXR4O1xuICAgICAgY28uc2hhZG93T2Zmc2V0WSA9IHByZV9ib3VuZGluZ19zaGFkb3dvZmZzZXR5O1xuICAgIH1cbiAgICBpZiAobnVtbGluZXMgPiAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWxpbmVzOyArK2kpIHtcbiAgICAgICAgY28uZmlsbFRleHQodGV4dF9tdWx0aWxpbmVbaV0sIHgsIHkgKyBzaXplX3BpeGVscyAqIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjby5maWxsVGV4dCh0ZXh0LCB4ICsgMC41LCB5ICsgMC41KTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlICE9IDApIHtcbiAgICAgIGlmIChhbmdsZSA9PSA5MCkge1xuICAgICAgICBpZiAoaGFsaWduID09ICdsZWZ0Jykge1xuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC8gMiAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAodmFsaWduID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC8gMiAtIDI7Ym91bmRpbmdXID0gaGVpZ2h0ICsgNDtib3VuZGluZ0ggPSB3aWR0aCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIGhlaWdodCAvIDIgLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC8gMiAtIDI7Ym91bmRpbmdXID0gaGVpZ2h0ICsgNDtib3VuZGluZ0ggPSB3aWR0aCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIGhlaWdodCAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gd2lkdGggLyAyIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZiAodmFsaWduID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC8gMiAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gd2lkdGggLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSBoZWlnaHQgLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW5nbGUgPT0gMTgwKSB7XG4gICAgICAgIGlmIChoYWxpZ24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gd2lkdGggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIDI7Ym91bmRpbmdXID0gd2lkdGggKyA0O2JvdW5kaW5nSCA9IGhlaWdodCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIHdpZHRoIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSBoZWlnaHQgLyAyIC0gMjtib3VuZGluZ1cgPSB3aWR0aCArIDQ7Ym91bmRpbmdIID0gaGVpZ2h0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gd2lkdGggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIGhlaWdodCAtIDI7Ym91bmRpbmdXID0gd2lkdGggKyA0O2JvdW5kaW5nSCA9IGhlaWdodCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIHdpZHRoIC8gMiAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gMjtib3VuZGluZ1cgPSB3aWR0aCArIDQ7Ym91bmRpbmdIID0gaGVpZ2h0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gd2lkdGggLyAyIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSBoZWlnaHQgLyAyIC0gMjtib3VuZGluZ1cgPSB3aWR0aCArIDQ7Ym91bmRpbmdIID0gaGVpZ2h0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gd2lkdGggLyAyIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSBoZWlnaHQgLSAyO2JvdW5kaW5nVyA9IHdpZHRoICsgNDtib3VuZGluZ0ggPSBoZWlnaHQgKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWCA9IG9yaWdpbmFsWCAtIDI7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gMjtib3VuZGluZ1cgPSB3aWR0aCArIDQ7Ym91bmRpbmdIID0gaGVpZ2h0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSBoZWlnaHQgLyAyIC0gMjtib3VuZGluZ1cgPSB3aWR0aCArIDQ7Ym91bmRpbmdIID0gaGVpZ2h0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSBoZWlnaHQgLSAyO2JvdW5kaW5nVyA9IHdpZHRoICsgNDtib3VuZGluZ0ggPSBoZWlnaHQgKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbmdsZSA9PSAyNzApIHtcbiAgICAgICAgaWYgKGhhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICBpZiAodmFsaWduID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSBoZWlnaHQgLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC8gMiAtIDQ7Ym91bmRpbmdZID0gb3JpZ2luYWxZIC0gd2lkdGggLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC0gMjtib3VuZGluZ1cgPSBoZWlnaHQgKyA0O2JvdW5kaW5nSCA9IHdpZHRoICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSB3aWR0aCAvIDIgLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSBoZWlnaHQgLyAyIC0gNDtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSB3aWR0aCAvIDIgLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIHdpZHRoIC8gMiAtIDI7Ym91bmRpbmdXID0gaGVpZ2h0ICsgNDtib3VuZGluZ0ggPSB3aWR0aCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgYm91bmRpbmdYID0gb3JpZ2luYWxYIC0gaGVpZ2h0IC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSBoZWlnaHQgLyAyIC0gMjtib3VuZGluZ1kgPSBvcmlnaW5hbFkgLSAyO2JvdW5kaW5nVyA9IGhlaWdodCArIDQ7Ym91bmRpbmdIID0gd2lkdGggKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgICBib3VuZGluZ1ggPSBvcmlnaW5hbFggLSAyO2JvdW5kaW5nWSA9IG9yaWdpbmFsWSAtIDI7Ym91bmRpbmdXID0gaGVpZ2h0ICsgNDtib3VuZGluZ0ggPSB3aWR0aCArIDQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjby5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGNvLnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztjby50ZXh0QWxpZ24gPSAnbGVmdCc7cmV0LnggPSBib3VuZGluZ1g7cmV0LnkgPSBib3VuZGluZ1k7cmV0LndpZHRoID0gYm91bmRpbmdXO3JldC5oZWlnaHQgPSBib3VuZGluZ0g7XG4gICAgcmV0Lm9iamVjdCA9IG9iajtyZXQudGV4dCA9IHRleHQ7cmV0LnRhZyA9IHRhZztpZiAob2JqICYmIG9iai5pc1JHcmFwaCAmJiBvYmouY29vcmRzVGV4dCkge1xuICAgICAgb2JqLmNvb3Jkc1RleHQucHVzaChyZXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdfZmlsbHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgY28uZmlsbFN0eWxlID0gb3JpZ19maWxsc3R5bGU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07Ukcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhKSB7XG4gICAgdmFyIGdyb3VwID0gMDt2YXIgZ3JvdXBlZF9pbmRleCA9IDA7d2hpbGUgKC0taW5kZXggPj0gMCkge1xuICAgICAgaWYgKFJHLmlzX251bGwoZGF0YVtncm91cF0pKSB7XG4gICAgICAgIGdyb3VwKys7Z3JvdXBlZF9pbmRleCA9IDA7Y29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFbZ3JvdXBdID09ICdudW1iZXInKSB7XG4gICAgICAgIGdyb3VwKys7XG4gICAgICAgIGdyb3VwZWRfaW5kZXggPSAwO2NvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZ3JvdXBlZF9pbmRleCsrO2lmIChncm91cGVkX2luZGV4ID49IGRhdGFbZ3JvdXBdLmxlbmd0aCkge1xuICAgICAgICBncm91cCsrO2dyb3VwZWRfaW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2dyb3VwLCBncm91cGVkX2luZGV4XTtcbiAgfTtSRy5IaWdobGlnaHQucmVjdCA9IFJHLkhpZ2hsaWdodC5SZWN0ID0gZnVuY3Rpb24gKG9iaiwgc2hhcGUpIHtcbiAgICB2YXIgY2EgPSBvYmouY2FudmFzO3ZhciBjbyA9IG9iai5jb250ZXh0O3ZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7aWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKSB7XG4gICAgICBjby5saW5lV2lkdGggPSAxO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107Y28ucmVjdChzaGFwZVsneCddLCBzaGFwZVsneSddLCBzaGFwZVsnd2lkdGgnXSwgc2hhcGVbJ2hlaWdodCddKTtjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgfVxuICB9O1JHLkhpZ2hsaWdodC5wb2ludCA9IFJHLkhpZ2hsaWdodC5Qb2ludCA9IGZ1bmN0aW9uIChvYmosIHNoYXBlKSB7XG4gICAgdmFyIHByb3AgPSBvYmoucHJvcGVydGllczt2YXIgY2EgPSBvYmouY2FudmFzO3ZhciBjbyA9IG9iai5jb250ZXh0O2lmIChwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTt2YXIgcmFkaXVzID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnBvaW50LnJhZGl1cyddIHx8IDI7Y28uYXJjKHNoYXBlWyd4J10sIHNoYXBlWyd5J10sIHJhZGl1cywgMCwgUkcuVFdPUEksIDApO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICB9XG4gIH07UkcucGFyc2VEYXRlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHN0ciA9IFJHLnRyaW0oc3RyKTtpZiAoc3RyID09PSAnbm93Jykge1xuICAgICAgc3RyID0gbmV3IERhdGUoKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoc3RyLm1hdGNoKC9eKFxcZFxcZCkoPzotfFxcLykoXFxkXFxkKSg/Oi18XFwvKShcXGRcXGRcXGRcXGQpKC4qKSQvKSkge1xuICAgICAgc3RyID0gJ3sxfS97Mn0vezN9ezR9Jy5mb3JtYXQoUmVnRXhwLiQzLCBSZWdFeHAuJDIsIFJlZ0V4cC4kMSwgUmVnRXhwLiQ0KTtcbiAgICB9XG4gICAgaWYgKHN0ci5tYXRjaCgvXihcXGRcXGRcXGRcXGQpKC18XFwvKShcXGRcXGQpKC18XFwvKShcXGRcXGQpKCB8VCkoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSQvKSkge1xuICAgICAgc3RyID0gUmVnRXhwLiQxICsgJy0nICsgUmVnRXhwLiQzICsgJy0nICsgUmVnRXhwLiQ1ICsgJ1QnICsgUmVnRXhwLiQ3ICsgJzonICsgUmVnRXhwLiQ4ICsgJzonICsgUmVnRXhwLiQ5O1xuICAgIH1cbiAgICBpZiAoc3RyLm1hdGNoKC9eXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGQkLykpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8tL2csICcvJyk7XG4gICAgfVxuICAgIGlmIChzdHIubWF0Y2goL15cXGRcXGQ6XFxkXFxkOlxcZFxcZCQvKSkge1xuICAgICAgdmFyIGRhdGVPYmogPSBuZXcgRGF0ZSgpO3ZhciBkYXRlID0gZGF0ZU9iai5nZXREYXRlKCk7dmFyIG1vbnRoID0gZGF0ZU9iai5nZXRNb250aCgpICsgMTt2YXIgeWVhciA9IGRhdGVPYmouZ2V0RnVsbFllYXIoKTtpZiAoU3RyaW5nKG1vbnRoKS5sZW5ndGggPT09IDEpIG1vbnRoID0gJzAnICsgbW9udGg7aWYgKFN0cmluZyhkYXRlKS5sZW5ndGggPT09IDEpIGRhdGUgPSAnMCcgKyBkYXRlO3N0ciA9IHllYXIgKyAnLycgKyBtb250aCArICcvJyArIGRhdGUgKyAnICcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBEYXRlLnBhcnNlKHN0cik7XG4gIH07UkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmoub3JpZ2luYWxfY29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBqIGluIG9iai5vcmlnaW5hbF9jb2xvcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJyAmJiBqLnN1YnN0cigwLCA2KSA9PT0gJ2NoYXJ0LicpIHtcbiAgICAgICAgICBvYmoucHJvcGVydGllc1tqXSA9IFJHLmFycmF5Q2xvbmUob2JqLm9yaWdpbmFsX2NvbG9yc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmoucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmoucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKCk7XG4gICAgfVxuICAgIG9iai5jb2xvcnNQYXJzZWQgPSBmYWxzZTtcbiAgfTtSRy5saW5lYXJHcmFkaWVudCA9IFJHLkxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKG9iaiwgeDEsIHkxLCB4MiwgeTIsIGNvbG9yMSwgY29sb3IyKSB7XG4gICAgdmFyIGdyYWRpZW50ID0gb2JqLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO3ZhciBudW1Db2xvcnMgPSBhcmd1bWVudHMubGVuZ3RoIC0gNTtmb3IgKHZhciBpID0gNTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNvbG9yID0gYXJndW1lbnRzW2ldO3ZhciBzdG9wID0gKGkgLSA1KSAvIChudW1Db2xvcnMgLSAxKTtncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH07UkcucmFkaWFsR3JhZGllbnQgPSBSRy5SYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uIChvYmosIHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIsIGNvbG9yMSwgY29sb3IyKSB7XG4gICAgdmFyIGdyYWRpZW50ID0gb2JqLmNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoeDEsIHkxLCByMSwgeDIsIHkyLCByMik7dmFyIG51bUNvbG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggLSA3O2ZvciAodmFyIGkgPSA3OyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY29sb3IgPSBhcmd1bWVudHNbaV07dmFyIHN0b3AgPSAoaSAtIDcpIC8gKG51bUNvbG9ycyAtIDEpO2dyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfTtSRy5hZGRFdmVudExpc3RlbmVyID0gUkcuQWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChpZCwgZSwgZnVuYykge1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogJ3Vua25vd24nO1JHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuZXZlbnQuaGFuZGxlcnMnKS5wdXNoKFtpZCwgZSwgZnVuYywgdHlwZV0pO1xuICB9O1JHLmNsZWFyRXZlbnRMaXN0ZW5lcnMgPSBSRy5DbGVhckV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkID09ICd3aW5kb3cnKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgd2luZG93Ll9fcmdyYXBoX21vdXNlZG93bl9ldmVudF9saXN0ZW5lcl9pbnN0YWxsZWRfXywgZmFsc2UpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgd2luZG93Ll9fcmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXJfaW5zdGFsbGVkX18sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGNhbnZhcy5fX3JncmFwaF9tb3VzZXVwX2V2ZW50X2xpc3RlbmVyX2luc3RhbGxlZF9fLCBmYWxzZSk7Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGNhbnZhcy5fX3JncmFwaF9tb3VzZW1vdmVfZXZlbnRfbGlzdGVuZXJfaW5zdGFsbGVkX18sIGZhbHNlKTtjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2FudmFzLl9fcmdyYXBoX21vdXNlZG93bl9ldmVudF9saXN0ZW5lcl9pbnN0YWxsZWRfXywgZmFsc2UpO2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbnZhcy5fX3JncmFwaF9jbGlja19ldmVudF9saXN0ZW5lcl9pbnN0YWxsZWRfXywgZmFsc2UpO1xuICAgIH1cbiAgfTtSRy5oaWRlUGFsZXR0ZSA9IFJHLkhpZGVQYWxldHRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXYgPSBSRy5SZWdpc3RyeS5nZXQoJ3BhbGV0dGUnKTtpZiAoKHR5cGVvZiBkaXYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRpdikpID09ICdvYmplY3QnICYmIGRpdikge1xuICAgICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztkaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztSRy5SZWdpc3RyeS5zZXQoJ3BhbGV0dGUnLCBudWxsKTtcbiAgICB9XG4gIH07UkcucmFuZG9tID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgdmFyIGRwID0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogMDt2YXIgciA9IG1hLnJhbmRvbSgpO3JldHVybiBOdW1iZXIoKChtYXggLSBtaW4pICogciArIG1pbikudG9GaXhlZChkcCkpO1xuICB9O1JHLmFycmF5UmFuZCA9IFJHLmFycmF5UmFuZG9tID0gUkcucmFuZG9tLmFycmF5ID0gZnVuY3Rpb24gKG51bSwgbWluLCBtYXgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyID0gW107IGkgPCBudW07IGkgKz0gMSkge1xuICAgICAgYXJyLnB1c2goUkcucmFuZG9tKG1pbiwgbWF4LCBhcmd1bWVudHNbM10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtSRy5ub1NoYWRvdyA9IFJHLk5vU2hhZG93ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBjbyA9IG9iai5jb250ZXh0O2NvLnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO2NvLnNoYWRvd0JsdXIgPSAwO2NvLnNoYWRvd09mZnNldFggPSAwO2NvLnNoYWRvd09mZnNldFkgPSAwO1xuICB9O1JHLnNldFNoYWRvdyA9IFJHLlNldFNoYWRvdyA9IGZ1bmN0aW9uIChvYmosIGNvbG9yLCBvZmZzZXR4LCBvZmZzZXR5LCBibHVyKSB7XG4gICAgdmFyIGNvID0gb2JqLmNvbnRleHQ7Y28uc2hhZG93Q29sb3IgPSBjb2xvcjtjby5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0eDtjby5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0eTtjby5zaGFkb3dCbHVyID0gYmx1cjtcbiAgfTtSRy5SZWdpc3RyeS5zZXQgPSBSRy5SZWdpc3RyeS5TZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiAnLicgKyBTdHJpbmcoUmVnRXhwLiQxKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO2lmIChuYW1lLnN1YnN0cigwLCA2KSAhPT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIFJHLlJlZ2lzdHJ5LnN0b3JlW25hbWVdID0gdmFsdWU7cmV0dXJuIHZhbHVlO1xuICB9O1JHLlJlZ2lzdHJ5LmdldCA9IFJHLlJlZ2lzdHJ5LkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gJy4nICsgU3RyaW5nKFJlZ0V4cC4kMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtpZiAobmFtZS5zdWJzdHIoMCwgNikgIT09ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gUkcuUmVnaXN0cnkuc3RvcmVbbmFtZV07XG4gIH07UkcuZGVncmVlczJSYWRpYW5zID0gZnVuY3Rpb24gKGRlZykge1xuICAgIHJldHVybiBkZWcgKiAoUkcuUEkgLyAxODApO1xuICB9O1JHLmxvZyA9IGZ1bmN0aW9uIChuLCBiYXNlKSB7XG4gICAgcmV0dXJuIG1hLmxvZyhuKSAvIChiYXNlID8gbWEubG9nKGJhc2UpIDogMSk7XG4gIH07UkcuaXNBcnJheSA9IFJHLmlzX2FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLmNvbnN0cnVjdG9yKSB7XG4gICAgICB2YXIgcG9zID0gb2JqLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZignQXJyYXknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIHBvcyA9PT0gJ251bWJlcicgJiYgcG9zID4gMCAmJiBwb3MgPCAyMDtcbiAgfTtSRy50cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBSRy5sdHJpbShSRy5ydHJpbShzdHIpKTtcbiAgfTtSRy5sdHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oXFxzfFxcMCkrLywgJycpO1xuICB9O1JHLnJ0cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcc3xcXDApKyQvLCAnJyk7XG4gIH07UkcuaXNOdWxsID0gUkcuaXNfbnVsbCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoYXJnID09IG51bGwgfHwgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFyZykpID09PSAnb2JqZWN0JyAmJiAhYXJnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLmFzeW5jID0gUkcuQXN5bmMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmMsIGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDEpO1xuICB9O1JHLnJlc2V0ID0gUkcuUmVzZXQgPSBmdW5jdGlvbiAoY2EpIHtcbiAgICBjYS53aWR0aCA9IGNhLndpZHRoO1JHLk9iamVjdFJlZ2lzdHJ5LmNsZWFyKGNhKTtjYS5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSBmYWxzZTtpZiAoUkcudGV4dDIuZG9tTm9kZUNhY2hlICYmIFJHLnRleHQyLmRvbU5vZGVDYWNoZS5yZXNldCkge1xuICAgICAgUkcudGV4dDIuZG9tTm9kZUNhY2hlLnJlc2V0KGNhKTtcbiAgICB9XG4gICAgaWYgKCFSRy50ZXh0Mi5kb21Ob2RlQ2FjaGUpIHtcbiAgICAgIFJHLnRleHQyLmRvbU5vZGVDYWNoZSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIVJHLnRleHQyLmRvbU5vZGVEaW1lbnNpb25DYWNoZSkge1xuICAgICAgUkcudGV4dDIuZG9tTm9kZURpbWVuc2lvbkNhY2hlID0gW107XG4gICAgfVxuICAgIFJHLnRleHQyLmRvbU5vZGVDYWNoZVtjYS5pZF0gPSBbXTtSRy50ZXh0Mi5kb21Ob2RlRGltZW5zaW9uQ2FjaGVbY2EuaWRdID0gW107XG4gIH07UkcuYXR0ID0gUkcuYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGNhID0gb2JqLmNhbnZhcyxcbiAgICAgICAgY28gPSBvYmouY29udGV4dCxcbiAgICAgICAgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO2lmICghY2EgfHwgIWNvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IGNhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBjYS5oZWlnaHQsXG4gICAgICAgIHdyYXBwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3ZzJykuX19vYmplY3RfXy5jYW52YXMucGFyZW50Tm9kZSxcbiAgICAgICAgdGV4dCA9IHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLnRleHQnXSB8fCAnRnJlZSBDaGFydHMgd2l0aCBSR3JhcGgubmV0JyxcbiAgICAgICAgeCA9IHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLngnXSxcbiAgICAgICAgeSA9IHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLnknXSxcbiAgICAgICAgYm9sZCA9IHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLmJvbGQnXSxcbiAgICAgICAgaXRhbGljID0gcHJvcFsnY2hhcnQuYXR0cmlidXRpb24uaXRhbGljJ10sXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC5hdHRyaWJ1dGlvbi5mb250J10gfHwgJ3NhbnMtc2VyaWYnLFxuICAgICAgICBzaXplID0gcHJvcFsnY2hhcnQuYXR0cmlidXRpb24uc2l6ZSddIHx8IDgsXG4gICAgICAgIHVuZGVybGluZSA9IHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLnVuZGVybGluZSddID8gJ3VuZGVybGluZScgOiAnbm9uZScsXG4gICAgICAgIGNvbG9yID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLmNvbG9yJ10gPT09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQuYXR0cmlidXRpb24uY29sb3InXSA6ICcnLFxuICAgICAgICBocmVmID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmF0dHJpYnV0aW9uLmhyZWYnXSA9PT0gJ3N0cmluZycgPyBwcm9wWydjaGFydC5hdHRyaWJ1dGlvbi5ocmVmJ10gOiAnaHR0cDovL3d3dy5yZ3JhcGgubmV0L2NhbnZhcy9pbmRleC5odG1sJztpZiAod3JhcHBlci5hdHRyaWJ1dGlvbl9ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtZWFzdXJlbWVudHMgPSBSRy5tZWFzdXJlVGV4dCh0ZXh0LCBib2xkLCBmb250LCBzaXplKTt2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTthLmhyZWYgPSBocmVmO2EuaW5uZXJIVE1MID0gdGV4dDthLnRhcmdldCA9ICdfYmxhbmsnO2Euc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Euc3R5bGUubGVmdCA9IHR5cGVvZiB4ID09PSAnbnVtYmVyJyA/IHggOiB3cmFwcGVyLm9mZnNldFdpZHRoIC0gbWVhc3VyZW1lbnRzWzBdIC0gNSArICdweCc7YS5zdHlsZS50b3AgPSB0eXBlb2YgeSA9PT0gJ251bWJlcicgPyB5IDogd3JhcHBlci5vZmZzZXRIZWlnaHQgLSBtZWFzdXJlbWVudHNbMV0gKyAncHgnO2Euc3R5bGUuZm9udFNpemUgPSBzaXplICsgJ3B0JzthLnN0eWxlLmZvbnRTdHlsZSA9IHR5cGVvZiBpdGFsaWMgPT09ICdib29sZWFuJyA/IGl0YWxpYyA/ICdpdGFsaWMnIDogJycgOiAnaXRhbGljJywgYS5zdHlsZS5mb250V2VpZ2h0ID0gYm9sZCA/ICdib2xkJyA6ICcnLCBhLnN0eWxlLnRleHREZWNvcmF0aW9uID0gdW5kZXJsaW5lO2Euc3R5bGUuZm9udEZhbWlseSA9IGZvbnQ7YS5zdHlsZS5jb2xvciA9IGNvbG9yO3dyYXBwZXIuYXBwZW5kQ2hpbGQoYSk7d3JhcHBlci5hdHRyaWJ1dGlvbl9ub2RlID0gYTtcbiAgfTtSRy5nZXRDYW52YXNUYWcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZCA9ICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlkKSkgPT09ICdvYmplY3QnID8gaWQuaWQgOiBpZDt2YXIgY2FudmFzID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtyZXR1cm4gW2lkLCBjYW52YXNdO1xuICB9O1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzID0gUkcuRWZmZWN0cy5VcGRhdGVDYW52YXMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbi5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuYywgMTYuNjY2KTtcbiAgICB9O3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuYyk7XG4gIH07UkcuRWZmZWN0cy5nZXRFYXNpbmdNdWx0aXBsaWVyID0gZnVuY3Rpb24gKGZyYW1lcywgZnJhbWUpIHtcbiAgICByZXR1cm4gbWEucG93KG1hLnNpbihmcmFtZSAvIGZyYW1lcyAqIFJHLkhBTEZQSSksIDMpO1xuICB9O1JHLnN0cmluZ3NUb051bWJlcnMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50c1sxXSB8fCAnLCc7aWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZihzZXApICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zcGxpdChzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0cikpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzdHJbaV0gPSBwYXJzZUZsb2F0KHN0cltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07UkcuY2FjaGVkRHJhdyA9IGZ1bmN0aW9uIChvYmosIGlkLCBmdW5jKSB7XG4gICAgaWYgKCFSRy5jYWNoZVtpZF0pIHtcbiAgICAgIFJHLmNhY2hlW2lkXSA9IHt9O1JHLmNhY2hlW2lkXS5vYmplY3QgPSBvYmo7UkcuY2FjaGVbaWRdLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1JHLmNhY2hlW2lkXS5jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIG9iai5jYW52YXMud2lkdGgpO1JHLmNhY2hlW2lkXS5jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBvYmouY2FudmFzLmhlaWdodCk7UkcuY2FjaGVbaWRdLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2JhY2tncm91bmRfY2FjaGVkX2NhbnZhcycgKyBvYmouY2FudmFzLmlkKTtSRy5jYWNoZVtpZF0uY2FudmFzLl9fb2JqZWN0X18gPSBvYmo7UkcuY2FjaGVbaWRdLmNvbnRleHQgPSBSRy5jYWNoZVtpZF0uY2FudmFzLmdldENvbnRleHQoJzJkJyk7UkcuY2FjaGVbaWRdLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTtmdW5jKG9iaiwgUkcuY2FjaGVbaWRdLmNhbnZhcywgUkcuY2FjaGVbaWRdLmNvbnRleHQpO1xuICAgIH1cbiAgICBvYmouY29udGV4dC5kcmF3SW1hZ2UoUkcuY2FjaGVbaWRdLmNhbnZhcywgLTAuNSwgLTAuNSk7XG4gIH07UkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyA9IGZ1bmN0aW9uIChvYmosIGNvbmZpZykge1xuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gcmVjdXJzZShvYmosIGNvbmZpZywgbmFtZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBpO2ZvciAoa2V5IGluIGNvbmZpZykge1xuICAgICAgICBpZiAoa2V5Lm1hdGNoKC9eZXhlY1swLTldKiQvKSkge1xuICAgICAgICAgIGNvbmZpZ1trZXldKG9iaiwgc2V0dGluZ3MpO2NvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc09iamVjdCA9IGZhbHNlO3ZhciBpc0FycmF5ID0gZmFsc2U7dmFyIHZhbHVlID0gY29uZmlnW2tleV07d2hpbGUgKGtleS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICAgICAga2V5ID0ga2V5LnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFSRy5pc051bGwodmFsdWUpICYmIHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgaXNPYmplY3QgPSB2YWx1ZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoJ09iamVjdCcpID4gMDtpc0FycmF5ID0gdmFsdWUuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKCdBcnJheScpID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3QgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICByZWN1cnNlKG9iaiwgY29uZmlnW2tleV0sIG5hbWUgKyAnLicgKyBrZXksIHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZWxmJykge1xuICAgICAgICAgIHNldHRpbmdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGluZ3NbbmFtZSArICcuJyArIGtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH07dmFyIHNldHRpbmdzID0gcmVjdXJzZShvYmosIGNvbmZpZywgJ2NoYXJ0Jywge30pO2ZvciAoa2V5IGluIHNldHRpbmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLnNldChrZXksIHNldHRpbmdzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5wYXRoMiA9IGZ1bmN0aW9uIChjbywgcCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO2lmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHAgPSBzcGxpdHN0cmluZyhwKTtcbiAgICB9XG4gICAgUkcucGF0aDIubGFzdCA9IFJHLmFycmF5Q2xvbmUocCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHAubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHN3aXRjaCAocFtpXSkge2Nhc2UgJ2InOlxuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2JyZWFrO2Nhc2UgJ2MnOlxuICAgICAgICAgIGNvLmNsb3NlUGF0aCgpO2JyZWFrO2Nhc2UgJ20nOlxuICAgICAgICAgIGNvLm1vdmVUbyhwYXJzZUZsb2F0KHBbaSArIDFdKSwgcGFyc2VGbG9hdChwW2kgKyAyXSkpO2kgKz0gMjticmVhaztjYXNlICdsJzpcbiAgICAgICAgICBjby5saW5lVG8ocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pKTtpICs9IDI7YnJlYWs7Y2FzZSAncyc6XG4gICAgICAgICAgaWYgKHBbaSArIDFdKSBjby5zdHJva2VTdHlsZSA9IHBbaSArIDFdO2NvLnN0cm9rZSgpO2krKzticmVhaztjYXNlICdmJzpcbiAgICAgICAgICBpZiAocFtpICsgMV0pIHtcbiAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IHBbaSArIDFdO1xuICAgICAgICAgIH1jby5maWxsKCk7aSsrO2JyZWFrO2Nhc2UgJ3FjJzpcbiAgICAgICAgICBjby5xdWFkcmF0aWNDdXJ2ZVRvKHBhcnNlRmxvYXQocFtpICsgMV0pLCBwYXJzZUZsb2F0KHBbaSArIDJdKSwgcGFyc2VGbG9hdChwW2kgKyAzXSksIHBhcnNlRmxvYXQocFtpICsgNF0pKTtpICs9IDQ7YnJlYWs7Y2FzZSAnYmMnOlxuICAgICAgICAgIGNvLmJlemllckN1cnZlVG8ocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pLCBwYXJzZUZsb2F0KHBbaSArIDNdKSwgcGFyc2VGbG9hdChwW2kgKyA0XSksIHBhcnNlRmxvYXQocFtpICsgNV0pLCBwYXJzZUZsb2F0KHBbaSArIDZdKSk7aSArPSA2O2JyZWFrO2Nhc2UgJ3InOlxuICAgICAgICAgIGNvLnJlY3QocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pLCBwYXJzZUZsb2F0KHBbaSArIDNdKSwgcGFyc2VGbG9hdChwW2kgKyA0XSkpO2kgKz0gNDticmVhaztjYXNlICdhJzpcbiAgICAgICAgICBjby5hcmMocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pLCBwYXJzZUZsb2F0KHBbaSArIDNdKSwgcGFyc2VGbG9hdChwW2kgKyA0XSksIHBhcnNlRmxvYXQocFtpICsgNV0pLCBwW2kgKyA2XSA9PT0gJ3RydWUnIHx8IHBbaSArIDZdID09PSB0cnVlIHx8IHBbaSArIDZdID09PSAxIHx8IHBbaSArIDZdID09PSAnMScgPyB0cnVlIDogZmFsc2UpO2kgKz0gNjticmVhaztjYXNlICdhdCc6XG4gICAgICAgICAgY28uYXJjVG8ocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pLCBwYXJzZUZsb2F0KHBbaSArIDNdKSwgcGFyc2VGbG9hdChwW2kgKyA0XSksIHBhcnNlRmxvYXQocFtpICsgNV0pKTtpICs9IDU7YnJlYWs7Y2FzZSAnbHcnOlxuICAgICAgICAgIGNvLmxpbmVXaWR0aCA9IHBhcnNlRmxvYXQocFtpICsgMV0pO2krKzticmVhaztjYXNlICdlJzpcbiAgICAgICAgICBjby5lbGxpcHNlKHBhcnNlRmxvYXQocFtpICsgMV0pLCBwYXJzZUZsb2F0KHBbaSArIDJdKSwgcGFyc2VGbG9hdChwW2kgKyAzXSksIHBhcnNlRmxvYXQocFtpICsgNF0pLCBwYXJzZUZsb2F0KHBbaSArIDVdKSwgcGFyc2VGbG9hdChwW2kgKyA2XSksIHBhcnNlRmxvYXQocFtpICsgN10pLCBwW2kgKyA4XSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlKTtpICs9IDg7YnJlYWs7Y2FzZSAnbGonOlxuICAgICAgICAgIGNvLmxpbmVKb2luID0gcFtpICsgMV07aSsrO2JyZWFrO2Nhc2UgJ2xjJzpcbiAgICAgICAgICBjby5saW5lQ2FwID0gcFtpICsgMV07aSsrO2JyZWFrO2Nhc2UgJ3NjJzpcbiAgICAgICAgICBjby5zaGFkb3dDb2xvciA9IHBbaSArIDFdO2krKzticmVhaztjYXNlICdzYic6XG4gICAgICAgICAgY28uc2hhZG93Qmx1ciA9IHBhcnNlRmxvYXQocFtpICsgMV0pO2krKzticmVhaztjYXNlICdzeCc6XG4gICAgICAgICAgY28uc2hhZG93T2Zmc2V0WCA9IHBhcnNlRmxvYXQocFtpICsgMV0pO2krKzticmVhaztjYXNlICdzeSc6XG4gICAgICAgICAgY28uc2hhZG93T2Zmc2V0WSA9IHBhcnNlRmxvYXQocFtpICsgMV0pO2krKzticmVhaztjYXNlICdmcyc6XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gcFtpICsgMV07aSsrO2JyZWFrO2Nhc2UgJ3NzJzpcbiAgICAgICAgICBjby5zdHJva2VTdHlsZSA9IHBbaSArIDFdO2krKzticmVhaztjYXNlICdmcic6XG4gICAgICAgICAgY28uZmlsbFJlY3QocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pLCBwYXJzZUZsb2F0KHBbaSArIDNdKSwgcGFyc2VGbG9hdChwW2kgKyA0XSkpO2kgKz0gNDticmVhaztjYXNlICdzcic6XG4gICAgICAgICAgY28uc3Ryb2tlUmVjdChwYXJzZUZsb2F0KHBbaSArIDFdKSwgcGFyc2VGbG9hdChwW2kgKyAyXSksIHBhcnNlRmxvYXQocFtpICsgM10pLCBwYXJzZUZsb2F0KHBbaSArIDRdKSk7aSArPSA0O2JyZWFrO2Nhc2UgJ2NsJzpcbiAgICAgICAgICBjby5jbGlwKCk7YnJlYWs7Y2FzZSAnc2EnOlxuICAgICAgICAgIGNvLnNhdmUoKTticmVhaztjYXNlICdycyc6XG4gICAgICAgICAgY28ucmVzdG9yZSgpO2JyZWFrO2Nhc2UgJ3RyJzpcbiAgICAgICAgICBjby50cmFuc2xhdGUocGFyc2VGbG9hdChwW2kgKyAxXSksIHBhcnNlRmxvYXQocFtpICsgMl0pKTtpICs9IDI7YnJlYWs7Y2FzZSAnc2wnOlxuICAgICAgICAgIGNvLnNjYWxlKHBhcnNlRmxvYXQocFtpICsgMV0pLCBwYXJzZUZsb2F0KHBbaSArIDJdKSk7aSArPSAyO2JyZWFrO2Nhc2UgJ3JvJzpcbiAgICAgICAgICBjby5yb3RhdGUocGFyc2VGbG9hdChwW2kgKyAxXSkpO2krKzticmVhaztjYXNlICd0Zic6XG4gICAgICAgICAgY28udHJhbnNmb3JtKHBhcnNlRmxvYXQocFtpICsgMV0pLCBwYXJzZUZsb2F0KHBbaSArIDJdKSwgcGFyc2VGbG9hdChwW2kgKyAzXSksIHBhcnNlRmxvYXQocFtpICsgNF0pLCBwYXJzZUZsb2F0KHBbaSArIDVdKSwgcGFyc2VGbG9hdChwW2kgKyA2XSkpO2kgKz0gNjticmVhaztjYXNlICdzdGYnOlxuICAgICAgICAgIGNvLnNldFRyYW5zZm9ybShwYXJzZUZsb2F0KHBbaSArIDFdKSwgcGFyc2VGbG9hdChwW2kgKyAyXSksIHBhcnNlRmxvYXQocFtpICsgM10pLCBwYXJzZUZsb2F0KHBbaSArIDRdKSwgcGFyc2VGbG9hdChwW2kgKyA1XSksIHBhcnNlRmxvYXQocFtpICsgNl0pKTtpICs9IDY7YnJlYWs7Y2FzZSAnY3InOlxuICAgICAgICAgIGNvLmNsZWFyUmVjdChwYXJzZUZsb2F0KHBbaSArIDFdKSwgcGFyc2VGbG9hdChwW2kgKyAyXSksIHBhcnNlRmxvYXQocFtpICsgM10pLCBwYXJzZUZsb2F0KHBbaSArIDRdKSk7aSArPSA0O2JyZWFrO2Nhc2UgJ2xkJzpcbiAgICAgICAgICB2YXIgcGFydHMgPSBwW2kgKyAxXTtjby5zZXRMaW5lRGFzaChwYXJ0cyk7aSArPSAxO2JyZWFrO2Nhc2UgJ2xkbyc6XG4gICAgICAgICAgY28ubGluZURhc2hPZmZzZXQgPSBwW2kgKyAxXTtpKys7YnJlYWs7Y2FzZSAnZm8nOlxuICAgICAgICAgIGNvLmZvbnQgPSBwW2kgKyAxXTtpKys7YnJlYWs7Y2FzZSAnZnQnOlxuICAgICAgICAgIGNvLmZpbGxUZXh0KHBbaSArIDFdLCBwYXJzZUZsb2F0KHBbaSArIDJdKSwgcGFyc2VGbG9hdChwW2kgKyAzXSkpO2kgKz0gMzticmVhaztjYXNlICdzdCc6XG4gICAgICAgICAgY28uc3Ryb2tlVGV4dChwW2kgKyAxXSwgcGFyc2VGbG9hdChwW2kgKyAyXSksIHBhcnNlRmxvYXQocFtpICsgM10pKTtpICs9IDM7YnJlYWs7Y2FzZSAndGEnOlxuICAgICAgICAgIGNvLnRleHRBbGlnbiA9IHBbaSArIDFdO2krKzticmVhaztjYXNlICd0YmwnOlxuICAgICAgICAgIGNvLnRleHRCYXNlbGluZSA9IHBbaSArIDFdO2krKzticmVhaztjYXNlICdnYSc6XG4gICAgICAgICAgY28uZ2xvYmFsQWxwaGEgPSBwYXJzZUZsb2F0KHBbaSArIDFdKTtpKys7YnJlYWs7Y2FzZSAnZ2NvJzpcbiAgICAgICAgICBjby5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBwW2kgKyAxXTtpKys7YnJlYWs7Y2FzZSAnZnUnOlxuICAgICAgICAgIHBbaSArIDFdKGNvLmNhbnZhcy5fX29iamVjdF9fKTtpKys7YnJlYWs7Y2FzZSAnJzpcbiAgICAgICAgICBicmVhaztkZWZhdWx0OlxuICAgICAgICAgIGFsZXJ0KCdbRVJST1JdIFVua25vd24gb3B0aW9uOiAnICsgcFtpXSk7fVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdHN0cmluZyhwKSB7XG4gICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgYnVmZmVyID0gJycsXG4gICAgICAgICAgaW5xdW90ZSA9IGZhbHNlLFxuICAgICAgICAgIHF1b3RlID0gJycsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uSW5kZXggPSAyO2ZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hyID0gcFtpXSxcbiAgICAgICAgICAgIGlzV1MgPSBjaHIubWF0Y2goLyAvKTtpZiAoaXNXUykge1xuICAgICAgICAgIGlmICghaW5xdW90ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclswXSA9PT0gJ1wiJyB8fCBidWZmZXJbMF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIoMSwgYnVmZmVyLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkgPT09ICclJyAmJiB0eXBlb2YgYXJnc1tzdWJzdGl0dXRpb25JbmRleF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGFyZ3Nbc3Vic3RpdHV0aW9uSW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIpO2J1ZmZlciA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hyID09PSBcIidcIiB8fCBjaHIgPT09ICdcIicpIHtcbiAgICAgICAgICAgIGlucXVvdGUgPSAhaW5xdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyICs9IGNocjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlci50cmltKCkgPT09ICclJyAmJiBhcmdzW3N1YnN0aXR1dGlvbkluZGV4XSkge1xuICAgICAgICBidWZmZXIgPSBhcmdzW3N1YnN0aXR1dGlvbkluZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0LnB1c2goYnVmZmVyKTtyZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtSRy53cmFwID0gZnVuY3Rpb24gKCkge307XG59KSh3aW5kb3csIGRvY3VtZW50KTt3aW5kb3cuJHAgPSBmdW5jdGlvbiAodikge1xuICBSR3JhcGgucHIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1szXSk7XG59O3dpbmRvdy4kYSA9IGZ1bmN0aW9uICh2KSB7XG4gIGFsZXJ0KHYpO1xufTt3aW5kb3cuJGNsID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIGNvbnNvbGUubG9nKHYpO1xufTtpZiAoIVN0cmluZy5wcm90b3R5cGUuZm9ybWF0KSB7XG4gIFN0cmluZy5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO3JldHVybiB0aGlzLnJlcGxhY2UoL3soXFxkKyl9L2csIGZ1bmN0aW9uIChzdHIsIGlkeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhcmdzW2lkeCAtIDFdICE9PSAndW5kZWZpbmVkJyA/IGFyZ3NbaWR4IC0gMV0gOiBzdHI7XG4gICAgfSk7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///166\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.uid = RGraph.createUID();this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uY3N2LmpzPzI4Y2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguQ1NWID0gZnVuY3Rpb24gKHVybCwgZnVuYykge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGg7dGhpcy51cmwgPSB1cmw7dGhpcy5yZWFkeSA9IGZ1bmM7dGhpcy5kYXRhID0gbnVsbDt0aGlzLm51bXJvd3MgPSBudWxsO3RoaXMubnVtY29scyA9IG51bGw7dGhpcy5zZXBlcmF0b3IgPSBhcmd1bWVudHNbMl0gfHwgJywnO3RoaXMuZW5kb2ZsaW5lID0gYXJndW1lbnRzWzNdIHx8IC9cXHI/XFxuLzt0aGlzLnVpZCA9IFJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLnNwbGl0Q1NWID0gZnVuY3Rpb24gKHN0ciwgc3BsaXQpIHtcbiAgICB2YXIgYXJyID0gW107dmFyIGZpZWxkID0gJyc7dmFyIGluRG91YmxlUXVvdGVzID0gZmFsc2U7dmFyIGluU2luZ2xlUXVvdGVzID0gZmFsc2U7dmFyIHByZXNlcnZlID0gKHR5cGVvZiBzcGxpdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3BsaXQpKSA9PT0gJ29iamVjdCcgJiYgc3BsaXQucHJlc2VydmUgPyB0cnVlIDogZmFsc2U7aWYgKCh0eXBlb2Ygc3BsaXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHNwbGl0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodHlwZW9mIHNwbGl0LmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNwbGl0ID0gc3BsaXQuY2hhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0ID0gJywnO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjaGFyID0gc3RyLmNoYXJBdChpKTtpZiAoY2hhciA9PT0gJ1wiJyAmJiAhaW5Eb3VibGVRdW90ZXMpIHtcbiAgICAgICAgaW5Eb3VibGVRdW90ZXMgPSB0cnVlO2NvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXCInICYmIGluRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIGluRG91YmxlUXVvdGVzID0gZmFsc2U7Y29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gXCInXCIgJiYgIWluU2luZ2xlUXVvdGVzKSB7XG4gICAgICAgIGluU2luZ2xlUXVvdGVzID0gdHJ1ZTtjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCInXCIgJiYgaW5TaW5nbGVRdW90ZXMpIHtcbiAgICAgICAgaW5TaW5nbGVRdW90ZXMgPSBmYWxzZTtjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gc3BsaXQgJiYgIWluRG91YmxlUXVvdGVzICYmICFpblNpbmdsZVF1b3Rlcykge1xuICAgICAgICBhcnIucHVzaChmaWVsZCk7ZmllbGQgPSAnJztjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkID0gZmllbGQgKyBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICBhcnIucHVzaChmaWVsZCk7aWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpXS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07dGhpcy5mZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VwID0gdGhpcy5zZXBlcmF0b3IsXG4gICAgICAgIGVvbCA9IHRoaXMuZW5kb2ZsaW5lLFxuICAgICAgICBvYmogPSB0aGlzO2lmICh0aGlzLnVybC5zdWJzdHJpbmcoMCwgMykgPT09ICdpZDonIHx8IHRoaXMudXJsLnN1YnN0cmluZygwLCA0KSA9PT0gJ3N0cjonKSB7XG4gICAgICBpZiAodGhpcy51cmwuc3Vic3RyaW5nKDAsIDMpID09PSAnaWQ6Jykge1xuICAgICAgICB2YXIgZGF0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudXJsLnN1YnN0cmluZygzKSkuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51cmwuc3Vic3RyaW5nKDAsIDQpID09PSAnc3RyOicpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnVybC5zdWJzdHJpbmcoNCkudHJpbSgpO1xuICAgICAgfVxuICAgICAgb2JqLmRhdGEgPSBkYXRhLnNwbGl0KGVvbCk7b2JqLm51bXJvd3MgPSBvYmouZGF0YS5sZW5ndGg7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHZhciByb3cgPSBvYmouc3BsaXRDU1Yob2JqLmRhdGFbaV0sIHsgcHJlc2VydmU6IGZhbHNlLCBjaGFyOiBzZXAgfSk7aWYgKCFvYmoubnVtY29scykge1xuICAgICAgICAgIG9iai5udW1jb2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGlmICgvXlxcLT9bMC05Ll0rJC8udGVzdChyb3dbal0pKSB7XG4gICAgICAgICAgICByb3dbal0gPSBwYXJzZUZsb2F0KHJvd1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5kYXRhW2ldID0gcm93O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmoucmVhZHkob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkdyYXBoLkFKQVguZ2V0U3RyaW5nKHRoaXMudXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8oXFxyP1xcbikrJC8sICcnKTtvYmouZGF0YSA9IGRhdGEuc3BsaXQoZW9sKTtvYmoubnVtcm93cyA9IG9iai5kYXRhLmxlbmd0aDtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgcm93ID0gb2JqLnNwbGl0Q1NWKG9iai5kYXRhW2ldLCB7IHByZXNlcnZlOiBmYWxzZSwgY2hhcjogc2VwIH0pO2lmICghb2JqLm51bWNvbHMpIHtcbiAgICAgICAgICAgIG9iai5udW1jb2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgvXlxcLT9bMC05Ll0rJC8udGVzdChyb3dbal0pKSB7XG4gICAgICAgICAgICAgIHJvd1tqXSA9IHBhcnNlRmxvYXQocm93W2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5kYXRhW2ldID0gcm93O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmoucmVhZHkob2JqKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTt0aGlzLmdldFJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByb3cgPSBbXTt2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV0gfHwgMDtmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCB0aGlzLm51bWNvbHM7IGkgKz0gMSkge1xuICAgICAgcm93LnB1c2godGhpcy5kYXRhW2luZGV4XVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByb3c7XG4gIH07dGhpcy5nZXRDb2wgPSB0aGlzLmdldENvbHVtbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBjb2wgPSBbXTt2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV0gfHwgMDtmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCB0aGlzLm51bXJvd3M7IGkgKz0gMSkge1xuICAgICAgY29sLnB1c2godGhpcy5kYXRhW2ldW2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiBjb2w7XG4gIH07dGhpcy5mZXRjaCgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmNzdi5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///167\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.text = RG.Text = function (context, font, size, x, y, text) {\n    var args = arguments;if (typeof text != 'string' && typeof text != 'number' || text == 'undefined') {\n      return;\n    }\n    if (typeof text == 'string' && text.match(/\\r\\n/)) {\n      var dimensions = RGraph.MeasureText('M', args[11], font, size);var arr = text.split('\\r\\n');if (args[6] && args[6] == 'center') y = y - dimensions[1] * ((arr.length - 1) / 2);for (var i = 1; i < arr.length; ++i) {\n        RGraph.Text(context, font, size, args[9] == -90 ? x + size * 1.5 : x, y + dimensions[1] * i, arr[i], args[6] ? args[6] : null, args[7], args[8], args[9], args[10], args[11], args[12]);\n      }\n      text = arr[0];\n    }\n    if (document.all && RGraph.ISOLD) {\n      y += 2;\n    }\n    context.font = (args[11] ? 'Bold ' : '') + size + 'pt ' + font;var i;var origX = x;var origY = y;var originalFillStyle = context.fillStyle;var originalLineWidth = context.lineWidth;if (typeof args[6] == 'undefined') args[6] = 'bottom';if (typeof args[7] == 'undefined') args[7] = 'left';if (typeof args[8] == 'undefined') args[8] = null;if (typeof args[9] == 'undefined') args[9] = 0;if (navigator.userAgent.indexOf('Opera') != -1) {\n      context.canvas.__rgraph_valign__ = args[6];context.canvas.__rgraph_halign__ = args[7];\n    }\n    context.save();context.canvas.__rgraph_originalx__ = x;context.canvas.__rgraph_originaly__ = y;context.translate(x, y);x = 0;y = 0;if (args[9]) {\n      context.rotate(args[9] / (180 / RGraph.PI));\n    }\n    if (args[6]) {\n      var vAlign = args[6];if (vAlign == 'center') {\n        context.textBaseline = 'middle';\n      } else if (vAlign == 'top') {\n        context.textBaseline = 'top';\n      }\n    }\n    if (args[7]) {\n      var hAlign = args[7];var width = context.measureText(text).width;if (hAlign) {\n        if (hAlign == 'center') {\n          context.textAlign = 'center';\n        } else if (hAlign == 'right') {\n          context.textAlign = 'right';\n        }\n      }\n    }\n    context.fillStyle = originalFillStyle;context.save();context.fillText(text, 0, 0);context.lineWidth = 1;var width = context.measureText(text).width;var width_offset = hAlign == 'center' ? width / 2 : hAlign == 'right' ? width : 0;var height = size * 1.5;var height_offset = vAlign == 'center' ? height / 2 : vAlign == 'top' ? height : 0;var ieOffset = RGraph.ISOLD ? 2 : 0;if (args[8]) {\n      context.strokeRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);if (args[10]) {\n        context.fillStyle = args[10];context.fillRect(-3 - width_offset, 0 - 3 - height - ieOffset + height_offset, width + 6, height + 6);\n      }\n      context.fillStyle = originalFillStyle;context.fillText(text, 0, 0);\n    }\n    context.restore();context.lineWidth = originalLineWidth;context.restore();\n  };RG.getMouseXY = function (e) {\n    var el = RGraph.ISOLD ? event.srcElement : e.target;var x;var y;var paddingLeft = el.style.paddingLeft ? parseInt(el.style.paddingLeft) : 0;var paddingTop = el.style.paddingTop ? parseInt(el.style.paddingTop) : 0;var borderLeft = el.style.borderLeftWidth ? parseInt(el.style.borderLeftWidth) : 0;var borderTop = el.style.borderTopWidth ? parseInt(el.style.borderTopWidth) : 0;if (RGraph.ISIE8) e = event;if (typeof e.offsetX == 'number' && typeof e.offsetY == 'number') {\n      x = e.offsetX;y = e.offsetY;\n    } else {\n      x = 0;y = 0;while (el != document.body && el) {\n        x += el.offsetLeft;y += el.offsetTop;el = el.offsetParent;\n      }\n      x = e.pageX - x;y = e.pageY - y;\n    }\n    return [x, y];\n  };RG.oldBrowserCompat = RG.OldBrowserCompat = function (co) {\n    if (!co) {\n      return;\n    }\n    if (!co.measureText) {\n      co.measureText = function (text) {\n        var textObj = document.createElement('DIV');textObj.innerHTML = text;textObj.style.position = 'absolute';textObj.style.top = '-100px';textObj.style.left = 0;document.body.appendChild(textObj);var width = { width: textObj.offsetWidth };textObj.style.display = 'none';return width;\n      };\n    }\n    if (!co.fillText) {\n      co.fillText = function (text, targetX, targetY) {\n        return false;\n      };\n    }\n    if (!co.canvas.addEventListener) {\n      window.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n      co.canvas.addEventListener = function (ev, func, bubble) {\n        return this.attachEvent('on' + ev, func);\n      };\n    }\n  };RG.each = function (arr, func) {\n    for (var i = 0, len = arr.length; i < len; i += 1) {\n      if (typeof arguments[2] !== 'undefined') {\n        var ret = func.call(arguments[2], i, arr[i]);\n      } else {\n        var ret = func.call(arr, i, arr[i]);\n      }\n      if (ret === false) {\n        return;\n      }\n    }\n  };RG.getHeight = RG.GetHeight = function (obj) {\n    return obj.canvas.height;\n  };RG.getWidth = RG.GetWidth = function (obj) {\n    return obj.canvas.width;\n  };RG.timer = RG.Timer = function (label) {\n    if (typeof RG.TIMER_LAST_CHECKPOINT == 'undefined') {\n      RG.TIMER_LAST_CHECKPOINT = Date.now();\n    }\n    var now = Date.now();console.log(label + ': ' + (now - RG.TIMER_LAST_CHECKPOINT).toString());RG.TIMER_LAST_CHECKPOINT = now;\n  };RG.setConfig = RG.SetConfig = function (obj, config) {\n    for (i in config) {\n      if (typeof i === 'string') {\n        obj.Set(i, config[i]);\n      }\n    }\n    return obj;\n  };\n})(window, document);window.$empty = function (value) {\n  if (!value || value.length <= 0) {\n    return true;\n  }\n  return false;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZGVwcmVjYXRlZC5qcz9lY2UyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy50ZXh0ID0gUkcuVGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBmb250LCBzaXplLCB4LCB5LCB0ZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7aWYgKHR5cGVvZiB0ZXh0ICE9ICdzdHJpbmcnICYmIHR5cGVvZiB0ZXh0ICE9ICdudW1iZXInIHx8IHRleHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09ICdzdHJpbmcnICYmIHRleHQubWF0Y2goL1xcclxcbi8pKSB7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IFJHcmFwaC5NZWFzdXJlVGV4dCgnTScsIGFyZ3NbMTFdLCBmb250LCBzaXplKTt2YXIgYXJyID0gdGV4dC5zcGxpdCgnXFxyXFxuJyk7aWYgKGFyZ3NbNl0gJiYgYXJnc1s2XSA9PSAnY2VudGVyJykgeSA9IHkgLSBkaW1lbnNpb25zWzFdICogKChhcnIubGVuZ3RoIC0gMSkgLyAyKTtmb3IgKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICBSR3JhcGguVGV4dChjb250ZXh0LCBmb250LCBzaXplLCBhcmdzWzldID09IC05MCA/IHggKyBzaXplICogMS41IDogeCwgeSArIGRpbWVuc2lvbnNbMV0gKiBpLCBhcnJbaV0sIGFyZ3NbNl0gPyBhcmdzWzZdIDogbnVsbCwgYXJnc1s3XSwgYXJnc1s4XSwgYXJnc1s5XSwgYXJnc1sxMF0sIGFyZ3NbMTFdLCBhcmdzWzEyXSk7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gYXJyWzBdO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuYWxsICYmIFJHcmFwaC5JU09MRCkge1xuICAgICAgeSArPSAyO1xuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSAoYXJnc1sxMV0gPyAnQm9sZCAnIDogJycpICsgc2l6ZSArICdwdCAnICsgZm9udDt2YXIgaTt2YXIgb3JpZ1ggPSB4O3ZhciBvcmlnWSA9IHk7dmFyIG9yaWdpbmFsRmlsbFN0eWxlID0gY29udGV4dC5maWxsU3R5bGU7dmFyIG9yaWdpbmFsTGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7aWYgKHR5cGVvZiBhcmdzWzZdID09ICd1bmRlZmluZWQnKSBhcmdzWzZdID0gJ2JvdHRvbSc7aWYgKHR5cGVvZiBhcmdzWzddID09ICd1bmRlZmluZWQnKSBhcmdzWzddID0gJ2xlZnQnO2lmICh0eXBlb2YgYXJnc1s4XSA9PSAndW5kZWZpbmVkJykgYXJnc1s4XSA9IG51bGw7aWYgKHR5cGVvZiBhcmdzWzldID09ICd1bmRlZmluZWQnKSBhcmdzWzldID0gMDtpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPcGVyYScpICE9IC0xKSB7XG4gICAgICBjb250ZXh0LmNhbnZhcy5fX3JncmFwaF92YWxpZ25fXyA9IGFyZ3NbNl07Y29udGV4dC5jYW52YXMuX19yZ3JhcGhfaGFsaWduX18gPSBhcmdzWzddO1xuICAgIH1cbiAgICBjb250ZXh0LnNhdmUoKTtjb250ZXh0LmNhbnZhcy5fX3JncmFwaF9vcmlnaW5hbHhfXyA9IHg7Y29udGV4dC5jYW52YXMuX19yZ3JhcGhfb3JpZ2luYWx5X18gPSB5O2NvbnRleHQudHJhbnNsYXRlKHgsIHkpO3ggPSAwO3kgPSAwO2lmIChhcmdzWzldKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZShhcmdzWzldIC8gKDE4MCAvIFJHcmFwaC5QSSkpO1xuICAgIH1cbiAgICBpZiAoYXJnc1s2XSkge1xuICAgICAgdmFyIHZBbGlnbiA9IGFyZ3NbNl07aWYgKHZBbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfSBlbHNlIGlmICh2QWxpZ24gPT0gJ3RvcCcpIHtcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3NbN10pIHtcbiAgICAgIHZhciBoQWxpZ24gPSBhcmdzWzddO3ZhciB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7aWYgKGhBbGlnbikge1xuICAgICAgICBpZiAoaEFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmIChoQWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbFN0eWxlO2NvbnRleHQuc2F2ZSgpO2NvbnRleHQuZmlsbFRleHQodGV4dCwgMCwgMCk7Y29udGV4dC5saW5lV2lkdGggPSAxO3ZhciB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7dmFyIHdpZHRoX29mZnNldCA9IGhBbGlnbiA9PSAnY2VudGVyJyA/IHdpZHRoIC8gMiA6IGhBbGlnbiA9PSAncmlnaHQnID8gd2lkdGggOiAwO3ZhciBoZWlnaHQgPSBzaXplICogMS41O3ZhciBoZWlnaHRfb2Zmc2V0ID0gdkFsaWduID09ICdjZW50ZXInID8gaGVpZ2h0IC8gMiA6IHZBbGlnbiA9PSAndG9wJyA/IGhlaWdodCA6IDA7dmFyIGllT2Zmc2V0ID0gUkdyYXBoLklTT0xEID8gMiA6IDA7aWYgKGFyZ3NbOF0pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgtMyAtIHdpZHRoX29mZnNldCwgMCAtIDMgLSBoZWlnaHQgLSBpZU9mZnNldCArIGhlaWdodF9vZmZzZXQsIHdpZHRoICsgNiwgaGVpZ2h0ICsgNik7aWYgKGFyZ3NbMTBdKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXJnc1sxMF07Y29udGV4dC5maWxsUmVjdCgtMyAtIHdpZHRoX29mZnNldCwgMCAtIDMgLSBoZWlnaHQgLSBpZU9mZnNldCArIGhlaWdodF9vZmZzZXQsIHdpZHRoICsgNiwgaGVpZ2h0ICsgNik7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbFN0eWxlO2NvbnRleHQuZmlsbFRleHQodGV4dCwgMCwgMCk7XG4gICAgfVxuICAgIGNvbnRleHQucmVzdG9yZSgpO2NvbnRleHQubGluZVdpZHRoID0gb3JpZ2luYWxMaW5lV2lkdGg7Y29udGV4dC5yZXN0b3JlKCk7XG4gIH07UkcuZ2V0TW91c2VYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGVsID0gUkdyYXBoLklTT0xEID8gZXZlbnQuc3JjRWxlbWVudCA6IGUudGFyZ2V0O3ZhciB4O3ZhciB5O3ZhciBwYWRkaW5nTGVmdCA9IGVsLnN0eWxlLnBhZGRpbmdMZWZ0ID8gcGFyc2VJbnQoZWwuc3R5bGUucGFkZGluZ0xlZnQpIDogMDt2YXIgcGFkZGluZ1RvcCA9IGVsLnN0eWxlLnBhZGRpbmdUb3AgPyBwYXJzZUludChlbC5zdHlsZS5wYWRkaW5nVG9wKSA6IDA7dmFyIGJvcmRlckxlZnQgPSBlbC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPyBwYXJzZUludChlbC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIDogMDt2YXIgYm9yZGVyVG9wID0gZWwuc3R5bGUuYm9yZGVyVG9wV2lkdGggPyBwYXJzZUludChlbC5zdHlsZS5ib3JkZXJUb3BXaWR0aCkgOiAwO2lmIChSR3JhcGguSVNJRTgpIGUgPSBldmVudDtpZiAodHlwZW9mIGUub2Zmc2V0WCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZS5vZmZzZXRZID09ICdudW1iZXInKSB7XG4gICAgICB4ID0gZS5vZmZzZXRYO3kgPSBlLm9mZnNldFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAwO3kgPSAwO3doaWxlIChlbCAhPSBkb2N1bWVudC5ib2R5ICYmIGVsKSB7XG4gICAgICAgIHggKz0gZWwub2Zmc2V0TGVmdDt5ICs9IGVsLm9mZnNldFRvcDtlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHggPSBlLnBhZ2VYIC0geDt5ID0gZS5wYWdlWSAtIHk7XG4gICAgfVxuICAgIHJldHVybiBbeCwgeV07XG4gIH07Ukcub2xkQnJvd3NlckNvbXBhdCA9IFJHLk9sZEJyb3dzZXJDb21wYXQgPSBmdW5jdGlvbiAoY28pIHtcbiAgICBpZiAoIWNvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY28ubWVhc3VyZVRleHQpIHtcbiAgICAgIGNvLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHRleHRPYmogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTt0ZXh0T2JqLmlubmVySFRNTCA9IHRleHQ7dGV4dE9iai5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7dGV4dE9iai5zdHlsZS50b3AgPSAnLTEwMHB4Jzt0ZXh0T2JqLnN0eWxlLmxlZnQgPSAwO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dE9iaik7dmFyIHdpZHRoID0geyB3aWR0aDogdGV4dE9iai5vZmZzZXRXaWR0aCB9O3RleHRPYmouc3R5bGUuZGlzcGxheSA9ICdub25lJztyZXR1cm4gd2lkdGg7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWNvLmZpbGxUZXh0KSB7XG4gICAgICBjby5maWxsVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB0YXJnZXRYLCB0YXJnZXRZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghY28uY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmdW5jLCBidWJibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoRXZlbnQoJ29uJyArIGV2LCBmdW5jKTtcbiAgICAgIH07XG4gICAgICBjby5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZnVuYywgYnViYmxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaEV2ZW50KCdvbicgKyBldiwgZnVuYyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtSRy5lYWNoID0gZnVuY3Rpb24gKGFyciwgZnVuYykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgcmV0ID0gZnVuYy5jYWxsKGFyZ3VtZW50c1syXSwgaSwgYXJyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXQgPSBmdW5jLmNhbGwoYXJyLCBpLCBhcnJbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5nZXRIZWlnaHQgPSBSRy5HZXRIZWlnaHQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5jYW52YXMuaGVpZ2h0O1xuICB9O1JHLmdldFdpZHRoID0gUkcuR2V0V2lkdGggPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5jYW52YXMud2lkdGg7XG4gIH07UkcudGltZXIgPSBSRy5UaW1lciA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmICh0eXBlb2YgUkcuVElNRVJfTEFTVF9DSEVDS1BPSU5UID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBSRy5USU1FUl9MQVNUX0NIRUNLUE9JTlQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtjb25zb2xlLmxvZyhsYWJlbCArICc6ICcgKyAobm93IC0gUkcuVElNRVJfTEFTVF9DSEVDS1BPSU5UKS50b1N0cmluZygpKTtSRy5USU1FUl9MQVNUX0NIRUNLUE9JTlQgPSBub3c7XG4gIH07Ukcuc2V0Q29uZmlnID0gUkcuU2V0Q29uZmlnID0gZnVuY3Rpb24gKG9iaiwgY29uZmlnKSB7XG4gICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmouU2V0KGksIGNvbmZpZ1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTt3aW5kb3cuJGVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZGVwcmVjYXRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///168\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.installWindowMousedownListener = RG.InstallWindowMousedownListener = function (obj) {\n    if (!RG.window_mousedown_event_listener) {\n      RG.window_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {\n          RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);RG.redraw();RG.hideTooltip();\n        }\n      };win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);\n    }\n  };RG.installWindowMouseupListener = RG.InstallWindowMouseupListener = function (obj) {\n    if (!RG.window_mouseup_event_listener) {\n      RG.window_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;e = RG.fixEventObject(e);if (RG.annotating_window_onmouseup) {\n          RG.annotating_window_onmouseup(e);return;\n        }\n        if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {\n          var obj = RG.Registry.Get('chart.adjusting');if (obj && obj.type === 'line') {\n            obj.data_arr = RG.arrayLinearize(obj.data);\n          }\n          RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');\n        }\n        RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);var tags = document.getElementsByTagName('canvas');for (var i = 0; i < tags.length; ++i) {\n          if (tags[i].__object__ && tags[i].__object__.isRGraph) {\n            if (!tags[i].__object__.get('chart.annotatable')) {\n              if (!tags[i].__rgraph_trace_cover__ && !noredraw) {\n                RG.clear(tags[i]);\n              } else {\n                var noredraw = true;\n              }\n            }\n          }\n        }\n        if (!noredraw) {\n          RG.redraw();\n        }\n      };win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMouseupListener = RG.InstallCanvasMouseupListener = function (obj) {\n    if (!obj.canvas.rgraph_mouseup_event_listener) {\n      obj.canvas.rgraph_mouseup_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);if (objects) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i],\n                id = objects[i].id;var link = obj.Get('link');if (obj.type == 'drawing.text' && typeof link === 'string') {\n              var link_target = obj.get('link.target');var link_options = obj.get('link.options');window.open(link, link_target ? link_target : null, link_options);\n            }\n            if (!RG.isNull(obj) && RG.tooltip) {\n              var shape = obj.getShape(e);if (shape && shape['tooltip']) {\n                var text = shape['tooltip'];if (text) {\n                  var type = shape['object'].type;RG.clear(obj.canvas);RG.redraw();RG.Registry.set('chart.tooltip.shape', shape);RG.tooltip(obj, text, 0, 0, shape['index'], e);obj.highlight(shape);if (RG.Registry.get('chart.tooltip')) {\n                    RG.Registry.get('chart.tooltip').__shape__ = shape;RG.evaluateCursor(e);\n                  }\n                  e.cancelBubble = true;e.stopPropagation();return false;\n                }\n              }\n            }\n            if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {\n              if (obj && obj.type === 'line') {\n                obj.data_arr = RG.arrayLinearize(obj.data);\n              }\n              RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');\n            }\n            RG.Registry.set('chart.adjusting', null);RG.Registry.set('chart.adjusting.shape', null);RG.Registry.set('chart.adjusting.gantt', null);if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n        }\n      };obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);\n    }\n  };RG.installCanvasMousemoveListener = RG.InstallCanvasMousemoveListener = function (obj) {\n    if (!obj.canvas.rgraph_mousemove_event_listener) {\n      obj.canvas.rgraph_mousemove_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.OR.getObjectsByXY(e);var uids = [];if (objects && objects.length > 0) {\n          for (var i = 0, len = objects.length; i < len; i += 1) {\n            var obj = objects[i];var id = obj.id;uids[obj.uid] = true;if (!obj.getShape) {\n              continue;\n            }\n            var shape = obj.getShape(e);if (!shape && typeof obj.__mouseover_shape_index__ === 'number' || shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__) {\n              RG.fireCustomEvent(obj, 'onmouseout');\n            }\n            if (obj.coords && obj.coords.key && obj.coords.key.length) {\n              var mouseXY = RG.getMouseXY(e);for (var i = 0, overkey = false; i < obj.coords.key.length; ++i) {\n                if (mouseXY[0] >= obj.coords.key[i][0] && mouseXY[0] <= obj.coords.key[i][0] + obj.coords.key[i][2] && mouseXY[1] >= obj.coords.key[i][1] && mouseXY[1] <= obj.coords.key[i][1] + obj.coords.key[i][3]) {\n                  RG.Registry.set('key-element', obj.coords.key[i]);overkey = true;\n                }\n                if (!overkey) {\n                  RG.Registry.set('key-element', null);\n                }\n              }\n            }\n            var func = obj.get('chart.events.mousemove');if (!func && typeof obj.onmousemove == 'function') {\n              var func = obj.onmousemove;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmousemove == 'function') {\n                var func2 = obj['$' + index].onmousemove;\n              }\n            }\n            if (shape && (typeof func == 'function' || typeof func2 == 'function' || typeof obj.Get('link') === 'string')) {\n              if (obj.Get('chart.events.mousemove.revertto') == null) {\n                obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);\n              }\n              if (typeof func == 'function') RGraph.custom_events_mousemove_pointer = func(e, shape);if (typeof func2 == 'function') RGraph.custom_events_mousemove_pointer = RGraph.custom_events_mousemove_pointer || func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                for (i in RG.events[obj.uid]) {\n                  if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmousemove' && typeof RG.events[obj.uid][i][2] === 'function') {\n                    RG.events[obj.uid][i][2](obj);\n                  }\n                }\n              }\n            } else if (typeof obj.Get('chart.events.mousemove.revertto') == 'string') {\n              RG.cursor.push('default');obj.Set('chart.events.mousemove.revertto', null);\n            }\n            var func = obj.properties['chart.events.mouseover'];if (!func && typeof obj.onmouseover === 'function') {\n              func = obj.onmouseover;\n            }\n            if (shape) {\n              var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (_typeof(obj['$' + index]) == 'object' && typeof obj['$' + index].onmouseover == 'function') {\n                var func2 = obj['$' + index].onmouseover;\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            if (typeof RG.__mouseover_objects__ === 'undefined') {\n              RG.__mouseover_objects__ = [];\n            }\n            if (shape) {\n              if (obj.__mouseover_shape_index__ === shape.index === false) {\n                obj.__mouseover_shape_index__ = shape.index;RG.__mouseover_objects__.push(obj);if (func) func(e, shape);if (func2) func2(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n                  for (i in RG.events[obj.uid]) {\n                    if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onmouseover' && typeof RG.events[obj.uid][i][2] === 'function') {\n                      RG.events[obj.uid][i][2](obj);\n                    }\n                  }\n                }\n              }\n            } else {\n              obj.__mouseover_shape_index__ = null;RG.__mouseover_objects__ = [];\n            }\n            var current_tooltip = RG.Registry.get('chart.tooltip');var tooltips = obj.get('chart.tooltips');var tooltips_event = obj.Get('chart.tooltips.event');if (shape && (tooltips && tooltips[shape['index']] || shape['tooltip']) && tooltips_event.indexOf('mousemove') !== -1 && (RG.isNull(current_tooltip) || obj.uid != current_tooltip.__object__.uid || current_tooltip.__index__ != shape['index'] || typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])) {\n              RG.clear(obj.canvas);RG.hideTooltip();RG.redraw();obj.canvas.rgraph_mouseup_event_listener(e);return;\n            }\n            if (obj && obj.get('chart.adjustable')) {\n              obj.Adjusting_mousemove(e);\n            }\n            if (shape || obj.overChartArea && obj.overChartArea(e)) {\n              break;\n            }\n          }\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; ++i) {\n            if (!uids[objects[i].uid]) {\n              objects[i].__mouseover_shape_index__ = null;\n            }\n          }\n        } else {\n          var objects = RG.OR.getObjectsByCanvasID(e.target.id);for (var i = 0; i < objects.length; i++) {\n            if (typeof objects[i].__mouseover_shape_index__ === 'number') {\n              RG.fireCustomEvent(objects[i], 'onmouseout');\n            }\n            objects[i].__mouseover_shape_index__ = null;\n          }\n          RG.__mouseover_objects__ = [];\n        }\n        if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {\n          RG.drawCrosshairs(e, e.target.__object__);\n        }\n        if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {\n          RG.annotating_canvas_onmousemove(e);\n        }\n        RG.evaluateCursor(e);\n      };obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);\n    }\n  };RG.installCanvasMousedownListener = RG.InstallCanvasMousedownListener = function (obj) {\n    if (!obj.canvas.rgraph_mousedown_event_listener) {\n      obj.canvas.rgraph_mousedown_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {\n          RG.annotating_canvas_onmousedown(e);return;\n        }\n        var obj = RG.ObjectRegistry.getObjectByXY(e);if (obj) {\n          var id = obj.id;if (obj && obj.isRGraph && obj.get('chart.adjustable')) {\n            var obj = RG.OR.getObjectByXY(e);if (obj && obj.isRGraph) {\n              switch (obj.type) {case 'bar':\n                  var shape = obj.getShapeByX(e);break;case 'gantt':\n                  var shape = obj.getShape(e);var data = typeof shape.subindex === 'number' ? obj.data[shape.index][shape.subindex] : obj.data[shape.index];if (shape) {\n                    var mouseXY = RG.getMouseXY(e);RG.Registry.set('chart.adjusting.gantt', { index: shape.index, subindex: shape.subindex, object: obj, mousex: mouseXY[0], mousey: mouseXY[1], event: data, event_start: data[0], event_duration: data[1], mode: mouseXY[0] > shape['x'] + shape['width'] - 5 ? 'resize' : 'move', shape: shape });\n                  }\n                  break;case 'line':\n                  var shape = obj.getShape(e);break;case 'hbar':\n                  var shape = obj.getShapeByY(e);break;default:\n                  var shape = null;}\n              if (RG.isNull(obj.properties['chart.adjustable.only']) || typeof obj.properties['chart.adjustable.only'] === 'undefined' || RG.isArray(obj.properties['chart.adjustable.only']) && obj.isAdjustable && obj.isAdjustable(shape)) {\n                RG.Registry.set('chart.adjusting.shape', shape);RG.fireCustomEvent(obj, 'onadjustbegin');RG.Registry.set('chart.adjusting', obj);RG.clear(obj.canvas);RG.redraw();obj.canvas.rgraph_mousemove_event_listener(e);\n              }\n            }\n          }\n          RG.clear(obj.canvas);RG.redraw();\n        }\n      };obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);\n    }\n  };RG.installCanvasClickListener = RG.InstallCanvasClickListener = function (obj) {\n    if (!obj.canvas.rgraph_click_event_listener) {\n      obj.canvas.rgraph_click_event_listener = function (e) {\n        if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;e = RG.fixEventObject(e);var objects = RG.ObjectRegistry.getObjectsByXY(e);for (var i = 0, len = objects.length; i < len; i += 1) {\n          var obj = objects[i];var id = obj.id;var shape = obj.getShape(e);var func = obj.get('chart.events.click');if (!func && typeof obj.onclick == 'function') {\n            func = obj.onclick;\n          }\n          if (shape && typeof func == 'function') {\n            func(e, shape);if (_typeof(RG.events) === 'object' && _typeof(RG.events[obj.uid]) === 'object') {\n              for (i in RG.events[obj.uid]) {\n                if (typeof i === 'string' && _typeof(RG.events[obj.uid][i]) === 'object' && RG.events[obj.uid][i][1] === 'onclick' && typeof RG.events[obj.uid][i][2] === 'function') {\n                  RG.events[obj.uid][i][2](obj);\n                }\n              }\n            }\n            return;\n          }\n          var key = RG.Registry.get('key-element');if (key) {\n            RG.fireCustomEvent(obj, 'onkeyclick');\n          }\n          if (shape) {\n            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];if (typeof index == 'number' && obj['$' + index]) {\n              var func = obj['$' + index].onclick;if (typeof func == 'function') {\n                func(e, shape);return;\n              }\n            }\n          }\n          if (shape || obj.overChartArea && obj.overChartArea(e)) {\n            break;\n          }\n        }\n      };obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);\n    }\n  };RG.evaluateCursor = RG.EvaluateCursor = function (e) {\n    var obj = null;var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var canvas = e.target;var objects = RG.OR.getObjectsByCanvasID(canvas.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i].getShape && objects[i].getShape(e) || objects[i].overChartArea && objects[i].overChartArea(e)) {\n        var obj = objects[i];var id = obj.id;\n      }\n    }\n    if (!RG.isNull(obj)) {\n      if (obj.getShape && obj.getShape(e)) {\n        var shape = obj.getShape(e);if (obj.get('chart.tooltips')) {\n          var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {\n            text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);\n          }\n          if (text) {\n            var pointer = true;\n          }\n        }\n      }\n      if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {\n        for (var j = 0; j < obj.coords.key.length; ++j) {\n          if (mouseX > obj.coords.key[j][0] && mouseX < obj.coords.key[j][0] + obj.coords.key[j][2] && mouseY > obj.coords.key[j][1] && mouseY < obj.coords.key[j][1] + obj.coords.key[j][3]) {\n            var pointer = true;\n          }\n        }\n      }\n    }\n    if (RGraph.custom_events_mousemove_pointer) {\n      var pointer = true;RGraph.custom_events_mousemove_pointer = false;\n    }\n    var objects = RG.OR.objects.byCanvasID;for (var i = 0, len = objects.length; i < len; i += 1) {\n      if (objects[i] && objects[i][1].Get('chart.resizable')) {\n        var resizable = true;\n      }\n    }\n    if (resizable && mouseX > e.target.width - 32 && mouseY > e.target.height - 16) {\n      pointer = true;\n    }\n    if (pointer) {\n      e.target.style.cursor = 'pointer';\n    } else if (e.target.style.cursor == 'pointer') {\n      e.target.style.cursor = 'default';\n    } else {\n      e.target.style.cursor = null;\n    }\n    if (resizable && mouseX >= e.target.width - 15 && mouseY >= e.target.height - 15) {\n      e.target.style.cursor = 'move';\n    } else if (e.target.style.cursor === 'move') {\n      e.target.style.cursor = 'default';\n    }\n    if (typeof mouse_over_key == 'boolean' && mouse_over_key) {\n      e.target.style.cursor = 'pointer';\n    }\n    if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {\n      if (obj.getShape) {\n        var shape = obj.getShape(e);if (shape && obj.isAdjustable(shape)) {\n          e.target.style.cursor = 'ns-resize';\n        }\n      } else {\n        e.target.style.cursor = 'default';\n      }\n    }\n    if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {\n      e.target.style.cursor = 'crosshair';\n    }\n    if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {\n      e.target.style.cursor = 'pointer';\n    }\n  };RG.parseTooltipText = function (tooltips, idx) {\n    if (!tooltips) {\n      return null;\n    }\n    if (typeof tooltips == 'function') {\n      var text = tooltips(idx);\n    } else if (typeof tooltips == 'string') {\n      var text = tooltips;\n    } else if ((typeof tooltips === 'undefined' ? 'undefined' : _typeof(tooltips)) == 'object' && typeof tooltips[idx] == 'function') {\n      var text = tooltips[idx](idx);\n    } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {\n      var text = tooltips[idx];\n    } else {\n      var text = '';\n    }\n    if (text == 'undefined') {\n      text = '';\n    } else if (text == 'null') {\n      text = '';\n    }\n    return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;\n  };RG.drawCrosshairs = RG.DrawCrosshairs = function (e, obj) {\n    var e = RG.fixEventObject(e),\n        width = obj.canvas.width,\n        height = obj.canvas.height,\n        mouseXY = RG.getMouseXY(e),\n        x = mouseXY[0],\n        y = mouseXY[1],\n        gutterLeft = obj.gutterLeft,\n        gutterRight = obj.gutterRight,\n        gutterTop = obj.gutterTop,\n        gutterBottom = obj.gutterBottom,\n        Mathround = Math.round,\n        prop = obj.properties,\n        co = obj.context,\n        ca = obj.canvas;\n    RG.redrawCanvas(ca);if (x >= gutterLeft && y >= gutterTop && x <= width - gutterRight && y <= height - gutterBottom) {\n      var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;co.lineWidth = linewidth ? linewidth : 1;co.beginPath();co.strokeStyle = prop['chart.crosshairs.color'];if (prop['chart.crosshairs.snap']) {\n        var point = null;var dist = null;var len = null;if (obj.type == 'line') {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);if (typeof dist != 'number' || length < dist) {\n              var point = i;var dist = length;\n            }\n          }\n          x = obj.coords[point][0];y = obj.coords[point][1];for (var dataset = 0; dataset < obj.coords2.length; ++dataset) {\n            for (var point = 0; point < obj.coords2[dataset].length; ++point) {\n              if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {\n                ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;\n              }\n            }\n          }\n        } else {\n          for (var i = 0; i < obj.coords.length; ++i) {\n            for (var j = 0; j < obj.coords[i].length; ++j) {\n              var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);if (typeof dist != 'number' || len < dist) {\n                var dataset = i;var point = j;var dist = len;\n              }\n            }\n          }\n          ca.__crosshairs_snap_dataset__ = dataset;ca.__crosshairs_snap_point__ = point;x = obj.coords[dataset][point][0];y = obj.coords[dataset][point][1];\n        }\n      }\n      if (prop['chart.crosshairs.vline']) {\n        co.moveTo(Mathround(x), Mathround(gutterTop));co.lineTo(Mathround(x), Mathround(height - gutterBottom));\n      }\n      if (prop['chart.crosshairs.hline']) {\n        co.moveTo(Mathround(gutterLeft), Mathround(y));co.lineTo(Mathround(width - gutterRight), Mathround(y));\n      }\n      co.stroke();if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {\n        var xCoord = (x - gutterLeft) / (width - gutterLeft - gutterRight) * (prop['chart.xmax'] - prop['chart.xmin']) + prop['chart.xmin'];xCoord = xCoord.toFixed(prop['chart.scale.decimals']);var yCoord = obj.max - (y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom) * obj.max;if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {\n          yCoord = (yCoord - obj.max / 2) * 2;\n        }\n        yCoord = yCoord.toFixed(prop['chart.scale.decimals']);var div = RG.Registry.get('chart.coordinates.coords.div');var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(ca);if (!div) {\n          var div = document.createElement('DIV');div.__object__ = obj;div.style.position = 'absolute';div.style.backgroundColor = 'white';div.style.border = '1px solid black';div.style.fontFamily = 'Arial, Verdana, sans-serif';div.style.fontSize = '10pt';\n          div.style.padding = '2px';div.style.opacity = 1;div.style.WebkitBorderRadius = '3px';div.style.borderRadius = '3px';div.style.MozBorderRadius = '3px';document.body.appendChild(div);RG.Registry.set('chart.coordinates.coords.div', div);\n        }\n        div.style.opacity = 1;div.style.display = 'inline';if (!prop['chart.crosshairs.coords.fixed']) {\n          div.style.left = ma.max(2, e.pageX - div.offsetWidth - 3) + 'px';div.style.top = ma.max(2, e.pageY - div.offsetHeight - 3) + 'px';\n        } else {\n          div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';div.style.top = canvasXY[1] + gutterTop + 3 + 'px';\n        }\n        div.innerHTML = '<span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style=\"color: #666\">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);ca.__crosshairs_labels__ = div;ca.__crosshairs_x__ = xCoord;ca.__crosshairs_y__ = yCoord;\n      } else if (prop['chart.crosshairs.coords']) {\n        alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');\n      }\n      RG.fireCustomEvent(obj, 'oncrosshairs');\n    } else {\n      RG.hideCrosshairCoords();\n    }\n  };RG.allowSegmentHighlight = function (opt) {\n    var obj = opt.object,\n        count = opt.count,\n        fill = opt.fill,\n        stroke = opt.stroke;\n    if (!RG.segmentHighlightFunction) {\n      RG.segmentHighlightFunction = function (e) {\n        var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (angle > RG.TWOPI) {\n          angle -= RG.TWOPI;\n        }\n        RG.redraw();var start = 0;var end = 0;var a = ma.PI * 2 / count;var r = obj.radius;(function () {\n          for (i = 0; i < count; i += 1) {\n            if (angle < a * (i + 1)) {\n              start = i * a;end = (i + 1) * a;return;\n            }\n          }\n        })();start -= RG.HALFPI;end -= RG.HALFPI;RG.path2(obj.context, 'b m % % a % % % % % false c s % f %', obj.centerx, obj.centery, obj.centerx, obj.centery, r, start, end, stroke, fill);\n      };obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZHluYW1pYy5qcz9lYzdmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy5pbnN0YWxsV2luZG93TW91c2Vkb3duTGlzdGVuZXIgPSBSRy5JbnN0YWxsV2luZG93TW91c2Vkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFSRy53aW5kb3dfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyKSB7XG4gICAgICBSRy53aW5kb3dfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApIHdpbi5ldmVudCA9IGU7ZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO2lmIChSRy5IaWRlVG9vbHRpcCAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LnRvb2x0aXAnKSkge1xuICAgICAgICAgIFJHLmNsZWFyKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcCcpLl9fY2FudmFzX18pO1JHLnJlZHJhdygpO1JHLmhpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH07d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIFJHLndpbmRvd19tb3VzZWRvd25fZXZlbnRfbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH07UkcuaW5zdGFsbFdpbmRvd01vdXNldXBMaXN0ZW5lciA9IFJHLkluc3RhbGxXaW5kb3dNb3VzZXVwTGlzdGVuZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFSRy53aW5kb3dfbW91c2V1cF9ldmVudF9saXN0ZW5lcikge1xuICAgICAgUkcud2luZG93X21vdXNldXBfZXZlbnRfbGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPj0gMCkgd2luLmV2ZW50ID0gZTtlID0gUkcuZml4RXZlbnRPYmplY3QoZSk7aWYgKFJHLmFubm90YXRpbmdfd2luZG93X29ubW91c2V1cCkge1xuICAgICAgICAgIFJHLmFubm90YXRpbmdfd2luZG93X29ubW91c2V1cChlKTtyZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykgfHwgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKSkge1xuICAgICAgICAgIHZhciBvYmogPSBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpO2lmIChvYmogJiYgb2JqLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgb2JqLmRhdGFfYXJyID0gUkcuYXJyYXlMaW5lYXJpemUob2JqLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSRy5maXJlQ3VzdG9tRXZlbnQoUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSwgJ29uYWRqdXN0ZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgUkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcnLCBudWxsKTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LmFkanVzdGluZy5zaGFwZScsIG51bGwpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLmdhbnR0JywgbnVsbCk7dmFyIHRhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7Zm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHRhZ3NbaV0uX19vYmplY3RfXyAmJiB0YWdzW2ldLl9fb2JqZWN0X18uaXNSR3JhcGgpIHtcbiAgICAgICAgICAgIGlmICghdGFnc1tpXS5fX29iamVjdF9fLmdldCgnY2hhcnQuYW5ub3RhdGFibGUnKSkge1xuICAgICAgICAgICAgICBpZiAoIXRhZ3NbaV0uX19yZ3JhcGhfdHJhY2VfY292ZXJfXyAmJiAhbm9yZWRyYXcpIHtcbiAgICAgICAgICAgICAgICBSRy5jbGVhcih0YWdzW2ldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9yZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9yZWRyYXcpIHtcbiAgICAgICAgICBSRy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfTt3aW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIFJHLndpbmRvd19tb3VzZXVwX2V2ZW50X2xpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9O1JHLmluc3RhbGxDYW52YXNNb3VzZXVwTGlzdGVuZXIgPSBSRy5JbnN0YWxsQ2FudmFzTW91c2V1cExpc3RlbmVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2V1cF9ldmVudF9saXN0ZW5lcikge1xuICAgICAgb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2V1cF9ldmVudF9saXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwKSB3aW5kb3cuZXZlbnQgPSBlO2UgPSBSRy5maXhFdmVudE9iamVjdChlKTt2YXIgb2JqZWN0cyA9IFJHLk9iamVjdFJlZ2lzdHJ5LmdldE9iamVjdHNCeVhZKGUpO2lmIChvYmplY3RzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldLFxuICAgICAgICAgICAgICAgIGlkID0gb2JqZWN0c1tpXS5pZDt2YXIgbGluayA9IG9iai5HZXQoJ2xpbmsnKTtpZiAob2JqLnR5cGUgPT0gJ2RyYXdpbmcudGV4dCcgJiYgdHlwZW9mIGxpbmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5rX3RhcmdldCA9IG9iai5nZXQoJ2xpbmsudGFyZ2V0Jyk7dmFyIGxpbmtfb3B0aW9ucyA9IG9iai5nZXQoJ2xpbmsub3B0aW9ucycpO3dpbmRvdy5vcGVuKGxpbmssIGxpbmtfdGFyZ2V0ID8gbGlua190YXJnZXQgOiBudWxsLCBsaW5rX29wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSRy5pc051bGwob2JqKSAmJiBSRy50b29sdGlwKSB7XG4gICAgICAgICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZShlKTtpZiAoc2hhcGUgJiYgc2hhcGVbJ3Rvb2x0aXAnXSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2hhcGVbJ3Rvb2x0aXAnXTtpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzaGFwZVsnb2JqZWN0J10udHlwZTtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXcoKTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LnRvb2x0aXAuc2hhcGUnLCBzaGFwZSk7UkcudG9vbHRpcChvYmosIHRleHQsIDAsIDAsIHNoYXBlWydpbmRleCddLCBlKTtvYmouaGlnaGxpZ2h0KHNoYXBlKTtpZiAoUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJykuX19zaGFwZV9fID0gc2hhcGU7UkcuZXZhbHVhdGVDdXJzb3IoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7ZS5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKSB8fCBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpKSB7XG4gICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIG9iai5kYXRhX2FyciA9IFJHLmFycmF5TGluZWFyaXplKG9iai5kYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSRy5maXJlQ3VzdG9tRXZlbnQoUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKSwgJ29uYWRqdXN0ZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LmFkanVzdGluZycsIG51bGwpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJywgbnVsbCk7UkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnLCBudWxsKTtpZiAoc2hhcGUgfHwgb2JqLm92ZXJDaGFydEFyZWEgJiYgb2JqLm92ZXJDaGFydEFyZWEoZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9iai5jYW52YXMucmdyYXBoX21vdXNldXBfZXZlbnRfbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH07UkcuaW5zdGFsbENhbnZhc01vdXNlbW92ZUxpc3RlbmVyID0gUkcuSW5zdGFsbENhbnZhc01vdXNlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2Vtb3ZlX2V2ZW50X2xpc3RlbmVyKSB7XG4gICAgICBvYmouY2FudmFzLnJncmFwaF9tb3VzZW1vdmVfZXZlbnRfbGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPj0gMCkgd2luZG93LmV2ZW50ID0gZTtlID0gUkcuZml4RXZlbnRPYmplY3QoZSk7dmFyIG9iamVjdHMgPSBSRy5PUi5nZXRPYmplY3RzQnlYWShlKTt2YXIgdWlkcyA9IFtdO2lmIChvYmplY3RzICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTt2YXIgaWQgPSBvYmouaWQ7dWlkc1tvYmoudWlkXSA9IHRydWU7aWYgKCFvYmouZ2V0U2hhcGUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBvYmouZ2V0U2hhcGUoZSk7aWYgKCFzaGFwZSAmJiB0eXBlb2Ygb2JqLl9fbW91c2VvdmVyX3NoYXBlX2luZGV4X18gPT09ICdudW1iZXInIHx8IHNoYXBlICYmIHR5cGVvZiBvYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXyA9PT0gJ251bWJlcicgJiYgc2hhcGUuaW5kZXggIT09IG9iai5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fKSB7XG4gICAgICAgICAgICAgIFJHLmZpcmVDdXN0b21FdmVudChvYmosICdvbm1vdXNlb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLmNvb3JkcyAmJiBvYmouY29vcmRzLmtleSAmJiBvYmouY29vcmRzLmtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO2ZvciAodmFyIGkgPSAwLCBvdmVya2V5ID0gZmFsc2U7IGkgPCBvYmouY29vcmRzLmtleS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVhZWzBdID49IG9iai5jb29yZHMua2V5W2ldWzBdICYmIG1vdXNlWFlbMF0gPD0gb2JqLmNvb3Jkcy5rZXlbaV1bMF0gKyBvYmouY29vcmRzLmtleVtpXVsyXSAmJiBtb3VzZVhZWzFdID49IG9iai5jb29yZHMua2V5W2ldWzFdICYmIG1vdXNlWFlbMV0gPD0gb2JqLmNvb3Jkcy5rZXlbaV1bMV0gKyBvYmouY29vcmRzLmtleVtpXVszXSkge1xuICAgICAgICAgICAgICAgICAgUkcuUmVnaXN0cnkuc2V0KCdrZXktZWxlbWVudCcsIG9iai5jb29yZHMua2V5W2ldKTtvdmVya2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvdmVya2V5KSB7XG4gICAgICAgICAgICAgICAgICBSRy5SZWdpc3RyeS5zZXQoJ2tleS1lbGVtZW50JywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnVuYyA9IG9iai5nZXQoJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnKTtpZiAoIWZ1bmMgJiYgdHlwZW9mIG9iai5vbm1vdXNlbW92ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBmdW5jID0gb2JqLm9ubW91c2Vtb3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHNoYXBlWydvYmplY3QnXS50eXBlID09ICdzY2F0dGVyJyA/IHNoYXBlWydpbmRleF9hZGp1c3RlZCddIDogc2hhcGVbJ2luZGV4J107aWYgKF90eXBlb2Yob2JqWyckJyArIGluZGV4XSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9ialsnJCcgKyBpbmRleF0ub25tb3VzZW1vdmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBmdW5jMiA9IG9ialsnJCcgKyBpbmRleF0ub25tb3VzZW1vdmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiAodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuYzIgPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLkdldCgnbGluaycpID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgaWYgKG9iai5HZXQoJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUucmV2ZXJ0dG8nKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2JqLlNldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZS5yZXZlcnR0bycsIGUudGFyZ2V0LnN0eWxlLmN1cnNvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicpIFJHcmFwaC5jdXN0b21fZXZlbnRzX21vdXNlbW92ZV9wb2ludGVyID0gZnVuYyhlLCBzaGFwZSk7aWYgKHR5cGVvZiBmdW5jMiA9PSAnZnVuY3Rpb24nKSBSR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlciA9IFJHcmFwaC5jdXN0b21fZXZlbnRzX21vdXNlbW92ZV9wb2ludGVyIHx8IGZ1bmMyKGUsIHNoYXBlKTtpZiAoX3R5cGVvZihSRy5ldmVudHMpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKFJHLmV2ZW50c1tvYmoudWlkXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIFJHLmV2ZW50c1tvYmoudWlkXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJyAmJiBfdHlwZW9mKFJHLmV2ZW50c1tvYmoudWlkXVtpXSkgPT09ICdvYmplY3QnICYmIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsxXSA9PT0gJ29ubW91c2Vtb3ZlJyAmJiB0eXBlb2YgUkcuZXZlbnRzW29iai51aWRdW2ldWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXShvYmopO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqLkdldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZS5yZXZlcnR0bycpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIFJHLmN1cnNvci5wdXNoKCdkZWZhdWx0Jyk7b2JqLlNldCgnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZS5yZXZlcnR0bycsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBvYmoucHJvcGVydGllc1snY2hhcnQuZXZlbnRzLm1vdXNlb3ZlciddO2lmICghZnVuYyAmJiB0eXBlb2Ygb2JqLm9ubW91c2VvdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBvYmoub25tb3VzZW92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc2hhcGVbJ29iamVjdCddLnR5cGUgPT0gJ3NjYXR0ZXInID8gc2hhcGVbJ2luZGV4X2FkanVzdGVkJ10gOiBzaGFwZVsnaW5kZXgnXTtpZiAoX3R5cGVvZihvYmpbJyQnICsgaW5kZXhdKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqWyckJyArIGluZGV4XS5vbm1vdXNlb3ZlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMyID0gb2JqWyckJyArIGluZGV4XS5vbm1vdXNlb3ZlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqLl9fbW91c2VvdmVyX3NoYXBlX2luZGV4X18gPSBudWxsO1JHLl9fbW91c2VvdmVyX29iamVjdHNfXyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSRy5fX21vdXNlb3Zlcl9vYmplY3RzX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIFJHLl9fbW91c2VvdmVyX29iamVjdHNfXyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgIGlmIChvYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXyA9PT0gc2hhcGUuaW5kZXggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9fbW91c2VvdmVyX3NoYXBlX2luZGV4X18gPSBzaGFwZS5pbmRleDtSRy5fX21vdXNlb3Zlcl9vYmplY3RzX18ucHVzaChvYmopO2lmIChmdW5jKSBmdW5jKGUsIHNoYXBlKTtpZiAoZnVuYzIpIGZ1bmMyKGUsIHNoYXBlKTtpZiAoX3R5cGVvZihSRy5ldmVudHMpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKFJHLmV2ZW50c1tvYmoudWlkXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gUkcuZXZlbnRzW29iai51aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycgJiYgX3R5cGVvZihSRy5ldmVudHNbb2JqLnVpZF1baV0pID09PSAnb2JqZWN0JyAmJiBSRy5ldmVudHNbb2JqLnVpZF1baV1bMV0gPT09ICdvbm1vdXNlb3ZlcicgJiYgdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXShvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmouX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXyA9IG51bGw7UkcuX19tb3VzZW92ZXJfb2JqZWN0c19fID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudF90b29sdGlwID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC50b29sdGlwJyk7dmFyIHRvb2x0aXBzID0gb2JqLmdldCgnY2hhcnQudG9vbHRpcHMnKTt2YXIgdG9vbHRpcHNfZXZlbnQgPSBvYmouR2V0KCdjaGFydC50b29sdGlwcy5ldmVudCcpO2lmIChzaGFwZSAmJiAodG9vbHRpcHMgJiYgdG9vbHRpcHNbc2hhcGVbJ2luZGV4J11dIHx8IHNoYXBlWyd0b29sdGlwJ10pICYmIHRvb2x0aXBzX2V2ZW50LmluZGV4T2YoJ21vdXNlbW92ZScpICE9PSAtMSAmJiAoUkcuaXNOdWxsKGN1cnJlbnRfdG9vbHRpcCkgfHwgb2JqLnVpZCAhPSBjdXJyZW50X3Rvb2x0aXAuX19vYmplY3RfXy51aWQgfHwgY3VycmVudF90b29sdGlwLl9faW5kZXhfXyAhPSBzaGFwZVsnaW5kZXgnXSB8fCB0eXBlb2Ygc2hhcGVbJ2RhdGFzZXQnXSA9PT0gJ251bWJlcicgJiYgc2hhcGVbJ2RhdGFzZXQnXSAhPSBjdXJyZW50X3Rvb2x0aXAuX19zaGFwZV9fWydkYXRhc2V0J10pKSB7XG4gICAgICAgICAgICAgIFJHLmNsZWFyKG9iai5jYW52YXMpO1JHLmhpZGVUb29sdGlwKCk7UkcucmVkcmF3KCk7b2JqLmNhbnZhcy5yZ3JhcGhfbW91c2V1cF9ldmVudF9saXN0ZW5lcihlKTtyZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5nZXQoJ2NoYXJ0LmFkanVzdGFibGUnKSkge1xuICAgICAgICAgICAgICBvYmouQWRqdXN0aW5nX21vdXNlbW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZSB8fCBvYmoub3ZlckNoYXJ0QXJlYSAmJiBvYmoub3ZlckNoYXJ0QXJlYShlKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9iamVjdHMgPSBSRy5PUi5nZXRPYmplY3RzQnlDYW52YXNJRChlLnRhcmdldC5pZCk7Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXVpZHNbb2JqZWN0c1tpXS51aWRdKSB7XG4gICAgICAgICAgICAgIG9iamVjdHNbaV0uX19tb3VzZW92ZXJfc2hhcGVfaW5kZXhfXyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvYmplY3RzID0gUkcuT1IuZ2V0T2JqZWN0c0J5Q2FudmFzSUQoZS50YXJnZXQuaWQpO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RzW2ldLl9fbW91c2VvdmVyX3NoYXBlX2luZGV4X18gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIFJHLmZpcmVDdXN0b21FdmVudChvYmplY3RzW2ldLCAnb25tb3VzZW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0c1tpXS5fX21vdXNlb3Zlcl9zaGFwZV9pbmRleF9fID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUkcuX19tb3VzZW92ZXJfb2JqZWN0c19fID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0Ll9fb2JqZWN0X18gJiYgZS50YXJnZXQuX19vYmplY3RfXy5nZXQoJ2NoYXJ0LmNyb3NzaGFpcnMnKSkge1xuICAgICAgICAgIFJHLmRyYXdDcm9zc2hhaXJzKGUsIGUudGFyZ2V0Ll9fb2JqZWN0X18pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldC5fX29iamVjdF9fICYmIGUudGFyZ2V0Ll9fb2JqZWN0X18uZ2V0KCdjaGFydC5hbm5vdGF0YWJsZScpICYmIFJHLmFubm90YXRpbmdfY2FudmFzX29ubW91c2Vtb3ZlKSB7XG4gICAgICAgICAgUkcuYW5ub3RhdGluZ19jYW52YXNfb25tb3VzZW1vdmUoZSk7XG4gICAgICAgIH1cbiAgICAgICAgUkcuZXZhbHVhdGVDdXJzb3IoZSk7XG4gICAgICB9O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2Vtb3ZlX2V2ZW50X2xpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9O1JHLmluc3RhbGxDYW52YXNNb3VzZWRvd25MaXN0ZW5lciA9IFJHLkluc3RhbGxDYW52YXNNb3VzZWRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5jYW52YXMucmdyYXBoX21vdXNlZG93bl9ldmVudF9saXN0ZW5lcikge1xuICAgICAgb2JqLmNhbnZhcy5yZ3JhcGhfbW91c2Vkb3duX2V2ZW50X2xpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApIHdpbmRvdy5ldmVudCA9IGU7ZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO2lmIChlLnRhcmdldC5fX29iamVjdF9fICYmIGUudGFyZ2V0Ll9fb2JqZWN0X18uZ2V0KCdjaGFydC5hbm5vdGF0YWJsZScpICYmIFJHLmFubm90YXRpbmdfY2FudmFzX29ubW91c2Vkb3duKSB7XG4gICAgICAgICAgUkcuYW5ub3RhdGluZ19jYW52YXNfb25tb3VzZWRvd24oZSk7cmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmogPSBSRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RCeVhZKGUpO2lmIChvYmopIHtcbiAgICAgICAgICB2YXIgaWQgPSBvYmouaWQ7aWYgKG9iaiAmJiBvYmouaXNSR3JhcGggJiYgb2JqLmdldCgnY2hhcnQuYWRqdXN0YWJsZScpKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gUkcuT1IuZ2V0T2JqZWN0QnlYWShlKTtpZiAob2JqICYmIG9iai5pc1JHcmFwaCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7Y2FzZSAnYmFyJzpcbiAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZUJ5WChlKTticmVhaztjYXNlICdnYW50dCc6XG4gICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBvYmouZ2V0U2hhcGUoZSk7dmFyIGRhdGEgPSB0eXBlb2Ygc2hhcGUuc3ViaW5kZXggPT09ICdudW1iZXInID8gb2JqLmRhdGFbc2hhcGUuaW5kZXhdW3NoYXBlLnN1YmluZGV4XSA6IG9iai5kYXRhW3NoYXBlLmluZGV4XTtpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO1JHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLmdhbnR0JywgeyBpbmRleDogc2hhcGUuaW5kZXgsIHN1YmluZGV4OiBzaGFwZS5zdWJpbmRleCwgb2JqZWN0OiBvYmosIG1vdXNleDogbW91c2VYWVswXSwgbW91c2V5OiBtb3VzZVhZWzFdLCBldmVudDogZGF0YSwgZXZlbnRfc3RhcnQ6IGRhdGFbMF0sIGV2ZW50X2R1cmF0aW9uOiBkYXRhWzFdLCBtb2RlOiBtb3VzZVhZWzBdID4gc2hhcGVbJ3gnXSArIHNoYXBlWyd3aWR0aCddIC0gNSA/ICdyZXNpemUnIDogJ21vdmUnLCBzaGFwZTogc2hhcGUgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztjYXNlICdsaW5lJzpcbiAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZShlKTticmVhaztjYXNlICdoYmFyJzpcbiAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZUJ5WShlKTticmVhaztkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDt9XG4gICAgICAgICAgICAgIGlmIChSRy5pc051bGwob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSB8fCB0eXBlb2Ygb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmFkanVzdGFibGUub25seSddID09PSAndW5kZWZpbmVkJyB8fCBSRy5pc0FycmF5KG9iai5wcm9wZXJ0aWVzWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkgJiYgb2JqLmlzQWRqdXN0YWJsZSAmJiBvYmouaXNBZGp1c3RhYmxlKHNoYXBlKSkge1xuICAgICAgICAgICAgICAgIFJHLlJlZ2lzdHJ5LnNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJywgc2hhcGUpO1JHLmZpcmVDdXN0b21FdmVudChvYmosICdvbmFkanVzdGJlZ2luJyk7UkcuUmVnaXN0cnkuc2V0KCdjaGFydC5hZGp1c3RpbmcnLCBvYmopO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhdygpO29iai5jYW52YXMucmdyYXBoX21vdXNlbW92ZV9ldmVudF9saXN0ZW5lcihlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfTtvYmouY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9iai5jYW52YXMucmdyYXBoX21vdXNlZG93bl9ldmVudF9saXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfTtSRy5pbnN0YWxsQ2FudmFzQ2xpY2tMaXN0ZW5lciA9IFJHLkluc3RhbGxDYW52YXNDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLmNhbnZhcy5yZ3JhcGhfY2xpY2tfZXZlbnRfbGlzdGVuZXIpIHtcbiAgICAgIG9iai5jYW52YXMucmdyYXBoX2NsaWNrX2V2ZW50X2xpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApIHdpbmRvdy5ldmVudCA9IGU7ZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO3ZhciBvYmplY3RzID0gUkcuT2JqZWN0UmVnaXN0cnkuZ2V0T2JqZWN0c0J5WFkoZSk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTt2YXIgaWQgPSBvYmouaWQ7dmFyIHNoYXBlID0gb2JqLmdldFNoYXBlKGUpO3ZhciBmdW5jID0gb2JqLmdldCgnY2hhcnQuZXZlbnRzLmNsaWNrJyk7aWYgKCFmdW5jICYmIHR5cGVvZiBvYmoub25jbGljayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmdW5jID0gb2JqLm9uY2xpY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaGFwZSAmJiB0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmdW5jKGUsIHNoYXBlKTtpZiAoX3R5cGVvZihSRy5ldmVudHMpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKFJHLmV2ZW50c1tvYmoudWlkXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGZvciAoaSBpbiBSRy5ldmVudHNbb2JqLnVpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnICYmIF90eXBlb2YoUkcuZXZlbnRzW29iai51aWRdW2ldKSA9PT0gJ29iamVjdCcgJiYgUkcuZXZlbnRzW29iai51aWRdW2ldWzFdID09PSAnb25jbGljaycgJiYgdHlwZW9mIFJHLmV2ZW50c1tvYmoudWlkXVtpXVsyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgUkcuZXZlbnRzW29iai51aWRdW2ldWzJdKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXkgPSBSRy5SZWdpc3RyeS5nZXQoJ2tleS1lbGVtZW50Jyk7aWYgKGtleSkge1xuICAgICAgICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwgJ29ua2V5Y2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzaGFwZVsnb2JqZWN0J10udHlwZSA9PSAnc2NhdHRlcicgPyBzaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXSA6IHNoYXBlWydpbmRleCddO2lmICh0eXBlb2YgaW5kZXggPT0gJ251bWJlcicgJiYgb2JqWyckJyArIGluZGV4XSkge1xuICAgICAgICAgICAgICB2YXIgZnVuYyA9IG9ialsnJCcgKyBpbmRleF0ub25jbGljaztpZiAodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZ1bmMoZSwgc2hhcGUpO3JldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hhcGUgfHwgb2JqLm92ZXJDaGFydEFyZWEgJiYgb2JqLm92ZXJDaGFydEFyZWEoZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtvYmouY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb2JqLmNhbnZhcy5yZ3JhcGhfY2xpY2tfZXZlbnRfbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH07UkcuZXZhbHVhdGVDdXJzb3IgPSBSRy5FdmFsdWF0ZUN1cnNvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9iaiA9IG51bGw7dmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO3ZhciBjYW52YXMgPSBlLnRhcmdldDt2YXIgb2JqZWN0cyA9IFJHLk9SLmdldE9iamVjdHNCeUNhbnZhc0lEKGNhbnZhcy5pZCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChvYmplY3RzW2ldLmdldFNoYXBlICYmIG9iamVjdHNbaV0uZ2V0U2hhcGUoZSkgfHwgb2JqZWN0c1tpXS5vdmVyQ2hhcnRBcmVhICYmIG9iamVjdHNbaV0ub3ZlckNoYXJ0QXJlYShlKSkge1xuICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTt2YXIgaWQgPSBvYmouaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghUkcuaXNOdWxsKG9iaikpIHtcbiAgICAgIGlmIChvYmouZ2V0U2hhcGUgJiYgb2JqLmdldFNoYXBlKGUpKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZShlKTtpZiAob2JqLmdldCgnY2hhcnQudG9vbHRpcHMnKSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gUkcucGFyc2VUb29sdGlwVGV4dChvYmouZ2V0KCdjaGFydC50b29sdGlwcycpLCBzaGFwZVsnaW5kZXgnXSk7aWYgKCF0ZXh0ICYmIHNoYXBlWydvYmplY3QnXS50eXBlID09ICdzY2F0dGVyJyAmJiBzaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXSkge1xuICAgICAgICAgICAgdGV4dCA9IFJHLnBhcnNlVG9vbHRpcFRleHQob2JqLmdldCgnY2hhcnQudG9vbHRpcHMnKSwgc2hhcGVbJ2luZGV4X2FkanVzdGVkJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFSRy5pc051bGwob2JqKSAmJiBvYmouR2V0KCdjaGFydC5rZXkuaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5jb29yZHMua2V5Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKG1vdXNlWCA+IG9iai5jb29yZHMua2V5W2pdWzBdICYmIG1vdXNlWCA8IG9iai5jb29yZHMua2V5W2pdWzBdICsgb2JqLmNvb3Jkcy5rZXlbal1bMl0gJiYgbW91c2VZID4gb2JqLmNvb3Jkcy5rZXlbal1bMV0gJiYgbW91c2VZIDwgb2JqLmNvb3Jkcy5rZXlbal1bMV0gKyBvYmouY29vcmRzLmtleVtqXVszXSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUkdyYXBoLmN1c3RvbV9ldmVudHNfbW91c2Vtb3ZlX3BvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdHJ1ZTtSR3JhcGguY3VzdG9tX2V2ZW50c19tb3VzZW1vdmVfcG9pbnRlciA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgb2JqZWN0cyA9IFJHLk9SLm9iamVjdHMuYnlDYW52YXNJRDtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXVsxXS5HZXQoJ2NoYXJ0LnJlc2l6YWJsZScpKSB7XG4gICAgICAgIHZhciByZXNpemFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzaXphYmxlICYmIG1vdXNlWCA+IGUudGFyZ2V0LndpZHRoIC0gMzIgJiYgbW91c2VZID4gZS50YXJnZXQuaGVpZ2h0IC0gMTYpIHtcbiAgICAgIHBvaW50ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocG9pbnRlcikge1xuICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH0gZWxzZSBpZiAoZS50YXJnZXQuc3R5bGUuY3Vyc29yID09ICdwb2ludGVyJykge1xuICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzaXphYmxlICYmIG1vdXNlWCA+PSBlLnRhcmdldC53aWR0aCAtIDE1ICYmIG1vdXNlWSA+PSBlLnRhcmdldC5oZWlnaHQgLSAxNSkge1xuICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoZS50YXJnZXQuc3R5bGUuY3Vyc29yID09PSAnbW92ZScpIHtcbiAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtb3VzZV9vdmVyX2tleSA9PSAnYm9vbGVhbicgJiYgbW91c2Vfb3Zlcl9rZXkpIHtcbiAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmoudHlwZSA9PSAnbGluZScgJiYgb2JqLmdldCgnY2hhcnQuYWRqdXN0YWJsZScpKSB7XG4gICAgICBpZiAob2JqLmdldFNoYXBlKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IG9iai5nZXRTaGFwZShlKTtpZiAoc2hhcGUgJiYgb2JqLmlzQWRqdXN0YWJsZShzaGFwZSkpIHtcbiAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZS50YXJnZXQuX19vYmplY3RfXyAmJiBlLnRhcmdldC5fX29iamVjdF9fLmdldCgnY2hhcnQuYW5ub3RhdGFibGUnKSkge1xuICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgfVxuICAgIGlmIChvYmogJiYgb2JqLnR5cGUgPT09ICdkcmF3aW5nLnRleHQnICYmIHNoYXBlICYmIHR5cGVvZiBvYmouZ2V0KCdsaW5rJykgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICB9O1JHLnBhcnNlVG9vbHRpcFRleHQgPSBmdW5jdGlvbiAodG9vbHRpcHMsIGlkeCkge1xuICAgIGlmICghdG9vbHRpcHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRvb2x0aXBzID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0ZXh0ID0gdG9vbHRpcHMoaWR4KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0b29sdGlwcyA9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHRleHQgPSB0b29sdGlwcztcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgdG9vbHRpcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRvb2x0aXBzKSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRvb2x0aXBzW2lkeF0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRleHQgPSB0b29sdGlwc1tpZHhdKGlkeCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdG9vbHRpcHNbaWR4XSA9PSAnc3RyaW5nJyAmJiB0b29sdGlwc1tpZHhdKSB7XG4gICAgICB2YXIgdGV4dCA9IHRvb2x0aXBzW2lkeF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgfVxuICAgIGlmICh0ZXh0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXh0ID0gJyc7XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09ICdudWxsJykge1xuICAgICAgdGV4dCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gUkcuZ2V0VG9vbHRpcFRleHRGcm9tRElWID8gUkcuZ2V0VG9vbHRpcFRleHRGcm9tRElWKHRleHQpIDogdGV4dDtcbiAgfTtSRy5kcmF3Q3Jvc3NoYWlycyA9IFJHLkRyYXdDcm9zc2hhaXJzID0gZnVuY3Rpb24gKGUsIG9iaikge1xuICAgIHZhciBlID0gUkcuZml4RXZlbnRPYmplY3QoZSksXG4gICAgICAgIHdpZHRoID0gb2JqLmNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gb2JqLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICB4ID0gbW91c2VYWVswXSxcbiAgICAgICAgeSA9IG1vdXNlWFlbMV0sXG4gICAgICAgIGd1dHRlckxlZnQgPSBvYmouZ3V0dGVyTGVmdCxcbiAgICAgICAgZ3V0dGVyUmlnaHQgPSBvYmouZ3V0dGVyUmlnaHQsXG4gICAgICAgIGd1dHRlclRvcCA9IG9iai5ndXR0ZXJUb3AsXG4gICAgICAgIGd1dHRlckJvdHRvbSA9IG9iai5ndXR0ZXJCb3R0b20sXG4gICAgICAgIE1hdGhyb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcyxcbiAgICAgICAgY28gPSBvYmouY29udGV4dCxcbiAgICAgICAgY2EgPSBvYmouY2FudmFzO1xuICAgIFJHLnJlZHJhd0NhbnZhcyhjYSk7aWYgKHggPj0gZ3V0dGVyTGVmdCAmJiB5ID49IGd1dHRlclRvcCAmJiB4IDw9IHdpZHRoIC0gZ3V0dGVyUmlnaHQgJiYgeSA8PSBoZWlnaHQgLSBndXR0ZXJCb3R0b20pIHtcbiAgICAgIHZhciBsaW5ld2lkdGggPSBwcm9wWydjaGFydC5jcm9zc2hhaXJzLmxpbmV3aWR0aCddID8gcHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5saW5ld2lkdGgnXSA6IDE7Y28ubGluZVdpZHRoID0gbGluZXdpZHRoID8gbGluZXdpZHRoIDogMTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXTtpZiAocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5zbmFwJ10pIHtcbiAgICAgICAgdmFyIHBvaW50ID0gbnVsbDt2YXIgZGlzdCA9IG51bGw7dmFyIGxlbiA9IG51bGw7aWYgKG9iai50eXBlID09ICdsaW5lJykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IFJHLmdldEh5cExlbmd0aChvYmouY29vcmRzW2ldWzBdLCBvYmouY29vcmRzW2ldWzFdLCB4LCB5KTtpZiAodHlwZW9mIGRpc3QgIT0gJ251bWJlcicgfHwgbGVuZ3RoIDwgZGlzdCkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBpO3ZhciBkaXN0ID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB4ID0gb2JqLmNvb3Jkc1twb2ludF1bMF07eSA9IG9iai5jb29yZHNbcG9pbnRdWzFdO2ZvciAodmFyIGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgb2JqLmNvb3JkczIubGVuZ3RoOyArK2RhdGFzZXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHBvaW50ID0gMDsgcG9pbnQgPCBvYmouY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7ICsrcG9pbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG9iai5jb29yZHMyW2RhdGFzZXRdW3BvaW50XVswXSA9PSB4ICYmIG9iai5jb29yZHMyW2RhdGFzZXRdW3BvaW50XVsxXSA9PSB5KSB7XG4gICAgICAgICAgICAgICAgY2EuX19jcm9zc2hhaXJzX3NuYXBfZGF0YXNldF9fID0gZGF0YXNldDtjYS5fX2Nyb3NzaGFpcnNfc25hcF9wb2ludF9fID0gcG9pbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouY29vcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5jb29yZHNbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IFJHLmdldEh5cExlbmd0aChvYmouY29vcmRzW2ldW2pdWzBdLCBvYmouY29vcmRzW2ldW2pdWzFdLCB4LCB5KTtpZiAodHlwZW9mIGRpc3QgIT0gJ251bWJlcicgfHwgbGVuIDwgZGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhc2V0ID0gaTt2YXIgcG9pbnQgPSBqO3ZhciBkaXN0ID0gbGVuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhLl9fY3Jvc3NoYWlyc19zbmFwX2RhdGFzZXRfXyA9IGRhdGFzZXQ7Y2EuX19jcm9zc2hhaXJzX3NuYXBfcG9pbnRfXyA9IHBvaW50O3ggPSBvYmouY29vcmRzW2RhdGFzZXRdW3BvaW50XVswXTt5ID0gb2JqLmNvb3Jkc1tkYXRhc2V0XVtwb2ludF1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5jcm9zc2hhaXJzLnZsaW5lJ10pIHtcbiAgICAgICAgY28ubW92ZVRvKE1hdGhyb3VuZCh4KSwgTWF0aHJvdW5kKGd1dHRlclRvcCkpO2NvLmxpbmVUbyhNYXRocm91bmQoeCksIE1hdGhyb3VuZChoZWlnaHQgLSBndXR0ZXJCb3R0b20pKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5jcm9zc2hhaXJzLmhsaW5lJ10pIHtcbiAgICAgICAgY28ubW92ZVRvKE1hdGhyb3VuZChndXR0ZXJMZWZ0KSwgTWF0aHJvdW5kKHkpKTtjby5saW5lVG8oTWF0aHJvdW5kKHdpZHRoIC0gZ3V0dGVyUmlnaHQpLCBNYXRocm91bmQoeSkpO1xuICAgICAgfVxuICAgICAgY28uc3Ryb2tlKCk7aWYgKG9iai50eXBlID09ICdzY2F0dGVyJyAmJiBwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvb3JkcyddKSB7XG4gICAgICAgIHZhciB4Q29vcmQgPSAoeCAtIGd1dHRlckxlZnQpIC8gKHdpZHRoIC0gZ3V0dGVyTGVmdCAtIGd1dHRlclJpZ2h0KSAqIChwcm9wWydjaGFydC54bWF4J10gLSBwcm9wWydjaGFydC54bWluJ10pICsgcHJvcFsnY2hhcnQueG1pbiddO3hDb29yZCA9IHhDb29yZC50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pO3ZhciB5Q29vcmQgPSBvYmoubWF4IC0gKHkgLSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pIC8gKGhlaWdodCAtIGd1dHRlclRvcCAtIGd1dHRlckJvdHRvbSkgKiBvYmoubWF4O2lmIChvYmoudHlwZSA9PSAnc2NhdHRlcicgJiYgb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB5Q29vcmQgPSAoeUNvb3JkIC0gb2JqLm1heCAvIDIpICogMjtcbiAgICAgICAgfVxuICAgICAgICB5Q29vcmQgPSB5Q29vcmQudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKTt2YXIgZGl2ID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5jb29yZGluYXRlcy5jb29yZHMuZGl2Jyk7dmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBjYW52YXNYWSA9IFJHLmdldENhbnZhc1hZKGNhKTtpZiAoIWRpdikge1xuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuX19vYmplY3RfXyA9IG9iajtkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO2Rpdi5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsYWNrJztkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZic7ZGl2LnN0eWxlLmZvbnRTaXplID0gJzEwcHQnO1xuICAgICAgICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJweCc7ZGl2LnN0eWxlLm9wYWNpdHkgPSAxO2Rpdi5zdHlsZS5XZWJraXRCb3JkZXJSYWRpdXMgPSAnM3B4JztkaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzNweCc7ZGl2LnN0eWxlLk1vekJvcmRlclJhZGl1cyA9ICczcHgnO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtSRy5SZWdpc3RyeS5zZXQoJ2NoYXJ0LmNvb3JkaW5hdGVzLmNvb3Jkcy5kaXYnLCBkaXYpO1xuICAgICAgICB9XG4gICAgICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMTtkaXYuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO2lmICghcHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMuZml4ZWQnXSkge1xuICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gbWEubWF4KDIsIGUucGFnZVggLSBkaXYub2Zmc2V0V2lkdGggLSAzKSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IG1hLm1heCgyLCBlLnBhZ2VZIC0gZGl2Lm9mZnNldEhlaWdodCAtIDMpICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGNhbnZhc1hZWzBdICsgZ3V0dGVyTGVmdCArIDMgKyAncHgnO2Rpdi5zdHlsZS50b3AgPSBjYW52YXNYWVsxXSArIGd1dHRlclRvcCArIDMgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNwYW4gc3R5bGU9XCJjb2xvcjogIzY2NlwiPicgKyBwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvb3Jkcy5sYWJlbHMueCddICsgJzo8L3NwYW4+ICcgKyB4Q29vcmQgKyAnPGJyPjxzcGFuIHN0eWxlPVwiY29sb3I6ICM2NjZcIj4nICsgcHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMubGFiZWxzLnknXSArICc6PC9zcGFuPiAnICsgeUNvb3JkO29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBSRy5oaWRlQ3Jvc3NoYWlyQ29vcmRzLCBmYWxzZSk7Y2EuX19jcm9zc2hhaXJzX2xhYmVsc19fID0gZGl2O2NhLl9fY3Jvc3NoYWlyc194X18gPSB4Q29vcmQ7Y2EuX19jcm9zc2hhaXJzX3lfXyA9IHlDb29yZDtcbiAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMnXSkge1xuICAgICAgICBhbGVydCgnW1JHUkFQSF0gU2hvd2luZyBjcm9zc2hhaXIgY29vcmRpbmF0ZXMgaXMgb25seSBzdXBwb3J0ZWQgb24gdGhlIFNjYXR0ZXIgY2hhcnQnKTtcbiAgICAgIH1cbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudChvYmosICdvbmNyb3NzaGFpcnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuaGlkZUNyb3NzaGFpckNvb3JkcygpO1xuICAgIH1cbiAgfTtSRy5hbGxvd1NlZ21lbnRIaWdobGlnaHQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG9iaiA9IG9wdC5vYmplY3QsXG4gICAgICAgIGNvdW50ID0gb3B0LmNvdW50LFxuICAgICAgICBmaWxsID0gb3B0LmZpbGwsXG4gICAgICAgIHN0cm9rZSA9IG9wdC5zdHJva2U7XG4gICAgaWYgKCFSRy5zZWdtZW50SGlnaGxpZ2h0RnVuY3Rpb24pIHtcbiAgICAgIFJHLnNlZ21lbnRIaWdobGlnaHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgYW5nbGUgPSBSRy5nZXRBbmdsZUJ5WFkob2JqLmNlbnRlcngsIG9iai5jZW50ZXJ5LCBtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKTthbmdsZSArPSBSRy5IQUxGUEk7aWYgKGFuZ2xlID4gUkcuVFdPUEkpIHtcbiAgICAgICAgICBhbmdsZSAtPSBSRy5UV09QSTtcbiAgICAgICAgfVxuICAgICAgICBSRy5yZWRyYXcoKTt2YXIgc3RhcnQgPSAwO3ZhciBlbmQgPSAwO3ZhciBhID0gbWEuUEkgKiAyIC8gY291bnQ7dmFyIHIgPSBvYmoucmFkaXVzOyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IGEgKiAoaSArIDEpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSAqIGE7ZW5kID0gKGkgKyAxKSAqIGE7cmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtzdGFydCAtPSBSRy5IQUxGUEk7ZW5kIC09IFJHLkhBTEZQSTtSRy5wYXRoMihvYmouY29udGV4dCwgJ2IgbSAlICUgYSAlICUgJSAlICUgZmFsc2UgYyBzICUgZiAlJywgb2JqLmNlbnRlcngsIG9iai5jZW50ZXJ5LCBvYmouY2VudGVyeCwgb2JqLmNlbnRlcnksIHIsIHN0YXJ0LCBlbmQsIHN0cm9rZSwgZmlsbCk7XG4gICAgICB9O29iai5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgUkcuc2VnbWVudEhpZ2hsaWdodEZ1bmN0aW9uLCBmYWxzZSk7XG4gICAgfVxuICB9O1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5keW5hbWljLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///169\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Common = {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.Effects.decorate = function (obj) {\n    for (i in RG.Effects.Common) {\n      if (typeof RG.Effects.Common[i] === 'function') {\n        obj[i] = RG.Effects.Common[i];\n      }\n    }\n  };RG.Effects.replaceCanvasWithDIV = RG.Effects.ReplaceCanvasWithDIV = RG.Effects.wrap = function (canvas) {\n    if (!canvas.rgraph_wrapper) {\n      var div = $('<div></div>').css({ width: canvas.width + 'px', height: canvas.height + 'px', cssFloat: canvas.style.cssFloat, left: canvas.style.left, top: canvas.style.top, display: 'inline-block' }).get(0);canvas.parentNode.insertBefore(div, canvas);canvas.parentNode.removeChild(canvas);div.appendChild(canvas);canvas.style.position = 'relative';canvas.style.left = div.offsetWidth / 2 + 'px';canvas.style.top = div.offsetHeight / 2 + 'px';canvas.style.cssFloat = '';canvas.rgraph_wrapper = div;\n    }\n    var div = canvas.rgraph_wrapper;return div;\n  };RG.Effects.Common.fadeIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.opacity = 0;RG.redrawCanvas(obj.canvas);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return obj;\n  };RG.Effects.Common.fadeOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.canvas.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.Effects.Common.fadeSlideIn = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.getCanvasXY(obj.canvas),\n        color = opt.color || 'white',\n        callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeSlideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var pc = -20;var step = (120 - pc) / frames;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, obj.get('clearto'));\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white ' + radius + '%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutOutwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, white 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas, color);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularInInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1] + 'px', left: canvasXY[0] + 'px', position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.fadeCircularOutInwards = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 120;var frame = 0;var radius = ma.max(obj.canvas.width, obj.canvas.height);var canvasXY = RG.getCanvasXY(obj.canvas);var color = opt.color || 'white';var callback = arguments[1] || function () {};RG.redrawCanvas(obj.canvas);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: canvasXY[1], left: canvasXY[0], position: 'absolute' }).appendTo($(obj.canvas.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();\n  };RG.Effects.Common.expand = function () {\n    var obj = this;var opt = arguments[0] || {};var bounce = typeof opt.bounce === 'boolean' ? opt.bounce : true;var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!this.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(this.canvas);this.canvas.rgraph_wrapper = div;\n    } else {\n      div = this.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';this.canvas.style.top = this.canvas.height / 2 + 'px';this.canvas.style.left = this.canvas.width / 2 + 'px';this.canvas.style.width = 0;this.canvas.style.height = 0;this.canvas.style.opacity = 0;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);if (bounce) {\n      jQuery('#' + obj.id).animate({ opacity: 1, width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.5, function () {\n        jQuery('#' + obj.id).animate({ width: obj.canvas.width * 0.9 + 'px', height: obj.canvas.height * 0.9 + 'px', top: obj.canvas.height * 0.05 + 'px', left: obj.canvas.width * 0.05 + 'px' }, duration * 0.25, function () {\n          jQuery('#' + obj.id).animate({ width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', top: 0, left: 0 }, duration * 0.25, function () {\n            callback(obj);\n          });\n        });\n      });\n    } else {\n      jQuery(obj.canvas).animate({ opacity: 1, width: obj.canvas.width + 'px', height: obj.canvas.height + 'px', left: 0, top: 0 }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.contract = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};if (!obj.canvas.rgraph_wrapper) {\n      var div = RG.Effects.wrap(obj.canvas);obj.canvas.rgraph_wrapper = div;\n    } else {\n      div = obj.canvas.rgraph_wrapper;\n    }\n    div.style.position = 'relative';obj.canvas.style.top = 0;obj.canvas.style.left = 0;if (opt.bounce !== false) {\n      jQuery('#' + obj.id).animate({ width: obj.canvas.width * 1.2 + 'px', height: obj.canvas.height * 1.2 + 'px', left: obj.canvas.width * -0.1 + 'px', top: obj.canvas.height * -0.1 + 'px' }, duration * 0.25, function () {\n        jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n          callback(obj);\n        });\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ opacity: 0, width: 0, height: 0, left: obj.canvas.width * 0.5 + 'px', top: obj.canvas.height * 0.5 + 'px' }, duration * 0.75, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.reveal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var divs = [['rgraph_reveal_left_' + obj.id, xy[0], xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_right_' + obj.id, xy[0] + obj.canvas.width / 2, xy[1], obj.canvas.width / 2, obj.canvas.height], ['rgraph_reveal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, obj.canvas.height / 2], ['rgraph_reveal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height / 2, obj.canvas.width, obj.canvas.height / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = document.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = opt && typeof opt.color === 'string' ? opt.color : 'white';document.body.appendChild(div);\n    }\n    RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + obj.canvas.width / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + obj.canvas.height / 2, height: 0 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.revealCircular = RG.Effects.Common.revealcircular = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var currentRadius = 0;\n    var centerx = obj.canvas.width / 2;var centery = obj.canvas.height / 2;var targetRadius = ma.max(obj.canvas.height, obj.canvas.width);var step = targetRadius / frames;var color = opt.background || opt.color || opt.backgroundColor || 'transparent';function iterator() {\n      RG.clear(obj.canvas, color);obj.context.save();obj.context.beginPath();obj.context.arc(centerx, centery, currentRadius, 0, RG.TWOPI, false);obj.context.clip();if (opt.background) {\n        RG.clear(obj.canvas, opt.background);\n      }\n      obj.draw();obj.context.restore();if (currentRadius < targetRadius) {\n        currentRadius += step;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Effects.Common.conceal = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var divs = [['rgraph_conceal_left_' + obj.id, xy[0], xy[1], 0, obj.canvas.height], ['rgraph_conceal_right_' + obj.id, xy[0] + obj.canvas.width, xy[1], 0, obj.canvas.height], ['rgraph_conceal_top_' + obj.id, xy[0], xy[1], obj.canvas.width, 0], ['rgraph_conceal_bottom_' + obj.id, xy[0], xy[1] + obj.canvas.height, obj.canvas.width, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + obj.canvas.width / 2, width: obj.canvas.width / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + obj.canvas.height / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + obj.canvas.height / 2, height: obj.canvas.height / 2 }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));doc.body.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.clear(obj.canvas);callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsOpen = RG.Effects.Common.hblindsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;RG.clear(this.canvas);RG.redrawCanvas(this.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;document.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hBlindsClose = RG.Effects.Common.hblindsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = this.canvas.height / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.width = this.canvas.width + 'px';div.style.height = 0;div.style.left = xy[0] + 'px';div.style.top = xy[1] + this.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.Effects.Common.vBlindsOpen = RG.Effects.Common.vblindsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.vblindsclose = RG.Effects.Common.vBlindsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = 0;div.style.height = this.canvas.height + 'px';div.style.left = xy[0] + this.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.Effects.Common.slideIn = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var from = opt.from || 'left';div.style.overflow = 'hidden';RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);canvas.style.position = 'relative';if (from == 'left') {\n      obj.canvas.style.left = 0 - div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    } else if (from == 'top') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = 0 - div.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      obj.canvas.style.left = 0;obj.canvas.style.top = div.offsetHeight + 'px';\n    } else {\n      obj.canvas.style.left = div.offsetWidth + 'px';obj.canvas.style.top = 0;\n    }\n    jQuery('#' + obj.id).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.Effects.Common.slideOut = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var div = RG.Effects.wrap(obj.canvas);var to = opt.to || 'left';div.style.overflow = 'hidden';obj.canvas.style.position = 'relative';obj.canvas.style.left = 0;obj.canvas.style.top = 0;if (to == 'left') {\n      jQuery('#' + obj.id).animate({ left: 0 - obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'top') {\n      jQuery('#' + obj.id).animate({ left: 0, top: 0 - div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else if (to == 'bottom') {\n      jQuery('#' + obj.id).animate({ top: 0 + div.offsetHeight + 'px' }, duration, function () {\n        callback(obj);\n      });\n    } else {\n      jQuery('#' + obj.id).animate({ left: 0 + obj.canvas.width + 'px' }, duration, function () {\n        callback(obj);\n      });\n    }\n    return this;\n  };RG.Effects.Common.hscissorsopen = RG.Effects.Common.hScissorsOpen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;var to = opt.to || 'left';var height = obj.canvas.height / 5;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = obj.canvas.width + 'px';div.style.height = height + 'px';div.style.left = xy[0] + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + obj.canvas.width + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.hScissorsClose = RG.Effects.Common.hscissorsclose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var height = obj.canvas.height / 5;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + obj.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? xy[0] + obj.canvas.width : xy[0]) + 'px';div.style.top = xy[1] + obj.canvas.height * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ left: xy[0] + 'px', width: obj.canvas.width + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + obj.id).animate({ width: obj.canvas.width + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RGraph.clear(obj.canvas);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vScissorsOpen = RG.Effects.Common.vscissorsopen = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = obj.canvas.height + 'px';div.style.left = xy[0] + obj.canvas.width * (i / 10) + 'px';div.style.top = xy[1] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + obj.canvas.height + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      doc.body.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));doc.body.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.vscissorsclose = RG.Effects.Common.vScissorsClose = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var duration = frames / 60 * 1000;var frame = 0;var callback = arguments[1] || function () {};var xy = RG.getCanvasXY(obj.canvas);var color = opt.background || opt.color || opt.backgroundColor || 'white';var xy = RG.getCanvasXY(this.canvas);var width = this.canvas.width / 10;RG.redrawCanvas(obj.canvas);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + obj.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = xy[0] + width * i + 'px';div.style.top = (i % 2 == 0 ? xy[1] + obj.canvas.height : xy[1]) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;doc.body.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ top: xy[1] + 'px', height: obj.canvas.height + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + obj.id).animate({ height: obj.canvas.height + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.clear(obj.canvas);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };RG.Effects.Common.animate = function (map) {\n    var obj = this;obj.draw();var totalFrames = map && map['frames'] ? map['frames'] : 30;var currentFrame = new Array();var originalValues = new Array();var diffs = new Array();var steps = new Array();var callback = arguments[1];\n    function iterator() {\n      var id = [obj.id + '_' + obj.type];if (!currentFrame[id]) {\n        currentFrame[id] = totalFrames;originalValues[id] = {};diffs[id] = {};steps[id] = {};\n      }\n      for (var i in map) {\n        if (typeof map[i] === 'string' || typeof map[i] === 'number') {\n          if (currentFrame[id] == totalFrames) {\n            originalValues[id][i] = obj.get(i);diffs[id][i] = map[i] - originalValues[id][i];steps[id][i] = diffs[id][i] / totalFrames;\n          }\n          obj.set(i, obj.get(i) + steps[id][i]);RG.clear(obj.canvas);obj.draw();\n        }\n      }\n      if (--currentFrame[id] > 0) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        if (typeof callback === 'function') {\n          callback(obj);\n        }\n      }\n    }\n    iterator();\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZWZmZWN0cy5qcz9mOThiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkVmZmVjdHMgPSBSR3JhcGguRWZmZWN0cyB8fCB7fTtSR3JhcGguRWZmZWN0cy5Db21tb24gPSB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoO1JHLkVmZmVjdHMuZGVjb3JhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yIChpIGluIFJHLkVmZmVjdHMuQ29tbW9uKSB7XG4gICAgICBpZiAodHlwZW9mIFJHLkVmZmVjdHMuQ29tbW9uW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ialtpXSA9IFJHLkVmZmVjdHMuQ29tbW9uW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5FZmZlY3RzLnJlcGxhY2VDYW52YXNXaXRoRElWID0gUkcuRWZmZWN0cy5SZXBsYWNlQ2FudmFzV2l0aERJViA9IFJHLkVmZmVjdHMud3JhcCA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICBpZiAoIWNhbnZhcy5yZ3JhcGhfd3JhcHBlcikge1xuICAgICAgdmFyIGRpdiA9ICQoJzxkaXY+PC9kaXY+JykuY3NzKHsgd2lkdGg6IGNhbnZhcy53aWR0aCArICdweCcsIGhlaWdodDogY2FudmFzLmhlaWdodCArICdweCcsIGNzc0Zsb2F0OiBjYW52YXMuc3R5bGUuY3NzRmxvYXQsIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LCB0b3A6IGNhbnZhcy5zdHlsZS50b3AsIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH0pLmdldCgwKTtjYW52YXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGl2LCBjYW52YXMpO2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7ZGl2LmFwcGVuZENoaWxkKGNhbnZhcyk7Y2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztjYW52YXMuc3R5bGUubGVmdCA9IGRpdi5vZmZzZXRXaWR0aCAvIDIgKyAncHgnO2NhbnZhcy5zdHlsZS50b3AgPSBkaXYub2Zmc2V0SGVpZ2h0IC8gMiArICdweCc7Y2FudmFzLnN0eWxlLmNzc0Zsb2F0ID0gJyc7Y2FudmFzLnJncmFwaF93cmFwcGVyID0gZGl2O1xuICAgIH1cbiAgICB2YXIgZGl2ID0gY2FudmFzLnJncmFwaF93cmFwcGVyO3JldHVybiBkaXY7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uZmFkZUluID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O29iai5jYW52YXMuc3R5bGUub3BhY2l0eSA9IDA7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2ZvciAodmFyIGkgPSAxOyBpIDw9IGZyYW1lczsgKytpKSB7XG4gICAgICAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9iai5jYW52YXMuc3R5bGUub3BhY2l0eSA9IGluZGV4IC8gZnJhbWVzO2lmIChpbmRleCA+PSBmcmFtZXMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpbmRleCAvIGZyYW1lcyAqIGR1cmF0aW9uKTtcbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307Zm9yICh2YXIgaSA9IDE7IGkgPD0gZnJhbWVzOyArK2kpIHtcbiAgICAgIChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JqLmNhbnZhcy5zdHlsZS5vcGFjaXR5ID0gMSAtIGluZGV4IC8gZnJhbWVzO2lmIChpbmRleCA+PSBmcmFtZXMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpbmRleCAvIGZyYW1lcyAqIGR1cmF0aW9uKTtcbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtSRy5FZmZlY3RzLkNvbW1vbi5mYWRlU2xpZGVJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIHBjID0gLTIwLFxuICAgICAgICBzdGVwID0gKDEyMCAtIHBjKSAvIGZyYW1lcyxcbiAgICAgICAgY2FudmFzWFkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArIHBjICsgJyUsICcgKyBjb2xvciArICcgJyArIChwYyArIDIwKSArICclKScsIHdpZHRoOiBvYmouY2FudmFzLndpZHRoICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCArICdweCcsIHRvcDogY2FudmFzWFlbMV0gKyAncHgnLCBsZWZ0OiBjYW52YXNYWVswXSArICdweCcsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQob2JqLmNhbnZhcy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAocGMgPCAxMjApIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArIHBjICsgJyUsICcgKyBjb2xvciArICcgJyArIChwYyArIDIwKSArICclKScgfSk7cGMgKz0gc3RlcDtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVTbGlkZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIHBjID0gLTIwO3ZhciBzdGVwID0gKDEyMCAtIHBjKSAvIGZyYW1lczt2YXIgY2FudmFzWFkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJzt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsICcgKyBjb2xvciArICcgJyArIHBjICsgJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArIChwYyArIDIwKSArICclKScsIHdpZHRoOiBvYmouY2FudmFzLndpZHRoICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCArICdweCcsIHRvcDogY2FudmFzWFlbMV0gKyAncHgnLCBsZWZ0OiBjYW52YXNYWVswXSArICdweCcsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQob2JqLmNhbnZhcy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAocGMgPCAxMjApIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsICcgKyBjb2xvciArICcgJyArIHBjICsgJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArIChwYyArIDIwKSArICclKScgfSk7cGMgKz0gc3RlcDtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSRy5jbGVhcihvYmouY2FudmFzLCBvYmouZ2V0KCdjbGVhcnRvJykpO1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVDaXJjdWxhckluT3V0d2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAxMjA7dmFyIGZyYW1lID0gMDt2YXIgcmFkaXVzID0gMDt2YXIgY2FudmFzWFkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJzt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCB3aGl0ZSAnICsgcmFkaXVzICsgJyUpJywgd2lkdGg6IG9iai5jYW52YXMud2lkdGggKyAncHgnLCBoZWlnaHQ6IG9iai5jYW52YXMuaGVpZ2h0ICsgJ3B4JywgdG9wOiBjYW52YXNYWVsxXSwgbGVmdDogY2FudmFzWFlbMF0sIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQob2JqLmNhbnZhcy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApICcgKyBmcmFtZSsrIC8gZnJhbWVzICogMTAwICsgJyUsICcgKyBjb2xvciArICcgJyArIGZyYW1lKysgLyBmcmFtZXMgKiAxNTAgKyAnJSknIH0pO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uZmFkZUNpcmN1bGFyT3V0T3V0d2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAxMjA7dmFyIGZyYW1lID0gMDt2YXIgY2FudmFzWFkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJzt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCB3aGl0ZSAwJSknLCB3aWR0aDogb2JqLmNhbnZhcy53aWR0aCArICdweCcsIGhlaWdodDogb2JqLmNhbnZhcy5oZWlnaHQgKyAncHgnLCB0b3A6IGNhbnZhc1hZWzFdLCBsZWZ0OiBjYW52YXNYWVswXSwgcG9zaXRpb246ICdhYnNvbHV0ZScgfSkuYXBwZW5kVG8oJChvYmouY2FudmFzLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGlmIChmcmFtZSA8IGZyYW1lcykge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5jc3MoeyBiYWNrZ3JvdW5kOiAncmFkaWFsLWdyYWRpZW50KCcgKyBjb2xvciArICcgJyArIGZyYW1lKysgLyBmcmFtZXMgKiAxMDAgKyAnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgZnJhbWUrKyAvIGZyYW1lcyAqIDE1MCArICclKScgfSk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcywgY29sb3IpOyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uZmFkZUNpcmN1bGFySW5JbndhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMTIwO3ZhciBmcmFtZSA9IDA7dmFyIHJhZGl1cyA9IG1hLm1heChvYmouY2FudmFzLndpZHRoLCBvYmouY2FudmFzLmhlaWdodCk7dmFyIGNhbnZhc1hZID0gUkcuZ2V0Q2FudmFzWFkob2JqLmNhbnZhcyk7dmFyIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZSc7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkICsgJ1wiPjwvZGl2PicpLmNzcyh7IGJhY2tncm91bmQ6ICdyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAxMDAlLCByZ2JhKDI1NSwyNTUsMjU1LDApIDAlKScsIHdpZHRoOiBvYmouY2FudmFzLndpZHRoICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCArICdweCcsIHRvcDogY2FudmFzWFlbMV0gKyAncHgnLCBsZWZ0OiBjYW52YXNYWVswXSArICdweCcsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQob2JqLmNhbnZhcy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudCgnICsgY29sb3IgKyAnICcgKyAoZnJhbWVzIC0gZnJhbWUrKykgLyBmcmFtZXMgKiAxMDAgKyAnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgKGZyYW1lcyAtIGZyYW1lKyspIC8gZnJhbWVzICogMTIwICsgJyUpJyB9KTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmZhZGVDaXJjdWxhck91dElud2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAxMjA7dmFyIGZyYW1lID0gMDt2YXIgcmFkaXVzID0gbWEubWF4KG9iai5jYW52YXMud2lkdGgsIG9iai5jYW52YXMuaGVpZ2h0KTt2YXIgY2FudmFzWFkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJzt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpOyQoJzxkaXYgaWQ9XCJyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCByZ2JhKDI1NSwyNTUsMjU1LDApIDAlKScsIHdpZHRoOiBvYmouY2FudmFzLndpZHRoICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCArICdweCcsIHRvcDogY2FudmFzWFlbMV0sIGxlZnQ6IGNhbnZhc1hZWzBdLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9KS5hcHBlbmRUbygkKG9iai5jYW52YXMucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgaWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgICQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLmNzcyh7IGJhY2tncm91bmQ6ICdyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgKGZyYW1lcyAtIGZyYW1lKyspIC8gZnJhbWVzICogMTAwICsgJyUsICcgKyBjb2xvciArICcgJyArIChmcmFtZXMgLSBmcmFtZSsrKSAvIGZyYW1lcyAqIDEyMCArICclKScgfSk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7JCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtcbiAgfTtSRy5FZmZlY3RzLkNvbW1vbi5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgYm91bmNlID0gdHlwZW9mIG9wdC5ib3VuY2UgPT09ICdib29sZWFuJyA/IG9wdC5ib3VuY2UgOiB0cnVlO3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307aWYgKCF0aGlzLmNhbnZhcy5yZ3JhcGhfd3JhcHBlcikge1xuICAgICAgdmFyIGRpdiA9IFJHLkVmZmVjdHMud3JhcCh0aGlzLmNhbnZhcyk7dGhpcy5jYW52YXMucmdyYXBoX3dyYXBwZXIgPSBkaXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdiA9IHRoaXMuY2FudmFzLnJncmFwaF93cmFwcGVyO1xuICAgIH1cbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO3RoaXMuY2FudmFzLnN0eWxlLnRvcCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDIgKyAncHgnO3RoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSB0aGlzLmNhbnZhcy53aWR0aCAvIDIgKyAncHgnO3RoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gMDt0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAwO3RoaXMuY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAwO1JHLmNsZWFyKHRoaXMuY2FudmFzKTtSRy5yZWRyYXdDYW52YXModGhpcy5jYW52YXMpO2lmIChib3VuY2UpIHtcbiAgICAgIGpRdWVyeSgnIycgKyBvYmouaWQpLmFuaW1hdGUoeyBvcGFjaXR5OiAxLCB3aWR0aDogb2JqLmNhbnZhcy53aWR0aCAqIDEuMiArICdweCcsIGhlaWdodDogb2JqLmNhbnZhcy5oZWlnaHQgKiAxLjIgKyAncHgnLCBsZWZ0OiBvYmouY2FudmFzLndpZHRoICogLTAuMSArICdweCcsIHRvcDogb2JqLmNhbnZhcy5oZWlnaHQgKiAtMC4xICsgJ3B4JyB9LCBkdXJhdGlvbiAqIDAuNSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkoJyMnICsgb2JqLmlkKS5hbmltYXRlKHsgd2lkdGg6IG9iai5jYW52YXMud2lkdGggKiAwLjkgKyAncHgnLCBoZWlnaHQ6IG9iai5jYW52YXMuaGVpZ2h0ICogMC45ICsgJ3B4JywgdG9wOiBvYmouY2FudmFzLmhlaWdodCAqIDAuMDUgKyAncHgnLCBsZWZ0OiBvYmouY2FudmFzLndpZHRoICogMC4wNSArICdweCcgfSwgZHVyYXRpb24gKiAwLjI1LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgalF1ZXJ5KCcjJyArIG9iai5pZCkuYW5pbWF0ZSh7IHdpZHRoOiBvYmouY2FudmFzLndpZHRoICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCArICdweCcsIHRvcDogMCwgbGVmdDogMCB9LCBkdXJhdGlvbiAqIDAuMjUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpRdWVyeShvYmouY2FudmFzKS5hbmltYXRlKHsgb3BhY2l0eTogMSwgd2lkdGg6IG9iai5jYW52YXMud2lkdGggKyAncHgnLCBoZWlnaHQ6IG9iai5jYW52YXMuaGVpZ2h0ICsgJ3B4JywgbGVmdDogMCwgdG9wOiAwIH0sIGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uY29udHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O2lmICghb2JqLmNhbnZhcy5yZ3JhcGhfd3JhcHBlcikge1xuICAgICAgdmFyIGRpdiA9IFJHLkVmZmVjdHMud3JhcChvYmouY2FudmFzKTtvYmouY2FudmFzLnJncmFwaF93cmFwcGVyID0gZGl2O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYgPSBvYmouY2FudmFzLnJncmFwaF93cmFwcGVyO1xuICAgIH1cbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO29iai5jYW52YXMuc3R5bGUudG9wID0gMDtvYmouY2FudmFzLnN0eWxlLmxlZnQgPSAwO2lmIChvcHQuYm91bmNlICE9PSBmYWxzZSkge1xuICAgICAgalF1ZXJ5KCcjJyArIG9iai5pZCkuYW5pbWF0ZSh7IHdpZHRoOiBvYmouY2FudmFzLndpZHRoICogMS4yICsgJ3B4JywgaGVpZ2h0OiBvYmouY2FudmFzLmhlaWdodCAqIDEuMiArICdweCcsIGxlZnQ6IG9iai5jYW52YXMud2lkdGggKiAtMC4xICsgJ3B4JywgdG9wOiBvYmouY2FudmFzLmhlaWdodCAqIC0wLjEgKyAncHgnIH0sIGR1cmF0aW9uICogMC4yNSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkoJyMnICsgb2JqLmlkKS5hbmltYXRlKHsgb3BhY2l0eTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgbGVmdDogb2JqLmNhbnZhcy53aWR0aCAqIDAuNSArICdweCcsIHRvcDogb2JqLmNhbnZhcy5oZWlnaHQgKiAwLjUgKyAncHgnIH0sIGR1cmF0aW9uICogMC43NSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpRdWVyeSgnIycgKyBvYmouaWQpLmFuaW1hdGUoeyBvcGFjaXR5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBsZWZ0OiBvYmouY2FudmFzLndpZHRoICogMC41ICsgJ3B4JywgdG9wOiBvYmouY2FudmFzLmhlaWdodCAqIDAuNSArICdweCcgfSwgZHVyYXRpb24gKiAwLjc1LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24ucmV2ZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgNjA7dmFyIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgZGl2cyA9IFtbJ3JncmFwaF9yZXZlYWxfbGVmdF8nICsgb2JqLmlkLCB4eVswXSwgeHlbMV0sIG9iai5jYW52YXMud2lkdGggLyAyLCBvYmouY2FudmFzLmhlaWdodF0sIFsncmdyYXBoX3JldmVhbF9yaWdodF8nICsgb2JqLmlkLCB4eVswXSArIG9iai5jYW52YXMud2lkdGggLyAyLCB4eVsxXSwgb2JqLmNhbnZhcy53aWR0aCAvIDIsIG9iai5jYW52YXMuaGVpZ2h0XSwgWydyZ3JhcGhfcmV2ZWFsX3RvcF8nICsgb2JqLmlkLCB4eVswXSwgeHlbMV0sIG9iai5jYW52YXMud2lkdGgsIG9iai5jYW52YXMuaGVpZ2h0IC8gMl0sIFsncmdyYXBoX3JldmVhbF9ib3R0b21fJyArIG9iai5pZCwgeHlbMF0sIHh5WzFdICsgb2JqLmNhbnZhcy5oZWlnaHQgLyAyLCBvYmouY2FudmFzLndpZHRoLCBvYmouY2FudmFzLmhlaWdodCAvIDJdXTtmb3IgKHZhciBpID0gMCwgbGVuID0gZGl2cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9IGRpdnNbaV1bMF07ZGl2LnN0eWxlLndpZHRoID0gZGl2c1tpXVszXSArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IGRpdnNbaV1bNF0gKyAncHgnO2Rpdi5zdHlsZS5sZWZ0ID0gZGl2c1tpXVsxXSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IGRpdnNbaV1bMl0gKyAncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdCAmJiB0eXBlb2Ygb3B0LmNvbG9yID09PSAnc3RyaW5nJyA/IG9wdC5jb2xvciA6ICd3aGl0ZSc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH1cbiAgICBSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9sZWZ0XycgKyBvYmouaWQpLmFuaW1hdGUoeyB3aWR0aDogMCB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9yaWdodF8nICsgb2JqLmlkKS5hbmltYXRlKHsgbGVmdDogJys9JyArIG9iai5jYW52YXMud2lkdGggLyAyLCB3aWR0aDogMCB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF90b3BfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGhlaWdodDogMCB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9ib3R0b21fJyArIG9iai5pZCkuYW5pbWF0ZSh7IHRvcDogJys9JyArIG9iai5jYW52YXMuaGVpZ2h0IC8gMiwgaGVpZ2h0OiAwIH0sIGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfdG9wX1wiICsgb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3JldmVhbF9ib3R0b21fXCIgKyBvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX2xlZnRfXCIgKyBvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX3JpZ2h0X1wiICsgb2JqLmlkKSk7Y2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbik7cmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24ucmV2ZWFsQ2lyY3VsYXIgPSBSRy5FZmZlY3RzLkNvbW1vbi5yZXZlYWxjaXJjdWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciBjdXJyZW50UmFkaXVzID0gMDtcbiAgICB2YXIgY2VudGVyeCA9IG9iai5jYW52YXMud2lkdGggLyAyO3ZhciBjZW50ZXJ5ID0gb2JqLmNhbnZhcy5oZWlnaHQgLyAyO3ZhciB0YXJnZXRSYWRpdXMgPSBtYS5tYXgob2JqLmNhbnZhcy5oZWlnaHQsIG9iai5jYW52YXMud2lkdGgpO3ZhciBzdGVwID0gdGFyZ2V0UmFkaXVzIC8gZnJhbWVzO3ZhciBjb2xvciA9IG9wdC5iYWNrZ3JvdW5kIHx8IG9wdC5jb2xvciB8fCBvcHQuYmFja2dyb3VuZENvbG9yIHx8ICd0cmFuc3BhcmVudCc7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBSRy5jbGVhcihvYmouY2FudmFzLCBjb2xvcik7b2JqLmNvbnRleHQuc2F2ZSgpO29iai5jb250ZXh0LmJlZ2luUGF0aCgpO29iai5jb250ZXh0LmFyYyhjZW50ZXJ4LCBjZW50ZXJ5LCBjdXJyZW50UmFkaXVzLCAwLCBSRy5UV09QSSwgZmFsc2UpO29iai5jb250ZXh0LmNsaXAoKTtpZiAob3B0LmJhY2tncm91bmQpIHtcbiAgICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcywgb3B0LmJhY2tncm91bmQpO1xuICAgICAgfVxuICAgICAgb2JqLmRyYXcoKTtvYmouY29udGV4dC5yZXN0b3JlKCk7aWYgKGN1cnJlbnRSYWRpdXMgPCB0YXJnZXRSYWRpdXMpIHtcbiAgICAgICAgY3VycmVudFJhZGl1cyArPSBzdGVwO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uY29uY2VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWShvYmouY2FudmFzKTt2YXIgY29sb3IgPSBvcHQuYmFja2dyb3VuZCB8fCBvcHQuY29sb3IgfHwgb3B0LmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO3ZhciBkaXZzID0gW1sncmdyYXBoX2NvbmNlYWxfbGVmdF8nICsgb2JqLmlkLCB4eVswXSwgeHlbMV0sIDAsIG9iai5jYW52YXMuaGVpZ2h0XSwgWydyZ3JhcGhfY29uY2VhbF9yaWdodF8nICsgb2JqLmlkLCB4eVswXSArIG9iai5jYW52YXMud2lkdGgsIHh5WzFdLCAwLCBvYmouY2FudmFzLmhlaWdodF0sIFsncmdyYXBoX2NvbmNlYWxfdG9wXycgKyBvYmouaWQsIHh5WzBdLCB4eVsxXSwgb2JqLmNhbnZhcy53aWR0aCwgMF0sIFsncmdyYXBoX2NvbmNlYWxfYm90dG9tXycgKyBvYmouaWQsIHh5WzBdLCB4eVsxXSArIG9iai5jYW52YXMuaGVpZ2h0LCBvYmouY2FudmFzLndpZHRoLCAwXV07Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpdnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gZGl2c1tpXVswXTtkaXYuc3R5bGUud2lkdGggPSBkaXZzW2ldWzNdICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gZGl2c1tpXVs0XSArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSBkaXZzW2ldWzFdICsgJ3B4JztkaXYuc3R5bGUudG9wID0gZGl2c1tpXVsyXSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB9XG4gICAgalF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfbGVmdF8nICsgb2JqLmlkKS5hbmltYXRlKHsgd2lkdGg6ICcrPScgKyBvYmouY2FudmFzLndpZHRoIC8gMiB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfcmlnaHRfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGxlZnQ6ICctPScgKyBvYmouY2FudmFzLndpZHRoIC8gMiwgd2lkdGg6IG9iai5jYW52YXMud2lkdGggLyAyIH0sIGR1cmF0aW9uKTtqUXVlcnkoJyNyZ3JhcGhfY29uY2VhbF90b3BfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGhlaWdodDogJys9JyArIG9iai5jYW52YXMuaGVpZ2h0IC8gMiB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfYm90dG9tXycgKyBvYmouaWQpLmFuaW1hdGUoeyB0b3A6ICctPScgKyBvYmouY2FudmFzLmhlaWdodCAvIDIsIGhlaWdodDogb2JqLmNhbnZhcy5oZWlnaHQgLyAyIH0sIGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9jb25jZWFsX3RvcF9cIiArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9jb25jZWFsX2JvdHRvbV9cIiArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9jb25jZWFsX2xlZnRfXCIgKyBvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF9yaWdodF9cIiArIG9iai5pZCkpO1JHLmNsZWFyKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmhCbGluZHNPcGVuID0gUkcuRWZmZWN0cy5Db21tb24uaGJsaW5kc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIGNvbG9yID0gb3B0LmJhY2tncm91bmQgfHwgb3B0LmNvbG9yIHx8IG9wdC5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJzt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDU7UkcuY2xlYXIodGhpcy5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyh0aGlzLmNhbnZhcyk7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oYmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztkaXYuc3R5bGUubGVmdCA9IHh5WzBdICsgJ3B4JztkaXYuc3R5bGUudG9wID0geHlbMV0gKyB0aGlzLmNhbnZhcy5oZWlnaHQgKiAoaSAvIDUpICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX2hibGluZHNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IDAgfSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzJfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfM18nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhvYmopO1xuICAgIH0sIGR1cmF0aW9uKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5FZmZlY3RzLkNvbW1vbi5oQmxpbmRzQ2xvc2UgPSBSRy5FZmZlY3RzLkNvbW1vbi5oYmxpbmRzY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIGNvbG9yID0gb3B0LmJhY2tncm91bmQgfHwgb3B0LmNvbG9yIHx8IG9wdC5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJzt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDU7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oYmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gMDtkaXYuc3R5bGUubGVmdCA9IHh5WzBdICsgJ3B4JztkaXYuc3R5bGUudG9wID0geHlbMV0gKyB0aGlzLmNhbnZhcy5oZWlnaHQgKiAoaSAvIDUpICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtkb2MuYm9keS5hcHBlbmRDaGlsZChkaXYpO2pRdWVyeSgnI3JncmFwaF9oYmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkKS5hbmltYXRlKHsgaGVpZ2h0OiBoZWlnaHQgKyAncHgnIH0sIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5jbGVhcihvYmouY2FudmFzKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzBfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMV8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18yXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzNfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfNF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7XG4gIH07UkcuRWZmZWN0cy5Db21tb24udkJsaW5kc09wZW4gPSBSRy5FZmZlY3RzLkNvbW1vbi52YmxpbmRzb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgY29sb3IgPSBvcHQuYmFja2dyb3VuZCB8fCBvcHQuY29sb3IgfHwgb3B0LmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO3ZhciB4eSA9IFJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDEwO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtmb3IgKHZhciBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF92YmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ICsgJ3B4JztkaXYuc3R5bGUubGVmdCA9IHh5WzBdICsgdGhpcy5jYW52YXMud2lkdGggKiAoaSAvIDEwKSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IHh5WzFdICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtkb2MuYm9keS5hcHBlbmRDaGlsZChkaXYpO2pRdWVyeSgnI3JncmFwaF92YmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkKS5hbmltYXRlKHsgd2lkdGg6IDAgfSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzJfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfM18nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzVfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNl8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzhfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOV8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24udmJsaW5kc2Nsb3NlID0gUkcuRWZmZWN0cy5Db21tb24udkJsaW5kc0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgNjA7dmFyIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciBjb2xvciA9IG9wdC5iYWNrZ3JvdW5kIHx8IG9wdC5jb2xvciB8fCBvcHQuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSc7dmFyIHh5ID0gUkcuZ2V0Q2FudmFzWFkodGhpcy5jYW52YXMpO3ZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gMTA7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfdmJsaW5kc18nICsgaSArICdfJyArIG9iai5pZDtkaXYuc3R5bGUud2lkdGggPSAwO2Rpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgKyAncHgnO2Rpdi5zdHlsZS5sZWZ0ID0geHlbMF0gKyB0aGlzLmNhbnZhcy53aWR0aCAqIChpIC8gMTApICsgJ3B4JztkaXYuc3R5bGUudG9wID0geHlbMV0gKyAncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO2RvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX3ZibGluZHNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyB3aWR0aDogd2lkdGggfSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLmNsZWFyKG9iai5jYW52YXMpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzJfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfM18nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzVfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNl8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzhfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOV8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uc2xpZGVJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgY29sb3IgPSBvcHQuYmFja2dyb3VuZCB8fCBvcHQuY29sb3IgfHwgb3B0LmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO3ZhciB4eSA9IFJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDEwO3ZhciBkaXYgPSBSRy5FZmZlY3RzLndyYXAob2JqLmNhbnZhcyk7dmFyIGZyb20gPSBvcHQuZnJvbSB8fCAnbGVmdCc7ZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7aWYgKGZyb20gPT0gJ2xlZnQnKSB7XG4gICAgICBvYmouY2FudmFzLnN0eWxlLmxlZnQgPSAwIC0gZGl2Lm9mZnNldFdpZHRoICsgJ3B4JztvYmouY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgfSBlbHNlIGlmIChmcm9tID09ICd0b3AnKSB7XG4gICAgICBvYmouY2FudmFzLnN0eWxlLmxlZnQgPSAwO29iai5jYW52YXMuc3R5bGUudG9wID0gMCAtIGRpdi5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA9PSAnYm90dG9tJykge1xuICAgICAgb2JqLmNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtvYmouY2FudmFzLnN0eWxlLnRvcCA9IGRpdi5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouY2FudmFzLnN0eWxlLmxlZnQgPSBkaXYub2Zmc2V0V2lkdGggKyAncHgnO29iai5jYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICB9XG4gICAgalF1ZXJ5KCcjJyArIG9iai5pZCkuYW5pbWF0ZSh7IGxlZnQ6IDAsIHRvcDogMCB9LCBkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9KTtyZXR1cm4gdGhpcztcbiAgfTtSRy5FZmZlY3RzLkNvbW1vbi5zbGlkZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgY29sb3IgPSBvcHQuYmFja2dyb3VuZCB8fCBvcHQuY29sb3IgfHwgb3B0LmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO3ZhciB4eSA9IFJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDEwO3ZhciBkaXYgPSBSRy5FZmZlY3RzLndyYXAob2JqLmNhbnZhcyk7dmFyIHRvID0gb3B0LnRvIHx8ICdsZWZ0JztkaXYuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztvYmouY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztvYmouY2FudmFzLnN0eWxlLmxlZnQgPSAwO29iai5jYW52YXMuc3R5bGUudG9wID0gMDtpZiAodG8gPT0gJ2xlZnQnKSB7XG4gICAgICBqUXVlcnkoJyMnICsgb2JqLmlkKS5hbmltYXRlKHsgbGVmdDogMCAtIG9iai5jYW52YXMud2lkdGggKyAncHgnIH0sIGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRvID09ICd0b3AnKSB7XG4gICAgICBqUXVlcnkoJyMnICsgb2JqLmlkKS5hbmltYXRlKHsgbGVmdDogMCwgdG9wOiAwIC0gZGl2Lm9mZnNldEhlaWdodCArICdweCcgfSwgZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodG8gPT0gJ2JvdHRvbScpIHtcbiAgICAgIGpRdWVyeSgnIycgKyBvYmouaWQpLmFuaW1hdGUoeyB0b3A6IDAgKyBkaXYub2Zmc2V0SGVpZ2h0ICsgJ3B4JyB9LCBkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpRdWVyeSgnIycgKyBvYmouaWQpLmFuaW1hdGUoeyBsZWZ0OiAwICsgb2JqLmNhbnZhcy53aWR0aCArICdweCcgfSwgZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtSRy5FZmZlY3RzLkNvbW1vbi5oc2Npc3NvcnNvcGVuID0gUkcuRWZmZWN0cy5Db21tb24uaFNjaXNzb3JzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgY29sb3IgPSBvcHQuYmFja2dyb3VuZCB8fCBvcHQuY29sb3IgfHwgb3B0LmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO3ZhciB4eSA9IFJHLmdldENhbnZhc1hZKHRoaXMuY2FudmFzKTt2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDEwO3ZhciB0byA9IG9wdC50byB8fCAnbGVmdCc7dmFyIGhlaWdodCA9IG9iai5jYW52YXMuaGVpZ2h0IC8gNTtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfaHNjaXNzb3JzX1wiICsgaSArICdfJyArIG9iai5pZCk7XG4gICAgICBpZiAoIWRpdikge1xuICAgICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfaHNjaXNzb3JzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS53aWR0aCA9IG9iai5jYW52YXMud2lkdGggKyAncHgnO2Rpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO2Rpdi5zdHlsZS5sZWZ0ID0geHlbMF0gKyAncHgnO2Rpdi5zdHlsZS50b3AgPSB4eVsxXSArIG9iai5jYW52YXMuaGVpZ2h0ICogKGkgLyA1KSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIH1cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgaSArICdfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGxlZnQ6IHh5WzBdICsgb2JqLmNhbnZhcy53aWR0aCArICdweCcsIHdpZHRoOiAwIH0sIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgaSArICdfJyArIG9iai5pZCkuYW5pbWF0ZSh7IHdpZHRoOiAwIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oc2Npc3NvcnNfMF8nICsgb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaHNjaXNzb3JzXzFfJyArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18yXycgKyBvYmouaWQpKTtkb2MuYm9keS5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oc2Npc3NvcnNfM18nICsgb2JqLmlkKSk7ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaHNjaXNzb3JzXzRfJyArIG9iai5pZCkpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLmhTY2lzc29yc0Nsb3NlID0gUkcuRWZmZWN0cy5Db21tb24uaHNjaXNzb3JzY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIGNvbG9yID0gb3B0LmJhY2tncm91bmQgfHwgb3B0LmNvbG9yIHx8IG9wdC5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJzt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIGhlaWdodCA9IG9iai5jYW52YXMuaGVpZ2h0IC8gNTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oc2Npc3NvcnNfJyArIGkgKyAnXycgKyBvYmouaWQ7ZGl2LnN0eWxlLndpZHRoID0gMDtkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztkaXYuc3R5bGUubGVmdCA9IChpICUgMiA9PSAwID8geHlbMF0gKyBvYmouY2FudmFzLndpZHRoIDogeHlbMF0pICsgJ3B4JztkaXYuc3R5bGUudG9wID0geHlbMV0gKyBvYmouY2FudmFzLmhlaWdodCAqIChpIC8gNSkgKyAncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO2RvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7aWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgalF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyBpICsgJ18nICsgb2JqLmlkKS5hbmltYXRlKHsgbGVmdDogeHlbMF0gKyAncHgnLCB3aWR0aDogb2JqLmNhbnZhcy53aWR0aCArICdweCcgfSwgZHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgalF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyBpICsgJ18nICsgb2JqLmlkKS5hbmltYXRlKHsgd2lkdGg6IG9iai5jYW52YXMud2lkdGggKyAncHgnIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBSR3JhcGguY2xlYXIob2JqLmNhbnZhcyk7alF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyAwICsgJ18nICsgb2JqLmlkKS5yZW1vdmUoKTtqUXVlcnkoJyMnICsgJ3JncmFwaF9oc2Npc3NvcnNfJyArIDEgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgMiArICdfJyArIG9iai5pZCkucmVtb3ZlKCk7alF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyAzICsgJ18nICsgb2JqLmlkKS5yZW1vdmUoKTtqUXVlcnkoJyMnICsgJ3JncmFwaF9oc2Npc3NvcnNfJyArIDQgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLnZTY2lzc29yc09wZW4gPSBSRy5FZmZlY3RzLkNvbW1vbi52c2Npc3NvcnNvcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgNjA7dmFyIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciB4eSA9IFJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3ZhciBjb2xvciA9IG9wdC5iYWNrZ3JvdW5kIHx8IG9wdC5jb2xvciB8fCBvcHQuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSc7dmFyIHh5ID0gUkcuZ2V0Q2FudmFzWFkodGhpcy5jYW52YXMpO3ZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gMTA7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2ZvciAodmFyIGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgICAgdmFyIGRpdiA9IGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF92c2Npc3NvcnNfXCIgKyBpICsgJ18nICsgb2JqLmlkKTtpZiAoIWRpdikge1xuICAgICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfdnNjaXNzb3JzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gb2JqLmNhbnZhcy5oZWlnaHQgKyAncHgnO2Rpdi5zdHlsZS5sZWZ0ID0geHlbMF0gKyBvYmouY2FudmFzLndpZHRoICogKGkgLyAxMCkgKyAncHgnO2Rpdi5zdHlsZS50b3AgPSB4eVsxXSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIH1cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIG9iai5pZCkuYW5pbWF0ZSh7IHRvcDogeHlbMV0gKyBvYmouY2FudmFzLmhlaWdodCArICdweCcsIGhlaWdodDogMCB9LCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqUXVlcnkoJyMnICsgJ3JncmFwaF92c2Npc3NvcnNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IDAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18wJyArICdfJyArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18xJyArICdfJyArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18yJyArICdfJyArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18zJyArICdfJyArIG9iai5pZCkpO2RvYy5ib2R5LnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc180JyArICdfJyArIG9iai5pZCkpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLkVmZmVjdHMuQ29tbW9uLnZzY2lzc29yc2Nsb3NlID0gUkcuRWZmZWN0cy5Db21tb24udlNjaXNzb3JzQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDt2YXIgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIHh5ID0gUkcuZ2V0Q2FudmFzWFkob2JqLmNhbnZhcyk7dmFyIGNvbG9yID0gb3B0LmJhY2tncm91bmQgfHwgb3B0LmNvbG9yIHx8IG9wdC5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJzt2YXIgeHkgPSBSRy5nZXRDYW52YXNYWSh0aGlzLmNhbnZhcyk7dmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyAxMDtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3ZzY2lzc29yc19cIiArIGkgKyAnXycgKyBvYmouaWQpO1xuICAgICAgaWYgKCFkaXYpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQgPSAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIG9iai5pZDtkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IDA7ZGl2LnN0eWxlLmxlZnQgPSB4eVswXSArIHdpZHRoICogaSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IChpICUgMiA9PSAwID8geHlbMV0gKyBvYmouY2FudmFzLmhlaWdodCA6IHh5WzFdKSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIH1cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIG9iai5pZCkuYW5pbWF0ZSh7IHRvcDogeHlbMV0gKyAncHgnLCBoZWlnaHQ6IG9iai5jYW52YXMuaGVpZ2h0ICsgJ3B4JyB9LCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqUXVlcnkoJyMnICsgJ3JncmFwaF92c2Npc3NvcnNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IG9iai5jYW52YXMuaGVpZ2h0ICsgJ3B4JyB9LCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGpRdWVyeSgnI3JncmFwaF92c2Npc3NvcnNfJyArIGkgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbik7cmV0dXJuIHRoaXM7XG4gIH07UkcuRWZmZWN0cy5Db21tb24uYW5pbWF0ZSA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICB2YXIgb2JqID0gdGhpcztvYmouZHJhdygpO3ZhciB0b3RhbEZyYW1lcyA9IG1hcCAmJiBtYXBbJ2ZyYW1lcyddID8gbWFwWydmcmFtZXMnXSA6IDMwO3ZhciBjdXJyZW50RnJhbWUgPSBuZXcgQXJyYXkoKTt2YXIgb3JpZ2luYWxWYWx1ZXMgPSBuZXcgQXJyYXkoKTt2YXIgZGlmZnMgPSBuZXcgQXJyYXkoKTt2YXIgc3RlcHMgPSBuZXcgQXJyYXkoKTt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICB2YXIgaWQgPSBbb2JqLmlkICsgJ18nICsgb2JqLnR5cGVdO2lmICghY3VycmVudEZyYW1lW2lkXSkge1xuICAgICAgICBjdXJyZW50RnJhbWVbaWRdID0gdG90YWxGcmFtZXM7b3JpZ2luYWxWYWx1ZXNbaWRdID0ge307ZGlmZnNbaWRdID0ge307c3RlcHNbaWRdID0ge307XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hcFtpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1hcFtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAoY3VycmVudEZyYW1lW2lkXSA9PSB0b3RhbEZyYW1lcykge1xuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbaWRdW2ldID0gb2JqLmdldChpKTtkaWZmc1tpZF1baV0gPSBtYXBbaV0gLSBvcmlnaW5hbFZhbHVlc1tpZF1baV07c3RlcHNbaWRdW2ldID0gZGlmZnNbaWRdW2ldIC8gdG90YWxGcmFtZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5zZXQoaSwgb2JqLmdldChpKSArIHN0ZXBzW2lkXVtpXSk7UkcuY2xlYXIob2JqLmNhbnZhcyk7b2JqLmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKC0tY3VycmVudEZyYW1lW2lkXSA+IDApIHtcbiAgICAgICAgUkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtcbiAgfTtcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uZWZmZWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///170\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HTML = RGraph.HTML || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.drawKey = RG.DrawKey = function (obj, key, colors) {\n    if (!key) {\n      return;\n    }\n    var ca = obj.canvas,\n        co = obj.context,\n        prop = obj.properties,\n        keypos = prop['chart.key.position'],\n        textsize = prop['chart.text.size'],\n        key_non_null = [],\n        colors_non_null = [];co.lineWidth = 1;co.beginPath();if (typeof prop['chart.key.vpos'] == 'number') {\n      obj.Set('chart.key.position.y', prop['chart.key.vpos'] * prop['chart.gutter.top']);\n    }\n    for (var i = 0; i < key.length; ++i) {\n      if (key[i] != null) {\n        colors_non_null.push(colors[i]);key_non_null.push(key[i]);\n      }\n    }\n    key = key_non_null;colors = colors_non_null;function DrawKey_graph(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'];var text_italic = prop['chart.key.text.italic'] ? true : false;\n      var text_bold = prop['chart.key.text.bold'] ? true : false;\n      var text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'];var gutterLeft = obj.gutterLeft;var gutterRight = obj.gutterRight;var gutterTop = obj.gutterTop;var gutterBottom = obj.gutterBottom;var hpos = prop['chart.yaxispos'] == 'right' ? gutterLeft + 10 : ca.width - gutterRight - 10;var vpos = gutterTop + 10;var title = prop['chart.title'];var blob_size = text_size;var hmargin = 8;var vmargin = 4;var fillstyle = prop['chart.key.background'];var text_color = prop['chart.key.text.color'];var strokestyle = '#333';var height = 0;var width = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = text_size + 'pt ' + prop['chart.text.font'];for (i = 0; i < key.length; ++i) {\n        width = Math.max(width, co.measureText(key[i]).width);\n      }\n      width += 5;width += blob_size;width += 5;width += 5;width += 5;if (prop['chart.yaxispos'] == 'left' || obj.type === 'pie' && !prop['chart.yaxispos'] || obj.type === 'hbar' && !prop['chart.yaxispos'] || obj.type === 'hbar' && prop['chart.yaxispos'] === 'center' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' || obj.type === 'rscatter' && !prop['chart.yaxispos'] || obj.type === 'radar' && !prop['chart.yaxispos'] || obj.type === 'rose' && !prop['chart.yaxispos'] || obj.type === 'funnel' && !prop['chart.yaxispos'] || obj.type === 'vprogress' && !prop['chart.yaxispos'] || obj.type === 'hprogress' && !prop['chart.yaxispos']) {\n        hpos -= width;\n      }\n      if (typeof prop['chart.key.halign'] == 'string') {\n        if (prop['chart.key.halign'] == 'left') {\n          hpos = gutterLeft + 10;\n        } else if (prop['chart.key.halign'] == 'right') {\n          hpos = ca.width - gutterRight - width;\n        }\n      }\n      if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (prop['chart.key.shadow']) {\n        co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n      }\n      co.beginPath();co.fillStyle = prop['chart.key.background'];co.strokeStyle = 'black';if (typeof prop['chart.key.position.graph.boxed'] == 'undefined' || typeof prop['chart.key.position.graph.boxed'] == 'boolean' && prop['chart.key.position.graph.boxed']) {\n        if (arguments[3] != false) {\n          co.lineWidth = typeof prop['chart.key.linewidth'] == 'number' ? prop['chart.key.linewidth'] : 1;if (prop['chart.key.rounded'] == true) {\n            co.beginPath();co.strokeStyle = strokestyle;RG.strokedCurvyRect(co, Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key), 4);co.stroke();co.fill();RG.NoShadow(obj);\n          } else {\n            co.strokeRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));co.fillRect(Math.round(hpos), Math.round(vpos), width - 5, 5 + (text_size + 5) * RG.getKeyLength(key));\n          }\n        }\n      }\n      RG.NoShadow(obj);co.beginPath();if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = key.length - 1; i >= 0; i--) {\n        var j = Number(i) + 1;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.arc(hpos + 5 + blob_size / 2, vpos + 5 * j + text_size * j - text_size + blob_size / 2, blob_size / 2, 0, 6.26, 0);co.fill();\n        } else if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'triangle') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(hpos + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.lineTo(hpos + blob_size / 2 + 5, vpos + 5 * j + text_size * j - text_size);co.lineTo(hpos + blob_size + 5, vpos + 5 * j + text_size * j - text_size + blob_size);co.closePath();co.fillStyle = colors[i];co.fill();\n        } else {\n          co.fillStyle = colors[i];co.fillRect(hpos + 5, vpos + 5 * j + text_size * j - text_size, text_size, text_size + 1);\n        }\n        co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) == 'object' ? text_color[i] : text_color;ret = RG.Text2(obj, { 'font': text_font, 'size': text_size, 'bold': text_bold, 'italic': text_italic, 'x': hpos + blob_size + 5 + 5, 'y': vpos + 5 * j + text_size * j + 3, 'text': key[i], 'accessible': !obj.properties['chart.key.interactive'] });obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n      co.fill();\n    }\n    function DrawKey_gutter(obj, key, colors) {\n      var text_size = typeof prop['chart.key.text.size'] == 'number' ? prop['chart.key.text.size'] : prop['chart.text.size'],\n          text_bold = prop['chart.key.text.bold'],\n          text_italic = prop['chart.key.text.italic'],\n          text_font = prop['chart.key.text.font'] || prop['chart.key.font'] || prop['chart.text.font'],\n          text_color = prop['chart.key.text.color'],\n          gutterLeft = obj.gutterLeft,\n          gutterRight = obj.gutterRight,\n          gutterTop = obj.gutterTop,\n          gutterBottom = obj.gutterBottom,\n          hpos = (ca.width - gutterLeft - gutterRight) / 2 + obj.gutterLeft,\n          vpos = gutterTop - text_size - 5,\n          title = prop['chart.title'],\n          blob_size = text_size,\n          hmargin = 8,\n          vmargin = 4,\n          fillstyle = prop['chart.key.background'],\n          strokestyle = '#999',\n          length = 0;if (!obj.coords) obj.coords = {};obj.coords.key = [];co.font = (obj.properties['chart.key.text.italic'] ? 'italic ' : '') + (obj.properties['chart.key.text.bold'] ? 'bold ' : '') + text_size + 'pt ' + text_font;for (i = 0; i < key.length; ++i) {\n        length += hmargin;length += blob_size;length += hmargin;length += co.measureText(key[i]).width;\n      }\n      length += hmargin;if (obj.type == 'pie') {\n        if (prop['chart.align'] == 'left') {\n          var hpos = obj.radius + gutterLeft;\n        } else if (prop['chart.align'] == 'right') {\n          var hpos = ca.width - obj.radius - gutterRight;\n        } else {\n          hpos = ca.width / 2;\n        }\n      }\n      hpos -= length / 2;if (typeof prop['chart.key.position.x'] == 'number') {\n        hpos = prop['chart.key.position.x'];\n      }\n      if (typeof prop['chart.key.position.y'] == 'number') {\n        vpos = prop['chart.key.position.y'];\n      }\n      if (obj.Get('chart.key.position.gutter.boxed')) {\n        if (prop['chart.key.shadow']) {\n          co.shadowColor = prop['chart.key.shadow.color'];co.shadowBlur = prop['chart.key.shadow.blur'];co.shadowOffsetX = prop['chart.key.shadow.offsetx'];co.shadowOffsetY = prop['chart.key.shadow.offsety'];\n        }\n        co.beginPath();co.fillStyle = fillstyle;co.strokeStyle = strokestyle;if (prop['chart.key.rounded']) {\n          RG.strokedCurvyRect(co, hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        } else {\n          co.rect(hpos, vpos - vmargin, length, text_size + vmargin + vmargin);\n        }\n        co.stroke();co.fill();RG.NoShadow(obj);\n      }\n      if (prop['chart.key.colors']) {\n        colors = prop['chart.key.colors'];\n      }\n      for (var i = 0, pos = hpos; i < key.length; ++i) {\n        pos += hmargin;if (_typeof(prop['chart.key.color.shape']) == 'object' && typeof prop['chart.key.color.shape'][i] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'][i];\n        } else if (typeof prop['chart.key.color.shape'] == 'string') {\n          var blob_shape = prop['chart.key.color.shape'];\n        } else {\n          var blob_shape = 'square';\n        }\n        if (blob_shape == 'line') {\n          co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.lineTo(pos + blob_size, vpos + blob_size / 2);co.stroke();\n        } else if (blob_shape == 'circle') {\n          co.beginPath();co.fillStyle = colors[i];co.moveTo(pos, vpos + blob_size / 2);co.arc(pos + blob_size / 2, vpos + blob_size / 2, blob_size / 2, 0, 6.28, 0);co.fill();\n        } else if (blob_shape == 'triangle') {\n          co.fillStyle = colors[i];co.beginPath();co.strokeStyle = colors[i];co.moveTo(pos, vpos + blob_size);co.lineTo(pos + blob_size / 2, vpos);co.lineTo(pos + blob_size, vpos + blob_size);co.closePath();co.fill();\n        } else {\n          co.beginPath();co.fillStyle = colors[i];co.rect(pos, vpos, blob_size, blob_size);co.fill();\n        }\n        pos += blob_size;pos += hmargin;co.beginPath();co.fillStyle = (typeof text_color === 'undefined' ? 'undefined' : _typeof(text_color)) === 'object' ? text_color[i] : text_color;var ret = RG.Text2(obj, { 'font': text_font, 'bold': text_bold, 'size': text_size, 'italic': text_italic, 'x': pos, 'y': vpos + text_size + 3, 'text': key[i], accessible: !obj.properties['chart.key.interactive'] });co.fill();pos += co.measureText(key[i]).width;obj.coords.key[i] = [ret.x, ret.y, ret.width, ret.height, key[i], colors[i], obj];\n      }\n    }\n    if (keypos && keypos == 'gutter') {\n      DrawKey_gutter(obj, key, colors);\n    } else if (keypos && keypos == 'graph') {\n      DrawKey_graph(obj, key, colors);\n    } else {\n      alert('[COMMON] (' + obj.id + ') Unknown key position: ' + keypos);\n    }\n    if (prop['chart.key.interactive']) {\n      if (!RGraph.Drawing || !RGraph.Drawing.Rect) {\n        alert('[INTERACTIVE KEY] The drawing API Rect library does not appear to have been included (which the interactive key uses)');\n      }\n      if (!RGraph.InstallWindowMousedownListener) {\n        alert('[INTERACTIVE KEY] The dynamic library does not appear to have been included');\n      }\n      for (var i = 0, len = obj.coords.key.length, maxlen = 0; i < len; i += 1) {\n        maxlen = Math.max(maxlen, obj.coords.key[i][2]);\n      }\n      for (var i = 0, len = obj.coords.key.length; i < len; i += 1) {\n        (function (idx) {\n          var arr = obj.coords.key;var value = obj.coords.key[idx];var index = idx;var rect = new RGraph.Drawing.Rect(obj.id, value[0], value[1], prop['chart.key.position'] == 'gutter' ? value[2] : maxlen, value[3]).Set('fillstyle', 'rgba(0,0,0,0)').Draw();rect.onclick = function (e, shape) {\n            var co = rect.context;co.fillStyle = prop['chart.key.interactive.highlight.label'];co.fillRect(shape.x, shape.y, shape.width, shape.height);if (typeof obj.interactiveKeyHighlight == 'function') {\n              obj.Set('chart.key.interactive.index', idx);RG.FireCustomEvent(obj, 'onbeforeinteractivekey');obj.interactiveKeyHighlight(index);RG.FireCustomEvent(obj, 'onafterinteractivekey');\n            }\n          };\n          rect.onmousemove = function (e, shape) {\n            return true;\n          };\n        })(i);\n      }\n    }\n  };RG.getKeyLength = function (key) {\n    var length = 0;for (var i = 0, len = key.length; i < len; i += 1) {\n      if (key[i] != null) {\n        ++length;\n      }\n    }\n    return length;\n  };RGraph.HTML.key = RGraph.HTML.Key = function (id, prop) {\n    var div = doc.getElementById(id);var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n      var style = '';\n      for (i in prop.tableCss) {\n        if (typeof i === 'string') {\n          style = style + i + ': ' + prop.tableCss[i] + ';';\n        }\n      }\n      return style;\n    }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';for (var i = 0; i < prop.labels.length; i += 1) {\n      str += '<tr><td><div style=\"' + function () {\n        var style = '';for (var j in prop.blobCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.blobCss[j] + ';';\n          }\n        }\n        return style;\n      }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n        var style = '';for (var j in prop.labelCss) {\n          if (typeof j === 'string') {\n            style = style + j + ': ' + prop.labelCss[j] + ';';\n          }\n        }\n        return style;\n      }() + '\" ' + function () {\n        var style = '';if (prop['labelCss_' + i]) {\n          for (var j in prop['labelCss_' + i]) {\n            style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n          }\n        }\n        return style ? 'style=\"' + style + '\"' : '';\n      }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n    }\n    div.innerHTML += str + '</table>';return doc.getElementById('rgraph_key');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24ua2V5LmpzP2YwYjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguSFRNTCA9IFJHcmFwaC5IVE1MIHx8IHt9OyhmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGg7UkcuZHJhd0tleSA9IFJHLkRyYXdLZXkgPSBmdW5jdGlvbiAob2JqLCBrZXksIGNvbG9ycykge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYSA9IG9iai5jYW52YXMsXG4gICAgICAgIGNvID0gb2JqLmNvbnRleHQsXG4gICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcyxcbiAgICAgICAga2V5cG9zID0gcHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uJ10sXG4gICAgICAgIHRleHRzaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIGtleV9ub25fbnVsbCA9IFtdLFxuICAgICAgICBjb2xvcnNfbm9uX251bGwgPSBbXTtjby5saW5lV2lkdGggPSAxO2NvLmJlZ2luUGF0aCgpO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQua2V5LnZwb3MnXSA9PSAnbnVtYmVyJykge1xuICAgICAgb2JqLlNldCgnY2hhcnQua2V5LnBvc2l0aW9uLnknLCBwcm9wWydjaGFydC5rZXkudnBvcyddICogcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChrZXlbaV0gIT0gbnVsbCkge1xuICAgICAgICBjb2xvcnNfbm9uX251bGwucHVzaChjb2xvcnNbaV0pO2tleV9ub25fbnVsbC5wdXNoKGtleVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGtleSA9IGtleV9ub25fbnVsbDtjb2xvcnMgPSBjb2xvcnNfbm9uX251bGw7ZnVuY3Rpb24gRHJhd0tleV9ncmFwaChvYmosIGtleSwgY29sb3JzKSB7XG4gICAgICB2YXIgdGV4dF9zaXplID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmtleS50ZXh0LnNpemUnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmtleS50ZXh0LnNpemUnXSA6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB0ZXh0X2l0YWxpYyA9IHByb3BbJ2NoYXJ0LmtleS50ZXh0Lml0YWxpYyddID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgdmFyIHRleHRfYm9sZCA9IHByb3BbJ2NoYXJ0LmtleS50ZXh0LmJvbGQnXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIHZhciB0ZXh0X2ZvbnQgPSBwcm9wWydjaGFydC5rZXkudGV4dC5mb250J10gfHwgcHJvcFsnY2hhcnQua2V5LmZvbnQnXSB8fCBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgZ3V0dGVyTGVmdCA9IG9iai5ndXR0ZXJMZWZ0O3ZhciBndXR0ZXJSaWdodCA9IG9iai5ndXR0ZXJSaWdodDt2YXIgZ3V0dGVyVG9wID0gb2JqLmd1dHRlclRvcDt2YXIgZ3V0dGVyQm90dG9tID0gb2JqLmd1dHRlckJvdHRvbTt2YXIgaHBvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0JyA/IGd1dHRlckxlZnQgKyAxMCA6IGNhLndpZHRoIC0gZ3V0dGVyUmlnaHQgLSAxMDt2YXIgdnBvcyA9IGd1dHRlclRvcCArIDEwO3ZhciB0aXRsZSA9IHByb3BbJ2NoYXJ0LnRpdGxlJ107dmFyIGJsb2Jfc2l6ZSA9IHRleHRfc2l6ZTt2YXIgaG1hcmdpbiA9IDg7dmFyIHZtYXJnaW4gPSA0O3ZhciBmaWxsc3R5bGUgPSBwcm9wWydjaGFydC5rZXkuYmFja2dyb3VuZCddO3ZhciB0ZXh0X2NvbG9yID0gcHJvcFsnY2hhcnQua2V5LnRleHQuY29sb3InXTt2YXIgc3Ryb2tlc3R5bGUgPSAnIzMzMyc7dmFyIGhlaWdodCA9IDA7dmFyIHdpZHRoID0gMDtpZiAoIW9iai5jb29yZHMpIG9iai5jb29yZHMgPSB7fTtvYmouY29vcmRzLmtleSA9IFtdO2NvLmZvbnQgPSB0ZXh0X3NpemUgKyAncHQgJyArIHByb3BbJ2NoYXJ0LnRleHQuZm9udCddO2ZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY28ubWVhc3VyZVRleHQoa2V5W2ldKS53aWR0aCk7XG4gICAgICB9XG4gICAgICB3aWR0aCArPSA1O3dpZHRoICs9IGJsb2Jfc2l6ZTt3aWR0aCArPSA1O3dpZHRoICs9IDU7d2lkdGggKz0gNTtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgfHwgb2JqLnR5cGUgPT09ICdwaWUnICYmICFwcm9wWydjaGFydC55YXhpc3BvcyddIHx8IG9iai50eXBlID09PSAnaGJhcicgJiYgIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gfHwgb2JqLnR5cGUgPT09ICdoYmFyJyAmJiBwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAnY2VudGVyJyB8fCBvYmoudHlwZSA9PT0gJ2hiYXInICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcgfHwgb2JqLnR5cGUgPT09ICdyc2NhdHRlcicgJiYgIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gfHwgb2JqLnR5cGUgPT09ICdyYWRhcicgJiYgIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gfHwgb2JqLnR5cGUgPT09ICdyb3NlJyAmJiAhcHJvcFsnY2hhcnQueWF4aXNwb3MnXSB8fCBvYmoudHlwZSA9PT0gJ2Z1bm5lbCcgJiYgIXByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gfHwgb2JqLnR5cGUgPT09ICd2cHJvZ3Jlc3MnICYmICFwcm9wWydjaGFydC55YXhpc3BvcyddIHx8IG9iai50eXBlID09PSAnaHByb2dyZXNzJyAmJiAhcHJvcFsnY2hhcnQueWF4aXNwb3MnXSkge1xuICAgICAgICBocG9zIC09IHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5rZXkuaGFsaWduJ10gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmtleS5oYWxpZ24nXSA9PSAnbGVmdCcpIHtcbiAgICAgICAgICBocG9zID0gZ3V0dGVyTGVmdCArIDEwO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmtleS5oYWxpZ24nXSA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgaHBvcyA9IGNhLndpZHRoIC0gZ3V0dGVyUmlnaHQgLSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5rZXkucG9zaXRpb24ueCddID09ICdudW1iZXInKSB7XG4gICAgICAgIGhwb3MgPSBwcm9wWydjaGFydC5rZXkucG9zaXRpb24ueCddO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5rZXkucG9zaXRpb24ueSddID09ICdudW1iZXInKSB7XG4gICAgICAgIHZwb3MgPSBwcm9wWydjaGFydC5rZXkucG9zaXRpb24ueSddO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cnXSkge1xuICAgICAgICBjby5zaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQua2V5LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WCA9IHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknXTtcbiAgICAgIH1cbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmtleS5iYWNrZ3JvdW5kJ107Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uLmdyYXBoLmJveGVkJ10gPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi5ncmFwaC5ib3hlZCddID09ICdib29sZWFuJyAmJiBwcm9wWydjaGFydC5rZXkucG9zaXRpb24uZ3JhcGguYm94ZWQnXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzNdICE9IGZhbHNlKSB7XG4gICAgICAgICAgY28ubGluZVdpZHRoID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5saW5ld2lkdGgnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmtleS5saW5ld2lkdGgnXSA6IDE7aWYgKHByb3BbJ2NoYXJ0LmtleS5yb3VuZGVkJ10gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBzdHJva2VzdHlsZTtSRy5zdHJva2VkQ3VydnlSZWN0KGNvLCBNYXRoLnJvdW5kKGhwb3MpLCBNYXRoLnJvdW5kKHZwb3MpLCB3aWR0aCAtIDUsIDUgKyAodGV4dF9zaXplICsgNSkgKiBSRy5nZXRLZXlMZW5ndGgoa2V5KSwgNCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvLnN0cm9rZVJlY3QoTWF0aC5yb3VuZChocG9zKSwgTWF0aC5yb3VuZCh2cG9zKSwgd2lkdGggLSA1LCA1ICsgKHRleHRfc2l6ZSArIDUpICogUkcuZ2V0S2V5TGVuZ3RoKGtleSkpO2NvLmZpbGxSZWN0KE1hdGgucm91bmQoaHBvcyksIE1hdGgucm91bmQodnBvcyksIHdpZHRoIC0gNSwgNSArICh0ZXh0X3NpemUgKyA1KSAqIFJHLmdldEtleUxlbmd0aChrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJHLk5vU2hhZG93KG9iaik7Y28uYmVnaW5QYXRoKCk7aWYgKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSkge1xuICAgICAgICBjb2xvcnMgPSBwcm9wWydjaGFydC5rZXkuY29sb3JzJ107XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBqID0gTnVtYmVyKGkpICsgMTtpZiAoX3R5cGVvZihwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddW2ldID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJsb2Jfc2hhcGUgPSBwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXVtpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ10gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgYmxvYl9zaGFwZSA9IHByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBibG9iX3NoYXBlID0gJ3NxdWFyZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2Jfc2hhcGUgPT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBjb2xvcnNbaV07Y28uYXJjKGhwb3MgKyA1ICsgYmxvYl9zaXplIC8gMiwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSArIGJsb2Jfc2l6ZSAvIDIsIGJsb2Jfc2l6ZSAvIDIsIDAsIDYuMjYsIDApO2NvLmZpbGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChibG9iX3NoYXBlID09ICdsaW5lJykge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO2NvLm1vdmVUbyhocG9zICsgNSwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSArIGJsb2Jfc2l6ZSAvIDIpO2NvLmxpbmVUbyhocG9zICsgYmxvYl9zaXplICsgNSwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSArIGJsb2Jfc2l6ZSAvIDIpO2NvLnN0cm9rZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2Jfc2hhcGUgPT0gJ3RyaWFuZ2xlJykge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO2NvLm1vdmVUbyhocG9zICsgNSwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSArIGJsb2Jfc2l6ZSk7Y28ubGluZVRvKGhwb3MgKyBibG9iX3NpemUgLyAyICsgNSwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSk7Y28ubGluZVRvKGhwb3MgKyBibG9iX3NpemUgKyA1LCB2cG9zICsgNSAqIGogKyB0ZXh0X3NpemUgKiBqIC0gdGV4dF9zaXplICsgYmxvYl9zaXplKTtjby5jbG9zZVBhdGgoKTtjby5maWxsU3R5bGUgPSBjb2xvcnNbaV07Y28uZmlsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IGNvbG9yc1tpXTtjby5maWxsUmVjdChocG9zICsgNSwgdnBvcyArIDUgKiBqICsgdGV4dF9zaXplICogaiAtIHRleHRfc2l6ZSwgdGV4dF9zaXplLCB0ZXh0X3NpemUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSAodHlwZW9mIHRleHRfY29sb3IgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRleHRfY29sb3IpKSA9PSAnb2JqZWN0JyA/IHRleHRfY29sb3JbaV0gOiB0ZXh0X2NvbG9yO3JldCA9IFJHLlRleHQyKG9iaiwgeyAnZm9udCc6IHRleHRfZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICdib2xkJzogdGV4dF9ib2xkLCAnaXRhbGljJzogdGV4dF9pdGFsaWMsICd4JzogaHBvcyArIGJsb2Jfc2l6ZSArIDUgKyA1LCAneSc6IHZwb3MgKyA1ICogaiArIHRleHRfc2l6ZSAqIGogKyAzLCAndGV4dCc6IGtleVtpXSwgJ2FjY2Vzc2libGUnOiAhb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSddIH0pO29iai5jb29yZHMua2V5W2ldID0gW3JldC54LCByZXQueSwgcmV0LndpZHRoLCByZXQuaGVpZ2h0LCBrZXlbaV0sIGNvbG9yc1tpXSwgb2JqXTtcbiAgICAgIH1cbiAgICAgIGNvLmZpbGwoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRHJhd0tleV9ndXR0ZXIob2JqLCBrZXksIGNvbG9ycykge1xuICAgICAgdmFyIHRleHRfc2l6ZSA9IHR5cGVvZiBwcm9wWydjaGFydC5rZXkudGV4dC5zaXplJ10gPT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5rZXkudGV4dC5zaXplJ10gOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgICB0ZXh0X2JvbGQgPSBwcm9wWydjaGFydC5rZXkudGV4dC5ib2xkJ10sXG4gICAgICAgICAgdGV4dF9pdGFsaWMgPSBwcm9wWydjaGFydC5rZXkudGV4dC5pdGFsaWMnXSxcbiAgICAgICAgICB0ZXh0X2ZvbnQgPSBwcm9wWydjaGFydC5rZXkudGV4dC5mb250J10gfHwgcHJvcFsnY2hhcnQua2V5LmZvbnQnXSB8fCBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgICB0ZXh0X2NvbG9yID0gcHJvcFsnY2hhcnQua2V5LnRleHQuY29sb3InXSxcbiAgICAgICAgICBndXR0ZXJMZWZ0ID0gb2JqLmd1dHRlckxlZnQsXG4gICAgICAgICAgZ3V0dGVyUmlnaHQgPSBvYmouZ3V0dGVyUmlnaHQsXG4gICAgICAgICAgZ3V0dGVyVG9wID0gb2JqLmd1dHRlclRvcCxcbiAgICAgICAgICBndXR0ZXJCb3R0b20gPSBvYmouZ3V0dGVyQm90dG9tLFxuICAgICAgICAgIGhwb3MgPSAoY2Eud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQpIC8gMiArIG9iai5ndXR0ZXJMZWZ0LFxuICAgICAgICAgIHZwb3MgPSBndXR0ZXJUb3AgLSB0ZXh0X3NpemUgLSA1LFxuICAgICAgICAgIHRpdGxlID0gcHJvcFsnY2hhcnQudGl0bGUnXSxcbiAgICAgICAgICBibG9iX3NpemUgPSB0ZXh0X3NpemUsXG4gICAgICAgICAgaG1hcmdpbiA9IDgsXG4gICAgICAgICAgdm1hcmdpbiA9IDQsXG4gICAgICAgICAgZmlsbHN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmJhY2tncm91bmQnXSxcbiAgICAgICAgICBzdHJva2VzdHlsZSA9ICcjOTk5JyxcbiAgICAgICAgICBsZW5ndGggPSAwO2lmICghb2JqLmNvb3Jkcykgb2JqLmNvb3JkcyA9IHt9O29iai5jb29yZHMua2V5ID0gW107Y28uZm9udCA9IChvYmoucHJvcGVydGllc1snY2hhcnQua2V5LnRleHQuaXRhbGljJ10gPyAnaXRhbGljICcgOiAnJykgKyAob2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmtleS50ZXh0LmJvbGQnXSA/ICdib2xkICcgOiAnJykgKyB0ZXh0X3NpemUgKyAncHQgJyArIHRleHRfZm9udDtmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBobWFyZ2luO2xlbmd0aCArPSBibG9iX3NpemU7bGVuZ3RoICs9IGhtYXJnaW47bGVuZ3RoICs9IGNvLm1lYXN1cmVUZXh0KGtleVtpXSkud2lkdGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggKz0gaG1hcmdpbjtpZiAob2JqLnR5cGUgPT0gJ3BpZScpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdmFyIGhwb3MgPSBvYmoucmFkaXVzICsgZ3V0dGVyTGVmdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5hbGlnbiddID09ICdyaWdodCcpIHtcbiAgICAgICAgICB2YXIgaHBvcyA9IGNhLndpZHRoIC0gb2JqLnJhZGl1cyAtIGd1dHRlclJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhwb3MgPSBjYS53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhwb3MgLT0gbGVuZ3RoIC8gMjtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi54J10gPT0gJ251bWJlcicpIHtcbiAgICAgICAgaHBvcyA9IHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi54J107XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi55J10gPT0gJ251bWJlcicpIHtcbiAgICAgICAgdnBvcyA9IHByb3BbJ2NoYXJ0LmtleS5wb3NpdGlvbi55J107XG4gICAgICB9XG4gICAgICBpZiAob2JqLkdldCgnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCcpKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5rZXkuc2hhZG93J10pIHtcbiAgICAgICAgICBjby5zaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQua2V5LnNoYWRvdy5ibHVyJ107Y28uc2hhZG93T2Zmc2V0WCA9IHByb3BbJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknXTtcbiAgICAgICAgfVxuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBmaWxsc3R5bGU7Y28uc3Ryb2tlU3R5bGUgPSBzdHJva2VzdHlsZTtpZiAocHJvcFsnY2hhcnQua2V5LnJvdW5kZWQnXSkge1xuICAgICAgICAgIFJHLnN0cm9rZWRDdXJ2eVJlY3QoY28sIGhwb3MsIHZwb3MgLSB2bWFyZ2luLCBsZW5ndGgsIHRleHRfc2l6ZSArIHZtYXJnaW4gKyB2bWFyZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5yZWN0KGhwb3MsIHZwb3MgLSB2bWFyZ2luLCBsZW5ndGgsIHRleHRfc2l6ZSArIHZtYXJnaW4gKyB2bWFyZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2UoKTtjby5maWxsKCk7UkcuTm9TaGFkb3cob2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pIHtcbiAgICAgICAgY29sb3JzID0gcHJvcFsnY2hhcnQua2V5LmNvbG9ycyddO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IGhwb3M7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcG9zICs9IGhtYXJnaW47aWYgKF90eXBlb2YocHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ10pID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXVtpXSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBibG9iX3NoYXBlID0gcHJvcFsnY2hhcnQua2V5LmNvbG9yLnNoYXBlJ11baV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSddID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJsb2Jfc2hhcGUgPSBwcm9wWydjaGFydC5rZXkuY29sb3Iuc2hhcGUnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYmxvYl9zaGFwZSA9ICdzcXVhcmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9iX3NoYXBlID09ICdsaW5lJykge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO2NvLm1vdmVUbyhwb3MsIHZwb3MgKyBibG9iX3NpemUgLyAyKTtjby5saW5lVG8ocG9zICsgYmxvYl9zaXplLCB2cG9zICsgYmxvYl9zaXplIC8gMik7Y28uc3Ryb2tlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvYl9zaGFwZSA9PSAnY2lyY2xlJykge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGNvbG9yc1tpXTtjby5tb3ZlVG8ocG9zLCB2cG9zICsgYmxvYl9zaXplIC8gMik7Y28uYXJjKHBvcyArIGJsb2Jfc2l6ZSAvIDIsIHZwb3MgKyBibG9iX3NpemUgLyAyLCBibG9iX3NpemUgLyAyLCAwLCA2LjI4LCAwKTtjby5maWxsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvYl9zaGFwZSA9PSAndHJpYW5nbGUnKSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gY29sb3JzW2ldO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO2NvLm1vdmVUbyhwb3MsIHZwb3MgKyBibG9iX3NpemUpO2NvLmxpbmVUbyhwb3MgKyBibG9iX3NpemUgLyAyLCB2cG9zKTtjby5saW5lVG8ocG9zICsgYmxvYl9zaXplLCB2cG9zICsgYmxvYl9zaXplKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gY29sb3JzW2ldO2NvLnJlY3QocG9zLCB2cG9zLCBibG9iX3NpemUsIGJsb2Jfc2l6ZSk7Y28uZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBibG9iX3NpemU7cG9zICs9IGhtYXJnaW47Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gKHR5cGVvZiB0ZXh0X2NvbG9yID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0ZXh0X2NvbG9yKSkgPT09ICdvYmplY3QnID8gdGV4dF9jb2xvcltpXSA6IHRleHRfY29sb3I7dmFyIHJldCA9IFJHLlRleHQyKG9iaiwgeyAnZm9udCc6IHRleHRfZm9udCwgJ2JvbGQnOiB0ZXh0X2JvbGQsICdzaXplJzogdGV4dF9zaXplLCAnaXRhbGljJzogdGV4dF9pdGFsaWMsICd4JzogcG9zLCAneSc6IHZwb3MgKyB0ZXh0X3NpemUgKyAzLCAndGV4dCc6IGtleVtpXSwgYWNjZXNzaWJsZTogIW9iai5wcm9wZXJ0aWVzWydjaGFydC5rZXkuaW50ZXJhY3RpdmUnXSB9KTtjby5maWxsKCk7cG9zICs9IGNvLm1lYXN1cmVUZXh0KGtleVtpXSkud2lkdGg7b2JqLmNvb3Jkcy5rZXlbaV0gPSBbcmV0LngsIHJldC55LCByZXQud2lkdGgsIHJldC5oZWlnaHQsIGtleVtpXSwgY29sb3JzW2ldLCBvYmpdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cG9zICYmIGtleXBvcyA9PSAnZ3V0dGVyJykge1xuICAgICAgRHJhd0tleV9ndXR0ZXIob2JqLCBrZXksIGNvbG9ycyk7XG4gICAgfSBlbHNlIGlmIChrZXlwb3MgJiYga2V5cG9zID09ICdncmFwaCcpIHtcbiAgICAgIERyYXdLZXlfZ3JhcGgob2JqLCBrZXksIGNvbG9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsZXJ0KCdbQ09NTU9OXSAoJyArIG9iai5pZCArICcpIFVua25vd24ga2V5IHBvc2l0aW9uOiAnICsga2V5cG9zKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSddKSB7XG4gICAgICBpZiAoIVJHcmFwaC5EcmF3aW5nIHx8ICFSR3JhcGguRHJhd2luZy5SZWN0KSB7XG4gICAgICAgIGFsZXJ0KCdbSU5URVJBQ1RJVkUgS0VZXSBUaGUgZHJhd2luZyBBUEkgUmVjdCBsaWJyYXJ5IGRvZXMgbm90IGFwcGVhciB0byBoYXZlIGJlZW4gaW5jbHVkZWQgKHdoaWNoIHRoZSBpbnRlcmFjdGl2ZSBrZXkgdXNlcyknKTtcbiAgICAgIH1cbiAgICAgIGlmICghUkdyYXBoLkluc3RhbGxXaW5kb3dNb3VzZWRvd25MaXN0ZW5lcikge1xuICAgICAgICBhbGVydCgnW0lOVEVSQUNUSVZFIEtFWV0gVGhlIGR5bmFtaWMgbGlicmFyeSBkb2VzIG5vdCBhcHBlYXIgdG8gaGF2ZSBiZWVuIGluY2x1ZGVkJyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5rZXkubGVuZ3RoLCBtYXhsZW4gPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbWF4bGVuID0gTWF0aC5tYXgobWF4bGVuLCBvYmouY29vcmRzLmtleVtpXVsyXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5rZXkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB2YXIgYXJyID0gb2JqLmNvb3Jkcy5rZXk7dmFyIHZhbHVlID0gb2JqLmNvb3Jkcy5rZXlbaWR4XTt2YXIgaW5kZXggPSBpZHg7dmFyIHJlY3QgPSBuZXcgUkdyYXBoLkRyYXdpbmcuUmVjdChvYmouaWQsIHZhbHVlWzBdLCB2YWx1ZVsxXSwgcHJvcFsnY2hhcnQua2V5LnBvc2l0aW9uJ10gPT0gJ2d1dHRlcicgPyB2YWx1ZVsyXSA6IG1heGxlbiwgdmFsdWVbM10pLlNldCgnZmlsbHN0eWxlJywgJ3JnYmEoMCwwLDAsMCknKS5EcmF3KCk7cmVjdC5vbmNsaWNrID0gZnVuY3Rpb24gKGUsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgY28gPSByZWN0LmNvbnRleHQ7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5sYWJlbCddO2NvLmZpbGxSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO2lmICh0eXBlb2Ygb2JqLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb2JqLlNldCgnY2hhcnQua2V5LmludGVyYWN0aXZlLmluZGV4JywgaWR4KTtSRy5GaXJlQ3VzdG9tRXZlbnQob2JqLCAnb25iZWZvcmVpbnRlcmFjdGl2ZWtleScpO29iai5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodChpbmRleCk7UkcuRmlyZUN1c3RvbUV2ZW50KG9iaiwgJ29uYWZ0ZXJpbnRlcmFjdGl2ZWtleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjdC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlLCBzaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1JHLmdldEtleUxlbmd0aCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gMDtmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoa2V5W2ldICE9IG51bGwpIHtcbiAgICAgICAgKytsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG4gIH07UkdyYXBoLkhUTUwua2V5ID0gUkdyYXBoLkhUTUwuS2V5ID0gZnVuY3Rpb24gKGlkLCBwcm9wKSB7XG4gICAgdmFyIGRpdiA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCk7dmFyIHN0ciA9ICc8dGFibGUgYm9yZGVyPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGNlbGxwYWRkaW5nPVwiMFwiIGlkPVwicmdyYXBoX2tleVwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lOycgKyBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3R5bGUgPSAnJztcbiAgICAgIGZvciAoaSBpbiBwcm9wLnRhYmxlQ3NzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHlsZSA9IHN0eWxlICsgaSArICc6ICcgKyBwcm9wLnRhYmxlQ3NzW2ldICsgJzsnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSgpICsgJ1wiICcgKyAocHJvcC50YWJsZUNsYXNzID8gJ2NsYXNzPVwiJyArIHByb3AudGFibGVDbGFzcyArICdcIicgOiAnJykgKyAnPic7Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wLmxhYmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc3RyICs9ICc8dHI+PHRkPjxkaXYgc3R5bGU9XCInICsgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSAnJztmb3IgKHZhciBqIGluIHByb3AuYmxvYkNzcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGUgKyBqICsgJzogJyArIHByb3AuYmxvYkNzc1tqXSArICc7JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSgpICsgJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLXJpZ2h0OiA1cHg7IG1hcmdpbi10b3A6IDRweDsgd2lkdGg6IDE1cHg7IGhlaWdodDogMTVweDsgYmFja2dyb3VuZC1jb2xvcjogJyArIHByb3AuY29sb3JzW2ldICsgJ1wiJyArIChwcm9wLmJsb2JDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmJsb2JDbGFzcyArICdcIicgOiAnJykgKyAnPiZuYnNwOzwvZGl2Pjx0ZD4nICsgKHByb3AubGlua3MgJiYgcHJvcC5saW5rc1tpXSA/ICc8YSBocmVmPVwiJyArIHByb3AubGlua3NbaV0gKyAnXCI+JyA6ICcnKSArICc8c3BhbiAnICsgKHByb3AubGFiZWxDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmxhYmVsQ2xhc3MgKyAnXCInIDogJycpICsgJ1wiIHN0eWxlPVwiJyArIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gJyc7Zm9yICh2YXIgaiBpbiBwcm9wLmxhYmVsQ3NzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSArIGogKyAnOiAnICsgcHJvcC5sYWJlbENzc1tqXSArICc7JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSgpICsgJ1wiICcgKyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9ICcnO2lmIChwcm9wWydsYWJlbENzc18nICsgaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqIGluIHByb3BbJ2xhYmVsQ3NzXycgKyBpXSkge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSArIGogKyAnOiAnICsgcHJvcFsnbGFiZWxDc3NfJyArIGldW2pdICsgJzsnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGUgPyAnc3R5bGU9XCInICsgc3R5bGUgKyAnXCInIDogJyc7XG4gICAgICB9KCkgKyAnPicgKyBwcm9wLmxhYmVsc1tpXSArICc8L3NwYW4+JyArIChwcm9wLmxpbmtzICYmIHByb3AubGlua3NbaV0gPyAnPC9hPicgOiAnJykgKyAnPC90ZD48L3RyPic7XG4gICAgfVxuICAgIGRpdi5pbm5lckhUTUwgKz0gc3RyICsgJzwvdGFibGU+JztyZXR1cm4gZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfa2V5Jyk7XG4gIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLmtleS5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///171\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      active = null;RGraph.allowResizing = RGraph.AllowResizing = function (obj) {\n    var ca = obj.canvas,\n        co = obj.context,\n        pa2 = RG.path2;ca.resizing = ca.resizing || {};ca.resizing.placeHolders = ca.resizing.placeHolders || [];if (!ca.resizing.originalw) {\n      ca.resizing.originalw = ca.width;\n    }\n    if (!ca.resizing.originalh) {\n      ca.resizing.originalh = ca.height;\n    }\n    var resizeHandleSize = 15;if (!ca.resizing.__rgraph_original_width__ || !ca.resizing.__rgraph_original_height__ || !ca.resizing.__adjustX || !ca.resizing.__adjustY) {\n      ca.resizing.__rgraph_original_width__ = ca.width;ca.resizing.__rgraph_original_height__ = ca.height;ca.resizing.adjustX = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[0] == 'number' ? obj.Get('chart.resize.handle.adjust')[0] : 0;ca.resizing.adjustY = _typeof(obj.get('chart.resize.handle.adjust')) == 'object' && typeof obj.get('chart.resize.handle.adjust')[1] == 'number' ? obj.Get('chart.resize.handle.adjust')[1] : 0;ca.resizing.bgcolor = obj.get('chart.resize.handle.background') || 'rgba(0,0,0,0)';\n    }\n    pa2(co, 'b m % % r % % % % f %', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize, ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 2 * resizeHandleSize, resizeHandleSize, ca.resizing.bgcolor);pa2(co, 'b lw 1 m % % l % % m % % l % % s gray f transparent', ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height - resizeHandleSize + ca.resizing.adjustY, ma.round(ca.width - resizeHandleSize / 2 + ca.resizing.adjustX), ca.height + ca.resizing.adjustY, ca.width + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY), ca.width - resizeHandleSize + ca.resizing.adjustX, ma.round(ca.height - resizeHandleSize / 2 + ca.resizing.adjustY));pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height - resizeHandleSize + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize + 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize / 2 + ca.resizing.adjustX, ca.height + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 + 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize / 2 - 3 + ca.resizing.adjustX, ca.height - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize + 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 'l', ca.width - 3 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'c', 'f', 'gray']);pa2(co, ['b', 'm', ca.width + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 'r', ca.width - resizeHandleSize / 2 - 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 4, 4, 's', 'gray', 'f', 'white']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - 3 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 - 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + 2 + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + 2 + ca.resizing.adjustY, 'l', ca.width - resizeHandleSize - resizeHandleSize + ca.resizing.adjustX, ca.height - resizeHandleSize / 2 + ca.resizing.adjustY, 's', 'gray', 'f', 'gray']);pa2(co, ['b', 'm', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 - 3 + ca.resizing.adjustY, 'l', ma.round(ca.width - resizeHandleSize - resizeHandleSize - 1 + ca.resizing.adjustX), ca.height - resizeHandleSize / 2 + 3 + ca.resizing.adjustY, 's', 'f']);if (obj.get('chart.resizable') && !ca.rgraphResizewrapper) {\n      ca.rgraphResizewrapper = $('<div id=\"rgraph_resize_container_' + ca.id + '\"></div>').css({ 'float': ca.style.cssFloat, position: 'relative' }).get(0);$(ca).wrap(ca.rgraphResizewrapper);ca.style.cssFloat = 'none';ca.style.top = 0;ca.style.left = 0;var window_onmousemove = function window_onmousemove(e) {\n        var ca = active,\n            obj = ca ? ca.__object__ : null;if (ca) {\n          e = RG.fixEventObject(e);if (ca.resizing.mousedown) {\n            var newWidth = ca.width + (e.pageX - ca.resizing.originalx);var newHeight = ca.height + (e.pageY - ca.resizing.originaly);if (newWidth > ca.resizing.originalw / 2 && (typeof obj.get('resizableMaxwidth') === 'number' ? newWidth < obj.get('resizableMaxwidth') : true)) {\n              ca.resizing.div.style.width = newWidth + 'px';\n            }\n            if (newHeight > ca.resizing.originalh / 2 && (typeof obj.get('resizableMaxheight') === 'number' ? newHeight < obj.get('resizableMaxheight') : true)) {\n              ca.resizing.div.style.height = newHeight + 'px';\n            }\n            RG.fireCustomEvent(ca.__object__, 'onresize');\n          }\n        }\n      };\n      if (typeof ca.rgraph_resize_window_mousemove_listener_installed != 'boolean') {\n        window.addEventListener('mousemove', window_onmousemove, false);ca.rgraph_resize_window_mousemove_listener_installed = true;\n      }\n      var MouseupFunc = function MouseupFunc(e) {\n        if (!ca.resizing || !ca.resizing.div || !ca.resizing.mousedown) {\n          return;\n        }\n        if (ca.resizing.div) {\n          var div = ca.resizing.div;var coords = RG.getCanvasXY(ca);var parentNode = ca.parentNode;if (ca.style.position != 'absolute') {\n            var placeHolderDIV = document.createElement('DIV');placeHolderDIV.style.width = ca.resizing.originalw + 'px';placeHolderDIV.style.height = ca.resizing.originalh + 'px';placeHolderDIV.style.display = 'inline-block';placeHolderDIV.style.position = ca.style.position;placeHolderDIV.style.left = ca.style.left;placeHolderDIV.style.top = ca.style.top;placeHolderDIV.style.cssFloat = ca.style.cssFloat;parentNode.insertBefore(placeHolderDIV, ca);\n          }\n          ca.style.backgroundColor = 'white';ca.style.position = 'absolute';ca.style.border = '1px dashed gray';ca.style.boxShadow = '2px 2px 5px #ddd';ca.style.left = 0;ca.style.top = 0;ca.width = parseInt(div.style.width);ca.height = parseInt(div.style.height);ca.getContext('2d').translate(0.5, 0.5);var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0, len = objects.length; i < len; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (typeof objects[i].reset === 'function') {\n              objects[i].reset();\n            }\n          }\n          RG.cache = [];RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');RG.redrawCanvas(ca);ca.resizing.mousedown = false;div.style.display = 'none';document.body.removeChild(div);\n        }\n        if (RG.Registry.Get('chart.zoomed.div') || RGraph.Registry.Get('chart.zoomed.img')) {\n          RG.Registry.Set('chart.zoomed.div', null);RG.Registry.Set('chart.zoomed.img', null);\n        }\n        RG.FireCustomEvent(ca.__object__, 'onresizeend');\n      };var window_onmouseup = MouseupFunc;if (typeof ca.rgraph_resize_window_mouseup_listener_installed != 'boolean') {\n        window.addEventListener('mouseup', window_onmouseup, false);ca.rgraph_resize_window_mouseup_listener_installed = true;\n      }\n      var canvas_onmousemove = function canvas_onmousemove(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var obj = e.target.__object__;var ca = e.target;var co = ca.getContext('2d');var cursor = ca.style.cursor;if (!ca.resizing.original_cursor) {\n          ca.resizing.original_cursor = cursor;\n        }\n        if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'move';\n        } else if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          ca.style.cursor = 'pointer';\n        } else {\n          if (ca.resizing.original_cursor) {\n            ca.style.cursor = ca.resizing.original_cursor;ca.resizing.original_cursor = null;\n          } else {\n            ca.style.cursor = 'default';\n          }\n        }\n      };if (typeof ca.rgraph_resize_mousemove_listener_installed != 'boolean') {\n        ca.addEventListener('mousemove', canvas_onmousemove, false);ca.rgraph_resize_mousemove_listener_installed = true;\n      }\n      var canvas_onmouseout = function canvas_onmouseout(e) {\n        e.target.style.cursor = 'default';e.target.title = '';\n      };if (typeof ca.rgraph_resize_mouseout_listener_installed != 'boolean') {\n        ca.addEventListener('mouseout', canvas_onmouseout, false);ca.rgraph_resize_mouseout_listener_installed = true;\n      }\n      var canvas_onmousedown = function canvas_onmousedown(e) {\n        e = RG.fixEventObject(e);var coords = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(e.target);var ca = e.target;active = ca;if (coords[0] > ca.width - resizeHandleSize && coords[0] < ca.width && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height) {\n          RG.fireCustomEvent(obj, 'onresizebegin');if (ca.resizing.original_css_border == null) {\n            ca.resizing.original_css_border = ca.style.border;\n          }\n          if (ca.resizing.original_css_shadow == null) {\n            ca.resizing.original_css_shadow = ca.style.boxShadow;\n          }\n          ca.resizing.mousedown = true;var div = document.createElement('DIV');div.style.position = 'absolute';div.style.left = canvasXY[0] + 'px';div.style.top = canvasXY[1] + 'px';div.style.width = ca.width + 'px';div.style.height = ca.height + 'px';div.style.border = '1px dotted black';div.style.backgroundColor = 'gray';div.style.opacity = 0.5;div.__canvas__ = e.target;document.body.appendChild(div);ca.resizing.div = div;ca.resizing.placeHolders.push(div);for (var i = 0; i < ca.resizing.placeHolders.length - 1; ++i) {\n            ca.resizing.placeHolders[i].style.display = 'none';\n          }\n          div.onmouseup = function (e) {\n            MouseupFunc(e);\n          };\n          ca.resizing.div.onmouseover = function (e) {\n            e = RG.fixEventObject(e);e.stopPropagation();\n          };\n          ca.resizing.originalx = e.pageX;ca.resizing.originaly = e.pageY;ca.resizing.originalCanvasX = RG.getCanvasXY(ca)[0];ca.resizing.originalCanvasY = RG.getCanvasXY(ca)[1];\n        }\n        if (coords[0] > ca.width - resizeHandleSize - resizeHandleSize && coords[0] < ca.width - resizeHandleSize && coords[1] > ca.height - resizeHandleSize && coords[1] < ca.height && ca.resizing.originalw && ca.resizing.originaly) {\n          RG.fireCustomEvent(ca.__object__, 'onresizebegin');ca.width = ca.resizing.originalw;ca.height = ca.resizing.originalh;if (ca.__link__ && ca.__link__.style.display === 'none') {\n            ca.__link__.style.display = 'inline';\n          }\n          if (typeof ca.parentNode.id === 'string' && ca.parentNode.id.substring(0, 24) === 'rgraph_resize_container_') {\n            ca.parentNode.style.width = ca.resizing.originalw + 'px';ca.parentNode.style.height = ca.resizing.originalh + 'px';\n          }\n          ca.style.border = ca.resizing.original_css_border;ca.style.boxShadow = ca.resizing.original_css_shadow;ca.style.left = parseInt(ca.style.left) + 'px';ca.style.top = parseInt(ca.style.top) + 'px';ca.getContext('2d').translate(0.5, 0.5);RG.fireCustomEvent(ca.__object__, 'onresizebeforedraw');var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);for (var i = 0; i < objects.length; i += 1) {\n            RG.resetColorsToOriginalValues(objects[i]);if (objects[i].reset) {\n              objects[i].reset();\n            }\n            RG.redrawCanvas(objects[i].canvas);\n          }\n          RG.cache = [];if (ca.resizing.div) {\n            ca.resizing.div.style.width = ca.__original_width__ + 'px';ca.resizing.div.style.height = ca.__original_height__ + 'px';\n          }\n          RG.fireCustomEvent(ca.__object__, 'onresize');RG.fireCustomEvent(ca.__object__, 'onresizeend');\n        }\n      };if (typeof ca.rgraph_resize_mousedown_listener_installed != 'boolean') {\n        ca.addEventListener('mousedown', canvas_onmousedown, false);ca.rgraph_resize_mousedown_listener_installed = true;\n      }\n    }\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24ucmVzaXppbmcuanM/ZjBkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9OyhmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGgsXG4gICAgICBhY3RpdmUgPSBudWxsO1JHcmFwaC5hbGxvd1Jlc2l6aW5nID0gUkdyYXBoLkFsbG93UmVzaXppbmcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGNhID0gb2JqLmNhbnZhcyxcbiAgICAgICAgY28gPSBvYmouY29udGV4dCxcbiAgICAgICAgcGEyID0gUkcucGF0aDI7Y2EucmVzaXppbmcgPSBjYS5yZXNpemluZyB8fCB7fTtjYS5yZXNpemluZy5wbGFjZUhvbGRlcnMgPSBjYS5yZXNpemluZy5wbGFjZUhvbGRlcnMgfHwgW107aWYgKCFjYS5yZXNpemluZy5vcmlnaW5hbHcpIHtcbiAgICAgIGNhLnJlc2l6aW5nLm9yaWdpbmFsdyA9IGNhLndpZHRoO1xuICAgIH1cbiAgICBpZiAoIWNhLnJlc2l6aW5nLm9yaWdpbmFsaCkge1xuICAgICAgY2EucmVzaXppbmcub3JpZ2luYWxoID0gY2EuaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgcmVzaXplSGFuZGxlU2l6ZSA9IDE1O2lmICghY2EucmVzaXppbmcuX19yZ3JhcGhfb3JpZ2luYWxfd2lkdGhfXyB8fCAhY2EucmVzaXppbmcuX19yZ3JhcGhfb3JpZ2luYWxfaGVpZ2h0X18gfHwgIWNhLnJlc2l6aW5nLl9fYWRqdXN0WCB8fCAhY2EucmVzaXppbmcuX19hZGp1c3RZKSB7XG4gICAgICBjYS5yZXNpemluZy5fX3JncmFwaF9vcmlnaW5hbF93aWR0aF9fID0gY2Eud2lkdGg7Y2EucmVzaXppbmcuX19yZ3JhcGhfb3JpZ2luYWxfaGVpZ2h0X18gPSBjYS5oZWlnaHQ7Y2EucmVzaXppbmcuYWRqdXN0WCA9IF90eXBlb2Yob2JqLmdldCgnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnKSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5nZXQoJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JylbMF0gPT0gJ251bWJlcicgPyBvYmouR2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCcpWzBdIDogMDtjYS5yZXNpemluZy5hZGp1c3RZID0gX3R5cGVvZihvYmouZ2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCcpKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmdldCgnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnKVsxXSA9PSAnbnVtYmVyJyA/IG9iai5HZXQoJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JylbMV0gOiAwO2NhLnJlc2l6aW5nLmJnY29sb3IgPSBvYmouZ2V0KCdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnKSB8fCAncmdiYSgwLDAsMCwwKSc7XG4gICAgfVxuICAgIHBhMihjbywgJ2IgbSAlICUgciAlICUgJSAlIGYgJScsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIHJlc2l6ZUhhbmRsZVNpemUgKyBjYS5yZXNpemluZy5hZGp1c3RYLCBjYS5oZWlnaHQgLSByZXNpemVIYW5kbGVTaXplLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLSByZXNpemVIYW5kbGVTaXplICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSArIGNhLnJlc2l6aW5nLmFkanVzdFksIDIgKiByZXNpemVIYW5kbGVTaXplLCByZXNpemVIYW5kbGVTaXplLCBjYS5yZXNpemluZy5iZ2NvbG9yKTtwYTIoY28sICdiIGx3IDEgbSAlICUgbCAlICUgbSAlICUgbCAlICUgcyBncmF5IGYgdHJhbnNwYXJlbnQnLCBtYS5yb3VuZChjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgY2EucmVzaXppbmcuYWRqdXN0WCksIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgKyBjYS5yZXNpemluZy5hZGp1c3RZLCBtYS5yb3VuZChjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgY2EucmVzaXppbmcuYWRqdXN0WCksIGNhLmhlaWdodCArIGNhLnJlc2l6aW5nLmFkanVzdFksIGNhLndpZHRoICsgY2EucmVzaXppbmcuYWRqdXN0WCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZKSwgY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplICsgY2EucmVzaXppbmcuYWRqdXN0WCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZKSk7cGEyKGNvLCBbJ2InLCAnbScsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RYLCBjYS5oZWlnaHQgLSByZXNpemVIYW5kbGVTaXplICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2wnLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgMyArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgKyAzICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2wnLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyIC0gMyArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgKyAzICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2MnLCAnZicsICdncmF5J10pO3BhMihjbywgWydiJywgJ20nLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0ICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2wnLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgMyArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIDMgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgLSAzICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gMyArIGNhLnJlc2l6aW5nLmFkanVzdFksICdjJywgJ2YnLCAnZ3JheSddKTtwYTIoY28sIFsnYicsICdtJywgY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSArIDMgKyBjYS5yZXNpemluZy5hZGp1c3RYLCBjYS5oZWlnaHQgLSByZXNpemVIYW5kbGVTaXplIC8gMiArIDMgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSArIDMgKyBjYS5yZXNpemluZy5hZGp1c3RYLCBjYS5oZWlnaHQgLSByZXNpemVIYW5kbGVTaXplIC8gMiAtIDMgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnYycsICdmJywgJ2dyYXknXSk7cGEyKGNvLCBbJ2InLCAnbScsIGNhLndpZHRoICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIGNhLndpZHRoIC0gMyArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgMyArIGNhLnJlc2l6aW5nLmFkanVzdFksICdsJywgY2Eud2lkdGggLSAzICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgLSAzICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2MnLCAnZicsICdncmF5J10pO3BhMihjbywgWydiJywgJ20nLCBjYS53aWR0aCArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ3InLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyIC0gMiArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyIC0gMiArIGNhLnJlc2l6aW5nLmFkanVzdFksIDQsIDQsICdyJywgY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplIC8gMiAtIDIgKyBjYS5yZXNpemluZy5hZGp1c3RYLCBjYS5oZWlnaHQgLSByZXNpemVIYW5kbGVTaXplIC8gMiAtIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZLCA0LCA0LCAncycsICdncmF5JywgJ2YnLCAnd2hpdGUnXSk7cGEyKGNvLCBbJ2InLCAnbScsIG1hLnJvdW5kKGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIDMgKyBjYS5yZXNpemluZy5hZGp1c3RYKSwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIG1hLnJvdW5kKGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIHJlc2l6ZUhhbmRsZVNpemUgKyBjYS5yZXNpemluZy5hZGp1c3RYKSwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyBjYS5yZXNpemluZy5hZGp1c3RZLCAnbCcsIGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIHJlc2l6ZUhhbmRsZVNpemUgKyAyICsgY2EucmVzaXppbmcuYWRqdXN0WCwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgLSAyICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ2wnLCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgLSByZXNpemVIYW5kbGVTaXplICsgMiArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgMiArIGNhLnJlc2l6aW5nLmFkanVzdFksICdsJywgY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplIC0gcmVzaXplSGFuZGxlU2l6ZSArIGNhLnJlc2l6aW5nLmFkanVzdFgsIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ3MnLCAnZ3JheScsICdmJywgJ2dyYXknXSk7cGEyKGNvLCBbJ2InLCAnbScsIG1hLnJvdW5kKGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIHJlc2l6ZUhhbmRsZVNpemUgLSAxICsgY2EucmVzaXppbmcuYWRqdXN0WCksIGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgLyAyIC0gMyArIGNhLnJlc2l6aW5nLmFkanVzdFksICdsJywgbWEucm91bmQoY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplIC0gcmVzaXplSGFuZGxlU2l6ZSAtIDEgKyBjYS5yZXNpemluZy5hZGp1c3RYKSwgY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAvIDIgKyAzICsgY2EucmVzaXppbmcuYWRqdXN0WSwgJ3MnLCAnZiddKTtpZiAob2JqLmdldCgnY2hhcnQucmVzaXphYmxlJykgJiYgIWNhLnJncmFwaFJlc2l6ZXdyYXBwZXIpIHtcbiAgICAgIGNhLnJncmFwaFJlc2l6ZXdyYXBwZXIgPSAkKCc8ZGl2IGlkPVwicmdyYXBoX3Jlc2l6ZV9jb250YWluZXJfJyArIGNhLmlkICsgJ1wiPjwvZGl2PicpLmNzcyh7ICdmbG9hdCc6IGNhLnN0eWxlLmNzc0Zsb2F0LCBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9KS5nZXQoMCk7JChjYSkud3JhcChjYS5yZ3JhcGhSZXNpemV3cmFwcGVyKTtjYS5zdHlsZS5jc3NGbG9hdCA9ICdub25lJztjYS5zdHlsZS50b3AgPSAwO2NhLnN0eWxlLmxlZnQgPSAwO3ZhciB3aW5kb3dfb25tb3VzZW1vdmUgPSBmdW5jdGlvbiB3aW5kb3dfb25tb3VzZW1vdmUoZSkge1xuICAgICAgICB2YXIgY2EgPSBhY3RpdmUsXG4gICAgICAgICAgICBvYmogPSBjYSA/IGNhLl9fb2JqZWN0X18gOiBudWxsO2lmIChjYSkge1xuICAgICAgICAgIGUgPSBSRy5maXhFdmVudE9iamVjdChlKTtpZiAoY2EucmVzaXppbmcubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBjYS53aWR0aCArIChlLnBhZ2VYIC0gY2EucmVzaXppbmcub3JpZ2luYWx4KTt2YXIgbmV3SGVpZ2h0ID0gY2EuaGVpZ2h0ICsgKGUucGFnZVkgLSBjYS5yZXNpemluZy5vcmlnaW5hbHkpO2lmIChuZXdXaWR0aCA+IGNhLnJlc2l6aW5nLm9yaWdpbmFsdyAvIDIgJiYgKHR5cGVvZiBvYmouZ2V0KCdyZXNpemFibGVNYXh3aWR0aCcpID09PSAnbnVtYmVyJyA/IG5ld1dpZHRoIDwgb2JqLmdldCgncmVzaXphYmxlTWF4d2lkdGgnKSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgIGNhLnJlc2l6aW5nLmRpdi5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPiBjYS5yZXNpemluZy5vcmlnaW5hbGggLyAyICYmICh0eXBlb2Ygb2JqLmdldCgncmVzaXphYmxlTWF4aGVpZ2h0JykgPT09ICdudW1iZXInID8gbmV3SGVpZ2h0IDwgb2JqLmdldCgncmVzaXphYmxlTWF4aGVpZ2h0JykgOiB0cnVlKSkge1xuICAgICAgICAgICAgICBjYS5yZXNpemluZy5kaXYuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHLmZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCAnb25yZXNpemUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIGNhLnJncmFwaF9yZXNpemVfd2luZG93X21vdXNlbW92ZV9saXN0ZW5lcl9pbnN0YWxsZWQgIT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB3aW5kb3dfb25tb3VzZW1vdmUsIGZhbHNlKTtjYS5yZ3JhcGhfcmVzaXplX3dpbmRvd19tb3VzZW1vdmVfbGlzdGVuZXJfaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBNb3VzZXVwRnVuYyA9IGZ1bmN0aW9uIE1vdXNldXBGdW5jKGUpIHtcbiAgICAgICAgaWYgKCFjYS5yZXNpemluZyB8fCAhY2EucmVzaXppbmcuZGl2IHx8ICFjYS5yZXNpemluZy5tb3VzZWRvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhLnJlc2l6aW5nLmRpdikge1xuICAgICAgICAgIHZhciBkaXYgPSBjYS5yZXNpemluZy5kaXY7dmFyIGNvb3JkcyA9IFJHLmdldENhbnZhc1hZKGNhKTt2YXIgcGFyZW50Tm9kZSA9IGNhLnBhcmVudE5vZGU7aWYgKGNhLnN0eWxlLnBvc2l0aW9uICE9ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZUhvbGRlckRJViA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO3BsYWNlSG9sZGVyRElWLnN0eWxlLndpZHRoID0gY2EucmVzaXppbmcub3JpZ2luYWx3ICsgJ3B4JztwbGFjZUhvbGRlckRJVi5zdHlsZS5oZWlnaHQgPSBjYS5yZXNpemluZy5vcmlnaW5hbGggKyAncHgnO3BsYWNlSG9sZGVyRElWLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztwbGFjZUhvbGRlckRJVi5zdHlsZS5wb3NpdGlvbiA9IGNhLnN0eWxlLnBvc2l0aW9uO3BsYWNlSG9sZGVyRElWLnN0eWxlLmxlZnQgPSBjYS5zdHlsZS5sZWZ0O3BsYWNlSG9sZGVyRElWLnN0eWxlLnRvcCA9IGNhLnN0eWxlLnRvcDtwbGFjZUhvbGRlckRJVi5zdHlsZS5jc3NGbG9hdCA9IGNhLnN0eWxlLmNzc0Zsb2F0O3BhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBsYWNlSG9sZGVyRElWLCBjYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7Y2Euc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2NhLnN0eWxlLmJvcmRlciA9ICcxcHggZGFzaGVkIGdyYXknO2NhLnN0eWxlLmJveFNoYWRvdyA9ICcycHggMnB4IDVweCAjZGRkJztjYS5zdHlsZS5sZWZ0ID0gMDtjYS5zdHlsZS50b3AgPSAwO2NhLndpZHRoID0gcGFyc2VJbnQoZGl2LnN0eWxlLndpZHRoKTtjYS5oZWlnaHQgPSBwYXJzZUludChkaXYuc3R5bGUuaGVpZ2h0KTtjYS5nZXRDb250ZXh0KCcyZCcpLnRyYW5zbGF0ZSgwLjUsIDAuNSk7dmFyIG9iamVjdHMgPSBSRy5PYmplY3RSZWdpc3RyeS5nZXRPYmplY3RzQnlDYW52YXNJRChjYS5pZCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFJHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyhvYmplY3RzW2ldKTtpZiAodHlwZW9mIG9iamVjdHNbaV0ucmVzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb2JqZWN0c1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBSRy5jYWNoZSA9IFtdO1JHLmZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCAnb25yZXNpemViZWZvcmVkcmF3Jyk7UkcucmVkcmF3Q2FudmFzKGNhKTtjYS5yZXNpemluZy5tb3VzZWRvd24gPSBmYWxzZTtkaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuem9vbWVkLmRpdicpIHx8IFJHcmFwaC5SZWdpc3RyeS5HZXQoJ2NoYXJ0Lnpvb21lZC5pbWcnKSkge1xuICAgICAgICAgIFJHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuem9vbWVkLmRpdicsIG51bGwpO1JHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuem9vbWVkLmltZycsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIFJHLkZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCAnb25yZXNpemVlbmQnKTtcbiAgICAgIH07dmFyIHdpbmRvd19vbm1vdXNldXAgPSBNb3VzZXVwRnVuYztpZiAodHlwZW9mIGNhLnJncmFwaF9yZXNpemVfd2luZG93X21vdXNldXBfbGlzdGVuZXJfaW5zdGFsbGVkICE9ICdib29sZWFuJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHdpbmRvd19vbm1vdXNldXAsIGZhbHNlKTtjYS5yZ3JhcGhfcmVzaXplX3dpbmRvd19tb3VzZXVwX2xpc3RlbmVyX2luc3RhbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzX29ubW91c2Vtb3ZlID0gZnVuY3Rpb24gY2FudmFzX29ubW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO3ZhciBjb29yZHMgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBvYmogPSBlLnRhcmdldC5fX29iamVjdF9fO3ZhciBjYSA9IGUudGFyZ2V0O3ZhciBjbyA9IGNhLmdldENvbnRleHQoJzJkJyk7dmFyIGN1cnNvciA9IGNhLnN0eWxlLmN1cnNvcjtpZiAoIWNhLnJlc2l6aW5nLm9yaWdpbmFsX2N1cnNvcikge1xuICAgICAgICAgIGNhLnJlc2l6aW5nLm9yaWdpbmFsX2N1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRzWzBdID4gY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplICYmIGNvb3Jkc1swXSA8IGNhLndpZHRoICYmIGNvb3Jkc1sxXSA+IGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgJiYgY29vcmRzWzFdIDwgY2EuaGVpZ2h0KSB7XG4gICAgICAgICAgY2Euc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvb3Jkc1swXSA+IGNhLndpZHRoIC0gcmVzaXplSGFuZGxlU2l6ZSAtIHJlc2l6ZUhhbmRsZVNpemUgJiYgY29vcmRzWzBdIDwgY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplICYmIGNvb3Jkc1sxXSA+IGNhLmhlaWdodCAtIHJlc2l6ZUhhbmRsZVNpemUgJiYgY29vcmRzWzFdIDwgY2EuaGVpZ2h0KSB7XG4gICAgICAgICAgY2Euc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYS5yZXNpemluZy5vcmlnaW5hbF9jdXJzb3IpIHtcbiAgICAgICAgICAgIGNhLnN0eWxlLmN1cnNvciA9IGNhLnJlc2l6aW5nLm9yaWdpbmFsX2N1cnNvcjtjYS5yZXNpemluZy5vcmlnaW5hbF9jdXJzb3IgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O2lmICh0eXBlb2YgY2EucmdyYXBoX3Jlc2l6ZV9tb3VzZW1vdmVfbGlzdGVuZXJfaW5zdGFsbGVkICE9ICdib29sZWFuJykge1xuICAgICAgICBjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBjYW52YXNfb25tb3VzZW1vdmUsIGZhbHNlKTtjYS5yZ3JhcGhfcmVzaXplX21vdXNlbW92ZV9saXN0ZW5lcl9pbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc19vbm1vdXNlb3V0ID0gZnVuY3Rpb24gY2FudmFzX29ubW91c2VvdXQoZSkge1xuICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7ZS50YXJnZXQudGl0bGUgPSAnJztcbiAgICAgIH07aWYgKHR5cGVvZiBjYS5yZ3JhcGhfcmVzaXplX21vdXNlb3V0X2xpc3RlbmVyX2luc3RhbGxlZCAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgY2EuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBjYW52YXNfb25tb3VzZW91dCwgZmFsc2UpO2NhLnJncmFwaF9yZXNpemVfbW91c2VvdXRfbGlzdGVuZXJfaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNfb25tb3VzZWRvd24gPSBmdW5jdGlvbiBjYW52YXNfb25tb3VzZWRvd24oZSkge1xuICAgICAgICBlID0gUkcuZml4RXZlbnRPYmplY3QoZSk7dmFyIGNvb3JkcyA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIGNhbnZhc1hZID0gUkcuZ2V0Q2FudmFzWFkoZS50YXJnZXQpO3ZhciBjYSA9IGUudGFyZ2V0O2FjdGl2ZSA9IGNhO2lmIChjb29yZHNbMF0gPiBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgJiYgY29vcmRzWzBdIDwgY2Eud2lkdGggJiYgY29vcmRzWzFdID4gY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAmJiBjb29yZHNbMV0gPCBjYS5oZWlnaHQpIHtcbiAgICAgICAgICBSRy5maXJlQ3VzdG9tRXZlbnQob2JqLCAnb25yZXNpemViZWdpbicpO2lmIChjYS5yZXNpemluZy5vcmlnaW5hbF9jc3NfYm9yZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhLnJlc2l6aW5nLm9yaWdpbmFsX2Nzc19ib3JkZXIgPSBjYS5zdHlsZS5ib3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYS5yZXNpemluZy5vcmlnaW5hbF9jc3Nfc2hhZG93ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhLnJlc2l6aW5nLm9yaWdpbmFsX2Nzc19zaGFkb3cgPSBjYS5zdHlsZS5ib3hTaGFkb3c7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhLnJlc2l6aW5nLm1vdXNlZG93biA9IHRydWU7dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmxlZnQgPSBjYW52YXNYWVswXSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IGNhbnZhc1hZWzFdICsgJ3B4JztkaXYuc3R5bGUud2lkdGggPSBjYS53aWR0aCArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IGNhLmhlaWdodCArICdweCc7ZGl2LnN0eWxlLmJvcmRlciA9ICcxcHggZG90dGVkIGJsYWNrJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyYXknO2Rpdi5zdHlsZS5vcGFjaXR5ID0gMC41O2Rpdi5fX2NhbnZhc19fID0gZS50YXJnZXQ7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO2NhLnJlc2l6aW5nLmRpdiA9IGRpdjtjYS5yZXNpemluZy5wbGFjZUhvbGRlcnMucHVzaChkaXYpO2ZvciAodmFyIGkgPSAwOyBpIDwgY2EucmVzaXppbmcucGxhY2VIb2xkZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgY2EucmVzaXppbmcucGxhY2VIb2xkZXJzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpdi5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTW91c2V1cEZ1bmMoZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYS5yZXNpemluZy5kaXYub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO2Uuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYS5yZXNpemluZy5vcmlnaW5hbHggPSBlLnBhZ2VYO2NhLnJlc2l6aW5nLm9yaWdpbmFseSA9IGUucGFnZVk7Y2EucmVzaXppbmcub3JpZ2luYWxDYW52YXNYID0gUkcuZ2V0Q2FudmFzWFkoY2EpWzBdO2NhLnJlc2l6aW5nLm9yaWdpbmFsQ2FudmFzWSA9IFJHLmdldENhbnZhc1hZKGNhKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRzWzBdID4gY2Eud2lkdGggLSByZXNpemVIYW5kbGVTaXplIC0gcmVzaXplSGFuZGxlU2l6ZSAmJiBjb29yZHNbMF0gPCBjYS53aWR0aCAtIHJlc2l6ZUhhbmRsZVNpemUgJiYgY29vcmRzWzFdID4gY2EuaGVpZ2h0IC0gcmVzaXplSGFuZGxlU2l6ZSAmJiBjb29yZHNbMV0gPCBjYS5oZWlnaHQgJiYgY2EucmVzaXppbmcub3JpZ2luYWx3ICYmIGNhLnJlc2l6aW5nLm9yaWdpbmFseSkge1xuICAgICAgICAgIFJHLmZpcmVDdXN0b21FdmVudChjYS5fX29iamVjdF9fLCAnb25yZXNpemViZWdpbicpO2NhLndpZHRoID0gY2EucmVzaXppbmcub3JpZ2luYWx3O2NhLmhlaWdodCA9IGNhLnJlc2l6aW5nLm9yaWdpbmFsaDtpZiAoY2EuX19saW5rX18gJiYgY2EuX19saW5rX18uc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjYS5fX2xpbmtfXy5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2EucGFyZW50Tm9kZS5pZCA9PT0gJ3N0cmluZycgJiYgY2EucGFyZW50Tm9kZS5pZC5zdWJzdHJpbmcoMCwgMjQpID09PSAncmdyYXBoX3Jlc2l6ZV9jb250YWluZXJfJykge1xuICAgICAgICAgICAgY2EucGFyZW50Tm9kZS5zdHlsZS53aWR0aCA9IGNhLnJlc2l6aW5nLm9yaWdpbmFsdyArICdweCc7Y2EucGFyZW50Tm9kZS5zdHlsZS5oZWlnaHQgPSBjYS5yZXNpemluZy5vcmlnaW5hbGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYS5zdHlsZS5ib3JkZXIgPSBjYS5yZXNpemluZy5vcmlnaW5hbF9jc3NfYm9yZGVyO2NhLnN0eWxlLmJveFNoYWRvdyA9IGNhLnJlc2l6aW5nLm9yaWdpbmFsX2Nzc19zaGFkb3c7Y2Euc3R5bGUubGVmdCA9IHBhcnNlSW50KGNhLnN0eWxlLmxlZnQpICsgJ3B4JztjYS5zdHlsZS50b3AgPSBwYXJzZUludChjYS5zdHlsZS50b3ApICsgJ3B4JztjYS5nZXRDb250ZXh0KCcyZCcpLnRyYW5zbGF0ZSgwLjUsIDAuNSk7UkcuZmlyZUN1c3RvbUV2ZW50KGNhLl9fb2JqZWN0X18sICdvbnJlc2l6ZWJlZm9yZWRyYXcnKTt2YXIgb2JqZWN0cyA9IFJHLk9iamVjdFJlZ2lzdHJ5LmdldE9iamVjdHNCeUNhbnZhc0lEKGNhLmlkKTtmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFJHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyhvYmplY3RzW2ldKTtpZiAob2JqZWN0c1tpXS5yZXNldCkge1xuICAgICAgICAgICAgICBvYmplY3RzW2ldLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSRy5yZWRyYXdDYW52YXMob2JqZWN0c1tpXS5jYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSRy5jYWNoZSA9IFtdO2lmIChjYS5yZXNpemluZy5kaXYpIHtcbiAgICAgICAgICAgIGNhLnJlc2l6aW5nLmRpdi5zdHlsZS53aWR0aCA9IGNhLl9fb3JpZ2luYWxfd2lkdGhfXyArICdweCc7Y2EucmVzaXppbmcuZGl2LnN0eWxlLmhlaWdodCA9IGNhLl9fb3JpZ2luYWxfaGVpZ2h0X18gKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSRy5maXJlQ3VzdG9tRXZlbnQoY2EuX19vYmplY3RfXywgJ29ucmVzaXplJyk7UkcuZmlyZUN1c3RvbUV2ZW50KGNhLl9fb2JqZWN0X18sICdvbnJlc2l6ZWVuZCcpO1xuICAgICAgICB9XG4gICAgICB9O2lmICh0eXBlb2YgY2EucmdyYXBoX3Jlc2l6ZV9tb3VzZWRvd25fbGlzdGVuZXJfaW5zdGFsbGVkICE9ICdib29sZWFuJykge1xuICAgICAgICBjYS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjYW52YXNfb25tb3VzZWRvd24sIGZhbHNlKTtjYS5yZ3JhcGhfcmVzaXplX21vdXNlZG93bl9saXN0ZW5lcl9pbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24ucmVzaXppbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///172\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uc2hlZXRzLmpzPzczMWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgUkdyYXBoLlNoZWV0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgd29ya3NoZWV0LFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbGV0dGVycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHdvcmtzaGVldCA9IE51bWJlcihhcmd1bWVudHNbMV0pO2NhbGxiYWNrID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3Jrc2hlZXQgPSAxO2NhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vc3ByZWFkc2hlZXRzLmdvb2dsZS5jb20vZmVlZHMvY2VsbHMvW0tFWV0vW1dPUktTSEVFVF0vcHVibGljL2Z1bGw/YWx0PWpzb24taW4tc2NyaXB0JmNhbGxiYWNrPV9fcmdyYXBoX0pTT05QQ2FsbGJhY2snLnJlcGxhY2UoL1xcW0tFWVxcXS8sIGtleSkucmVwbGFjZSgvXFxbV09SS1NIRUVUXFxdLywgd29ya3NoZWV0KTt0aGlzLmxvYWQgPSBmdW5jdGlvbiAodXJsLCB1c2VyQ2FsbGJhY2spIHtcbiAgICAgIHZhciBvYmogPSB0aGlzO19fcmdyYXBoX0pTT05QQ2FsbGJhY2sgPSBmdW5jdGlvbiBfX3JncmFwaF9KU09OUENhbGxiYWNrKGpzb24pIHtcbiAgICAgICAgb2JqLmpzb24gPSBqc29uO3ZhciBncmlkID0gW10sXG4gICAgICAgICAgICByb3cgPSAwLFxuICAgICAgICAgICAgY29sID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IGpzb24uZmVlZC5lbnRyeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJvdyA9IGpzb24uZmVlZC5lbnRyeVtpXS5ncyRjZWxsLnJvdyAtIDE7Y29sID0ganNvbi5mZWVkLmVudHJ5W2ldLmdzJGNlbGwuY29sIC0gMTtpZiAoIWdyaWRbcm93XSkge1xuICAgICAgICAgICAgZ3JpZFtyb3ddID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyaWRbcm93XVtjb2xdID0ganNvbi5mZWVkLmVudHJ5W2ldLmNvbnRlbnQuJHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heGNvbHMgPSAwO2ZvciAodmFyIGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG1heGNvbHMgPSBncmlkW2ldID8gTWF0aC5tYXgobWF4Y29scywgZ3JpZFtpXS5sZW5ndGgpIDogbWF4Y29scztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGdyaWRbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBncmlkW2ldID0gbmV3IEFycmF5KG1heGNvbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heGNvbHM7IGorKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBncmlkW2ldW2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBncmlkW2ldW2pdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZFtpXVtqXS5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICBncmlkW2ldW2pdID0gcGFyc2VJbnQoZ3JpZFtpXVtqXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyaWRbaV1bal0ubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgICAgICAgIGdyaWRbaV1bal0gPSBwYXJzZUZsb2F0KGdyaWRbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmouZGF0YSA9IGdyaWQ7dXNlckNhbGxiYWNrKG9iaik7XG4gICAgICB9O3ZhciBzY3JpcHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU0NSSVBUJyk7c2NyaXB0Tm9kZS5zcmMgPSB1cmw7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHROb2RlKTtcbiAgICB9O3RoaXMucm93ID0gZnVuY3Rpb24gKGluZGV4LCBzdGFydCkge1xuICAgICAgdmFyIG9wdCA9IHt9LFxuICAgICAgICAgIHJvdztzdGFydCA9IHN0YXJ0IHx8IDE7aWYgKGFyZ3VtZW50cyAmJiBfdHlwZW9mKGFyZ3VtZW50c1syXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmd1bWVudHNbMl0udHJpbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdC50cmltID0gYXJndW1lbnRzWzJdLnRyaW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQudHJpbSA9IHRydWU7XG4gICAgICB9XG4gICAgICByb3cgPSB0aGlzLmRhdGFbaW5kZXggLSAxXS5zbGljZShzdGFydCAtIDEpO2lmIChvcHQudHJpbSkge1xuICAgICAgICByb3cgPSBSR3JhcGguYXJyYXlUcmltKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93O1xuICAgIH07dGhpcy5jb2wgPSBmdW5jdGlvbiAoaW5kZXgsIHN0YXJ0KSB7XG4gICAgICB2YXIgb3B0ID0ge30sXG4gICAgICAgICAgY29sID0gW107c3RhcnQgPSBzdGFydCB8fCAxO2lmIChhcmd1bWVudHMgJiYgX3R5cGVvZihhcmd1bWVudHNbMl0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzJdLnRyaW0gPT09ICdib29sZWFuJykge1xuICAgICAgICBvcHQudHJpbSA9IGFyZ3VtZW50c1syXS50cmltO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LnRyaW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29sLnB1c2godGhpcy5kYXRhW2ldW2luZGV4IC0gMV0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC50cmltKSB7XG4gICAgICAgIGNvbCA9IFJHcmFwaC5hcnJheVRyaW0oY29sKTtcbiAgICAgIH1cbiAgICAgIGNvbCA9IGNvbC5zbGljZShzdGFydCAtIDEpO3JldHVybiBjb2w7XG4gICAgfTt0aGlzLmdldEluZGV4T2ZMZXR0ZXJzID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGwuc3BsaXQoJycpO2lmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlcnMuaW5kZXhPZihsKSArIDE7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgaWR4ID0gKGxldHRlcnMuaW5kZXhPZihwYXJ0c1swXSkgKyAxKSAqIDI2ICsgKGxldHRlcnMuaW5kZXhPZihwYXJ0c1sxXSkgKyAxKTtyZXR1cm4gaWR4O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtpZiAoc3RyLm1hdGNoKC9eW2Etel0rJC9pKSkge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxldHRlcnMuaW5kZXhPZihzdHIpICsgMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsIDEsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHZhciBpbmRleCA9IChsZXR0ZXJzLmluZGV4T2Yoc3RyWzBdKSArIDEpICogMjYgKyBsZXR0ZXJzLmluZGV4T2Yoc3RyWzFdKSArIDE7cmV0dXJuIHRoaXMuY29sKGluZGV4LCAxLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyLm1hdGNoKC9eWzAtOV0rJC9pKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3coc3RyLCBudWxsLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5tYXRjaCgvXihbYS16XXsxLDJ9KShbMC05XSspJC9pKSkge1xuICAgICAgICB2YXIgbGV0dGVyID0gUmVnRXhwLiQxLFxuICAgICAgICAgICAgbnVtYmVyID0gUmVnRXhwLiQyLFxuICAgICAgICAgICAgY29sID0gdGhpcy5nZXQobGV0dGVyLCB7IHRyaW06IGZhbHNlIH0pO3JldHVybiBjb2xbbnVtYmVyIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoc3RyLm1hdGNoKC9eKFthLXpdezEsMn0pKFswLTldKyk6KFthLXpdezEsMn0pKFswLTldKykkL2kpKSB7XG4gICAgICAgIHZhciBsZXR0ZXIxID0gUmVnRXhwLiQxLFxuICAgICAgICAgICAgbnVtYmVyMSA9IFJlZ0V4cC4kMixcbiAgICAgICAgICAgIGxldHRlcjIgPSBSZWdFeHAuJDMsXG4gICAgICAgICAgICBudW1iZXIyID0gUmVnRXhwLiQ0O1xuICAgICAgICBpZiAobGV0dGVyMSA9PT0gbGV0dGVyMikge1xuICAgICAgICAgIHZhciBjZWxscyA9IFtdLFxuICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPZkxldHRlcnMobGV0dGVyMSksXG4gICAgICAgICAgICAgIGNvbCA9IHRoaXMuY29sKGluZGV4LCBudWxsLCB7IHRyaW06IGZhbHNlIH0pO2ZvciAodmFyIGkgPSBudW1iZXIxIC0gMTsgaSA8PSBudW1iZXIyIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNvbFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG51bWJlcjEgPT09IG51bWJlcjIpIHtcbiAgICAgICAgICB2YXIgY2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgcm93ID0gdGhpcy5yb3cobnVtYmVyMSwgbnVsbCwgeyB0cmltOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgaW5kZXgxID0gdGhpcy5nZXRJbmRleE9mTGV0dGVycyhsZXR0ZXIxKSxcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5nZXRJbmRleE9mTGV0dGVycyhsZXR0ZXIyKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXgxIC0gMTsgaSA8PSBpbmRleDIgLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2gocm93W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0udHJpbSA9PT0gZmFsc2UpIHt9IGVsc2Uge1xuICAgICAgICAgIGNlbGxzID0gUkdyYXBoLmFycmF5VHJpbShjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgICAgfVxuICAgIH07dGhpcy5sb2FkKHVybCwgY2FsbGJhY2spO1xuICB9O1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmNvbW1vbi5zaGVldHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///173\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.tooltips = {};RG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '10pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', opacity: 0 };RG.tooltip = RG.Tooltip = function (obj, text, x, y, idx, e) {\n    if (RG.trim(text).length === 0) {\n      return;\n    }\n    RG.fireCustomEvent(obj, 'onbeforetooltip');if (typeof obj.get('chart.tooltips.override') == 'function') {\n      return obj.get('chart.tooltips.override')(obj, text, x, y, idx);\n    }\n    var originalX = x;var originalY = y;text = RG.getTooltipTextFromDIV(text);var timers = RG.Registry.Get('chart.tooltip.timers');if (timers && timers.length) {\n      for (i = 0; i < timers.length; ++i) {\n        clearTimeout(timers[i]);\n      }\n    }\n    RG.Registry.Set('chart.tooltip.timers', []);if (obj.get('chart.contextmenu')) {\n      RG.hideContext();\n    }\n    var tooltipObj = document.createElement('DIV');tooltipObj.className = obj.get('chart.tooltips.css.class');for (var i in RGraph.tooltips.style) {\n      if (typeof i === 'string') {\n        tooltipObj.style[i] = RGraph.tooltips.style[i];\n      }\n    }\n    tooltipObj.innerHTML = text;tooltipObj.__text__ = text;tooltipObj.__canvas__ = obj.canvas;tooltipObj.id = '__rgraph_tooltip_' + obj.canvas.id + '_' + obj.uid + '_' + idx;tooltipObj.__event__ = obj.Get('chart.tooltips.event') || 'click';tooltipObj.__object__ = obj;if (typeof idx === 'number') {\n      tooltipObj.__index__ = idx;origIdx = idx;\n    }\n    if (obj.type === 'line' || obj.type === 'radar') {\n      for (var ds = 0; ds < obj.data.length; ++ds) {\n        if (idx >= obj.data[ds].length) {\n          idx -= obj.data[ds].length;\n        } else {\n          break;\n        }\n      }\n      tooltipObj.__dataset__ = ds;tooltipObj.__index2__ = idx;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth;var height = tooltipObj.offsetHeight;tooltipObj.style.width = width + 'px';var mouseXY = RG.getMouseXY(e);var canvasXY = RG.getCanvasXY(obj.canvas);tooltipObj.style.left = e.pageX - (parseFloat(tooltipObj.style.paddingLeft) + width / 2) + 'px';tooltipObj.style.top = e.pageY - height - 10 + 'px';if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.isFixed(obj.canvas)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = e.pageY - scrollTop - height - 10 + 'px';\n    }\n    if (obj.get('chart.tooltips.effect') === 'fade') {\n      for (var i = 1; i <= 10; ++i) {\n        (function (index) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = index / 10;\n          }, index * 25);\n        })(i);\n      }\n    } else {\n      tooltipObj.style.opacity = 1;\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };\n    tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };\n    RG.Registry.Set('chart.tooltip', tooltipObj);RG.fireCustomEvent(obj, 'ontooltip');\n  };RG.getTooltipTextFromDIV = function (text) {\n    var result = /^id:(.*)/.exec(text);if (result && result[1] && document.getElementById(result[1])) {\n      text = document.getElementById(result[1]).innerHTML;\n    } else if (result && result[1]) {\n      text = '';\n    }\n    return text;\n  };RG.getTooltipWidth = function (text, obj) {\n    var div = document.createElement('DIV');div.className = obj.Get('chart.tooltips.css.class');div.style.paddingLeft = RG.tooltips.padding;div.style.paddingRight = RG.tooltips.padding;div.style.fontFamily = RG.tooltips.font_face;div.style.fontSize = RG.tooltips.font_size;div.style.visibility = 'hidden';div.style.position = 'absolute';div.style.top = '300px';div.style.left = 0;div.style.display = 'inline';div.innerHTML = RG.getTooltipTextFromDIV(text);document.body.appendChild(div);return div.offsetWidth;\n  };RG.hideTooltip = RG.HideTooltip = function () {\n    var tooltip = RG.Registry.Get('chart.tooltip');var uid = arguments[0] && arguments[0].uid ? arguments[0].uid : null;if (tooltip && tooltip.parentNode && (!uid || uid == tooltip.__canvas__.uid)) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.Registry.Set('chart.tooltip', null);\n    }\n  };RG.preLoadTooltipImages = RG.PreLoadTooltipImages = function (obj) {\n    var tooltips = obj.Get('chart.tooltips');if (RG.hasTooltips(obj)) {\n      if (obj.type == 'rscatter') {\n        tooltips = [];for (var i = 0; i < obj.data.length; ++i) {\n          tooltips.push(obj.data[3]);\n        }\n      }\n      for (var i = 0; i < tooltips.length; ++i) {\n        var div = document.createElement('DIV');div.style.position = 'absolute';div.style.opacity = 0;div.style.top = '-100px';div.style.left = '-100px';div.innerHTML = tooltips[i];document.body.appendChild(div);var img_tags = div.getElementsByTagName('IMG');for (var j = 0; j < img_tags.length; ++j) {\n          if (img_tags && img_tags[i]) {\n            var img = document.createElement('IMG');img.style.position = 'absolute';img.style.opacity = 0;img.style.top = '-100px';img.style.left = '-100px';img.src = img_tags[i].src;\n            document.body.appendChild(img);setTimeout(function () {\n              document.body.removeChild(img);\n            }, 250);\n          }\n        }\n        document.body.removeChild(div);\n      }\n    }\n  };RG.tooltips_mousemove = RG.Tooltips_mousemove = function (obj, e) {\n    var shape = obj.getShape(e);var changeCursor_tooltips = false;\n    if (shape && typeof shape['index'] == 'number' && obj.Get('chart.tooltips')[shape['index']]) {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;if (obj.Get('chart.tooltips.event') == 'onmousemove') {\n          if (!RG.Registry.Get('chart.tooltip') || RG.Registry.Get('chart.tooltip').__object__.uid != obj.uid || RG.Registry.Get('chart.tooltip').__index__ != shape['index']) {\n            RG.hideTooltip();RG.Clear(obj.canvas);RG.redraw();RG.tooltip(obj, text, e.pageX, e.pageY, shape['index']);obj.Highlight(shape);\n          }\n        }\n      }\n    } else if (shape && typeof shape['index'] == 'number') {\n      var text = RG.parseTooltipText(obj.Get('chart.tooltips'), shape['index']);if (text) {\n        changeCursor_tooltips = true;\n      }\n    }\n    return changeCursor_tooltips;\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24udG9vbHRpcHMuanM/Njc0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9OyhmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGg7UkcudG9vbHRpcHMgPSB7fTtSRy50b29sdGlwcy5zdHlsZSA9IHsgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBwYWRkaW5nOiAnNnB4JywgZm9udEZhbWlseTogJ0FyaWFsJywgZm9udFNpemU6ICcxMHB0JywgZm9udFdlaWdodDogJ25vcm1hbCcsIHRleHRBbGlnbjogJ2NlbnRlcicsIGxlZnQ6IDAsIHRvcDogMCwgYmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwyNTUsMjM5KScsIGNvbG9yOiAnYmxhY2snLCB2aXNpYmlsaXR5OiAndmlzaWJsZScsIHpJbmRleDogMywgYm9yZGVyUmFkaXVzOiAnNXB4JywgYm94U2hhZG93OiAncmdiYSg5Niw5Niw5NiwwLjUpIDAgMCA1cHgnLCBvcGFjaXR5OiAwIH07UkcudG9vbHRpcCA9IFJHLlRvb2x0aXAgPSBmdW5jdGlvbiAob2JqLCB0ZXh0LCB4LCB5LCBpZHgsIGUpIHtcbiAgICBpZiAoUkcudHJpbSh0ZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwgJ29uYmVmb3JldG9vbHRpcCcpO2lmICh0eXBlb2Ygb2JqLmdldCgnY2hhcnQudG9vbHRpcHMub3ZlcnJpZGUnKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb2JqLmdldCgnY2hhcnQudG9vbHRpcHMub3ZlcnJpZGUnKShvYmosIHRleHQsIHgsIHksIGlkeCk7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbFggPSB4O3ZhciBvcmlnaW5hbFkgPSB5O3RleHQgPSBSRy5nZXRUb29sdGlwVGV4dEZyb21ESVYodGV4dCk7dmFyIHRpbWVycyA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcC50aW1lcnMnKTtpZiAodGltZXJzICYmIHRpbWVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aW1lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFJHLlJlZ2lzdHJ5LlNldCgnY2hhcnQudG9vbHRpcC50aW1lcnMnLCBbXSk7aWYgKG9iai5nZXQoJ2NoYXJ0LmNvbnRleHRtZW51JykpIHtcbiAgICAgIFJHLmhpZGVDb250ZXh0KCk7XG4gICAgfVxuICAgIHZhciB0b29sdGlwT2JqID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7dG9vbHRpcE9iai5jbGFzc05hbWUgPSBvYmouZ2V0KCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnKTtmb3IgKHZhciBpIGluIFJHcmFwaC50b29sdGlwcy5zdHlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b29sdGlwT2JqLnN0eWxlW2ldID0gUkdyYXBoLnRvb2x0aXBzLnN0eWxlW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB0b29sdGlwT2JqLmlubmVySFRNTCA9IHRleHQ7dG9vbHRpcE9iai5fX3RleHRfXyA9IHRleHQ7dG9vbHRpcE9iai5fX2NhbnZhc19fID0gb2JqLmNhbnZhczt0b29sdGlwT2JqLmlkID0gJ19fcmdyYXBoX3Rvb2x0aXBfJyArIG9iai5jYW52YXMuaWQgKyAnXycgKyBvYmoudWlkICsgJ18nICsgaWR4O3Rvb2x0aXBPYmouX19ldmVudF9fID0gb2JqLkdldCgnY2hhcnQudG9vbHRpcHMuZXZlbnQnKSB8fCAnY2xpY2snO3Rvb2x0aXBPYmouX19vYmplY3RfXyA9IG9iajtpZiAodHlwZW9mIGlkeCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRvb2x0aXBPYmouX19pbmRleF9fID0gaWR4O29yaWdJZHggPSBpZHg7XG4gICAgfVxuICAgIGlmIChvYmoudHlwZSA9PT0gJ2xpbmUnIHx8IG9iai50eXBlID09PSAncmFkYXInKSB7XG4gICAgICBmb3IgKHZhciBkcyA9IDA7IGRzIDwgb2JqLmRhdGEubGVuZ3RoOyArK2RzKSB7XG4gICAgICAgIGlmIChpZHggPj0gb2JqLmRhdGFbZHNdLmxlbmd0aCkge1xuICAgICAgICAgIGlkeCAtPSBvYmouZGF0YVtkc10ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b29sdGlwT2JqLl9fZGF0YXNldF9fID0gZHM7dG9vbHRpcE9iai5fX2luZGV4Ml9fID0gaWR4O1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBPYmopO3ZhciB3aWR0aCA9IHRvb2x0aXBPYmoub2Zmc2V0V2lkdGg7dmFyIGhlaWdodCA9IHRvb2x0aXBPYmoub2Zmc2V0SGVpZ2h0O3Rvb2x0aXBPYmouc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7dmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBjYW52YXNYWSA9IFJHLmdldENhbnZhc1hZKG9iai5jYW52YXMpO3Rvb2x0aXBPYmouc3R5bGUubGVmdCA9IGUucGFnZVggLSAocGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLnBhZGRpbmdMZWZ0KSArIHdpZHRoIC8gMikgKyAncHgnO3Rvb2x0aXBPYmouc3R5bGUudG9wID0gZS5wYWdlWSAtIGhlaWdodCAtIDEwICsgJ3B4JztpZiAocGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLmxlZnQpIDw9IDUpIHtcbiAgICAgIHRvb2x0aXBPYmouc3R5bGUubGVmdCA9ICc1cHgnO1xuICAgIH1cbiAgICBpZiAocGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLmxlZnQpICsgcGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLndpZHRoKSA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICB0b29sdGlwT2JqLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgIHRvb2x0aXBPYmouc3R5bGUucmlnaHQgPSAnNXB4JztcbiAgICB9XG4gICAgaWYgKFJHLmlzRml4ZWQob2JqLmNhbnZhcykpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cuc2Nyb2xsWSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO3Rvb2x0aXBPYmouc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO3Rvb2x0aXBPYmouc3R5bGUudG9wID0gZS5wYWdlWSAtIHNjcm9sbFRvcCAtIGhlaWdodCAtIDEwICsgJ3B4JztcbiAgICB9XG4gICAgaWYgKG9iai5nZXQoJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCcpID09PSAnZmFkZScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDEwOyArK2kpIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdG9vbHRpcE9iai5zdHlsZS5vcGFjaXR5ID0gaW5kZXggLyAxMDtcbiAgICAgICAgICB9LCBpbmRleCAqIDI1KTtcbiAgICAgICAgfSkoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXBPYmouc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIHRvb2x0aXBPYmoub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHRvb2x0aXBPYmoub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICB0b29sdGlwT2JqLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuYnV0dG9uID09IDApIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJHLlJlZ2lzdHJ5LlNldCgnY2hhcnQudG9vbHRpcCcsIHRvb2x0aXBPYmopO1JHLmZpcmVDdXN0b21FdmVudChvYmosICdvbnRvb2x0aXAnKTtcbiAgfTtSRy5nZXRUb29sdGlwVGV4dEZyb21ESVYgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAvXmlkOiguKikvLmV4ZWModGV4dCk7aWYgKHJlc3VsdCAmJiByZXN1bHRbMV0gJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVzdWx0WzFdKSkge1xuICAgICAgdGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlc3VsdFsxXSkuaW5uZXJIVE1MO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIHJlc3VsdFsxXSkge1xuICAgICAgdGV4dCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtSRy5nZXRUb29sdGlwV2lkdGggPSBmdW5jdGlvbiAodGV4dCwgb2JqKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5jbGFzc05hbWUgPSBvYmouR2V0KCdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnKTtkaXYuc3R5bGUucGFkZGluZ0xlZnQgPSBSRy50b29sdGlwcy5wYWRkaW5nO2Rpdi5zdHlsZS5wYWRkaW5nUmlnaHQgPSBSRy50b29sdGlwcy5wYWRkaW5nO2Rpdi5zdHlsZS5mb250RmFtaWx5ID0gUkcudG9vbHRpcHMuZm9udF9mYWNlO2Rpdi5zdHlsZS5mb250U2l6ZSA9IFJHLnRvb2x0aXBzLmZvbnRfc2l6ZTtkaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLnRvcCA9ICczMDBweCc7ZGl2LnN0eWxlLmxlZnQgPSAwO2Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7ZGl2LmlubmVySFRNTCA9IFJHLmdldFRvb2x0aXBUZXh0RnJvbURJVih0ZXh0KTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7cmV0dXJuIGRpdi5vZmZzZXRXaWR0aDtcbiAgfTtSRy5oaWRlVG9vbHRpcCA9IFJHLkhpZGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b29sdGlwID0gUkcuUmVnaXN0cnkuR2V0KCdjaGFydC50b29sdGlwJyk7dmFyIHVpZCA9IGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0udWlkID8gYXJndW1lbnRzWzBdLnVpZCA6IG51bGw7aWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5wYXJlbnROb2RlICYmICghdWlkIHx8IHVpZCA9PSB0b29sdGlwLl9fY2FudmFzX18udWlkKSkge1xuICAgICAgdG9vbHRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvb2x0aXApO3Rvb2x0aXAuc3R5bGUuZGlzcGxheSA9ICdub25lJzt0b29sdGlwLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztSRy5SZWdpc3RyeS5TZXQoJ2NoYXJ0LnRvb2x0aXAnLCBudWxsKTtcbiAgICB9XG4gIH07UkcucHJlTG9hZFRvb2x0aXBJbWFnZXMgPSBSRy5QcmVMb2FkVG9vbHRpcEltYWdlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdG9vbHRpcHMgPSBvYmouR2V0KCdjaGFydC50b29sdGlwcycpO2lmIChSRy5oYXNUb29sdGlwcyhvYmopKSB7XG4gICAgICBpZiAob2JqLnR5cGUgPT0gJ3JzY2F0dGVyJykge1xuICAgICAgICB0b29sdGlwcyA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0b29sdGlwcy5wdXNoKG9iai5kYXRhWzNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUub3BhY2l0eSA9IDA7ZGl2LnN0eWxlLnRvcCA9ICctMTAwcHgnO2Rpdi5zdHlsZS5sZWZ0ID0gJy0xMDBweCc7ZGl2LmlubmVySFRNTCA9IHRvb2x0aXBzW2ldO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTt2YXIgaW1nX3RhZ3MgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lNRycpO2ZvciAodmFyIGogPSAwOyBqIDwgaW1nX3RhZ3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpZiAoaW1nX3RhZ3MgJiYgaW1nX3RhZ3NbaV0pIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTUcnKTtpbWcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2ltZy5zdHlsZS5vcGFjaXR5ID0gMDtpbWcuc3R5bGUudG9wID0gJy0xMDBweCc7aW1nLnN0eWxlLmxlZnQgPSAnLTEwMHB4JztpbWcuc3JjID0gaW1nX3RhZ3NbaV0uc3JjO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWcpO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICB9XG4gICAgfVxuICB9O1JHLnRvb2x0aXBzX21vdXNlbW92ZSA9IFJHLlRvb2x0aXBzX21vdXNlbW92ZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcbiAgICB2YXIgc2hhcGUgPSBvYmouZ2V0U2hhcGUoZSk7dmFyIGNoYW5nZUN1cnNvcl90b29sdGlwcyA9IGZhbHNlO1xuICAgIGlmIChzaGFwZSAmJiB0eXBlb2Ygc2hhcGVbJ2luZGV4J10gPT0gJ251bWJlcicgJiYgb2JqLkdldCgnY2hhcnQudG9vbHRpcHMnKVtzaGFwZVsnaW5kZXgnXV0pIHtcbiAgICAgIHZhciB0ZXh0ID0gUkcucGFyc2VUb29sdGlwVGV4dChvYmouR2V0KCdjaGFydC50b29sdGlwcycpLCBzaGFwZVsnaW5kZXgnXSk7aWYgKHRleHQpIHtcbiAgICAgICAgY2hhbmdlQ3Vyc29yX3Rvb2x0aXBzID0gdHJ1ZTtpZiAob2JqLkdldCgnY2hhcnQudG9vbHRpcHMuZXZlbnQnKSA9PSAnb25tb3VzZW1vdmUnKSB7XG4gICAgICAgICAgaWYgKCFSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LnRvb2x0aXAnKSB8fCBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LnRvb2x0aXAnKS5fX29iamVjdF9fLnVpZCAhPSBvYmoudWlkIHx8IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQudG9vbHRpcCcpLl9faW5kZXhfXyAhPSBzaGFwZVsnaW5kZXgnXSkge1xuICAgICAgICAgICAgUkcuaGlkZVRvb2x0aXAoKTtSRy5DbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXcoKTtSRy50b29sdGlwKG9iaiwgdGV4dCwgZS5wYWdlWCwgZS5wYWdlWSwgc2hhcGVbJ2luZGV4J10pO29iai5IaWdobGlnaHQoc2hhcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hhcGUgJiYgdHlwZW9mIHNoYXBlWydpbmRleCddID09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdGV4dCA9IFJHLnBhcnNlVG9vbHRpcFRleHQob2JqLkdldCgnY2hhcnQudG9vbHRpcHMnKSwgc2hhcGVbJ2luZGV4J10pO2lmICh0ZXh0KSB7XG4gICAgICAgIGNoYW5nZUN1cnNvcl90b29sdGlwcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VDdXJzb3JfdG9vbHRpcHM7XG4gIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnRvb2x0aXBzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///174\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.zoom = RG.Zoom = function (e) {\n    e = RGraph.fixEventObject(e);if (e && e.target && e.target.__canvas__) {\n      var canvas = e.target.__canvas__;\n    } else if (e && e.target && e.target.__object__) {\n      var canvas = e.target.__object__.canvas;e.stopPropagation();\n    }\n    if (!canvas) {\n      var registry_canvas = RGraph.Registry.get('chart.contextmenu').__canvas__;if (registry_canvas) {\n        var canvas = registry_canvas;\n      }\n    }\n    var obj = canvas.__object__;var context = obj.context;var dataurl = canvas.toDataURL();var tmp = canvas;var coords = RG.getCanvasXY(canvas);var factor = obj.Get('chart.zoom.factor') - 1;var x = coords[0];var y = coords[1];var img = document.createElement('img');img.className = 'RGraph_zoomed_canvas';img.style.border = '1px solid #ccc';img.style.width = canvas.width + 'px';img.style.height = canvas.height + 'px';img.style.position = 'absolute';img.style.left = x + 'px';img.style.top = y + 'px';img.style.backgroundColor = 'white';img.style.opacity = obj.Get('chart.zoom.fade.in') ? 0 : 1;img.style.zIndex = 99;img.src = dataurl;document.body.appendChild(img);RGraph.zoom_image = img;RGraph.zoom_image.obj = obj;img.onclick = function (e) {\n      e = RGraph.fixEventObject(e);e.stopPropagation();return false;\n    };\n    var width = parseInt(canvas.width);var height = parseInt(canvas.height);var frames = obj.Get('chart.zoom.frames');var delay = obj.Get('chart.zoom.delay');if (obj.Get('chart.zoom.hdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = x + canvas.width / 2 - newWidth / 2;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.hdir') == 'left') {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;var rightHandEdge = x + canvas.width;var newLeft = rightHandEdge - newWidth;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'; RGraph.zoom_image.style.left = '\" + newLeft + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        var newWidth = width * factor * (i / frames) + width;setTimeout(\"RGraph.zoom_image.style.width = '\" + String(newWidth) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.vdir') == 'up') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else if (obj.Get('chart.zoom.vdir') == 'center') {\n      for (var i = 1; i <= frames; ++i) {\n        var newHeight = height * factor * (i / frames) + height;var bottomEdge = y + canvas.height / 2 + newHeight / 2;var newTop = bottomEdge - newHeight;setTimeout(\"RGraph.zoom_image.style.height = '\" + String(newHeight) + \"px'; RGraph.zoom_image.style.top = '\" + newTop + \"px'\", i * delay);\n      }\n    } else {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.height = '\" + String(height * factor * (i / frames) + height) + \"px'\", i * delay);\n      }\n    }\n    if (obj.Get('chart.zoom.fade.in')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.opacity = \" + Number(i / frames), i * (delay / 2));\n      }\n    }\n    if (obj.Get('chart.zoom.shadow')) {\n      for (var i = 1; i <= frames; ++i) {\n        setTimeout(\"RGraph.zoom_image.style.boxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.MozBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);setTimeout(\"RGraph.zoom_image.style.WebkitBoxShadow = 'rgba(128,128,128,\" + Number(i / frames) / 2 + \") 0 0 25px'\", i * delay);\n      }\n    }\n    var div = document.createElement('DIV');div.style.backgroundColor = 'white';div.style.opacity = 0;div.style.position = 'fixed';div.style.top = 0;div.style.left = 0;div.style.width = screen.width + 100 + 'px';div.style.height = screen.height + 100 + 'px';div.style.zIndex = 98;div.onclick = div.oncontextmenu = function (e) {\n      return RG.hideZoomedCanvas(e);\n    };\n    div.origHeight = div.style.height;document.body.appendChild(div);RG.zoom_background = div;for (var i = 1; i <= frames; ++i) {\n      setTimeout(\"RGraph.zoom_background.style.opacity = \" + Number(i / frames) * 0.8, i * (delay / 2));\n    }\n    RG.fireCustomEvent(obj, 'onzoom');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb21tb24uem9vbS5qcz84ZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy56b29tID0gUkcuWm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSA9IFJHcmFwaC5maXhFdmVudE9iamVjdChlKTtpZiAoZSAmJiBlLnRhcmdldCAmJiBlLnRhcmdldC5fX2NhbnZhc19fKSB7XG4gICAgICB2YXIgY2FudmFzID0gZS50YXJnZXQuX19jYW52YXNfXztcbiAgICB9IGVsc2UgaWYgKGUgJiYgZS50YXJnZXQgJiYgZS50YXJnZXQuX19vYmplY3RfXykge1xuICAgICAgdmFyIGNhbnZhcyA9IGUudGFyZ2V0Ll9fb2JqZWN0X18uY2FudmFzO2Uuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICB2YXIgcmVnaXN0cnlfY2FudmFzID0gUkdyYXBoLlJlZ2lzdHJ5LmdldCgnY2hhcnQuY29udGV4dG1lbnUnKS5fX2NhbnZhc19fO2lmIChyZWdpc3RyeV9jYW52YXMpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHJlZ2lzdHJ5X2NhbnZhcztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9iaiA9IGNhbnZhcy5fX29iamVjdF9fO3ZhciBjb250ZXh0ID0gb2JqLmNvbnRleHQ7dmFyIGRhdGF1cmwgPSBjYW52YXMudG9EYXRhVVJMKCk7dmFyIHRtcCA9IGNhbnZhczt2YXIgY29vcmRzID0gUkcuZ2V0Q2FudmFzWFkoY2FudmFzKTt2YXIgZmFjdG9yID0gb2JqLkdldCgnY2hhcnQuem9vbS5mYWN0b3InKSAtIDE7dmFyIHggPSBjb29yZHNbMF07dmFyIHkgPSBjb29yZHNbMV07dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO2ltZy5jbGFzc05hbWUgPSAnUkdyYXBoX3pvb21lZF9jYW52YXMnO2ltZy5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNjY2MnO2ltZy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7aW1nLnN0eWxlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKyAncHgnO2ltZy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7aW1nLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztpbWcuc3R5bGUudG9wID0geSArICdweCc7aW1nLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7aW1nLnN0eWxlLm9wYWNpdHkgPSBvYmouR2V0KCdjaGFydC56b29tLmZhZGUuaW4nKSA/IDAgOiAxO2ltZy5zdHlsZS56SW5kZXggPSA5OTtpbWcuc3JjID0gZGF0YXVybDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7UkdyYXBoLnpvb21faW1hZ2UgPSBpbWc7UkdyYXBoLnpvb21faW1hZ2Uub2JqID0gb2JqO2ltZy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUgPSBSR3JhcGguZml4RXZlbnRPYmplY3QoZSk7ZS5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUludChjYW52YXMud2lkdGgpO3ZhciBoZWlnaHQgPSBwYXJzZUludChjYW52YXMuaGVpZ2h0KTt2YXIgZnJhbWVzID0gb2JqLkdldCgnY2hhcnQuem9vbS5mcmFtZXMnKTt2YXIgZGVsYXkgPSBvYmouR2V0KCdjaGFydC56b29tLmRlbGF5Jyk7aWYgKG9iai5HZXQoJ2NoYXJ0Lnpvb20uaGRpcicpID09ICdjZW50ZXInKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSB3aWR0aCAqIGZhY3RvciAqIChpIC8gZnJhbWVzKSArIHdpZHRoO3ZhciByaWdodEhhbmRFZGdlID0geCArIGNhbnZhcy53aWR0aDt2YXIgbmV3TGVmdCA9IHggKyBjYW52YXMud2lkdGggLyAyIC0gbmV3V2lkdGggLyAyO3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS53aWR0aCA9ICdcIiArIFN0cmluZyhuZXdXaWR0aCkgKyBcInB4JzsgUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUubGVmdCA9ICdcIiArIG5ld0xlZnQgKyBcInB4J1wiLCBpICogZGVsYXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqLkdldCgnY2hhcnQuem9vbS5oZGlyJykgPT0gJ2xlZnQnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSB3aWR0aCAqIGZhY3RvciAqIChpIC8gZnJhbWVzKSArIHdpZHRoO3ZhciByaWdodEhhbmRFZGdlID0geCArIGNhbnZhcy53aWR0aDt2YXIgbmV3TGVmdCA9IHJpZ2h0SGFuZEVkZ2UgLSBuZXdXaWR0aDtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUud2lkdGggPSAnXCIgKyBTdHJpbmcobmV3V2lkdGgpICsgXCJweCc7IFJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmxlZnQgPSAnXCIgKyBuZXdMZWZ0ICsgXCJweCdcIiwgaSAqIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZnJhbWVzOyArK2kpIHtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gd2lkdGggKiBmYWN0b3IgKiAoaSAvIGZyYW1lcykgKyB3aWR0aDtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUud2lkdGggPSAnXCIgKyBTdHJpbmcobmV3V2lkdGgpICsgXCJweCdcIiwgaSAqIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5HZXQoJ2NoYXJ0Lnpvb20udmRpcicpID09ICd1cCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZyYW1lczsgKytpKSB7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBoZWlnaHQgKiBmYWN0b3IgKiAoaSAvIGZyYW1lcykgKyBoZWlnaHQ7dmFyIGJvdHRvbUVkZ2UgPSB5ICsgY2FudmFzLmhlaWdodDt2YXIgbmV3VG9wID0gYm90dG9tRWRnZSAtIG5ld0hlaWdodDtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gJ1wiICsgU3RyaW5nKG5ld0hlaWdodCkgKyBcInB4JzsgUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUudG9wID0gJ1wiICsgbmV3VG9wICsgXCJweCdcIiwgaSAqIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iai5HZXQoJ2NoYXJ0Lnpvb20udmRpcicpID09ICdjZW50ZXInKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gaGVpZ2h0ICogZmFjdG9yICogKGkgLyBmcmFtZXMpICsgaGVpZ2h0O3ZhciBib3R0b21FZGdlID0geSArIGNhbnZhcy5oZWlnaHQgLyAyICsgbmV3SGVpZ2h0IC8gMjt2YXIgbmV3VG9wID0gYm90dG9tRWRnZSAtIG5ld0hlaWdodDtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gJ1wiICsgU3RyaW5nKG5ld0hlaWdodCkgKyBcInB4JzsgUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUudG9wID0gJ1wiICsgbmV3VG9wICsgXCJweCdcIiwgaSAqIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZnJhbWVzOyArK2kpIHtcbiAgICAgICAgc2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmhlaWdodCA9ICdcIiArIFN0cmluZyhoZWlnaHQgKiBmYWN0b3IgKiAoaSAvIGZyYW1lcykgKyBoZWlnaHQpICsgXCJweCdcIiwgaSAqIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5HZXQoJ2NoYXJ0Lnpvb20uZmFkZS5pbicpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgICBzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUub3BhY2l0eSA9IFwiICsgTnVtYmVyKGkgLyBmcmFtZXMpLCBpICogKGRlbGF5IC8gMikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLkdldCgnY2hhcnQuem9vbS5zaGFkb3cnKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZnJhbWVzOyArK2kpIHtcbiAgICAgICAgc2V0VGltZW91dChcIlJHcmFwaC56b29tX2ltYWdlLnN0eWxlLmJveFNoYWRvdyA9ICdyZ2JhKDEyOCwxMjgsMTI4LFwiICsgTnVtYmVyKGkgLyBmcmFtZXMpIC8gMiArIFwiKSAwIDAgMjVweCdcIiwgaSAqIGRlbGF5KTtzZXRUaW1lb3V0KFwiUkdyYXBoLnpvb21faW1hZ2Uuc3R5bGUuTW96Qm94U2hhZG93ID0gJ3JnYmEoMTI4LDEyOCwxMjgsXCIgKyBOdW1iZXIoaSAvIGZyYW1lcykgLyAyICsgXCIpIDAgMCAyNXB4J1wiLCBpICogZGVsYXkpO3NldFRpbWVvdXQoXCJSR3JhcGguem9vbV9pbWFnZS5zdHlsZS5XZWJraXRCb3hTaGFkb3cgPSAncmdiYSgxMjgsMTI4LDEyOCxcIiArIE51bWJlcihpIC8gZnJhbWVzKSAvIDIgKyBcIikgMCAwIDI1cHgnXCIsIGkgKiBkZWxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztkaXYuc3R5bGUub3BhY2l0eSA9IDA7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztkaXYuc3R5bGUudG9wID0gMDtkaXYuc3R5bGUubGVmdCA9IDA7ZGl2LnN0eWxlLndpZHRoID0gc2NyZWVuLndpZHRoICsgMTAwICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gc2NyZWVuLmhlaWdodCArIDEwMCArICdweCc7ZGl2LnN0eWxlLnpJbmRleCA9IDk4O2Rpdi5vbmNsaWNrID0gZGl2Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIFJHLmhpZGVab29tZWRDYW52YXMoZSk7XG4gICAgfTtcbiAgICBkaXYub3JpZ0hlaWdodCA9IGRpdi5zdHlsZS5oZWlnaHQ7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1JHLnpvb21fYmFja2dyb3VuZCA9IGRpdjtmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgc2V0VGltZW91dChcIlJHcmFwaC56b29tX2JhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IFwiICsgTnVtYmVyKGkgLyBmcmFtZXMpICogMC44LCBpICogKGRlbGF5IC8gMikpO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQob2JqLCAnb256b29tJyk7XG4gIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29tbW9uLnpvb20uanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///175\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CornerGauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.min === 'number' && typeof conf.max === 'number' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'cornergauge';this.min = min;this.max = max;this.value = RGraph.stringsToNumbers(value);this.angles = {};this.angles.needle = [];this.centerpin = {};this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.strokestyle': 'black', 'chart.linewidth': 2, 'chart.title': '', 'chart.title.vpos': 0.5, 'chart.title.size': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.text.font': 'Arial', 'chart.text.color': '#666', 'chart.text.size': 10, 'chart.background.gradient.color1': '#ddd', 'chart.background.gradient.color2': 'white', 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.resizable': false, 'chart.chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.colors.ranges': null, 'chart.red.start': min + 0.9 * (this.max - min), 'chart.green.end': min + 0.7 * (this.max - min), 'chart.red.color': 'red', 'chart.yellow.color': 'yellow', 'chart.green.color': '#0f0', 'chart.value.text': true, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.value.text.boxed': true, 'chart.value.text.font': 'Arial', 'chart.value.text.size': 18, 'chart.value.text.bold': false, 'chart.value.text.decimals': 0, 'chart.centerpin.stroke': 'rgba(0,0,0,0)', 'chart.centerpin.fill': null, 'chart.centerpin.color': 'blue', 'chart.needle.colors': ['#ccc', '#D5604D', 'red', 'green', 'yellow'], 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph;var ca = this.canvas;var co = ca.getContext('2d');var prop = this.properties;var jq = jQuery;var pa = RG.Path;var win = window;var doc = document;var ma = Math;this.set = this.Set = function (name, value) {\n    if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n      RG.parseObjectStyleConfig(this, arguments[0]);return this;\n    }\n    name = name.toLowerCase();if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (typeof this.gutterLeft == 'undefined') {\n      this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];\n    }\n    this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom);if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];this.centerx = ca.width / 2 - this.radius / 2 + Math.max(30, this.radius * 0.1);this.centery = ca.height / 2 + this.radius / 2 - this.radius * 0.1;this.coordsText = [];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawBackGround();this.DrawTickmarks();this.DrawColorBands();this.DrawLabel();this.DrawLabels();if (_typeof(this.value) === 'object') {\n      for (var i = 0, len = this.value.length; i < len; ++i) {\n        this.DrawNeedle(i, this.value[i], this.radius - 65);\n      }\n    } else {\n      this.DrawNeedle(0, this.value, this.radius - 65);\n    }\n    this.DrawCenterpin();var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;\n    prop['chart.title.y'] = this.centery + 20 - this.radius - 1.5 * size / 2;RGraph.DrawTitle(this, prop['chart.title'], this.guttertop, this.centerx + this.radius / 2, size);if (prop['chart.contextmenu']) {\n      RGraph.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RGraph.AllowResizing(this);\n    }\n    RGraph.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RGraph.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, false);co.stroke();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.stroke();RG.NoShadow(this);co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 0.0001;co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.stroke();RGraph.NoShadow(this);co.lineWidth = 0;co.fillStyle = RGraph.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius * 0.5, prop['chart.background.gradient.color1'], prop['chart.background.gradient.color2']);co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 30, 0, RGraph.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.moveTo(this.centerx - 20, this.centery + 20);co.lineTo(this.centerx - 20, this.centery + 20 - this.radius);co.arc(this.centerx - 20, this.centery + 20, this.radius, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);co.closePath();co.fill();co.beginPath();co.lineWidth = 1;co.strokeStyle = '#eee';for (var i = 0; i <= 5; ++i) {\n      var p1 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, 30);var p2 = RG.getRadiusEndPoint(this.centerx, this.centery, RGraph.HALFPI / 5 * i + RGraph.PI + RGraph.HALFPI, this.radius - 90);co.moveTo(p1[0], p1[1]);co.lineTo(p2[0], p2[1]);\n    }\n    co.stroke();\n  };this.drawNeedle = this.DrawNeedle = function (index, value, radius) {\n    var grad = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, 20, 'rgba(0,0,0,0)', prop['chart.needle.colors'][index]);\n    this.angles.needle[index] = (value - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.lineWidth = 1;\n    co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = grad;co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] - RG.HALFPI, this.angles.needle[index] - RG.HALFPI + 0.000001, false);co.arc(this.centerx, this.centery, radius - 30, this.angles.needle[index], this.angles.needle[index] + 0.000001, false);co.arc(this.centerx, this.centery, 10, this.angles.needle[index] + RG.HALFPI, this.angles.needle[index] + RG.HALFPI + 0.000001, false);co.stroke();co.fill();\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (!prop['chart.centerpin.fill']) {\n      prop['chart.centerpin.fill'] = RG.RadialGradient(this, this.centerx + 5, this.centery - 5, 0, this.centerx + 5, this.centery - 5, 20, 'white', prop['chart.centerpin.color']);\n    }\n    co.strokeStyle = prop['chart.centerpin.stroke'];co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.lineWidth = 2;co.arc(this.centerx, this.centery, 15, 0, RGraph.TWOPI, false);co.stroke();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var numLabels = 6;co.fillStyle = prop['chart.text.color'];for (var i = 0; i < numLabels; ++i) {\n      co.beginPath();var num = Number(this.min + (this.max - this.min) * (i / (numLabels - 1))).toFixed(prop['chart.scale.decimals']);num = RG.number_format(this, num, prop['chart.units.pre'], prop['chart.units.post']);var angle = i * 18 / (180 / RG.PI);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx + ma.sin(angle) * (this.radius - 53), 'y': this.centery - ma.cos(angle) * (this.radius - 53), 'text': String(num), 'valign': 'top', 'halign': 'center', 'angle': 90 * (i / (numLabels - 1)), 'tag': 'scale' });co.fill();\n    }\n  };this.drawTickmarks = this.DrawTickmarks = function () {\n    var bigTicks = 5;var smallTicks = 25;for (var i = 0; i < smallTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (smallTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 44, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 46, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n    for (var i = 0; i < bigTicks; ++i) {\n      co.beginPath();var angle = RG.HALFPI / (bigTicks - 1) * i;\n      co.lineWidth = 1;co.arc(this.centerx, this.centery, this.radius - 43, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 47, RG.PI + RG.HALFPI + angle, RG.PI + RG.HALFPI + angle + 0.0001, false);co.stroke();\n    }\n  };this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0, len = ranges.length; i < len; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), false);co.arc(this.centerx, this.centery, this.radius - 54 - 10 - prop['chart.text.size'] * 1.5, (ranges[i][1] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), (ranges[i][0] - this.min) / (this.max - this.min) * RG.HALFPI + (RG.PI + RG.HALFPI), true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = RG.PI + RG.HALFPI;var greenEnd = greenStart + (RG.TWOPI - greenStart) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = (prop['chart.red.start'] - this.min) / (this.max - this.min) * RG.HALFPI + RG.PI + RG.HALFPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = RGraph.TWOPI;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5, redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - 54 - prop['chart.text.size'] * 1.5 - 10, redEnd, redStart, true);co.fill();\n  };this.drawLabel = this.DrawLabel = function () {\n    if (prop['chart.value.text']) {\n      co.strokeStyle = prop['chart.text.color'];co.fillStyle = prop['chart.text.color'];var value = typeof this.value == 'number' ? this.value.toFixed(prop['chart.value.text.decimals']) : this.value;if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n        for (var i = 0; i < value.length; ++i) {\n          value[i] = parseFloat(value[i]).toFixed(prop['chart.value.text.decimals']);\n        }\n        value = value.toString();\n      }\n      RG.Text2(this, { 'font': prop['chart.value.text.font'], 'size': prop['chart.value.text.size'], 'x': this.centerx + ma.cos(RG.PI / 180 * 45) * (this.radius / 3), 'y': this.centery - ma.sin(RG.PI / 180 * 45) * (this.radius / 3), 'text': prop['chart.value.text.units.pre'] + value + prop['chart.value.text.units.post'], 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.value.text.boxed'], 'boundingFill': 'white', 'bold': prop['chart.value.text.bold'], 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle > RG.TWOPI && angle < RG.PI + RG.HALFPI) {\n      return null;\n    }\n    var value = (angle - (RG.PI + RG.HALFPI)) / (RG.TWOPI - (RG.PI + RG.HALFPI)) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    if (mouseX > this.centerx && mouseY > this.centery) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - 5 && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + 5 && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.Clear(ca);RG.RedrawCanvas(ca);RG.FireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.HALFPI;\n    angle += RG.PI + RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    if (!RG.is_null(prop['chart.colors.ranges'])) {\n      for (var i = 0; i < prop['chart.colors.ranges'].length; ++i) {\n        prop['chart.colors.ranges'][i][2] = this.parseSingleColorForGradient(prop['chart.colors.ranges'][i][2]);\n      }\n    } else {\n      prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var radius_start = this.radius - 54 - prop['chart.text.size'];var radius_end = radius_start - 15;var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, radius_end);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    this[type] = func;return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0];var callback = arguments[1];var numFrames = 30;var frame = 0;var obj = this;if (typeof this.value === 'number') {\n      var origValue = Number(this.currentValue);if (this.currentValue === null) {\n        this.currentValue = this.min;origValue = this.min;\n      }\n      var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;var iterator = function iterator() {\n        frame++;obj.value = frame / numFrames * diff + origValue;\n        if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.Clear(obj.canvas);RGraph.RedrawCanvas(obj.canvas);if (frame < 30) {\n          RGraph.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];var step = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);step[i] = diff[i] / numFrames;\n      }\n      var max = this.max;var min = this.min;var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / numFrames * diff[i] + origValue[i];if (obj.value[i] > max) obj.value[i] = max;if (obj.value[i] < min) obj.value[i] = min;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n        }\n        if (frame < 30) {\n          RG.Effects.updateCanvas(iterator);\n        } else if (typeof callback === 'function') {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };\n  RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5jb3JuZXJnYXVnZS5qcz9iNmY0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkNvcm5lckdhdWdlID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5taW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb25mLm1heCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYudmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQ7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgbWluID0gY29uZi5taW47dmFyIG1heCA9IGNvbmYubWF4O3ZhciB2YWx1ZSA9IGNvbmYudmFsdWU7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZCA9IGNvbmY7dmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgbWluID0gYXJndW1lbnRzWzFdO3ZhciBtYXggPSBhcmd1bWVudHNbMl07dmFyIHZhbHVlID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGNhbnZhczt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6ICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlkKSkgPT09ICdvYmplY3QnICYmIGlkLmFscGhhID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSB9KSA6IG51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ2Nvcm5lcmdhdWdlJzt0aGlzLm1pbiA9IG1pbjt0aGlzLm1heCA9IG1heDt0aGlzLnZhbHVlID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnModmFsdWUpO3RoaXMuYW5nbGVzID0ge307dGhpcy5hbmdsZXMubmVlZGxlID0gW107dGhpcy5jZW50ZXJwaW4gPSB7fTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7dGhpcy51aWQgPSBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkID0gdGhpcy5jYW52YXMudWlkID8gdGhpcy5jYW52YXMudWlkIDogUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO2lmIChfdHlwZW9mKHRoaXMudmFsdWUpID09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZVtpXSA+IHRoaXMubWF4KSB0aGlzLnZhbHVlW2ldID0gbWF4O2lmICh0aGlzLnZhbHVlW2ldIDwgdGhpcy5taW4pIHRoaXMudmFsdWVbaV0gPSBtaW47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLnZhbHVlID4gdGhpcy5tYXgpIHRoaXMudmFsdWUgPSBtYXg7aWYgKHRoaXMudmFsdWUgPCB0aGlzLm1pbikgdGhpcy52YWx1ZSA9IG1pbjtcbiAgfVxuICB0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5jZW50ZXJ4JzogbnVsbCwgJ2NoYXJ0LmNlbnRlcnknOiBudWxsLCAnY2hhcnQucmFkaXVzJzogbnVsbCwgJ2NoYXJ0Lmd1dHRlci5sZWZ0JzogMjUsICdjaGFydC5ndXR0ZXIucmlnaHQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci50b3AnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOiAyNSwgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJ2JsYWNrJywgJ2NoYXJ0LmxpbmV3aWR0aCc6IDIsICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUudnBvcyc6IDAuNSwgJ2NoYXJ0LnRpdGxlLnNpemUnOiBudWxsLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGV4dC5mb250JzogJ0FyaWFsJywgJ2NoYXJ0LnRleHQuY29sb3InOiAnIzY2NicsICdjaGFydC50ZXh0LnNpemUnOiAxMCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JhZGllbnQuY29sb3IxJzogJyNkZGQnLCAnY2hhcnQuYmFja2dyb3VuZC5ncmFkaWVudC5jb2xvcjInOiAnd2hpdGUnLCAnY2hhcnQuc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICdncmF5JywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMCwgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMCwgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogMTUsICdjaGFydC5zY2FsZS5kZWNpbWFscyc6IDAsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQudW5pdHMucHJlJzogJycsICdjaGFydC51bml0cy5wb3N0JzogJycsICdjaGFydC5yZXNpemFibGUnOiBmYWxzZSwgJ2NoYXJ0LmNoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC5hZGp1c3RhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0YWJsZSc6IGZhbHNlLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuY29sb3JzLnJhbmdlcyc6IG51bGwsICdjaGFydC5yZWQuc3RhcnQnOiBtaW4gKyAwLjkgKiAodGhpcy5tYXggLSBtaW4pLCAnY2hhcnQuZ3JlZW4uZW5kJzogbWluICsgMC43ICogKHRoaXMubWF4IC0gbWluKSwgJ2NoYXJ0LnJlZC5jb2xvcic6ICdyZWQnLCAnY2hhcnQueWVsbG93LmNvbG9yJzogJ3llbGxvdycsICdjaGFydC5ncmVlbi5jb2xvcic6ICcjMGYwJywgJ2NoYXJ0LnZhbHVlLnRleHQnOiB0cnVlLCAnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQudmFsdWUudGV4dC5ib3hlZCc6IHRydWUsICdjaGFydC52YWx1ZS50ZXh0LmZvbnQnOiAnQXJpYWwnLCAnY2hhcnQudmFsdWUudGV4dC5zaXplJzogMTgsICdjaGFydC52YWx1ZS50ZXh0LmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LnZhbHVlLnRleHQuZGVjaW1hbHMnOiAwLCAnY2hhcnQuY2VudGVycGluLnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJzogbnVsbCwgJ2NoYXJ0LmNlbnRlcnBpbi5jb2xvcic6ICdibHVlJywgJ2NoYXJ0Lm5lZWRsZS5jb2xvcnMnOiBbJyNjY2MnLCAnI0Q1NjA0RCcsICdyZWQnLCAnZ3JlZW4nLCAneWVsbG93J10sICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uaGRpcic6ICdyaWdodCcsICdjaGFydC56b29tLnZkaXInOiAnZG93bicsICdjaGFydC56b29tLmZyYW1lcyc6IDI1LCAnY2hhcnQuem9vbS5kZWxheSc6IDE2LjY2NiwgJ2NoYXJ0Lnpvb20uc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6IHRydWUgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaDt2YXIgY2EgPSB0aGlzLmNhbnZhczt2YXIgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpO3ZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3ZhciBqcSA9IGpRdWVyeTt2YXIgcGEgPSBSRy5QYXRoO3ZhciB3aW4gPSB3aW5kb3c7dmFyIGRvYyA9IGRvY3VtZW50O3ZhciBtYSA9IE1hdGg7dGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgYXJndW1lbnRzWzBdKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTtpZiAodHlwZW9mIHRoaXMuZ3V0dGVyTGVmdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107XG4gICAgfVxuICAgIHRoaXMucmFkaXVzID0gTWF0aC5taW4oY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO3RoaXMuY2VudGVyeCA9IGNhLndpZHRoIC8gMiAtIHRoaXMucmFkaXVzIC8gMiArIE1hdGgubWF4KDMwLCB0aGlzLnJhZGl1cyAqIDAuMSk7dGhpcy5jZW50ZXJ5ID0gY2EuaGVpZ2h0IC8gMiArIHRoaXMucmFkaXVzIC8gMiAtIHRoaXMucmFkaXVzICogMC4xO3RoaXMuY29vcmRzVGV4dCA9IFtdO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeCddID09PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ4ID0gcHJvcFsnY2hhcnQuY2VudGVyeCddO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeSddID09PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ5ID0gcHJvcFsnY2hhcnQuY2VudGVyeSddO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuRHJhd0JhY2tHcm91bmQoKTt0aGlzLkRyYXdUaWNrbWFya3MoKTt0aGlzLkRyYXdDb2xvckJhbmRzKCk7dGhpcy5EcmF3TGFiZWwoKTt0aGlzLkRyYXdMYWJlbHMoKTtpZiAoX3R5cGVvZih0aGlzLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRoaXMuRHJhd05lZWRsZShpLCB0aGlzLnZhbHVlW2ldLCB0aGlzLnJhZGl1cyAtIDY1KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5EcmF3TmVlZGxlKDAsIHRoaXMudmFsdWUsIHRoaXMucmFkaXVzIC0gNjUpO1xuICAgIH1cbiAgICB0aGlzLkRyYXdDZW50ZXJwaW4oKTt2YXIgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA/IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICsgMjtcbiAgICBwcm9wWydjaGFydC50aXRsZS55J10gPSB0aGlzLmNlbnRlcnkgKyAyMCAtIHRoaXMucmFkaXVzIC0gMS41ICogc2l6ZSAvIDI7UkdyYXBoLkRyYXdUaXRsZSh0aGlzLCBwcm9wWydjaGFydC50aXRsZSddLCB0aGlzLmd1dHRlcnRvcCwgdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgLyAyLCBzaXplKTtpZiAocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSkge1xuICAgICAgUkdyYXBoLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHcmFwaC5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBSR3JhcGguSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHcmFwaC5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0JhY2tHcm91bmQgPSB0aGlzLkRyYXdCYWNrR3JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkdyYXBoLlNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXSA/IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddIDogMC4wMDAxO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMzAsIDAsIFJHcmFwaC5UV09QSSwgZmFsc2UpO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSAyMCwgdGhpcy5jZW50ZXJ5ICsgMjApO2NvLmFyYyh0aGlzLmNlbnRlcnggLSAyMCwgdGhpcy5jZW50ZXJ5ICsgMjAsIHRoaXMucmFkaXVzLCBSR3JhcGguUEkgKyBSR3JhcGguSEFMRlBJLCBSR3JhcGguVFdPUEksIGZhbHNlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7UkcuTm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddID8gcHJvcFsnY2hhcnQubGluZXdpZHRoJ10gOiAwLjAwMDE7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIDIwLCB0aGlzLmNlbnRlcnkgKyAyMCk7Y28uYXJjKHRoaXMuY2VudGVyeCAtIDIwLCB0aGlzLmNlbnRlcnkgKyAyMCwgdGhpcy5yYWRpdXMsIFJHcmFwaC5QSSArIFJHcmFwaC5IQUxGUEksIFJHcmFwaC5UV09QSSwgZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO1JHcmFwaC5Ob1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGggPSAwO2NvLmZpbGxTdHlsZSA9IFJHcmFwaC5SYWRpYWxHcmFkaWVudCh0aGlzLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzICogMC41LCBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50LmNvbG9yMSddLCBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50LmNvbG9yMiddKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMzAsIDAsIFJHcmFwaC5UV09QSSwgMCk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSAyMCwgdGhpcy5jZW50ZXJ5ICsgMjApO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggLSAyMCwgdGhpcy5jZW50ZXJ5ICsgMjAgLSB0aGlzLnJhZGl1cyk7Y28uYXJjKHRoaXMuY2VudGVyeCAtIDIwLCB0aGlzLmNlbnRlcnkgKyAyMCwgdGhpcy5yYWRpdXMsIFJHcmFwaC5QSSArIFJHcmFwaC5IQUxGUEksIFJHcmFwaC5UV09QSSwgZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGggPSAxO2NvLnN0cm9rZVN0eWxlID0gJyNlZWUnO2ZvciAodmFyIGkgPSAwOyBpIDw9IDU7ICsraSkge1xuICAgICAgdmFyIHAxID0gUkcuZ2V0UmFkaXVzRW5kUG9pbnQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIFJHcmFwaC5IQUxGUEkgLyA1ICogaSArIFJHcmFwaC5QSSArIFJHcmFwaC5IQUxGUEksIDMwKTt2YXIgcDIgPSBSRy5nZXRSYWRpdXNFbmRQb2ludCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgUkdyYXBoLkhBTEZQSSAvIDUgKiBpICsgUkdyYXBoLlBJICsgUkdyYXBoLkhBTEZQSSwgdGhpcy5yYWRpdXMgLSA5MCk7Y28ubW92ZVRvKHAxWzBdLCBwMVsxXSk7Y28ubGluZVRvKHAyWzBdLCBwMlsxXSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1xuICB9O3RoaXMuZHJhd05lZWRsZSA9IHRoaXMuRHJhd05lZWRsZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIHJhZGl1cykge1xuICAgIHZhciBncmFkID0gUkcuUmFkaWFsR3JhZGllbnQodGhpcywgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIDAsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAyMCwgJ3JnYmEoMCwwLDAsMCknLCBwcm9wWydjaGFydC5uZWVkbGUuY29sb3JzJ11baW5kZXhdKTtcbiAgICB0aGlzLmFuZ2xlcy5uZWVkbGVbaW5kZXhdID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogUkcuSEFMRlBJICsgUkcuUEkgKyBSRy5IQUxGUEk7Y28ubGluZVdpZHRoID0gMTtcbiAgICBjby5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztjby5maWxsU3R5bGUgPSBncmFkO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAxMCwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSAtIFJHLkhBTEZQSSwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSAtIFJHLkhBTEZQSSArIDAuMDAwMDAxLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCByYWRpdXMgLSAzMCwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSArIDAuMDAwMDAxLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAxMCwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSArIFJHLkhBTEZQSSwgdGhpcy5hbmdsZXMubmVlZGxlW2luZGV4XSArIFJHLkhBTEZQSSArIDAuMDAwMDAxLCBmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZHJhd0NlbnRlcnBpbiA9IHRoaXMuRHJhd0NlbnRlcnBpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ10pIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ10gPSBSRy5SYWRpYWxHcmFkaWVudCh0aGlzLCB0aGlzLmNlbnRlcnggKyA1LCB0aGlzLmNlbnRlcnkgLSA1LCAwLCB0aGlzLmNlbnRlcnggKyA1LCB0aGlzLmNlbnRlcnkgLSA1LCAyMCwgJ3doaXRlJywgcHJvcFsnY2hhcnQuY2VudGVycGluLmNvbG9yJ10pO1xuICAgIH1cbiAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jZW50ZXJwaW4uZmlsbCddO2NvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aCA9IDI7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAxNSwgMCwgUkdyYXBoLlRXT1BJLCBmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbnVtTGFiZWxzID0gNjtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1MYWJlbHM7ICsraSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7dmFyIG51bSA9IE51bWJlcih0aGlzLm1pbiArICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChpIC8gKG51bUxhYmVscyAtIDEpKSkudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKTtudW0gPSBSRy5udW1iZXJfZm9ybWF0KHRoaXMsIG51bSwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSk7dmFyIGFuZ2xlID0gaSAqIDE4IC8gKDE4MCAvIFJHLlBJKTtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudGV4dC5mb250J10sICdzaXplJzogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sICd4JzogdGhpcy5jZW50ZXJ4ICsgbWEuc2luKGFuZ2xlKSAqICh0aGlzLnJhZGl1cyAtIDUzKSwgJ3knOiB0aGlzLmNlbnRlcnkgLSBtYS5jb3MoYW5nbGUpICogKHRoaXMucmFkaXVzIC0gNTMpLCAndGV4dCc6IFN0cmluZyhudW0pLCAndmFsaWduJzogJ3RvcCcsICdoYWxpZ24nOiAnY2VudGVyJywgJ2FuZ2xlJzogOTAgKiAoaSAvIChudW1MYWJlbHMgLSAxKSksICd0YWcnOiAnc2NhbGUnIH0pO2NvLmZpbGwoKTtcbiAgICB9XG4gIH07dGhpcy5kcmF3VGlja21hcmtzID0gdGhpcy5EcmF3VGlja21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiaWdUaWNrcyA9IDU7dmFyIHNtYWxsVGlja3MgPSAyNTtmb3IgKHZhciBpID0gMDsgaSA8IHNtYWxsVGlja3M7ICsraSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7dmFyIGFuZ2xlID0gUkcuSEFMRlBJIC8gKHNtYWxsVGlja3MgLSAxKSAqIGk7XG4gICAgICBjby5saW5lV2lkdGggPSAxO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSA0NCwgUkcuUEkgKyBSRy5IQUxGUEkgKyBhbmdsZSwgUkcuUEkgKyBSRy5IQUxGUEkgKyBhbmdsZSArIDAuMDAwMSwgZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSA0NiwgUkcuUEkgKyBSRy5IQUxGUEkgKyBhbmdsZSwgUkcuUEkgKyBSRy5IQUxGUEkgKyBhbmdsZSArIDAuMDAwMSwgZmFsc2UpO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpZ1RpY2tzOyArK2kpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciBhbmdsZSA9IFJHLkhBTEZQSSAvIChiaWdUaWNrcyAtIDEpICogaTtcbiAgICAgIGNvLmxpbmVXaWR0aCA9IDE7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDQzLCBSRy5QSSArIFJHLkhBTEZQSSArIGFuZ2xlLCBSRy5QSSArIFJHLkhBTEZQSSArIGFuZ2xlICsgMC4wMDAxLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDQ3LCBSRy5QSSArIFJHLkhBTEZQSSArIGFuZ2xlLCBSRy5QSSArIFJHLkhBTEZQSSArIGFuZ2xlICsgMC4wMDAxLCBmYWxzZSk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICB9O3RoaXMuRHJhd0NvbG9yQmFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJHLmlzX2FycmF5KHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXSkpIHtcbiAgICAgIHZhciByYW5nZXMgPSBwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjby5maWxsU3R5bGUgPSByYW5nZXNbaV1bMl07Y28ubGluZVdpZHRoID0gMDtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNTQgLSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAqIDEuNSwgKHJhbmdlc1tpXVswXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLkhBTEZQSSArIChSRy5QSSArIFJHLkhBTEZQSSksIChyYW5nZXNbaV1bMV0gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiBSRy5IQUxGUEkgKyAoUkcuUEkgKyBSRy5IQUxGUEkpLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDU0IC0gMTAgLSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAqIDEuNSwgKHJhbmdlc1tpXVsxXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLkhBTEZQSSArIChSRy5QSSArIFJHLkhBTEZQSSksIChyYW5nZXNbaV1bMF0gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiBSRy5IQUxGUEkgKyAoUkcuUEkgKyBSRy5IQUxGUEkpLCB0cnVlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5ncmVlbi5jb2xvciddO3ZhciBncmVlblN0YXJ0ID0gUkcuUEkgKyBSRy5IQUxGUEk7dmFyIGdyZWVuRW5kID0gZ3JlZW5TdGFydCArIChSRy5UV09QSSAtIGdyZWVuU3RhcnQpICogKChwcm9wWydjaGFydC5ncmVlbi5lbmQnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDU0IC0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKiAxLjUsIGdyZWVuU3RhcnQsIGdyZWVuRW5kLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDU0IC0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKiAxLjUgLSAxMCwgZ3JlZW5FbmQsIGdyZWVuU3RhcnQsIHRydWUpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO3ZhciB5ZWxsb3dTdGFydCA9IGdyZWVuRW5kO3ZhciB5ZWxsb3dFbmQgPSAocHJvcFsnY2hhcnQucmVkLnN0YXJ0J10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiBSRy5IQUxGUEkgKyBSRy5QSSArIFJHLkhBTEZQSTtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNTQgLSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAqIDEuNSwgeWVsbG93U3RhcnQsIHllbGxvd0VuZCwgZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSA1NCAtIHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICogMS41IC0gMTAsIHllbGxvd0VuZCwgeWVsbG93U3RhcnQsIHRydWUpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddO3ZhciByZWRTdGFydCA9IHllbGxvd0VuZDt2YXIgcmVkRW5kID0gUkdyYXBoLlRXT1BJO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSA1NCAtIHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICogMS41LCByZWRTdGFydCwgcmVkRW5kLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDU0IC0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKiAxLjUgLSAxMCwgcmVkRW5kLCByZWRTdGFydCwgdHJ1ZSk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZHJhd0xhYmVsID0gdGhpcy5EcmF3TGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQnXSkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciB2YWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09ICdudW1iZXInID8gdGhpcy52YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuZGVjaW1hbHMnXSkgOiB0aGlzLnZhbHVlO2lmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlRmxvYXQodmFsdWVbaV0pLnRvRml4ZWQocHJvcFsnY2hhcnQudmFsdWUudGV4dC5kZWNpbWFscyddKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudmFsdWUudGV4dC5mb250J10sICdzaXplJzogcHJvcFsnY2hhcnQudmFsdWUudGV4dC5zaXplJ10sICd4JzogdGhpcy5jZW50ZXJ4ICsgbWEuY29zKFJHLlBJIC8gMTgwICogNDUpICogKHRoaXMucmFkaXVzIC8gMyksICd5JzogdGhpcy5jZW50ZXJ5IC0gbWEuc2luKFJHLlBJIC8gMTgwICogNDUpICogKHRoaXMucmFkaXVzIC8gMyksICd0ZXh0JzogcHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnXSArIHZhbHVlICsgcHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wb3N0J10sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiBwcm9wWydjaGFydC52YWx1ZS50ZXh0LmJveGVkJ10sICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAnYm9sZCc6IHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuYm9sZCddLCAndGFnJzogJ3ZhbHVlLnRleHQnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHt9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07dmFyIGFuZ2xlID0gUkcuZ2V0QW5nbGVCeVhZKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBtb3VzZVgsIG1vdXNlWSk7aWYgKGFuZ2xlID4gUkcuVFdPUEkgJiYgYW5nbGUgPCBSRy5QSSArIFJHLkhBTEZQSSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChhbmdsZSAtIChSRy5QSSArIFJHLkhBTEZQSSkpIC8gKFJHLlRXT1BJIC0gKFJHLlBJICsgUkcuSEFMRlBJKSkgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7dmFsdWUgPSB2YWx1ZSArIHRoaXMubWluO2lmICh2YWx1ZSA8IHRoaXMubWluKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgaWYgKG1vdXNlWCA+IHRoaXMuY2VudGVyeCAmJiBtb3VzZVkgPiB0aGlzLmNlbnRlcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkdyYXBoLmdldE1vdXNlWFkoZSk7aWYgKG1vdXNlWFlbMF0gPiB0aGlzLmNlbnRlcnggLSA1ICYmIG1vdXNlWFlbMF0gPCB0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzFdID4gdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXMgJiYgbW91c2VYWVsxXSA8IHRoaXMuY2VudGVyeSArIDUgJiYgUkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKSA8PSB0aGlzLnJhZGl1cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZSA9IHRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpICYmIFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkID09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRWYWx1ZShlKTtSRy5DbGVhcihjYSk7UkcuUmVkcmF3Q2FudmFzKGNhKTtSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYWRqdXN0Jyk7XG4gICAgfVxuICB9O3RoaXMuZ2V0QW5nbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCB0aGlzLm1pbiB8fCB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGFuZ2xlID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogUkcuSEFMRlBJO1xuICAgIGFuZ2xlICs9IFJHLlBJICsgUkcuSEFMRlBJO3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMucmFuZ2VzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5ncmVlbi5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnllbGxvdy5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5yZWQuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTtcbiAgICB9XG4gICAgaWYgKCFSRy5pc19udWxsKHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXVtpXVsyXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXVtpXVsyXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTtwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddKTtwcm9wWydjaGFydC5yZWQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTtcbiAgICB9XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIHJhZGl1c19zdGFydCA9IHRoaXMucmFkaXVzIC0gNTQgLSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgcmFkaXVzX2VuZCA9IHJhZGl1c19zdGFydCAtIDE1O3ZhciBncmFkID0gY28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHJhZGl1c19zdGFydCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHJhZGl1c19lbmQpO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDEsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICB0aGlzW3R5cGVdID0gZnVuYztyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IGFyZ3VtZW50c1swXTt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07dmFyIG51bUZyYW1lcyA9IDMwO3ZhciBmcmFtZSA9IDA7dmFyIG9iaiA9IHRoaXM7aWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG9yaWdWYWx1ZSA9IE51bWJlcih0aGlzLmN1cnJlbnRWYWx1ZSk7aWYgKHRoaXMuY3VycmVudFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5taW47b3JpZ1ZhbHVlID0gdGhpcy5taW47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO3ZhciBkaWZmID0gbmV3VmFsdWUgLSBvcmlnVmFsdWU7dmFyIHN0ZXAgPSBkaWZmIC8gbnVtRnJhbWVzO3ZhciBmcmFtZSA9IDA7dmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgIGZyYW1lKys7b2JqLnZhbHVlID0gZnJhbWUgLyBudW1GcmFtZXMgKiBkaWZmICsgb3JpZ1ZhbHVlO1xuICAgICAgICBpZiAob2JqLnZhbHVlID4gb2JqLm1heCkgb2JqLnZhbHVlID0gb2JqLm1heDtpZiAob2JqLnZhbHVlIDwgb2JqLm1pbikgb2JqLnZhbHVlID0gb2JqLm1pbjtSR3JhcGguQ2xlYXIob2JqLmNhbnZhcyk7UkdyYXBoLlJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoZnJhbWUgPCAzMCkge1xuICAgICAgICAgIFJHcmFwaC5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtpdGVyYXRvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob2JqLmN1cnJlbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG9iai5jdXJyZW50VmFsdWUgPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLnZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgb2JqLmN1cnJlbnRWYWx1ZVtpXSA9IG9iai5taW47XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ1ZhbHVlID0gUkcuYXJyYXlfY2xvbmUob2JqLmN1cnJlbnRWYWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ1ZhbHVlID0gUkcuYXJyYXlfY2xvbmUob2JqLmN1cnJlbnRWYWx1ZSk7dmFyIG5ld1ZhbHVlID0gUkcuYXJyYXlfY2xvbmUob2JqLnZhbHVlKTt2YXIgZGlmZiA9IFtdO3ZhciBzdGVwID0gW107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG5ld1ZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGRpZmZbaV0gPSBuZXdWYWx1ZVtpXSAtIE51bWJlcihvYmouY3VycmVudFZhbHVlW2ldKTtzdGVwW2ldID0gZGlmZltpXSAvIG51bUZyYW1lcztcbiAgICAgIH1cbiAgICAgIHZhciBtYXggPSB0aGlzLm1heDt2YXIgbWluID0gdGhpcy5taW47dmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgIGZyYW1lKys7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai52YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIG9iai52YWx1ZVtpXSA9IGZyYW1lIC8gbnVtRnJhbWVzICogZGlmZltpXSArIG9yaWdWYWx1ZVtpXTtpZiAob2JqLnZhbHVlW2ldID4gbWF4KSBvYmoudmFsdWVbaV0gPSBtYXg7aWYgKG9iai52YWx1ZVtpXSA8IG1pbikgb2JqLnZhbHVlW2ldID0gbWluO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWUgPCAzMCkge1xuICAgICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgICB9XG4gICAgICB9O2l0ZXJhdG9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBSRy5SZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguY29ybmVyZ2F1Z2UuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Background = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id);\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.type = 'drawing.background';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.linewidth': 1, 'chart.title': '', 'chart.title.size': null, 'chart.title.font': null, 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.color': 'black', 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': 'black', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.yaxis.pos': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.BACKGROUND] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa = RG.Path,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RG.drawBackgroundImage(this);RG.Background.draw(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var tooltip = prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null;\n      return { 0: this, 1: 0, 2: tooltip, 'object': this, 'index': 0, 'tooltip': tooltip };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b r % % % % f % s %', prop['chart.gutter.left'], prop['chart.gutter.top'], ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'], prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, ca.height - this.gutterRight),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmJhY2tncm91bmQuanM/MWI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnR5cGUgPSAnZHJhd2luZy5iYWNrZ3JvdW5kJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOiAnI2RkZCcsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQud2lkdGgnOiAxLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzogNSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6IDIwLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRhc2hlZCc6IGZhbHNlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRvdHRlZCc6IGZhbHNlLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZSc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS54JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLncnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5oJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxpZ24nOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6IG51bGwsICdjaGFydC5ndXR0ZXIubGVmdCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMjUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMjUsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5saW5ld2lkdGgnOiAxLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLnNpemUnOiBudWxsLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUudnBvcyc6IG51bGwsICdjaGFydC50aXRsZS5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRpdGxlLngnOiBudWxsLCAnY2hhcnQudGl0bGUueSc6IG51bGwsICdjaGFydC50aXRsZS5oYWxpZ24nOiBudWxsLCAnY2hhcnQudGl0bGUudmFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzJzogJycsICdjaGFydC50aXRsZS54YXhpcy5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLnhheGlzLnNpemUnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLnknOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMucG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzJzogJycsICdjaGFydC50aXRsZS55YXhpcy5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6ICdibGFjaycsICdjaGFydC50aXRsZS55YXhpcy54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLnknOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMucG9zJzogbnVsbCwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRFJBV0lORy5CQUNLR1JPVU5EXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjtcbiAgfVxuICB0aGlzLiQwID0ge307aWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEgPSBSRy5QYXRoLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTt0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBSRy5kcmF3QmFja2dyb3VuZEltYWdlKHRoaXMpO1JHLkJhY2tncm91bmQuZHJhdyh0aGlzKTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5nZXRTaGFwZShlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXTtpZiAobW91c2VYID49IHRoaXMuZ3V0dGVyTGVmdCAmJiBtb3VzZVggPD0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICYmIG1vdXNlWSA+PSB0aGlzLmd1dHRlclRvcCAmJiBtb3VzZVkgPD0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pIHtcbiAgICAgIHZhciB0b29sdGlwID0gcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA/IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF0gOiBudWxsO1xuICAgICAgcmV0dXJuIHsgMDogdGhpcywgMTogMCwgMjogdG9vbHRpcCwgJ29iamVjdCc6IHRoaXMsICdpbmRleCc6IDAsICd0b29sdGlwJzogdG9vbHRpcCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhMihjbywgJ2IgciAlICUgJSAlIGYgJSBzICUnLCBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLCBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10sIGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLCBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmd1dHRlckxlZnQsIHRoaXMuZ3V0dGVyVG9wLCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyUmlnaHQpLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2ZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O1JHLnJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmJhY2tncm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///177\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Circle = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.circle';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.linewidth': 2, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.CIRCLE] No canvas support');return;\n  }\n  this.coords = [[this.centerx, this.centery, this.radius]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, 'b lw %', prop['chart.linewidth']);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    pa2(co, 'b a % % % % % % f % s %', this.coords[0][0], this.coords[0][1], this.radius, 0, RG.TWOPI, false, prop['chart.fillstyle'], prop['chart.strokestyle']);RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, 'b a % % % % % % f % s %', this.centerx, this.centery, this.radius + 0.5, 0, RG.TWOPI, false, prop['chart.highlight.fill'], prop['chart.highlight.stroke']);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmNpcmNsZS5qcz9iZmFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkRyYXdpbmcgPSBSR3JhcGguRHJhd2luZyB8fCB7fTtSR3JhcGguRHJhd2luZy5DaXJjbGUgPSBmdW5jdGlvbiAoY29uZikge1xuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLnggPT09ICdudW1iZXInICYmIHR5cGVvZiBjb25mLnkgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb25mLnJhZGl1cyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICB4ID0gY29uZi54LFxuICAgICAgICB5ID0gY29uZi55LFxuICAgICAgICByYWRpdXMgPSBjb25mLnJhZGl1cyxcbiAgICAgICAgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZixcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICB4ID0gYXJndW1lbnRzWzFdLFxuICAgICAgICB5ID0gYXJndW1lbnRzWzJdLFxuICAgICAgICByYWRpdXMgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLmNlbnRlcnggPSB4O3RoaXMuY2VudGVyeSA9IHk7dGhpcy5yYWRpdXMgPSByYWRpdXM7dGhpcy50eXBlID0gJ2RyYXdpbmcuY2lyY2xlJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5maWxsc3R5bGUnOiAncmVkJywgJ2NoYXJ0LmV2ZW50cy5jbGljayc6IG51bGwsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzogbnVsbCwgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ2dyYXknLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQuc2hhZG93LmJsdXInOiA1LCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdibGFjaycsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQubGluZXdpZHRoJzogMiwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRFJBV0lORy5DSVJDTEVdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuY29vcmRzID0gW1t0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXNdXTt0aGlzLiQwID0ge307aWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBwcm9wW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHBhMihjbywgJ2IgbHcgJScsIHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddKTtpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgIFJHLnNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7XG4gICAgfVxuICAgIHBhMihjbywgJ2IgYSAlICUgJSAlICUgJSBmICUgcyAlJywgdGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzWzBdWzFdLCB0aGlzLnJhZGl1cywgMCwgUkcuVFdPUEksIGZhbHNlLCBwcm9wWydjaGFydC5maWxsc3R5bGUnXSwgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7Ukcubm9TaGFkb3codGhpcyk7UkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuZ2V0U2hhcGUoZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKFJHLmdldEh5cExlbmd0aCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYWVswXSwgbW91c2VYWVsxXSkgPD0gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHJldHVybiB7IDA6IHRoaXMsIDE6IHRoaXMuY2VudGVyeCwgMjogdGhpcy5jZW50ZXJ5LCAzOiB0aGlzLnJhZGl1cywgNDogbnVsbCwgNTogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogdGhpcy5jZW50ZXJ4LCAneSc6IHRoaXMuY2VudGVyeSwgJ3JhZGl1cyc6IHRoaXMucmFkaXVzLCAnaW5kZXgnOiAwLCAndG9vbHRpcCc6IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10gPyBwcm9wWydjaGFydC50b29sdGlwcyddWzBdIDogbnVsbCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhMihjbywgJ2IgYSAlICUgJSAlICUgJSBmICUgcyAlJywgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzICsgMC41LCAwLCBSRy5UV09QSSwgZmFsc2UsIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAwLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMpLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2ZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O1JHLnJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///178\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Image = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.src === 'string' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        src = conf.src,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        src = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.alignmentProcessed = false;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.src = src;this.img = new Image();this.img.src = this.src;this.type = 'drawing.image';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.src': null, 'chart.width': null, 'chart.height': null, 'chart.halign': 'left', 'chart.valign': 'top', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.alpha': 1, 'chart.border': false, 'chart.border.color': 'black', 'chart.border.linewidth': 1, 'chart.border.radius': 0, 'chart.background.color': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.IMAGE] No canvas support');return;\n  }\n  this.coords = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');var obj = this;this.img.onload = function () {\n      if (!obj.colorsParsed) {\n        obj.parseColors();obj.colorsParsed = true;\n      }\n      obj.width = this.width;obj.height = this.height;if (!this.alignmentProcessed) {\n        var customWidthHeight = typeof obj.properties['chart.width'] == 'number' && typeof obj.properties['chart.width'] == 'number';if (obj.properties['chart.halign'] === 'center') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] / 2 : this.width / 2;\n        } else if (obj.properties['chart.halign'] == 'right') {\n          obj.x -= customWidthHeight ? obj.properties['chart.width'] : this.width;\n        }\n        if (obj.properties['chart.valign'] === 'center') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] / 2 : this.height / 2;\n        } else if (obj.properties['chart.valign'] == 'bottom') {\n          obj.y -= customWidthHeight ? obj.properties['chart.height'] : this.height;\n        }\n        this.alignmentProcessed = true;\n      }\n    };\n    if (this.img.complete || this.img.readyState === 4) {\n      this.img.onload();\n    }\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var oldAlpha = co.globalAlpha;co.globalAlpha = prop['chart.alpha'];if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.border.linewidth'];var borderRadius = 0;if (this.width || this.height) {\n        borderRadius = ma.min(this.width / 2, this.height / 2);\n      }\n      if (prop['chart.width'] / 2 > borderRadius && prop['chart.height'] / 2 > borderRadius) {\n        borderRadius = ma.min(prop['chart.width'] / 2, prop['chart.height'] / 2);\n      }\n      if (prop['chart.border.radius'] < borderRadius) {\n        borderRadius = prop['chart.border.radius'];\n      }\n      co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);\n    }\n    if (borderRadius) {\n      co.save();this.drawBackgroundColor(borderRadius);co.beginPath();this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.clip();\n    } else {\n      this.drawBackgroundColor(0);\n    }\n    RG.noShadow(this);if (typeof prop['chart.height'] === 'number' || typeof prop['chart.width'] === 'number') {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y), prop['chart.width'] || this.width, prop['chart.height'] || this.height);\n    } else {\n      co.drawImage(this.img, ma.round(this.x), ma.round(this.y));\n    }\n    if (borderRadius) {\n      co.restore();\n    }\n    if (prop['chart.border']) {\n      RG.noShadow(this);co.stroke();\n    }\n    co.globalAlpha = oldAlpha;this.img.onload = function () {\n      RG.redrawCanvas(ca);obj.coords[0] = [ma.round(obj.x), ma.round(obj.y), typeof prop['chart.width'] === 'number' ? prop['chart.width'] : this.width, typeof prop['chart.height'] == 'number' ? prop['chart.height'] : this.height];\n    };\n    RG.noShadow(this);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (this.coords && this.coords[0] && mouseXY[0] >= this.coords[0][0] && mouseXY[0] <= this.coords[0][0] + this.coords[0][2] && mouseXY[1] >= this.coords[0][1] && mouseXY[1] <= this.coords[0][1] + this.coords[0][3]) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.img.width, this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.roundedRect = function (x, y, width, height, radius) {\n    co.save();co.translate(x, y);co.moveTo(width / 2, 0);co.arcTo(width, 0, width, height, ma.min(height / 2, radius));co.arcTo(width, height, 0, height, ma.min(width / 2, radius));co.arcTo(0, height, 0, 0, ma.min(height / 2, radius));co.arcTo(0, 0, radius, 0, ma.min(width / 2, radius));co.lineTo(width / 2, 0);co.restore();\n  };this.drawBackgroundColor = function (borderRadius) {\n    co.beginPath();co.fillStyle = prop['chart.background.color'];this.roundedRect(ma.round(this.x) - ma.round(co.lineWidth / 2), ma.round(this.y) - ma.round(co.lineWidth / 2), (prop['chart.width'] || this.img.width) + co.lineWidth, (prop['chart.height'] || this.img.height) + co.lineWidth, borderRadius);co.fill();\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLmltYWdlLmpzPzYzN2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguRHJhd2luZyA9IFJHcmFwaC5EcmF3aW5nIHx8IHt9O1JHcmFwaC5EcmF3aW5nLkltYWdlID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29uZi55ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29uZi5zcmMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgeCA9IGNvbmYueCxcbiAgICAgICAgeSA9IGNvbmYueSxcbiAgICAgICAgc3JjID0gY29uZi5zcmMsXG4gICAgICAgIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZCA9IGNvbmYsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgeCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgeSA9IGFyZ3VtZW50c1syXSxcbiAgICAgICAgc3JjID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLmFsaWdubWVudFByb2Nlc3NlZCA9IGZhbHNlO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMueCA9IHg7dGhpcy55ID0geTt0aGlzLnNyYyA9IHNyYzt0aGlzLmltZyA9IG5ldyBJbWFnZSgpO3RoaXMuaW1nLnNyYyA9IHRoaXMuc3JjO3RoaXMudHlwZSA9ICdkcmF3aW5nLmltYWdlJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuc3JjJzogbnVsbCwgJ2NoYXJ0LndpZHRoJzogbnVsbCwgJ2NoYXJ0LmhlaWdodCc6IG51bGwsICdjaGFydC5oYWxpZ24nOiAnbGVmdCcsICdjaGFydC52YWxpZ24nOiAndG9wJywgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ2dyYXknLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQuc2hhZG93LmJsdXInOiA1LCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQuYWxwaGEnOiAxLCAnY2hhcnQuYm9yZGVyJzogZmFsc2UsICdjaGFydC5ib3JkZXIuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuYm9yZGVyLmxpbmV3aWR0aCc6IDEsICdjaGFydC5ib3JkZXIucmFkaXVzJzogMCwgJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5jbGVhcnRvJzogJ3JnYmEoMCwwLDAsMCknIH07XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0RSQVdJTkcuSU1BR0VdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuY29vcmRzID0gW107dGhpcy4kMCA9IHt9O2lmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7dmFyIG9iaiA9IHRoaXM7dGhpcy5pbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFvYmouY29sb3JzUGFyc2VkKSB7XG4gICAgICAgIG9iai5wYXJzZUNvbG9ycygpO29iai5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb2JqLndpZHRoID0gdGhpcy53aWR0aDtvYmouaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7aWYgKCF0aGlzLmFsaWdubWVudFByb2Nlc3NlZCkge1xuICAgICAgICB2YXIgY3VzdG9tV2lkdGhIZWlnaHQgPSB0eXBlb2Ygb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LndpZHRoJ10gPT0gJ251bWJlcicgJiYgdHlwZW9mIG9iai5wcm9wZXJ0aWVzWydjaGFydC53aWR0aCddID09ICdudW1iZXInO2lmIChvYmoucHJvcGVydGllc1snY2hhcnQuaGFsaWduJ10gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLnggLT0gY3VzdG9tV2lkdGhIZWlnaHQgPyBvYmoucHJvcGVydGllc1snY2hhcnQud2lkdGgnXSAvIDIgOiB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoucHJvcGVydGllc1snY2hhcnQuaGFsaWduJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIG9iai54IC09IGN1c3RvbVdpZHRoSGVpZ2h0ID8gb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LndpZHRoJ10gOiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucHJvcGVydGllc1snY2hhcnQudmFsaWduJ10gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgb2JqLnkgLT0gY3VzdG9tV2lkdGhIZWlnaHQgPyBvYmoucHJvcGVydGllc1snY2hhcnQuaGVpZ2h0J10gLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5wcm9wZXJ0aWVzWydjaGFydC52YWxpZ24nXSA9PSAnYm90dG9tJykge1xuICAgICAgICAgIG9iai55IC09IGN1c3RvbVdpZHRoSGVpZ2h0ID8gb2JqLnByb3BlcnRpZXNbJ2NoYXJ0LmhlaWdodCddIDogdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGlnbm1lbnRQcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuaW1nLmNvbXBsZXRlIHx8IHRoaXMuaW1nLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgIHRoaXMuaW1nLm9ubG9hZCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgIFJHLnNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7XG4gICAgfVxuICAgIHZhciBvbGRBbHBoYSA9IGNvLmdsb2JhbEFscGhhO2NvLmdsb2JhbEFscGhhID0gcHJvcFsnY2hhcnQuYWxwaGEnXTtpZiAocHJvcFsnY2hhcnQuYm9yZGVyJ10pIHtcbiAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yJ107Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuYm9yZGVyLmxpbmV3aWR0aCddO3ZhciBib3JkZXJSYWRpdXMgPSAwO2lmICh0aGlzLndpZHRoIHx8IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGJvcmRlclJhZGl1cyA9IG1hLm1pbih0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC53aWR0aCddIC8gMiA+IGJvcmRlclJhZGl1cyAmJiBwcm9wWydjaGFydC5oZWlnaHQnXSAvIDIgPiBib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgYm9yZGVyUmFkaXVzID0gbWEubWluKHByb3BbJ2NoYXJ0LndpZHRoJ10gLyAyLCBwcm9wWydjaGFydC5oZWlnaHQnXSAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LmJvcmRlci5yYWRpdXMnXSA8IGJvcmRlclJhZGl1cykge1xuICAgICAgICBib3JkZXJSYWRpdXMgPSBwcm9wWydjaGFydC5ib3JkZXIucmFkaXVzJ107XG4gICAgICB9XG4gICAgICBjby5iZWdpblBhdGgoKTt0aGlzLnJvdW5kZWRSZWN0KG1hLnJvdW5kKHRoaXMueCkgLSBtYS5yb3VuZChjby5saW5lV2lkdGggLyAyKSwgbWEucm91bmQodGhpcy55KSAtIG1hLnJvdW5kKGNvLmxpbmVXaWR0aCAvIDIpLCAocHJvcFsnY2hhcnQud2lkdGgnXSB8fCB0aGlzLmltZy53aWR0aCkgKyBjby5saW5lV2lkdGgsIChwcm9wWydjaGFydC5oZWlnaHQnXSB8fCB0aGlzLmltZy5oZWlnaHQpICsgY28ubGluZVdpZHRoLCBib3JkZXJSYWRpdXMpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyUmFkaXVzKSB7XG4gICAgICBjby5zYXZlKCk7dGhpcy5kcmF3QmFja2dyb3VuZENvbG9yKGJvcmRlclJhZGl1cyk7Y28uYmVnaW5QYXRoKCk7dGhpcy5yb3VuZGVkUmVjdChtYS5yb3VuZCh0aGlzLngpIC0gbWEucm91bmQoY28ubGluZVdpZHRoIC8gMiksIG1hLnJvdW5kKHRoaXMueSkgLSBtYS5yb3VuZChjby5saW5lV2lkdGggLyAyKSwgKHByb3BbJ2NoYXJ0LndpZHRoJ10gfHwgdGhpcy5pbWcud2lkdGgpICsgY28ubGluZVdpZHRoLCAocHJvcFsnY2hhcnQuaGVpZ2h0J10gfHwgdGhpcy5pbWcuaGVpZ2h0KSArIGNvLmxpbmVXaWR0aCwgYm9yZGVyUmFkaXVzKTtjby5jbGlwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmRDb2xvcigwKTtcbiAgICB9XG4gICAgUkcubm9TaGFkb3codGhpcyk7aWYgKHR5cGVvZiBwcm9wWydjaGFydC5oZWlnaHQnXSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BbJ2NoYXJ0LndpZHRoJ10gPT09ICdudW1iZXInKSB7XG4gICAgICBjby5kcmF3SW1hZ2UodGhpcy5pbWcsIG1hLnJvdW5kKHRoaXMueCksIG1hLnJvdW5kKHRoaXMueSksIHByb3BbJ2NoYXJ0LndpZHRoJ10gfHwgdGhpcy53aWR0aCwgcHJvcFsnY2hhcnQuaGVpZ2h0J10gfHwgdGhpcy5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby5kcmF3SW1hZ2UodGhpcy5pbWcsIG1hLnJvdW5kKHRoaXMueCksIG1hLnJvdW5kKHRoaXMueSkpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyUmFkaXVzKSB7XG4gICAgICBjby5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgUkcubm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvLmdsb2JhbEFscGhhID0gb2xkQWxwaGE7dGhpcy5pbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgUkcucmVkcmF3Q2FudmFzKGNhKTtvYmouY29vcmRzWzBdID0gW21hLnJvdW5kKG9iai54KSwgbWEucm91bmQob2JqLnkpLCB0eXBlb2YgcHJvcFsnY2hhcnQud2lkdGgnXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC53aWR0aCddIDogdGhpcy53aWR0aCwgdHlwZW9mIHByb3BbJ2NoYXJ0LmhlaWdodCddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQuaGVpZ2h0J10gOiB0aGlzLmhlaWdodF07XG4gICAgfTtcbiAgICBSRy5ub1NoYWRvdyh0aGlzKTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7aWYgKHRoaXMuZ2V0U2hhcGUoZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKHRoaXMuY29vcmRzICYmIHRoaXMuY29vcmRzWzBdICYmIG1vdXNlWFlbMF0gPj0gdGhpcy5jb29yZHNbMF1bMF0gJiYgbW91c2VYWVswXSA8PSB0aGlzLmNvb3Jkc1swXVswXSArIHRoaXMuY29vcmRzWzBdWzJdICYmIG1vdXNlWFlbMV0gPj0gdGhpcy5jb29yZHNbMF1bMV0gJiYgbW91c2VYWVsxXSA8PSB0aGlzLmNvb3Jkc1swXVsxXSArIHRoaXMuY29vcmRzWzBdWzNdKSB7XG4gICAgICByZXR1cm4geyAwOiB0aGlzLCAxOiB0aGlzLmNvb3Jkc1swXVswXSwgMjogdGhpcy5jb29yZHNbMF1bMV0sIDM6IHRoaXMuY29vcmRzWzBdWzJdLCA0OiB0aGlzLmNvb3Jkc1swXVszXSwgNTogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogdGhpcy5jb29yZHNbMF1bMF0sICd5JzogdGhpcy5jb29yZHNbMF1bMV0sICd3aWR0aCc6IHRoaXMuY29vcmRzWzBdWzJdLCAnaGVpZ2h0JzogdGhpcy5jb29yZHNbMF1bM10sICdpbmRleCc6IDAsICd0b29sdGlwJzogcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA/IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF0gOiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGEyKGNvLCBbJ2InLCAncicsIHRoaXMuY29vcmRzWzBdWzBdLCB0aGlzLmNvb3Jkc1swXVsxXSwgdGhpcy5jb29yZHNbMF1bMl0sIHRoaXMuY29vcmRzWzBdWzNdLCAnZicsIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sICdzJywgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLngsIHRoaXMueSwgdGhpcy54ICsgdGhpcy5pbWcud2lkdGgsIHRoaXMueSksXG4gICAgICAgICAgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucm91bmRlZFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgY28uc2F2ZSgpO2NvLnRyYW5zbGF0ZSh4LCB5KTtjby5tb3ZlVG8od2lkdGggLyAyLCAwKTtjby5hcmNUbyh3aWR0aCwgMCwgd2lkdGgsIGhlaWdodCwgbWEubWluKGhlaWdodCAvIDIsIHJhZGl1cykpO2NvLmFyY1RvKHdpZHRoLCBoZWlnaHQsIDAsIGhlaWdodCwgbWEubWluKHdpZHRoIC8gMiwgcmFkaXVzKSk7Y28uYXJjVG8oMCwgaGVpZ2h0LCAwLCAwLCBtYS5taW4oaGVpZ2h0IC8gMiwgcmFkaXVzKSk7Y28uYXJjVG8oMCwgMCwgcmFkaXVzLCAwLCBtYS5taW4od2lkdGggLyAyLCByYWRpdXMpKTtjby5saW5lVG8od2lkdGggLyAyLCAwKTtjby5yZXN0b3JlKCk7XG4gIH07dGhpcy5kcmF3QmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24gKGJvcmRlclJhZGl1cykge1xuICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTt0aGlzLnJvdW5kZWRSZWN0KG1hLnJvdW5kKHRoaXMueCkgLSBtYS5yb3VuZChjby5saW5lV2lkdGggLyAyKSwgbWEucm91bmQodGhpcy55KSAtIG1hLnJvdW5kKGNvLmxpbmVXaWR0aCAvIDIpLCAocHJvcFsnY2hhcnQud2lkdGgnXSB8fCB0aGlzLmltZy53aWR0aCkgKyBjby5saW5lV2lkdGgsIChwcm9wWydjaGFydC5oZWlnaHQnXSB8fCB0aGlzLmltZy5oZWlnaHQpICsgY28ubGluZVdpZHRoLCBib3JkZXJSYWRpdXMpO2NvLmZpbGwoKTtcbiAgfTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5pbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///179\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker1 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.radius == 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3],\n        text = arguments[4];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext(\"2d\");this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.centerx = x;this.centery = y;this.radius = radius;this.text = text;this.type = 'drawing.marker1';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.linewidth': 2, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,0,0,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.align': 'center', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER1] No canvas support');return;\n  }\n  this.$0 = {};this.coords = [];this.coordsText = [];if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');var r = this.radius;if (prop['chart.align'] == 'left') {\n      this.markerCenterx = this.centerx - r - r - 3;this.markerCentery = this.centery - r - r - 3;\n    } else if (prop['chart.align'] == 'right') {\n      this.markerCenterx = this.centerx + r + r + 3;this.markerCentery = this.centery - r - r - 3;\n    } else {\n      this.markerCenterx = this.centerx;this.markerCentery = this.centery - r - r - 3;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];pa2(co, ['b', 'lw', prop['chart.linewidth']]);if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.drawMarker();pa2(co, ['c', 's', prop['chart.strokestyle'], 'f', prop['chart.fillstyle']]);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] - 1, y: this.coords[0][1] - 1, text: this.text, valign: 'center', halign: 'center', tag: 'labels' });RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();this.drawMarker();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n      return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'radius': this.coords[0][2], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];this.drawMarker();co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.drawMarker = this.DrawMarker = function () {\n    var r = this.radius;if (prop['chart.align'] === 'left') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.TWOPI, false]);pa2(co, ['qc', x + r, y + r, x + r + r, y + r + r]);pa2(co, ['qc', x + r, y + r, x, y + r]);\n    } else if (prop['chart.align'] === 'right') {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI, RG.PI, true]);pa2(co, ['qc', x - r, y + r, x - r - r, y + r + r]);pa2(co, ['qc', x - r, y + r, x, y + r]);\n    } else {\n      var x = this.markerCenterx,\n          y = this.markerCentery;pa2(co, ['a', x, y, r, RG.HALFPI / 2, RG.PI - RG.HALFPI / 2, true]);pa2(co, ['qc', x, y + r + r / 4, x, y + r + r - 2]);pa2(co, ['qc', x, y + r + r / 4, x + ma.cos(RG.HALFPI / 2) * r, y + ma.sin(RG.HALFPI / 2) * r]);\n    }\n    this.coords[0] = [x, y, r];\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.arrayClone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.markerCenterx, this.markerCentery, 0, this.markerCenterx, this.markerCentery, this.radius),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLm1hcmtlcjEuanM/NDg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuTWFya2VyMSA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYueSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYucmFkaXVzID09ICdudW1iZXInICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgY29uZi50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgeCA9IGNvbmYueCxcbiAgICAgICAgeSA9IGNvbmYueSxcbiAgICAgICAgcmFkaXVzID0gY29uZi5yYWRpdXMsXG4gICAgICAgIHRleHQgPSBjb25mLnRleHQsXG4gICAgICAgIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZCA9IGNvbmYsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgeCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgeSA9IGFyZ3VtZW50c1syXSxcbiAgICAgICAgcmFkaXVzID0gYXJndW1lbnRzWzNdLFxuICAgICAgICB0ZXh0ID0gYXJndW1lbnRzWzRdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGNhbnZhczt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLmNlbnRlcnggPSB4O3RoaXMuY2VudGVyeSA9IHk7dGhpcy5yYWRpdXMgPSByYWRpdXM7dGhpcy50ZXh0ID0gdGV4dDt0aGlzLnR5cGUgPSAnZHJhd2luZy5tYXJrZXIxJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAnYmxhY2snLCAnY2hhcnQuZmlsbHN0eWxlJzogJ3doaXRlJywgJ2NoYXJ0LmxpbmV3aWR0aCc6IDIsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQuc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICcjYWFhJywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMCwgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMCwgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogMTUsICdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOiAncmdiYSgyNTUsMCwwLDAuNyknLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQuYWxpZ24nOiAnY2VudGVyJywgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRFJBV0lORy5NQVJLRVIxXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjtcbiAgfVxuICB0aGlzLiQwID0ge307dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBwcm9wW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3ZhciByID0gdGhpcy5yYWRpdXM7aWYgKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLm1hcmtlckNlbnRlcnggPSB0aGlzLmNlbnRlcnggLSByIC0gciAtIDM7dGhpcy5tYXJrZXJDZW50ZXJ5ID0gdGhpcy5jZW50ZXJ5IC0gciAtIHIgLSAzO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuYWxpZ24nXSA9PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLm1hcmtlckNlbnRlcnggPSB0aGlzLmNlbnRlcnggKyByICsgciArIDM7dGhpcy5tYXJrZXJDZW50ZXJ5ID0gdGhpcy5jZW50ZXJ5IC0gciAtIHIgLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlckNlbnRlcnggPSB0aGlzLmNlbnRlcng7dGhpcy5tYXJrZXJDZW50ZXJ5ID0gdGhpcy5jZW50ZXJ5IC0gciAtIHIgLSAzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvb3Jkc1RleHQgPSBbXTtwYTIoY28sIFsnYicsICdsdycsIHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddXSk7aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBSRy5zZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO1xuICAgIH1cbiAgICB0aGlzLmRyYXdNYXJrZXIoKTtwYTIoY28sIFsnYycsICdzJywgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSwgJ2YnLCBwcm9wWydjaGFydC5maWxsc3R5bGUnXV0pO1JHLm5vU2hhZG93KHRoaXMpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBzaXplOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgeDogdGhpcy5jb29yZHNbMF1bMF0gLSAxLCB5OiB0aGlzLmNvb3Jkc1swXVsxXSAtIDEsIHRleHQ6IHRoaXMudGV4dCwgdmFsaWduOiAnY2VudGVyJywgaGFsaWduOiAnY2VudGVyJywgdGFnOiAnbGFiZWxzJyB9KTtSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5nZXRTaGFwZShlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXTtjby5iZWdpblBhdGgoKTt0aGlzLmRyYXdNYXJrZXIoKTtpZiAoY28uaXNQb2ludEluUGF0aChtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKSkge1xuICAgICAgcmV0dXJuIHsgMDogdGhpcywgMTogdGhpcy5jb29yZHNbMF1bMF0sIDI6IHRoaXMuY29vcmRzWzBdWzFdLCAzOiB0aGlzLmNvb3Jkc1swXVsyXSwgNDogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogdGhpcy5jb29yZHNbMF1bMF0sICd5JzogdGhpcy5jb29yZHNbMF1bMV0sICdyYWRpdXMnOiB0aGlzLmNvb3Jkc1swXVsyXSwgJ2luZGV4JzogMCwgJ3Rvb2x0aXAnOiBwcm9wWydjaGFydC50b29sdGlwcyddID8gcHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXSA6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmIChwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXShzaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddO3RoaXMuZHJhd01hcmtlcigpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3TWFya2VyID0gdGhpcy5EcmF3TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7aWYgKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT09ICdsZWZ0Jykge1xuICAgICAgdmFyIHggPSB0aGlzLm1hcmtlckNlbnRlcngsXG4gICAgICAgICAgeSA9IHRoaXMubWFya2VyQ2VudGVyeTtwYTIoY28sIFsnYScsIHgsIHksIHIsIFJHLkhBTEZQSSwgUkcuVFdPUEksIGZhbHNlXSk7cGEyKGNvLCBbJ3FjJywgeCArIHIsIHkgKyByLCB4ICsgciArIHIsIHkgKyByICsgcl0pO3BhMihjbywgWydxYycsIHggKyByLCB5ICsgciwgeCwgeSArIHJdKTtcbiAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT09ICdyaWdodCcpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5tYXJrZXJDZW50ZXJ4LFxuICAgICAgICAgIHkgPSB0aGlzLm1hcmtlckNlbnRlcnk7cGEyKGNvLCBbJ2EnLCB4LCB5LCByLCBSRy5IQUxGUEksIFJHLlBJLCB0cnVlXSk7cGEyKGNvLCBbJ3FjJywgeCAtIHIsIHkgKyByLCB4IC0gciAtIHIsIHkgKyByICsgcl0pO3BhMihjbywgWydxYycsIHggLSByLCB5ICsgciwgeCwgeSArIHJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHggPSB0aGlzLm1hcmtlckNlbnRlcngsXG4gICAgICAgICAgeSA9IHRoaXMubWFya2VyQ2VudGVyeTtwYTIoY28sIFsnYScsIHgsIHksIHIsIFJHLkhBTEZQSSAvIDIsIFJHLlBJIC0gUkcuSEFMRlBJIC8gMiwgdHJ1ZV0pO3BhMihjbywgWydxYycsIHgsIHkgKyByICsgciAvIDQsIHgsIHkgKyByICsgciAtIDJdKTtwYTIoY28sIFsncWMnLCB4LCB5ICsgciArIHIgLyA0LCB4ICsgbWEuY29zKFJHLkhBTEZQSSAvIDIpICogciwgeSArIG1hLnNpbihSRy5IQUxGUEkgLyAyKSAqIHJdKTtcbiAgICB9XG4gICAgdGhpcy5jb29yZHNbMF0gPSBbeCwgeSwgcl07XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZmlsbHN0eWxlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IFJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXSA9IFJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6JyksXG4gICAgICAgICAgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMubWFya2VyQ2VudGVyeCwgdGhpcy5tYXJrZXJDZW50ZXJ5LCAwLCB0aGlzLm1hcmtlckNlbnRlcngsIHRoaXMubWFya2VyQ2VudGVyeSwgdGhpcy5yYWRpdXMpLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIxLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///180\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker2 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.text === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        text = conf.text,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.x = x;this.y = y;this.text = text;this.type = 'drawing.marker2';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'black', 'chart.fillstyle': 'white', 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.voffset': 20, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER2] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.lineWidth = 1;RG.fireCustomEvent(this, 'onbeforedraw');this.metrics = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);if (this.x + this.metrics[0] >= ca.width) {\n      this.alignRight = true;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var x = this.alignRight ? this.x - this.metrics[0] - 6 : this.x,\n        y = this.y - 6 - prop['chart.voffset'] - this.metrics[1],\n        width = this.metrics[0] + 6,\n        height = this.metrics[1] + 6;this.coords[0] = [x, y, width, height];this.coordsText = [];co.lineWidth = prop['chart.linewidth'];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];co.strokeRect(x + (this.alignRight ? width : 0), y, 0, height + prop['chart.voffset'] - 6);co.strokeRect(x, y, width, height);co.fillRect(x, y, width, height);RG.noShadow(this);co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: ma.round(this.x) - (this.alignRight ? this.metrics[0] + 3 : -3), y: this.y - 3 - prop['chart.voffset'], text: this.text, valign: 'bottom', halign: 'left', tag: 'labels' });this.coords[0].push([x, y, width, height]);RG.noShadow(this);co.textBaseline = 'alphabetic';RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (mouseX >= this.coords[0][0] && mouseX <= this.coords[0][0] + this.coords[0][2]) {\n      if (mouseY >= this.coords[0][1] && mouseY <= this.coords[0][1] + this.coords[0][3]) {\n        return { 0: this, 1: this.coords[0][0], 2: this.coords[0][1], 3: this.coords[0][2], 4: this.coords[0][3], 5: 0, 'object': this, 'x': this.coords[0][0], 'y': this.coords[0][1], 'width': this.coords[0][2], 'height': this.coords[0][3], 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(this.x, this.y, this.x + this.metrics[0], this.y),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLm1hcmtlcjIuanM/ODcwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuTWFya2VyMiA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYueSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjb25mLnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICB4ID0gY29uZi54LFxuICAgICAgICB5ID0gY29uZi55LFxuICAgICAgICB0ZXh0ID0gY29uZi50ZXh0LFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIHggPSBhcmd1bWVudHNbMV0sXG4gICAgICAgIHkgPSBhcmd1bWVudHNbMl0sXG4gICAgICAgIHRleHQgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgdGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnggPSB4O3RoaXMueSA9IHk7dGhpcy50ZXh0ID0gdGV4dDt0aGlzLnR5cGUgPSAnZHJhd2luZy5tYXJrZXIyJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAnYmxhY2snLCAnY2hhcnQuZmlsbHN0eWxlJzogJ3doaXRlJywgJ2NoYXJ0LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ2dyYXknLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQuc2hhZG93LmJsdXInOiA1LCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC52b2Zmc2V0JzogMjAsICdjaGFydC5jbGVhcnRvJzogJ3JnYmEoMCwwLDAsMCknIH07XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0RSQVdJTkcuTUFSS0VSMl0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLiQwID0ge307aWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28ubGluZVdpZHRoID0gMTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMubWV0cmljcyA9IFJHLm1lYXN1cmVUZXh0KHRoaXMudGV4dCwgcHJvcFsnY2hhcnQudGV4dC5ib2xkJ10sIHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBwcm9wWydjaGFydC50ZXh0LnNpemUnXSk7aWYgKHRoaXMueCArIHRoaXMubWV0cmljc1swXSA+PSBjYS53aWR0aCkge1xuICAgICAgdGhpcy5hbGlnblJpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHggPSB0aGlzLmFsaWduUmlnaHQgPyB0aGlzLnggLSB0aGlzLm1ldHJpY3NbMF0gLSA2IDogdGhpcy54LFxuICAgICAgICB5ID0gdGhpcy55IC0gNiAtIHByb3BbJ2NoYXJ0LnZvZmZzZXQnXSAtIHRoaXMubWV0cmljc1sxXSxcbiAgICAgICAgd2lkdGggPSB0aGlzLm1ldHJpY3NbMF0gKyA2LFxuICAgICAgICBoZWlnaHQgPSB0aGlzLm1ldHJpY3NbMV0gKyA2O3RoaXMuY29vcmRzWzBdID0gW3gsIHksIHdpZHRoLCBoZWlnaHRdO3RoaXMuY29vcmRzVGV4dCA9IFtdO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcuc2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICB9XG4gICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddO2NvLnN0cm9rZVJlY3QoeCArICh0aGlzLmFsaWduUmlnaHQgPyB3aWR0aCA6IDApLCB5LCAwLCBoZWlnaHQgKyBwcm9wWydjaGFydC52b2Zmc2V0J10gLSA2KTtjby5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO2NvLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1JHLm5vU2hhZG93KHRoaXMpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBzaXplOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgeDogbWEucm91bmQodGhpcy54KSAtICh0aGlzLmFsaWduUmlnaHQgPyB0aGlzLm1ldHJpY3NbMF0gKyAzIDogLTMpLCB5OiB0aGlzLnkgLSAzIC0gcHJvcFsnY2hhcnQudm9mZnNldCddLCB0ZXh0OiB0aGlzLnRleHQsIHZhbGlnbjogJ2JvdHRvbScsIGhhbGlnbjogJ2xlZnQnLCB0YWc6ICdsYWJlbHMnIH0pO3RoaXMuY29vcmRzWzBdLnB1c2goW3gsIHksIHdpZHRoLCBoZWlnaHRdKTtSRy5ub1NoYWRvdyh0aGlzKTtjby50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7UkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuZ2V0U2hhcGUoZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKG1vdXNlWCA+PSB0aGlzLmNvb3Jkc1swXVswXSAmJiBtb3VzZVggPD0gdGhpcy5jb29yZHNbMF1bMF0gKyB0aGlzLmNvb3Jkc1swXVsyXSkge1xuICAgICAgaWYgKG1vdXNlWSA+PSB0aGlzLmNvb3Jkc1swXVsxXSAmJiBtb3VzZVkgPD0gdGhpcy5jb29yZHNbMF1bMV0gKyB0aGlzLmNvb3Jkc1swXVszXSkge1xuICAgICAgICByZXR1cm4geyAwOiB0aGlzLCAxOiB0aGlzLmNvb3Jkc1swXVswXSwgMjogdGhpcy5jb29yZHNbMF1bMV0sIDM6IHRoaXMuY29vcmRzWzBdWzJdLCA0OiB0aGlzLmNvb3Jkc1swXVszXSwgNTogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogdGhpcy5jb29yZHNbMF1bMF0sICd5JzogdGhpcy5jb29yZHNbMF1bMV0sICd3aWR0aCc6IHRoaXMuY29vcmRzWzBdWzJdLCAnaGVpZ2h0JzogdGhpcy5jb29yZHNbMF1bM10sICdpbmRleCc6IDAsICd0b29sdGlwJzogcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA/IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF0gOiBudWxsIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGEyKGNvLCBbJ2InLCAncicsIHRoaXMuY29vcmRzWzBdWzBdLCB0aGlzLmNvb3Jkc1swXVsxXSwgdGhpcy5jb29yZHNbMF1bMl0sIHRoaXMuY29vcmRzWzBdWzNdLCAnZicsIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sICdzJywgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGV4dC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LnRleHQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLngsIHRoaXMueSwgdGhpcy54ICsgdGhpcy5tZXRyaWNzWzBdLCB0aGlzLnkpLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///181\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Marker3 = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string' && typeof conf.radius === 'number') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        x = conf.x,\n        y = conf.y,\n        radius = conf.radius,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        x = arguments[1],\n        y = arguments[2],\n        radius = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');\n  this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.firstDraw = true;this.actualRadius = 0;this.alpha = 1;this.centerx = x;this.centery = y;this.radius = radius;this.type = 'drawing.marker3';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.fillstyle': 'rgba(255,255,255,1)', 'chart.delay': 50, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.fill': 'rgba(255,0,0,1.0)', 'chart.tooltips': null, 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.MARKER3] No canvas support');return;\n  }\n  this.coords = [];this.coordsText = [];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    co.globalAlpha = this.alpha;pa2(co, ['b', 'a', this.centerx, this.centery, this.actualRadius, 0, 2 * Math.PI, false, 'a', this.centerx, this.centery, ma.max(this.actualRadius - 8, 0), 2 * Math.PI, 0, true, 'f', prop['chart.fillstyle']]);this.alpha = this.actualRadius ? 1 - this.actualRadius * 0.75 / this.radius : 1;co.globalAlpha = 1;if (this.actualRadius < this.radius) {\n      this.actualRadius += 2;\n    } else if (this.actualRadius >= this.radius) {\n      this.actualRadius = 0;this.alpha = 1;\n    }\n    if (!this.TIMER) {\n      var obj = this;setInterval(function () {\n        RG.redrawCanvas(ca);\n      }, prop['chart.delay']);this.TIMER = true;\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return { 0: this, 1: this.centerx, 2: this.centery, 3: this.radius, 4: null, 5: 0, 'object': this, 'x': this.centerx, 'y': this.centery, 'radius': this.radius, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.arrayClone(prop['chart.fillstyle']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius),\n          diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; j += 1) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLm1hcmtlcjMuanM/MTlkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuTWFya2VyMyA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYueSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjb25mLnJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIHggPSBjb25mLngsXG4gICAgICAgIHkgPSBjb25mLnksXG4gICAgICAgIHJhZGl1cyA9IGNvbmYucmFkaXVzLFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIHggPSBhcmd1bWVudHNbMV0sXG4gICAgICAgIHkgPSBhcmd1bWVudHNbMl0sXG4gICAgICAgIHJhZGl1cyA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMuYWN0dWFsUmFkaXVzID0gMDt0aGlzLmFscGhhID0gMTt0aGlzLmNlbnRlcnggPSB4O3RoaXMuY2VudGVyeSA9IHk7dGhpcy5yYWRpdXMgPSByYWRpdXM7dGhpcy50eXBlID0gJ2RyYXdpbmcubWFya2VyMyc7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy51aWQgPSBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkID0gdGhpcy5jYW52YXMudWlkID8gdGhpcy5jYW52YXMudWlkIDogUkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMucHJvcGVydGllcyA9IHsgJ2NoYXJ0LmZpbGxzdHlsZSc6ICdyZ2JhKDI1NSwyNTUsMjU1LDEpJywgJ2NoYXJ0LmRlbGF5JzogNTAsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwwLDAsMS4wKScsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuY2xlYXJ0byc6ICdyZ2JhKDAsMCwwLDApJyB9O1xuICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgYWxlcnQoJ1tEUkFXSU5HLk1BUktFUjNdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy4kMCA9IHt9O2lmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7aWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uZ2xvYmFsQWxwaGEgPSB0aGlzLmFscGhhO3BhMihjbywgWydiJywgJ2EnLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5hY3R1YWxSYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSwgJ2EnLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbWEubWF4KHRoaXMuYWN0dWFsUmFkaXVzIC0gOCwgMCksIDIgKiBNYXRoLlBJLCAwLCB0cnVlLCAnZicsIHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddXSk7dGhpcy5hbHBoYSA9IHRoaXMuYWN0dWFsUmFkaXVzID8gMSAtIHRoaXMuYWN0dWFsUmFkaXVzICogMC43NSAvIHRoaXMucmFkaXVzIDogMTtjby5nbG9iYWxBbHBoYSA9IDE7aWYgKHRoaXMuYWN0dWFsUmFkaXVzIDwgdGhpcy5yYWRpdXMpIHtcbiAgICAgIHRoaXMuYWN0dWFsUmFkaXVzICs9IDI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdHVhbFJhZGl1cyA+PSB0aGlzLnJhZGl1cykge1xuICAgICAgdGhpcy5hY3R1YWxSYWRpdXMgPSAwO3RoaXMuYWxwaGEgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuVElNRVIpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzO3NldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUkcucmVkcmF3Q2FudmFzKGNhKTtcbiAgICAgIH0sIHByb3BbJ2NoYXJ0LmRlbGF5J10pO3RoaXMuVElNRVIgPSB0cnVlO1xuICAgIH1cbiAgICBSRy5pbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5nZXRTaGFwZShlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXTtpZiAoUkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKSA8PSB0aGlzLnJhZGl1cykge1xuICAgICAgcmV0dXJuIHsgMDogdGhpcywgMTogdGhpcy5jZW50ZXJ4LCAyOiB0aGlzLmNlbnRlcnksIDM6IHRoaXMucmFkaXVzLCA0OiBudWxsLCA1OiAwLCAnb2JqZWN0JzogdGhpcywgJ3gnOiB0aGlzLmNlbnRlcngsICd5JzogdGhpcy5jZW50ZXJ5LCAncmFkaXVzJzogdGhpcy5yYWRpdXMsICdpbmRleCc6IDAsICd0b29sdGlwJzogcHJvcFsnY2hhcnQudG9vbHRpcHMnXSA/IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF0gOiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGEyKGNvLCBbJ2InLCAncicsIHRoaXMuY29vcmRzWzBdWzBdLCB0aGlzLmNvb3Jkc1swXVsxXSwgdGhpcy5jb29yZHNbMF1bMl0sIHRoaXMuY29vcmRzWzBdWzNdLCAnZicsIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10sICdzJywgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddID0gUkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC5maWxsc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzKSxcbiAgICAgICAgICBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy5tYXJrZXIzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///182\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Poly = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.coords) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        coords = conf.coords,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        coords = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.coords = coords;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.poly';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();this.properties = { 'chart.linewidth': 1, 'chart.strokestyle': 'black', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.tooltips': null, 'chart.tooltips.override': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.2)', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.POLY] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];var obj = this;pa2(co, ['b', 'fu', function (obj) {\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];co.shadowBlur = prop['chart.shadow.blur'];\n      }\n    }, 'fu', function (obj) {\n      co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.fillstyle'];obj.drawPoly();\n    }, 'lw', prop['chart.linewidth'], 'f', prop['chart.fillstyle'], 'fu', function () {\n      RG.noShadow(obj);\n    }, 's', prop['chart.strokestyle']]);RG.noShadow(this);\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawPoly = this.DrawPoly = function () {\n    var coords = this.coords;pa2(co, ['b', 'm', coords[0][0], coords[0][1]]);for (var i = 1, len = coords.length; i < len; ++i) {\n      co.lineTo(coords[i][0], coords[i][1]);\n    }\n    pa2(co, ['lw', prop['chart.linewidth'], 'c', 'f', co.fillStyle, 's', co.strokeStyle]);\n  };this.getShape = function (e) {\n    var coords = this.coords,\n        mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.fillStyle = 'rgba(0,0,0,0)';this.drawPoly();if (co.isPointInPath(mouseX, mouseY)) {\n      return { 0: this, 1: this.coords, 2: 0, 'object': this, 'coords': this.coords, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    co.fillStyle = prop['chart.fillstyle'];if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else {\n        pa2(co, ['b', 'fu', function (obj) {\n          obj.DrawPoly();\n        }, 'f', prop['chart.highlight.fill'], 's', prop['chart.highlight.stroke']]);\n      }\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    var func = this.parseSingleColorForGradient;prop['chart.fillstyle'] = func(prop['chart.fillstyle']);prop['chart.strokestyle'] = func(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = func(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = func(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnBvbHkuanM/ZGIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuUG9seSA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihjb25mLmNvb3JkcykgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQsXG4gICAgICAgIGNvb3JkcyA9IGNvbmYuY29vcmRzLFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjb29yZHMgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMuY29vcmRzID0gY29vcmRzO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMudHlwZSA9ICdkcmF3aW5nLnBvbHknO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLmNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5saW5ld2lkdGgnOiAxLCAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAnYmxhY2snLCAnY2hhcnQuZmlsbHN0eWxlJzogJ3JlZCcsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5vdmVycmlkZSc6IG51bGwsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICdyZ2JhKDAsMCwwLDAuMiknLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQuc2hhZG93LmJsdXInOiA1LCAnY2hhcnQuY2xlYXJ0byc6ICdyZ2JhKDAsMCwwLDApJyB9O1xuICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgYWxlcnQoJ1tEUkFXSU5HLlBPTFldIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuJDAgPSB7fTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO2lmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jb29yZHNUZXh0ID0gW107dmFyIG9iaiA9IHRoaXM7cGEyKGNvLCBbJ2InLCAnZnUnLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtcbiAgICAgIH1cbiAgICB9LCAnZnUnLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ107b2JqLmRyYXdQb2x5KCk7XG4gICAgfSwgJ2x3JywgcHJvcFsnY2hhcnQubGluZXdpZHRoJ10sICdmJywgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10sICdmdScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLm5vU2hhZG93KG9iaik7XG4gICAgfSwgJ3MnLCBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddXSk7Ukcubm9TaGFkb3codGhpcyk7XG4gICAgUkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuZ2V0U2hhcGUoZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdQb2x5ID0gdGhpcy5EcmF3UG9seSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHM7cGEyKGNvLCBbJ2InLCAnbScsIGNvb3Jkc1swXVswXSwgY29vcmRzWzBdWzFdXSk7Zm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY28ubGluZVRvKGNvb3Jkc1tpXVswXSwgY29vcmRzW2ldWzFdKTtcbiAgICB9XG4gICAgcGEyKGNvLCBbJ2x3JywgcHJvcFsnY2hhcnQubGluZXdpZHRoJ10sICdjJywgJ2YnLCBjby5maWxsU3R5bGUsICdzJywgY28uc3Ryb2tlU3R5bGVdKTtcbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHMsXG4gICAgICAgIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO2NvLmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJzt0aGlzLmRyYXdQb2x5KCk7aWYgKGNvLmlzUG9pbnRJblBhdGgobW91c2VYLCBtb3VzZVkpKSB7XG4gICAgICByZXR1cm4geyAwOiB0aGlzLCAxOiB0aGlzLmNvb3JkcywgMjogMCwgJ29iamVjdCc6IHRoaXMsICdjb29yZHMnOiB0aGlzLmNvb3JkcywgJ2luZGV4JzogMCwgJ3Rvb2x0aXAnOiBwcm9wWydjaGFydC50b29sdGlwcyddID8gcHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXSA6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddO2lmIChwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXShzaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYTIoY28sIFsnYicsICdmdScsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBvYmouRHJhd1BvbHkoKTtcbiAgICAgICAgfSwgJ2YnLCBwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddLCAncycsIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5maWxsc3R5bGUnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gICAgfVxuICAgIHZhciBmdW5jID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQ7cHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPSBmdW5jKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddID0gZnVuYyhwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBmdW5jKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IGZ1bmMocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYS53aWR0aCwgMCksXG4gICAgICAgICAgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307UkcucmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmRyYXdpbmcucG9seS5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///183\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Rect = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.width === 'number' && typeof conf.height === 'number' && typeof conf.id === 'string') {\n    var id = conf.id,\n        x = conf.x,\n        y = conf.y,\n        width = conf.width,\n        height = conf.height,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        x = arguments[1],\n        y = arguments[2],\n        width = arguments[3],\n        height = arguments[4];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.original_colors = [];this.coordsText = [];this.firstDraw = true;this.type = 'drawing.rect';this.isRGraph = true;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.fillstyle': 'red', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.shadow': false, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 5, 'chart.highlight.stroke': 'black', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.tooltips.valign': 'top', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.RECT] No canvas support');return;\n  }\n  this.coords = [[Math.round(x), Math.round(y), width, height]];this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    pa2(co, ['b']);if (prop['chart.shadow']) {\n      pa2(co, ['sc', prop['chart.shadow.color'], 'sx', prop['chart.shadow.offsetx'], 'sy', prop['chart.shadow.offsety'], 'sb', prop['chart.shadow.blur']]);\n    }\n    pa2(co, ['r', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], 'f', prop['chart.fillstyle']]);RG.NoShadow(this);pa2(co, ['s', prop['chart.strokestyle']]);RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var coords = this.coords[i];var left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          grad = co.createLinearGradient(0, 0, ca.width, 0),\n          diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnJlY3QuanM/MjQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuUmVjdCA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYueSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYud2lkdGggPT09ICdudW1iZXInICYmIHR5cGVvZiBjb25mLmhlaWdodCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgeCA9IGNvbmYueCxcbiAgICAgICAgeSA9IGNvbmYueSxcbiAgICAgICAgd2lkdGggPSBjb25mLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCxcbiAgICAgICAgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZixcbiAgICAgICAgeCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgeSA9IGFyZ3VtZW50c1syXSxcbiAgICAgICAgd2lkdGggPSBhcmd1bWVudHNbM10sXG4gICAgICAgIGhlaWdodCA9IGFyZ3VtZW50c1s0XTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy5vcmlnaW5hbF9jb2xvcnMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLmZpcnN0RHJhdyA9IHRydWU7dGhpcy50eXBlID0gJ2RyYXdpbmcucmVjdCc7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy51aWQgPSBSR3JhcGguY3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkID0gdGhpcy5jYW52YXMudWlkID8gdGhpcy5jYW52YXMudWlkIDogUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMucHJvcGVydGllcyA9IHsgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuZmlsbHN0eWxlJzogJ3JlZCcsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICdncmF5JywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMywgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogNSwgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAnYmxhY2snLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6IGZhbHNlLCAnY2hhcnQudG9vbHRpcHMudmFsaWduJzogJ3RvcCcsICdjaGFydC5jbGVhcnRvJzogJ3JnYmEoMCwwLDAsMCknIH07XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0RSQVdJTkcuUkVDVF0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdGhpcy5jb29yZHMgPSBbW01hdGgucm91bmQoeCksIE1hdGgucm91bmQoeSksIHdpZHRoLCBoZWlnaHRdXTt0aGlzLiQwID0ge307aWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBwcm9wW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuY29vcmRzVGV4dCA9IFtdO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHBhMihjbywgWydiJ10pO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgcGEyKGNvLCBbJ3NjJywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sICdzeCcsIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sICdzeScsIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sICdzYicsIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ11dKTtcbiAgICB9XG4gICAgcGEyKGNvLCBbJ3InLCB0aGlzLmNvb3Jkc1swXVswXSwgdGhpcy5jb29yZHNbMF1bMV0sIHRoaXMuY29vcmRzWzBdWzJdLCB0aGlzLmNvb3Jkc1swXVszXSwgJ2YnLCBwcm9wWydjaGFydC5maWxsc3R5bGUnXV0pO1JHLk5vU2hhZG93KHRoaXMpO3BhMihjbywgWydzJywgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXV0pO1JHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0aGlzLmdldFNoYXBlKGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzW2ldO3ZhciBsZWZ0ID0gY29vcmRzWzBdLFxuICAgICAgICAgIHRvcCA9IGNvb3Jkc1sxXSxcbiAgICAgICAgICB3aWR0aCA9IGNvb3Jkc1syXSxcbiAgICAgICAgICBoZWlnaHQgPSBjb29yZHNbM107aWYgKG1vdXNlWCA+PSBsZWZ0ICYmIG1vdXNlWCA8PSBsZWZ0ICsgd2lkdGggJiYgbW91c2VZID49IHRvcCAmJiBtb3VzZVkgPD0gdG9wICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IDA6IHRoaXMsIDE6IGxlZnQsIDI6IHRvcCwgMzogd2lkdGgsIDQ6IGhlaWdodCwgNTogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogbGVmdCwgJ3knOiB0b3AsICd3aWR0aCc6IHdpZHRoLCAnaGVpZ2h0JzogaGVpZ2h0LCAnaW5kZXgnOiAwLCAndG9vbHRpcCc6IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10gPyBwcm9wWydjaGFydC50b29sdGlwcyddWzBdIDogbnVsbCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5IaWdobGlnaHQucmVjdCh0aGlzLCBzaGFwZSk7XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmZpbGxzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKSxcbiAgICAgICAgICBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2Eud2lkdGgsIDApLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMSwgbGVuID0gcGFydHMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O1JHLnJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///184\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.Text = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var y = conf.y;var text = String(conf.text);var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];var y = arguments[2];var text = arguments[3];\n  }\n  this.id = id;this.canvas = document.getElementById(id);this.context = this.canvas.getContext('2d');this.colorsParsed = false;this.canvas.__object__ = this;this.x = x;this.y = y;this.text = String(text);this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.text';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.size': 10, 'chart.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.bold': false, 'chart.angle': 0, 'chart.colors': ['black'], 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.highlight.stroke': '#ccc', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.bounding': false, 'chart.bounding.fill': 'rgba(255,255,255,0.7)', 'chart.bounding.stroke': '#777', 'chart.bounding.shadow': false, 'chart.bounding.shadow.color': '#ccc', 'chart.bounding.shadow.blur': 3, 'chart.bounding.shadow.offsetx': 3, 'chart.bounding.shadow.offsety': 3, 'chart.marker': false, 'chart.halign': 'left', 'chart.valign': 'bottom', 'chart.link': null, 'chart.link.target': '_self', 'chart.link.options': '', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.clearto': 'rgba(0,0,0,0)', 'chart.shadow': false, 'chart.shadow.color': '#ccc', 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3 };\n  if (!this.canvas) {\n    alert('[DRAWING.TEXT] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coords = [];this.coordsText = [];var dimensions = RG.measureText(this.text, prop['chart.text.bold'], prop['chart.text.font'], prop['chart.text.size']);co.fillStyle = prop['chart.colors'][0];if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    var ret = RG.text2(this, { font: prop['chart.font'], size: prop['chart.size'], x: this.x, y: this.y, text: this.text, bold: prop['chart.bold'], angle: prop['chart.angle'], bounding: prop['chart.bounding'], 'bounding.fill': prop['chart.bounding.fill'], 'bounding.stroke': prop['chart.bounding.stroke'], 'bounding.shadow': prop['chart.bounding.shadow'], 'bounding.shadow.color': prop['chart.bounding.shadow.color'], 'bounding.shadow.blur': prop['chart.bounding.shadow.blur'], 'bounding.shadow.offsetx': prop['chart.bounding.shadow.offsetx'], 'bounding.shadow.offsety': prop['chart.bounding.shadow.offsety'], marker: prop['chart.marker'], halign: prop['chart.halign'], valign: prop['chart.valign'] });if (prop['chart.shadow']) {\n      RG.noShadow(this);\n    }\n    this.coords.push({ 0: ret.x, 'x': ret.x, 1: ret.y, 'y': ret.y, 2: ret.width, 'width': ret.width, 3: ret.height, 'height': ret.height });RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var prop = this.properties;var coords = this.coords;var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = coords[i].x;var top = coords[i].y;var width = coords[i].width;var height = coords[i].height;if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        return { 0: this, 1: left, 2: top, 3: width, 4: height, 5: 0, 'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors'])[0];this.original_colors['chart.fillstyle'] = RG.array_clone(prop['chart.fillstyle']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, 0, ca.width, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnRleHQuanM/OGM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5EcmF3aW5nID0gUkdyYXBoLkRyYXdpbmcgfHwge307UkdyYXBoLkRyYXdpbmcuVGV4dCA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYueSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZDtcbiAgICB2YXIgeCA9IGNvbmYueDt2YXIgeSA9IGNvbmYueTt2YXIgdGV4dCA9IFN0cmluZyhjb25mLnRleHQpO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciB4ID0gYXJndW1lbnRzWzFdO3ZhciB5ID0gYXJndW1lbnRzWzJdO3ZhciB0ZXh0ID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy54ID0geDt0aGlzLnkgPSB5O3RoaXMudGV4dCA9IFN0cmluZyh0ZXh0KTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMudHlwZSA9ICdkcmF3aW5nLnRleHQnO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5zaXplJzogMTAsICdjaGFydC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC5ib2xkJzogZmFsc2UsICdjaGFydC5hbmdsZSc6IDAsICdjaGFydC5jb2xvcnMnOiBbJ2JsYWNrJ10sICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzogJyNjY2MnLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6IGZhbHNlLCAnY2hhcnQuYm91bmRpbmcnOiBmYWxzZSwgJ2NoYXJ0LmJvdW5kaW5nLmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmJvdW5kaW5nLnN0cm9rZSc6ICcjNzc3JywgJ2NoYXJ0LmJvdW5kaW5nLnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuYm91bmRpbmcuc2hhZG93LmNvbG9yJzogJyNjY2MnLCAnY2hhcnQuYm91bmRpbmcuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQuYm91bmRpbmcuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuYm91bmRpbmcuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQubWFya2VyJzogZmFsc2UsICdjaGFydC5oYWxpZ24nOiAnbGVmdCcsICdjaGFydC52YWxpZ24nOiAnYm90dG9tJywgJ2NoYXJ0LmxpbmsnOiBudWxsLCAnY2hhcnQubGluay50YXJnZXQnOiAnX3NlbGYnLCAnY2hhcnQubGluay5vcHRpb25zJzogJycsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuY2xlYXJ0byc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJyNjY2MnLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAyLCAnY2hhcnQuc2hhZG93LmJsdXInOiAzIH07XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0RSQVdJTkcuVEVYVF0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdGhpcy4kMCA9IHt9O2lmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt2YXIgZGltZW5zaW9ucyA9IFJHLm1lYXN1cmVUZXh0KHRoaXMudGV4dCwgcHJvcFsnY2hhcnQudGV4dC5ib2xkJ10sIHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBwcm9wWydjaGFydC50ZXh0LnNpemUnXSk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBSRy5zZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gUkcudGV4dDIodGhpcywgeyBmb250OiBwcm9wWydjaGFydC5mb250J10sIHNpemU6IHByb3BbJ2NoYXJ0LnNpemUnXSwgeDogdGhpcy54LCB5OiB0aGlzLnksIHRleHQ6IHRoaXMudGV4dCwgYm9sZDogcHJvcFsnY2hhcnQuYm9sZCddLCBhbmdsZTogcHJvcFsnY2hhcnQuYW5nbGUnXSwgYm91bmRpbmc6IHByb3BbJ2NoYXJ0LmJvdW5kaW5nJ10sICdib3VuZGluZy5maWxsJzogcHJvcFsnY2hhcnQuYm91bmRpbmcuZmlsbCddLCAnYm91bmRpbmcuc3Ryb2tlJzogcHJvcFsnY2hhcnQuYm91bmRpbmcuc3Ryb2tlJ10sICdib3VuZGluZy5zaGFkb3cnOiBwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cnXSwgJ2JvdW5kaW5nLnNoYWRvdy5jb2xvcic6IHByb3BbJ2NoYXJ0LmJvdW5kaW5nLnNoYWRvdy5jb2xvciddLCAnYm91bmRpbmcuc2hhZG93LmJsdXInOiBwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cuYmx1ciddLCAnYm91bmRpbmcuc2hhZG93Lm9mZnNldHgnOiBwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cub2Zmc2V0eCddLCAnYm91bmRpbmcuc2hhZG93Lm9mZnNldHknOiBwcm9wWydjaGFydC5ib3VuZGluZy5zaGFkb3cub2Zmc2V0eSddLCBtYXJrZXI6IHByb3BbJ2NoYXJ0Lm1hcmtlciddLCBoYWxpZ246IHByb3BbJ2NoYXJ0LmhhbGlnbiddLCB2YWxpZ246IHByb3BbJ2NoYXJ0LnZhbGlnbiddIH0pO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcubm9TaGFkb3codGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY29vcmRzLnB1c2goeyAwOiByZXQueCwgJ3gnOiByZXQueCwgMTogcmV0LnksICd5JzogcmV0LnksIDI6IHJldC53aWR0aCwgJ3dpZHRoJzogcmV0LndpZHRoLCAzOiByZXQuaGVpZ2h0LCAnaGVpZ2h0JzogcmV0LmhlaWdodCB9KTtSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5nZXRTaGFwZShlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3ZhciBjb29yZHMgPSB0aGlzLmNvb3Jkczt2YXIgbW91c2VYWSA9IFJHcmFwaC5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGxlZnQgPSBjb29yZHNbaV0ueDt2YXIgdG9wID0gY29vcmRzW2ldLnk7dmFyIHdpZHRoID0gY29vcmRzW2ldLndpZHRoO3ZhciBoZWlnaHQgPSBjb29yZHNbaV0uaGVpZ2h0O2lmIChtb3VzZVggPj0gbGVmdCAmJiBtb3VzZVggPD0gbGVmdCArIHdpZHRoICYmIG1vdXNlWSA+PSB0b3AgJiYgbW91c2VZIDw9IHRvcCArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4geyAwOiB0aGlzLCAxOiBsZWZ0LCAyOiB0b3AsIDM6IHdpZHRoLCA0OiBoZWlnaHQsIDU6IDAsICdvYmplY3QnOiB0aGlzLCAneCc6IGxlZnQsICd5JzogdG9wLCAnd2lkdGgnOiB3aWR0aCwgJ2hlaWdodCc6IGhlaWdodCwgJ2luZGV4JzogMCwgJ3Rvb2x0aXAnOiBwcm9wWydjaGFydC50b29sdGlwcyddID8gcHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXSA6IG51bGwgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlJlY3QodGhpcywgc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKVswXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZmlsbHN0eWxlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5maWxsc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC5jb2xvcnMnXVswXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdKTtwcm9wWydjaGFydC5maWxsc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2Eud2lkdGgsIDApO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSR3JhcGgudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZHJhd2luZy50ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///185\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.XAxis = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.y === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var y = conf.y;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var y = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.y = y;this.coords = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.type = 'drawing.xaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = { 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.labels': null, 'chart.labels.position': 'section', 'chart.colors': ['black'], 'chart.title.color': null, 'chart.text.color': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'bottom', 'chart.numlabels': 5, 'chart.scale.visible': true, 'chart.scale.formatter': null, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.invert': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.title': '', 'chart.numticks': null, 'chart.hmargin': 0, 'chart.linewidth': 1, 'chart.noendtick.left': false, 'chart.noendtick.right': false, 'chart.noxaxis': false, 'chart.max': null, 'chart.min': 0, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[DRAWING.XAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels' && !prop['chart.numxticks']) {\n      prop['chart.numxticks'] = value.length;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.DrawXAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.y - (prop['chart.align'] == 'top' ? prop['chart.text.size'] * 1.5 + 5 : 0) && mouseY <= this.y + (prop['chart.align'] == 'top' ? 0 : prop['chart.text.size'] * 1.5 + 5)) {\n      var x = this.gutterLeft;var y = this.y;var w = ca.width - this.gutterLeft - this.gutterRight;var h = 15;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawXAxis = this.DrawXAxis = function () {\n    var gutterLeft = prop['chart.gutter.left'],\n        gutterRight = prop['chart.gutter.right'],\n        x = this.gutterLeft,\n        y = this.y,\n        min = +prop['chart.min'],\n        max = +prop['chart.max'],\n        labels = prop['chart.labels'],\n        labels_position = prop['chart.labels.position'],\n        color = prop['chart.colors'][0],\n        title_color = prop['chart.title.color'],\n        label_color = prop['chart.text.color'],\n        width = ca.width - this.gutterLeft - this.gutterRight,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        align = prop['chart.align'],\n        numlabels = prop['chart.numlabels'],\n        formatter = prop['chart.scale.formatter'],\n        decimals = Number(prop['chart.scale.decimals']),\n        invert = prop['chart.scale.invert'],\n        scale_visible = prop['chart.scale.visible'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        title = prop['chart.title'];\n    numticks = prop['chart.numticks'], hmargin = prop['chart.hmargin'], linewidth = prop['chart.linewidth'], noleftendtick = prop['chart.noendtick.left'], norightendtick = prop['chart.noendtick.right'], noxaxis = prop['chart.noxaxis'], xaxispos = prop['chart.xaxispos'], yaxispos = prop['chart.yaxispos'];\n    if (RG.is_null(numticks)) {\n      if (labels && labels.length) {\n        numticks = labels.length;\n      } else if (!labels && max != 0) {\n        numticks = 10;\n      } else {\n        numticks = numlabels;\n      }\n    }\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noxaxis) {\n      pa2(co, ['b', 'm', x, ma.round(y), 'l', x + width, ma.round(y), 's', co.strokeStyle]);co.beginPath();for (var i = noleftendtick ? 1 : 0; i <= numticks - (norightendtick ? 1 : 0); ++i) {\n        co.moveTo(ma.round(x + width / numticks * i), xaxispos == 'center' ? align == 'bottom' ? y - 3 : y + 3 : y);co.lineTo(ma.round(x + width / numticks * i), y + (align == 'bottom' ? 3 : -3));\n      }\n      co.stroke();\n    }\n    co.fillStyle = label_color;if (labels) {\n      numlabels = labels.length;var h = 0;var l = 0;var single_line = RG.MeasureText('Mg', false, font, size);for (var i = 0, len = labels.length; i < len; ++i) {\n        var dimensions = RG.MeasureText(labels[i], false, font, size);var h = ma.max(h, dimensions[1]);var l = ma.max(l, labels[i].split('\\r\\n').length);\n      }\n      for (var i = 0, len = labels.length; i < len; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': labels_position == 'edge' ? (width - hmargin - hmargin) / (labels.length - 1) * i + gutterLeft + hmargin : (width - hmargin - hmargin) / labels.length * i + width / labels.length / 2 + gutterLeft + hmargin, 'y': align == 'bottom' ? y + 3 : y - 3 - h + single_line[1], 'text': String(labels[i]), 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else if (scale_visible) {\n      if (max === null) {\n        alert('[DRAWING.XAXIS] If not specifying axis.labels you must specify axis.max!');\n      }\n      if (yaxispos == 'center') {\n        width /= 2;var additionalX = width;\n      } else {\n        var additionalX = 0;\n      }\n      for (var i = 0; i <= numlabels; ++i) {\n        if (i == 0 && !prop['chart.scale.zerostart']) {\n          continue;\n        }\n        var original = (max - min) / numlabels * i + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post));if (invert) {\n          var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft + additionalX;\n        } else {\n          var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin + additionalX;\n        }\n        RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + 3 : y - 3, 'text': text, 'valign': align == 'bottom' ? 'top' : 'bottom', 'halign': 'center', 'tag': 'scale' });\n      }\n      if (yaxispos == 'center') {\n        for (var i = 0; i < numlabels; ++i) {\n          var original = (max - min) / numlabels * (numlabels - i) + min;var hmargin = prop['chart.hmargin'];var text = String(typeof formatter == 'function' ? formatter(this, original) : RG.number_format(this, original.toFixed(decimals), units_pre, units_post));if (invert) {\n            var x = width - hmargin - (width - hmargin - hmargin) / numlabels * i + gutterLeft;\n          } else {\n            var x = (width - hmargin - hmargin) / numlabels * i + gutterLeft + hmargin;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': align == 'bottom' ? y + size + 2 : y - size - 2, 'text': '-' + text, 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n      }\n    }\n    if (title) {\n      var dimensions = RG.MeasureText(title, false, font, size + 2);co.fillStyle = title_color;\n      RG.Text2(this, { 'font': font, 'size': size + 2, 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': align == 'bottom' ? y + dimensions[1] + 10 : y - dimensions[1] - 10, 'text': title, 'valign': 'center', 'halign': 'center', 'tag': 'title' });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnhheGlzLmpzPzQwYWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguRHJhd2luZyA9IFJHcmFwaC5EcmF3aW5nIHx8IHt9O1JHcmFwaC5EcmF3aW5nLlhBeGlzID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi55ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkO1xuICAgIHZhciB5ID0gY29uZi55O3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciB5ID0gYXJndW1lbnRzWzFdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy55ID0geTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMudHlwZSA9ICdkcmF3aW5nLnhheGlzJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQubGFiZWxzJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbic6ICdzZWN0aW9uJywgJ2NoYXJ0LmNvbG9ycyc6IFsnYmxhY2snXSwgJ2NoYXJ0LnRpdGxlLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LnRleHQuY29sb3InOiBudWxsLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5hbGlnbic6ICdib3R0b20nLCAnY2hhcnQubnVtbGFiZWxzJzogNSwgJ2NoYXJ0LnNjYWxlLnZpc2libGUnOiB0cnVlLCAnY2hhcnQuc2NhbGUuZm9ybWF0dGVyJzogbnVsbCwgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnNjYWxlLnBvaW50JzogJy4nLCAnY2hhcnQuc2NhbGUudGhvdXNhbmQnOiAnLCcsICdjaGFydC5zY2FsZS5pbnZlcnQnOiBmYWxzZSwgJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCc6IHRydWUsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnRpdGxlJzogJycsICdjaGFydC5udW10aWNrcyc6IG51bGwsICdjaGFydC5obWFyZ2luJzogMCwgJ2NoYXJ0LmxpbmV3aWR0aCc6IDEsICdjaGFydC5ub2VuZHRpY2subGVmdCc6IGZhbHNlLCAnY2hhcnQubm9lbmR0aWNrLnJpZ2h0JzogZmFsc2UsICdjaGFydC5ub3hheGlzJzogZmFsc2UsICdjaGFydC5tYXgnOiBudWxsLCAnY2hhcnQubWluJzogMCwgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LmV2ZW50cy5jbGljayc6IG51bGwsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzogbnVsbCwgJ2NoYXJ0LnhheGlzcG9zJzogJ2JvdHRvbScsICdjaGFydC55YXhpc3Bvcyc6ICdsZWZ0JywgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRFJBV0lORy5YQVhJU10gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdGhpcy4kMCA9IHt9O2lmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5sYWJlbHMnICYmICFwcm9wWydjaGFydC5udW14dGlja3MnXSkge1xuICAgICAgcHJvcFsnY2hhcnQubnVteHRpY2tzJ10gPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107aWYgKCFwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pIHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmICghcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSkgcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuRHJhd1hBeGlzKCk7UkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuZ2V0U2hhcGUoZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKG1vdXNlWCA+PSB0aGlzLmd1dHRlckxlZnQgJiYgbW91c2VYIDw9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAmJiBtb3VzZVkgPj0gdGhpcy55IC0gKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT0gJ3RvcCcgPyBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAqIDEuNSArIDUgOiAwKSAmJiBtb3VzZVkgPD0gdGhpcy55ICsgKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT0gJ3RvcCcgPyAwIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKiAxLjUgKyA1KSkge1xuICAgICAgdmFyIHggPSB0aGlzLmd1dHRlckxlZnQ7dmFyIHkgPSB0aGlzLnk7dmFyIHcgPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dmFyIGggPSAxNTtyZXR1cm4geyAwOiB0aGlzLCAxOiB4LCAyOiB5LCAzOiB3LCA0OiBoLCA1OiAwLCAnb2JqZWN0JzogdGhpcywgJ3gnOiB4LCAneSc6IHksICd3aWR0aCc6IHcsICdoZWlnaHQnOiBoLCAnaW5kZXgnOiAwLCAndG9vbHRpcCc6IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10gPyBwcm9wWydjaGFydC50b29sdGlwcyddWzBdIDogbnVsbCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVswXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQocHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSwgMCwgY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgMCk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMSwgbGVuID0gcGFydHMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5kcmF3WEF4aXMgPSB0aGlzLkRyYXdYQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10sXG4gICAgICAgIGd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sXG4gICAgICAgIHggPSB0aGlzLmd1dHRlckxlZnQsXG4gICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgIG1pbiA9ICtwcm9wWydjaGFydC5taW4nXSxcbiAgICAgICAgbWF4ID0gK3Byb3BbJ2NoYXJ0Lm1heCddLFxuICAgICAgICBsYWJlbHMgPSBwcm9wWydjaGFydC5sYWJlbHMnXSxcbiAgICAgICAgbGFiZWxzX3Bvc2l0aW9uID0gcHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10sXG4gICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0sXG4gICAgICAgIHRpdGxlX2NvbG9yID0gcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSxcbiAgICAgICAgbGFiZWxfY29sb3IgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sXG4gICAgICAgIHdpZHRoID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0LFxuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgYWxpZ24gPSBwcm9wWydjaGFydC5hbGlnbiddLFxuICAgICAgICBudW1sYWJlbHMgPSBwcm9wWydjaGFydC5udW1sYWJlbHMnXSxcbiAgICAgICAgZm9ybWF0dGVyID0gcHJvcFsnY2hhcnQuc2NhbGUuZm9ybWF0dGVyJ10sXG4gICAgICAgIGRlY2ltYWxzID0gTnVtYmVyKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLFxuICAgICAgICBpbnZlcnQgPSBwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSxcbiAgICAgICAgc2NhbGVfdmlzaWJsZSA9IHByb3BbJ2NoYXJ0LnNjYWxlLnZpc2libGUnXSxcbiAgICAgICAgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sXG4gICAgICAgIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J10sXG4gICAgICAgIHRpdGxlID0gcHJvcFsnY2hhcnQudGl0bGUnXTtcbiAgICBudW10aWNrcyA9IHByb3BbJ2NoYXJ0Lm51bXRpY2tzJ10sIGhtYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luJ10sIGxpbmV3aWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddLCBub2xlZnRlbmR0aWNrID0gcHJvcFsnY2hhcnQubm9lbmR0aWNrLmxlZnQnXSwgbm9yaWdodGVuZHRpY2sgPSBwcm9wWydjaGFydC5ub2VuZHRpY2sucmlnaHQnXSwgbm94YXhpcyA9IHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSwgeGF4aXNwb3MgPSBwcm9wWydjaGFydC54YXhpc3BvcyddLCB5YXhpc3BvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ107XG4gICAgaWYgKFJHLmlzX251bGwobnVtdGlja3MpKSB7XG4gICAgICBpZiAobGFiZWxzICYmIGxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgbnVtdGlja3MgPSBsYWJlbHMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICghbGFiZWxzICYmIG1heCAhPSAwKSB7XG4gICAgICAgIG51bXRpY2tzID0gMTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW10aWNrcyA9IG51bWxhYmVscztcbiAgICAgIH1cbiAgICB9XG4gICAgY28ubGluZVdpZHRoID0gbGluZXdpZHRoICsgMC4wMDE7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtpZiAoIW5veGF4aXMpIHtcbiAgICAgIHBhMihjbywgWydiJywgJ20nLCB4LCBtYS5yb3VuZCh5KSwgJ2wnLCB4ICsgd2lkdGgsIG1hLnJvdW5kKHkpLCAncycsIGNvLnN0cm9rZVN0eWxlXSk7Y28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgaSA9IG5vbGVmdGVuZHRpY2sgPyAxIDogMDsgaSA8PSBudW10aWNrcyAtIChub3JpZ2h0ZW5kdGljayA/IDEgOiAwKTsgKytpKSB7XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4ICsgd2lkdGggLyBudW10aWNrcyAqIGkpLCB4YXhpc3BvcyA9PSAnY2VudGVyJyA/IGFsaWduID09ICdib3R0b20nID8geSAtIDMgOiB5ICsgMyA6IHkpO2NvLmxpbmVUbyhtYS5yb3VuZCh4ICsgd2lkdGggLyBudW10aWNrcyAqIGkpLCB5ICsgKGFsaWduID09ICdib3R0b20nID8gMyA6IC0zKSk7XG4gICAgICB9XG4gICAgICBjby5zdHJva2UoKTtcbiAgICB9XG4gICAgY28uZmlsbFN0eWxlID0gbGFiZWxfY29sb3I7aWYgKGxhYmVscykge1xuICAgICAgbnVtbGFiZWxzID0gbGFiZWxzLmxlbmd0aDt2YXIgaCA9IDA7dmFyIGwgPSAwO3ZhciBzaW5nbGVfbGluZSA9IFJHLk1lYXN1cmVUZXh0KCdNZycsIGZhbHNlLCBmb250LCBzaXplKTtmb3IgKHZhciBpID0gMCwgbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gUkcuTWVhc3VyZVRleHQobGFiZWxzW2ldLCBmYWxzZSwgZm9udCwgc2l6ZSk7dmFyIGggPSBtYS5tYXgoaCwgZGltZW5zaW9uc1sxXSk7dmFyIGwgPSBtYS5tYXgobCwgbGFiZWxzW2ldLnNwbGl0KCdcXHJcXG4nKS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGxhYmVsc19wb3NpdGlvbiA9PSAnZWRnZScgPyAod2lkdGggLSBobWFyZ2luIC0gaG1hcmdpbikgLyAobGFiZWxzLmxlbmd0aCAtIDEpICogaSArIGd1dHRlckxlZnQgKyBobWFyZ2luIDogKHdpZHRoIC0gaG1hcmdpbiAtIGhtYXJnaW4pIC8gbGFiZWxzLmxlbmd0aCAqIGkgKyB3aWR0aCAvIGxhYmVscy5sZW5ndGggLyAyICsgZ3V0dGVyTGVmdCArIGhtYXJnaW4sICd5JzogYWxpZ24gPT0gJ2JvdHRvbScgPyB5ICsgMyA6IHkgLSAzIC0gaCArIHNpbmdsZV9saW5lWzFdLCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaV0pLCAndmFsaWduJzogYWxpZ24gPT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nLCAnaGFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnbGFiZWxzJyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjYWxlX3Zpc2libGUpIHtcbiAgICAgIGlmIChtYXggPT09IG51bGwpIHtcbiAgICAgICAgYWxlcnQoJ1tEUkFXSU5HLlhBWElTXSBJZiBub3Qgc3BlY2lmeWluZyBheGlzLmxhYmVscyB5b3UgbXVzdCBzcGVjaWZ5IGF4aXMubWF4IScpO1xuICAgICAgfVxuICAgICAgaWYgKHlheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgIHdpZHRoIC89IDI7dmFyIGFkZGl0aW9uYWxYID0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYWRkaXRpb25hbFggPSAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtbGFiZWxzOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT0gMCAmJiAhcHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWwgPSAobWF4IC0gbWluKSAvIG51bWxhYmVscyAqIGkgKyBtaW47dmFyIGhtYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luJ107dmFyIHRleHQgPSBTdHJpbmcodHlwZW9mIGZvcm1hdHRlciA9PSAnZnVuY3Rpb24nID8gZm9ybWF0dGVyKHRoaXMsIG9yaWdpbmFsKSA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBvcmlnaW5hbC50b0ZpeGVkKG9yaWdpbmFsID09PSAwID8gMCA6IGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSk7aWYgKGludmVydCkge1xuICAgICAgICAgIHZhciB4ID0gd2lkdGggLSBobWFyZ2luIC0gKHdpZHRoIC0gaG1hcmdpbiAtIGhtYXJnaW4pIC8gbnVtbGFiZWxzICogaSArIGd1dHRlckxlZnQgKyBhZGRpdGlvbmFsWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeCA9ICh3aWR0aCAtIGhtYXJnaW4gLSBobWFyZ2luKSAvIG51bWxhYmVscyAqIGkgKyBndXR0ZXJMZWZ0ICsgaG1hcmdpbiArIGFkZGl0aW9uYWxYO1xuICAgICAgICB9XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCwgJ3knOiBhbGlnbiA9PSAnYm90dG9tJyA/IHkgKyAzIDogeSAtIDMsICd0ZXh0JzogdGV4dCwgJ3ZhbGlnbic6IGFsaWduID09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh5YXhpc3BvcyA9PSAnY2VudGVyJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWxhYmVsczsgKytpKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gKG1heCAtIG1pbikgLyBudW1sYWJlbHMgKiAobnVtbGFiZWxzIC0gaSkgKyBtaW47dmFyIGhtYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luJ107dmFyIHRleHQgPSBTdHJpbmcodHlwZW9mIGZvcm1hdHRlciA9PSAnZnVuY3Rpb24nID8gZm9ybWF0dGVyKHRoaXMsIG9yaWdpbmFsKSA6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgb3JpZ2luYWwudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCkpO2lmIChpbnZlcnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gd2lkdGggLSBobWFyZ2luIC0gKHdpZHRoIC0gaG1hcmdpbiAtIGhtYXJnaW4pIC8gbnVtbGFiZWxzICogaSArIGd1dHRlckxlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB4ID0gKHdpZHRoIC0gaG1hcmdpbiAtIGhtYXJnaW4pIC8gbnVtbGFiZWxzICogaSArIGd1dHRlckxlZnQgKyBobWFyZ2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHgsICd5JzogYWxpZ24gPT0gJ2JvdHRvbScgPyB5ICsgc2l6ZSArIDIgOiB5IC0gc2l6ZSAtIDIsICd0ZXh0JzogJy0nICsgdGV4dCwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBSRy5NZWFzdXJlVGV4dCh0aXRsZSwgZmFsc2UsIGZvbnQsIHNpemUgKyAyKTtjby5maWxsU3R5bGUgPSB0aXRsZV9jb2xvcjtcbiAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUgKyAyLCAneCc6IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiArIHRoaXMuZ3V0dGVyTGVmdCwgJ3knOiBhbGlnbiA9PSAnYm90dG9tJyA/IHkgKyBkaW1lbnNpb25zWzFdICsgMTAgOiB5IC0gZGltZW5zaW9uc1sxXSAtIDEwLCAndGV4dCc6IHRpdGxlLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICd0aXRsZScgfSk7XG4gICAgfVxuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnhheGlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///186\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Drawing = RGraph.Drawing || {};RGraph.Drawing.YAxis = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.x === 'number' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var x = conf.x;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var x = arguments[1];\n  }\n  this.id = id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext(\"2d\");this.canvas.__object__ = this;this.x = x;this.coords = [];this.coordsText = [];this.original_colors = [];this.maxLabelLength = 0;this.firstDraw = true;this.type = 'drawing.yaxis';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.properties = (_properties = { 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.min': 0, 'chart.max': null, 'chart.colors': ['black'], 'chart.title': '', 'chart.title.color': null, 'chart.numticks': 5, 'chart.numlabels': 5, 'chart.labels.specific': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': null, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.align': 'left', 'hart.scale.formatter': null, 'chart.scale.point': '.', 'chart.scale.decimals': 0 }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.invert', false), _defineProperty(_properties, 'chart.scale.zerostart', true), _defineProperty(_properties, 'chart.scale.visible', true), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.noendtick.top', false), _defineProperty(_properties, 'chart.noendtick.bottom', false), _defineProperty(_properties, 'chart.noyaxis', false), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.xaxispos', 'bottom'), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[DRAWING.YAXIS] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!prop['chart.text.color']) prop['chart.text.color'] = prop['chart.colors'][0];if (!prop['chart.title.color']) prop['chart.title.color'] = prop['chart.colors'][0];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawYAxis();RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.x - (prop['chart.align'] == 'right' ? 0 : this.getWidth()) && mouseX <= this.x + (prop['chart.align'] == 'right' ? this.getWidth() : 0) && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      var x = this.x;var y = this.gutterTop;var w = 15;;var h = ca.height - this.gutterTop - this.gutterBottom;return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: 0, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': 0, 'tooltip': prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null };\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - this.gutterBottom);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawYAxis = this.DrawYAxis = function () {\n    for (i in prop) {\n      if (typeof i == 'string') {\n        var key = i.replace(/^chart\\./, 'axis.');prop[key] = prop[i];\n      }\n    }\n    var x = this.x,\n        y = this.gutterTop,\n        height = ca.height - this.gutterBottom - this.gutterTop,\n        min = +prop['chart.min'] ? +prop['chart.min'] : 0,\n        max = +prop['chart.max'],\n        title = prop['chart.title'] ? prop['chart.title'] : '',\n        color = prop['chart.colors'] ? prop['chart.colors'][0] : 'black',\n        title_color = prop['chart.title.color'] ? prop['chart.title.color'] : color,\n        label_color = prop['chart.text.color'] ? prop['chart.text.color'] : color,\n        numticks = typeof prop['chart.numticks'] == 'number' ? prop['chart.numticks'] : 10,\n        labels_specific = prop['chart.labels.specific'],\n        numlabels = prop['chart.numlabels'] ? prop['chart.numlabels'] : 5,\n        font = prop['chart.text.font'] ? prop['chart.text.font'] : 'Arial',\n        size = prop['chart.text.size'] ? prop['chart.text.size'] : 10;\n    align = typeof prop['chart.align'] == 'string' ? prop['chart.align'] : 'left', formatter = prop['chart.scale.formatter'], decimals = prop['chart.scale.decimals'], invert = prop['chart.scale.invert'], scale_visible = prop['chart.scale.visible'], units_pre = prop['chart.units.pre'], units_post = prop['chart.units.post'], linewidth = prop['chart.linewidth'] ? prop['chart.linewidth'] : 1, notopendtick = prop['chart.noendtick.top'], nobottomendtick = prop['chart.noendtick.bottom'], noyaxis = prop['chart.noyaxis'], xaxispos = prop['chart.xaxispos'];\n    co.lineWidth = linewidth + 0.001;co.strokeStyle = color;if (!noyaxis) {\n      pa2(co, ['b', 'm', Math.round(x), y, 'l', Math.round(x), y + height, 's', color]);if (numticks) {\n        var gap = (xaxispos == 'center' ? height / 2 : height) / numticks;var halfheight = height / 2;co.beginPath();for (var i = notopendtick ? 1 : 0; i <= numticks - (nobottomendtick || xaxispos == 'center' ? 1 : 0); ++i) {\n          pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + gap * i), 'l', x, Math.round(y + gap * i)]);\n        }\n        if (xaxispos == 'center') {\n          for (var i = 1; i <= numticks; ++i) {\n            pa2(co, ['m', align == 'right' ? x + 3 : x - 3, Math.round(y + halfheight + gap * i), 'l', x, Math.round(y + halfheight + gap * i)]);\n          }\n        }\n        co.stroke();\n      }\n    }\n    co.fillStyle = label_color;var text_len = 0;if (scale_visible) {\n      if (labels_specific && labels_specific.length) {\n        var text_len = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          text_len = ma.max(text_len, co.measureText(labels_specific[i]).width);\n        }\n        for (var i = 0, len = labels_specific.length; i < len; ++i) {\n          var gap = len - 1 > 0 ? height / (len - 1) : 0;if (xaxispos == 'center') {\n            gap /= 2;\n          }\n          RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': i * gap + this.gutterTop, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });this.maxLabelLength = ma.max(this.maxLabelLength, co.measureText(labels_specific[i]).width);\n        }\n        if (xaxispos == 'center') {\n          for (var i = labels_specific.length - 2; i >= 0; --i) {\n            RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - i * gap, 'text': labels_specific[i], 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      } else {\n        for (var i = 0; i <= numlabels; ++i) {\n          var original = (max - min) * ((numlabels - i) / numlabels) + min;if (original == 0 && prop['chart.scale.zerostart'] == false) {\n            continue;\n          }\n          var text = RG.numberFormat(this, original.toFixed(original === 0 ? 0 : decimals), units_pre, units_post);var text = String(typeof formatter == 'function' ? formatter(this, original) : text);var text_len = ma.max(text_len, co.measureText(text).width);this.maxLabelLength = text_len;if (invert) {\n            var y = height - height / numlabels * i;\n          } else {\n            var y = height / numlabels * i;\n          }\n          if (prop['chart.xaxispos'] == 'center') {\n            y = y / 2;\n          }\n          text = text.replace(/^-,([0-9])/, '-$1');RG.text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': y + this.gutterTop, 'text': text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });if (prop['chart.xaxispos'] == 'center' && i < numlabels) {\n            RG.Text2(this, { 'font': font, 'size': size, 'x': x - (align == 'right' ? -5 : 5), 'y': ca.height - this.gutterBottom - y, 'text': '-' + text, 'valign': 'center', 'halign': align == 'right' ? 'left' : 'right', 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (title) {\n      co.beginPath();co.fillStyle = title_color;if (labels_specific) {\n        var width = 0;for (var i = 0, len = labels_specific.length; i < len; i += 1) {\n          width = Math.max(width, co.measureText(labels_specific[i]).width);\n        }\n      } else {\n        var width = co.measureText(prop['chart.units.pre'] + prop['chart.max'].toFixed(prop['chart.scale.decimals']) + prop['chart.units.post']).width;\n      }\n      RG.text2(this, { font: font, size: size + 2, x: align == 'right' ? x + width + 8 : x - width - 8, y: height / 2 + this.gutterTop, text: title, valign: 'bottom', halign: 'center', angle: align == 'right' ? 90 : -90, accessible: false });co.stroke();\n    }\n  };this.getWidth = function () {\n    var width = this.maxLabelLength;if (prop['chart.title'] && prop['chart.title'].length) {\n      width += prop['chart.text.size'] * 1.5;\n    }\n    this.width = width;return width;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5kcmF3aW5nLnlheGlzLmpzPzFlNjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguRHJhd2luZyA9IFJHcmFwaC5EcmF3aW5nIHx8IHt9O1JHcmFwaC5EcmF3aW5nLllBeGlzID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgdmFyIF9wcm9wZXJ0aWVzO1xuXG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZDtcbiAgICB2YXIgeCA9IGNvbmYueDt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZjt2YXIgeCA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy54ID0geDt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5tYXhMYWJlbExlbmd0aCA9IDA7dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMudHlwZSA9ICdkcmF3aW5nLnlheGlzJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5wcm9wZXJ0aWVzID0gKF9wcm9wZXJ0aWVzID0geyAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDMwLCAnY2hhcnQubWluJzogMCwgJ2NoYXJ0Lm1heCc6IG51bGwsICdjaGFydC5jb2xvcnMnOiBbJ2JsYWNrJ10sICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUuY29sb3InOiBudWxsLCAnY2hhcnQubnVtdGlja3MnOiA1LCAnY2hhcnQubnVtbGFiZWxzJzogNSwgJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyc6IG51bGwsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6IG51bGwsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuYWxpZ24nOiAnbGVmdCcsICdoYXJ0LnNjYWxlLmZvcm1hdHRlcic6IG51bGwsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS5kZWNpbWFscycsIDApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS5wb2ludCcsICcuJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnNjYWxlLmludmVydCcsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuc2NhbGUuemVyb3N0YXJ0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnNjYWxlLnZpc2libGUnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudW5pdHMucHJlJywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC51bml0cy5wb3N0JywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5saW5ld2lkdGgnLCAxKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubm9lbmR0aWNrLnRvcCcsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubm9lbmR0aWNrLmJvdHRvbScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubm95YXhpcycsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudG9vbHRpcHMnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JywgJ2ZhZGUnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJywgJ1JHcmFwaF90b29sdGlwJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JywgJ29uY2xpY2snKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueGF4aXNwb3MnLCAnYm90dG9tJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmV2ZW50cy5jbGljaycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfcHJvcGVydGllcyk7XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0RSQVdJTkcuWUFYSVNdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuJDAgPSB7fTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBwcm9wW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY29vcmRzVGV4dCA9IFtdO2lmICghcHJvcFsnY2hhcnQudGV4dC5jb2xvciddKSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10gPSBwcm9wWydjaGFydC5jb2xvcnMnXVswXTtpZiAoIXByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10pIHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10gPSBwcm9wWydjaGFydC5jb2xvcnMnXVswXTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmRyYXdZQXhpcygpO1JHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0aGlzLmdldFNoYXBlKGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO2lmIChtb3VzZVggPj0gdGhpcy54IC0gKHByb3BbJ2NoYXJ0LmFsaWduJ10gPT0gJ3JpZ2h0JyA/IDAgOiB0aGlzLmdldFdpZHRoKCkpICYmIG1vdXNlWCA8PSB0aGlzLnggKyAocHJvcFsnY2hhcnQuYWxpZ24nXSA9PSAncmlnaHQnID8gdGhpcy5nZXRXaWR0aCgpIDogMCkgJiYgbW91c2VZID49IHRoaXMuZ3V0dGVyVG9wICYmIG1vdXNlWSA8PSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkge1xuICAgICAgdmFyIHggPSB0aGlzLng7dmFyIHkgPSB0aGlzLmd1dHRlclRvcDt2YXIgdyA9IDE1Ozt2YXIgaCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207cmV0dXJuIHsgMDogdGhpcywgMTogeCwgMjogeSwgMzogdywgNDogaCwgNTogMCwgJ29iamVjdCc6IHRoaXMsICd4JzogeCwgJ3knOiB5LCAnd2lkdGgnOiB3LCAnaGVpZ2h0JzogaCwgJ2luZGV4JzogMCwgJ3Rvb2x0aXAnOiBwcm9wWydjaGFydC50b29sdGlwcyddID8gcHJvcFsnY2hhcnQudG9vbHRpcHMnXVswXSA6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11bMF0pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSwgMCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLmRyYXdZQXhpcyA9IHRoaXMuRHJhd1lBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAoaSBpbiBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIGkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGtleSA9IGkucmVwbGFjZSgvXmNoYXJ0XFwuLywgJ2F4aXMuJyk7cHJvcFtrZXldID0gcHJvcFtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgIHkgPSB0aGlzLmd1dHRlclRvcCxcbiAgICAgICAgaGVpZ2h0ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSB0aGlzLmd1dHRlclRvcCxcbiAgICAgICAgbWluID0gK3Byb3BbJ2NoYXJ0Lm1pbiddID8gK3Byb3BbJ2NoYXJ0Lm1pbiddIDogMCxcbiAgICAgICAgbWF4ID0gK3Byb3BbJ2NoYXJ0Lm1heCddLFxuICAgICAgICB0aXRsZSA9IHByb3BbJ2NoYXJ0LnRpdGxlJ10gPyBwcm9wWydjaGFydC50aXRsZSddIDogJycsXG4gICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQuY29sb3JzJ10gPyBwcm9wWydjaGFydC5jb2xvcnMnXVswXSA6ICdibGFjaycsXG4gICAgICAgIHRpdGxlX2NvbG9yID0gcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSA/IHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10gOiBjb2xvcixcbiAgICAgICAgbGFiZWxfY29sb3IgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10gPyBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10gOiBjb2xvcixcbiAgICAgICAgbnVtdGlja3MgPSB0eXBlb2YgcHJvcFsnY2hhcnQubnVtdGlja3MnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0Lm51bXRpY2tzJ10gOiAxMCxcbiAgICAgICAgbGFiZWxzX3NwZWNpZmljID0gcHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10sXG4gICAgICAgIG51bWxhYmVscyA9IHByb3BbJ2NoYXJ0Lm51bWxhYmVscyddID8gcHJvcFsnY2hhcnQubnVtbGFiZWxzJ10gOiA1LFxuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10gPyBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSA6ICdBcmlhbCcsXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSA/IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddIDogMTA7XG4gICAgYWxpZ24gPSB0eXBlb2YgcHJvcFsnY2hhcnQuYWxpZ24nXSA9PSAnc3RyaW5nJyA/IHByb3BbJ2NoYXJ0LmFsaWduJ10gOiAnbGVmdCcsIGZvcm1hdHRlciA9IHByb3BbJ2NoYXJ0LnNjYWxlLmZvcm1hdHRlciddLCBkZWNpbWFscyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sIGludmVydCA9IHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddLCBzY2FsZV92aXNpYmxlID0gcHJvcFsnY2hhcnQuc2NhbGUudmlzaWJsZSddLCB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgdW5pdHNfcG9zdCA9IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwgbGluZXdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ10gPyBwcm9wWydjaGFydC5saW5ld2lkdGgnXSA6IDEsIG5vdG9wZW5kdGljayA9IHByb3BbJ2NoYXJ0Lm5vZW5kdGljay50b3AnXSwgbm9ib3R0b21lbmR0aWNrID0gcHJvcFsnY2hhcnQubm9lbmR0aWNrLmJvdHRvbSddLCBub3lheGlzID0gcHJvcFsnY2hhcnQubm95YXhpcyddLCB4YXhpc3BvcyA9IHByb3BbJ2NoYXJ0LnhheGlzcG9zJ107XG4gICAgY28ubGluZVdpZHRoID0gbGluZXdpZHRoICsgMC4wMDE7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtpZiAoIW5veWF4aXMpIHtcbiAgICAgIHBhMihjbywgWydiJywgJ20nLCBNYXRoLnJvdW5kKHgpLCB5LCAnbCcsIE1hdGgucm91bmQoeCksIHkgKyBoZWlnaHQsICdzJywgY29sb3JdKTtpZiAobnVtdGlja3MpIHtcbiAgICAgICAgdmFyIGdhcCA9ICh4YXhpc3BvcyA9PSAnY2VudGVyJyA/IGhlaWdodCAvIDIgOiBoZWlnaHQpIC8gbnVtdGlja3M7dmFyIGhhbGZoZWlnaHQgPSBoZWlnaHQgLyAyO2NvLmJlZ2luUGF0aCgpO2ZvciAodmFyIGkgPSBub3RvcGVuZHRpY2sgPyAxIDogMDsgaSA8PSBudW10aWNrcyAtIChub2JvdHRvbWVuZHRpY2sgfHwgeGF4aXNwb3MgPT0gJ2NlbnRlcicgPyAxIDogMCk7ICsraSkge1xuICAgICAgICAgIHBhMihjbywgWydtJywgYWxpZ24gPT0gJ3JpZ2h0JyA/IHggKyAzIDogeCAtIDMsIE1hdGgucm91bmQoeSArIGdhcCAqIGkpLCAnbCcsIHgsIE1hdGgucm91bmQoeSArIGdhcCAqIGkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtdGlja3M7ICsraSkge1xuICAgICAgICAgICAgcGEyKGNvLCBbJ20nLCBhbGlnbiA9PSAncmlnaHQnID8geCArIDMgOiB4IC0gMywgTWF0aC5yb3VuZCh5ICsgaGFsZmhlaWdodCArIGdhcCAqIGkpLCAnbCcsIHgsIE1hdGgucm91bmQoeSArIGhhbGZoZWlnaHQgKyBnYXAgKiBpKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY28uZmlsbFN0eWxlID0gbGFiZWxfY29sb3I7dmFyIHRleHRfbGVuID0gMDtpZiAoc2NhbGVfdmlzaWJsZSkge1xuICAgICAgaWYgKGxhYmVsc19zcGVjaWZpYyAmJiBsYWJlbHNfc3BlY2lmaWMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZXh0X2xlbiA9IDA7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhYmVsc19zcGVjaWZpYy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRleHRfbGVuID0gbWEubWF4KHRleHRfbGVuLCBjby5tZWFzdXJlVGV4dChsYWJlbHNfc3BlY2lmaWNbaV0pLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGFiZWxzX3NwZWNpZmljLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgdmFyIGdhcCA9IGxlbiAtIDEgPiAwID8gaGVpZ2h0IC8gKGxlbiAtIDEpIDogMDtpZiAoeGF4aXNwb3MgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGdhcCAvPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHggLSAoYWxpZ24gPT0gJ3JpZ2h0JyA/IC01IDogNSksICd5JzogaSAqIGdhcCArIHRoaXMuZ3V0dGVyVG9wLCAndGV4dCc6IGxhYmVsc19zcGVjaWZpY1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24gPT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCcsICd0YWcnOiAnc2NhbGUnIH0pO3RoaXMubWF4TGFiZWxMZW5ndGggPSBtYS5tYXgodGhpcy5tYXhMYWJlbExlbmd0aCwgY28ubWVhc3VyZVRleHQobGFiZWxzX3NwZWNpZmljW2ldKS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGxhYmVsc19zcGVjaWZpYy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4IC0gKGFsaWduID09ICdyaWdodCcgPyAtNSA6IDUpLCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gaSAqIGdhcCwgJ3RleHQnOiBsYWJlbHNfc3BlY2lmaWNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduID09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG51bWxhYmVsczsgKytpKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gKG1heCAtIG1pbikgKiAoKG51bWxhYmVscyAtIGkpIC8gbnVtbGFiZWxzKSArIG1pbjtpZiAob3JpZ2luYWwgPT0gMCAmJiBwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0ZXh0ID0gUkcubnVtYmVyRm9ybWF0KHRoaXMsIG9yaWdpbmFsLnRvRml4ZWQob3JpZ2luYWwgPT09IDAgPyAwIDogZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpO3ZhciB0ZXh0ID0gU3RyaW5nKHR5cGVvZiBmb3JtYXR0ZXIgPT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdHRlcih0aGlzLCBvcmlnaW5hbCkgOiB0ZXh0KTt2YXIgdGV4dF9sZW4gPSBtYS5tYXgodGV4dF9sZW4sIGNvLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoKTt0aGlzLm1heExhYmVsTGVuZ3RoID0gdGV4dF9sZW47aWYgKGludmVydCkge1xuICAgICAgICAgICAgdmFyIHkgPSBoZWlnaHQgLSBoZWlnaHQgLyBudW1sYWJlbHMgKiBpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgeSA9IGhlaWdodCAvIG51bWxhYmVscyAqIGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5ID0geSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL14tLChbMC05XSkvLCAnLSQxJyk7UkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4IC0gKGFsaWduID09ICdyaWdodCcgPyAtNSA6IDUpLCAneSc6IHkgKyB0aGlzLmd1dHRlclRvcCwgJ3RleHQnOiB0ZXh0LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiA9PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JywgJ3RhZyc6ICdzY2FsZScgfSk7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicgJiYgaSA8IG51bWxhYmVscykge1xuICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4IC0gKGFsaWduID09ICdyaWdodCcgPyAtNSA6IDUpLCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0geSwgJ3RleHQnOiAnLScgKyB0ZXh0LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiA9PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gdGl0bGVfY29sb3I7aWYgKGxhYmVsc19zcGVjaWZpYykge1xuICAgICAgICB2YXIgd2lkdGggPSAwO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHNfc3BlY2lmaWMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjby5tZWFzdXJlVGV4dChsYWJlbHNfc3BlY2lmaWNbaV0pLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdpZHRoID0gY28ubWVhc3VyZVRleHQocHJvcFsnY2hhcnQudW5pdHMucHJlJ10gKyBwcm9wWydjaGFydC5tYXgnXS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pICsgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKS53aWR0aDtcbiAgICAgIH1cbiAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSArIDIsIHg6IGFsaWduID09ICdyaWdodCcgPyB4ICsgd2lkdGggKyA4IDogeCAtIHdpZHRoIC0gOCwgeTogaGVpZ2h0IC8gMiArIHRoaXMuZ3V0dGVyVG9wLCB0ZXh0OiB0aXRsZSwgdmFsaWduOiAnYm90dG9tJywgaGFsaWduOiAnY2VudGVyJywgYW5nbGU6IGFsaWduID09ICdyaWdodCcgPyA5MCA6IC05MCwgYWNjZXNzaWJsZTogZmFsc2UgfSk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICB9O3RoaXMuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5tYXhMYWJlbExlbmd0aDtpZiAocHJvcFsnY2hhcnQudGl0bGUnXSAmJiBwcm9wWydjaGFydC50aXRsZSddLmxlbmd0aCkge1xuICAgICAgd2lkdGggKz0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKiAxLjU7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtyZXR1cm4gd2lkdGg7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmRyYXdpbmcueWF4aXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///187\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Fuel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'fuel';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.angles = {};this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.colors': ['Gradient(white:red)'], 'chart.needle.color': 'red', 'chart.gutter.left': 5, 'chart.gutter.right': 5, 'chart.gutter.top': 5, 'chart.gutter.bottom': 5, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.icon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAfCAYAAAD0ma06AAAEGElEQVRIS7VXSyhtYRT+jnfe5FEMjAwUBiQGHikzRWIkkgy8YyDK+xnJK5JCeZSUGKBMiAyYkMxMJAMpSfJ+2/d8695/33NunSPnHqt2Z5+91/9/' + '/' + '/et9a/1b8Pn56dmMBhg/IWDgwNoNzc38PHxkXtN0+Tiexp9eH18fIDj1Bj63N/fw8vLS/wsmcHoqKmXT09PuL29RVFREU5OTvTJ6UIAgioQ+vLe09MTb29v8PX1RWBgICYnJ+XXIqDRWXN0dJT3nIDsWlpadP+lpSWZlD4KmL/8/' + '/7+Ls/S09N1/7y8PISHh+sK/QssDJWcHEyGCnB1dRUDAwPIzMzUx5GpAnZ1dcXy8jK2trbM5j06OsLc3JzISx8q4OzsLOOsAq6treHg4AAeHh4WJbq7u0Nzc7P+PiYmBnt7ezg9PcXExAQCAgLg5OSEx8dHuLu7Wwfc3t7G/v6+yEcjO8rIROGKaWdnZ+jr6zMDjI6OxvT0tDzr6uqS2KtksspwZ2cHjY2NuqSUhnHmilUCraysmElaWloKJpQCjI2NRX5+Pl5eXr6WlCv08/MTEMVOZDH+Zzw4CdlfX1/rDHt7ezE1NQXGkcYEKi4ulkVKYlpLGouBs/JiaGgIZL25uSlecXFxohAz/ccAz8/P4e/vj7q6Ojw8PMje5DNRy94MQ0JCUFtbK2wqKipE+sHBQbi4uPwMQ86ak5ODxMREVFdXIywsDCUlJRJDXnZlmJqaip6eHuTm5kqikGlycjIyMjL+ZrY9JSUgMzQiIgINDQ2ypaqqqkCZWXHsnjQEHB8fR0pKigAxabq7uyWOlJNxtLukTJDs7GxUVlZKDNl5oqKi8Pr6+jOAIyMjiI+Pl5JGQG4F1Qy+LN7f3fiUdGZmBsHBwRgbG8Pw8LD01ba2NmlX0rTtnTQLCwvSjEdHR3FxcSExLCwsRGRkpBR9vePzeMDyw3bT1NT0XXLiT4a7u7s4Pj4GGzd7K8GCgoKEsRR8I4Cm6hwHXV5eiv62GAE5npMTmFuBTCkzmzT7qs5Q9TlW/o6ODlvwhCHPM5SVPZIxYzNeXFxEa2srvL29YTC2GI3aMm3Zeq6urv4LMC0tDRsbG1K8k5KS9DgS0IwhKVFjSsJA22r9/f0oKCgQdvPz83JEmZ2dlcpD9maSshow0KZnlO8Csx9yK3BLKCMJPpf2xGMigdi9WXooaWdn53dxdP+amhrZh4eHh1hfX5cTW319vZyBnp+ffzNkBWBmhYaGysB/j322oCckJCArK0uGMlsJ5ubmBoPxRiMzFlomjr2MGdne3i5ANILRJEtJt6ysTG8h9gDl4am8vFwSUWron1O9LulXIOqk9pWftfdSS40yyj5Uh101wPRryuR7R1ZMX/U1pfy5IF40xcgUnGAc9wsGYxsFhy87kwAAAABJRU5ErkJggg=='), _defineProperty(_properties, 'chart.icon.redraw', true), _defineProperty(_properties, 'chart.background.image.stretch', false), _defineProperty(_properties, 'chart.background.image.x', null), _defineProperty(_properties, 'chart.background.image.y', null), _defineProperty(_properties, 'chart.labels.full', 'F'), _defineProperty(_properties, 'chart.labels.empty', 'E'), _defineProperty(_properties, 'chart.labels.count', 5), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.scale.visible', false), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - 20 - this.gutterBottom;\n    this.radius = ca.height - this.gutterTop - this.gutterBottom - 20;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.angles.start = RG.PI + RG.HALFPI - 0.5;this.angles.end = RG.PI + RG.HALFPI + 0.5;this.angles.needle = this.getAngle(this.value);this.DrawLabels();this.DrawChart();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawChart = this.DrawChart = function () {\n    this.DrawScale();if (!RG.ISOLD) {\n      this.DrawIcon();\n    }\n    this.DrawNeedle();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.scale.visible']) {\n      var radius = this.radius - 20;co.fillStyle = prop['chart.text.color'];var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx - Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.empty'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });var y = this.centery - Math.sin(this.angles.start - RG.PI) * (this.radius - 25);var x = this.centerx + Math.cos(this.angles.start - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': x, 'y': y, 'text': prop['chart.labels.full'], 'halign': 'center', 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function () {\n    co.beginPath();co.lineWidth = 5;co.lineCap = 'round';co.strokeStyle = prop['chart.needle.color'];var angle = this.angles.needle;co.arc(this.centerx, this.centery, this.radius - 30, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);co.stroke();co.lineWidth = 1;var cx = this.centerx + 10;var cy = this.centery - 10;\n    var grad = co.createRadialGradient(cx, cy, 35, cx, cy, 0);grad.addColorStop(0, 'black');grad.addColorStop(1, '#eee');if (navigator.userAgent.indexOf('Firefox/6.0') > 0) {\n      grad = co.createLinearGradient(cx + 10, cy - 10, cx - 10, cy + 10);grad.addColorStop(1, '#666');grad.addColorStop(0.5, '#ccc');\n    }\n    co.beginPath();co.fillStyle = grad;co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 20, 0, RG.TWOPI, 0);co.fill();\n  };this.drawScale = this.DrawScale = function () {\n    var a, x, y;co.beginPath();co.strokeStyle = 'black';co.fillStyle = 'white';co.arc(this.centerx, this.centery, this.radius, this.angles.start, this.angles.end, false);co.arc(this.centerx, this.centery, this.radius - 10, this.angles.end, this.angles.start, true);co.closePath();co.stroke();co.fill();var start = this.angles.start;var end = this.angles.needle;co.beginPath();co.fillStyle = prop['chart.colors'][0];co.arc(this.centerx, this.centery, this.radius, start, end, false);co.arc(this.centerx, this.centery, this.radius - 10, end, start, true);co.closePath();co.fill();for (a = this.angles.start; a <= this.angles.end + 0.01; a += (this.angles.end - this.angles.start) / 5) {\n      co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10, a, a + 0.0001, false);co.arc(this.centerx, this.centery, this.radius - 15, a + 0.0001, a, true);co.stroke();\n    }\n    if (prop['chart.scale.visible']) {\n      co.fillStyle = prop['chart.text.color'];var numLabels = prop['chart.labels.count'];var decimals = prop['chart.scale.decimals'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var units_post = prop['chart.units.post'];var units_pre = prop['chart.units.pre'];for (var i = 0; i <= numLabels; ++i) {\n        a = (this.angles.end - this.angles.start) * (i / numLabels) + this.angles.start;y = this.centery - Math.sin(a - RG.PI) * (this.radius - 25);x = this.centerx - Math.cos(a - RG.PI) * (this.radius - 25);RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': RG.number_format(this, (this.min + (this.max - this.min) * (i / numLabels)).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (angle >= this.angles.end) {\n      return this.max;\n    } else if (angle <= this.angles.start) {\n      return this.min;\n    }\n    var value = (angle - this.angles.start) / (this.angles.end - this.angles.start);value = value * (this.max - this.min);value = value + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var accuracy = 15;var leftMin = this.centerx - this.radius;var rightMax = this.centerx + this.radius;var topMin = this.centery - this.radius;var bottomMax = this.centery + this.radius;if (mouseXY[0] > leftMin && mouseXY[0] < rightMax && mouseXY[1] > topMin && mouseXY[1] < bottomMax) {\n      return this;\n    }\n  };this.drawIcon = this.DrawIcon = function () {\n    if (!RG.ISOLD) {\n      if (!this.__icon__ || !this.__icon__.__loaded__) {\n        var img = new Image();img.src = prop['chart.icon'];img.__object__ = this;this.__icon__ = img;img.onload = function (e) {\n          img.__loaded__ = true;var obj = img.__object__;co.drawImage(img, obj.centerx - img.width / 2, obj.centery - obj.radius + 35);obj.DrawNeedle();if (prop['chart.icon.redraw']) {\n            obj.Set('chart.icon.redraw', false);RG.Clear(obj.canvas);RG.RedrawCanvas(ca);\n          }\n        };\n      } else {\n        var img = this.__icon__;co.drawImage(img, this.centerx - img.width / 2, this.centery - this.radius + 35);\n      }\n    }\n    this.DrawNeedle();\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value < this.min || value > this.max) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.angles.end - this.angles.start) + this.angles.start;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.needle.color'] = RG.array_clone(prop['chart.needle.color']);\n    }\n    var props = this.properties;var colors = props['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForLinearGradient(colors[i]);\n    }\n    props['chart.needle.color'] = this.parseSingleColorForRadialGradient(props['chart.needle.color']);\n  };this.reset = function () {};this.parseSingleColorForLinearGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForRadialGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var callback = arguments[1] || function () {};var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;var obj = this;var origValue = Number(this.currentValue);if (this.currentValue == null) {\n      this.currentValue = this.min;origValue = this.min;\n    }\n    var newValue = this.value;var diff = newValue - origValue;var step = diff / numFrames;var frame = 0;function iterator() {\n      frame++;obj.value = frame / numFrames * diff + origValue;\n      if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < numFrames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5mdWVsLmpzPzA1YTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguRnVlbCA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIHZhciBfcHJvcGVydGllcztcblxuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgbWluID0gY29uZi5taW4sXG4gICAgICAgIG1heCA9IGNvbmYubWF4LFxuICAgICAgICB2YWx1ZSA9IGNvbmYudmFsdWUsXG4gICAgICAgIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZCA9IGNvbmYsXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgbWluID0gYXJndW1lbnRzWzFdLFxuICAgICAgICBtYXggPSBhcmd1bWVudHNbMl0sXG4gICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGNhbnZhczt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6ICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlkKSkgPT09ICdvYmplY3QnICYmIGlkLmFscGhhID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSB9KSA6IG51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ2Z1ZWwnO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMubWluID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWluKTt0aGlzLm1heCA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1heCk7dGhpcy52YWx1ZSA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmFuZ2xlcyA9IHt9O3RoaXMuY3VycmVudFZhbHVlID0gbnVsbDt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5vcmlnaW5hbF9jb2xvcnMgPSBbXTt0aGlzLmZpcnN0RHJhdyA9IHRydWU7aWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRlVFTF0gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdGhpcy5wcm9wZXJ0aWVzID0gKF9wcm9wZXJ0aWVzID0geyAnY2hhcnQuY29sb3JzJzogWydHcmFkaWVudCh3aGl0ZTpyZWQpJ10sICdjaGFydC5uZWVkbGUuY29sb3InOiAncmVkJywgJ2NoYXJ0Lmd1dHRlci5sZWZ0JzogNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDUsICdjaGFydC5ndXR0ZXIudG9wJzogNSwgJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOiA1LCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuZm9udCc6ICdTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6ICd2aXNpYmxlJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzogdHJ1ZSwgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycsICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhY3RvcicsIDEuNSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uZmFkZS5pbicsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhZGUub3V0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uaGRpcicsICdyaWdodCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLnZkaXInLCAnZG93bicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZyYW1lcycsIDI1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5kZWxheScsIDE2LjY2NiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uc2hhZG93JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmFjdGlvbicsICd6b29tJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFkanVzdGFibGUnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJlc2l6YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lmljb24nLCAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCd0FBQUFmQ0FZQUFBRDBtYTA2QUFBRUdFbEVRVlJJUzdWWFN5aHRZUlQram5mZTVGRU1qQXdVQmlRR0hpa3pSV0lra2d5OFl5REsreG5KSzVKQ2VaU1VHS0JNaUF5WWtNeE1KQU1wU2ZKKzIvZDg2OTUvMzNOdW5TUG5IcXQyWjUrOTEvOS8nICsgJy8nICsgJy9ldDlhLzFiOFBuNTZkbU1CaGcvSVdEZ3dOb056YzM4UEh4a1h0TjArVGlleHA5ZUgxOGZJRGoxQmo2M04vZnc4dkxTL3dzbWNIb3FLbVhUMDlQdUwyOVJWRlJFVTVPVHZUSjZVSUFnaW9RK3ZMZTA5TVRiMjl2OFBYMVJXQmdJQ1luSitYWElxRFJXWE4wZEpUM25JRHNXbHBhZFArbHBTV1psRDRLbUwvOC8nICsgJy83K0xzL1MwOU4xLzd5OFBJU0hoK3NLL1Fzc0RKV2NIRXlHQ25CMWRSVURBd1BJek16VXg1R3BBbloxZGNYeThqSzJ0cmJNNWowNk9zTGMzSnpJU3g4cTRPenNMT09zQXE2dHJlSGc0QUFlSGg0V0picTd1ME56YzdQK1BpWW1CbnQ3ZXpnOVBjWEV4QVFDQWdMZzVPU0V4OGRIdUx1N1d3ZmMzdDdHL3Y2K3lFY2pPOHJJUk9HS2FXZG5aK2pyNnpNRGpJNk94dlQwdER6cjZ1cVMyS3Rrc3Nwd1oyY0hqWTJOdXFTVWhuSG1pbFVDcmF5c21FbGFXbG9LSnBRQ2pJMk5SWDUrUGw1ZVhyNldsQ3YwOC9NVEVNVk9aREgrWnp3NENkbGZYMS9yREh0N2V6RTFOUVhHa2NZRUtpNHVsa1ZLWWxwTEdvdUJzL0ppYUdnSVpMMjV1U2xlY1hGeG9oQXovY2NBejgvUDRlL3ZqN3E2T2p3OFBNamU1RE5SeTk0TVEwSkNVRnRiSzJ3cUtpcEUrc0hCUWJpNHVQd01RODZhazVPRHhNUkVWRmRYSXl3c0RDVWxKUkpEWG5abG1KcWFpcDZlSHVUbTVrcWlrR2x5Y2pJeU1qTCtaclk5SlNVZ016UWlJZ0lORFEyeXBhcXFxa0NaV1hIc25qUUVIQjhmUjBwS2lnQXhhYnE3dXlXT2xKTnh0THVrVEpEczdHeFVWbFpLRE5sNW9xS2k4UHI2K2pPQUl5TWppSStQbDVKR1FHNEYxUXkrTE43ZjNmaVVkR1ptQnNIQndSZ2JHOFB3OExEMDFiYTJObWxYMHJUdG5UUUxDd3ZTakVkSFIzRnhjU0V4TEN3c1JHUmtwQlI5dmVQemVNRHl3M2JUMU5UMFhYTGlUNGE3dTdzNFBqNEdHemQ3SzhHQ2dvS0VzUlI4STRDbTZod0hYVjVlaXY2MkdBRTVucE1UbUZ1QlRDa3ptelQ3cXM1UTlUbFcvbzZPRGx2d2hDSFBNNVNWUFpJeFl6TmVYRnhFYTJzcnZMMjlZVEMyR0kzYU1tM1plcTZ1cnY0TE1DMHREUnNiRzFLOGs1S1M5RGdTMEl3aEtWRmpTc0pBMjJyOS9mMG9LQ2dRZHZQejgzSkVtWjJkbGNwRDltYVNzaG93MEtabmxPOENzeDl5SzNCTEtDTUpQcGYyeEdNaWdkaTlXWG9vYVdkbjUzZHhkUCthbWhyWmg0ZUhoMWhmWDVjVFczMTl2WnlCbnArZmZ6TmtCV0JtaFlhR3lzQi9qMzIyb0Nja0pDQXJLMHVHTWxzSjV1Ym1Cb1B4UmlNekZsb21qcjJNR2RuZTNpNUFOSUxSSkV0SnQ2eXNURzhoOWdEbDRhbTh2RndTVVdyb24xTzlMdWxYSU9xazlwV2Z0ZmRTUzQweXlqNVVoMTAxd1BScnl1UjdSMVpNWC9VMXBmeTVJRjQweGNnVW5HQWM5d3NHWXhzRmh5ODdrd0FBQUFCSlJVNUVya0pnZ2c9PScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5pY29uLnJlZHJhdycsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueCcsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnknLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubGFiZWxzLmZ1bGwnLCAnRicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5sYWJlbHMuZW1wdHknLCAnRScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5sYWJlbHMuY291bnQnLCA1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuY2VudGVyeCcsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jZW50ZXJ5JywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJhZGl1cycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS52aXNpYmxlJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS5kZWNpbWFscycsIDApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC51bml0cy5wcmUnLCAnJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnVuaXRzLnBvc3QnLCAnJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfcHJvcGVydGllcyk7XG4gIGlmICh0aGlzLnZhbHVlID4gdGhpcy5tYXgpIHRoaXMudmFsdWUgPSB0aGlzLm1heDtpZiAodGhpcy52YWx1ZSA8IHRoaXMubWluKSB0aGlzLnZhbHVlID0gdGhpcy5taW47aWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTt0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jZW50ZXJ4ID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeSA9IGNhLmhlaWdodCAtIDIwIC0gdGhpcy5ndXR0ZXJCb3R0b207XG4gICAgdGhpcy5yYWRpdXMgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gMjA7dGhpcy5jb29yZHNUZXh0ID0gW107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ4J10gPT0gJ251bWJlcicpIHRoaXMuY2VudGVyeCA9IHByb3BbJ2NoYXJ0LmNlbnRlcngnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXSA9PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ5ID0gcHJvcFsnY2hhcnQuY2VudGVyeSddO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQucmFkaXVzJ10gPT0gJ251bWJlcicpIHRoaXMucmFkaXVzID0gcHJvcFsnY2hhcnQucmFkaXVzJ107aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5hbmdsZXMuc3RhcnQgPSBSRy5QSSArIFJHLkhBTEZQSSAtIDAuNTt0aGlzLmFuZ2xlcy5lbmQgPSBSRy5QSSArIFJHLkhBTEZQSSArIDAuNTt0aGlzLmFuZ2xlcy5uZWVkbGUgPSB0aGlzLmdldEFuZ2xlKHRoaXMudmFsdWUpO3RoaXMuRHJhd0xhYmVscygpO3RoaXMuRHJhd0NoYXJ0KCk7aWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdDaGFydCA9IHRoaXMuRHJhd0NoYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuRHJhd1NjYWxlKCk7aWYgKCFSRy5JU09MRCkge1xuICAgICAgdGhpcy5EcmF3SWNvbigpO1xuICAgIH1cbiAgICB0aGlzLkRyYXdOZWVkbGUoKTtcbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwcm9wWydjaGFydC5zY2FsZS52aXNpYmxlJ10pIHtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cyAtIDIwO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgeSA9IHRoaXMuY2VudGVyeSAtIE1hdGguc2luKHRoaXMuYW5nbGVzLnN0YXJ0IC0gUkcuUEkpICogKHRoaXMucmFkaXVzIC0gMjUpO3ZhciB4ID0gdGhpcy5jZW50ZXJ4IC0gTWF0aC5jb3ModGhpcy5hbmdsZXMuc3RhcnQgLSBSRy5QSSkgKiAodGhpcy5yYWRpdXMgLSAyNSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IHgsICd5JzogeSwgJ3RleHQnOiBwcm9wWydjaGFydC5sYWJlbHMuZW1wdHknXSwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnbGFiZWxzJyB9KTt2YXIgeSA9IHRoaXMuY2VudGVyeSAtIE1hdGguc2luKHRoaXMuYW5nbGVzLnN0YXJ0IC0gUkcuUEkpICogKHRoaXMucmFkaXVzIC0gMjUpO3ZhciB4ID0gdGhpcy5jZW50ZXJ4ICsgTWF0aC5jb3ModGhpcy5hbmdsZXMuc3RhcnQgLSBSRy5QSSkgKiAodGhpcy5yYWRpdXMgLSAyNSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IHgsICd5JzogeSwgJ3RleHQnOiBwcm9wWydjaGFydC5sYWJlbHMuZnVsbCddLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdsYWJlbHMnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdOZWVkbGUgPSB0aGlzLkRyYXdOZWVkbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gNTtjby5saW5lQ2FwID0gJ3JvdW5kJztjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvciddO3ZhciBhbmdsZSA9IHRoaXMuYW5nbGVzLm5lZWRsZTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMzAsIGFuZ2xlLCBhbmdsZSArIDAuMDAwMSwgZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gMTt2YXIgY3ggPSB0aGlzLmNlbnRlcnggKyAxMDt2YXIgY3kgPSB0aGlzLmNlbnRlcnkgLSAxMDtcbiAgICB2YXIgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KGN4LCBjeSwgMzUsIGN4LCBjeSwgMCk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgJ2JsYWNrJyk7Z3JhZC5hZGRDb2xvclN0b3AoMSwgJyNlZWUnKTtpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94LzYuMCcpID4gMCkge1xuICAgICAgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KGN4ICsgMTAsIGN5IC0gMTAsIGN4IC0gMTAsIGN5ICsgMTApO2dyYWQuYWRkQ29sb3JTdG9wKDEsICcjNjY2Jyk7Z3JhZC5hZGRDb2xvclN0b3AoMC41LCAnI2NjYycpO1xuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBncmFkO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAyMCwgMCwgUkcuVFdPUEksIDApO2NvLmZpbGwoKTtcbiAgfTt0aGlzLmRyYXdTY2FsZSA9IHRoaXMuRHJhd1NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhLCB4LCB5O2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztjby5maWxsU3R5bGUgPSAnd2hpdGUnO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHRoaXMuYW5nbGVzLnN0YXJ0LCB0aGlzLmFuZ2xlcy5lbmQsIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAsIHRoaXMuYW5nbGVzLmVuZCwgdGhpcy5hbmdsZXMuc3RhcnQsIHRydWUpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt2YXIgc3RhcnQgPSB0aGlzLmFuZ2xlcy5zdGFydDt2YXIgZW5kID0gdGhpcy5hbmdsZXMubmVlZGxlO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHN0YXJ0LCBlbmQsIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAsIGVuZCwgc3RhcnQsIHRydWUpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtmb3IgKGEgPSB0aGlzLmFuZ2xlcy5zdGFydDsgYSA8PSB0aGlzLmFuZ2xlcy5lbmQgKyAwLjAxOyBhICs9ICh0aGlzLmFuZ2xlcy5lbmQgLSB0aGlzLmFuZ2xlcy5zdGFydCkgLyA1KSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAsIGEsIGEgKyAwLjAwMDEsIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTUsIGEgKyAwLjAwMDEsIGEsIHRydWUpO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuc2NhbGUudmlzaWJsZSddKSB7XG4gICAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIG51bUxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO3ZhciBkZWNpbWFscyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107dmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXTtmb3IgKHZhciBpID0gMDsgaSA8PSBudW1MYWJlbHM7ICsraSkge1xuICAgICAgICBhID0gKHRoaXMuYW5nbGVzLmVuZCAtIHRoaXMuYW5nbGVzLnN0YXJ0KSAqIChpIC8gbnVtTGFiZWxzKSArIHRoaXMuYW5nbGVzLnN0YXJ0O3kgPSB0aGlzLmNlbnRlcnkgLSBNYXRoLnNpbihhIC0gUkcuUEkpICogKHRoaXMucmFkaXVzIC0gMjUpO3ggPSB0aGlzLmNlbnRlcnggLSBNYXRoLmNvcyhhIC0gUkcuUEkpICogKHRoaXMucmFkaXVzIC0gMjUpO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCwgJ3knOiB5LCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgKHRoaXMubWluICsgKHRoaXMubWF4IC0gdGhpcy5taW4pICogKGkgLyBudW1MYWJlbHMpKS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGUpIHt9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgYW5nbGUgPSBSRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG1vdXNlWFlbMF0sIG1vdXNlWFlbMV0pO2lmIChhbmdsZSA+PSB0aGlzLmFuZ2xlcy5lbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heDtcbiAgICB9IGVsc2UgaWYgKGFuZ2xlIDw9IHRoaXMuYW5nbGVzLnN0YXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5taW47XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChhbmdsZSAtIHRoaXMuYW5nbGVzLnN0YXJ0KSAvICh0aGlzLmFuZ2xlcy5lbmQgLSB0aGlzLmFuZ2xlcy5zdGFydCk7dmFsdWUgPSB2YWx1ZSAqICh0aGlzLm1heCAtIHRoaXMubWluKTt2YWx1ZSA9IHZhbHVlICsgdGhpcy5taW47cmV0dXJuIHZhbHVlO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBhbmdsZSA9IFJHLmdldEFuZ2xlQnlYWSh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYWVswXSwgbW91c2VYWVsxXSk7dmFyIGFjY3VyYWN5ID0gMTU7dmFyIGxlZnRNaW4gPSB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1czt2YXIgcmlnaHRNYXggPSB0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1czt2YXIgdG9wTWluID0gdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXM7dmFyIGJvdHRvbU1heCA9IHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzO2lmIChtb3VzZVhZWzBdID4gbGVmdE1pbiAmJiBtb3VzZVhZWzBdIDwgcmlnaHRNYXggJiYgbW91c2VYWVsxXSA+IHRvcE1pbiAmJiBtb3VzZVhZWzFdIDwgYm90dG9tTWF4KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5kcmF3SWNvbiA9IHRoaXMuRHJhd0ljb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSRy5JU09MRCkge1xuICAgICAgaWYgKCF0aGlzLl9faWNvbl9fIHx8ICF0aGlzLl9faWNvbl9fLl9fbG9hZGVkX18pIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO2ltZy5zcmMgPSBwcm9wWydjaGFydC5pY29uJ107aW1nLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMuX19pY29uX18gPSBpbWc7aW1nLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaW1nLl9fbG9hZGVkX18gPSB0cnVlO3ZhciBvYmogPSBpbWcuX19vYmplY3RfXztjby5kcmF3SW1hZ2UoaW1nLCBvYmouY2VudGVyeCAtIGltZy53aWR0aCAvIDIsIG9iai5jZW50ZXJ5IC0gb2JqLnJhZGl1cyArIDM1KTtvYmouRHJhd05lZWRsZSgpO2lmIChwcm9wWydjaGFydC5pY29uLnJlZHJhdyddKSB7XG4gICAgICAgICAgICBvYmouU2V0KCdjaGFydC5pY29uLnJlZHJhdycsIGZhbHNlKTtSRy5DbGVhcihvYmouY2FudmFzKTtSRy5SZWRyYXdDYW52YXMoY2EpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbWcgPSB0aGlzLl9faWNvbl9fO2NvLmRyYXdJbWFnZShpbWcsIHRoaXMuY2VudGVyeCAtIGltZy53aWR0aCAvIDIsIHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICsgMzUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLkRyYXdOZWVkbGUoKTtcbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZSk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYWRqdXN0Jyk7XG4gICAgfVxuICB9O3RoaXMuZ2V0QW5nbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCB0aGlzLm1pbiB8fCB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGFuZ2xlID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHRoaXMuYW5nbGVzLmVuZCAtIHRoaXMuYW5nbGVzLnN0YXJ0KSArIHRoaXMuYW5nbGVzLnN0YXJ0O3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQubmVlZGxlLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5uZWVkbGUuY29sb3InXSk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllczt2YXIgY29sb3JzID0gcHJvcHNbJ2NoYXJ0LmNvbG9ycyddO2ZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JMaW5lYXJHcmFkaWVudChjb2xvcnNbaV0pO1xuICAgIH1cbiAgICBwcm9wc1snY2hhcnQubmVlZGxlLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JSYWRpYWxHcmFkaWVudChwcm9wc1snY2hhcnQubmVlZGxlLmNvbG9yJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQocHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSwgMCwgY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgMCk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvclJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgbnVtRnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMDt2YXIgZnJhbWUgPSAwO3ZhciBvYmogPSB0aGlzO3ZhciBvcmlnVmFsdWUgPSBOdW1iZXIodGhpcy5jdXJyZW50VmFsdWUpO2lmICh0aGlzLmN1cnJlbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMubWluO29yaWdWYWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO3ZhciBkaWZmID0gbmV3VmFsdWUgLSBvcmlnVmFsdWU7dmFyIHN0ZXAgPSBkaWZmIC8gbnVtRnJhbWVzO3ZhciBmcmFtZSA9IDA7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBmcmFtZSsrO29iai52YWx1ZSA9IGZyYW1lIC8gbnVtRnJhbWVzICogZGlmZiArIG9yaWdWYWx1ZTtcbiAgICAgIGlmIChvYmoudmFsdWUgPiBvYmoubWF4KSBvYmoudmFsdWUgPSBvYmoubWF4O2lmIChvYmoudmFsdWUgPCBvYmoubWluKSBvYmoudmFsdWUgPSBvYmoubWluO1JHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSA8IG51bUZyYW1lcykge1xuICAgICAgICBSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5mdWVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///188\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Funnel = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'funnel';this.coords = [];this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (!this.canvas) {\n    alert('[FUNNEL] No canvas support');return;\n  }\n  this.properties = (_properties = { 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': null, 'chart.labels.sticks': false, 'chart.labels.x': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['Gradient(white:red)', 'Gradient(white:green)', 'Gradient(white:gray)', 'Gradient(white:blue)', 'Gradient(white:black)', 'Gradient(white:gray)', 'Gradient(white:pink)', 'Gradient(white:blue)', 'Gradient(white:yellow)', 'Gradient(white:green)', 'Gradient(white:red)'], 'chart.text.size': 12, 'chart.text.boxed': true, 'chart.text.halign': 'left', 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.tooltips.highlight': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true }, _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var i = 0; i < data.length; ++i) {\n    data[i] = parseFloat(data[i]);\n  }\n  this.data = data;for (var i = 0; i < data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.DrawFunnel();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawLabels();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawFunnel = this.DrawFunnel = function () {\n    var width = ca.width - this.gutterLeft - this.gutterRight;var height = ca.height - this.gutterTop - this.gutterBottom;var total = RG.array_max(this.data);var accheight = this.gutterTop;if (prop['chart.shadow']) {\n      co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n    for (i = 0, len = this.data.length; i < len; ++i) {\n      var firstvalue = this.data[0];var firstwidth = firstvalue / total * width;var curvalue = this.data[i];var curwidth = curvalue / total * width;var curheight = height / this.data.length;var halfCurWidth = curwidth / 2;var nextvalue = this.data[i + 1];var nextwidth = this.data[i + 1] ? nextvalue / total * width : null;var halfNextWidth = nextwidth / 2;var center = this.gutterLeft + firstwidth / 2;var x1 = center - halfCurWidth;var y1 = accheight;var x2 = center + halfCurWidth;var y2 = accheight;var x3 = center + halfNextWidth;var y3 = accheight + curheight;var x4 = center - halfNextWidth;var y4 = accheight + curheight;if (nextwidth && i < this.data.length - 1) {\n        co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.moveTo(x1, y1);co.lineTo(x2, y2);co.lineTo(x3, y3);co.lineTo(x4, y4);co.closePath();this.coords.push([x1, y1, x2, y2, x3, y3, x4, y4]);\n      }\n      if (!prop['chart.shadow']) {\n        co.stroke();\n      }\n      co.fill();accheight += curheight;\n    }\n    if (prop['chart.shadow']) {\n      RG.NoShadow(this);for (i = 0; i < this.coords.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][i];co.beginPath();co.moveTo(this.coords[i][0], this.coords[i][1]);co.lineTo(this.coords[i][2], this.coords[i][3]);co.lineTo(this.coords[i][4], this.coords[i][5]);co.lineTo(this.coords[i][6], this.coords[i][7]);co.closePath();co.stroke();co.fill();\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var color = prop['chart.text.color'];var labels = prop['chart.labels'];var halign = prop['chart.text.halign'] == 'left' ? 'left' : 'center';var bgcolor = prop['chart.text.boxed'] ? 'white' : null;if (typeof prop['chart.labels.x'] == 'number') {\n        var x = prop['chart.labels.x'];\n      } else {\n        var x = halign == 'left' ? this.gutterLeft - 15 : (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;\n      }\n      for (var j = 0; j < this.coords.length; ++j) {\n        co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;RG.NoShadow(this);var label = labels[j];RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j][1], 'text': label, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(label).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, ma.round(this.coords[j][1]));co.lineTo(this.coords[j][0] - 10, ma.round(this.coords[j][1]));co.stroke();\n        }\n      }\n      var lastLabel = labels[j];if (lastLabel) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': x, 'y': this.coords[j - 1][5], 'text': lastLabel, 'valign': 'center', 'halign': halign, 'bounding': prop['chart.text.boxed'], 'boundingFill': bgcolor, 'tag': 'labels' });if (prop['chart.labels.sticks']) {\n          co.font = size + 'pt ' + font;var labelWidth = co.measureText(lastLabel).width;co.beginPath();co.strokeStyle = 'gray';co.moveTo(x + labelWidth + 10, Math.round(this.coords[j - 1][7]));co.lineTo(this.coords[j - 1][6] - 10, Math.round(this.coords[j - 1][7]));co.stroke();\n        }\n      }\n    }\n  };this.getShape = this.getSegment = function (e) {\n    var coords = this.coords;var mouseCoords = RG.getMouseXY(e);var x = mouseCoords[0];var y = mouseCoords[1];for (i = 0, len = coords.length; i < len; ++i) {\n      var segment = coords[i];\n      co.beginPath();co.moveTo(segment[0], segment[1]);co.lineTo(segment[2], segment[3]);co.lineTo(segment[4], segment[5]);co.lineTo(segment[6], segment[7]);co.lineTo(segment[8], segment[9]);if (co.isPointInPath(x, y)) {\n        var tooltip = RGraph.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: coords, 2: i, 'object': this, 'coords': segment, 'index': i, 'tooltip': tooltip };\n      }\n    }\n    return null;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      var coords = shape['coords'];pa2(co, 'b m % % l % % l % % l % % c s % f %', coords[0], coords[1], coords[2], coords[3], coords[4], coords[5], coords[6], coords[7], prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] && mouseXY[0] < ca.width - prop['chart.gutter.right'] && mouseXY[1] > prop['chart.gutter.top'] && mouseXY[1] < ca.height - prop['chart.gutter.bottom']) {\n      return this;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForHorizontalGradient(colors[i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForHorizontalGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForVerticalGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForHorizontalGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForHorizontalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.parseSingleColorForVerticalGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, prop['chart.gutter.top'], 0, ca.height - prop['chart.gutter.bottom']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RGraph.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];if (coords && coords.length == 8) {\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.beginPath();co.moveTo(coords[0], coords[1]);co.lineTo(coords[2], coords[3]);co.lineTo(coords[4], coords[5]);co.lineTo(coords[6], coords[7]);co.closePath();co.fill();co.stroke();co.lineWidth = pre_linewidth;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5mdW5uZWwuanM/ZWJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5GdW5uZWwgPSBmdW5jdGlvbiAoY29uZikge1xuICB2YXIgX3Byb3BlcnRpZXM7XG5cbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYuZGF0YSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpZCA9IGNvbmYuaWQ7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgZGF0YSA9IGNvbmYuZGF0YTt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZjt2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBkYXRhID0gYXJndW1lbnRzWzFdO1xuICB9XG4gIHRoaXMuaWQgPSBpZDt0aGlzLmNhbnZhcyA9IGNhbnZhczt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6ICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlkKSkgPT09ICdvYmplY3QnICYmIGlkLmFscGhhID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSB9KSA6IG51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ2Z1bm5lbCc7dGhpcy5jb29yZHMgPSBbXTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5vcmlnaW5hbF9jb2xvcnMgPSBbXTt0aGlzLmZpcnN0RHJhdyA9IHRydWU7aWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbRlVOTkVMXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjtcbiAgfVxuICB0aGlzLnByb3BlcnRpZXMgPSAoX3Byb3BlcnRpZXMgPSB7ICdjaGFydC5zdHJva2VzdHlsZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0Lmd1dHRlci5sZWZ0JzogMjUsICdjaGFydC5ndXR0ZXIucmlnaHQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci50b3AnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOiAyNSwgJ2NoYXJ0LmxhYmVscyc6IG51bGwsICdjaGFydC5sYWJlbHMuc3RpY2tzJzogZmFsc2UsICdjaGFydC5sYWJlbHMueCc6IG51bGwsICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC50aXRsZS5ocG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLngnOiBudWxsLCAnY2hhcnQudGl0bGUueSc6IG51bGwsICdjaGFydC50aXRsZS5oYWxpZ24nOiBudWxsLCAnY2hhcnQudGl0bGUudmFsaWduJzogbnVsbCwgJ2NoYXJ0LmNvbG9ycyc6IFsnR3JhZGllbnQod2hpdGU6cmVkKScsICdHcmFkaWVudCh3aGl0ZTpncmVlbiknLCAnR3JhZGllbnQod2hpdGU6Z3JheSknLCAnR3JhZGllbnQod2hpdGU6Ymx1ZSknLCAnR3JhZGllbnQod2hpdGU6YmxhY2spJywgJ0dyYWRpZW50KHdoaXRlOmdyYXkpJywgJ0dyYWRpZW50KHdoaXRlOnBpbmspJywgJ0dyYWRpZW50KHdoaXRlOmJsdWUpJywgJ0dyYWRpZW50KHdoaXRlOnllbGxvdyknLCAnR3JhZGllbnQod2hpdGU6Z3JlZW4pJywgJ0dyYWRpZW50KHdoaXRlOnJlZCknXSwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5ib3hlZCc6IHRydWUsICdjaGFydC50ZXh0LmhhbGlnbic6ICdsZWZ0JywgJ2NoYXJ0LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQuc2hhZG93JzogZmFsc2UsICdjaGFydC5zaGFkb3cuY29sb3InOiAnIzY2NicsICdjaGFydC5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDMsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDMsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOiAnYmxhY2snLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzogJ3JnYmEoMjU1LDAsMCwwLjIpJywgJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycsICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhY3RvcicsIDEuNSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uZmFkZS5pbicsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhZGUub3V0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uaGRpcicsICdyaWdodCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLnZkaXInLCAnZG93bicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZyYW1lcycsIDI1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5kZWxheScsIDE2LjY2NiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uc2hhZG93JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmFjdGlvbicsICd6b29tJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJlc2l6YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXZlbnRzLmNsaWNrJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuY2xlYXJ0bycsICdyZ2JhKDAsMCwwLDApJyksIF9wcm9wZXJ0aWVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgZGF0YVtpXSA9IHBhcnNlRmxvYXQoZGF0YVtpXSk7XG4gIH1cbiAgdGhpcy5kYXRhID0gZGF0YTtmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzWyckJyArIGldID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO1JHLkRyYXdUaXRsZSh0aGlzLCBwcm9wWydjaGFydC50aXRsZSddLCB0aGlzLmd1dHRlclRvcCwgbnVsbCwgcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddID8gcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyKTt0aGlzLkRyYXdGdW5uZWwoKTtpZiAocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSkge1xuICAgICAgUkcuU2hvd0NvbnRleHQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuRHJhd0xhYmVscygpO2lmIChwcm9wWydjaGFydC5yZXNpemFibGUnXSkge1xuICAgICAgUkcuQWxsb3dSZXNpemluZyh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0Z1bm5lbCA9IHRoaXMuRHJhd0Z1bm5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dmFyIGhlaWdodCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207dmFyIHRvdGFsID0gUkcuYXJyYXlfbWF4KHRoaXMuZGF0YSk7dmFyIGFjY2hlaWdodCA9IHRoaXMuZ3V0dGVyVG9wO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIgZmlyc3R2YWx1ZSA9IHRoaXMuZGF0YVswXTt2YXIgZmlyc3R3aWR0aCA9IGZpcnN0dmFsdWUgLyB0b3RhbCAqIHdpZHRoO3ZhciBjdXJ2YWx1ZSA9IHRoaXMuZGF0YVtpXTt2YXIgY3Vyd2lkdGggPSBjdXJ2YWx1ZSAvIHRvdGFsICogd2lkdGg7dmFyIGN1cmhlaWdodCA9IGhlaWdodCAvIHRoaXMuZGF0YS5sZW5ndGg7dmFyIGhhbGZDdXJXaWR0aCA9IGN1cndpZHRoIC8gMjt2YXIgbmV4dHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTt2YXIgbmV4dHdpZHRoID0gdGhpcy5kYXRhW2kgKyAxXSA/IG5leHR2YWx1ZSAvIHRvdGFsICogd2lkdGggOiBudWxsO3ZhciBoYWxmTmV4dFdpZHRoID0gbmV4dHdpZHRoIC8gMjt2YXIgY2VudGVyID0gdGhpcy5ndXR0ZXJMZWZ0ICsgZmlyc3R3aWR0aCAvIDI7dmFyIHgxID0gY2VudGVyIC0gaGFsZkN1cldpZHRoO3ZhciB5MSA9IGFjY2hlaWdodDt2YXIgeDIgPSBjZW50ZXIgKyBoYWxmQ3VyV2lkdGg7dmFyIHkyID0gYWNjaGVpZ2h0O3ZhciB4MyA9IGNlbnRlciArIGhhbGZOZXh0V2lkdGg7dmFyIHkzID0gYWNjaGVpZ2h0ICsgY3VyaGVpZ2h0O3ZhciB4NCA9IGNlbnRlciAtIGhhbGZOZXh0V2lkdGg7dmFyIHk0ID0gYWNjaGVpZ2h0ICsgY3VyaGVpZ2h0O2lmIChuZXh0d2lkdGggJiYgaSA8IHRoaXMuZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVtpXTtjby5tb3ZlVG8oeDEsIHkxKTtjby5saW5lVG8oeDIsIHkyKTtjby5saW5lVG8oeDMsIHkzKTtjby5saW5lVG8oeDQsIHk0KTtjby5jbG9zZVBhdGgoKTt0aGlzLmNvb3Jkcy5wdXNoKFt4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTRdKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgY28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjby5maWxsKCk7YWNjaGVpZ2h0ICs9IGN1cmhlaWdodDtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBSRy5Ob1NoYWRvdyh0aGlzKTtmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNvb3Jkc1tpXVswXSwgdGhpcy5jb29yZHNbaV1bMV0pO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVsyXSwgdGhpcy5jb29yZHNbaV1bM10pO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVs0XSwgdGhpcy5jb29yZHNbaV1bNV0pO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVs2XSwgdGhpcy5jb29yZHNbaV1bN10pO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmtleSddICYmIHByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCkge1xuICAgICAgUkcuRHJhd0tleSh0aGlzLCBwcm9wWydjaGFydC5rZXknXSwgcHJvcFsnY2hhcnQuY29sb3JzJ10pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscyddICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgY29sb3IgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107dmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscyddO3ZhciBoYWxpZ24gPSBwcm9wWydjaGFydC50ZXh0LmhhbGlnbiddID09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdjZW50ZXInO3ZhciBiZ2NvbG9yID0gcHJvcFsnY2hhcnQudGV4dC5ib3hlZCddID8gJ3doaXRlJyA6IG51bGw7aWYgKHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMueCddID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB4ID0gcHJvcFsnY2hhcnQubGFiZWxzLngnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gaGFsaWduID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCAtIDE1IDogKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvb3Jkcy5sZW5ndGg7ICsraikge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9ICdibGFjayc7Y28uZmlsbFN0eWxlID0gY29sb3I7UkcuTm9TaGFkb3codGhpcyk7dmFyIGxhYmVsID0gbGFiZWxzW2pdO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCwgJ3knOiB0aGlzLmNvb3Jkc1tqXVsxXSwgJ3RleHQnOiBsYWJlbCwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogaGFsaWduLCAnYm91bmRpbmcnOiBwcm9wWydjaGFydC50ZXh0LmJveGVkJ10sICdib3VuZGluZ0ZpbGwnOiBiZ2NvbG9yLCAndGFnJzogJ2xhYmVscycgfSk7aWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MnXSkge1xuICAgICAgICAgIGNvLmZvbnQgPSBzaXplICsgJ3B0ICcgKyBmb250O3ZhciBsYWJlbFdpZHRoID0gY28ubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ2dyYXknO2NvLm1vdmVUbyh4ICsgbGFiZWxXaWR0aCArIDEwLCBtYS5yb3VuZCh0aGlzLmNvb3Jkc1tqXVsxXSkpO2NvLmxpbmVUbyh0aGlzLmNvb3Jkc1tqXVswXSAtIDEwLCBtYS5yb3VuZCh0aGlzLmNvb3Jkc1tqXVsxXSkpO2NvLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbGFzdExhYmVsID0gbGFiZWxzW2pdO2lmIChsYXN0TGFiZWwpIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4LCAneSc6IHRoaXMuY29vcmRzW2ogLSAxXVs1XSwgJ3RleHQnOiBsYXN0TGFiZWwsICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGhhbGlnbiwgJ2JvdW5kaW5nJzogcHJvcFsnY2hhcnQudGV4dC5ib3hlZCddLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ3RhZyc6ICdsYWJlbHMnIH0pO2lmIChwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzJ10pIHtcbiAgICAgICAgICBjby5mb250ID0gc2l6ZSArICdwdCAnICsgZm9udDt2YXIgbGFiZWxXaWR0aCA9IGNvLm1lYXN1cmVUZXh0KGxhc3RMYWJlbCkud2lkdGg7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSAnZ3JheSc7Y28ubW92ZVRvKHggKyBsYWJlbFdpZHRoICsgMTAsIE1hdGgucm91bmQodGhpcy5jb29yZHNbaiAtIDFdWzddKSk7Y28ubGluZVRvKHRoaXMuY29vcmRzW2ogLSAxXVs2XSAtIDEwLCBNYXRoLnJvdW5kKHRoaXMuY29vcmRzW2ogLSAxXVs3XSkpO2NvLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldFNlZ21lbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBjb29yZHMgPSB0aGlzLmNvb3Jkczt2YXIgbW91c2VDb29yZHMgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciB4ID0gbW91c2VDb29yZHNbMF07dmFyIHkgPSBtb3VzZUNvb3Jkc1sxXTtmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gY29vcmRzW2ldO1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO2NvLmxpbmVUbyhzZWdtZW50WzJdLCBzZWdtZW50WzNdKTtjby5saW5lVG8oc2VnbWVudFs0XSwgc2VnbWVudFs1XSk7Y28ubGluZVRvKHNlZ21lbnRbNl0sIHNlZ21lbnRbN10pO2NvLmxpbmVUbyhzZWdtZW50WzhdLCBzZWdtZW50WzldKTtpZiAoY28uaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICB2YXIgdG9vbHRpcCA9IFJHcmFwaC5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGkpO3JldHVybiB7IDA6IHRoaXMsIDE6IGNvb3JkcywgMjogaSwgJ29iamVjdCc6IHRoaXMsICdjb29yZHMnOiBzZWdtZW50LCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmIChwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXShzaGFwZSk7cmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvb3JkcyA9IHNoYXBlWydjb29yZHMnXTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIGMgcyAlIGYgJScsIGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgY29vcmRzWzRdLCBjb29yZHNbNV0sIGNvb3Jkc1s2XSwgY29vcmRzWzddLCBwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10sIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO1xuICAgIH1cbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkdyYXBoLmdldE1vdXNlWFkoZSk7aWYgKG1vdXNlWFlbMF0gPiBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddICYmIG1vdXNlWFlbMF0gPCBjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddICYmIG1vdXNlWFlbMV0gPiBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gJiYgbW91c2VYWVsxXSA8IGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTtcbiAgICB9XG4gICAgdmFyIGNvbG9ycyA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddO2ZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JIb3Jpem9udGFsR3JhZGllbnQoY29sb3JzW2ldKTtcbiAgICB9XG4gICAgdmFyIGtleUNvbG9ycyA9IHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXTtpZiAoa2V5Q29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXlDb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JIb3Jpem9udGFsR3JhZGllbnQoa2V5Q29sb3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvclZlcnRpY2FsR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9ySG9yaXpvbnRhbEdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckhvcml6b250YWxHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9ySG9yaXpvbnRhbEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLCAwLCBjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLCAwKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkdyYXBoLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvclZlcnRpY2FsR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSwgMCwgY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkdyYXBoLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHNbaW5kZXhdO2lmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA9PSA4KSB7XG4gICAgICB2YXIgcHJlX2xpbmV3aWR0aCA9IGNvLmxpbmVXaWR0aDtjby5saW5lV2lkdGggPSAyO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oY29vcmRzWzBdLCBjb29yZHNbMV0pO2NvLmxpbmVUbyhjb29yZHNbMl0sIGNvb3Jkc1szXSk7Y28ubGluZVRvKGNvb3Jkc1s0XSwgY29vcmRzWzVdKTtjby5saW5lVG8oY29vcmRzWzZdLCBjb29yZHNbN10pO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGggPSBwcmVfbGluZXdpZHRoO1xuICAgIH1cbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguZnVubmVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///189\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gantt = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gantt';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.data = data;this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 7, 'chart.background.grid.autofit.numvlines': null, 'chart.vbars': [], 'chart.hbars': [], 'chart.text.size': 12, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.gutter.left': 75, 'chart.gutter.right': 25, 'chart.gutter.top': 35, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.align': 'bottom', 'chart.labels.inbar': null, 'chart.labels.inbar.color': 'black', 'chart.labels.inbar.bgcolor': null, 'chart.labels.inbar.align': 'left', 'chart.labels.inbar.size': 10, 'chart.labels.inbar.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.inbar.above': false, 'chart.labels.percent': true, 'chart.vmargin': 2, 'chart.title': '', 'chart.title.background': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.color': null, 'chart.title.yaxis.position': 'right', 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.bold': true, 'chart.title.xaxis.color': null }, _defineProperty(_properties, 'chart.title.x', null), _defineProperty(_properties, 'chart.title.y', null), _defineProperty(_properties, 'chart.title.halign', null), _defineProperty(_properties, 'chart.title.valign', null), _defineProperty(_properties, 'chart.borders', true), _defineProperty(_properties, 'chart.defaultcolor', 'white'), _defineProperty(_properties, 'chart.coords', []), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.xmax', 0), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!data) {\n    alert('[GANTT] The Gantt chart event data is now supplied as the second argument to the constructor - please update your code');\n  } else {\n    for (var i = 0, idx = 0; i < data.length; ++i) {\n      if (typeof data[i][0] === 'string') data[i][0] = parseFloat(data[i][0]);if (typeof data[i][1] === 'string') data[i][1] = parseFloat(data[i][1]);if (typeof data[i][2] === 'string') data[i][2] = parseFloat(data[i][2]);if (typeof data[i][7] === 'string') data[i][7] = parseFloat(data[i][7]);\n    }\n  }\n  for (var i = 0, idx = 0; i < data.length; ++i) {\n    if (RGraph.isArray(this.data[i][0])) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        this['$' + idx++] = {};\n      }\n    } else {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    if (name == 'chart.events') {\n      alert('[GANTT] The chart.events property is deprecated - supply the events data as an argument to the constructor instead');this.data = value;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.margin') {\n      name = 'chart.vmargin';\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coordsText = [];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.graphArea = ca.width - this.gutterLeft - this.gutterRight;this.graphHeight = ca.height - this.gutterTop - this.gutterBottom;this.numEvents = this.data.length;\n    this.barHeight = this.graphHeight / this.numEvents;this.halfBarHeight = this.barHeight / 2;RG.background.Draw(this);this.drawLabels();this.DrawEvents();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];var labelsColor = prop['chart.labels.color'] || prop['chart.text.color'];var labelSpace = this.graphArea / labels.length;var x = this.gutterLeft + labelSpace / 2;var y = this.gutterTop - prop['chart.text.size'] / 2 - 5;var font = prop['chart.text.font'];var size = prop['chart.text.size'];co.beginPath();co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';\n    if (prop['chart.labels.align'] == 'bottom') {\n      y = ca.height - this.gutterBottom + size + 2;\n    }\n    for (i = 0; i < labels.length; ++i) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': x + i * labelSpace, 'y': y, 'text': String(labels[i]), 'halign': 'center', 'valign': 'center', 'tag': 'labels.horizontal' });\n    }\n    for (var i = 0, len = this.data.length; i < len; ++i) {\n      var ev = this.data[i];var x = this.gutterLeft;var y = this.gutterTop + this.halfBarHeight + i * this.barHeight;co.fillStyle = labelsColor || prop['chart.text.color'];RG.text2(this, { 'font': font, 'size': size, 'x': x - 5, 'y': y, 'text': RG.isArray(ev[0]) ? ev[0][3] ? String(ev[0][3]) : '' : typeof ev[3] == 'string' ? ev[3] : '', 'halign': 'right', 'valign': 'center', 'tag': 'labels.vertical' });\n    }\n  };this.drawEvents = this.DrawEvents = function () {\n    var events = this.data;this.coords = [];if (prop['chart.vbars']) {\n      for (i = 0, len = prop['chart.vbars'].length; i < len; ++i) {\n        if (prop['chart.vbars'][i][0] + prop['chart.vbars'][i][1] > prop['chart.xmax']) {\n          prop['chart.vbars'][i][1] = 364 - prop['chart.vbars'][i][0];\n        }\n        var barX = this.gutterLeft + (prop['chart.vbars'][i][0] - prop['chart.xmin']) / (prop['chart.xmax'] - prop['chart.xmin']) * this.graphArea;var barY = this.gutterTop;var width = this.graphArea / (prop['chart.xmax'] - prop['chart.xmin']) * prop['chart.vbars'][i][1];var height = ca.height - this.gutterTop - this.gutterBottom;if (barX + width > ca.width - this.gutterRight) {\n          width = ca.width - this.gutterRight - barX;\n        }\n        co.fillStyle = prop['chart.vbars'][i][2];co.fillRect(barX, barY, width, height);\n      }\n    }\n    if (prop['chart.hbars']) {\n      for (i = 0, len = prop['chart.hbars'].length; i < len; ++i) {\n        if (prop['chart.hbars'][i]) {\n          var barX = this.gutterLeft,\n              barY = (ca.height - this.gutterTop - this.gutterBottom) / this.data.length * i + this.gutterTop,\n              width = this.graphArea,\n              height = this.barHeight;\n          co.fillStyle = prop['chart.hbars'][i];co.fillRect(barX, barY, width, height);\n        }\n      }\n    }\n    var sequentialIndex = 0;for (i = 0; i < events.length; ++i) {\n      if (typeof events[i][0] == 'number') {\n        this.DrawSingleEvent(events[i], i, sequentialIndex++);\n      } else {\n        for (var j = 0; j < events[i].length; ++j) {\n          var subindex = j;this.DrawSingleEvent(events[i][j], i, sequentialIndex++, subindex);\n        }\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    e = RG.fixEventObject(e);var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);var ret = { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: this.coords[i][4].index, subindex: this.coords[i][4] && typeof this.coords[i][4].subindex === 'number' ? this.coords[i][4].subindex : null, sequentialIndex: this.coords[i][5], tooltip: tooltip };return ret;\n      }\n    }\n  };this.drawSingleEvent = this.DrawSingleEvent = function (ev, index, sequentialIndex) {\n    ev.index = index;if (typeof arguments[3] === 'number') {\n      ev.subindex = arguments[3];\n    }\n    var min = prop['chart.xmin'];co.beginPath();co.strokeStyle = 'black';co.fillStyle = ev[4] ? ev[4] : prop['chart.defaultcolor'];var barStartX = this.gutterLeft + (ev[0] - min) / (prop['chart.xmax'] - min) * this.graphArea;var barStartY = this.gutterTop + index * this.barHeight;var barWidth = ev[1] / (prop['chart.xmax'] - min) * this.graphArea;if (barStartX + barWidth > ca.width - this.gutterRight) {\n      barWidth = ca.width - this.gutterRight - barStartX;\n    }\n    this.coords.push([barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin'], ev, sequentialIndex]);if (prop['chart.borders'] || ev[6]) {\n      co.strokeStyle = typeof ev[6] == 'string' ? ev[6] : 'black';co.lineWidth = typeof ev[7] == 'number' ? ev[7] : 1;co.beginPath();co.strokeRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);\n    }\n    co.beginPath();co.fillRect(barStartX, barStartY + prop['chart.vmargin'], barWidth, this.barHeight - 2 * prop['chart.vmargin']);co.fill();var complete = ev[2] / 100 * barWidth;if (typeof ev[2] == 'number') {\n      co.beginPath();co.fillStyle = ev[5] ? ev[5] : '#0c0';co.fillRect(barStartX, barStartY + prop['chart.vmargin'], ev[2] / 100 * barWidth, this.barHeight - 2 * prop['chart.vmargin']);if (prop['chart.labels.percent']) {\n        co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': barStartX + barWidth + 5, 'y': barStartY + this.halfBarHeight, 'text': String(ev[2]) + '%', 'valign': 'center', 'tag': 'labels.complete' });\n      }\n    }\n    if (prop['chart.labels.inbar'] && prop['chart.labels.inbar'][sequentialIndex]) {\n      var label = String(prop['chart.labels.inbar'][sequentialIndex]);var halign = prop['chart.labels.inbar.align'] == 'left' ? 'left' : 'center';halign = prop['chart.labels.inbar.align'] == 'right' ? 'right' : halign;if (halign == 'right') {\n        var x = barStartX + barWidth - 5;\n      } else if (halign == 'center') {\n        var x = barStartX + barWidth / 2;\n      } else {\n        var x = barStartX + 5;\n      }\n      if (prop['chart.labels.inbar.above']) {\n        x = barStartX + barWidth + 5;halign = 'left';\n      }\n      co.fillStyle = prop['chart.labels.inbar.color'];RG.text2(this, { 'font': prop['chart.labels.inbar.font'], 'size': prop['chart.labels.inbar.size'], 'x': x, 'y': barStartY + this.halfBarHeight, 'text': label, 'valign': 'center', 'halign': halign, 'bounding': typeof prop['chart.labels.inbar.bgcolor'] == 'string', 'boundingFill': typeof prop['chart.labels.inbar.bgcolor'] == 'string' ? prop['chart.labels.inbar.bgcolor'] : null, 'tag': 'labels.inbar' });\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var bar = RG.Registry.get('chart.adjusting.gantt');if (bar) {\n        var mouseXY = RG.getMouseXY(e),\n            obj = RG.Registry.get('chart.adjusting.gantt')['object'],\n            index = bar['index'],\n            subindex = bar['subindex'],\n            diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'],\n            eventStart = RG.Registry.get('chart.adjusting.gantt')['event_start'],\n            duration = RG.Registry.get('chart.adjusting.gantt')['event_duration'],\n            event = typeof subindex === 'number' ? obj.data[index][subindex] : obj.data[index];\n        if (bar['mode'] == 'move') {\n          diff = ma.round(diff);if (RG.isNull(subindex)) {\n            event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              obj.data[index][0] = 0;\n            } else if (eventStart + diff + obj.data[index][1] > prop['chart.xmax']) {\n              obj.data[index][0] = prop['chart.xmax'] - obj.data[index][1];\n            }\n          } else {\n            var index = RG.Registry.get('chart.adjusting.gantt').index;var subindex = RG.Registry.get('chart.adjusting.gantt').subindex;var event = this.data[index][subindex];event[0] = eventStart + diff;if (eventStart + diff < 0) {\n              event[0] = 0;\n            } else if (eventStart + diff + event[1] > prop['chart.xmax']) {\n              event[0] = prop['chart.xmax'] - event[1];\n            }\n          }\n        } else if (bar['mode'] == 'resize') {\n          if (mouseXY[0] > ca.width - obj.gutterRight) {\n            mouseXY[0] = ca.width - obj.gutterRight;\n          }\n          var diff = (mouseXY[0] - RG.Registry.get('chart.adjusting.gantt')['mousex']) / (ca.width - obj.gutterLeft - obj.gutterRight) * prop['chart.xmax'];diff = ma.round(diff);if (RG.isNull(subindex)) {\n            obj.data[index][1] = duration + diff;if (obj.data[index][1] < 0) {\n              obj.data[index][1] = 1;\n            }\n          } else {\n            obj.data[index][subindex][1] = duration + diff;if (obj.data[index][subindex][1] < 0) {\n              obj.data[index][subindex][1] = 1;\n            }\n          }\n        }\n        RG.resetColorsToOriginalValues(this);RG.redrawCanvas(ca);RG.fireCustomEvent(obj, 'onadjust');\n      }\n    }\n  };this.getXCoord = function (value) {\n    var min = prop['chart.xmin'];var max = prop['chart.xmax'];var graphArea = ca.width - this.gutterLeft - this.gutterRight;if (value > max || value < min) {\n      return null;\n    }\n    var x = (value - min) / (max - min) * graphArea + this.gutterLeft;return x;\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseXY = arg;\n    } else {\n      var mouseXY = RGraph.getMouseXY(arg);\n    }\n    var mouseX = mouseXY[0];var mouseY = mouseXY[1];var value = (mouseX - this.gutterLeft) / (ca.width - this.gutterLeft - this.gutterRight);value *= prop['chart.xmax'] - prop['chart.xmin'];if (value < prop['chart.xmin'] || value > prop['chart.xmax']) {\n      value = null;\n    }\n    return value;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.arrayClone(this.data);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i) {\n      if (_typeof(this.data[i][0]) == 'object' && typeof this.data[i][0][0] === 'number') {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1, sequentialIndex += 1) {\n          this.data[i][j][4] = this.parseSingleColorForGradient(this.data[i][j][4], { start: this.data[i][j][0], duration: this.data[i][j][1] });this.data[i][j][5] = this.parseSingleColorForGradient(this.data[i][j][5], { start: this.data[i][j][0], duration: this.data[i][j][1] });\n        }\n      } else {\n        if (typeof this.data[i][4] == 'string') this.data[i][4] = this.parseSingleColorForGradient(this.data[i][4], { start: this.data[i][0], duration: this.data[i][1] });if (typeof this.data[i][5] == 'string') this.data[i][5] = this.parseSingleColorForGradient(this.data[i][5], { start: this.data[i][0], duration: this.data[i][1] });++sequentialIndex;\n      }\n    }\n    prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var opts = arguments[1] || {};if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var value = opts.start + opts.duration > prop['chart.xmax'] ? prop['chart.xmax'] : opts.start + opts.duration;var grad = co.createLinearGradient(typeof opts.start === 'number' ? this.getXCoord(opts.start) : this.gutterLeft, 0, typeof opts.start === 'number' ? this.getXCoord(value) : ca.width - this.gutterRight, 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] ? arguments[1] : function () {};var canvas = obj.canvas;var context = obj.context;var numFrames = opt.frames || 30;var frame = 0;var original_events = RG.arrayClone(obj.data);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= numFrames) {\n        for (var i = 0, len = obj.data.length; i < len; ++i) {\n          if (_typeof(obj.data[i][0]) === 'object') {\n            for (var j = 0; j < obj.data[i].length; ++j) {\n              obj.data[i][j][1] = frame / numFrames * original_events[i][j][1];\n            }\n          } else {\n            obj.data[i][1] = frame / numFrames * original_events[i][1];\n          }\n        }\n        obj.reset();frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0; i < this.original_colors['data'].length; ++i) {\n      if (this.original_colors['data'][i][4]) {\n        this.data[i][4] = RG.arrayClone(this.original_colors['data'][i][4]);\n      }\n      if (this.original_colors['data'][i][5]) {\n        this.data[i][5] = RG.arrayClone(this.original_colors['data'][i][5]);\n      }\n      if (_typeof(this.original_colors['data'][i][0]) === 'object' && typeof this.original_colors['data'][i][0][0] === 'number') {\n        for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n          this.data[i][j][4] = RG.arrayClone(this.original_colors['data'][i][j][4]);this.data[i][j][5] = RG.arrayClone(this.original_colors['data'][i][j][5]);\n        }\n      }\n    }\n  };this.reset = function () {\n    this.resetColorsToOriginalValues();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.coords = [];\n  };this.sequentialIndex2Grouped = function () {\n    alert('[RGRAPH] Please post in the forum if you see this alert');\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    } else if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.sequentialIndex]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5nYW50dC5qcz9kMDQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkdhbnR0ID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgdmFyIF9wcm9wZXJ0aWVzO1xuXG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihjb25mLmRhdGEpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGEgPSBjb25mLmRhdGE7dmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZCA9IGNvbmY7dmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBjYW52YXM7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCA/IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpZCkpID09PSAnb2JqZWN0JyAmJiBpZC5hbHBoYSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUgfSkgOiBudWxsO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMudHlwZSA9ICdnYW50dCc7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy51aWQgPSBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkID0gdGhpcy5jYW52YXMudWlkID8gdGhpcy5jYW52YXMudWlkIDogUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuZGF0YSA9IGRhdGE7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnByb3BlcnRpZXMgPSAoX3Byb3BlcnRpZXMgPSB7ICdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCc6IDEsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InOiAnI2RkZCcsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnOiAyMCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6IDIwLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmhsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQuYWxpZ24nOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzogNywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6IG51bGwsICdjaGFydC52YmFycyc6IFtdLCAnY2hhcnQuaGJhcnMnOiBbXSwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5ndXR0ZXIubGVmdCc6IDc1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMzUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMjUsICdjaGFydC5sYWJlbHMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5jb2xvcic6IG51bGwsICdjaGFydC5sYWJlbHMuYWxpZ24nOiAnYm90dG9tJywgJ2NoYXJ0LmxhYmVscy5pbmJhcic6IG51bGwsICdjaGFydC5sYWJlbHMuaW5iYXIuY29sb3InOiAnYmxhY2snLCAnY2hhcnQubGFiZWxzLmluYmFyLmJnY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzLmluYmFyLmFsaWduJzogJ2xlZnQnLCAnY2hhcnQubGFiZWxzLmluYmFyLnNpemUnOiAxMCwgJ2NoYXJ0LmxhYmVscy5pbmJhci5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC5sYWJlbHMuaW5iYXIuYWJvdmUnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5wZXJjZW50JzogdHJ1ZSwgJ2NoYXJ0LnZtYXJnaW4nOiAyLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcyc6ICcnLCAnY2hhcnQudGl0bGUueWF4aXMuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS55YXhpcy5wb3MnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMuY29sb3InOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMucG9zaXRpb24nOiAncmlnaHQnLCAnY2hhcnQudGl0bGUueWF4aXMueCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzogbnVsbCB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50aXRsZS54JywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRpdGxlLnknLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudGl0bGUuaGFsaWduJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRpdGxlLnZhbGlnbicsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ib3JkZXJzJywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmRlZmF1bHRjb2xvcicsICd3aGl0ZScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jb29yZHMnLCBbXSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCcsICdmYWRlJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcycsICdSR3JhcGhfdG9vbHRpcCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnLCAnb25jbGljaycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJywgJ3JnYmEoMCwwLDAsMCknKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnLCAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnhtaW4nLCAwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueG1heCcsIDApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jb250ZXh0bWVudScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hbm5vdGF0YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InLCAnYmxhY2snKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5mYWN0b3InLCAxLjUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhZGUuaW4nLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5mYWRlLm91dCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmhkaXInLCAncmlnaHQnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS52ZGlyJywgJ2Rvd24nKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5mcmFtZXMnLCAyNSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uZGVsYXknLCAxNi42NjYpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLnNoYWRvdycsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmJhY2tncm91bmQnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5hY3Rpb24nLCAnem9vbScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5yZXNpemFibGUnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JywgWzAsIDBdKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFkanVzdGFibGUnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFkanVzdGFibGUub25seScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMuY2xpY2snLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jbGVhcnRvJywgJ3JnYmEoMCwwLDAsMCknKSwgX3Byb3BlcnRpZXMpO1xuICBpZiAoIWRhdGEpIHtcbiAgICBhbGVydCgnW0dBTlRUXSBUaGUgR2FudHQgY2hhcnQgZXZlbnQgZGF0YSBpcyBub3cgc3VwcGxpZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IgLSBwbGVhc2UgdXBkYXRlIHlvdXIgY29kZScpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBpZHggPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldWzBdID09PSAnc3RyaW5nJykgZGF0YVtpXVswXSA9IHBhcnNlRmxvYXQoZGF0YVtpXVswXSk7aWYgKHR5cGVvZiBkYXRhW2ldWzFdID09PSAnc3RyaW5nJykgZGF0YVtpXVsxXSA9IHBhcnNlRmxvYXQoZGF0YVtpXVsxXSk7aWYgKHR5cGVvZiBkYXRhW2ldWzJdID09PSAnc3RyaW5nJykgZGF0YVtpXVsyXSA9IHBhcnNlRmxvYXQoZGF0YVtpXVsyXSk7aWYgKHR5cGVvZiBkYXRhW2ldWzddID09PSAnc3RyaW5nJykgZGF0YVtpXVs3XSA9IHBhcnNlRmxvYXQoZGF0YVtpXVs3XSk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBpZHggPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChSR3JhcGguaXNBcnJheSh0aGlzLmRhdGFbaV1bMF0pKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICB0aGlzWyckJyArIGlkeCsrXSA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzWyckJyArIGlkeCsrXSA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubWFyZ2luJykge1xuICAgICAgbmFtZSA9ICdjaGFydC52bWFyZ2luJztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LmV2ZW50cycpIHtcbiAgICAgIGFsZXJ0KCdbR0FOVFRdIFRoZSBjaGFydC5ldmVudHMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCAtIHN1cHBseSB0aGUgZXZlbnRzIGRhdGEgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQnKTt0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0Lm1hcmdpbicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQudm1hcmdpbic7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jb29yZHNUZXh0ID0gW107aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5ncmFwaEFyZWEgPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5udW1FdmVudHMgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIHRoaXMuYmFySGVpZ2h0ID0gdGhpcy5ncmFwaEhlaWdodCAvIHRoaXMubnVtRXZlbnRzO3RoaXMuaGFsZkJhckhlaWdodCA9IHRoaXMuYmFySGVpZ2h0IC8gMjtSRy5iYWNrZ3JvdW5kLkRyYXcodGhpcyk7dGhpcy5kcmF3TGFiZWxzKCk7dGhpcy5EcmF3RXZlbnRzKCk7aWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscyddO3ZhciBsYWJlbHNDb2xvciA9IHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddIHx8IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgbGFiZWxTcGFjZSA9IHRoaXMuZ3JhcGhBcmVhIC8gbGFiZWxzLmxlbmd0aDt2YXIgeCA9IHRoaXMuZ3V0dGVyTGVmdCArIGxhYmVsU3BhY2UgLyAyO3ZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgLSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAvIDIgLSA1O3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMuYWxpZ24nXSA9PSAnYm90dG9tJykge1xuICAgICAgeSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgc2l6ZSArIDI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCArIGkgKiBsYWJlbFNwYWNlLCAneSc6IHksICd0ZXh0JzogU3RyaW5nKGxhYmVsc1tpXSksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ2xhYmVscy5ob3Jpem9udGFsJyB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIGV2ID0gdGhpcy5kYXRhW2ldO3ZhciB4ID0gdGhpcy5ndXR0ZXJMZWZ0O3ZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZCYXJIZWlnaHQgKyBpICogdGhpcy5iYXJIZWlnaHQ7Y28uZmlsbFN0eWxlID0gbGFiZWxzQ29sb3IgfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCAtIDUsICd5JzogeSwgJ3RleHQnOiBSRy5pc0FycmF5KGV2WzBdKSA/IGV2WzBdWzNdID8gU3RyaW5nKGV2WzBdWzNdKSA6ICcnIDogdHlwZW9mIGV2WzNdID09ICdzdHJpbmcnID8gZXZbM10gOiAnJywgJ2hhbGlnbic6ICdyaWdodCcsICd2YWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdsYWJlbHMudmVydGljYWwnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdFdmVudHMgPSB0aGlzLkRyYXdFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZGF0YTt0aGlzLmNvb3JkcyA9IFtdO2lmIChwcm9wWydjaGFydC52YmFycyddKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9wWydjaGFydC52YmFycyddLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC52YmFycyddW2ldWzBdICsgcHJvcFsnY2hhcnQudmJhcnMnXVtpXVsxXSA+IHByb3BbJ2NoYXJ0LnhtYXgnXSkge1xuICAgICAgICAgIHByb3BbJ2NoYXJ0LnZiYXJzJ11baV1bMV0gPSAzNjQgLSBwcm9wWydjaGFydC52YmFycyddW2ldWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXJYID0gdGhpcy5ndXR0ZXJMZWZ0ICsgKHByb3BbJ2NoYXJ0LnZiYXJzJ11baV1bMF0gLSBwcm9wWydjaGFydC54bWluJ10pIC8gKHByb3BbJ2NoYXJ0LnhtYXgnXSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgKiB0aGlzLmdyYXBoQXJlYTt2YXIgYmFyWSA9IHRoaXMuZ3V0dGVyVG9wO3ZhciB3aWR0aCA9IHRoaXMuZ3JhcGhBcmVhIC8gKHByb3BbJ2NoYXJ0LnhtYXgnXSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgKiBwcm9wWydjaGFydC52YmFycyddW2ldWzFdO3ZhciBoZWlnaHQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tO2lmIChiYXJYICsgd2lkdGggPiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQpIHtcbiAgICAgICAgICB3aWR0aCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIGJhclg7XG4gICAgICAgIH1cbiAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudmJhcnMnXVtpXVsyXTtjby5maWxsUmVjdChiYXJYLCBiYXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmhiYXJzJ10pIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3BbJ2NoYXJ0LmhiYXJzJ10ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmhiYXJzJ11baV0pIHtcbiAgICAgICAgICB2YXIgYmFyWCA9IHRoaXMuZ3V0dGVyTGVmdCxcbiAgICAgICAgICAgICAgYmFyWSA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIHRoaXMuZGF0YS5sZW5ndGggKiBpICsgdGhpcy5ndXR0ZXJUb3AsXG4gICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5ncmFwaEFyZWEsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuYmFySGVpZ2h0O1xuICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmhiYXJzJ11baV07Y28uZmlsbFJlY3QoYmFyWCwgYmFyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlcXVlbnRpYWxJbmRleCA9IDA7Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiBldmVudHNbaV1bMF0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5EcmF3U2luZ2xlRXZlbnQoZXZlbnRzW2ldLCBpLCBzZXF1ZW50aWFsSW5kZXgrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV2ZW50c1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzdWJpbmRleCA9IGo7dGhpcy5EcmF3U2luZ2xlRXZlbnQoZXZlbnRzW2ldW2pdLCBpLCBzZXF1ZW50aWFsSW5kZXgrKywgc3ViaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldEJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSA9IFJHLmZpeEV2ZW50T2JqZWN0KGUpO3ZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5jb29yZHNbaV1bMF0sXG4gICAgICAgICAgdG9wID0gdGhpcy5jb29yZHNbaV1bMV0sXG4gICAgICAgICAgd2lkdGggPSB0aGlzLmNvb3Jkc1tpXVsyXSxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvb3Jkc1tpXVszXTtpZiAobW91c2VYID49IGxlZnQgJiYgbW91c2VYIDw9IGxlZnQgKyB3aWR0aCAmJiBtb3VzZVkgPj0gdG9wICYmIG1vdXNlWSA8PSB0b3AgKyBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGkpO3ZhciByZXQgPSB7IDA6IHRoaXMsIG9iamVjdDogdGhpcywgMTogbGVmdCwgeDogbGVmdCwgMjogdG9wLCB5OiB0b3AsIDM6IHdpZHRoLCB3aWR0aDogd2lkdGgsIDQ6IGhlaWdodCwgaGVpZ2h0OiBoZWlnaHQsIDU6IGksIGluZGV4OiB0aGlzLmNvb3Jkc1tpXVs0XS5pbmRleCwgc3ViaW5kZXg6IHRoaXMuY29vcmRzW2ldWzRdICYmIHR5cGVvZiB0aGlzLmNvb3Jkc1tpXVs0XS5zdWJpbmRleCA9PT0gJ251bWJlcicgPyB0aGlzLmNvb3Jkc1tpXVs0XS5zdWJpbmRleCA6IG51bGwsIHNlcXVlbnRpYWxJbmRleDogdGhpcy5jb29yZHNbaV1bNV0sIHRvb2x0aXA6IHRvb2x0aXAgfTtyZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdTaW5nbGVFdmVudCA9IHRoaXMuRHJhd1NpbmdsZUV2ZW50ID0gZnVuY3Rpb24gKGV2LCBpbmRleCwgc2VxdWVudGlhbEluZGV4KSB7XG4gICAgZXYuaW5kZXggPSBpbmRleDtpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGV2LnN1YmluZGV4ID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgICB2YXIgbWluID0gcHJvcFsnY2hhcnQueG1pbiddO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztjby5maWxsU3R5bGUgPSBldls0XSA/IGV2WzRdIDogcHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ107dmFyIGJhclN0YXJ0WCA9IHRoaXMuZ3V0dGVyTGVmdCArIChldlswXSAtIG1pbikgLyAocHJvcFsnY2hhcnQueG1heCddIC0gbWluKSAqIHRoaXMuZ3JhcGhBcmVhO3ZhciBiYXJTdGFydFkgPSB0aGlzLmd1dHRlclRvcCArIGluZGV4ICogdGhpcy5iYXJIZWlnaHQ7dmFyIGJhcldpZHRoID0gZXZbMV0gLyAocHJvcFsnY2hhcnQueG1heCddIC0gbWluKSAqIHRoaXMuZ3JhcGhBcmVhO2lmIChiYXJTdGFydFggKyBiYXJXaWR0aCA+IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCkge1xuICAgICAgYmFyV2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSBiYXJTdGFydFg7XG4gICAgfVxuICAgIHRoaXMuY29vcmRzLnB1c2goW2JhclN0YXJ0WCwgYmFyU3RhcnRZICsgcHJvcFsnY2hhcnQudm1hcmdpbiddLCBiYXJXaWR0aCwgdGhpcy5iYXJIZWlnaHQgLSAyICogcHJvcFsnY2hhcnQudm1hcmdpbiddLCBldiwgc2VxdWVudGlhbEluZGV4XSk7aWYgKHByb3BbJ2NoYXJ0LmJvcmRlcnMnXSB8fCBldls2XSkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSB0eXBlb2YgZXZbNl0gPT0gJ3N0cmluZycgPyBldls2XSA6ICdibGFjayc7Y28ubGluZVdpZHRoID0gdHlwZW9mIGV2WzddID09ICdudW1iZXInID8gZXZbN10gOiAxO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVJlY3QoYmFyU3RhcnRYLCBiYXJTdGFydFkgKyBwcm9wWydjaGFydC52bWFyZ2luJ10sIGJhcldpZHRoLCB0aGlzLmJhckhlaWdodCAtIDIgKiBwcm9wWydjaGFydC52bWFyZ2luJ10pO1xuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5maWxsUmVjdChiYXJTdGFydFgsIGJhclN0YXJ0WSArIHByb3BbJ2NoYXJ0LnZtYXJnaW4nXSwgYmFyV2lkdGgsIHRoaXMuYmFySGVpZ2h0IC0gMiAqIHByb3BbJ2NoYXJ0LnZtYXJnaW4nXSk7Y28uZmlsbCgpO3ZhciBjb21wbGV0ZSA9IGV2WzJdIC8gMTAwICogYmFyV2lkdGg7aWYgKHR5cGVvZiBldlsyXSA9PSAnbnVtYmVyJykge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gZXZbNV0gPyBldls1XSA6ICcjMGMwJztjby5maWxsUmVjdChiYXJTdGFydFgsIGJhclN0YXJ0WSArIHByb3BbJ2NoYXJ0LnZtYXJnaW4nXSwgZXZbMl0gLyAxMDAgKiBiYXJXaWR0aCwgdGhpcy5iYXJIZWlnaHQgLSAyICogcHJvcFsnY2hhcnQudm1hcmdpbiddKTtpZiAocHJvcFsnY2hhcnQubGFiZWxzLnBlcmNlbnQnXSkge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAneCc6IGJhclN0YXJ0WCArIGJhcldpZHRoICsgNSwgJ3knOiBiYXJTdGFydFkgKyB0aGlzLmhhbGZCYXJIZWlnaHQsICd0ZXh0JzogU3RyaW5nKGV2WzJdKSArICclJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ2xhYmVscy5jb21wbGV0ZScgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMuaW5iYXInXSAmJiBwcm9wWydjaGFydC5sYWJlbHMuaW5iYXInXVtzZXF1ZW50aWFsSW5kZXhdKSB7XG4gICAgICB2YXIgbGFiZWwgPSBTdHJpbmcocHJvcFsnY2hhcnQubGFiZWxzLmluYmFyJ11bc2VxdWVudGlhbEluZGV4XSk7dmFyIGhhbGlnbiA9IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5hbGlnbiddID09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdjZW50ZXInO2hhbGlnbiA9IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5hbGlnbiddID09ICdyaWdodCcgPyAncmlnaHQnIDogaGFsaWduO2lmIChoYWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICB2YXIgeCA9IGJhclN0YXJ0WCArIGJhcldpZHRoIC0gNTtcbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciB4ID0gYmFyU3RhcnRYICsgYmFyV2lkdGggLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBiYXJTdGFydFggKyA1O1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5hYm92ZSddKSB7XG4gICAgICAgIHggPSBiYXJTdGFydFggKyBiYXJXaWR0aCArIDU7aGFsaWduID0gJ2xlZnQnO1xuICAgICAgfVxuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmNvbG9yJ107UkcudGV4dDIodGhpcywgeyAnZm9udCc6IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmJhci5mb250J10sICdzaXplJzogcHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLnNpemUnXSwgJ3gnOiB4LCAneSc6IGJhclN0YXJ0WSArIHRoaXMuaGFsZkJhckhlaWdodCwgJ3RleHQnOiBsYWJlbCwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogaGFsaWduLCAnYm91bmRpbmcnOiB0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmJnY29sb3InXSA9PSAnc3RyaW5nJywgJ2JvdW5kaW5nRmlsbCc6IHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuaW5iYXIuYmdjb2xvciddID09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQubGFiZWxzLmluYmFyLmJnY29sb3InXSA6IG51bGwsICd0YWcnOiAnbGFiZWxzLmluYmFyJyB9KTtcbiAgICB9XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlJlY3QodGhpcywgc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTtpZiAobW91c2VYWVswXSA+IHRoaXMuZ3V0dGVyTGVmdCAmJiBtb3VzZVhZWzBdIDwgY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICYmIG1vdXNlWFlbMV0gPiB0aGlzLmd1dHRlclRvcCAmJiBtb3VzZVhZWzFdIDwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdmFyIGJhciA9IFJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuYWRqdXN0aW5nLmdhbnR0Jyk7aWYgKGJhcikge1xuICAgICAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgICAgICBvYmogPSBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpWydvYmplY3QnXSxcbiAgICAgICAgICAgIGluZGV4ID0gYmFyWydpbmRleCddLFxuICAgICAgICAgICAgc3ViaW5kZXggPSBiYXJbJ3N1YmluZGV4J10sXG4gICAgICAgICAgICBkaWZmID0gKG1vdXNlWFlbMF0gLSBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZy5nYW50dCcpWydtb3VzZXgnXSkgLyAoY2Eud2lkdGggLSBvYmouZ3V0dGVyTGVmdCAtIG9iai5ndXR0ZXJSaWdodCkgKiBwcm9wWydjaGFydC54bWF4J10sXG4gICAgICAgICAgICBldmVudFN0YXJ0ID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKVsnZXZlbnRfc3RhcnQnXSxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKVsnZXZlbnRfZHVyYXRpb24nXSxcbiAgICAgICAgICAgIGV2ZW50ID0gdHlwZW9mIHN1YmluZGV4ID09PSAnbnVtYmVyJyA/IG9iai5kYXRhW2luZGV4XVtzdWJpbmRleF0gOiBvYmouZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChiYXJbJ21vZGUnXSA9PSAnbW92ZScpIHtcbiAgICAgICAgICBkaWZmID0gbWEucm91bmQoZGlmZik7aWYgKFJHLmlzTnVsbChzdWJpbmRleCkpIHtcbiAgICAgICAgICAgIGV2ZW50WzBdID0gZXZlbnRTdGFydCArIGRpZmY7aWYgKGV2ZW50U3RhcnQgKyBkaWZmIDwgMCkge1xuICAgICAgICAgICAgICBvYmouZGF0YVtpbmRleF1bMF0gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFN0YXJ0ICsgZGlmZiArIG9iai5kYXRhW2luZGV4XVsxXSA+IHByb3BbJ2NoYXJ0LnhtYXgnXSkge1xuICAgICAgICAgICAgICBvYmouZGF0YVtpbmRleF1bMF0gPSBwcm9wWydjaGFydC54bWF4J10gLSBvYmouZGF0YVtpbmRleF1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IFJHLlJlZ2lzdHJ5LmdldCgnY2hhcnQuYWRqdXN0aW5nLmdhbnR0JykuaW5kZXg7dmFyIHN1YmluZGV4ID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKS5zdWJpbmRleDt2YXIgZXZlbnQgPSB0aGlzLmRhdGFbaW5kZXhdW3N1YmluZGV4XTtldmVudFswXSA9IGV2ZW50U3RhcnQgKyBkaWZmO2lmIChldmVudFN0YXJ0ICsgZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgZXZlbnRbMF0gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFN0YXJ0ICsgZGlmZiArIGV2ZW50WzFdID4gcHJvcFsnY2hhcnQueG1heCddKSB7XG4gICAgICAgICAgICAgIGV2ZW50WzBdID0gcHJvcFsnY2hhcnQueG1heCddIC0gZXZlbnRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJhclsnbW9kZSddID09ICdyZXNpemUnKSB7XG4gICAgICAgICAgaWYgKG1vdXNlWFlbMF0gPiBjYS53aWR0aCAtIG9iai5ndXR0ZXJSaWdodCkge1xuICAgICAgICAgICAgbW91c2VYWVswXSA9IGNhLndpZHRoIC0gb2JqLmd1dHRlclJpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGlmZiA9IChtb3VzZVhZWzBdIC0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcuZ2FudHQnKVsnbW91c2V4J10pIC8gKGNhLndpZHRoIC0gb2JqLmd1dHRlckxlZnQgLSBvYmouZ3V0dGVyUmlnaHQpICogcHJvcFsnY2hhcnQueG1heCddO2RpZmYgPSBtYS5yb3VuZChkaWZmKTtpZiAoUkcuaXNOdWxsKHN1YmluZGV4KSkge1xuICAgICAgICAgICAgb2JqLmRhdGFbaW5kZXhdWzFdID0gZHVyYXRpb24gKyBkaWZmO2lmIChvYmouZGF0YVtpbmRleF1bMV0gPCAwKSB7XG4gICAgICAgICAgICAgIG9iai5kYXRhW2luZGV4XVsxXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iai5kYXRhW2luZGV4XVtzdWJpbmRleF1bMV0gPSBkdXJhdGlvbiArIGRpZmY7aWYgKG9iai5kYXRhW2luZGV4XVtzdWJpbmRleF1bMV0gPCAwKSB7XG4gICAgICAgICAgICAgIG9iai5kYXRhW2luZGV4XVtzdWJpbmRleF1bMV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXModGhpcyk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5maXJlQ3VzdG9tRXZlbnQob2JqLCAnb25hZGp1c3QnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRYQ29vcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgbWluID0gcHJvcFsnY2hhcnQueG1pbiddO3ZhciBtYXggPSBwcm9wWydjaGFydC54bWF4J107dmFyIGdyYXBoQXJlYSA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDtpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgeCA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSAqIGdyYXBoQXJlYSArIHRoaXMuZ3V0dGVyTGVmdDtyZXR1cm4geDtcbiAgfTt0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChhcmcubGVuZ3RoID09IDIpIHtcbiAgICAgIHZhciBtb3VzZVhZID0gYXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW91c2VYWSA9IFJHcmFwaC5nZXRNb3VzZVhZKGFyZyk7XG4gICAgfVxuICAgIHZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO3ZhciB2YWx1ZSA9IChtb3VzZVggLSB0aGlzLmd1dHRlckxlZnQpIC8gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCk7dmFsdWUgKj0gcHJvcFsnY2hhcnQueG1heCddIC0gcHJvcFsnY2hhcnQueG1pbiddO2lmICh2YWx1ZSA8IHByb3BbJ2NoYXJ0LnhtaW4nXSB8fCB2YWx1ZSA+IHByb3BbJ2NoYXJ0LnhtYXgnXSkge1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddID0gUkcuYXJyYXlDbG9uZSh0aGlzLmRhdGEpO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmRlZmF1bHRjb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBzZXF1ZW50aWFsSW5kZXggPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoX3R5cGVvZih0aGlzLmRhdGFbaV1bMF0pID09ICdvYmplY3QnICYmIHR5cGVvZiB0aGlzLmRhdGFbaV1bMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSB0aGlzLmRhdGFbaV0ubGVuZ3RoOyBqIDwgbGVuOyBqICs9IDEsIHNlcXVlbnRpYWxJbmRleCArPSAxKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW2ldW2pdWzRdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldW2pdWzRdLCB7IHN0YXJ0OiB0aGlzLmRhdGFbaV1bal1bMF0sIGR1cmF0aW9uOiB0aGlzLmRhdGFbaV1bal1bMV0gfSk7dGhpcy5kYXRhW2ldW2pdWzVdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldW2pdWzVdLCB7IHN0YXJ0OiB0aGlzLmRhdGFbaV1bal1bMF0sIGR1cmF0aW9uOiB0aGlzLmRhdGFbaV1bal1bMV0gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldWzRdID09ICdzdHJpbmcnKSB0aGlzLmRhdGFbaV1bNF0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCh0aGlzLmRhdGFbaV1bNF0sIHsgc3RhcnQ6IHRoaXMuZGF0YVtpXVswXSwgZHVyYXRpb246IHRoaXMuZGF0YVtpXVsxXSB9KTtpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVs1XSA9PSAnc3RyaW5nJykgdGhpcy5kYXRhW2ldWzVdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2ldWzVdLCB7IHN0YXJ0OiB0aGlzLmRhdGFbaV1bMF0sIGR1cmF0aW9uOiB0aGlzLmRhdGFbaV1bMV0gfSk7KytzZXF1ZW50aWFsSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTtwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmRlZmF1bHRjb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgdmFsdWUgPSBvcHRzLnN0YXJ0ICsgb3B0cy5kdXJhdGlvbiA+IHByb3BbJ2NoYXJ0LnhtYXgnXSA/IHByb3BbJ2NoYXJ0LnhtYXgnXSA6IG9wdHMuc3RhcnQgKyBvcHRzLmR1cmF0aW9uO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQodHlwZW9mIG9wdHMuc3RhcnQgPT09ICdudW1iZXInID8gdGhpcy5nZXRYQ29vcmQob3B0cy5zdGFydCkgOiB0aGlzLmd1dHRlckxlZnQsIDAsIHR5cGVvZiBvcHRzLnN0YXJ0ID09PSAnbnVtYmVyJyA/IHRoaXMuZ2V0WENvb3JkKHZhbHVlKSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgMCk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTt2YXIgY2FudmFzID0gb2JqLmNhbnZhczt2YXIgY29udGV4dCA9IG9iai5jb250ZXh0O3ZhciBudW1GcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIG9yaWdpbmFsX2V2ZW50cyA9IFJHLmFycmF5Q2xvbmUob2JqLmRhdGEpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSA8PSBudW1GcmFtZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2Yob2JqLmRhdGFbaV1bMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmouZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBvYmouZGF0YVtpXVtqXVsxXSA9IGZyYW1lIC8gbnVtRnJhbWVzICogb3JpZ2luYWxfZXZlbnRzW2ldW2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmouZGF0YVtpXVsxXSA9IGZyYW1lIC8gbnVtRnJhbWVzICogb3JpZ2luYWxfZXZlbnRzW2ldWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmoucmVzZXQoKTtmcmFtZSsrO1JHcmFwaC5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bNF0pIHtcbiAgICAgICAgdGhpcy5kYXRhW2ldWzRdID0gUkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzRdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzVdKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpXVs1XSA9IFJHLmFycmF5Q2xvbmUodGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVs1XSk7XG4gICAgICB9XG4gICAgICBpZiAoX3R5cGVvZih0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldWzBdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXS5sZW5ndGg7IGogPCBsZW4yOyArK2opIHtcbiAgICAgICAgICB0aGlzLmRhdGFbaV1bal1bNF0gPSBSRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bal1bNF0pO3RoaXMuZGF0YVtpXVtqXVs1XSA9IFJHLmFycmF5Q2xvbmUodGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVtqXVs1XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcygpO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5vcmlnaW5hbF9jb2xvcnMgPSBbXTt0aGlzLmZpcnN0RHJhdyA9IHRydWU7dGhpcy5jb29yZHMgPSBbXTtcbiAgfTt0aGlzLnNlcXVlbnRpYWxJbmRleDJHcm91cGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGFsZXJ0KCdbUkdSQVBIXSBQbGVhc2UgcG9zdCBpbiB0aGUgZm9ydW0gaWYgeW91IHNlZSB0aGlzIGFsZXJ0Jyk7XG4gIH07dGhpcy5pc0FkanVzdGFibGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChSRy5pc0FycmF5KHByb3BbJ2NoYXJ0LmFkanVzdGFibGUub25seSddKSAmJiBwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXVtzaGFwZS5zZXF1ZW50aWFsSW5kZXhdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5nYW50dC5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///190\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Gauge = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'gauge';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;if (_typeof(this.value) == 'object') {\n    for (var i = 0; i < this.value.length; ++i) {\n      if (this.value[i] > this.max) this.value[i] = max;if (this.value[i] < this.min) this.value[i] = min;\n    }\n  } else {\n    if (this.value > this.max) this.value = max;if (this.value < this.min) this.value = min;\n  }\n  this.properties = { 'chart.angles.start': null, 'chart.angles.end': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 15, 'chart.border.width': 10, 'chart.title.top': '', 'chart.title.top.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.top.size': 14, 'chart.title.top.color': '#333', 'chart.title.top.bold': false, 'chart.title.top.pos': null, 'chart.title.bottom': '', 'chart.title.bottom.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.bottom.size': 14, 'chart.title.bottom.color': '#333', 'chart.title.bottom.bold': false, 'chart.title.bottom.pos': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': '#666', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.background.color': 'white', 'chart.background.gradient': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.units.pre': '', 'chart.units.post': '', 'chart.value.text': false, 'chart.value.text.y.pos': 0.5, 'chart.value.text.units.pre': null, 'chart.value.text.units.post': null, 'chart.value.text.color': 'black', 'chart.value.text.bounding': true, 'chart.value.text.bounding.fill': 'white', 'chart.value.text.bounding.stroke': 'black', 'chart.red.start': 0.9 * this.max, 'chart.red.color': '#DC3912', 'chart.red.width': 10, 'chart.yellow.color': '#FF9900', 'chart.yellow.width': 10, 'chart.green.end': 0.7 * this.max, 'chart.green.color': 'rgba(0,0,0,0)', 'chart.green.width': 10, 'chart.colors.ranges': null, 'chart.needle.size': null, 'chart.needle.tail': false, 'chart.needle.colors': ['#D5604D', 'red', 'green', 'yellow'], 'chart.needle.type': 'triangle', 'chart.needle.width': 7, 'chart.border.outer': '#ccc', 'chart.border.inner': '#f1f1f1', 'chart.border.outline': 'black', 'chart.centerpin.color': 'blue', 'chart.centerpin.radius': null, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.tickmarks.small': 25, 'chart.tickmarks.small.color': 'black', 'chart.tickmarks.medium': 0, 'chart.tickmarks.medium.color': 'black', 'chart.tickmarks.big': 5, 'chart.tickmarks.big.color': 'black', 'chart.labels.count': 5, 'chart.labels.centered': false, 'chart.labels.offset.radius': 0, 'chart.labels.offset.angle': 0, 'chart.labels.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.border.gradient': false, 'chart.adjustable': false, 'chart.shadow': true, 'chart.shadow.color': 'gray', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.title') name = 'chart.title.top';if (name == 'chart.title.font') name = 'chart.title.top.font';if (name == 'chart.title.size') name = 'chart.title.top.size';if (name == 'chart.title.color') name = 'chart.title.top.color';if (name == 'chart.title.bold') name = 'chart.title.top.bold';if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.color') {\n      name = 'chart.needle.colors';\n    }\n    if (name == 'chart.labels.offset') {\n      name = 'chart.labels.offset.radius';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2);this.startAngle = prop['chart.angles.start'] ? prop['chart.angles.start'] : RG.HALFPI / 3 + RG.HALFPI;this.endAngle = prop['chart.angles.end'] ? prop['chart.angles.end'] : RG.TWOPI + RG.HALFPI - RG.HALFPI / 3;this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.centerpinRadius = 0.16 * this.radius;if (typeof prop['chart.centerpin.radius'] == 'number') {\n      this.centerpinRadius = prop['chart.centerpin.radius'];\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.DrawBackGround();this.DrawGradient();this.DrawColorBands();this.DrawSmallTickmarks();this.DrawMediumTickmarks();this.DrawBigTickmarks();this.DrawLabels();this.DrawTopTitle();this.DrawBottomTitle();if (_typeof(this.value) == 'object') {\n      for (var i = 0; i < this.value.length; ++i) {\n        this.DrawNeedle(this.value[i], prop['chart.needle.colors'][i], i);\n      }\n    } else {\n      this.DrawNeedle(this.value, prop['chart.needle.colors'][0], 0);\n    }\n    this.DrawCenterpin();if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackGround = this.DrawBackGround = function () {\n    if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);var grad = co.createRadialGradient(this.centerx + 50, this.centery - 50, 0, this.centerx + 50, this.centery - 50, 150);grad.addColorStop(0, '#eee');grad.addColorStop(1, 'white');var borderWidth = prop['chart.border.width'];co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.outer'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.border.inner'];co.arc(this.centerx, this.centery, this.radius - borderWidth, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();if (prop['chart.background.gradient']) {\n      co.beginPath();co.fillStyle = RG.RadialGradient(this, this.centerx, this.centery, 0, this.centerx, this.centery, this.radius, 'rgba(255,255,255,0.6)', 'rgba(255,255,255,0.1)');co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);co.fill();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.border.outline'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);co.stroke();\n  };this.drawSmallTickmarks = this.DrawSmallTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.small'];co.lineWidth = 1;for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 5, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawMediumTickmarks = this.DrawMediumTickmarks = function () {\n    if (prop['chart.tickmarks.medium']) {\n      var numTicks = prop['chart.tickmarks.medium'];co.lineWidth = 3;co.lineCap = 'round';co.strokeStyle = prop['chart.tickmarks.medium.color'];for (var i = 0; i <= numTicks; ++i) {\n        co.beginPath();var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle + (this.endAngle - this.startAngle) / (2 * numTicks);if (a > this.startAngle && a < this.endAngle) {\n          co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 6, a, a + 0.00001, 0);\n        }\n        co.stroke();\n      }\n    }\n  };this.drawBigTickmarks = this.DrawBigTickmarks = function () {\n    var numTicks = prop['chart.tickmarks.big'];co.lineWidth = 3;co.lineCap = 'round';for (var i = 0; i <= numTicks; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];var a = (this.endAngle - this.startAngle) / numTicks * i + this.startAngle;co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 10, a, a + 0.00001, 0);co.stroke();\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    var offset = 6;var grad = co.createRadialGradient(this.centerx + offset, this.centery - offset, 0, this.centerx + offset, this.centery - offset, 25);grad.addColorStop(0, '#ddf');grad.addColorStop(1, prop['chart.centerpin.color']);co.beginPath();co.fillStyle = grad;co.arc(this.centerx, this.centery, this.centerpinRadius, 0, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        num = prop['chart.labels.specific'] ? prop['chart.labels.specific'].length - 1 : prop['chart.labels.count'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'],\n        offseta = prop['chart.labels.offset.angle'];\n    co.beginPath();if (num) {\n      for (var i = 0; i <= num; ++i) {\n        var hyp = this.radius - 25 - prop['chart.border.width'] - prop['chart.labels.offset.radius'];var a = (this.endAngle - this.startAngle) / num;\n        a = this.startAngle + i * a;a -= RG.HALFPI;a += offseta;var x = this.centerx - ma.sin(a) * hyp;var y = this.centery + ma.cos(a) * hyp;var hAlign = x > this.centerx ? 'right' : 'left';var vAlign = y > this.centery ? 'bottom' : 'top';if (a == RG.HALFPI) {\n          vAlign = 'center';\n        } else if (a == RG.PI) {\n          hAlign = 'center';\n        } else if (a == RG.HALFPI + RG.PI) {\n          vAlign = 'center';\n        }\n        if (prop['chart.labels.centered']) {\n          hAlign = 'center';vAlign = 'center';\n        }\n        var value = (this.max - this.min) * (i / num) + this.min;RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': prop['chart.labels.specific'] ? prop['chart.labels.specific'][i] : RG.numberFormat(this, value.toFixed(value === 0 ? 0 : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), 'halign': hAlign, 'valign': vAlign, 'tag': prop['chart.labels.specific'] ? 'labels.specific' : 'labels' });\n      }\n    }\n    co.fill();if (prop['chart.value.text']) {\n      var x = this.centerx;var y = this.centery + prop['chart.value.text.y.pos'] * this.radius;var units_pre = typeof prop['chart.value.text.units.pre'] == 'string' ? prop['chart.value.text.units.pre'] : prop['chart.units.pre'];var units_post = typeof prop['chart.value.text.units.post'] == 'string' ? prop['chart.value.text.units.post'] : prop['chart.units.post'];var color = prop['chart.value.text.color'];var bounding = prop['chart.value.text.bounding'];var boundingFill = prop['chart.value.text.bounding.fill'];var boundingStroke = prop['chart.value.text.bounding.stroke'];co.fillStyle = color;RG.text2(this, { 'font': font, 'size': size + 2, 'x': x, 'y': y, 'text': RG.numberFormat(this, this.value.toFixed(prop['chart.value.text.decimals']), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'bounding': bounding, 'bounding.fill': boundingFill, 'bounding.stroke': boundingStroke, 'tag': 'value.text' });\n    }\n  };this.drawTopTitle = this.DrawTopTitle = function () {\n    var x = this.centerx;var y = this.centery - 25;if (typeof prop['chart.title.top.pos'] == 'number') {\n      y = this.centery - this.radius * prop['chart.title.top.pos'];\n    }\n    if (prop['chart.title.top']) {\n      co.fillStyle = prop['chart.title.top.color'];RG.Text2(this, { 'font': prop['chart.title.top.font'], 'size': prop['chart.title.top.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.top']), 'halign': 'center', 'valign': 'bottom', 'bold': prop['chart.title.top.bold'], 'tag': 'title.top' });\n    }\n  };this.drawBottomTitle = this.DrawBottomTitle = function () {\n    var x = this.centerx;var y = this.centery + this.centerpinRadius + 10;if (typeof prop['chart.title.bottom.pos'] == 'number') {\n      y = this.centery + this.radius * prop['chart.title.bottom.pos'];\n    }\n    if (prop['chart.title.bottom']) {\n      co.fillStyle = prop['chart.title.bottom.color'];RG.Text2(this, { 'font': prop['chart.title.bottom.font'], 'size': prop['chart.title.bottom.size'], 'x': x, 'y': y, 'text': String(prop['chart.title.bottom']), 'halign': 'center', 'valign': 'top', 'bold': prop['chart.title.bottom.bold'], 'tag': 'title.bottom' });\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color, index) {\n    var type = prop['chart.needle.type'];co.lineWidth = 0.5;co.strokeStyle = 'gray';co.fillStyle = color;var angle = (this.endAngle - this.startAngle) * ((value - this.min) / (this.max - this.min));angle += this.startAngle;if (_typeof(prop['chart.needle.size']) == 'object' && prop['chart.needle.size'] && typeof prop['chart.needle.size'][index] == 'number') {\n      var size = prop['chart.needle.size'][index];\n    } else if (typeof prop['chart.needle.size'] == 'number') {\n      var size = prop['chart.needle.size'];\n    } else {\n      var size = this.radius - 25 - prop['chart.border.width'];\n    }\n    if (type == 'line') {\n      co.beginPath();co.lineWidth = prop['chart.needle.width'];co.strokeStyle = color;co.arc(this.centerx, this.centery, size, angle, angle + 0.0001, false);co.lineTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.lineTo(this.centerx, this.centery);co.stroke();\n    } else {\n      co.beginPath();co.arc(this.centerx, this.centery, size, angle, angle + 0.00001, false);co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle + RG.HALFPI, angle + 0.00001 + RG.HALFPI, false);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, this.radius * 0.2, angle + RG.PI, angle + 0.00001 + RG.PI, false);\n      }\n      co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle - RG.HALFPI, angle - 0.00001 - RG.HALFPI, false);co.stroke();co.fill();this.angle = angle;\n    }\n  };this.drawColorBands = this.DrawColorBands = function () {\n    if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.fillStyle = ranges[i][2];co.lineWidth = 0;co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, false);co.arc(this.centerx, this.centery, this.radius - 20 - prop['chart.border.width'], (ranges[i][1] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, (ranges[i][0] - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle, true);co.closePath();co.fill();\n      }\n      return;\n    }\n    co.strokeStyle = prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];var greenStart = this.startAngle;var greenEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.green.end'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], greenStart, greenEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.green.width']) - prop['chart.border.width'], greenEnd, greenStart, true);co.fill();co.strokeStyle = prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];var yellowStart = greenEnd;var yellowEnd = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.red.start'] - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], yellowStart, yellowEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.yellow.width']) - prop['chart.border.width'], yellowEnd, yellowStart, true);co.fill();co.strokeStyle = prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];var redStart = yellowEnd;var redEnd = this.startAngle + (this.endAngle - this.startAngle) * ((this.max - this.min) / (this.max - this.min));\n    co.beginPath();co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], redStart, redEnd, false);co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.red.width']) - prop['chart.border.width'], redEnd, redStart, true);co.fill();\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle >= 0 && angle <= RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - this.startAngle) / (this.endAngle - this.startAngle) * (this.max - this.min);value = value + this.min;if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius) {\n      return this;\n    }\n  };this.drawGradient = this.DrawGradient = function () {\n    if (prop['chart.border.gradient']) {\n      co.beginPath();var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius - 15);grad.addColorStop(0, 'gray');grad.addColorStop(1, 'white');co.fillStyle = grad;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);\n      co.arc(this.centerx, this.centery, this.radius - 15, RG.TWOPI, 0, true);\n      co.fill();\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (this.endAngle - this.startAngle) + this.startAngle;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.border.inner'] = RG.array_clone(prop['chart.border.inner']);this.original_colors['chart.border.outer'] = RG.array_clone(prop['chart.border.outer']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);this.original_colors['chart.needle.colors'] = RG.array_clone(prop['chart.needle.colors']);\n    }\n    prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.border.inner'] = this.parseSingleColorForGradient(prop['chart.border.inner']);prop['chart.border.outer'] = this.parseSingleColorForGradient(prop['chart.border.outer']);if (prop['chart.colors.ranges']) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2], this.radius - 30);\n      }\n    }\n    if (prop['chart.needle.colors']) {\n      var colors = prop['chart.needle.colors'];for (var i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    var radiusStart = arguments[1] || 0;if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, radiusStart, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames || 30;var frame = 0;if (typeof obj.value === 'number') {\n      var origValue = Number(obj.currentValue);if (obj.currentValue == null) {\n        obj.currentValue = obj.min;origValue = obj.min;\n      }\n      var newValue = obj.value;var diff = newValue - origValue;var iterator = function iterator() {\n        obj.value = frame / frames * diff + origValue;if (obj.value > obj.max) obj.value = obj.max;if (obj.value < obj.min) obj.value = obj.min;RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    } else {\n      if (obj.currentValue == null) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = obj.min;\n        }\n        origValue = RG.array_clone(obj.currentValue);\n      }\n      var origValue = RG.array_clone(obj.currentValue);var newValue = RG.array_clone(obj.value);var diff = [];for (var i = 0, len = newValue.length; i < len; ++i) {\n        diff[i] = newValue[i] - Number(obj.currentValue[i]);\n      }\n      var iterator = function iterator() {\n        frame++;for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.value[i] = frame / frames * diff[i] + origValue[i];if (obj.value[i] > obj.max) obj.value[i] = obj.max;if (obj.value[i] < obj.min) obj.value[i] = obj.min;\n        }\n        RG.redrawCanvas(obj.canvas);if (frame < frames) {\n          RG.Effects.updateCanvas(iterator);\n        } else {\n          callback(obj);\n        }\n      };iterator();\n    }\n    return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5nYXVnZS5qcz82MDllIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkdhdWdlID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbiA9IGNvbmYubWluO3ZhciBtYXggPSBjb25mLm1heDt2YXIgdmFsdWUgPSBjb25mLnZhbHVlO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbiA9IGFyZ3VtZW50c1sxXTt2YXIgbWF4ID0gYXJndW1lbnRzWzJdO3ZhciB2YWx1ZSA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBjYW52YXM7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCA/IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpZCkpID09PSAnb2JqZWN0JyAmJiBpZC5hbHBoYSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUgfSkgOiBudWxsO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMudHlwZSA9ICdnYXVnZSc7dGhpcy5taW4gPSBSR3JhcGguc3RyaW5nc1RvTnVtYmVycyhtaW4pO3RoaXMubWF4ID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnModmFsdWUpO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMuY3VycmVudFZhbHVlID0gbnVsbDt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTtpZiAoX3R5cGVvZih0aGlzLnZhbHVlKSA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMudmFsdWVbaV0gPiB0aGlzLm1heCkgdGhpcy52YWx1ZVtpXSA9IG1heDtpZiAodGhpcy52YWx1ZVtpXSA8IHRoaXMubWluKSB0aGlzLnZhbHVlW2ldID0gbWluO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy52YWx1ZSA+IHRoaXMubWF4KSB0aGlzLnZhbHVlID0gbWF4O2lmICh0aGlzLnZhbHVlIDwgdGhpcy5taW4pIHRoaXMudmFsdWUgPSBtaW47XG4gIH1cbiAgdGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuYW5nbGVzLnN0YXJ0JzogbnVsbCwgJ2NoYXJ0LmFuZ2xlcy5lbmQnOiBudWxsLCAnY2hhcnQuY2VudGVyeCc6IG51bGwsICdjaGFydC5jZW50ZXJ5JzogbnVsbCwgJ2NoYXJ0LnJhZGl1cyc6IG51bGwsICdjaGFydC5ndXR0ZXIubGVmdCc6IDE1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMTUsICdjaGFydC5ndXR0ZXIudG9wJzogMTUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMTUsICdjaGFydC5ib3JkZXIud2lkdGgnOiAxMCwgJ2NoYXJ0LnRpdGxlLnRvcCc6ICcnLCAnY2hhcnQudGl0bGUudG9wLmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRpdGxlLnRvcC5zaXplJzogMTQsICdjaGFydC50aXRsZS50b3AuY29sb3InOiAnIzMzMycsICdjaGFydC50aXRsZS50b3AuYm9sZCc6IGZhbHNlLCAnY2hhcnQudGl0bGUudG9wLnBvcyc6IG51bGwsICdjaGFydC50aXRsZS5ib3R0b20nOiAnJywgJ2NoYXJ0LnRpdGxlLmJvdHRvbS5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50aXRsZS5ib3R0b20uc2l6ZSc6IDE0LCAnY2hhcnQudGl0bGUuYm90dG9tLmNvbG9yJzogJyMzMzMnLCAnY2hhcnQudGl0bGUuYm90dG9tLmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LnRpdGxlLmJvdHRvbS5wb3MnOiBudWxsLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmNvbG9yJzogJyM2NjYnLCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6ICd3aGl0ZScsICdjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50JzogZmFsc2UsICdjaGFydC5zY2FsZS5kZWNpbWFscyc6IDAsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQudW5pdHMucHJlJzogJycsICdjaGFydC51bml0cy5wb3N0JzogJycsICdjaGFydC52YWx1ZS50ZXh0JzogZmFsc2UsICdjaGFydC52YWx1ZS50ZXh0LnkucG9zJzogMC41LCAnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnOiBudWxsLCAnY2hhcnQudmFsdWUudGV4dC51bml0cy5wb3N0JzogbnVsbCwgJ2NoYXJ0LnZhbHVlLnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZyc6IHRydWUsICdjaGFydC52YWx1ZS50ZXh0LmJvdW5kaW5nLmZpbGwnOiAnd2hpdGUnLCAnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZy5zdHJva2UnOiAnYmxhY2snLCAnY2hhcnQucmVkLnN0YXJ0JzogMC45ICogdGhpcy5tYXgsICdjaGFydC5yZWQuY29sb3InOiAnI0RDMzkxMicsICdjaGFydC5yZWQud2lkdGgnOiAxMCwgJ2NoYXJ0LnllbGxvdy5jb2xvcic6ICcjRkY5OTAwJywgJ2NoYXJ0LnllbGxvdy53aWR0aCc6IDEwLCAnY2hhcnQuZ3JlZW4uZW5kJzogMC43ICogdGhpcy5tYXgsICdjaGFydC5ncmVlbi5jb2xvcic6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmdyZWVuLndpZHRoJzogMTAsICdjaGFydC5jb2xvcnMucmFuZ2VzJzogbnVsbCwgJ2NoYXJ0Lm5lZWRsZS5zaXplJzogbnVsbCwgJ2NoYXJ0Lm5lZWRsZS50YWlsJzogZmFsc2UsICdjaGFydC5uZWVkbGUuY29sb3JzJzogWycjRDU2MDREJywgJ3JlZCcsICdncmVlbicsICd5ZWxsb3cnXSwgJ2NoYXJ0Lm5lZWRsZS50eXBlJzogJ3RyaWFuZ2xlJywgJ2NoYXJ0Lm5lZWRsZS53aWR0aCc6IDcsICdjaGFydC5ib3JkZXIub3V0ZXInOiAnI2NjYycsICdjaGFydC5ib3JkZXIuaW5uZXInOiAnI2YxZjFmMScsICdjaGFydC5ib3JkZXIub3V0bGluZSc6ICdibGFjaycsICdjaGFydC5jZW50ZXJwaW4uY29sb3InOiAnYmx1ZScsICdjaGFydC5jZW50ZXJwaW4ucmFkaXVzJzogbnVsbCwgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6IHRydWUsICdjaGFydC56b29tLmFjdGlvbic6ICd6b29tJywgJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbCc6IDI1LCAnY2hhcnQudGlja21hcmtzLnNtYWxsLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRpY2ttYXJrcy5tZWRpdW0nOiAwLCAnY2hhcnQudGlja21hcmtzLm1lZGl1bS5jb2xvcic6ICdibGFjaycsICdjaGFydC50aWNrbWFya3MuYmlnJzogNSwgJ2NoYXJ0LnRpY2ttYXJrcy5iaWcuY29sb3InOiAnYmxhY2snLCAnY2hhcnQubGFiZWxzLmNvdW50JzogNSwgJ2NoYXJ0LmxhYmVscy5jZW50ZXJlZCc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLm9mZnNldC5yYWRpdXMnOiAwLCAnY2hhcnQubGFiZWxzLm9mZnNldC5hbmdsZSc6IDAsICdjaGFydC5sYWJlbHMuc3BlY2lmaWMnOiBudWxsLCAnY2hhcnQubGFiZWxzLm9mZnNldHgnOiAwLCAnY2hhcnQubGFiZWxzLm9mZnNldHknOiAwLCAnY2hhcnQuYm9yZGVyLmdyYWRpZW50JzogZmFsc2UsICdjaGFydC5hZGp1c3RhYmxlJzogZmFsc2UsICdjaGFydC5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ2dyYXknLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAwLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAwLCAnY2hhcnQuc2hhZG93LmJsdXInOiAxNSwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnRpdGxlJykgbmFtZSA9ICdjaGFydC50aXRsZS50b3AnO2lmIChuYW1lID09ICdjaGFydC50aXRsZS5mb250JykgbmFtZSA9ICdjaGFydC50aXRsZS50b3AuZm9udCc7aWYgKG5hbWUgPT0gJ2NoYXJ0LnRpdGxlLnNpemUnKSBuYW1lID0gJ2NoYXJ0LnRpdGxlLnRvcC5zaXplJztpZiAobmFtZSA9PSAnY2hhcnQudGl0bGUuY29sb3InKSBuYW1lID0gJ2NoYXJ0LnRpdGxlLnRvcC5jb2xvcic7aWYgKG5hbWUgPT0gJ2NoYXJ0LnRpdGxlLmJvbGQnKSBuYW1lID0gJ2NoYXJ0LnRpdGxlLnRvcC5ib2xkJztpZiAobmFtZSA9PSAnY2hhcnQubmVlZGxlLmNvbG9yJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5uZWVkbGUuY29sb3JzJztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LmxhYmVscy5vZmZzZXQnKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LmxhYmVscy5vZmZzZXQucmFkaXVzJztcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0Lm5lZWRsZS5jb2xvcicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQubmVlZGxlLmNvbG9ycyc7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5sYWJlbHMub2Zmc2V0Jykge1xuICAgICAgbmFtZSA9ICdjaGFydC5sYWJlbHMub2Zmc2V0LnJhZGl1cyc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTt0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmNlbnRlcnggPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDIgKyB0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5ID0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiArIHRoaXMuZ3V0dGVyVG9wO3RoaXMucmFkaXVzID0gTWF0aC5taW4oKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyLCAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyKTt0aGlzLnN0YXJ0QW5nbGUgPSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSA/IHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddIDogUkcuSEFMRlBJIC8gMyArIFJHLkhBTEZQSTt0aGlzLmVuZEFuZ2xlID0gcHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddID8gcHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIDogUkcuVFdPUEkgKyBSRy5IQUxGUEkgLSBSRy5IQUxGUEkgLyAzO3RoaXMuY29vcmRzVGV4dCA9IFtdO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeCddID09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT0gJ251bWJlcicpIHRoaXMuY2VudGVyeSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY2VudGVycGluUmFkaXVzID0gMC4xNiAqIHRoaXMucmFkaXVzO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVycGluLnJhZGl1cyddID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNlbnRlcnBpblJhZGl1cyA9IHByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5yYWRpdXMnXTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLkRyYXdCYWNrR3JvdW5kKCk7dGhpcy5EcmF3R3JhZGllbnQoKTt0aGlzLkRyYXdDb2xvckJhbmRzKCk7dGhpcy5EcmF3U21hbGxUaWNrbWFya3MoKTt0aGlzLkRyYXdNZWRpdW1UaWNrbWFya3MoKTt0aGlzLkRyYXdCaWdUaWNrbWFya3MoKTt0aGlzLkRyYXdMYWJlbHMoKTt0aGlzLkRyYXdUb3BUaXRsZSgpO3RoaXMuRHJhd0JvdHRvbVRpdGxlKCk7aWYgKF90eXBlb2YodGhpcy52YWx1ZSkgPT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLkRyYXdOZWVkbGUodGhpcy52YWx1ZVtpXSwgcHJvcFsnY2hhcnQubmVlZGxlLmNvbG9ycyddW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5EcmF3TmVlZGxlKHRoaXMudmFsdWUsIHByb3BbJ2NoYXJ0Lm5lZWRsZS5jb2xvcnMnXVswXSwgMCk7XG4gICAgfVxuICAgIHRoaXMuRHJhd0NlbnRlcnBpbigpO2lmIChwcm9wWydjaGFydC5yZXNpemFibGUnXSkge1xuICAgICAgUkcuQWxsb3dSZXNpemluZyh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0JhY2tHcm91bmQgPSB0aGlzLkRyYXdCYWNrR3JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcuU2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIDAsIFJHLlRXT1BJLCAwKTtjby5maWxsKCk7UkcuTm9TaGFkb3codGhpcyk7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcnggKyA1MCwgdGhpcy5jZW50ZXJ5IC0gNTAsIDAsIHRoaXMuY2VudGVyeCArIDUwLCB0aGlzLmNlbnRlcnkgLSA1MCwgMTUwKTtncmFkLmFkZENvbG9yU3RvcCgwLCAnI2VlZScpO2dyYWQuYWRkQ29sb3JTdG9wKDEsICd3aGl0ZScpO3ZhciBib3JkZXJXaWR0aCA9IHByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzLCAwLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJvcmRlci5vdXRlciddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIDAsIFJHLlRXT1BJLCAwKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ107Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIGJvcmRlcldpZHRoLCAwLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gYm9yZGVyV2lkdGggLSA0LCAwLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gYm9yZGVyV2lkdGggLSA0LCAwLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO2lmIChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyYWRpZW50J10pIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IFJHLlJhZGlhbEdyYWRpZW50KHRoaXMsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAwLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsICdyZ2JhKDI1NSwyNTUsMjU1LDAuNiknLCAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIGJvcmRlcldpZHRoIC0gNCwgMCwgUkcuVFdPUEksIDApO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5ib3JkZXIub3V0bGluZSddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIDAsIFJHLlRXT1BJLCAwKTtjby5zdHJva2UoKTtcbiAgfTt0aGlzLmRyYXdTbWFsbFRpY2ttYXJrcyA9IHRoaXMuRHJhd1NtYWxsVGlja21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBudW1UaWNrcyA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5zbWFsbCddO2NvLmxpbmVXaWR0aCA9IDE7Zm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtVGlja3M7ICsraSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC50aWNrbWFya3Muc21hbGwuY29sb3InXTt2YXIgYSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAvIG51bVRpY2tzICogaSArIHRoaXMuc3RhcnRBbmdsZTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10gLSAxMCwgYSwgYSArIDAuMDAwMDEsIDApO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSAtIDEwIC0gNSwgYSwgYSArIDAuMDAwMDEsIDApO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdNZWRpdW1UaWNrbWFya3MgPSB0aGlzLkRyYXdNZWRpdW1UaWNrbWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5tZWRpdW0nXSkge1xuICAgICAgdmFyIG51bVRpY2tzID0gcHJvcFsnY2hhcnQudGlja21hcmtzLm1lZGl1bSddO2NvLmxpbmVXaWR0aCA9IDM7Y28ubGluZUNhcCA9ICdyb3VuZCc7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC50aWNrbWFya3MubWVkaXVtLmNvbG9yJ107Zm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtVGlja3M7ICsraSkge1xuICAgICAgICBjby5iZWdpblBhdGgoKTt2YXIgYSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAvIG51bVRpY2tzICogaSArIHRoaXMuc3RhcnRBbmdsZSArICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAvICgyICogbnVtVGlja3MpO2lmIChhID4gdGhpcy5zdGFydEFuZ2xlICYmIGEgPCB0aGlzLmVuZEFuZ2xlKSB7XG4gICAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddIC0gMTAsIGEsIGEgKyAwLjAwMDAxLCAwKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10gLSAxMCAtIDYsIGEsIGEgKyAwLjAwMDAxLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3QmlnVGlja21hcmtzID0gdGhpcy5EcmF3QmlnVGlja21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBudW1UaWNrcyA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcnXTtjby5saW5lV2lkdGggPSAzO2NvLmxpbmVDYXAgPSAncm91bmQnO2ZvciAodmFyIGkgPSAwOyBpIDw9IG51bVRpY2tzOyArK2kpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQudGlja21hcmtzLmJpZy5jb2xvciddO3ZhciBhID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpIC8gbnVtVGlja3MgKiBpICsgdGhpcy5zdGFydEFuZ2xlO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSAtIDEwLCBhLCBhICsgMC4wMDAwMSwgMCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LmJvcmRlci53aWR0aCddIC0gMTAgLSAxMCwgYSwgYSArIDAuMDAwMDEsIDApO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdDZW50ZXJwaW4gPSB0aGlzLkRyYXdDZW50ZXJwaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldCA9IDY7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcnggKyBvZmZzZXQsIHRoaXMuY2VudGVyeSAtIG9mZnNldCwgMCwgdGhpcy5jZW50ZXJ4ICsgb2Zmc2V0LCB0aGlzLmNlbnRlcnkgLSBvZmZzZXQsIDI1KTtncmFkLmFkZENvbG9yU3RvcCgwLCAnI2RkZicpO2dyYWQuYWRkQ29sb3JTdG9wKDEsIHByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5jb2xvciddKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5jZW50ZXJwaW5SYWRpdXMsIDAsIFJHLlRXT1BJLCAwKTtjby5maWxsKCk7XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgZm9udCA9IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLFxuICAgICAgICBzaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIG51bSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddID8gcHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoIC0gMSA6IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLFxuICAgICAgICBvZmZzZXR4ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxcbiAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J10sXG4gICAgICAgIG9mZnNldGEgPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0LmFuZ2xlJ107XG4gICAgY28uYmVnaW5QYXRoKCk7aWYgKG51bSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtOyArK2kpIHtcbiAgICAgICAgdmFyIGh5cCA9IHRoaXMucmFkaXVzIC0gMjUgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSAtIHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQucmFkaXVzJ107dmFyIGEgPSAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgLyBudW07XG4gICAgICAgIGEgPSB0aGlzLnN0YXJ0QW5nbGUgKyBpICogYTthIC09IFJHLkhBTEZQSTthICs9IG9mZnNldGE7dmFyIHggPSB0aGlzLmNlbnRlcnggLSBtYS5zaW4oYSkgKiBoeXA7dmFyIHkgPSB0aGlzLmNlbnRlcnkgKyBtYS5jb3MoYSkgKiBoeXA7dmFyIGhBbGlnbiA9IHggPiB0aGlzLmNlbnRlcnggPyAncmlnaHQnIDogJ2xlZnQnO3ZhciB2QWxpZ24gPSB5ID4gdGhpcy5jZW50ZXJ5ID8gJ2JvdHRvbScgOiAndG9wJztpZiAoYSA9PSBSRy5IQUxGUEkpIHtcbiAgICAgICAgICB2QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmIChhID09IFJHLlBJKSB7XG4gICAgICAgICAgaEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PSBSRy5IQUxGUEkgKyBSRy5QSSkge1xuICAgICAgICAgIHZBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyZWQnXSkge1xuICAgICAgICAgIGhBbGlnbiA9ICdjZW50ZXInO3ZBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChpIC8gbnVtKSArIHRoaXMubWluO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd0ZXh0JzogcHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10gPyBwcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMnXVtpXSA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCB2YWx1ZS50b0ZpeGVkKHZhbHVlID09PSAwID8gMCA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKSwgJ2hhbGlnbic6IGhBbGlnbiwgJ3ZhbGlnbic6IHZBbGlnbiwgJ3RhZyc6IHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddID8gJ2xhYmVscy5zcGVjaWZpYycgOiAnbGFiZWxzJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY28uZmlsbCgpO2lmIChwcm9wWydjaGFydC52YWx1ZS50ZXh0J10pIHtcbiAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJ4O3ZhciB5ID0gdGhpcy5jZW50ZXJ5ICsgcHJvcFsnY2hhcnQudmFsdWUudGV4dC55LnBvcyddICogdGhpcy5yYWRpdXM7dmFyIHVuaXRzX3ByZSA9IHR5cGVvZiBwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnByZSddID09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wcmUnXSA6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0ID0gdHlwZW9mIHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucG9zdCddID09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQudmFsdWUudGV4dC51bml0cy5wb3N0J10gOiBwcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGNvbG9yID0gcHJvcFsnY2hhcnQudmFsdWUudGV4dC5jb2xvciddO3ZhciBib3VuZGluZyA9IHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuYm91bmRpbmcnXTt2YXIgYm91bmRpbmdGaWxsID0gcHJvcFsnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZy5maWxsJ107dmFyIGJvdW5kaW5nU3Ryb2tlID0gcHJvcFsnY2hhcnQudmFsdWUudGV4dC5ib3VuZGluZy5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBjb2xvcjtSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplICsgMiwgJ3gnOiB4LCAneSc6IHksICd0ZXh0JzogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMudmFsdWUudG9GaXhlZChwcm9wWydjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJ10pLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogYm91bmRpbmcsICdib3VuZGluZy5maWxsJzogYm91bmRpbmdGaWxsLCAnYm91bmRpbmcuc3Ryb2tlJzogYm91bmRpbmdTdHJva2UsICd0YWcnOiAndmFsdWUudGV4dCcgfSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd1RvcFRpdGxlID0gdGhpcy5EcmF3VG9wVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHggPSB0aGlzLmNlbnRlcng7dmFyIHkgPSB0aGlzLmNlbnRlcnkgLSAyNTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5wb3MnXSA9PSAnbnVtYmVyJykge1xuICAgICAgeSA9IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICogcHJvcFsnY2hhcnQudGl0bGUudG9wLnBvcyddO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudGl0bGUudG9wJ10pIHtcbiAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5jb2xvciddO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBwcm9wWydjaGFydC50aXRsZS50b3AuZm9udCddLCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5zaXplJ10sICd4JzogeCwgJ3knOiB5LCAndGV4dCc6IFN0cmluZyhwcm9wWydjaGFydC50aXRsZS50b3AnXSksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdib3R0b20nLCAnYm9sZCc6IHByb3BbJ2NoYXJ0LnRpdGxlLnRvcC5ib2xkJ10sICd0YWcnOiAndGl0bGUudG9wJyB9KTtcbiAgICB9XG4gIH07dGhpcy5kcmF3Qm90dG9tVGl0bGUgPSB0aGlzLkRyYXdCb3R0b21UaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeCA9IHRoaXMuY2VudGVyeDt2YXIgeSA9IHRoaXMuY2VudGVyeSArIHRoaXMuY2VudGVycGluUmFkaXVzICsgMTA7aWYgKHR5cGVvZiBwcm9wWydjaGFydC50aXRsZS5ib3R0b20ucG9zJ10gPT0gJ251bWJlcicpIHtcbiAgICAgIHkgPSB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyAqIHByb3BbJ2NoYXJ0LnRpdGxlLmJvdHRvbS5wb3MnXTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRpdGxlLmJvdHRvbSddKSB7XG4gICAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50aXRsZS5ib3R0b20uY29sb3InXTtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudGl0bGUuYm90dG9tLmZvbnQnXSwgJ3NpemUnOiBwcm9wWydjaGFydC50aXRsZS5ib3R0b20uc2l6ZSddLCAneCc6IHgsICd5JzogeSwgJ3RleHQnOiBTdHJpbmcocHJvcFsnY2hhcnQudGl0bGUuYm90dG9tJ10pLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAndG9wJywgJ2JvbGQnOiBwcm9wWydjaGFydC50aXRsZS5ib3R0b20uYm9sZCddLCAndGFnJzogJ3RpdGxlLmJvdHRvbScgfSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd05lZWRsZSA9IHRoaXMuRHJhd05lZWRsZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29sb3IsIGluZGV4KSB7XG4gICAgdmFyIHR5cGUgPSBwcm9wWydjaGFydC5uZWVkbGUudHlwZSddO2NvLmxpbmVXaWR0aCA9IDAuNTtjby5zdHJva2VTdHlsZSA9ICdncmF5Jztjby5maWxsU3R5bGUgPSBjb2xvcjt2YXIgYW5nbGUgPSAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKiAoKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTthbmdsZSArPSB0aGlzLnN0YXJ0QW5nbGU7aWYgKF90eXBlb2YocHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXSAmJiB0eXBlb2YgcHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXVtpbmRleF0gPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBzaXplID0gcHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXVtpbmRleF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQubmVlZGxlLnNpemUnXSA9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHNpemUgPSBwcm9wWydjaGFydC5uZWVkbGUuc2l6ZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMucmFkaXVzIC0gMjUgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2xpbmUnKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5uZWVkbGUud2lkdGgnXTtjby5zdHJva2VTdHlsZSA9IGNvbG9yO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgc2l6ZSwgYW5nbGUsIGFuZ2xlICsgMC4wMDAxLCBmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtpZiAocHJvcFsnY2hhcnQubmVlZGxlLnRhaWwnXSkge1xuICAgICAgICBjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzICogMC4yLCBhbmdsZSArIFJHLlBJLCBhbmdsZSArIDAuMDAwMDEgKyBSRy5QSSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBzaXplLCBhbmdsZSwgYW5nbGUgKyAwLjAwMDAxLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLmNlbnRlcnBpblJhZGl1cyAqIDAuNSwgYW5nbGUgKyBSRy5IQUxGUEksIGFuZ2xlICsgMC4wMDAwMSArIFJHLkhBTEZQSSwgZmFsc2UpO2lmIChwcm9wWydjaGFydC5uZWVkbGUudGFpbCddKSB7XG4gICAgICAgIGNvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgKiAwLjIsIGFuZ2xlICsgUkcuUEksIGFuZ2xlICsgMC4wMDAwMSArIFJHLlBJLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMuY2VudGVycGluUmFkaXVzICogMC41LCBhbmdsZSAtIFJHLkhBTEZQSSwgYW5nbGUgLSAwLjAwMDAxIC0gUkcuSEFMRlBJLCBmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO3RoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICB9XG4gIH07dGhpcy5kcmF3Q29sb3JCYW5kcyA9IHRoaXMuRHJhd0NvbG9yQmFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJHLmlzX2FycmF5KHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXSkpIHtcbiAgICAgIHZhciByYW5nZXMgPSBwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ107Zm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gcmFuZ2VzW2ldWzJdO2NvLmxpbmVXaWR0aCA9IDA7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDEwIC0gcHJvcFsnY2hhcnQuYm9yZGVyLndpZHRoJ10sIChyYW5nZXNbaV1bMF0gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKyB0aGlzLnN0YXJ0QW5nbGUsIChyYW5nZXNbaV1bMV0gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKyB0aGlzLnN0YXJ0QW5nbGUsIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMjAgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgKHJhbmdlc1tpXVsxXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSArIHRoaXMuc3RhcnRBbmdsZSwgKHJhbmdlc1tpXVswXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSArIHRoaXMuc3RhcnRBbmdsZSwgdHJ1ZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXTt2YXIgZ3JlZW5TdGFydCA9IHRoaXMuc3RhcnRBbmdsZTt2YXIgZ3JlZW5FbmQgPSB0aGlzLnN0YXJ0QW5nbGUgKyAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKiAoKHByb3BbJ2NoYXJ0LmdyZWVuLmVuZCddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICBjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgZ3JlZW5TdGFydCwgZ3JlZW5FbmQsIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gKDEwICsgcHJvcFsnY2hhcnQuZ3JlZW4ud2lkdGgnXSkgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgZ3JlZW5FbmQsIGdyZWVuU3RhcnQsIHRydWUpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO3ZhciB5ZWxsb3dTdGFydCA9IGdyZWVuRW5kO3ZhciB5ZWxsb3dFbmQgPSB0aGlzLnN0YXJ0QW5nbGUgKyAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKiAoKHByb3BbJ2NoYXJ0LnJlZC5zdGFydCddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICBjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgeWVsbG93U3RhcnQsIHllbGxvd0VuZCwgZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSAoMTAgKyBwcm9wWydjaGFydC55ZWxsb3cud2lkdGgnXSkgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgeWVsbG93RW5kLCB5ZWxsb3dTdGFydCwgdHJ1ZSk7Y28uZmlsbCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQucmVkLmNvbG9yJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQucmVkLmNvbG9yJ107dmFyIHJlZFN0YXJ0ID0geWVsbG93RW5kO3ZhciByZWRFbmQgPSB0aGlzLnN0YXJ0QW5nbGUgKyAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKiAoKHRoaXMubWF4IC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICBjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMTAgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgcmVkU3RhcnQsIHJlZEVuZCwgZmFsc2UpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSAoMTAgKyBwcm9wWydjaGFydC5yZWQud2lkdGgnXSkgLSBwcm9wWydjaGFydC5ib3JkZXIud2lkdGgnXSwgcmVkRW5kLCByZWRTdGFydCwgdHJ1ZSk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge307dGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO3ZhciBhbmdsZSA9IFJHLmdldEFuZ2xlQnlYWSh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYLCBtb3VzZVkpO2lmIChhbmdsZSA+PSAwICYmIGFuZ2xlIDw9IFJHLkhBTEZQSSkge1xuICAgICAgYW5nbGUgKz0gUkcuVFdPUEk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChhbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgLyAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7dmFsdWUgPSB2YWx1ZSArIHRoaXMubWluO2lmICh2YWx1ZSA8IHRoaXMubWluKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSR3JhcGguZ2V0TW91c2VYWShlKTtpZiAobW91c2VYWVswXSA+IHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzICYmIG1vdXNlWFlbMF0gPCB0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzFdID4gdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXMgJiYgbW91c2VYWVsxXSA8IHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzICYmIFJHLmdldEh5cExlbmd0aCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYWVswXSwgbW91c2VYWVsxXSkgPD0gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdHcmFkaWVudCA9IHRoaXMuRHJhd0dyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5ib3JkZXIuZ3JhZGllbnQnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDE1KTtncmFkLmFkZENvbG9yU3RvcCgwLCAnZ3JheScpO2dyYWQuYWRkQ29sb3JTdG9wKDEsICd3aGl0ZScpO2NvLmZpbGxTdHlsZSA9IGdyYWQ7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgMCwgUkcuVFdPUEksIGZhbHNlKTtcbiAgICAgIGNvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSAxNSwgUkcuVFdPUEksIDAsIHRydWUpO1xuICAgICAgY28uZmlsbCgpO1xuICAgIH1cbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZSk7UkcucmVkcmF3Q2FudmFzKHRoaXMuY2FudmFzKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYWRqdXN0Jyk7XG4gICAgfVxuICB9O3RoaXMuZ2V0QW5nbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heCB8fCB2YWx1ZSA8IHRoaXMubWluKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGFuZ2xlID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICsgdGhpcy5zdGFydEFuZ2xlO3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5yZWQuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQueWVsbG93LmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYm9yZGVyLmlubmVyJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJvcmRlci5vdXRlciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYm9yZGVyLm91dGVyJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMucmFuZ2VzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5uZWVkbGUuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5uZWVkbGUuY29sb3JzJ10pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnJlZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQucmVkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTtwcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJvcmRlci5pbm5lciddKTtwcm9wWydjaGFydC5ib3JkZXIub3V0ZXInXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJvcmRlci5vdXRlciddKTtpZiAocHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gcHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddO2ZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJhbmdlc1tpXVsyXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHJhbmdlc1tpXVsyXSwgdGhpcy5yYWRpdXMgLSAzMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5uZWVkbGUuY29sb3JzJ10pIHtcbiAgICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5uZWVkbGUuY29sb3JzJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29sb3JzW2ldID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIHJhZGl1c1N0YXJ0ID0gYXJndW1lbnRzWzFdIHx8IDA7aWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgcmFkaXVzU3RhcnQsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIG9wdCA9IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9O3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7aWYgKHR5cGVvZiBvYmoudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgb3JpZ1ZhbHVlID0gTnVtYmVyKG9iai5jdXJyZW50VmFsdWUpO2lmIChvYmouY3VycmVudFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgb2JqLmN1cnJlbnRWYWx1ZSA9IG9iai5taW47b3JpZ1ZhbHVlID0gb2JqLm1pbjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IG9iai52YWx1ZTt2YXIgZGlmZiA9IG5ld1ZhbHVlIC0gb3JpZ1ZhbHVlO3ZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICBvYmoudmFsdWUgPSBmcmFtZSAvIGZyYW1lcyAqIGRpZmYgKyBvcmlnVmFsdWU7aWYgKG9iai52YWx1ZSA+IG9iai5tYXgpIG9iai52YWx1ZSA9IG9iai5tYXg7aWYgKG9iai52YWx1ZSA8IG9iai5taW4pIG9iai52YWx1ZSA9IG9iai5taW47UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgICAgUkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH07aXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9iai5jdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBvYmouY3VycmVudFZhbHVlID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvYmouY3VycmVudFZhbHVlW2ldID0gb2JqLm1pbjtcbiAgICAgICAgfVxuICAgICAgICBvcmlnVmFsdWUgPSBSRy5hcnJheV9jbG9uZShvYmouY3VycmVudFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBvcmlnVmFsdWUgPSBSRy5hcnJheV9jbG9uZShvYmouY3VycmVudFZhbHVlKTt2YXIgbmV3VmFsdWUgPSBSRy5hcnJheV9jbG9uZShvYmoudmFsdWUpO3ZhciBkaWZmID0gW107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG5ld1ZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGRpZmZbaV0gPSBuZXdWYWx1ZVtpXSAtIE51bWJlcihvYmouY3VycmVudFZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICBmcmFtZSsrO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoudmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBvYmoudmFsdWVbaV0gPSBmcmFtZSAvIGZyYW1lcyAqIGRpZmZbaV0gKyBvcmlnVmFsdWVbaV07aWYgKG9iai52YWx1ZVtpXSA+IG9iai5tYXgpIG9iai52YWx1ZVtpXSA9IG9iai5tYXg7aWYgKG9iai52YWx1ZVtpXSA8IG9iai5taW4pIG9iai52YWx1ZVtpXSA9IG9iai5taW47XG4gICAgICAgIH1cbiAgICAgICAgUkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSA8IGZyYW1lcykge1xuICAgICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgICB9XG4gICAgICB9O2l0ZXJhdG9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmdhdWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///191\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HBar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.data = data;this.type = 'hbar';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coords2 = [];this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.max = 0;this.stackedOrGrouped = false;this.properties = (_properties = { 'chart.gutter.left': 75, 'chart.gutter.left.autosize': false, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid.hlines': true, 'chart.background.grid.vlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': null, 'chart.background.grid.autofit.numvlines': 5, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.color': null, 'chart.linewidth': 1, 'chart.title': '', 'chart.title.background': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': 0.8, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.xaxis.color': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.colors': ['red', 'blue', 'green', 'pink', 'yellow', 'cyan', 'navy', 'gray', 'black'], 'chart.colors.sequential': false, 'chart.xlabels.specific': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.above': false, 'chart.labels.above.decimals': 0, 'chart.labels.above.specific': null, 'chart.labels.above.color': null, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.font': null, 'chart.labels.above.size': null, 'chart.labels.above.bold': false, 'chart.labels.above.italic': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xlabels.offsetx': 0, 'chart.xlabels.offsety': 0, 'chart.xlabels': true, 'chart.xlabels.count': 5, 'chart.contextmenu': null, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.units.pre': '', 'chart.units.post': '', 'chart.units.ingraph': false, 'chart.strokestyle': 'rgba(0,0,0,0)', 'chart.xmin': 0, 'chart.xmax': 0, 'chart.axis.color': 'black', 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.vmargin': 2, 'chart.vmargin.grouped': 2, 'chart.grouping': 'grouped', 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.style': null, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.decimals': null, 'chart.scale.zerostart': true, 'chart.noredraw': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.noxaxis': false, 'chart.noyaxis': false, 'chart.noaxes': false, 'chart.noxtickmarks': false, 'chart.noytickmarks': false, 'chart.numyticks': data.length, 'chart.numxticks': 10, 'chart.variant': 'hbar', 'chart.variant.threed.angle': 0.1, 'chart.variant.threed.offsetx': 10, 'chart.variant.threed.offsety': 5, 'chart.variant.threed.xaxis': true, 'chart.variant.threed.yaxis': true, 'chart.yaxispos': 'left' }, _defineProperty(_properties, 'chart.variant', 'hbar'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _properties);\n  if (!this.canvas) {\n    alert('[HBAR] No canvas support');return;\n  }\n  for (i = 0, len = this.data.length; i < len; ++i) {\n    if (_typeof(this.data[i]) == 'object' && !RGraph.isNull(this.data[i])) {\n      this.stackedOrGrouped = true;for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    } else if (typeof this.data[i] == 'string') {\n      this.data[i] = parseFloat(this.data[i]) || 0;\n    } else if (typeof this.data[i] === 'undefined') {\n      this.data[i] = null;\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(data);for (var i = 0, len = linear_data.length; i < len; ++i) {\n    this['$' + i] = {};\n  }\n  this.data_arr = RGraph.arrayLinearize(this.data);if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.labels.abovebar') {\n      name = 'chart.labels.above';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (prop['chart.adjustable'] && prop['chart.grouping'] === 'stacked') {\n      alert('[RGRAPH] The HBar does not support stacked charts with adjusting');\n    }\n    if (prop['chart.variant'] === '3d') {\n      if (prop['chart.text.accessible']) {} else {\n        co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);\n      }\n      if (prop['chart.gutter.bottom'] === 25) {\n        this.set('gutterBottom', 80);\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.gutter.left.autosize']) {\n      var len = 0;var labels = prop['chart.labels'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];for (var i = 0; i < labels.length; i += 1) {\n        var length = RG.measureText(labels[i], false, font, size)[0] || 0;\n        len = ma.max(len, length);\n      }\n      prop['chart.gutter.left'] = len + 10;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coords2 = [];this.coordsText = [];this.max = 0;if (prop['chart.xmin'] > 0 && prop['chart.grouping'] == 'stacked') {\n      alert('[HBAR] Using chart.xmin is not supported with stacked charts, resetting chart.xmin to zero');this.Set('chart.xmin', 0);\n    }\n    this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.graphheight = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;this.halfway = ma.round(this.graphwidth / 2 + this.gutterLeft);\n    RG.Background.draw(this);this.drawbars();this.drawAxes();this.drawLabels();if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    var halfway = this.halfway;\n    co.beginPath();co.lineWidth = prop['chart.axis.linewidth'] ? prop['chart.axis.linewidth'] + 0.001 : 1.001;co.strokeStyle = prop['chart.axis.color'];if (prop['chart.noyaxis'] == false && prop['chart.noaxes'] == false) {\n      if (prop['chart.yaxispos'] == 'center') {\n        co.moveTo(halfway, this.gutterTop);co.lineTo(halfway, ca.height - this.gutterBottom);\n      } else if (prop['chart.yaxispos'] == 'right') {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.noaxes'] == false) {\n      co.moveTo(this.gutterLeft + 0.001, ca.height - this.gutterBottom + 0.001);co.lineTo(ca.width - this.gutterRight + 0.001, ca.height - this.gutterBottom + 0.001);\n    }\n    if (prop['chart.noytickmarks'] == false && prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0 && prop['chart.noaxes'] == false) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / (prop['chart.numyticks'] > 0 ? prop['chart.numyticks'] : this.data.length);for (y = this.gutterTop; y < ca.height - this.gutterBottom - 1; y += yTickGap) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] == true) {\n        if (prop['chart.yaxispos'] == 'center') {\n          co.moveTo(halfway + 3, ma.round(y));co.lineTo(halfway - 3, ma.round(y));\n        } else if (prop['chart.yaxispos'] == 'right') {\n          co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight + 3, ma.round(y));\n        } else {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n    }\n    if (prop['chart.noxtickmarks'] == false && prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0 && prop['chart.noaxes'] == false) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];yStart = ca.height - this.gutterBottom;yEnd = ca.height - this.gutterBottom + 3;var i = prop['chart.numxticks'];\n      while (i--) {\n        var x = ca.width - this.gutterRight - i * xTickGap;if (prop['chart.yaxispos'] === 'right') {\n          x -= xTickGap;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.yaxispos'] === 'center') {\n        var i = 5;while (i--) {\n          var x = this.gutterLeft + xTickGap * i;co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n        }\n      }\n      if (prop['chart.noyaxis'] == true) {\n        co.moveTo(this.gutterLeft, ma.round(yStart));co.lineTo(this.gutterLeft, ma.round(yEnd));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    var units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        text_size = prop['chart.text.size'],\n        font = prop['chart.text.font'],\n        offsetx = prop['chart.xlabels.offsetx'],\n        offsety = prop['chart.xlabels.offsety'];\n    if (prop['chart.units.ingraph']) {\n      units_pre = '';units_post = '';\n    }\n    if (prop['chart.xlabels']) {\n      if (RG.isArray(prop['chart.xlabels.specific'])) {\n        if (prop['chart.yaxispos'] == 'center') {\n          var halfGraphWidth = this.graphwidth / 2;var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / 2 / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + halfGraphWidth + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsetx, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = labels.length - 1; i > 0; i -= 1) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * (labels.length - i - 1) + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[i], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + interval * i + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'text': labels[labels.length - i - 1], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          var labels = prop['chart.xlabels.specific'];var interval = this.graphwidth / (labels.length - 1);co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; i += 1) {\n            RG.text2(this, { font: font, size: text_size, x: this.gutterLeft + interval * i + offsetx, y: ca.height - this.gutterBottom + offsety, text: labels[i], valign: 'top', halign: 'center', tag: 'scale' });\n          }\n        }\n      } else {\n        var gap = 7;co.beginPath();co.fillStyle = prop['chart.text.color'];if (prop['chart.yaxispos'] == 'center') {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 - this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth / 2 * ((i + 1) / this.scale2.labels.length) + this.graphwidth / 2 + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + i * (this.graphwidth / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': '-' + this.scale2.labels[len - 1 - i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': this.gutterLeft + this.graphwidth * ((i + 1) / len) + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.xmin'] > 0 || prop['chart.noyaxis'] == true || prop['chart.scale.zerostart'] || prop['chart.noaxes']) {\n          var x = prop['chart.yaxispos'] == 'center' ? this.gutterLeft + this.graphwidth / 2 : this.gutterLeft;if (prop['chart.yaxispos'] === 'right') {\n            var x = ca.width - this.gutterRight;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': this.gutterTop + this.halfTextHeight + this.graphheight + gap + offsety, 'text': RG.numberFormat(this, prop['chart.xmin'].toFixed(prop['chart.xmin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': 'center', 'tag': 'scale' });\n        }\n        co.fill();co.stroke();\n      }\n    }\n    if (_typeof(prop['chart.labels']) == 'object') {\n      var xOffset = prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right' ? 15 : 5,\n          font = prop['chart.text.font'],\n          color = prop['chart.labels.color'] || prop['chart.text.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.fillStyle = color;var barHeight = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length;\n      if (prop['chart.yaxispos'] === 'right') {\n        var x = ca.width - this.gutterRight + xOffset;var halign = 'left';\n      } else {\n        var x = this.gutterLeft - xOffset;var halign = 'right';\n      }\n      var i = 0;for (y = this.gutterTop + yTickGap / 2; y <= ca.height - this.gutterBottom; y += yTickGap) {\n        RG.text2(this, { 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.labels'][i++]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n      }\n    }\n  };this.drawbars = this.Drawbars = function () {\n    co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];var prevX = 0,\n        prevY = 0;if (prop['chart.xmax']) {\n      this.scale2 = RG.getScale2(this, { 'max': prop['chart.xmax'], 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'], 'strict': true });this.max = this.scale2.max;\n    } else {\n      var grouping = prop['chart.grouping'];for (i = 0; i < this.data.length; ++i) {\n        if (_typeof(this.data[i]) == 'object') {\n          var value = grouping == 'grouped' ? Number(RG.array_max(this.data[i], true)) : Number(RG.array_sum(this.data[i]));\n        } else {\n          var value = Number(ma.abs(this.data[i]));\n        }\n        this.max = ma.max(Math.abs(this.max), Math.abs(value));\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.xmin'], 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.xlabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    if (prop['chart.scale.decimals'] == null && Number(this.max) == 1) {\n      this.Set('chart.scale.decimals', 1);\n    }\n    var colorIdx = 0;this.numbars = RG.arrayLinearize(this.data).length;if (prop['chart.adjustable'] && !prop['chart.xmax']) {\n      this.set('chart.xmax', this.scale2.max);\n    }\n    if (prop['chart.variant'] === '3d') {\n      RG.draw3DAxes(this);\n    }\n    var graphwidth = ca.width - this.gutterLeft - this.gutterRight;var halfwidth = graphwidth / 2;for (i = len = this.data.length - 1; i >= 0; --i) {\n      var width = ma.abs(this.data[i] / this.max * graphwidth);var height = this.graphheight / this.data.length;var orig_height = height;var x = this.gutterLeft;var y = this.gutterTop + i * height;var vmargin = prop['chart.vmargin'];if (prop['chart.yaxispos'] === 'right') {\n        x = ca.width - this.gutterRight - ma.abs(width);\n      }\n      if (width < 0) {\n        x -= width;width = ma.abs(width);\n      }\n      if (prop['chart.shadow']) {\n        co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n      }\n      co.beginPath();if (typeof this.data[i] == 'number' || RG.isNull(this.data[i])) {\n        var barHeight = height - 2 * vmargin,\n            barWidth = (this.data[i] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * this.graphwidth,\n            barX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n          barWidth /= 2;barX += halfwidth;if (this.data[i] < 0) {\n            barWidth = (ma.abs(this.data[i]) - prop['chart.xmin']) / (this.max - prop['chart.xmin']);barWidth = barWidth * (this.graphwidth / 2);barX = this.graphwidth / 2 + this.gutterLeft - barWidth;\n          }\n        } else if (prop['chart.yaxispos'] == 'right') {\n          barWidth = ma.abs(barWidth);barX = ca.width - this.gutterRight - barWidth;\n        }\n        co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n          if (prop['chart.colors'][this.numbars - colorIdx]) {\n            co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n          } else {\n            co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n          }\n        }\n        co.strokeRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);co.fillRect(barX, this.gutterTop + i * height + prop['chart.vmargin'], barWidth, barHeight);this.coords.push([barX, y + vmargin, barWidth, height - 2 * vmargin, co.fillStyle, this.data[i], true]);if (prop['chart.variant'] === '3d' && typeof this.data[i] == 'number') {\n          var prevStrokeStyle = co.strokeStyle,\n              prevFillStyle = co.fillStyle;RG.noShadow(this);var barX = barX,\n              barY = y + vmargin,\n              barW = barWidth,\n              barH = height - 2 * vmargin,\n              offsetX = prop['chart.variant.threed.offsetx'],\n              offsetY = prop['chart.variant.threed.offsety'],\n              value = this.data[i];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX - (prop['chart.yaxispos'] == 'left' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW + offsetX - (prop['chart.yaxispos'] == 'center' && value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n            pa2(co, ['b', 'fs', prevFillStyle, 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {\n        if (prop['chart.yaxispos'] == 'center') {\n          alert('[HBAR] You can\\'t have a stacked chart with the Y axis in the center, change it to grouped');\n        } else if (prop['chart.yaxispos'] == 'right') {\n          var x = ca.width - this.gutterRight;\n        }\n        var barHeight = height - 2 * vmargin;if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = 0; j < this.data[i].length; ++j) {\n          if (prop['chart.shadow'] && prop['chart.variant'] === '3d') {\n            co.shadowColor = prop['chart.shadow.color'];co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n          }\n          if (!RG.isNull(this.data[i][j])) this.data[i][j] = ma.abs(this.data[i][j]);var last = j === this.data[i].length - 1;co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var width = this.data[i][j] / this.max * this.graphwidth;var totalWidth = RG.arraySum(this.data[i]) / this.max * this.graphwidth;if (prop['chart.yaxispos'] === 'right') {\n            x -= width;\n          }\n          co.strokeRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);co.fillRect(x, this.gutterTop + prop['chart.vmargin'] + this.graphheight / this.data.length * i, width, height - 2 * vmargin);this.coords.push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);this.coords2[i].push([x, y + vmargin, width, height - 2 * vmargin, co.fillStyle, RG.array_sum(this.data[i]), j == this.data[i].length - 1]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = x,\n                barY = y + vmargin,\n                barW = width,\n                barH = height - 2 * vmargin,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];if (!RG.isNull(value)) {\n              pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);\n            }\n            if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n          if (prop['chart.yaxispos'] !== 'right') {\n            x += width;\n          }\n        }\n      } else if (_typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {\n        var vmarginGrouped = prop['chart.vmargin.grouped'];var individualBarHeight = (height - 2 * vmargin - (this.data[i].length - 1) * vmarginGrouped) / this.data[i].length;\n        if (typeof this.coords2[i] == 'undefined') {\n          this.coords2[i] = [];\n        }\n        for (j = this.data[i].length - 1; j >= 0; --j) {\n          if (prop['chart.shadow']) {\n            RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n          }\n          co.strokeStyle = prop['chart.strokestyle'];++colorIdx;if (prop['chart.colors.sequential'] && typeof colorIdx === 'number') {\n            if (prop['chart.colors'][this.numbars - colorIdx]) {\n              co.fillStyle = prop['chart.colors'][this.numbars - colorIdx];\n            } else {\n              co.fillStyle = prop['chart.colors'][prop['chart.colors'].length - 1];\n            }\n          } else if (prop['chart.colors'][j]) {\n            co.fillStyle = prop['chart.colors'][j];\n          }\n          var startY = this.gutterTop + height * i + individualBarHeight * j + vmargin + vmarginGrouped * j;var width = (this.data[i][j] - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * (ca.width - this.gutterLeft - this.gutterRight);var startX = this.gutterLeft;if (prop['chart.yaxispos'] == 'center') {\n            width /= 2;startX += halfwidth;\n          } else if (prop['chart.yaxispos'] == 'right') {\n            width = ma.abs(width);startX = ca.width - this.gutterRight - ma.abs(width);;\n          }\n          if (width < 0) {\n            startX += width;width *= -1;\n          }\n          co.strokeRect(startX, startY, width, individualBarHeight);co.fillRect(startX, startY, width, individualBarHeight);this.coords.push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);this.coords2[i].push([startX, startY, width, individualBarHeight, co.fillStyle, this.data[i][j], true]);if (prop['chart.variant'] === '3d') {\n            RG.noShadow(this);var prevStrokeStyle = co.strokeStyle,\n                prevFillStyle = co.fillStyle;var barX = startX,\n                barY = startY,\n                barW = width,\n                barH = individualBarHeight,\n                offsetX = prop['chart.variant.threed.offsetx'],\n                offsetY = prop['chart.variant.threed.offsety'],\n                value = this.data[i][j];pa2(co, ['b', 'm', barX, barY, 'l', barX + offsetX, barY - offsetY, 'l', barX + barW + offsetX - (value < 0 ? offsetX : 0), barY - offsetY, 'l', barX + barW, barY, 'c', 's', co.strokeStyle, 'f', co.fillStyle, 'f', 'rgba(255,255,255,0.6)']);if (prop['chart.yaxispos'] !== 'right' && !(prop['chart.yaxispos'] === 'center' && value < 0) && value >= 0 && !RG.isNull(value)) {\n              pa2(co, ['fs', prevFillStyle, 'b', 'm', barX + barW, barY, 'l', barX + barW + offsetX, barY - offsetY, 'l', barX + barW + offsetX, barY - offsetY + barH, 'l', barX + barW, barY + barH, 'c', 's', co.strokeStyle, 'f', prevFillStyle, 'f', 'rgba(0,0,0,0.25)']);\n            }\n            co.beginPath();co.strokeStyle = prevStrokeStyle;co.fillStyle = prevFillStyle;\n          }\n        }\n        startY += vmargin;\n      }\n      co.closePath();\n    }\n    co.stroke();co.fill();if (prop['chart,yaxispos'] === 'right') {\n      pa2(co, 'cr % % % %', ca.width - this.gutterRight + prop['chart.variant.threed.offsetx'], '0', this.gutterRight, ca.height);\n    }\n    if (prop['chart.yaxispos'] === 'right' && prop['chart.variant'] === '3d') {\n      RG.draw3DYAxis(this);\n    }\n    RG.noShadow(this);this.coords = RG.arrayReverse(this.coords);if (prop['chart.grouping'] === 'grouped') {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        this.coords2[i] = RG.arrayReverse(this.coords2[i]);\n      }\n    }\n    this.redrawBars();\n  };this.redrawBars = this.RedrawBars = function () {\n    if (prop['chart.noredraw']) {\n      return;\n    }\n    var coords = this.coords;var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'];RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle'];for (var i = 0; i < coords.length; ++i) {\n      if (prop['chart.shadow']) {\n        pa2(co, 'b lw % r % % % % s % f %', prop['chart.linewidth'], coords[i][0], coords[i][1], coords[i][2], coords[i][3], prop['chart.strokestyle'], coords[i][4]);\n      }\n      var halign = 'left';if (prop['chart.labels.above'] && coords[i][6]) {\n        var border = coords[i][0] + coords[i][2] + 7 + co.measureText(prop['chart.labels.above.units.pre'] + this.coords[i][5] + prop['chart.labels.above.units.post']).width > ca.width ? true : false,\n            text = RG.numberFormat(this, this.coords[i][5].toFixed(prop['chart.labels.above.decimals']), prop['chart.labels.above.units.pre'], prop['chart.labels.above.units.post']);RG.noShadow(this);if (_typeof(prop['chart.labels.above.specific']) === 'object' && prop['chart.labels.above.specific'] && prop['chart.labels.above.specific'][i]) {\n          text = prop['chart.labels.above.specific'][i];\n        }\n        var x = coords[i][0] + coords[i][2] + 5;var y = coords[i][1] + coords[i][3] / 2;if (prop['chart.yaxispos'] === 'right') {\n          x = coords[i][0] - 5;halign = 'right';\n        } else if (prop['chart.yaxispos'] === 'center' && this.data_arr[i] < 0) {\n          x = coords[i][0] - 5;halign = 'right';\n        }\n        RG.text2(this, { font: typeof prop['chart.labels.above.font'] === 'string' ? prop['chart.labels.above.font'] : font, size: typeof prop['chart.labels.above.size'] === 'number' ? prop['chart.labels.above.size'] : size, color: typeof prop['chart.labels.above.color'] === 'string' ? prop['chart.labels.above.color'] : color, x: x, y: y, bold: prop['chart.labels.above.bold'], italic: prop['chart.labels.above.italic'], text: text, valign: 'center', halign: halign, tag: 'labels.above' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e);for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3],\n          idx = i;pa2(co, ['b', 'r', left, top, width, height]);if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: left, 'x': left, 2: top, 'y': top, 3: width, 'width': width, 4: height, 'height': height, 5: idx, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.yaxispos'] == 'center') {\n      var value = (mouseX - this.gutterLeft) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value = value - this.max;\n      if (prop['chart.xmin'] > 0) {\n        value = (mouseX - this.gutterLeft - this.graphwidth / 2) / (this.graphwidth / 2) * (this.max - prop['chart.xmin']);value += prop['chart.xmin'];if (mouseX < this.gutterLeft + this.graphwidth / 2) {\n          value -= 2 * prop['chart.xmin'];\n        }\n      }\n    } else if (prop['chart.yaxispos'] == 'right') {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value = this.scale2.max - value;\n    } else {\n      var value = (mouseX - this.gutterLeft) / this.graphwidth * (this.scale2.max - prop['chart.xmin']);value += prop['chart.xmin'];\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (prop['chart.variant'] === '3d') {\n      var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];mouseXY[1] -= adjustment;\n    }\n    if (mouseXY[0] >= this.gutterLeft && mouseXY[0] <= ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (prop['chart.yaxispos'] == 'center') {\n      if (value > this.max || value < -1 * this.max) {\n        return null;\n      }\n      var width = (ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2;var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width + width;coord = prop['chart.gutter.left'] + coord;\n    } else {\n      if (value > this.max || value < 0) {\n        return null;\n      }\n      var width = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];var coord = (value - prop['chart.xmin']) / (this.max - prop['chart.xmin']) * width;coord = prop['chart.gutter.left'] + coord;\n    }\n    return coord;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.labels.colors'] = RG.array_clone(prop['chart.labels.colors']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.labels.colors'] = this.parseSingleColorForGradient(prop['chart.labels.colors']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.yaxispos'] === 'right') {\n        parts = RG.arrayReverse(parts);\n      }\n      var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var obj = this;this.coords2.forEach(function (value, idx, arr) {\n      var shape = obj.coords2[idx][index];\n      var pre_linewidth = co.lineWidth;co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillRect(shape[0], shape[1], shape[2], shape[3]);co.strokeRect(shape[0], shape[1], shape[2], shape[3]);co.lineWidth = pre_linewidth;\n    });\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.getShapeByY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var obj = arguments[1] ? arguments[1] : this;for (var i = 0, len = obj.coords.length; i < len; i++) {\n      if (obj.coords[i].length == 0) {\n        continue;\n      }\n      var mouseX = mouseXY[0],\n          mouseY = mouseXY[1],\n          left = obj.coords[i][0],\n          top = obj.coords[i][1],\n          width = obj.coords[i][2],\n          height = obj.coords[i][3];if (mouseY >= top && mouseY <= top + height) {\n        if (prop['chart.tooltips']) {\n          var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];\n        }\n        return { 0: obj, object: obj, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e)),\n          shape = RG.Registry.get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {\n          var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);if (typeof this.data[indexes[0]] == 'number') {\n            this.data[indexes[0]] = Number(value);\n          } else if (!RG.is_null(this.data[indexes[0]])) {\n            this.data[indexes[0]][indexes[1]] = Number(value);\n          }\n        } else if (typeof this.data[shape['index']] == 'number') {\n          this.data[shape['index']] = Number(value);\n        }\n        RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.grow = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);obj.original_data = RG.arrayClone(obj.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    function iterator() {\n      for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        var easingFactor = RG.Effects.getEasingMultiplier(frames, frame);if (_typeof(obj.data[j]) === 'object' && obj.data[j]) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            obj.data[j][k] = RG.isNull(obj.data[j][k]) ? null : obj.original_data[j][k] * easingFactor;\n          }\n        } else {\n          obj.data[j] = RG.isNull(obj.data[j]) ? null : obj.original_data[j] * easingFactor;\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        obj = this,\n        labelsAbove = this.get('labelsAbove');\n    this.original_data = RG.arrayClone(this.data);if (prop['chart.xmax'] == 0) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'stacked') {\n          xmax = ma.max(xmax, RG.arraySum(obj.data[i]));\n        } else if (RG.isArray(obj.data[i]) && prop['chart.grouping'] == 'grouped') {\n          xmax = ma.max(xmax, RG.arrayMax(obj.data[i]));\n        } else {\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(obj.data[i])));\n        }\n      }\n      var scale2 = RG.getScale2(obj, { 'max': xmax });obj.Set('chart.xmax', scale2.max);\n    }\n    if (RG.isArray(opt.data)) {\n      var xmax = 0;for (var i = 0; i < opt.data.length; ++i) {\n        if (_typeof(opt.data[i]) === 'object') {\n          for (var j = 0; j < opt.data[i].length; ++j) {\n            if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\\+|\\-)([0-9]+)/)) {\n              if (RegExp.$1 === '+') {\n                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);\n              } else {\n                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);\n              }\n            }\n            xmax = ma.max(xmax, opt.data[i][j]);\n          }\n        } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\\+|\\-)([0-9]+)/)) {\n          if (RegExp.$1 === '+') {\n            opt.data[i] = this.original_data[i] + parseFloat(RegExp.$2);\n          } else {\n            opt.data[i] = this.original_data[i] - parseFloat(RegExp.$2);\n          }\n          xmax = ma.max(xmax, opt.data[i]);\n        } else {\n          xmax = ma.max(xmax, opt.data[i]);\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });if (typeof this.get('chart.xmax') === 'null') {\n        this.set('chart.xmax', scale.max);\n      }\n    }\n    this.set('labelsAbove', false);if (RG.isNull(prop['chart.xmax'])) {\n      var xmax = 0;for (var i = 0; i < obj.data.length; ++i) {\n        if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {\n          xmax = ma.max(xmax, ma.abs(RG.arraySum(this.data[i])));\n        } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {\n          for (var j = 0, group = []; j < this.data[i].length; j++) {\n            group.push(ma.abs(this.data[i][j]));\n          }\n          xmax = ma.max(xmax, ma.abs(RG.arrayMax(group)));\n        } else {\n          xmax = ma.max(xmax, ma.abs(this.data[i]));\n        }\n      }\n      var scale = RG.getScale2(this, { 'max': xmax });this.Set('chart.xmax', scale.max);\n    }\n    if (typeof opt.xmax === 'number') {\n      obj.set('xmax', opt.xmax);\n    }\n    var iterator = function iterator() {\n      var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);for (var j = 0, len = obj.original_data.length; j < len; ++j) {\n        if (_typeof(obj.data[j]) === 'object' && !RG.isNull(obj.data[j])) {\n          for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {\n            if (obj.firstDraw || !opt.data) {\n              obj.data[j][k] = easingMultiplier * obj.original_data[j][k];\n            } else if (opt.data && opt.data.length === obj.original_data.length) {\n              var diff = opt.data[j][k] - obj.original_data[j][k];obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];\n            }\n          }\n        } else {\n          if (obj.firstDraw || !opt.data) {\n            obj.data[j] = easingMultiplier * obj.original_data[j];\n          } else if (opt.data && opt.data.length === obj.original_data.length) {\n            var diff = opt.data[j] - obj.original_data[j];obj.data[j] = easingMultiplier * diff + obj.original_data[j];\n          }\n        }\n      }\n      RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame += 1;RG.Effects.updateCanvas(iterator);\n      } else {\n        if (RG.isArray(opt.data)) {\n          var linear_data = RG.arrayLinearize(data);for (var i = 0; i < linear_data.length; ++i) {\n            if (!obj['$' + i]) {\n              obj['$' + i] = {};\n            }\n          }\n        }\n        obj.data = data;obj.original_data = RG.arrayClone(data);if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redraw();\n        }\n        callback(obj);\n      }\n    };iterator();return this;\n  };this.wave = function () {\n    var obj = this,\n        opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n        frame = -1,\n        callback = arguments[1] || function () {},\n        original = RG.arrayClone(obj.data),\n        labelsAbove = prop['chart.labels.above'];this.set('labelsAbove', false);for (var i = 0, len = obj.data.length; i < len; i += 1) {\n      opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;if (_typeof(obj.data[i]) === 'object' && obj.data[i]) {\n        opt.counters[i] = [];for (var j = 0; j < obj.data[i].length; j++) {\n          opt.counters[i][j] = 0;\n        }\n      } else {\n        opt.counters[i] = 0;\n      }\n    }\n    obj.draw();obj.Set('xmax', obj.scale2.max);RG.clear(obj.canvas);function iterator() {\n      ++frame;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        if (frame > opt.startFrames[i]) {\n          if (typeof obj.data[i] === 'number') {\n            obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));if (original[i] < 0) {\n              obj.data[i] *= -1;\n            }\n          } else if (!RG.isNull(obj.data[i])) {\n            for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {\n              obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));if (original[i][j] < 0) {\n                obj.data[i][j] *= -1;\n              }\n            }\n          }\n        } else {\n          obj.data[i] = _typeof(obj.data[i]) === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;\n        }\n      }\n      if (frame >= opt.frames) {\n        if (labelsAbove) {\n          obj.set('labelsAbove', true);RG.redrawCanvas(obj.canvas);\n        }\n        callback(obj);\n      } else {\n        RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      }\n    }\n    iterator();return this;\n  };this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5oYmFyLmpzPzBiZTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguSEJhciA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIHZhciBfcHJvcGVydGllcztcblxuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZDtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBkYXRhID0gY29uZi5kYXRhO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQgPyB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaWQpKSA9PT0gJ29iamVjdCcgJiYgaWQuYWxwaGEgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlIH0pIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLmRhdGEgPSBkYXRhO3RoaXMudHlwZSA9ICdoYmFyJzt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMubWF4ID0gMDt0aGlzLnN0YWNrZWRPckdyb3VwZWQgPSBmYWxzZTt0aGlzLnByb3BlcnRpZXMgPSAoX3Byb3BlcnRpZXMgPSB7ICdjaGFydC5ndXR0ZXIubGVmdCc6IDc1LCAnY2hhcnQuZ3V0dGVyLmxlZnQuYXV0b3NpemUnOiBmYWxzZSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6ICcjZGRkJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCc6IDEsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnOiAyNSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6IDI1LCAnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMic6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYm9yZGVyJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0JzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0LmFsaWduJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bWhsaW5lcyc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW12bGluZXMnOiA1LCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRhc2hlZCc6IGZhbHNlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRvdHRlZCc6IGZhbHNlLCAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6IG51bGwsICdjaGFydC5saW5ld2lkdGgnOiAxLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMnOiAnJywgJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueGF4aXMuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzJzogJycsICdjaGFydC50aXRsZS55YXhpcy5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLnlheGlzLnNpemUnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5jb2xvcic6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy5wb3MnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMucG9zJzogMC44LCAnY2hhcnQudGl0bGUueWF4aXMueCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy5jb2xvcic6IG51bGwsICdjaGFydC50aXRsZS5ocG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLngnOiBudWxsLCAnY2hhcnQudGl0bGUueSc6IG51bGwsICdjaGFydC50aXRsZS5oYWxpZ24nOiBudWxsLCAnY2hhcnQudGl0bGUudmFsaWduJzogbnVsbCwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5jb2xvcnMnOiBbJ3JlZCcsICdibHVlJywgJ2dyZWVuJywgJ3BpbmsnLCAneWVsbG93JywgJ2N5YW4nLCAnbmF2eScsICdncmF5JywgJ2JsYWNrJ10sICdjaGFydC5jb2xvcnMuc2VxdWVudGlhbCc6IGZhbHNlLCAnY2hhcnQueGxhYmVscy5zcGVjaWZpYyc6IG51bGwsICdjaGFydC5sYWJlbHMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5ib2xkJzogZmFsc2UsICdjaGFydC5sYWJlbHMuY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlJzogZmFsc2UsICdjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnOiAwLCAnY2hhcnQubGFiZWxzLmFib3ZlLnNwZWNpZmljJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5jb2xvcic6IG51bGwsICdjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucHJlJzogJycsICdjaGFydC5sYWJlbHMuYWJvdmUudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlLmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5pdGFsaWMnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5vZmZzZXR4JzogMCwgJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzogMCwgJ2NoYXJ0LnhsYWJlbHMub2Zmc2V0eCc6IDAsICdjaGFydC54bGFiZWxzLm9mZnNldHknOiAwLCAnY2hhcnQueGxhYmVscyc6IHRydWUsICdjaGFydC54bGFiZWxzLmNvdW50JzogNSwgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LmtleSc6IG51bGwsICdjaGFydC5rZXkuYmFja2dyb3VuZCc6ICd3aGl0ZScsICdjaGFydC5rZXkucG9zaXRpb24nOiAnZ3JhcGgnLCAnY2hhcnQua2V5LmhhbGlnbic6ICdyaWdodCcsICdjaGFydC5rZXkuc2hhZG93JzogZmFsc2UsICdjaGFydC5rZXkuc2hhZG93LmNvbG9yJzogJyM2NjYnLCAnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzogMywgJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCc6IDIsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknOiAyLCAnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6IGZhbHNlLCAnY2hhcnQua2V5LnBvc2l0aW9uLngnOiBudWxsLCAnY2hhcnQua2V5LnBvc2l0aW9uLnknOiBudWxsLCAnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzogJ3NxdWFyZScsICdjaGFydC5rZXkucm91bmRlZCc6IHRydWUsICdjaGFydC5rZXkubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmtleS5jb2xvcnMnOiBudWxsLCAnY2hhcnQua2V5LmludGVyYWN0aXZlJzogZmFsc2UsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSc6ICdibGFjaycsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOiAncmdiYSgyNTUsMCwwLDAuMiknLCAnY2hhcnQua2V5LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudW5pdHMucHJlJzogJycsICdjaGFydC51bml0cy5wb3N0JzogJycsICdjaGFydC51bml0cy5pbmdyYXBoJzogZmFsc2UsICdjaGFydC5zdHJva2VzdHlsZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LnhtaW4nOiAwLCAnY2hhcnQueG1heCc6IDAsICdjaGFydC5heGlzLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJyM2NjYnLCAnY2hhcnQuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQudm1hcmdpbic6IDIsICdjaGFydC52bWFyZ2luLmdyb3VwZWQnOiAyLCAnY2hhcnQuZ3JvdXBpbmcnOiAnZ3JvdXBlZCcsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5oaWdobGlnaHQuc3R5bGUnOiBudWxsLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0Lnpvb20uZmFjdG9yJzogMS41LCAnY2hhcnQuem9vbS5mYWRlLmluJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOiB0cnVlLCAnY2hhcnQuem9vbS5oZGlyJzogJ3JpZ2h0JywgJ2NoYXJ0Lnpvb20udmRpcic6ICdkb3duJywgJ2NoYXJ0Lnpvb20uZnJhbWVzJzogMjUsICdjaGFydC56b29tLmRlbGF5JzogMTYuNjY2LCAnY2hhcnQuem9vbS5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYWN0aW9uJzogJ3pvb20nLCAnY2hhcnQucmVzaXphYmxlJzogZmFsc2UsICdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCc6IFswLCAwXSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiBudWxsLCAnY2hhcnQuc2NhbGUuemVyb3N0YXJ0JzogdHJ1ZSwgJ2NoYXJ0Lm5vcmVkcmF3JzogZmFsc2UsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5ub3hheGlzJzogZmFsc2UsICdjaGFydC5ub3lheGlzJzogZmFsc2UsICdjaGFydC5ub2F4ZXMnOiBmYWxzZSwgJ2NoYXJ0Lm5veHRpY2ttYXJrcyc6IGZhbHNlLCAnY2hhcnQubm95dGlja21hcmtzJzogZmFsc2UsICdjaGFydC5udW15dGlja3MnOiBkYXRhLmxlbmd0aCwgJ2NoYXJ0Lm51bXh0aWNrcyc6IDEwLCAnY2hhcnQudmFyaWFudCc6ICdoYmFyJywgJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJzogMC4xLCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCc6IDEwLCAnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSc6IDUsICdjaGFydC52YXJpYW50LnRocmVlZC54YXhpcyc6IHRydWUsICdjaGFydC52YXJpYW50LnRocmVlZC55YXhpcyc6IHRydWUsICdjaGFydC55YXhpc3Bvcyc6ICdsZWZ0JyB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC52YXJpYW50JywgJ2hiYXInKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuY2xlYXJ0bycsICdyZ2JhKDAsMCwwLDApJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFkanVzdGFibGUnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFkanVzdGFibGUub25seScsIG51bGwpLCBfcHJvcGVydGllcyk7XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0hCQVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT0gJ29iamVjdCcgJiYgIVJHcmFwaC5pc051bGwodGhpcy5kYXRhW2ldKSkge1xuICAgICAgdGhpcy5zdGFja2VkT3JHcm91cGVkID0gdHJ1ZTtmb3IgKHZhciBqID0gMCwgbGVuMiA9IHRoaXMuZGF0YVtpXS5sZW5ndGg7IGogPCBsZW4yOyArK2opIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV1bal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW2ldW2pdID0gcGFyc2VGbG9hdCh0aGlzLmRhdGFbaV1bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBwYXJzZUZsb2F0KHRoaXMuZGF0YVtpXSkgfHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICB2YXIgbGluZWFyX2RhdGEgPSBSR3JhcGguYXJyYXlMaW5lYXJpemUoZGF0YSk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVhcl9kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGhpc1snJCcgKyBpXSA9IHt9O1xuICB9XG4gIHRoaXMuZGF0YV9hcnIgPSBSR3JhcGguYXJyYXlMaW5lYXJpemUodGhpcy5kYXRhKTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubGFiZWxzLmFib3ZlYmFyJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5sYWJlbHMuYWJvdmUnO1xuICAgIH1cbiAgICBwcm9wW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubGFiZWxzLmFib3ZlYmFyJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5sYWJlbHMuYWJvdmUnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddICYmIHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ10gPT09ICdzdGFja2VkJykge1xuICAgICAgYWxlcnQoJ1tSR1JBUEhdIFRoZSBIQmFyIGRvZXMgbm90IHN1cHBvcnQgc3RhY2tlZCBjaGFydHMgd2l0aCBhZGp1c3RpbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSddKSB7fSBlbHNlIHtcbiAgICAgICAgY28uc2V0VHJhbnNmb3JtKDEsIHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10sIDAsIDEsIDAuNSwgMC41KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10gPT09IDI1KSB7XG4gICAgICAgIHRoaXMuc2V0KCdndXR0ZXJCb3R0b20nLCA4MCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ndXR0ZXIubGVmdC5hdXRvc2l6ZSddKSB7XG4gICAgICB2YXIgbGVuID0gMDt2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzJ107dmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO2ZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBSRy5tZWFzdXJlVGV4dChsYWJlbHNbaV0sIGZhbHNlLCBmb250LCBzaXplKVswXSB8fCAwO1xuICAgICAgICBsZW4gPSBtYS5tYXgobGVuLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSA9IGxlbiArIDEwO1xuICAgIH1cbiAgICB0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMubWF4ID0gMDtpZiAocHJvcFsnY2hhcnQueG1pbiddID4gMCAmJiBwcm9wWydjaGFydC5ncm91cGluZyddID09ICdzdGFja2VkJykge1xuICAgICAgYWxlcnQoJ1tIQkFSXSBVc2luZyBjaGFydC54bWluIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCBzdGFja2VkIGNoYXJ0cywgcmVzZXR0aW5nIGNoYXJ0LnhtaW4gdG8gemVybycpO3RoaXMuU2V0KCdjaGFydC54bWluJywgMCk7XG4gICAgfVxuICAgIHRoaXMuZ3JhcGh3aWR0aCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDt0aGlzLmdyYXBoaGVpZ2h0ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbTt0aGlzLmhhbGZncmFwaGFyZWEgPSB0aGlzLmdyYXBoYXJlYSAvIDI7dGhpcy5oYWxmVGV4dEhlaWdodCA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddIC8gMjt0aGlzLmhhbGZ3YXkgPSBtYS5yb3VuZCh0aGlzLmdyYXBod2lkdGggLyAyICsgdGhpcy5ndXR0ZXJMZWZ0KTtcbiAgICBSRy5CYWNrZ3JvdW5kLmRyYXcodGhpcyk7dGhpcy5kcmF3YmFycygpO3RoaXMuZHJhd0F4ZXMoKTt0aGlzLmRyYXdMYWJlbHMoKTtpZiAocHJvcFsnY2hhcnQua2V5J10gJiYgcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoKSB7XG4gICAgICBSRy5EcmF3S2V5KHRoaXMsIHByb3BbJ2NoYXJ0LmtleSddLCBwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgUkcuRHJhd0luR3JhcGhMYWJlbHModGhpcyk7aWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3QXhlcyA9IHRoaXMuRHJhd0F4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbGZ3YXkgPSB0aGlzLmhhbGZ3YXk7XG4gICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSA/IHByb3BbJ2NoYXJ0LmF4aXMubGluZXdpZHRoJ10gKyAwLjAwMSA6IDEuMDAxO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO2lmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UgJiYgcHJvcFsnY2hhcnQubm9heGVzJ10gPT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgIGNvLm1vdmVUbyhoYWxmd2F5LCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGhhbGZ3YXksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnKSB7XG4gICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm5vYXhlcyddID09IGZhbHNlKSB7XG4gICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0ICsgMC4wMDEsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMC4wMDEpO2NvLmxpbmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyAwLjAwMSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyAwLjAwMSk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ub3l0aWNrbWFya3MnXSA9PSBmYWxzZSAmJiBwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UgJiYgcHJvcFsnY2hhcnQubnVteXRpY2tzJ10gPiAwICYmIHByb3BbJ2NoYXJ0Lm5vYXhlcyddID09IGZhbHNlKSB7XG4gICAgICB2YXIgeVRpY2tHYXAgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAocHJvcFsnY2hhcnQubnVteXRpY2tzJ10gPiAwID8gcHJvcFsnY2hhcnQubnVteXRpY2tzJ10gOiB0aGlzLmRhdGEubGVuZ3RoKTtmb3IgKHkgPSB0aGlzLmd1dHRlclRvcDsgeSA8IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gMTsgeSArPSB5VGlja0dhcCkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGNvLm1vdmVUbyhoYWxmd2F5ICsgMywgbWEucm91bmQoeSkpO2NvLmxpbmVUbyhoYWxmd2F5IC0gMywgbWEucm91bmQoeSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIG1hLnJvdW5kKHkpKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgMywgbWEucm91bmQoeSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsIG1hLnJvdW5kKHkpKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0IC0gMywgbWEucm91bmQoeSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IHRydWUpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBjby5tb3ZlVG8oaGFsZndheSArIDMsIG1hLnJvdW5kKHkpKTtjby5saW5lVG8oaGFsZndheSAtIDMsIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdyaWdodCcpIHtcbiAgICAgICAgICBjby5tb3ZlVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCBtYS5yb3VuZCh5KSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDMsIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZCh5KSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCAtIDMsIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubm94dGlja21hcmtzJ10gPT0gZmFsc2UgJiYgcHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID4gMCAmJiBwcm9wWydjaGFydC5ub2F4ZXMnXSA9PSBmYWxzZSkge1xuICAgICAgeFRpY2tHYXAgPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO3lTdGFydCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tO3lFbmQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIDM7dmFyIGkgPSBwcm9wWydjaGFydC5udW14dGlja3MnXTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSBpICogeFRpY2tHYXA7aWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB4IC09IHhUaWNrR2FwO1xuICAgICAgICB9XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4KSwgeVN0YXJ0KTtjby5saW5lVG8obWEucm91bmQoeCksIHlFbmQpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciBpID0gNTt3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdmFyIHggPSB0aGlzLmd1dHRlckxlZnQgKyB4VGlja0dhcCAqIGk7Y28ubW92ZVRvKG1hLnJvdW5kKHgpLCB5U3RhcnQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSwgeUVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gdHJ1ZSkge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZCh5U3RhcnQpKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZCh5RW5kKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aCA9IDE7XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSxcbiAgICAgICAgdW5pdHNfcG9zdCA9IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxcbiAgICAgICAgdGV4dF9zaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LnhsYWJlbHMub2Zmc2V0eCddLFxuICAgICAgICBvZmZzZXR5ID0gcHJvcFsnY2hhcnQueGxhYmVscy5vZmZzZXR5J107XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnVuaXRzLmluZ3JhcGgnXSkge1xuICAgICAgdW5pdHNfcHJlID0gJyc7dW5pdHNfcG9zdCA9ICcnO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQueGxhYmVscyddKSB7XG4gICAgICBpZiAoUkcuaXNBcnJheShwcm9wWydjaGFydC54bGFiZWxzLnNwZWNpZmljJ10pKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdmFyIGhhbGZHcmFwaFdpZHRoID0gdGhpcy5ncmFwaHdpZHRoIC8gMjt2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQueGxhYmVscy5zcGVjaWZpYyddO3ZhciBpbnRlcnZhbCA9IHRoaXMuZ3JhcGh3aWR0aCAvIDIgLyAobGFiZWxzLmxlbmd0aCAtIDEpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIGhhbGZHcmFwaFdpZHRoICsgaW50ZXJ2YWwgKiBpICsgb2Zmc2V0eCwgJ3knOiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIG9mZnNldHgsICd0ZXh0JzogbGFiZWxzW2ldLCAndmFsaWduJzogJ3RvcCcsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIGludGVydmFsICogKGxhYmVscy5sZW5ndGggLSBpIC0gMSkgKyBvZmZzZXR4LCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgb2Zmc2V0eSwgJ3RleHQnOiBsYWJlbHNbaV0sICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LnhsYWJlbHMuc3BlY2lmaWMnXTt2YXIgaW50ZXJ2YWwgPSB0aGlzLmdyYXBod2lkdGggLyAobGFiZWxzLmxlbmd0aCAtIDEpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIGludGVydmFsICogaSArIG9mZnNldHgsICd5JzogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBvZmZzZXR5LCAndGV4dCc6IGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gaSAtIDFdLCAndmFsaWduJzogJ3RvcCcsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYWJlbHMgPSBwcm9wWydjaGFydC54bGFiZWxzLnNwZWNpZmljJ107dmFyIGludGVydmFsID0gdGhpcy5ncmFwaHdpZHRoIC8gKGxhYmVscy5sZW5ndGggLSAxKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogdGV4dF9zaXplLCB4OiB0aGlzLmd1dHRlckxlZnQgKyBpbnRlcnZhbCAqIGkgKyBvZmZzZXR4LCB5OiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIG9mZnNldHksIHRleHQ6IGxhYmVsc1tpXSwgdmFsaWduOiAndG9wJywgaGFsaWduOiAnY2VudGVyJywgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGdhcCA9IDc7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmdyYXBod2lkdGggLyAyIC0gdGhpcy5ncmFwaHdpZHRoIC8gMiAqICgoaSArIDEpIC8gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmVGV4dEhlaWdodCArIHRoaXMuZ3JhcGhoZWlnaHQgKyBnYXAgKyBvZmZzZXR5LCAndGV4dCc6ICctJyArIHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuZ3JhcGh3aWR0aCAvIDIgKiAoKGkgKyAxKSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpICsgdGhpcy5ncmFwaHdpZHRoIC8gMiArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZUZXh0SGVpZ2h0ICsgdGhpcy5ncmFwaGhlaWdodCArIGdhcCArIG9mZnNldHksICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB0aGlzLmd1dHRlckxlZnQgKyBpICogKHRoaXMuZ3JhcGh3aWR0aCAvIGxlbikgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmVGV4dEhlaWdodCArIHRoaXMuZ3JhcGhoZWlnaHQgKyBnYXAgKyBvZmZzZXR5LCAndGV4dCc6ICctJyArIHRoaXMuc2NhbGUyLmxhYmVsc1tsZW4gLSAxIC0gaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMuZ3JhcGh3aWR0aCAqICgoaSArIDEpIC8gbGVuKSArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZUZXh0SGVpZ2h0ICsgdGhpcy5ncmFwaGhlaWdodCArIGdhcCArIG9mZnNldHksICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWydjaGFydC54bWluJ10gPiAwIHx8IHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSA9PSB0cnVlIHx8IHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddIHx8IHByb3BbJ2NoYXJ0Lm5vYXhlcyddKSB7XG4gICAgICAgICAgdmFyIHggPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdjZW50ZXInID8gdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy5ncmFwaHdpZHRoIC8gMiA6IHRoaXMuZ3V0dGVyTGVmdDtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdmFyIHggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4ICsgb2Zmc2V0eCwgJ3knOiB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZlRleHRIZWlnaHQgKyB0aGlzLmdyYXBoaGVpZ2h0ICsgZ2FwICsgb2Zmc2V0eSwgJ3RleHQnOiBSRy5udW1iZXJGb3JtYXQodGhpcywgcHJvcFsnY2hhcnQueG1pbiddLnRvRml4ZWQocHJvcFsnY2hhcnQueG1pbiddID09PSAwID8gMCA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY28uZmlsbCgpO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3R5cGVvZihwcm9wWydjaGFydC5sYWJlbHMnXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciB4T2Zmc2V0ID0gcHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcgPyAxNSA6IDUsXG4gICAgICAgICAgZm9udCA9IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLFxuICAgICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddLFxuICAgICAgICAgIGJvbGQgPSBwcm9wWydjaGFydC5sYWJlbHMuYm9sZCddLFxuICAgICAgICAgIG9mZnNldHggPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddLFxuICAgICAgICAgIG9mZnNldHkgPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddO1xuICAgICAgY28uZmlsbFN0eWxlID0gY29sb3I7dmFyIGJhckhlaWdodCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aDt5VGlja0dhcCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aDtcbiAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAncmlnaHQnKSB7XG4gICAgICAgIHZhciB4ID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgeE9mZnNldDt2YXIgaGFsaWduID0gJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmd1dHRlckxlZnQgLSB4T2Zmc2V0O3ZhciBoYWxpZ24gPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAwO2ZvciAoeSA9IHRoaXMuZ3V0dGVyVG9wICsgeVRpY2tHYXAgLyAyOyB5IDw9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tOyB5ICs9IHlUaWNrR2FwKSB7XG4gICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLCAnYm9sZCc6IGJvbGQsICd4JzogeCArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd0ZXh0JzogU3RyaW5nKHByb3BbJ2NoYXJ0LmxhYmVscyddW2krK10pLCAnaGFsaWduJzogaGFsaWduLCAndmFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnbGFiZWxzJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3YmFycyA9IHRoaXMuRHJhd2JhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO3ZhciBwcmV2WCA9IDAsXG4gICAgICAgIHByZXZZID0gMDtpZiAocHJvcFsnY2hhcnQueG1heCddKSB7XG4gICAgICB0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiBwcm9wWydjaGFydC54bWF4J10sICdtaW4nOiBwcm9wWydjaGFydC54bWluJ10sICdzY2FsZS5kZWNpbWFscyc6IE51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC54bGFiZWxzLmNvdW50J10sICdzdHJpY3QnOiB0cnVlIH0pO3RoaXMubWF4ID0gdGhpcy5zY2FsZTIubWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ3JvdXBpbmcgPSBwcm9wWydjaGFydC5ncm91cGluZyddO2ZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdyb3VwaW5nID09ICdncm91cGVkJyA/IE51bWJlcihSRy5hcnJheV9tYXgodGhpcy5kYXRhW2ldLCB0cnVlKSkgOiBOdW1iZXIoUkcuYXJyYXlfc3VtKHRoaXMuZGF0YVtpXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihtYS5hYnModGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXggPSBtYS5tYXgoTWF0aC5hYnModGhpcy5tYXgpLCBNYXRoLmFicyh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyAnbWF4JzogdGhpcy5tYXgsICdtaW4nOiBwcm9wWydjaGFydC54bWluJ10sICdzY2FsZS5kZWNpbWFscyc6IE51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC54bGFiZWxzLmNvdW50J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlMi5taW47XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddID09IG51bGwgJiYgTnVtYmVyKHRoaXMubWF4KSA9PSAxKSB7XG4gICAgICB0aGlzLlNldCgnY2hhcnQuc2NhbGUuZGVjaW1hbHMnLCAxKTtcbiAgICB9XG4gICAgdmFyIGNvbG9ySWR4ID0gMDt0aGlzLm51bWJhcnMgPSBSRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLmxlbmd0aDtpZiAocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddICYmICFwcm9wWydjaGFydC54bWF4J10pIHtcbiAgICAgIHRoaXMuc2V0KCdjaGFydC54bWF4JywgdGhpcy5zY2FsZTIubWF4KTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgUkcuZHJhdzNEQXhlcyh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGdyYXBod2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dmFyIGhhbGZ3aWR0aCA9IGdyYXBod2lkdGggLyAyO2ZvciAoaSA9IGxlbiA9IHRoaXMuZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHdpZHRoID0gbWEuYWJzKHRoaXMuZGF0YVtpXSAvIHRoaXMubWF4ICogZ3JhcGh3aWR0aCk7dmFyIGhlaWdodCA9IHRoaXMuZ3JhcGhoZWlnaHQgLyB0aGlzLmRhdGEubGVuZ3RoO3ZhciBvcmlnX2hlaWdodCA9IGhlaWdodDt2YXIgeCA9IHRoaXMuZ3V0dGVyTGVmdDt2YXIgeSA9IHRoaXMuZ3V0dGVyVG9wICsgaSAqIGhlaWdodDt2YXIgdm1hcmdpbiA9IHByb3BbJ2NoYXJ0LnZtYXJnaW4nXTtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gbWEuYWJzKHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgeCAtPSB3aWR0aDt3aWR0aCA9IG1hLmFicyh3aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgY28uc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtjby5zaGFkb3dCbHVyID0gcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXTtjby5zaGFkb3dPZmZzZXRYID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXTtcbiAgICAgIH1cbiAgICAgIGNvLmJlZ2luUGF0aCgpO2lmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09ICdudW1iZXInIHx8IFJHLmlzTnVsbCh0aGlzLmRhdGFbaV0pKSB7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSBoZWlnaHQgLSAyICogdm1hcmdpbixcbiAgICAgICAgICAgIGJhcldpZHRoID0gKHRoaXMuZGF0YVtpXSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgLyAodGhpcy5tYXggLSBwcm9wWydjaGFydC54bWluJ10pICogdGhpcy5ncmFwaHdpZHRoLFxuICAgICAgICAgICAgYmFyWCA9IHRoaXMuZ3V0dGVyTGVmdDtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGJhcldpZHRoIC89IDI7YmFyWCArPSBoYWxmd2lkdGg7aWYgKHRoaXMuZGF0YVtpXSA8IDApIHtcbiAgICAgICAgICAgIGJhcldpZHRoID0gKG1hLmFicyh0aGlzLmRhdGFbaV0pIC0gcHJvcFsnY2hhcnQueG1pbiddKSAvICh0aGlzLm1heCAtIHByb3BbJ2NoYXJ0LnhtaW4nXSk7YmFyV2lkdGggPSBiYXJXaWR0aCAqICh0aGlzLmdyYXBod2lkdGggLyAyKTtiYXJYID0gdGhpcy5ncmFwaHdpZHRoIC8gMiArIHRoaXMuZ3V0dGVyTGVmdCAtIGJhcldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdyaWdodCcpIHtcbiAgICAgICAgICBiYXJXaWR0aCA9IG1hLmFicyhiYXJXaWR0aCk7YmFyWCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIGJhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVswXTsrK2NvbG9ySWR4O2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddICYmIHR5cGVvZiBjb2xvcklkeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzIC0gY29sb3JJZHhdKSB7XG4gICAgICAgICAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVt0aGlzLm51bWJhcnMgLSBjb2xvcklkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW3Byb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2VSZWN0KGJhclgsIHRoaXMuZ3V0dGVyVG9wICsgaSAqIGhlaWdodCArIHByb3BbJ2NoYXJ0LnZtYXJnaW4nXSwgYmFyV2lkdGgsIGJhckhlaWdodCk7Y28uZmlsbFJlY3QoYmFyWCwgdGhpcy5ndXR0ZXJUb3AgKyBpICogaGVpZ2h0ICsgcHJvcFsnY2hhcnQudm1hcmdpbiddLCBiYXJXaWR0aCwgYmFySGVpZ2h0KTt0aGlzLmNvb3Jkcy5wdXNoKFtiYXJYLCB5ICsgdm1hcmdpbiwgYmFyV2lkdGgsIGhlaWdodCAtIDIgKiB2bWFyZ2luLCBjby5maWxsU3R5bGUsIHRoaXMuZGF0YVtpXSwgdHJ1ZV0pO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcgJiYgdHlwZW9mIHRoaXMuZGF0YVtpXSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBwcmV2U3Ryb2tlU3R5bGUgPSBjby5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgcHJldkZpbGxTdHlsZSA9IGNvLmZpbGxTdHlsZTtSRy5ub1NoYWRvdyh0aGlzKTt2YXIgYmFyWCA9IGJhclgsXG4gICAgICAgICAgICAgIGJhclkgPSB5ICsgdm1hcmdpbixcbiAgICAgICAgICAgICAgYmFyVyA9IGJhcldpZHRoLFxuICAgICAgICAgICAgICBiYXJIID0gaGVpZ2h0IC0gMiAqIHZtYXJnaW4sXG4gICAgICAgICAgICAgIG9mZnNldFggPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sXG4gICAgICAgICAgICAgIG9mZnNldFkgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10sXG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kYXRhW2ldO3BhMihjbywgWydiJywgJ20nLCBiYXJYLCBiYXJZLCAnbCcsIGJhclggKyBvZmZzZXRYIC0gKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnICYmIHZhbHVlIDwgMCA/IG9mZnNldFggOiAwKSwgYmFyWSAtIG9mZnNldFksICdsJywgYmFyWCArIGJhclcgKyBvZmZzZXRYIC0gKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2NlbnRlcicgJiYgdmFsdWUgPCAwID8gb2Zmc2V0WCA6IDApLCBiYXJZIC0gb2Zmc2V0WSwgJ2wnLCBiYXJYICsgYmFyVywgYmFyWSwgJ2MnLCAncycsIGNvLnN0cm9rZVN0eWxlLCAnZicsIGNvLmZpbGxTdHlsZSwgJ2YnLCAncmdiYSgyNTUsMjU1LDI1NSwwLjYpJ10pO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddICE9PSAncmlnaHQnICYmICEocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PT0gJ2NlbnRlcicgJiYgdmFsdWUgPCAwKSAmJiB2YWx1ZSA+PSAwICYmICFSRy5pc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICBwYTIoY28sIFsnYicsICdmcycsIHByZXZGaWxsU3R5bGUsICdtJywgYmFyWCArIGJhclcsIGJhclksICdsJywgYmFyWCArIGJhclcgKyBvZmZzZXRYLCBiYXJZIC0gb2Zmc2V0WSwgJ2wnLCBiYXJYICsgYmFyVyArIG9mZnNldFgsIGJhclkgLSBvZmZzZXRZICsgYmFySCwgJ2wnLCBiYXJYICsgYmFyVywgYmFyWSArIGJhckgsICdjJywgJ3MnLCBjby5zdHJva2VTdHlsZSwgJ2YnLCBwcmV2RmlsbFN0eWxlLCAnZicsICdyZ2JhKDAsMCwwLDAuMjUpJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBhbGVydCgnW0hCQVJdIFlvdSBjYW5cXCd0IGhhdmUgYSBzdGFja2VkIGNoYXJ0IHdpdGggdGhlIFkgYXhpcyBpbiB0aGUgY2VudGVyLCBjaGFuZ2UgaXQgdG8gZ3JvdXBlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHZhciB4ID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSBoZWlnaHQgLSAyICogdm1hcmdpbjtpZiAodHlwZW9mIHRoaXMuY29vcmRzMltpXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29vcmRzMltpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10gJiYgcHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnKSB7XG4gICAgICAgICAgICBjby5zaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddO2NvLnNoYWRvd0JsdXIgPSBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFggPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVJHLmlzTnVsbCh0aGlzLmRhdGFbaV1bal0pKSB0aGlzLmRhdGFbaV1bal0gPSBtYS5hYnModGhpcy5kYXRhW2ldW2pdKTt2YXIgbGFzdCA9IGogPT09IHRoaXMuZGF0YVtpXS5sZW5ndGggLSAxO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTsrK2NvbG9ySWR4O2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddICYmIHR5cGVvZiBjb2xvcklkeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMnXVt0aGlzLm51bWJhcnMgLSBjb2xvcklkeF0pIHtcbiAgICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzIC0gY29sb3JJZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bcHJvcFsnY2hhcnQuY29sb3JzJ10ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5jb2xvcnMnXVtqXSkge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bal07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZGF0YVtpXVtqXSAvIHRoaXMubWF4ICogdGhpcy5ncmFwaHdpZHRoO3ZhciB0b3RhbFdpZHRoID0gUkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSAvIHRoaXMubWF4ICogdGhpcy5ncmFwaHdpZHRoO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5zdHJva2VSZWN0KHgsIHRoaXMuZ3V0dGVyVG9wICsgcHJvcFsnY2hhcnQudm1hcmdpbiddICsgdGhpcy5ncmFwaGhlaWdodCAvIHRoaXMuZGF0YS5sZW5ndGggKiBpLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIHZtYXJnaW4pO2NvLmZpbGxSZWN0KHgsIHRoaXMuZ3V0dGVyVG9wICsgcHJvcFsnY2hhcnQudm1hcmdpbiddICsgdGhpcy5ncmFwaGhlaWdodCAvIHRoaXMuZGF0YS5sZW5ndGggKiBpLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIHZtYXJnaW4pO3RoaXMuY29vcmRzLnB1c2goW3gsIHkgKyB2bWFyZ2luLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIHZtYXJnaW4sIGNvLmZpbGxTdHlsZSwgUkcuYXJyYXlfc3VtKHRoaXMuZGF0YVtpXSksIGogPT0gdGhpcy5kYXRhW2ldLmxlbmd0aCAtIDFdKTt0aGlzLmNvb3JkczJbaV0ucHVzaChbeCwgeSArIHZtYXJnaW4sIHdpZHRoLCBoZWlnaHQgLSAyICogdm1hcmdpbiwgY28uZmlsbFN0eWxlLCBSRy5hcnJheV9zdW0odGhpcy5kYXRhW2ldKSwgaiA9PSB0aGlzLmRhdGFbaV0ubGVuZ3RoIC0gMV0pO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT09ICczZCcpIHtcbiAgICAgICAgICAgIFJHLm5vU2hhZG93KHRoaXMpO3ZhciBwcmV2U3Ryb2tlU3R5bGUgPSBjby5zdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICBwcmV2RmlsbFN0eWxlID0gY28uZmlsbFN0eWxlO3ZhciBiYXJYID0geCxcbiAgICAgICAgICAgICAgICBiYXJZID0geSArIHZtYXJnaW4sXG4gICAgICAgICAgICAgICAgYmFyVyA9IHdpZHRoLFxuICAgICAgICAgICAgICAgIGJhckggPSBoZWlnaHQgLSAyICogdm1hcmdpbixcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eCddLFxuICAgICAgICAgICAgICAgIG9mZnNldFkgPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR5J10sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRhdGFbaV1bal07aWYgKCFSRy5pc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHBhMihjbywgWydiJywgJ20nLCBiYXJYLCBiYXJZLCAnbCcsIGJhclggKyBvZmZzZXRYLCBiYXJZIC0gb2Zmc2V0WSwgJ2wnLCBiYXJYICsgYmFyVyArIG9mZnNldFgsIGJhclkgLSBvZmZzZXRZLCAnbCcsIGJhclggKyBiYXJXLCBiYXJZLCAnYycsICdzJywgY28uc3Ryb2tlU3R5bGUsICdmJywgY28uZmlsbFN0eWxlLCAnZicsICdyZ2JhKDI1NSwyNTUsMjU1LDAuNiknXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSAhPT0gJ3JpZ2h0JyAmJiAhKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdjZW50ZXInICYmIHZhbHVlIDwgMCkgJiYgIVJHLmlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcGEyKGNvLCBbJ2ZzJywgcHJldkZpbGxTdHlsZSwgJ2InLCAnbScsIGJhclggKyBiYXJXLCBiYXJZLCAnbCcsIGJhclggKyBiYXJXICsgb2Zmc2V0WCwgYmFyWSAtIG9mZnNldFksICdsJywgYmFyWCArIGJhclcgKyBvZmZzZXRYLCBiYXJZIC0gb2Zmc2V0WSArIGJhckgsICdsJywgYmFyWCArIGJhclcsIGJhclkgKyBiYXJILCAnYycsICdzJywgY28uc3Ryb2tlU3R5bGUsICdmJywgcHJldkZpbGxTdHlsZSwgJ2YnLCAncmdiYSgwLDAsMCwwLjI1KSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJldlN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZSA9IHByZXZGaWxsU3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddICE9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB4ICs9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgdmFyIHZtYXJnaW5Hcm91cGVkID0gcHJvcFsnY2hhcnQudm1hcmdpbi5ncm91cGVkJ107dmFyIGluZGl2aWR1YWxCYXJIZWlnaHQgPSAoaGVpZ2h0IC0gMiAqIHZtYXJnaW4gLSAodGhpcy5kYXRhW2ldLmxlbmd0aCAtIDEpICogdm1hcmdpbkdyb3VwZWQpIC8gdGhpcy5kYXRhW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvb3JkczJbaV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmNvb3JkczJbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSB0aGlzLmRhdGFbaV0ubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgICAgIFJHLnNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTsrK2NvbG9ySWR4O2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddICYmIHR5cGVvZiBjb2xvcklkeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMnXVt0aGlzLm51bWJhcnMgLSBjb2xvcklkeF0pIHtcbiAgICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bdGhpcy5udW1iYXJzIC0gY29sb3JJZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bcHJvcFsnY2hhcnQuY29sb3JzJ10ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5jb2xvcnMnXVtqXSkge1xuICAgICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bal07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydFkgPSB0aGlzLmd1dHRlclRvcCArIGhlaWdodCAqIGkgKyBpbmRpdmlkdWFsQmFySGVpZ2h0ICogaiArIHZtYXJnaW4gKyB2bWFyZ2luR3JvdXBlZCAqIGo7dmFyIHdpZHRoID0gKHRoaXMuZGF0YVtpXVtqXSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgLyAodGhpcy5tYXggLSBwcm9wWydjaGFydC54bWluJ10pICogKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCk7dmFyIHN0YXJ0WCA9IHRoaXMuZ3V0dGVyTGVmdDtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgd2lkdGggLz0gMjtzdGFydFggKz0gaGFsZndpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG1hLmFicyh3aWR0aCk7c3RhcnRYID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gbWEuYWJzKHdpZHRoKTs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0WCArPSB3aWR0aDt3aWR0aCAqPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY28uc3Ryb2tlUmVjdChzdGFydFgsIHN0YXJ0WSwgd2lkdGgsIGluZGl2aWR1YWxCYXJIZWlnaHQpO2NvLmZpbGxSZWN0KHN0YXJ0WCwgc3RhcnRZLCB3aWR0aCwgaW5kaXZpZHVhbEJhckhlaWdodCk7dGhpcy5jb29yZHMucHVzaChbc3RhcnRYLCBzdGFydFksIHdpZHRoLCBpbmRpdmlkdWFsQmFySGVpZ2h0LCBjby5maWxsU3R5bGUsIHRoaXMuZGF0YVtpXVtqXSwgdHJ1ZV0pO3RoaXMuY29vcmRzMltpXS5wdXNoKFtzdGFydFgsIHN0YXJ0WSwgd2lkdGgsIGluZGl2aWR1YWxCYXJIZWlnaHQsIGNvLmZpbGxTdHlsZSwgdGhpcy5kYXRhW2ldW2pdLCB0cnVlXSk7aWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PT0gJzNkJykge1xuICAgICAgICAgICAgUkcubm9TaGFkb3codGhpcyk7dmFyIHByZXZTdHJva2VTdHlsZSA9IGNvLnN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgICAgIHByZXZGaWxsU3R5bGUgPSBjby5maWxsU3R5bGU7dmFyIGJhclggPSBzdGFydFgsXG4gICAgICAgICAgICAgICAgYmFyWSA9IHN0YXJ0WSxcbiAgICAgICAgICAgICAgICBiYXJXID0gd2lkdGgsXG4gICAgICAgICAgICAgICAgYmFySCA9IGluZGl2aWR1YWxCYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLm9mZnNldHgnXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQub2Zmc2V0eSddLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kYXRhW2ldW2pdO3BhMihjbywgWydiJywgJ20nLCBiYXJYLCBiYXJZLCAnbCcsIGJhclggKyBvZmZzZXRYLCBiYXJZIC0gb2Zmc2V0WSwgJ2wnLCBiYXJYICsgYmFyVyArIG9mZnNldFggLSAodmFsdWUgPCAwID8gb2Zmc2V0WCA6IDApLCBiYXJZIC0gb2Zmc2V0WSwgJ2wnLCBiYXJYICsgYmFyVywgYmFyWSwgJ2MnLCAncycsIGNvLnN0cm9rZVN0eWxlLCAnZicsIGNvLmZpbGxTdHlsZSwgJ2YnLCAncmdiYSgyNTUsMjU1LDI1NSwwLjYpJ10pO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddICE9PSAncmlnaHQnICYmICEocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PT0gJ2NlbnRlcicgJiYgdmFsdWUgPCAwKSAmJiB2YWx1ZSA+PSAwICYmICFSRy5pc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHBhMihjbywgWydmcycsIHByZXZGaWxsU3R5bGUsICdiJywgJ20nLCBiYXJYICsgYmFyVywgYmFyWSwgJ2wnLCBiYXJYICsgYmFyVyArIG9mZnNldFgsIGJhclkgLSBvZmZzZXRZLCAnbCcsIGJhclggKyBiYXJXICsgb2Zmc2V0WCwgYmFyWSAtIG9mZnNldFkgKyBiYXJILCAnbCcsIGJhclggKyBiYXJXLCBiYXJZICsgYmFySCwgJ2MnLCAncycsIGNvLnN0cm9rZVN0eWxlLCAnZicsIHByZXZGaWxsU3R5bGUsICdmJywgJ3JnYmEoMCwwLDAsMC4yNSknXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByZXZTdHJva2VTdHlsZTtjby5maWxsU3R5bGUgPSBwcmV2RmlsbFN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydFkgKz0gdm1hcmdpbjtcbiAgICAgIH1cbiAgICAgIGNvLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjby5zdHJva2UoKTtjby5maWxsKCk7aWYgKHByb3BbJ2NoYXJ0LHlheGlzcG9zJ10gPT09ICdyaWdodCcpIHtcbiAgICAgIHBhMihjbywgJ2NyICUgJSAlICUnLCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5vZmZzZXR4J10sICcwJywgdGhpcy5ndXR0ZXJSaWdodCwgY2EuaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcgJiYgcHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnKSB7XG4gICAgICBSRy5kcmF3M0RZQXhpcyh0aGlzKTtcbiAgICB9XG4gICAgUkcubm9TaGFkb3codGhpcyk7dGhpcy5jb29yZHMgPSBSRy5hcnJheVJldmVyc2UodGhpcy5jb29yZHMpO2lmIChwcm9wWydjaGFydC5ncm91cGluZyddID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuY29vcmRzMltpXSA9IFJHLmFycmF5UmV2ZXJzZSh0aGlzLmNvb3JkczJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZHJhd0JhcnMoKTtcbiAgfTt0aGlzLnJlZHJhd0JhcnMgPSB0aGlzLlJlZHJhd0JhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm5vcmVkcmF3J10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgY29sb3IgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Ukcubm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2ZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgcGEyKGNvLCAnYiBsdyAlIHIgJSAlICUgJSBzICUgZiAlJywgcHJvcFsnY2hhcnQubGluZXdpZHRoJ10sIGNvb3Jkc1tpXVswXSwgY29vcmRzW2ldWzFdLCBjb29yZHNbaV1bMl0sIGNvb3Jkc1tpXVszXSwgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSwgY29vcmRzW2ldWzRdKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYWxpZ24gPSAnbGVmdCc7aWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddICYmIGNvb3Jkc1tpXVs2XSkge1xuICAgICAgICB2YXIgYm9yZGVyID0gY29vcmRzW2ldWzBdICsgY29vcmRzW2ldWzJdICsgNyArIGNvLm1lYXN1cmVUZXh0KHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wcmUnXSArIHRoaXMuY29vcmRzW2ldWzVdICsgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnXSkud2lkdGggPiBjYS53aWR0aCA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHQgPSBSRy5udW1iZXJGb3JtYXQodGhpcywgdGhpcy5jb29yZHNbaV1bNV0udG9GaXhlZChwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnXSksIHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS51bml0cy5wcmUnXSwgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnXSk7Ukcubm9TaGFkb3codGhpcyk7aWYgKF90eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnNwZWNpZmljJ10pID09PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXSAmJiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXVtpXSkge1xuICAgICAgICAgIHRleHQgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXVtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGNvb3Jkc1tpXVswXSArIGNvb3Jkc1tpXVsyXSArIDU7dmFyIHkgPSBjb29yZHNbaV1bMV0gKyBjb29yZHNbaV1bM10gLyAyO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgeCA9IGNvb3Jkc1tpXVswXSAtIDU7aGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAnY2VudGVyJyAmJiB0aGlzLmRhdGFfYXJyW2ldIDwgMCkge1xuICAgICAgICAgIHggPSBjb29yZHNbaV1bMF0gLSA1O2hhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgUkcudGV4dDIodGhpcywgeyBmb250OiB0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnXSA9PT0gJ3N0cmluZycgPyBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZm9udCddIDogZm9udCwgc2l6ZTogdHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5zaXplJ10gPT09ICdudW1iZXInID8gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnNpemUnXSA6IHNpemUsIGNvbG9yOiB0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmNvbG9yJ10gPT09ICdzdHJpbmcnID8gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmNvbG9yJ10gOiBjb2xvciwgeDogeCwgeTogeSwgYm9sZDogcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmJvbGQnXSwgaXRhbGljOiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuaXRhbGljJ10sIHRleHQ6IHRleHQsIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogaGFsaWduLCB0YWc6ICdsYWJlbHMuYWJvdmUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gdGhpcy5nZXRCYXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV0sXG4gICAgICAgICAgbGVmdCA9IHRoaXMuY29vcmRzW2ldWzBdLFxuICAgICAgICAgIHRvcCA9IHRoaXMuY29vcmRzW2ldWzFdLFxuICAgICAgICAgIHdpZHRoID0gdGhpcy5jb29yZHNbaV1bMl0sXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5jb29yZHNbaV1bM10sXG4gICAgICAgICAgaWR4ID0gaTtwYTIoY28sIFsnYicsICdyJywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0XSk7aWYgKGNvLmlzUG9pbnRJblBhdGgobW91c2VYLCBtb3VzZVkpKSB7XG4gICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCBpKTtyZXR1cm4geyAwOiB0aGlzLCAnb2JqZWN0JzogdGhpcywgMTogbGVmdCwgJ3gnOiBsZWZ0LCAyOiB0b3AsICd5JzogdG9wLCAzOiB3aWR0aCwgJ3dpZHRoJzogd2lkdGgsIDQ6IGhlaWdodCwgJ2hlaWdodCc6IGhlaWdodCwgNTogaWR4LCAnaW5kZXgnOiBpZHgsICd0b29sdGlwJzogdG9vbHRpcCB9O1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChhcmcubGVuZ3RoID09IDIpIHtcbiAgICAgIHZhciBtb3VzZVggPSBhcmdbMF07dmFyIG1vdXNlWSA9IGFyZ1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gUkcuZ2V0TW91c2VYWShhcmcpO3ZhciBtb3VzZVggPSBtb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZID0gbW91c2VDb29yZHNbMV07XG4gICAgfVxuICAgIGlmIChtb3VzZVkgPCB0aGlzLmd1dHRlclRvcCB8fCBtb3VzZVkgPiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSB8fCBtb3VzZVggPCB0aGlzLmd1dHRlckxlZnQgfHwgbW91c2VYID4gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIHZhciB2YWx1ZSA9IChtb3VzZVggLSB0aGlzLmd1dHRlckxlZnQpIC8gKHRoaXMuZ3JhcGh3aWR0aCAvIDIpICogKHRoaXMubWF4IC0gcHJvcFsnY2hhcnQueG1pbiddKTt2YWx1ZSA9IHZhbHVlIC0gdGhpcy5tYXg7XG4gICAgICBpZiAocHJvcFsnY2hhcnQueG1pbiddID4gMCkge1xuICAgICAgICB2YWx1ZSA9IChtb3VzZVggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmdyYXBod2lkdGggLyAyKSAvICh0aGlzLmdyYXBod2lkdGggLyAyKSAqICh0aGlzLm1heCAtIHByb3BbJ2NoYXJ0LnhtaW4nXSk7dmFsdWUgKz0gcHJvcFsnY2hhcnQueG1pbiddO2lmIChtb3VzZVggPCB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLmdyYXBod2lkdGggLyAyKSB7XG4gICAgICAgICAgdmFsdWUgLT0gMiAqIHByb3BbJ2NoYXJ0LnhtaW4nXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnKSB7XG4gICAgICB2YXIgdmFsdWUgPSAobW91c2VYIC0gdGhpcy5ndXR0ZXJMZWZ0KSAvIHRoaXMuZ3JhcGh3aWR0aCAqICh0aGlzLnNjYWxlMi5tYXggLSBwcm9wWydjaGFydC54bWluJ10pO3ZhbHVlID0gdGhpcy5zY2FsZTIubWF4IC0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSA9IChtb3VzZVggLSB0aGlzLmd1dHRlckxlZnQpIC8gdGhpcy5ncmFwaHdpZHRoICogKHRoaXMuc2NhbGUyLm1heCAtIHByb3BbJ2NoYXJ0LnhtaW4nXSk7dmFsdWUgKz0gcHJvcFsnY2hhcnQueG1pbiddO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlJlY3QodGhpcywgc2hhcGUpO1xuICAgIH1cbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTtpZiAocHJvcFsnY2hhcnQudmFyaWFudCddID09PSAnM2QnKSB7XG4gICAgICB2YXIgYWRqdXN0bWVudCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQudGhyZWVkLmFuZ2xlJ10gKiBtb3VzZVhZWzBdO21vdXNlWFlbMV0gLT0gYWRqdXN0bWVudDtcbiAgICB9XG4gICAgaWYgKG1vdXNlWFlbMF0gPj0gdGhpcy5ndXR0ZXJMZWZ0ICYmIG1vdXNlWFlbMF0gPD0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICYmIG1vdXNlWFlbMV0gPj0gdGhpcy5ndXR0ZXJUb3AgJiYgbW91c2VYWVsxXSA8PSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0WENvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA+IHRoaXMubWF4IHx8IHZhbHVlIDwgLTEgKiB0aGlzLm1heCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB3aWR0aCA9IChjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSkgLyAyO3ZhciBjb29yZCA9ICh2YWx1ZSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgLyAodGhpcy5tYXggLSBwcm9wWydjaGFydC54bWluJ10pICogd2lkdGggKyB3aWR0aDtjb29yZCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gKyBjb29yZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlID4gdGhpcy5tYXggfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dmFyIGNvb3JkID0gKHZhbHVlIC0gcHJvcFsnY2hhcnQueG1pbiddKSAvICh0aGlzLm1heCAtIHByb3BbJ2NoYXJ0LnhtaW4nXSkgKiB3aWR0aDtjb29yZCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gKyBjb29yZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYXhpcy5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO1xuICAgIH1cbiAgICB2YXIgY29sb3JzID0gcHJvcFsnY2hhcnQuY29sb3JzJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbG9yc1tpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddKTtwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7aWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcGFydHMgPSBSRy5hcnJheVJldmVyc2UocGFydHMpO1xuICAgICAgfVxuICAgICAgdmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLCAwLCBjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLCAwKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBvYmogPSB0aGlzO3RoaXMuY29vcmRzMi5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4LCBhcnIpIHtcbiAgICAgIHZhciBzaGFwZSA9IG9iai5jb29yZHMyW2lkeF1baW5kZXhdO1xuICAgICAgdmFyIHByZV9saW5ld2lkdGggPSBjby5saW5lV2lkdGg7Y28ubGluZVdpZHRoID0gMjtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJ107Y28uZmlsbFJlY3Qoc2hhcGVbMF0sIHNoYXBlWzFdLCBzaGFwZVsyXSwgc2hhcGVbM10pO2NvLnN0cm9rZVJlY3Qoc2hhcGVbMF0sIHNoYXBlWzFdLCBzaGFwZVsyXSwgc2hhcGVbM10pO2NvLmxpbmVXaWR0aCA9IHByZV9saW5ld2lkdGg7XG4gICAgfSk7XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMuZ2V0U2hhcGVCeVkgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgb2JqID0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogdGhpcztmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG9iai5jb29yZHNbaV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdLFxuICAgICAgICAgIGxlZnQgPSBvYmouY29vcmRzW2ldWzBdLFxuICAgICAgICAgIHRvcCA9IG9iai5jb29yZHNbaV1bMV0sXG4gICAgICAgICAgd2lkdGggPSBvYmouY29vcmRzW2ldWzJdLFxuICAgICAgICAgIGhlaWdodCA9IG9iai5jb29yZHNbaV1bM107aWYgKG1vdXNlWSA+PSB0b3AgJiYgbW91c2VZIDw9IHRvcCArIGhlaWdodCkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMnXSkge1xuICAgICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dCA/IFJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSwgaSkgOiBwcm9wWydjaGFydC50b29sdGlwcyddW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IDA6IG9iaiwgb2JqZWN0OiBvYmosIDE6IGxlZnQsIHg6IGxlZnQsIDI6IHRvcCwgeTogdG9wLCAzOiB3aWR0aCwgd2lkdGg6IHdpZHRoLCA0OiBoZWlnaHQsIGhlaWdodDogaGVpZ2h0LCA1OiBpLCBpbmRleDogaSwgdG9vbHRpcDogdG9vbHRpcCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRoaXMuZ2V0VmFsdWUoZSkpLFxuICAgICAgICAgIHNoYXBlID0gUkcuUmVnaXN0cnkuZ2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnKTtpZiAoc2hhcGUpIHtcbiAgICAgICAgUkcuUmVnaXN0cnkuU2V0KCdjaGFydC5hZGp1c3Rpbmcuc2hhcGUnLCBzaGFwZSk7aWYgKHRoaXMuc3RhY2tlZE9yR3JvdXBlZCAmJiBwcm9wWydjaGFydC5ncm91cGluZyddID09ICdncm91cGVkJykge1xuICAgICAgICAgIHZhciBpbmRleGVzID0gUkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNoYXBlWydpbmRleCddLCB0aGlzLmRhdGEpO2lmICh0eXBlb2YgdGhpcy5kYXRhW2luZGV4ZXNbMF1dID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhlc1swXV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIVJHLmlzX251bGwodGhpcy5kYXRhW2luZGV4ZXNbMF1dKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2luZGV4ZXNbMF1dW2luZGV4ZXNbMV1dID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGF0YVtzaGFwZVsnaW5kZXgnXV0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbc2hhcGVbJ2luZGV4J11dID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBSRy5yZWRyYXdDYW52YXMoZS50YXJnZXQpO1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25hZGp1c3QnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGxhYmVsc0Fib3ZlID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlJ107dGhpcy5zZXQoJ2xhYmVsc0Fib3ZlJywgZmFsc2UpO29iai5vcmlnaW5hbF9kYXRhID0gUkcuYXJyYXlDbG9uZShvYmouZGF0YSk7aWYgKHByb3BbJ2NoYXJ0LnhtYXgnXSA9PSAwKSB7XG4gICAgICB2YXIgeG1heCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoUkcuaXNBcnJheShvYmouZGF0YVtpXSkgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIFJHLmFycmF5U3VtKG9iai5kYXRhW2ldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuaXNBcnJheShvYmouZGF0YVtpXSkgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIFJHLmFycmF5TWF4KG9iai5kYXRhW2ldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeG1heCA9IG1hLm1heCh4bWF4LCBtYS5hYnMoUkcuYXJyYXlNYXgob2JqLmRhdGFbaV0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZTIgPSBSRy5nZXRTY2FsZTIob2JqLCB7ICdtYXgnOiB4bWF4IH0pO29iai5TZXQoJ2NoYXJ0LnhtYXgnLCBzY2FsZTIubWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gb2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgdmFyIGVhc2luZ0ZhY3RvciA9IFJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKTtpZiAoX3R5cGVvZihvYmouZGF0YVtqXSkgPT09ICdvYmplY3QnICYmIG9iai5kYXRhW2pdKSB7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDAsIGxlbjIgPSBvYmouZGF0YVtqXS5sZW5ndGg7IGsgPCBsZW4yOyArK2spIHtcbiAgICAgICAgICAgIG9iai5kYXRhW2pdW2tdID0gUkcuaXNOdWxsKG9iai5kYXRhW2pdW2tdKSA/IG51bGwgOiBvYmoub3JpZ2luYWxfZGF0YVtqXVtrXSAqIGVhc2luZ0ZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLmRhdGFbal0gPSBSRy5pc051bGwob2JqLmRhdGFbal0pID8gbnVsbCA6IG9iai5vcmlnaW5hbF9kYXRhW2pdICogZWFzaW5nRmFjdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgIGZyYW1lICs9IDE7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxhYmVsc0Fib3ZlKSB7XG4gICAgICAgICAgb2JqLnNldCgnbGFiZWxzQWJvdmUnLCB0cnVlKTtSRy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvYmogPSB0aGlzLFxuICAgICAgICBsYWJlbHNBYm92ZSA9IHRoaXMuZ2V0KCdsYWJlbHNBYm92ZScpO1xuICAgIHRoaXMub3JpZ2luYWxfZGF0YSA9IFJHLmFycmF5Q2xvbmUodGhpcy5kYXRhKTtpZiAocHJvcFsnY2hhcnQueG1heCddID09IDApIHtcbiAgICAgIHZhciB4bWF4ID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IG9iai5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChSRy5pc0FycmF5KG9iai5kYXRhW2ldKSAmJiBwcm9wWydjaGFydC5ncm91cGluZyddID09ICdzdGFja2VkJykge1xuICAgICAgICAgIHhtYXggPSBtYS5tYXgoeG1heCwgUkcuYXJyYXlTdW0ob2JqLmRhdGFbaV0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChSRy5pc0FycmF5KG9iai5kYXRhW2ldKSAmJiBwcm9wWydjaGFydC5ncm91cGluZyddID09ICdncm91cGVkJykge1xuICAgICAgICAgIHhtYXggPSBtYS5tYXgoeG1heCwgUkcuYXJyYXlNYXgob2JqLmRhdGFbaV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG1hLmFicyhSRy5hcnJheU1heChvYmouZGF0YVtpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNjYWxlMiA9IFJHLmdldFNjYWxlMihvYmosIHsgJ21heCc6IHhtYXggfSk7b2JqLlNldCgnY2hhcnQueG1heCcsIHNjYWxlMi5tYXgpO1xuICAgIH1cbiAgICBpZiAoUkcuaXNBcnJheShvcHQuZGF0YSkpIHtcbiAgICAgIHZhciB4bWF4ID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9wdC5kYXRhW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wdC5kYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kYXRhW2ldW2pdID09PSAnc3RyaW5nJyAmJiBvcHQuZGF0YVtpXVtqXS5tYXRjaCgvKFxcK3xcXC0pKFswLTldKykvKSkge1xuICAgICAgICAgICAgICBpZiAoUmVnRXhwLiQxID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBvcHQuZGF0YVtpXVtqXSA9IHRoaXMub3JpZ2luYWxfZGF0YVtpXVtqXSArIHBhcnNlSW50KFJlZ0V4cC4kMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0LmRhdGFbaV1bal0gPSB0aGlzLm9yaWdpbmFsX2RhdGFbaV1bal0gLSBwYXJzZUludChSZWdFeHAuJDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG9wdC5kYXRhW2ldW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdC5kYXRhW2ldID09PSAnc3RyaW5nJyAmJiBvcHQuZGF0YVtpXS5tYXRjaCgvKFxcK3xcXC0pKFswLTldKykvKSkge1xuICAgICAgICAgIGlmIChSZWdFeHAuJDEgPT09ICcrJykge1xuICAgICAgICAgICAgb3B0LmRhdGFbaV0gPSB0aGlzLm9yaWdpbmFsX2RhdGFbaV0gKyBwYXJzZUZsb2F0KFJlZ0V4cC4kMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdC5kYXRhW2ldID0gdGhpcy5vcmlnaW5hbF9kYXRhW2ldIC0gcGFyc2VGbG9hdChSZWdFeHAuJDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG9wdC5kYXRhW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG9wdC5kYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNjYWxlID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHhtYXggfSk7aWYgKHR5cGVvZiB0aGlzLmdldCgnY2hhcnQueG1heCcpID09PSAnbnVsbCcpIHtcbiAgICAgICAgdGhpcy5zZXQoJ2NoYXJ0LnhtYXgnLCBzY2FsZS5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldCgnbGFiZWxzQWJvdmUnLCBmYWxzZSk7aWYgKFJHLmlzTnVsbChwcm9wWydjaGFydC54bWF4J10pKSB7XG4gICAgICB2YXIgeG1heCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoUkcuaXNBcnJheSh0aGlzLmRhdGFbaV0pICYmIHByb3BbJ2NoYXJ0Lmdyb3VwaW5nJ10gPT09ICdzdGFja2VkJykge1xuICAgICAgICAgIHhtYXggPSBtYS5tYXgoeG1heCwgbWEuYWJzKFJHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChSRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgcHJvcFsnY2hhcnQuZ3JvdXBpbmcnXSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGdyb3VwID0gW107IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdyb3VwLnB1c2gobWEuYWJzKHRoaXMuZGF0YVtpXVtqXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG1hLmFicyhSRy5hcnJheU1heChncm91cCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4bWF4ID0gbWEubWF4KHhtYXgsIG1hLmFicyh0aGlzLmRhdGFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNjYWxlID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHhtYXggfSk7dGhpcy5TZXQoJ2NoYXJ0LnhtYXgnLCBzY2FsZS5tYXgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdC54bWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgb2JqLnNldCgneG1heCcsIG9wdC54bWF4KTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICB2YXIgZWFzaW5nTXVsdGlwbGllciA9IFJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKTtmb3IgKHZhciBqID0gMCwgbGVuID0gb2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgaWYgKF90eXBlb2Yob2JqLmRhdGFbal0pID09PSAnb2JqZWN0JyAmJiAhUkcuaXNOdWxsKG9iai5kYXRhW2pdKSkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBsZW4yID0gb2JqLmRhdGFbal0ubGVuZ3RoOyBrIDwgbGVuMjsgKytrKSB7XG4gICAgICAgICAgICBpZiAob2JqLmZpcnN0RHJhdyB8fCAhb3B0LmRhdGEpIHtcbiAgICAgICAgICAgICAgb2JqLmRhdGFbal1ba10gPSBlYXNpbmdNdWx0aXBsaWVyICogb2JqLm9yaWdpbmFsX2RhdGFbal1ba107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdC5kYXRhICYmIG9wdC5kYXRhLmxlbmd0aCA9PT0gb2JqLm9yaWdpbmFsX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gb3B0LmRhdGFbal1ba10gLSBvYmoub3JpZ2luYWxfZGF0YVtqXVtrXTtvYmouZGF0YVtqXVtrXSA9IGVhc2luZ011bHRpcGxpZXIgKiBkaWZmICsgb2JqLm9yaWdpbmFsX2RhdGFbal1ba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvYmouZmlyc3REcmF3IHx8ICFvcHQuZGF0YSkge1xuICAgICAgICAgICAgb2JqLmRhdGFbal0gPSBlYXNpbmdNdWx0aXBsaWVyICogb2JqLm9yaWdpbmFsX2RhdGFbal07XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHQuZGF0YSAmJiBvcHQuZGF0YS5sZW5ndGggPT09IG9iai5vcmlnaW5hbF9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBvcHQuZGF0YVtqXSAtIG9iai5vcmlnaW5hbF9kYXRhW2pdO29iai5kYXRhW2pdID0gZWFzaW5nTXVsdGlwbGllciAqIGRpZmYgKyBvYmoub3JpZ2luYWxfZGF0YVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgZnJhbWUgKz0gMTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUkcuaXNBcnJheShvcHQuZGF0YSkpIHtcbiAgICAgICAgICB2YXIgbGluZWFyX2RhdGEgPSBSRy5hcnJheUxpbmVhcml6ZShkYXRhKTtmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVhcl9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW9ialsnJCcgKyBpXSkge1xuICAgICAgICAgICAgICBvYmpbJyQnICsgaV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLmRhdGEgPSBkYXRhO29iai5vcmlnaW5hbF9kYXRhID0gUkcuYXJyYXlDbG9uZShkYXRhKTtpZiAobGFiZWxzQWJvdmUpIHtcbiAgICAgICAgICBvYmouc2V0KCdsYWJlbHNBYm92ZScsIHRydWUpO1JHLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfTtpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMud2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O29wdC5mcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO29wdC5zdGFydEZyYW1lcyA9IFtdO29wdC5jb3VudGVycyA9IFtdO3ZhciBmcmFtZXNwZXJiYXIgPSBvcHQuZnJhbWVzIC8gMyxcbiAgICAgICAgZnJhbWUgPSAtMSxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9yaWdpbmFsID0gUkcuYXJyYXlDbG9uZShvYmouZGF0YSksXG4gICAgICAgIGxhYmVsc0Fib3ZlID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlJ107dGhpcy5zZXQoJ2xhYmVsc0Fib3ZlJywgZmFsc2UpO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmouZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3B0LnN0YXJ0RnJhbWVzW2ldID0gb3B0LmZyYW1lcyAvIDIgLyAob2JqLmRhdGEubGVuZ3RoIC0gMSkgKiBpO2lmIChfdHlwZW9mKG9iai5kYXRhW2ldKSA9PT0gJ29iamVjdCcgJiYgb2JqLmRhdGFbaV0pIHtcbiAgICAgICAgb3B0LmNvdW50ZXJzW2ldID0gW107Zm9yICh2YXIgaiA9IDA7IGogPCBvYmouZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG9wdC5jb3VudGVyc1tpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5jb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIG9iai5kcmF3KCk7b2JqLlNldCgneG1heCcsIG9iai5zY2FsZTIubWF4KTtSRy5jbGVhcihvYmouY2FudmFzKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICsrZnJhbWU7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChmcmFtZSA+IG9wdC5zdGFydEZyYW1lc1tpXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmRhdGFbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvYmouZGF0YVtpXSA9IG1hLm1pbihtYS5hYnMob3JpZ2luYWxbaV0pLCBtYS5hYnMob3JpZ2luYWxbaV0gKiAob3B0LmNvdW50ZXJzW2ldKysgLyBmcmFtZXNwZXJiYXIpKSk7aWYgKG9yaWdpbmFsW2ldIDwgMCkge1xuICAgICAgICAgICAgICBvYmouZGF0YVtpXSAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFSRy5pc051bGwob2JqLmRhdGFbaV0pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IG9iai5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGogKz0gMSkge1xuICAgICAgICAgICAgICBvYmouZGF0YVtpXVtqXSA9IG1hLm1pbihtYS5hYnMob3JpZ2luYWxbaV1bal0pLCBtYS5hYnMob3JpZ2luYWxbaV1bal0gKiAob3B0LmNvdW50ZXJzW2ldW2pdKysgLyBmcmFtZXNwZXJiYXIpKSk7aWYgKG9yaWdpbmFsW2ldW2pdIDwgMCkge1xuICAgICAgICAgICAgICAgIG9iai5kYXRhW2ldW2pdICo9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5kYXRhW2ldID0gX3R5cGVvZihvYmouZGF0YVtpXSkgPT09ICdvYmplY3QnICYmIG9iai5kYXRhW2ldID8gUkcuYXJyYXlQYWQoW10sIG9iai5kYXRhW2ldLmxlbmd0aCwgMCkgOiBSRy5pc051bGwob2JqLmRhdGFbaV0pID8gbnVsbCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZSA+PSBvcHQuZnJhbWVzKSB7XG4gICAgICAgIGlmIChsYWJlbHNBYm92ZSkge1xuICAgICAgICAgIG9iai5zZXQoJ2xhYmVsc0Fib3ZlJywgdHJ1ZSk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuaXNBZGp1c3RhYmxlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKFJHLmlzTnVsbChwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoUkcuaXNBcnJheShwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkgJiYgcHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J11bc2hhcGUuaW5kZXhdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5oYmFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///192\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.HProgress = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        min = conf.min,\n        max = conf.max,\n        value = conf.value,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        min = arguments[1],\n        max = arguments[2],\n        value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.type = 'hprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.tickmarks.zerostart': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.background': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.labels.specific': null, 'chart.labels.count': 10, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'gutter', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null }, _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'black'), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.labels.position', 'bottom'), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.border.inner', true), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[HPROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.array_linearize(value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.strokestyle') {\n      this.Set('chart.strokestyle.inner', value);this.Set('chart.strokestyle.outer', value);return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitle();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.fillStyle = prop['chart.colors'][0];co.strokeStyle = prop['chart.strokestyle.outer'];var margin = prop['chart.margin'];var barWidth = ma.min(this.width, (RG.array_sum(this.value) - this.min) / (this.max - this.min) * this.width);if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var x = this.gutterLeft; x < ca.width - this.gutterRight; x += spacing) {\n        co.moveTo(Math.round(x), this.gutterTop);co.lineTo(Math.round(x), this.gutterTop + 2);co.moveTo(Math.round(x), ca.height - this.gutterBottom);co.lineTo(Math.round(x), ca.height - this.gutterBottom - 2);\n      }\n      co.stroke();\n    }\n    if (typeof this.value === 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft, y: this.gutterTop + margin, width: barWidth, height: this.height - margin - margin, fill: prop['chart.colors'][0] });this.coords.push([this.gutterLeft, this.gutterTop + margin, barWidth, this.height - margin - margin]);\n    } else if (_typeof(this.value) === 'object') {\n      co.beginPath();var startPoint = this.gutterLeft;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentLength = this.value[i] / RG.arraySum(this.value) * barWidth;if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i], stroke: prop['chart.strokestyle.inner'] });\n        }\n        this.drawCurvedBar({ x: startPoint, y: this.gutterTop + margin, width: segmentLength, height: this.height - margin - margin, fill: prop['chart.colors'][i] });this.coords.push([startPoint, this.gutterTop + margin, segmentLength, this.height - margin - margin]);startPoint += segmentLength;\n      }\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft + barWidth;var y = this.gutterTop;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y - 3);co.lineTo(x + 2, y - 7);co.lineTo(x - 2, y - 7);co.closePath();co.stroke();co.fill();co.beginPath();co.moveTo(x, y + this.height + 4);co.lineTo(x + 2, y + this.height + 9);co.lineTo(x - 2, y + this.height + 9);co.closePath();co.stroke();co.fill();\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'] + 2, 'x': this.gutterLeft + barWidth + 5, 'y': this.gutterTop + this.height / 2, 'text': String(prop['chart.units.pre'] + this.value + prop['chart.units.post']), 'valign': 'bottom', 'halign': 'left', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n    pa2(co, 'b');\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();this.tickInterval = this.width / prop['chart.numticks'];var start = prop['chart.tickmarks.zerostart'] ? 0 : this.tickInterval;if (prop['chart.labels.position'] == 'top') {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop);co.lineTo(Math.round(i), this.gutterTop - 4);\n        }\n      } else {\n        for (var i = this.gutterLeft + start; i <= this.width + this.gutterLeft + 0.1; i += this.tickInterval) {\n          co.moveTo(Math.round(i), this.gutterTop + this.height);co.lineTo(Math.round(i), this.gutterTop + this.height + 4);\n        }\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var xPoints = [],\n        yPoints = [],\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        offsetx = prop['chart.labels.offsetx'],\n        offsety = prop['chart.labels.offsety'];for (i = 0, len = this.scale2.labels.length; i < len; i++) {\n      if (prop['chart.labels.position'] == 'top') {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.gutterTop - 6;var valign = 'bottom';\n      } else {\n        var x = this.width * (i / this.scale2.labels.length) + this.gutterLeft + this.width / this.scale2.labels.length;var y = this.height + this.gutterTop + 4;var valign = 'top';\n      }\n      RG.text2(this, { 'font': font, 'size': size, 'x': x + offsetx, 'y': y + offsety, 'text': this.scale2.labels[i], 'valign': valign, 'halign': 'center', 'tag': 'scale' });\n    }\n    if (prop['chart.tickmarks.zerostart']) {\n      if (prop['chart.labels.position'] == 'top') {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': this.gutterTop - 6 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'bottom', 'halign': 'center', 'tag': 'scale' });\n      } else {\n        RG.text2(this, { 'font': font, 'size': size, 'x': this.gutterLeft + offsetx, 'y': ca.height - this.gutterBottom + 5 + offsety, 'text': prop['chart.units.pre'] + Number(this.min).toFixed(this.min > 0 ? prop['chart.scale.decimals'] : 0) + prop['chart.units.post'], 'valign': 'top', 'halign': 'center', 'tag': 'scale' });\n      }\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, height: h, width: w });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], idx);return { 0: this, 1: x, 2: y, 3: w, 4: h, 5: idx, 'object': this, 'x': x, 'y': y, 'width': w, 'height': h, 'index': idx, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var value = (mouseXY[0] - this.gutterLeft) / this.width;value *= this.max - this.min;value += this.min;if (mouseXY[0] < this.gutterLeft) {\n      value = this.min;\n    }\n    if (mouseXY[0] > ca.width - this.gutterRight) {\n      value = this.max;\n    }\n    return value;\n  };this.highlight = this.Highlight = function (shape) {\n    var last = shape.index === this.coords.length - 1;if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value == 'number') {\n        this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          valign = prop['chart.labels.position'] == 'top' ? 'bottom' : 'top',\n          step = this.width / (labels.length - 1),\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { font: font, size: size, x: this.gutterLeft + step * i + offsetx, y: prop['chart.labels.position'] == 'top' ? this.gutterTop - 7 + offsety : ca.height - this.gutterBottom + 7 + offsety, text: labels[i], valign: valign, halign: 'center', tag: 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getXCoord = function (value) {\n    var min = this.min;if (value < min || value > this.max) {\n      return null;\n    }\n    var barWidth = ca.width - this.gutterLeft - this.gutterRight;var coord = (value - min) / (this.max - min) * barWidth;coord = this.gutterLeft + coord;return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, len = 0; i < this.coords.length; ++i) {\n      len += this.coords[i][2];\n    }co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[0][1], len, this.coords[0][3]);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[0][1], width: len, height: this.coords[0][3] });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 51, y: this.coords[0][1] - 1, width: len + 52, height: this.coords[0][3] + 2 });co.stroke();co.restore();co.restore();\n  };this.drawTitle = this.DrawTitle = function () {\n    if (prop['chart.title'].length) {\n      var x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;var text = prop['chart.title'];var size = prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2;var font = prop['chart.title.font'] ? prop['chart.title.font'] : prop['chart.text.font'];if (prop['chart.labels.position'] == 'top') {\n        y = ca.height - this.gutterBottom + 5;x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;valign = 'top';\n      } else {\n        x = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;y = this.gutterTop - 5;valign = 'bottom';\n      }\n      RG.Text2(this, { 'font': font, 'size': size, 'x': typeof prop['chart.title.x'] == 'number' ? prop['chart.title.x'] : x, 'y': typeof prop['chart.title.y'] == 'number' ? prop['chart.title.y'] : y, 'text': text, 'valign': prop['chart.title.valign'] ? prop['chart.title.valign'] : valign, 'halign': prop['chart.title.halign'] ? prop['chart.title.halign'] : 'center', 'bold': prop['chart.title.bold'], 'bounding': prop['chart.title.background'] ? true : false, 'boundingFill': prop['chart.title.background'], 'tag': 'title' });\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RG.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0, len = obj.value.length; i < len; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0, len = initial_value.length; i < len; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5ocHJvZ3Jlc3MuanM/N2U4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5IUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY29uZikge1xuICB2YXIgX3Byb3BlcnRpZXM7XG5cbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBtaW4gPSBjb25mLm1pbixcbiAgICAgICAgbWF4ID0gY29uZi5tYXgsXG4gICAgICAgIHZhbHVlID0gY29uZi52YWx1ZSxcbiAgICAgICAgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZixcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBtaW4gPSBhcmd1bWVudHNbMV0sXG4gICAgICAgIG1heCA9IGFyZ3VtZW50c1syXSxcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy5taW4gPSBSR3JhcGguc3RyaW5nc1RvTnVtYmVycyhtaW4pO3RoaXMubWF4ID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWF4KTt0aGlzLnZhbHVlID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnModmFsdWUpO3RoaXMudHlwZSA9ICdocHJvZ3Jlc3MnO3RoaXMuY29vcmRzID0gW107dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMucHJvcGVydGllcyA9IChfcHJvcGVydGllcyA9IHsgJ2NoYXJ0LmNvbG9ycyc6IFsnR3JhZGllbnQod2hpdGU6IzBjMCknLCAnR3JhZGllbnQod2hpdGU6cmVkKScsICdHcmFkaWVudCh3aGl0ZTpncmVlbiknLCAneWVsbG93JywgJ3BpbmsnLCAnY3lhbicsICdibGFjaycsICd3aGl0ZScsICdncmF5J10sICdjaGFydC5zdHJva2VzdHlsZS5pbm5lcic6ICcjOTk5JywgJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJzogJyM5OTknLCAnY2hhcnQudGlja21hcmtzJzogdHJ1ZSwgJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvcic6ICcjOTk5JywgJ2NoYXJ0LnRpY2ttYXJrcy5pbm5lcic6IGZhbHNlLCAnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCc6IHRydWUsICdjaGFydC5ndXR0ZXIubGVmdCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMjUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMjUsICdjaGFydC5udW10aWNrcyc6IDEwLCAnY2hhcnQubnVtdGlja3MuaW5uZXInOiA1MCwgJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOiAnR3JhZGllbnQoI2NjYzojZWVlOiNlZmVmZWYpJywgJ2NoYXJ0LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ3JnYmEoMCwwLDAsMC41KScsICdjaGFydC5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDMsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDMsICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC50aXRsZS5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhhbGlnbic6IG51bGwsICdjaGFydC50aXRsZS52YWxpZ24nOiBudWxsLCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuZm9udCc6ICdTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6ICd2aXNpYmxlJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzogdHJ1ZSwgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LnVuaXRzLnByZSc6ICcnLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzogJ2ZhZGUnLCAnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzogJ1JHcmFwaF90b29sdGlwJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC50b29sdGlwcy5ldmVudCc6ICdvbmNsaWNrJywgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0Lnpvb20uZmFjdG9yJzogMS41LCAnY2hhcnQuem9vbS5mYWRlLmluJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOiB0cnVlLCAnY2hhcnQuem9vbS5oZGlyJzogJ3JpZ2h0JywgJ2NoYXJ0Lnpvb20udmRpcic6ICdkb3duJywgJ2NoYXJ0Lnpvb20uZnJhbWVzJzogMjUsICdjaGFydC56b29tLmRlbGF5JzogMTYuNjY2LCAnY2hhcnQuem9vbS5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzogdHJ1ZSwgJ2NoYXJ0LmFycm93cyc6IGZhbHNlLCAnY2hhcnQubWFyZ2luJzogMCwgJ2NoYXJ0LnJlc2l6YWJsZSc6IGZhbHNlLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOiBbMCwgMF0sICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQubGFiZWxzLnNwZWNpZmljJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5jb3VudCc6IDEwLCAnY2hhcnQubGFiZWxzLm9mZnNldHgnOiAwLCAnY2hhcnQubGFiZWxzLm9mZnNldHknOiAwLCAnY2hhcnQuYWRqdXN0YWJsZSc6IGZhbHNlLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiAwLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5zY2FsZS50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LmtleSc6IG51bGwsICdjaGFydC5rZXkuYmFja2dyb3VuZCc6ICd3aGl0ZScsICdjaGFydC5rZXkucG9zaXRpb24nOiAnZ3V0dGVyJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCB9LCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuY29sb3Iuc2hhcGUnLCAnc3F1YXJlJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnLCAnYmxhY2snKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJywgJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJywgJ3JnYmEoMjU1LDAsMCwwLjIpJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJywgJ2JsYWNrJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbicsICdib3R0b20nKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMuY2xpY2snLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYm9yZGVyLmlubmVyJywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfcHJvcGVydGllcyk7XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW0hQUk9HUkVTU10gTm8gY2FudmFzIHN1cHBvcnQnKTtyZXR1cm47XG4gIH1cbiAgdmFyIGxpbmVhcl9kYXRhID0gUkdyYXBoLmFycmF5X2xpbmVhcml6ZSh2YWx1ZSk7Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lYXJfZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHRoaXNbJyQnICsgaV0gPSB7fTtcbiAgfVxuICBpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQuc3Ryb2tlc3R5bGUnKSB7XG4gICAgICB0aGlzLlNldCgnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInLCB2YWx1ZSk7dGhpcy5TZXQoJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJywgdmFsdWUpO3JldHVybjtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy53aWR0aCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDt0aGlzLmhlaWdodCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLmRyYXdiYXIoKTt0aGlzLkRyYXdUaWNrTWFya3MoKTt0aGlzLkRyYXdMYWJlbHMoKTt0aGlzLkRyYXdUaXRsZSgpO2lmIChwcm9wWydjaGFydC5iZXZlbCddKSB7XG4gICAgICB0aGlzLkRyYXdCZXZlbCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSkge1xuICAgICAgUkcuU2hvd0NvbnRleHQodGhpcyk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5rZXknXSAmJiBwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywgcHJvcFsnY2hhcnQua2V5J10sIHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3YmFyID0gdGhpcy5EcmF3YmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHRoaXMubWF4LCAnbWluJzogdGhpcy5taW4sICdzdHJpY3QnOiB0cnVlLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUuZGVjaW1hbHMnOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCAneWxhYmVscy5jb3VudCc6IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLCAnc2NhbGUucm91bmQnOiBwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCAndW5pdHMucHJlJzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sICd1bml0cy5wb3N0JzogcHJvcFsnY2hhcnQudW5pdHMucG9zdCddIH0pO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcuU2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICB9XG4gICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXTtjby5zdHJva2VSZWN0KHRoaXMuZ3V0dGVyTGVmdCwgdGhpcy5ndXR0ZXJUb3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtjby5maWxsUmVjdCh0aGlzLmd1dHRlckxlZnQsIHRoaXMuZ3V0dGVyVG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7Ukcubm9TaGFkb3codGhpcyk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddO3ZhciBtYXJnaW4gPSBwcm9wWydjaGFydC5tYXJnaW4nXTt2YXIgYmFyV2lkdGggPSBtYS5taW4odGhpcy53aWR0aCwgKFJHLmFycmF5X3N1bSh0aGlzLnZhbHVlKSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMud2lkdGgpO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MuaW5uZXInXSkge1xuICAgICAgdmFyIHNwYWNpbmcgPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIHByb3BbJ2NoYXJ0Lm51bXRpY2tzLmlubmVyJ107Y28ubGluZVdpZHRoID0gMTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ107Y28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgeCA9IHRoaXMuZ3V0dGVyTGVmdDsgeCA8IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodDsgeCArPSBzcGFjaW5nKSB7XG4gICAgICAgIGNvLm1vdmVUbyhNYXRoLnJvdW5kKHgpLCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKE1hdGgucm91bmQoeCksIHRoaXMuZ3V0dGVyVG9wICsgMik7Y28ubW92ZVRvKE1hdGgucm91bmQoeCksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4KSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSAyKTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pIHtcbiAgICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5ndXR0ZXJMZWZ0LCB5OiB0aGlzLmd1dHRlclRvcCArIG1hcmdpbiwgd2lkdGg6IGJhcldpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IC0gbWFyZ2luIC0gbWFyZ2luLCBzdHJva2U6IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ10gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdDdXJ2ZWRCYXIoeyB4OiB0aGlzLmd1dHRlckxlZnQsIHk6IHRoaXMuZ3V0dGVyVG9wICsgbWFyZ2luLCB3aWR0aDogYmFyV2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgLSBtYXJnaW4gLSBtYXJnaW4sIGZpbGw6IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdIH0pO3RoaXMuY29vcmRzLnB1c2goW3RoaXMuZ3V0dGVyTGVmdCwgdGhpcy5ndXR0ZXJUb3AgKyBtYXJnaW4sIGJhcldpZHRoLCB0aGlzLmhlaWdodCAtIG1hcmdpbiAtIG1hcmdpbl0pO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZih0aGlzLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciBzdGFydFBvaW50ID0gdGhpcy5ndXR0ZXJMZWZ0O2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50TGVuZ3RoID0gdGhpcy52YWx1ZVtpXSAvIFJHLmFycmF5U3VtKHRoaXMudmFsdWUpICogYmFyV2lkdGg7aWYgKHByb3BbJ2NoYXJ0LmJvcmRlci5pbm5lciddKSB7XG4gICAgICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogc3RhcnRQb2ludCwgeTogdGhpcy5ndXR0ZXJUb3AgKyBtYXJnaW4sIHdpZHRoOiBzZWdtZW50TGVuZ3RoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IC0gbWFyZ2luIC0gbWFyZ2luLCBmaWxsOiBwcm9wWydjaGFydC5jb2xvcnMnXVtpXSwgc3Ryb2tlOiBwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0N1cnZlZEJhcih7IHg6IHN0YXJ0UG9pbnQsIHk6IHRoaXMuZ3V0dGVyVG9wICsgbWFyZ2luLCB3aWR0aDogc2VnbWVudExlbmd0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCAtIG1hcmdpbiAtIG1hcmdpbiwgZmlsbDogcHJvcFsnY2hhcnQuY29sb3JzJ11baV0gfSk7dGhpcy5jb29yZHMucHVzaChbc3RhcnRQb2ludCwgdGhpcy5ndXR0ZXJUb3AgKyBtYXJnaW4sIHNlZ21lbnRMZW5ndGgsIHRoaXMuaGVpZ2h0IC0gbWFyZ2luIC0gbWFyZ2luXSk7c3RhcnRQb2ludCArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYXJyb3dzJ10pIHtcbiAgICAgIHZhciB4ID0gdGhpcy5ndXR0ZXJMZWZ0ICsgYmFyV2lkdGg7dmFyIHkgPSB0aGlzLmd1dHRlclRvcDtjby5saW5lV2lkdGggPSAxO2NvLmZpbGxTdHlsZSA9ICdibGFjayc7Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LCB5IC0gMyk7Y28ubGluZVRvKHggKyAyLCB5IC0gNyk7Y28ubGluZVRvKHggLSAyLCB5IC0gNyk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LCB5ICsgdGhpcy5oZWlnaHQgKyA0KTtjby5saW5lVG8oeCArIDIsIHkgKyB0aGlzLmhlaWdodCArIDkpO2NvLmxpbmVUbyh4IC0gMiwgeSArIHRoaXMuaGVpZ2h0ICsgOSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWwuaW5uZXInXSkge1xuICAgICAgY28uZmlsbFN0eWxlID0gJ2JsYWNrJztSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudGV4dC5mb250J10sICdzaXplJzogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIGJhcldpZHRoICsgNSwgJ3knOiB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGVpZ2h0IC8gMiwgJ3RleHQnOiBTdHJpbmcocHJvcFsnY2hhcnQudW5pdHMucHJlJ10gKyB0aGlzLnZhbHVlICsgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKSwgJ3ZhbGlnbic6ICdib3R0b20nLCAnaGFsaWduJzogJ2xlZnQnLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmdGaWxsJzogJ3doaXRlJywgJ3RhZyc6ICdsYWJlbC5pbm5lcicgfSk7XG4gICAgfVxuICAgIHBhMihjbywgJ2InKTtcbiAgfTt0aGlzLmRyYXdUaWNrTWFya3MgPSB0aGlzLkRyYXdUaWNrTWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXTtpZiAocHJvcFsnY2hhcnQudGlja21hcmtzJ10pIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO3RoaXMudGlja0ludGVydmFsID0gdGhpcy53aWR0aCAvIHByb3BbJ2NoYXJ0Lm51bXRpY2tzJ107dmFyIHN0YXJ0ID0gcHJvcFsnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCddID8gMCA6IHRoaXMudGlja0ludGVydmFsO2lmIChwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSA9PSAndG9wJykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ndXR0ZXJMZWZ0ICsgc3RhcnQ7IGkgPD0gdGhpcy53aWR0aCArIHRoaXMuZ3V0dGVyTGVmdCArIDAuMTsgaSArPSB0aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgIGNvLm1vdmVUbyhNYXRoLnJvdW5kKGkpLCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKE1hdGgucm91bmQoaSksIHRoaXMuZ3V0dGVyVG9wIC0gNCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmd1dHRlckxlZnQgKyBzdGFydDsgaSA8PSB0aGlzLndpZHRoICsgdGhpcy5ndXR0ZXJMZWZ0ICsgMC4xOyBpICs9IHRoaXMudGlja0ludGVydmFsKSB7XG4gICAgICAgICAgY28ubW92ZVRvKE1hdGgucm91bmQoaSksIHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oZWlnaHQpO2NvLmxpbmVUbyhNYXRoLnJvdW5kKGkpLCB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGVpZ2h0ICsgNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSRy5pc19udWxsKHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddKSkge1xuICAgICAgcmV0dXJuIHRoaXMuRHJhd1NwZWNpZmljTGFiZWxzKCk7XG4gICAgfVxuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgeFBvaW50cyA9IFtdLFxuICAgICAgICB5UG9pbnRzID0gW10sXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICBvZmZzZXR4ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxcbiAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J107Zm9yIChpID0gMCwgbGVuID0gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLndpZHRoICogKGkgLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSArIHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMud2lkdGggLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoO3ZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgLSA2O3ZhciB2YWxpZ24gPSAnYm90dG9tJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy53aWR0aCAqIChpIC8gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCkgKyB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLndpZHRoIC8gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDt2YXIgeSA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5ndXR0ZXJUb3AgKyA0O3ZhciB2YWxpZ24gPSAndG9wJztcbiAgICAgIH1cbiAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogeCArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogdmFsaWduLCAnaGFsaWduJzogJ2NlbnRlcicsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCddKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB0aGlzLmd1dHRlckxlZnQgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wIC0gNiArIG9mZnNldHksICd0ZXh0JzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10gKyBOdW1iZXIodGhpcy5taW4pLnRvRml4ZWQodGhpcy5taW4gPiAwID8gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSA6IDApICsgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddLCAndmFsaWduJzogJ2JvdHRvbScsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIG9mZnNldHgsICd5JzogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyA1ICsgb2Zmc2V0eSwgJ3RleHQnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSArIE51bWJlcih0aGlzLm1pbikudG9GaXhlZCh0aGlzLm1pbiA+IDAgPyBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddIDogMCkgKyBwcm9wWydjaGFydC51bml0cy5wb3N0J10sICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IHRoaXMuZ2V0QmFyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY29vcmRzW2ldWzBdLFxuICAgICAgICAgIHkgPSB0aGlzLmNvb3Jkc1tpXVsxXSxcbiAgICAgICAgICB3ID0gdGhpcy5jb29yZHNbaV1bMl0sXG4gICAgICAgICAgaCA9IHRoaXMuY29vcmRzW2ldWzNdLFxuICAgICAgICAgIGlkeCA9IGk7Y28uYmVnaW5QYXRoKCk7dGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogeCwgeTogeSwgaGVpZ2h0OiBoLCB3aWR0aDogdyB9KTtpZiAoY28uaXNQb2ludEluUGF0aChtb3VzZVgsIG1vdXNlWSkpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGlkeCk7cmV0dXJuIHsgMDogdGhpcywgMTogeCwgMjogeSwgMzogdywgNDogaCwgNTogaWR4LCAnb2JqZWN0JzogdGhpcywgJ3gnOiB4LCAneSc6IHksICd3aWR0aCc6IHcsICdoZWlnaHQnOiBoLCAnaW5kZXgnOiBpZHgsICd0b29sdGlwJzogdG9vbHRpcCB9O1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIHZhbHVlID0gKG1vdXNlWFlbMF0gLSB0aGlzLmd1dHRlckxlZnQpIC8gdGhpcy53aWR0aDt2YWx1ZSAqPSB0aGlzLm1heCAtIHRoaXMubWluO3ZhbHVlICs9IHRoaXMubWluO2lmIChtb3VzZVhZWzBdIDwgdGhpcy5ndXR0ZXJMZWZ0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAobW91c2VYWVswXSA+IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICB2YXIgbGFzdCA9IHNoYXBlLmluZGV4ID09PSB0aGlzLmNvb3Jkcy5sZW5ndGggLSAxO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogc2hhcGUueCwgeTogc2hhcGUueSwgd2lkdGg6IHNoYXBlLndpZHRoLCBoZWlnaHQ6IHNoYXBlLmhlaWdodCwgc3Ryb2tlOiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10sIGZpbGw6IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gfSk7XG4gICAgfVxuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO2lmIChtb3VzZVhZWzBdID4gdGhpcy5ndXR0ZXJMZWZ0ICYmIG1vdXNlWFlbMF0gPCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgJiYgbW91c2VYWVsxXSA+IHRoaXMuZ3V0dGVyVG9wICYmIG1vdXNlWFlbMV0gPCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZSA9IHRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpICYmIFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkID09IHRoaXMudWlkKSB7XG4gICAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZShlKTtpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBOdW1iZXIodmFsdWUudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYWRqdXN0Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd1NwZWNpZmljTGFiZWxzID0gdGhpcy5EcmF3U3BlY2lmaWNMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddO2lmIChsYWJlbHMpIHtcbiAgICAgIHZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICAgIHZhbGlnbiA9IHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddID09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcbiAgICAgICAgICBzdGVwID0gdGhpcy53aWR0aCAvIChsYWJlbHMubGVuZ3RoIC0gMSksXG4gICAgICAgICAgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR4J10sXG4gICAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR5J107XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgUkcuVGV4dDIodGhpcywgeyBmb250OiBmb250LCBzaXplOiBzaXplLCB4OiB0aGlzLmd1dHRlckxlZnQgKyBzdGVwICogaSArIG9mZnNldHgsIHk6IHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddID09ICd0b3AnID8gdGhpcy5ndXR0ZXJUb3AgLSA3ICsgb2Zmc2V0eSA6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgNyArIG9mZnNldHksIHRleHQ6IGxhYmVsc1tpXSwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogJ2NlbnRlcicsIHRhZzogJ2xhYmVscy5zcGVjaWZpYycgfSk7XG4gICAgICB9XG4gICAgICBjby5maWxsKCk7XG4gICAgfVxuICB9O3RoaXMuZ2V0WENvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluO2lmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJhcldpZHRoID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0O3ZhciBjb29yZCA9ICh2YWx1ZSAtIG1pbikgLyAodGhpcy5tYXggLSBtaW4pICogYmFyV2lkdGg7Y29vcmQgPSB0aGlzLmd1dHRlckxlZnQgKyBjb29yZDtyZXR1cm4gY29vcmQ7XG4gIH07dGhpcy5vdmVyQ2hhcnRBcmVhID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHcmFwaC5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO2lmIChtb3VzZVggPj0gdGhpcy5ndXR0ZXJMZWZ0ICYmIG1vdXNlWCA8PSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgJiYgbW91c2VZID49IHRoaXMuZ3V0dGVyVG9wICYmIG1vdXNlWSA8PSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGlja21hcmtzLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmNvbG9yJ10pO1xuICAgIH1cbiAgICB2YXIgY29sb3JzID0gcHJvcFsnY2hhcnQuY29sb3JzJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbG9yc1tpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jb2xvciddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10sIDAsIGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J10sIDApO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLmRyYXdCZXZlbCA9IHRoaXMuRHJhd0JldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbiArPSB0aGlzLmNvb3Jkc1tpXVsyXTtcbiAgICB9Y28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QodGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzWzBdWzFdLCBsZW4sIHRoaXMuY29vcmRzWzBdWzNdKTtjby5jbGlwKCk7Y28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO3RoaXMuZHJhd0N1cnZlZEJhcih7IHg6IHRoaXMuY29vcmRzWzBdWzBdLCB5OiB0aGlzLmNvb3Jkc1swXVsxXSwgd2lkdGg6IGxlbiwgaGVpZ2h0OiB0aGlzLmNvb3Jkc1swXVszXSB9KTtjby5jbGlwKCk7Y28uYmVnaW5QYXRoKCk7Y28uc2hhZG93Q29sb3IgPSAnYmxhY2snO2NvLnNoYWRvd09mZnNldFggPSAwO2NvLnNoYWRvd09mZnNldFkgPSAwO2NvLnNoYWRvd0JsdXIgPSAxNTtjby5saW5lV2lkdGggPSAyO3RoaXMuZHJhd0N1cnZlZEJhcih7IHg6IHRoaXMuY29vcmRzWzBdWzBdIC0gNTEsIHk6IHRoaXMuY29vcmRzWzBdWzFdIC0gMSwgd2lkdGg6IGxlbiArIDUyLCBoZWlnaHQ6IHRoaXMuY29vcmRzWzBdWzNdICsgMiB9KTtjby5zdHJva2UoKTtjby5yZXN0b3JlKCk7Y28ucmVzdG9yZSgpO1xuICB9O3RoaXMuZHJhd1RpdGxlID0gdGhpcy5EcmF3VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRpdGxlJ10ubGVuZ3RoKSB7XG4gICAgICB2YXIgeCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiArIHRoaXMuZ3V0dGVyTGVmdDt2YXIgdGV4dCA9IHByb3BbJ2NoYXJ0LnRpdGxlJ107dmFyIHNpemUgPSBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gPyBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSArIDI7dmFyIGZvbnQgPSBwcm9wWydjaGFydC50aXRsZS5mb250J10gPyBwcm9wWydjaGFydC50aXRsZS5mb250J10gOiBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTtpZiAocHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgeSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgNTt4ID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0O3ZhbGlnbiA9ICd0b3AnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiArIHRoaXMuZ3V0dGVyTGVmdDt5ID0gdGhpcy5ndXR0ZXJUb3AgLSA1O3ZhbGlnbiA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueCddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQudGl0bGUueCddIDogeCwgJ3knOiB0eXBlb2YgcHJvcFsnY2hhcnQudGl0bGUueSddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQudGl0bGUueSddIDogeSwgJ3RleHQnOiB0ZXh0LCAndmFsaWduJzogcHJvcFsnY2hhcnQudGl0bGUudmFsaWduJ10gPyBwcm9wWydjaGFydC50aXRsZS52YWxpZ24nXSA6IHZhbGlnbiwgJ2hhbGlnbic6IHByb3BbJ2NoYXJ0LnRpdGxlLmhhbGlnbiddID8gcHJvcFsnY2hhcnQudGl0bGUuaGFsaWduJ10gOiAnY2VudGVyJywgJ2JvbGQnOiBwcm9wWydjaGFydC50aXRsZS5ib2xkJ10sICdib3VuZGluZyc6IHByb3BbJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnXSA/IHRydWUgOiBmYWxzZSwgJ2JvdW5kaW5nRmlsbCc6IHByb3BbJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnXSwgJ3RhZyc6ICd0aXRsZScgfSk7XG4gICAgfVxuICB9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHNbaW5kZXhdO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5saW5lV2lkdGggPSAyO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCddO2NvLnJlY3QoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gMTtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3Q3VydmVkQmFyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHBhMihjbywgJ2IgciAlICUgJSAlJywgb3B0LngsIG9wdC55LCBvcHQud2lkdGgsIG9wdC5oZWlnaHQpO2lmIChvcHQuc3Ryb2tlKSB7XG4gICAgICBjby5zdHJva2VTdHlsZSA9IG9wdC5zdHJva2U7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChvcHQuZmlsbCkge1xuICAgICAgY28uZmlsbFN0eWxlID0gb3B0LmZpbGw7Y28uZmlsbCgpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBjYW52YXMgPSBvYmouY2FudmFzO3ZhciBjb250ZXh0ID0gb2JqLmNvbnRleHQ7dmFyIGluaXRpYWxfdmFsdWUgPSBvYmouY3VycmVudFZhbHVlO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIG51bUZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307aWYgKF90eXBlb2Yob2JqLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChSRy5pc19udWxsKG9iai5jdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIG9iai5jdXJyZW50VmFsdWUgPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLnZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgb2JqLmN1cnJlbnRWYWx1ZVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkaWZmID0gW107dmFyIGluY3JlbWVudCA9IFtdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoudmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgZGlmZltpXSA9IG9iai52YWx1ZVtpXSAtIE51bWJlcihvYmouY3VycmVudFZhbHVlW2ldKTtpbmNyZW1lbnRbaV0gPSBkaWZmW2ldIC8gbnVtRnJhbWVzO1xuICAgICAgfVxuICAgICAgaWYgKGluaXRpYWxfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsX3ZhbHVlID0gW107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai52YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGluaXRpYWxfdmFsdWVbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWZmID0gb2JqLnZhbHVlIC0gTnVtYmVyKG9iai5jdXJyZW50VmFsdWUpO3ZhciBpbmNyZW1lbnQgPSBkaWZmIC8gbnVtRnJhbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGZyYW1lKys7aWYgKGZyYW1lIDw9IG51bUZyYW1lcykge1xuICAgICAgICBpZiAoX3R5cGVvZihvYmoudmFsdWUpID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqLnZhbHVlID0gW107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGluaXRpYWxfdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIG9iai52YWx1ZVtpXSA9IGluaXRpYWxfdmFsdWVbaV0gKyBpbmNyZW1lbnRbaV0gKiBmcmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLnZhbHVlID0gaW5pdGlhbF92YWx1ZSArIGluY3JlbWVudCAqIGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIFJHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1JHcmFwaC5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLmhwcm9ncmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///193\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Line = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id;var canvas = document.getElementById(id);var data = conf.data;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.type = 'line';this.max = 0;this.coords = [];this.coords2 = [];this.coords.key = [];this.coordsText = [];this.coordsSpline = [];this.coordsAxes = { xaxis: [], yaxis: [] };this.hasnegativevalues = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': 1, 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 25, 'chart.background.grid.vsize': 25, 'chart.background.grid.color': '#ddd', 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': null, 'chart.background.grid.dashed': false, 'chart.background.grid.dotted': false, 'chart.background.hbars': null, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.labels': null, 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': null, 'chart.labels.above.color': null, 'chart.labels.above.background': 'white', 'chart.labels.above.font': null, 'chart.labels.above.border': true, 'chart.labels.above.offsety': 5, 'chart.labels.above.units.pre': '', 'chart.labels.above.units.post': '', 'chart.labels.above.specific': null, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.xtickgap': 20, 'chart.smallxticks': 3, 'chart.largexticks': 5, 'chart.ytickgap': 20, 'chart.smallyticks': 3, 'chart.largeyticks': 5, 'chart.numyticks': 10, 'chart.linewidth': 2.01, 'chart.colors': ['red', '#0f0', '#00f', '#f0f', '#ff0', '#0ff', 'green', 'pink', 'blue', 'black'], 'chart.hmargin': 0, 'chart.tickmarks.dot.stroke': 'white', 'chart.tickmarks.dot.fill': null, 'chart.tickmarks.dot.linewidth': 3, 'chart.tickmarks': 'endcircle', 'chart.tickmarks.linewidth': null, 'chart.tickmarks.image': null, 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 3, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.tickdirection': -1, 'chart.yaxispoints': 5, 'chart.fillstyle': null, 'chart.xaxispos': 'bottom', 'chart.xaxispos.value': 0, 'chart.yaxispos': 'left', 'chart.xticks': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymin': 0, 'chart.ymax': null, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.shadow.blur': 3, 'chart.shadow.color': 'rgba(128,128,128,0.5)', 'chart.tooltips': null, 'chart.tooltips.hotspot.xonly': false, 'chart.tooltips.hotspot.size': 5, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.highlight.style': null, 'chart.highlight.stroke': 'gray', 'chart.highlight.fill': 'white', 'chart.stepped': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': null, 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.inside': false, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.scale.invert': false, 'chart.xlabels.inside': false, 'chart.xlabels.inside.color': 'rgba(255,255,255,0.5)', 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.noxaxis': false, 'chart.noendxtick': false, 'chart.noendytick': false, 'chart.units.post': '', 'chart.units.pre': '', 'chart.scale.zerostart': true, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.axesontop': false, 'chart.filled': false, 'chart.filled.range': false, 'chart.filled.range.threshold': null, 'chart.filled.range.threshold.colors': ['red', 'green'], 'chart.filled.accumulative': true, 'chart.variant': null, 'chart.axis.color': 'black', 'chart.axis.linewidth': 1, 'chart.numxticks': data && typeof data[0] == 'number' ? data.length - 1 : _typeof(data[0]) === 'object' && data[0] && typeof data[0][0] === 'number' ? data[0].length - 1 : 20 }, _defineProperty(_properties, 'chart.numyticks', 10), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.backdrop', false), _defineProperty(_properties, 'chart.backdrop.size', 30), _defineProperty(_properties, 'chart.backdrop.alpha', 0.2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.adjustable.only', null), _defineProperty(_properties, 'chart.noredraw', false), _defineProperty(_properties, 'chart.outofbounds', false), _defineProperty(_properties, 'chart.outofbounds.clip', false), _defineProperty(_properties, 'chart.chromefix', true), _defineProperty(_properties, 'chart.animation.factor', 1), _defineProperty(_properties, 'chart.animation.unfold.x', false), _defineProperty(_properties, 'chart.animation.unfold.y', true), _defineProperty(_properties, 'chart.animation.unfold.initial', 2), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.curvy', false), _defineProperty(_properties, 'chart.line.visible', []), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.errorbars', false), _defineProperty(_properties, 'chart.errorbars.color', 'black'), _defineProperty(_properties, 'chart.errorbars.capped', true), _defineProperty(_properties, 'chart.errorbars.capped.width', 12), _defineProperty(_properties, 'chart.errorbars.linewidth', 1), _defineProperty(_properties, 'chart.combinedchart.effect', null), _defineProperty(_properties, 'chart.combinedchart.effect.options', null), _defineProperty(_properties, 'chart.combinedchart.effect.callback', null), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.dotted', false), _defineProperty(_properties, 'chart.dashed', false), _properties);\n  for (var i = 1; i < arguments.length; ++i) {\n    if (typeof arguments[i] == 'null' || !arguments[i]) {\n      arguments[i] = [];\n    }\n  }\n  this.original_data = [];if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && conf.data) {\n    if (typeof conf.data[0] === 'number' || RGraph.isNull(conf.data[0])) {\n      this.original_data[0] = RGraph.arrayClone(conf.data);\n    } else {\n      for (var i = 0; i < conf.data.length; ++i) {\n        this.original_data[i] = RGraph.arrayClone(conf.data[i]);\n      }\n    }\n  } else {\n    for (var i = 1; i < arguments.length; ++i) {\n      if (arguments[1] && _typeof(arguments[1]) == 'object' && arguments[1][0] && _typeof(arguments[1][0]) == 'object' && arguments[1][0].length) {\n        var tmp = [];for (var i = 0; i < arguments[1].length; ++i) {\n          tmp[i] = RGraph.array_clone(arguments[1][i]);\n        }\n        for (var j = 0; j < tmp.length; ++j) {\n          this.original_data[j] = RGraph.array_clone(tmp[j]);\n        }\n      } else {\n        this.original_data[i - 1] = RGraph.array_clone(arguments[i]);\n      }\n    }\n  }\n  if (!this.canvas) {\n    alert('[LINE] Fatal error: no canvas support');return;\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    for (var j = 0; j < this.original_data[i].length; ++j) {\n      if (typeof this.original_data[i][j] === 'string') {\n        this.original_data[i][j] = parseFloat(this.original_data[i][j]);\n      }\n    }\n  }\n  this.data_arr = RGraph.arrayLinearize(this.original_data);for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.tooltips' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value) {\n      var tooltips = [];for (var i = 1; i < arguments.length; i++) {\n        if (_typeof(arguments[i]) == 'object' && arguments[i][0]) {\n          for (var j = 0; j < arguments[i].length; j++) {\n            tooltips.push(arguments[i][j]);\n          }\n        } else if (typeof arguments[i] == 'function') {\n          tooltips = arguments[i];\n        } else {\n          tooltips.push(arguments[i]);\n        }\n      }\n      value = tooltips;\n    }\n    if (name == 'chart.linewidth' && navigator.userAgent.match(/Chrome/)) {\n      if (value == 1) {\n        value = 1.01;\n      } else if (RGraph.is_array(value)) {\n        for (var i = 0; i < value.length; ++i) {\n          if (typeof value[i] == 'number' && value[i] == 1) {\n            value[i] = 1.01;\n          }\n        }\n      }\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center' && value != 'top') {\n        alert('[LINE] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.xticks') {\n      name = 'chart.numxticks';\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    if (name == 'chart.ylabels.invert') {\n      name = 'chart.scale.invert';\n    }\n    this.properties[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.spline') {\n      name = 'chart.curvy';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] == 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.data = RG.array_clone(this.original_data);this.max = 0;if (prop['chart.filled'] && !prop['chart.filled.range'] && this.data.length > 1 && prop['chart.filled.accumulative']) {\n      var accumulation = [];for (var set = 0; set < this.data.length; ++set) {\n        for (var point = 0; point < this.data[set].length; ++point) {\n          this.data[set][point] = Number(accumulation[point] ? accumulation[point] : 0) + this.data[set][point];accumulation[point] = this.data[set][point];\n        }\n      }\n    }\n    if (prop['chart.ymax']) {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;if (!prop['chart.outofbounds']) {\n        for (dataset = 0; dataset < this.data.length; ++dataset) {\n          if (RGraph.isArray(this.data[dataset])) {\n            for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n              this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n            }\n          }\n        }\n      }\n    } else {\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;for (dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var datapoint = 0; datapoint < this.data[dataset].length; datapoint++) {\n          this.max = Math.max(this.max, this.data[dataset][datapoint] ? Math.abs(parseFloat(this.data[dataset][datapoint])) : 0);if (!prop['chart.outofbounds']) {\n            this.hasnegativevalues = this.data[dataset][datapoint] < 0 || this.hasnegativevalues;\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': prop['chart.ymin'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max ? this.scale2.max : 0;\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    this.coords = [];this.coordsText = [];this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.halfgrapharea = this.grapharea / 2;this.halfTextHeight = prop['chart.text.size'] / 2;if (prop['chart.variant'] == '3d') {\n      RG.Draw3DAxes(this);\n    }\n    RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.axesontop'] == false) {\n      this.DrawAxes();\n    }\n    co.save();\n    co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();for (var i = 0, j = 0, len = this.data.length; i < len; i++, j++) {\n      co.beginPath();if (!prop['chart.filled']) {\n        this.SetShadow(i);\n      }\n      if (prop['chart.fillstyle']) {\n        if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'][j]) {\n          var fill = prop['chart.fillstyle'][j];\n        } else if (_typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'].toString().indexOf('Gradient') > 0) {\n          var fill = prop['chart.fillstyle'];\n        } else if (typeof prop['chart.fillstyle'] == 'string') {\n          var fill = prop['chart.fillstyle'];\n        }\n      } else if (prop['chart.filled']) {\n        var fill = prop['chart.colors'][j];\n      } else {\n        var fill = null;\n      }\n      if (prop['chart.tickmarks'] && _typeof(prop['chart.tickmarks']) == 'object') {\n        var tickmarks = prop['chart.tickmarks'][i];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'string') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else if (prop['chart.tickmarks'] && typeof prop['chart.tickmarks'] == 'function') {\n        var tickmarks = prop['chart.tickmarks'];\n      } else {\n        var tickmarks = null;\n      }\n      if (prop['chart.outofbounds.clip']) {\n        pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n      this.drawLine(this.data[i], prop['chart.colors'][j], fill, this.getLineWidth(j), tickmarks, i);if (prop['chart.outofbounds.clip']) {\n        co.restore();\n      }\n      co.stroke();\n    }\n    if (prop['chart.outofbounds.clip']) {\n      pa2(co, 'sa b r % % % % cl b', 0, this.gutterTop, ca.width, ca.height - this.gutterTop - this.gutterBottom);\n    }\n    if (prop['chart.filled'] && prop['chart.filled.accumulative'] && !prop['chart.curvy']) {\n      for (var i = 0; i < this.coords2.length; ++i) {\n        co.beginPath();co.lineWidth = this.GetLineWidth(i);co.strokeStyle = !this.hidden(i) ? prop['chart.colors'][i] : 'rgba(0,0,0,0)';for (var j = 0, len = this.coords2[i].length; j < len; ++j) {\n          if (j == 0 || this.coords2[i][j][1] == null || this.coords2[i][j - 1] && this.coords2[i][j - 1][1] == null) {\n            co.moveTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          } else {\n            if (prop['chart.stepped']) {\n              co.lineTo(this.coords2[i][j][0], this.coords2[i][j - 1][1]);\n            }\n            co.lineTo(this.coords2[i][j][0], this.coords2[i][j][1]);\n          }\n        }\n        co.stroke();\n      }\n      if (prop['chart.tickmarks']) {\n        co.beginPath();co.fillStyle = 'white';for (var i = 0, len = this.coords2.length; i < len; ++i) {\n          co.beginPath();co.strokeStyle = prop['chart.colors'][i];for (var j = 0; j < this.coords2[i].length; ++j) {\n            if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n              var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], co.strokeStyle, false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n            }\n          }\n        }\n        co.stroke();co.fill();\n      }\n    } else if (prop['chart.filled'] && prop['chart.filled.accumulative'] && prop['chart.curvy']) {\n      for (var i = 0; i < this.coordsSpline.length; i += 1) {\n        co.beginPath();co.strokeStyle = prop['chart.colors'][i];co.lineWidth = this.GetLineWidth(i);for (var j = 0, len = this.coordsSpline[i].length; j < len; j += 1) {\n          var point = this.coordsSpline[i][j];j == 0 ? co.moveTo(point[0], point[1]) : co.lineTo(point[0], point[1]);\n        }\n        co.stroke();\n      }\n      for (var i = 0, len = this.coords2.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.coords2[i].length; j < len2; ++j) {\n          if (_typeof(this.coords2[i][j]) == 'object' && typeof this.coords2[i][j][0] == 'number' && typeof this.coords2[i][j][1] == 'number') {\n            var tickmarks = _typeof(prop['chart.tickmarks']) == 'object' && !RGraph.is_null(prop['chart.tickmarks']) ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];co.strokeStyle = prop['chart.colors'][i];this.DrawTick(this.coords2[i], this.coords2[i][j][0], this.coords2[i][j][1], prop['chart.colors'][i], false, j == 0 ? 0 : this.coords2[i][j - 1][0], j == 0 ? 0 : this.coords2[i][j - 1][1], tickmarks, j, i);\n          }\n        }\n      }\n    }\n    if (prop['chart.outofbounds.clip']) {\n      co.restore();\n    }\n    co.restore();co.beginPath();if (prop['chart.axesontop']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();this.DrawRange();if (prop['chart.key'] && prop['chart.key'].length && RG.DrawKey) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.drawAboveLabels();\n    }\n    RG.DrawInGraphLabels(this);if (prop['chart.filled'] && prop['chart.filled.range'] && this.data.length == 2) {\n      co.beginPath();var len = this.coords.length / 2;co.lineWidth = prop['chart.linewidth'];co.strokeStyle = this.hidden(0) ? 'rgba(0,0,0,0)' : prop['chart.colors'][0];for (var i = 0; i < len; ++i) {\n        if (!RG.isNull(this.coords[i][1])) {\n          if (i == 0) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.beginPath();if (prop['chart.colors'][1]) {\n        co.strokeStyle = this.hidden(1) ? 'rgba(0,0,0,0)' : prop['chart.colors'][1];\n      }\n      for (var i = this.coords.length - 1; i >= len; --i) {\n        if (!RG.is_null(this.coords[i][1])) {\n          if (i == this.coords.length - 1) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n      }\n      co.stroke();\n    } else if (prop['chart.filled'] && prop['chart.filled.range']) {\n      alert('[LINE] You must have only two sets of data for a filled range chart');\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    RG.noShadow(this);co.lineWidth = prop['chart.axis.linewidth'] + 0.001;co.lineCap = 'square';co.lineJoin = 'miter';co.strokeStyle = prop['chart.axis.color'];coords = { xaxis: {}, yaxis: {} };co.beginPath();if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        coords.xaxis = [this.gutterLeft, ma.round(this.grapharea / 2 + this.gutterTop), ca.width - this.gutterRight, ma.round(this.grapharea / 2 + this.gutterTop)];\n      } else if (prop['chart.xaxispos'] === 'top') {\n        coords.xaxis = [this.gutterLeft, this.gutterTop, ca.width - this.gutterRight, this.gutterTop];\n      } else {\n        var y = ma.round(this.getYCoord(prop['chart.ymin'] != 0 ? prop['chart.ymin'] : 0));if (prop['chart.scale.invert'] && prop['chart.ymin'] === 0) {\n          y = this.getYCoord(this.scale2.max);\n        } else if (prop['chart.scale.invert'] || prop['chart.ymin'] < 0) {\n          y = this.getYCoord(0);\n        }\n        coords.xaxis = [this.gutterLeft, y, ca.width - this.gutterRight, y];\n      }\n      co.moveTo(coords.xaxis[0], coords.xaxis[1]);co.lineTo(coords.xaxis[2], coords.xaxis[3]);this.coordsAxes = coords;\n    }\n    if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      var xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (!xTickInterval || xTickInterval <= 0) {\n        xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / (prop['chart.labels'] && prop['chart.labels'].length ? prop['chart.labels'].length - 1 : 10);\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' ? xTickInterval : 0); x <= ca.width - this.gutterRight + 1; x += xTickInterval) {\n        if (prop['chart.yaxispos'] == 'right' && x >= ca.width - this.gutterRight - 1) {\n          break;\n        }\n        if (prop['chart.noendxtick']) {\n          if (prop['chart.yaxispos'] == 'left' && x >= ca.width - this.gutterRight - 1) {\n            break;\n          } else if (prop['chart.yaxispos'] == 'right' && x == this.gutterLeft) {\n            continue;\n          }\n        }\n        var yStart = prop['chart.xaxispos'] === 'center' ? this.gutterTop + this.grapharea / 2 - 3 : ca.height - this.gutterBottom;var yEnd = prop['chart.xaxispos'] === 'center' ? yStart + 6 : ca.height - this.gutterBottom - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);if (prop['chart.ymin'] >= 0 && prop['chart.xaxispos'] === 'bottom') {\n          var yStart = this.getYCoord(prop['chart.ymin']) - (prop['chart.ymin'] >= 0 ? 0 : 3),\n              yEnd = this.getYCoord(prop['chart.ymin']) + 3;if (prop['chart.scale.invert']) {\n            yStart = ca.height - prop['chart.gutter.bottom'];yEnd = yStart + 3;\n          }\n        } else if (prop['chart.xaxispos'] == 'center') {\n          var yStart = Math.round(this.gutterTop + this.grapharea / 2) - 3,\n              yEnd = yStart + 6;\n        } else if (prop['chart.xaxispos'] == 'bottom') {\n          var yStart = this.getYCoord(0) - (prop['chart.ymin'] !== 0 ? 3 : 0),\n              yEnd = this.getYCoord(0) - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);yEnd += 0;\n        } else if (prop['chart.xaxispos'] == 'top') {\n          yStart = this.gutterTop - 3;yEnd = this.gutterTop;\n        }\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n    } else if (prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0) {\n      if (!prop['chart.noendytick']) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        } else {\n          co.moveTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\n        }\n      }\n    }\n    var numyticks = prop['chart.numyticks'];if (prop['chart.noyaxis'] == false && numyticks > 0) {\n      var counter = 0,\n          adjustment = 0;if (prop['chart.yaxispos'] == 'right') {\n        adjustment = ca.width - this.gutterLeft - this.gutterRight;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < this.grapharea / 2 + this.gutterTop; y += interval) {\n          if (y < this.grapharea / 2 + this.gutterTop) {\n            co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n          }\n        }\n        for (y = this.gutterTop + this.halfgrapharea + interval; y <= this.grapharea + this.gutterTop; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var interval = this.grapharea / numyticks;var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop + interval; y <= this.grapharea + this.gutterBottom; y += interval) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, Math.round(y));co.lineTo(lineto, Math.round(y));\n        }\n        if (prop['chart.noxaxis'] && prop['chart.noendytick'] == false) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight, this.gutterTop);co.lineTo(lineto, this.gutterTop);\n        }\n      } else {\n        var lineto = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight + prop['chart.smallyticks'];for (y = this.gutterTop; y < ca.height - this.gutterBottom && counter < numyticks; y += (ca.height - this.gutterTop - this.gutterBottom) / numyticks) {\n          if (ma.round(y) !== ma.round(this.coordsAxes.xaxis[1])) {\n            co.moveTo(this.gutterLeft + adjustment, ma.round(y));co.lineTo(lineto, ma.round(y));\n          }\n          var counter = counter + 1;\n        }\n        if (prop['chart.ymin'] < 0) {\n          co.moveTo(prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight, ma.round(y));co.lineTo(lineto, ma.round(y));\n        }\n      }\n    } else if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop : ca.height - this.gutterBottom);co.lineTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop - prop['chart.smallxticks'] : ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom + prop['chart.smallxticks']);\n      }\n    }\n    co.stroke();co.beginPath();\n  };this.drawLabels = this.DrawLabels = function () {\n    co.strokeStyle = 'black';co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;RG.NoShadow(this);var font = prop['chart.text.font'];var text_size = prop['chart.text.size'];var decimals = prop['chart.scale.decimals'];var context = co;var canvas = ca;var ymin = prop['chart.ymin'];if (prop['chart.ylabels'] && prop['chart.ylabels.specific'] == null) {\n      var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var numYLabels = this.scale2.labels.length;var bounding = false;var bgcolor = prop['chart.ylabels.inside'] ? prop['chart.ylabels.inside.color'] : null;var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.ylabels.inside'] == true && align == 'left') {\n        xpos -= 10;align = 'right';bounding = true;\n      } else if (prop['chart.ylabels.inside'] == true && align == 'right') {\n        xpos += 10;align = 'left';bounding = true;\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        var half = this.grapharea / 2;for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half - (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n        }\n        for (var i = 0; i < this.scale2.labels.length; ++i) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + (i + 1) / numYLabels * half + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n        }\n        if (prop['chart.noxaxis'] == true || ymin != 0 || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + half + offsety, 'text': prop['chart.units.pre'] + ymin.toFixed(ymin === 0 ? 0 : decimals) + prop['chart.units.post'], 'bounding': bounding, 'boundingFill': bgcolor, 'valign': 'center', 'halign': align, 'tag': 'scale' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var half = this.grapharea / 2;if (prop['chart.scale.invert']) {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0; i < this.scale2.labels.length; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / numYLabels * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.invert'] || prop['chart.scale.zerostart']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? ca.height - this.gutterBottom + offsety : this.gutterTop + offsety, 'text': (prop['chart.ymin'] != 0 ? '-' : '') + RG.numberFormat(this, prop['chart.ymin'].toFixed(ymin === 0 ? 0 : decimals), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      } else {\n        if (prop['chart.scale.invert']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': RG.numberFormat(this, this.min.toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[i], 'tag': 'scale' });\n          }\n        } else {\n          for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': this.gutterTop + i / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n          }\n        }\n        if (prop['chart.ymin'] != 0 && !prop['chart.scale.invert'] || prop['chart.scale.zerostart'] || prop['chart.noxaxis']) {\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.scale.invert'] ? this.gutterTop + offsety : ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n        }\n      }\n      if (prop['chart.noxaxis'] == true && prop['chart.ymin'] == null && prop['chart.xaxispos'] != 'center' && prop['chart.noendytick'] == false) {\n        RG.text2(this, { 'font': font, 'size': text_size, 'x': xpos + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + offsety : ca.height - this.gutterBottom, 'text': prop['chart.units.pre'] + Number(0).toFixed(prop['chart.scale.decimals']) + prop['chart.units.post'] + offsety, 'valign': 'center', 'halign': align, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'scale' });\n      }\n    } else if (prop['chart.ylabels'] && _typeof(prop['chart.ylabels.specific']) == 'object') {\n      var gap = this.grapharea / prop['chart.ylabels.specific'].length;var halign = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';var bounding = false;var bgcolor = null;var ymin = prop['chart.ymin'] != null && prop['chart.ymin'];if (prop['chart.yaxispos'] == 'left') {\n        var x = this.gutterLeft - 5;if (prop['chart.ylabels.inside']) {\n          x += 10;halign = 'left';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      } else if (prop['chart.yaxispos'] == 'right') {\n        var x = ca.width - this.gutterRight + 5;if (prop['chart.ylabels.inside']) {\n          x -= 10;halign = 'right';bounding = true;bgcolor = 'rgba(255,255,255,0.5)';\n        }\n      }\n      var offsetx = prop['chart.ylabels.offsetx'];var offsety = prop['chart.ylabels.offsety'];if (prop['chart.xaxispos'] == 'center') {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / ((prop['chart.ylabels.specific'].length - 1) * 2) * i;if (ymin && ymin > 0) {\n            var y = this.grapharea / 2 / (prop['chart.ylabels.specific'].length - (ymin ? 1 : 0)) * i;y += this.gutterTop;\n          }\n          RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / 2 + this.gutterTop + this.grapharea / ((reversed_labels.length - 1) * 2) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': i == 0 ? '' : String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else if (prop['chart.xaxispos'] == 'top') {\n        var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);for (var i = 0; i < reversed_labels.length; ++i) {\n          var y = this.grapharea / (reversed_labels.length - 1) * i;y = y + this.gutterTop;RG.Text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(reversed_labels[i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      } else {\n        for (var i = 0; i < prop['chart.ylabels.specific'].length; ++i) {\n          var y = this.gutterTop + this.grapharea / (prop['chart.ylabels.specific'].length - 1) * i;RG.text2(this, { 'font': font, 'size': text_size, 'x': x + offsetx, 'y': y + offsety, 'text': String(prop['chart.ylabels.specific'][i]), 'valign': 'center', 'halign': halign, 'bounding': bounding, 'boundingFill': bgcolor, 'tag': 'ylabels.specific' });\n        }\n      }\n    }\n    if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\n      var yOffset = 5,\n          bordered = false,\n          bgcolor = null;\n      co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var angle = 0,\n          valign = 'top',\n          halign = 'center',\n          bold = prop['chart.labels.bold'];\n      if (prop['chart.xlabels.inside']) {\n        yOffset = -5;bordered = true;bgcolor = prop['chart.xlabels.inside.color'];valign = 'bottom';\n      }\n      if (prop['chart.xaxispos'] == 'top') {\n        valign = 'bottom';yOffset += 2;\n      }\n      if (typeof prop['chart.text.angle'] == 'number' && prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yOffset = 10;if (prop['chart.xaxispos'] == 'top') {\n          yOffset = 10;\n        }\n      }\n      var numLabels = prop['chart.labels'].length,\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];for (i = 0; i < numLabels; ++i) {\n        if (prop['chart.labels'][i]) {\n          var labelX = (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) / (numLabels - 1) * i;labelX += this.gutterLeft + prop['chart.hmargin'];if (this.data.length === 0 || !this.data[0] || prop['chart.labels'].length != this.data[0].length) {\n            labelX = this.gutterLeft + prop['chart.hmargin'] + (ca.width - this.gutterLeft - this.gutterRight - 2 * prop['chart.hmargin']) * (i / (prop['chart.labels'].length - 1));\n          }\n          if (!labelX) {\n            labelX = this.gutterLeft + prop['chart.hmargin'];\n          }\n          if (prop['chart.xaxispos'] == 'top' && prop['chart.text.angle'] > 0) {\n            halign = 'left';\n          }\n          if (prop['chart.text.angle'] != 0) {\n            halign = 'right';\n          }\n          RG.Text2(this, { 'font': font, 'size': text_size, 'bold': bold, 'x': labelX + offsetx, 'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop - yOffset - (prop['chart.xlabels.inside'] ? -22 : 0) + offsety : ca.height - this.gutterBottom + yOffset + offsety, 'text': String(prop['chart.labels'][i]), 'valign': valign, 'halign': halign, 'bounding': bordered, 'boundingFill': bgcolor, 'angle': angle, 'tag': 'labels' });\n        }\n      }\n    }\n    co.stroke();co.fill();\n  };\n  this.drawLine = this.DrawLine = function (lineData, color, fill, linewidth, tickmarks, index) {\n    if (prop['chart.animation.unfold.y'] && prop['chart.animation.factor'] != 1) {\n      for (var i = 0; i < lineData.length; ++i) {\n        lineData[i] *= prop['chart.animation.factor'];\n      }\n    }\n    var penUp = false;var yPos = null;var xPos = 0;co.lineWidth = 1;var lineCoords = [];if (index > 0) {\n      var prevLineCoords = this.coords2[index - 1];\n    }\n    var xInterval = (ca.width - 2 * prop['chart.hmargin'] - this.gutterLeft - this.gutterRight) / (lineData.length - 1);for (i = 0, len = lineData.length; i < len; i += 1) {\n      var data_point = lineData[i];var yPos = this.getYCoord(data_point);if (lineData[i] == null || prop['chart.xaxispos'] == 'bottom' && lineData[i] < this.min && !prop['chart.outofbounds'] || prop['chart.xaxispos'] == 'center' && lineData[i] < -1 * this.max && !prop['chart.outofbounds'] || (lineData[i] < this.min && prop['chart.xaxispos'] !== 'center' || lineData[i] > this.max) && !prop['chart.outofbounds']) {\n        yPos = null;\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';if (i > 0) {\n        xPos = xPos + xInterval;\n      } else {\n        xPos = prop['chart.hmargin'] + this.gutterLeft;\n      }\n      if (prop['chart.animation.unfold.x']) {\n        xPos *= prop['chart.animation.factor'];if (xPos < prop['chart.gutter.left']) {\n          xPos = prop['chart.gutter.left'];\n        }\n      }\n      this.coords.push([xPos, yPos]);lineCoords.push([xPos, yPos]);\n    }\n    co.stroke();this.coords2[index] = lineCoords;if (RG.ISOLD && prop['chart.shadow']) {\n      this.DrawIEShadow(lineCoords, co.shadowColor);\n    }\n    co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';if (fill) {\n      co.fillStyle = fill;\n    }\n    var isStepped = prop['chart.stepped'];var isFilled = prop['chart.filled'];if (prop['chart.xaxispos'] == 'top') {\n      var xAxisPos = this.gutterTop;\n    } else if (prop['chart.xaxispos'] == 'center') {\n      var xAxisPos = this.gutterTop + this.grapharea / 2;\n    } else if (prop['chart.xaxispos'] == 'bottom') {\n      var xAxisPos = this.getYCoord(prop['chart.ymin']);\n    }\n    for (var i = 0, len = lineCoords.length; i < len; i += 1) {\n      xPos = lineCoords[i][0];yPos = lineCoords[i][1];var set = index;var prevY = lineCoords[i - 1] ? lineCoords[i - 1][1] : null;var isLast = i + 1 == lineCoords.length;if (!prop['chart.outofbounds'] && (prevY < this.gutterTop || prevY > ca.height - this.gutterBottom)) {\n        penUp = true;\n      }\n      if (i == 0 || penUp || !yPos || !prevY || prevY < this.gutterTop) {\n        if (prop['chart.filled'] && !prop['chart.filled.range']) {\n          if (!prop['chart.outofbounds'] || prevY === null || yPos === null) {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (prop['chart.xaxispos'] == 'top') {\n            co.moveTo(xPos + 1, xAxisPos);\n          }\n          if (isStepped && i > 0) {\n            co.lineTo(xPos, lineCoords[i - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        } else {\n          if (RG.ISOLD && yPos == null) {} else {\n            co.moveTo(xPos + 1, yPos);\n          }\n        }\n        if (yPos == null) {\n          penUp = true;\n        } else {\n          penUp = false;\n        }\n      } else {\n        if (isStepped) {\n          co.lineTo(xPos, lineCoords[i - 1][1]);\n        }\n        if (yPos >= this.gutterTop && yPos <= ca.height - this.gutterBottom || prop['chart.outofbounds']) {\n          if (isLast && prop['chart.filled'] && !prop['chart.filled.range'] && prop['chart.yaxispos'] == 'right') {\n            xPos -= 1;\n          }\n          if (!isStepped || !isLast) {\n            co.lineTo(xPos, yPos);if (isFilled && lineCoords[i + 1] && lineCoords[i + 1][1] == null) {\n              co.lineTo(xPos, xAxisPos);\n            }\n          } else if (isStepped && isLast) {\n            co.lineTo(xPos, yPos);\n          }\n          penUp = false;\n        } else {\n          penUp = true;\n        }\n      }\n    }\n    if (prop['chart.filled'] && !prop['chart.filled.range'] && !prop['chart.curvy']) {\n      var fillStyle = prop['chart.fillstyle'];if (index > 0 && prop['chart.filled.accumulative']) {\n        co.lineTo(xPos, prevLineCoords ? prevLineCoords[i - 1][1] : ca.height - this.gutterBottom - 1 + (prop['chart.xaxispos'] == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 : 0));for (var k = i - 1; k >= 0; --k) {\n          co.lineTo(k == 0 ? prevLineCoords[k][0] + 1 : prevLineCoords[k][0], prevLineCoords[k][1]);\n        }\n      } else {\n        if (prop['chart.xaxispos'] == 'top') {\n          co.lineTo(xPos, prop['chart.gutter.top'] + 1);co.lineTo(lineCoords[0][0], prop['chart.gutter.top'] + 1);\n        } else if (typeof lineCoords[i - 1][1] == 'number') {\n          var yPosition = this.getYCoord(0);co.lineTo(xPos, yPosition);co.lineTo(lineCoords[0][0], yPosition);\n        }\n      }\n      co.fillStyle = !this.hidden(index) ? fill : 'rgba(0,0,0,0)';co.fill();co.beginPath();\n    }\n    co.stroke();if (prop['chart.backdrop']) {\n      this.DrawBackdrop(lineCoords, color);\n    }\n    co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();if (typeof prop['chart.errorbars'] !== 'null') {\n      this.drawErrorbars();\n    }\n    this.SetShadow(index);this.redrawLine(lineCoords, color, linewidth, index);co.stroke();RG.NoShadow(this);for (var i = 0; i < lineCoords.length; ++i) {\n      i = Number(i);co.strokeStyle = color;if (isStepped && i == lineCoords.length - 1) {\n        co.beginPath();\n      }\n      if (tickmarks != 'endcircle' && tickmarks != 'endsquare' && tickmarks != 'filledendsquare' && tickmarks != 'endtick' && tickmarks != 'endtriangle' && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == 0 && tickmarks != 'arrow' && tickmarks != 'filledarrow' || i == lineCoords.length - 1) {\n        var prevX = i <= 0 ? null : lineCoords[i - 1][0];var prevY = i <= 0 ? null : lineCoords[i - 1][1];this.DrawTick(lineData, lineCoords[i][0], lineCoords[i][1], color, false, prevX, prevY, tickmarks, i, index);\n      }\n    }\n    co.restore();co.beginPath();co.arc(ca.width + 50000, ca.height + 50000, 2, 0, 6.38, 1);\n  };this.drawTick = this.DrawTick = function (lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index, dataset) {\n    if (this.hidden(dataset)) {\n      return;\n    } else if (RG.is_null(yPos)) {\n      return false;\n    } else if (yPos > ca.height - this.gutterBottom && !prop['chart.outofbounds']) {\n      return;\n    } else if (yPos < this.gutterTop && !prop['chart.outofbounds']) {\n      return;\n    }\n    co.beginPath();var offset = 0;co.lineWidth = prop['chart.tickmarks.linewidth'] ? prop['chart.tickmarks.linewidth'] : prop['chart.linewidth'];co.strokeStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle') {\n      if (tickmarks == 'circle' || tickmarks == 'filledcircle' || tickmarks == 'endcircle' && (index == 0 || index == lineData.length - 1)) {\n        co.beginPath();co.arc(xPos + offset, yPos + offset, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false);if (tickmarks == 'filledcircle') {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n        } else {\n          co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';\n        }\n        co.stroke();co.fill();\n      }\n    } else if (tickmarks == 'halftick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'tick') {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'endtick' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();co.moveTo(Math.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);co.stroke();\n    } else if (tickmarks == 'cross') {\n      co.beginPath();var ticksize = prop['chart.ticksize'];co.moveTo(xPos - ticksize, yPos - ticksize);co.lineTo(xPos + ticksize, yPos + ticksize);co.moveTo(xPos + ticksize, yPos - ticksize);co.lineTo(xPos - ticksize, yPos + ticksize);co.stroke();\n    } else if (tickmarks == 'triangle' || tickmarks == 'filledtriangle' || tickmarks == 'endtriangle' && (index == 0 || index == lineData.length - 1)) {\n      co.beginPath();if (tickmarks == 'filledtriangle') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\n      } else {\n        co.fillStyle = 'white';\n      }\n      co.moveTo(ma.round(xPos - prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.lineTo(ma.round(xPos), yPos - prop['chart.ticksize']);co.lineTo(ma.round(xPos + prop['chart.ticksize']), yPos + prop['chart.ticksize']);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'borderedcircle' || tickmarks == 'dot') {\n      co.lineWidth = prop['chart.tickmarks.dot.linewidth'] || 0.00000001;pa2(co, ['b', 'a', xPos, yPos, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false, 'c', 'f', prop['chart.tickmarks.dot.fill'] || color, 's', prop['chart.tickmarks.dot.stroke'] || color]);\n    } else if (tickmarks == 'square' || tickmarks == 'filledsquare' || tickmarks == 'endsquare' && (index == 0 || index == lineData.length - 1) || tickmarks == 'filledendsquare' && (index == 0 || index == lineData.length - 1)) {\n      co.fillStyle = 'white';co.strokeStyle = co.strokeStyle;co.beginPath();co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);if (tickmarks == 'filledsquare' || tickmarks == 'filledendsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);\n      } else if (tickmarks == 'square' || tickmarks == 'endsquare') {\n        co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';co.rect(Math.round(xPos - prop['chart.ticksize'] + 1), Math.round(yPos - prop['chart.ticksize'] + 1), prop['chart.ticksize'] * 2 - 2, prop['chart.ticksize'] * 2 - 2);\n      }\n      co.stroke();co.fill();\n    } else if (tickmarks == 'filledarrow') {\n      var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5, a + 0.5, false);co.closePath();co.stroke();co.fill();\n    } else if (tickmarks == 'arrow') {\n      var orig_linewidth = co.lineWidth;var x = Math.abs(xPos - prevX);var y = Math.abs(yPos - prevY);co.lineWidth;if (yPos < prevY) {\n        var a = Math.atan(x / y) + 1.57;\n      } else {\n        var a = Math.atan(y / x) + 3.14;\n      }\n      co.beginPath();co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5 - (doc.all ? 0.1 : 0.01), a - 0.4, false);co.moveTo(Math.round(xPos), Math.round(yPos));co.arc(Math.round(xPos), Math.round(yPos), 7, a + 0.5 + (doc.all ? 0.1 : 0.01), a + 0.5, true);co.stroke();co.fill();co.lineWidth = orig_linewidth;\n    } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n      var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n        img.src = tickmarks.substr(6);\n      } else {\n        img.src = tickmarks;\n      }\n      img.onload = function () {\n        if (prop['chart.tickmarks.image.halign'] === 'center') xPos -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') xPos -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yPos -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yPos -= this.height;xPos += prop['chart.tickmarks.image.offsetx'];yPos += prop['chart.tickmarks.image.offsety'];co.drawImage(this, xPos, yPos);\n      };\n    } else if (typeof tickmarks == 'function') {\n      tickmarks(this, lineData, lineData[index], index, xPos, yPos, color, prevX, prevY);\n    }\n  };this.drawRange = this.DrawRange = function () {\n    if (prop['chart.filled.range'] && prop['chart.filled']) {\n      if (RG.isNull(prop['chart.filled.range.threshold'])) {\n        prop['chart.filled.range.threshold'] = this.ymin;\n        prop['chart.filled.range.threshold.colors'] = [prop['chart.fillstyle'], prop['chart.fillstyle']];\n      }\n      for (var idx = 0; idx < 2; ++idx) {\n        var threshold_colors = prop['chart.filled.range.threshold.colors'];var y = this.getYCoord(prop['chart.filled.range.threshold']);\n        co.save();if (idx == 0) {\n          co.beginPath();co.rect(0, 0, ca.width, y);co.clip();\n        } else {\n          co.beginPath();co.rect(0, y, ca.width, ca.height);co.clip();\n        }\n        co.beginPath();co.fillStyle = idx == 1 ? prop['chart.filled.range.threshold.colors'][1] : prop['chart.filled.range.threshold.colors'][0];co.lineWidth = !this.hidden(idx) ? 1 : 0;var len = this.coords.length / 2;for (var i = 0; i < len; ++i) {\n          if (!RG.is_null(this.coords[i][1])) {\n            if (i == 0) {\n              co.moveTo(this.coords[i][0], this.coords[i][1]);\n            } else {\n              co.lineTo(this.coords[i][0], this.coords[i][1]);\n            }\n          }\n        }\n        for (var i = this.coords.length - 1; i >= len; --i) {\n          if (RG.is_null(this.coords[i][1])) {\n            co.moveTo(this.coords[i][0], this.coords[i][1]);\n          } else {\n            co.lineTo(this.coords[i][0], this.coords[i][1]);\n          }\n        }\n        co.fill();co.restore();\n      }\n    }\n  };this.redrawLine = this.RedrawLine = function (coords, color, linewidth, index) {\n    if (prop['chart.noredraw'] || prop['chart.filled.range']) {\n      return;\n    }\n    co.strokeStyle = (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color && color.toString().indexOf('CanvasGradient') == -1 ? color[0] : color;co.lineWidth = linewidth;if (prop['chart.dashed']) {\n      co.setLineDash([2, 6]);\n    } else if (prop['chart.dotted']) {\n      co.setLineDash([1, 5]);\n    }\n    if (this.hidden(index)) {\n      co.strokeStyle = 'rgba(0,0,0,0)';\n    }\n    if (!RG.ISOLD && (prop['chart.curvy'] || prop['chart.spline'])) {\n      this.DrawCurvyLine(coords, this.hidden(index) ? 'rgba(0,0,0,0)' : color, linewidth, index);return;\n    }\n    co.beginPath();var len = coords.length;var width = ca.width;\n    var height = ca.height;var penUp = false;for (var i = 0; i < len; ++i) {\n      var xPos = coords[i][0];var yPos = coords[i][1];if (i > 0) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];\n      }\n      if ((i == 0 && coords[i] || yPos < this.gutterTop || prevY < this.gutterTop || yPos > height - this.gutterBottom || i > 0 && prevX > width - this.gutterRight || i > 0 && prevY > height - this.gutterBottom || prevY == null || penUp == true) && (!prop['chart.outofbounds'] || yPos == null || prevY == null)) {\n        if (RG.ISOLD && yPos == null) {} else {\n          co.moveTo(coords[i][0], coords[i][1]);\n        }\n        penUp = false;\n      } else {\n        if (prop['chart.stepped'] && i > 0) {\n          co.lineTo(coords[i][0], coords[i - 1][1]);\n        }\n        co.lineTo(coords[i][0], coords[i][1]);penUp = false;\n      }\n    }\n    if (prop['chart.colors.alternate'] && (typeof color === 'undefined' ? 'undefined' : _typeof(color)) == 'object' && color[0] && color[1]) {\n      for (var i = 1; i < len; ++i) {\n        var prevX = coords[i - 1][0];var prevY = coords[i - 1][1];if (prevY != null && coords[i][1] != null) {\n          co.beginPath();co.strokeStyle = color[coords[i][1] < prevY ? 0 : 1];co.lineWidth = prop['chart.linewidth'];co.moveTo(prevX, prevY);co.lineTo(coords[i][0], coords[i][1]);co.stroke();\n        }\n      }\n    }\n    if (prop['chart.dashed'] || prop['chart.dotted']) {\n      co.setLineDash([1, 0]);\n    }\n  };this.drawIEShadow = this.DrawIEShadow = function (coords, color) {\n    var offsetx = prop['chart.shadow.offsetx'];var offsety = prop['chart.shadow.offsety'];co.lineWidth = prop['chart.linewidth'];co.strokeStyle = color;co.beginPath();for (var i = 0; i < coords.length; ++i) {\n      var isNull = RG.isNull(coords[i][1]);var prevIsNull = RG.isNull(coords[i - 1]) || RG.isNull(coords[i - 1][1]);if (i == 0 || isNull || prevIsNull) {\n        if (!isNull) {\n          co.moveTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n        }\n      } else {\n        co.lineTo(coords[i][0] + offsetx, coords[i][1] + offsety);\n      }\n    }\n    co.stroke();\n  };this.drawBackdrop = this.DrawBackdrop = function (coords, color) {\n    var size = prop['chart.backdrop.size'];co.lineWidth = size;co.globalAlpha = prop['chart.backdrop.alpha'];co.strokeStyle = color;var yCoords = [];co.beginPath();if (prop['chart.curvy'] && !RG.ISOLD) {\n      for (var i = 0; i < coords.length; ++i) {\n        yCoords.push(coords[i][1]);\n      }\n      this.DrawSpline(co, yCoords, color, null);\n    } else {\n      co.moveTo(coords[0][0], coords[0][1]);for (var j = 1; j < coords.length; ++j) {\n        co.lineTo(coords[j][0], coords[j][1]);\n      }\n    }\n    co.stroke();co.globalAlpha = 1;RG.NoShadow(this);\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[LINE] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var obj = this,\n        RG = RGraph,\n        ca = canvas = e.target,\n        co = context = this.context,\n        prop = this.properties;var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];if (arguments[1]) {\n      obj = arguments[1];\n    }\n    for (var i = 0; i < obj.coords.length; ++i) {\n      var x = obj.coords[i][0];var y = obj.coords[i][1];if (mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size'] && mouseY <= y + prop['chart.tooltips.hotspot.size'] && mouseY >= y - prop['chart.tooltips.hotspot.size']) {\n        if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);\n        }\n        var dataset = 0;var idx = i;while (idx + 1 > this.data[dataset].length) {\n          idx -= this.data[dataset].length;dataset++;\n        }\n        return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip, 'dataset': dataset, 'index_adjusted': idx };\n      } else if (prop['chart.tooltips.hotspot.xonly'] == true && mouseX <= x + prop['chart.tooltips.hotspot.size'] && mouseX >= x - prop['chart.tooltips.hotspot.size']) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: obj, 1: x, 2: y, 3: i, 'object': obj, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'],\n        font = prop['chart.labels.above.font'] || prop['chart.text.font'],\n        units_pre = prop['chart.labels.above.units.pre'],\n        units_post = prop['chart.labels.above.units.post'],\n        decimals = prop['chart.labels.above.decimals'],\n        color = prop['chart.labels.above.color'] || prop['chart.text.color'],\n        bgcolor = prop['chart.labels.above.background'] || 'white',\n        border = typeof prop['chart.labels.above.border'] === 'boolean' || typeof prop['chart.labels.above.border'] === 'number' ? prop['chart.labels.above.border'] : true,\n        offsety = prop['chart.labels.above.offsety'] + size,\n        specific = prop['chart.labels.above.specific'];co.beginPath();for (var i = 0, len = this.coords.length; i < len; i += 1) {\n      var coords = this.coords[i];RG.text2(this, { color: color, 'font': font, 'size': size, 'x': coords[0], 'y': coords[1] - offsety, 'text': specific && specific[i] ? specific[i] : specific ? null : RG.numberFormat(this, typeof decimals === 'number' ? this.data_arr[i].toFixed(decimals) : this.data_arr[i], units_pre, units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': bgcolor, 'boundingStroke': border ? 'black' : 'rgba(0,0,0,0)', 'tag': 'labels.above' });\n    }\n  };this.drawCurvyLine = this.DrawCurvyLine = function (coords, color, linewidth, index) {\n    var yCoords = [];for (var i = 0; i < coords.length; ++i) {\n      yCoords.push(coords[i][1]);\n    }\n    if (prop['chart.filled']) {\n      co.beginPath();var xaxisY = this.getYCoord(prop['chart.ymin']);co.moveTo(coords[0][0], xaxisY);this.drawSpline(co, yCoords, color, index);if (prop['chart.filled.accumulative'] && index > 0) {\n        for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; i -= 1) {\n          co.lineTo(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]);\n        }\n      } else {\n        co.lineTo(coords[coords.length - 1][0], xaxisY);\n      }\n      co.fill();\n    }\n    co.beginPath();this.DrawSpline(co, yCoords, color, index);co.stroke();\n  };this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;var xaxispos = prop['chart.xaxispos'];if (mouseY < prop['chart.gutter.top']) {\n      return xaxispos == 'bottom' || xaxispos == 'center' ? this.max : this.min;\n    } else if (mouseY > ca.height - prop['chart.gutter.bottom']) {\n      return xaxispos == 'bottom' ? this.min : this.max;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (obj.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value *= 2;value > 0 ? value += this.min : value -= this.min;return value;\n    } else if (prop['chart.xaxispos'] == 'top') {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);value = Math.abs(obj.max - value) * -1;return value;\n    } else {\n      var value = (obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea * (obj.max - obj.min);\n      value += obj.min;return value;\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] === 'halo') {\n        var obj = shape.object,\n            color = prop['chart.colors'][shape.dataset];RG.path2(obj.context, 'b a % % 13 0 6.2830 false f rgba(255,255,255,0.75)', shape.x, shape.y);RG.path2(obj.context, 'ga 0.15 b a % % 13 0 6.2830 false f % ga 1', shape.x, shape.y, color);RG.path2(obj.context, 'b a % % 7 0 6.2830 false f white', shape.x, shape.y);RG.path2(obj.context, 'b a % % 5 0 6.2830 false f %', shape.x, shape.y, color);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > prop['chart.gutter.left'] - 5 && mouseXY[0] < ca.width - prop['chart.gutter.right'] + 5 && mouseXY[1] > prop['chart.gutter.top'] - 5 && mouseXY[1] < ca.height - prop['chart.gutter.bottom'] + 5) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = Number(this.getValue(e));var shape = RG.Registry.Get('chart.adjusting.shape');if (shape) {\n        RG.Registry.Set('chart.adjusting.shape', shape);this.original_data[shape['dataset']][shape['index_adjusted']] = Number(value);RG.redrawCanvas(e.target);RG.fireCustomEvent(this, 'onadjust');\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var y;var xaxispos = prop['chart.xaxispos'];if (xaxispos == 'top') {\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = y + this.gutterTop;\n    } else if (xaxispos == 'center') {\n      y = (value - this.min) / (this.max - this.min) * (this.grapharea / 2);y = this.grapharea / 2 - y;y += this.gutterTop;\n    } else {\n      if ((value < this.min || value > this.max) && prop['chart.outofbounds'] == false) {\n        return null;\n      }\n      y = (value - this.min) / (this.max - this.min) * this.grapharea;if (prop['chart.scale.invert']) {\n        y = this.grapharea - y;\n      }\n      y = ca.height - this.gutterBottom - y;\n    }\n    return y;\n  };this.drawSpline = this.DrawSpline = function (context, coords, color, index) {\n    this.coordsSpline[index] = [];var xCoords = [];var gutterLeft = prop['chart.gutter.left'];var gutterRight = prop['chart.gutter.right'];var hmargin = prop['chart.hmargin'];var interval = (ca.width - (gutterLeft + gutterRight) - 2 * hmargin) / (coords.length - 1);co.strokeStyle = color;for (var i = 0, len = coords.length; i < len; i += 1) {\n      if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n        coords[i] = Number(coords[i][1]);\n      }\n    }\n    var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n      P.push(coords[i]);\n    }\n    P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n      for (var t = 0; t < 10; ++t) {\n        var yCoord = Spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);co.lineTo(xCoords[xCoords.length - 1], yCoord);if (typeof index == 'number') {\n          this.coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n        }\n      }\n    }\n    co.lineTo((j - 1) * interval + gutterLeft + hmargin, P[j]);if (typeof index == 'number') {\n      this.coordsSpline[index].push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n    }\n    function Spline(t, P0, P1, P2, P3) {\n      return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);this.original_colors['chart.fillstyle'] = RGraph.array_clone(prop['chart.fillstyle']);this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];this.original_colors['chart.background.color'] = prop['chart.background.color'];this.original_colors['chart.text.color'] = prop['chart.text.color'];this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];this.original_colors['chart.annotate.color'] = prop['chart.annotate.color'];this.original_colors['chart.title.color'] = prop['chart.title.color'];this.original_colors['chart.title.yaxis.color'] = prop['chart.title.yaxis.color'];this.original_colors['chart.key.background'] = prop['chart.key.background'];this.original_colors['chart.axis.color'] = prop['chart.axis.color'];this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      if (_typeof(prop['chart.colors'][i]) == 'object' && prop['chart.colors'][i][0] && prop['chart.colors'][i][1]) {\n        prop['chart.colors'][i][0] = this.parseSingleColorForGradient(prop['chart.colors'][i][0]);prop['chart.colors'][i][1] = this.parseSingleColorForGradient(prop['chart.colors'][i][1]);\n      } else {\n        prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n      }\n    }\n    if (prop['chart.fillstyle']) {\n      if (typeof prop['chart.fillstyle'] == 'string') {\n        prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle'], 'vertical');\n      } else {\n        for (var i = 0; i < prop['chart.fillstyle'].length; ++i) {\n          prop['chart.fillstyle'][i] = this.parseSingleColorForGradient(prop['chart.fillstyle'][i], 'vertical');\n        }\n      }\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    var properties = ['chart.background.barcolor1', 'chart.background.barcolor2', 'chart.background.grid.color', 'chart.background.color', 'chart.text.color', 'chart.crosshairs.color', 'chart.annotate.color', 'chart.title.color', 'chart.title.yaxis.color', 'chart.key.background', 'chart.axis.color', 'chart.highlight.fill'];for (var i = 0; i < properties.length; ++i) {\n      prop[properties[i]] = this.parseSingleColorForGradient(prop[properties[i]]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    var dir = typeof arguments[1] == 'string' ? arguments[1] : 'vertical';if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (dir == 'horizontal') {\n        var grad = co.createLinearGradient(0, 0, ca.width, 0);\n      } else {\n        var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);\n      }\n      var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.setShadow = this.SetShadow = function (i) {\n    if (prop['chart.shadow']) {\n      var shadowColor = prop['chart.shadow.color'];if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object' && shadowColor[i - 1]) {\n        co.shadowColor = shadowColor[i];\n      } else if ((typeof shadowColor === 'undefined' ? 'undefined' : _typeof(shadowColor)) == 'object') {\n        co.shadowColor = shadowColor[0];\n      } else if (typeof shadowColor == 'string') {\n        co.shadowColor = shadowColor;\n      }\n      co.shadowBlur = prop['chart.shadow.blur'];co.shadowOffsetX = prop['chart.shadow.offsetx'];co.shadowOffsetY = prop['chart.shadow.offsety'];\n    }\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();if (prop['chart.curvy']) {\n        this.DrawSpline(co, coords, prop['chart.key.interactive.highlight.chart'], null);\n      } else {\n        for (var i = 0, len = coords.length; i < len; i += 1) {\n          if (i == 0 || RG.is_null(coords[i][1]) || _typeof(coords[i - 1][1]) != undefined && RG.is_null(coords[i - 1][1])) {\n            co.moveTo(coords[i][0], coords[i][1]);\n          } else {\n            co.lineTo(coords[i][0], coords[i][1]);\n          }\n        }\n      }\n      co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.drawErrorbars = function () {\n    co.save();RG.noShadow(this);var coords = this.coords,\n        x = 0,\n        errorbars = prop['chart.errorbars'],\n        length = 0;if (!prop['chart.errorbars.capped']) {\n      prop['chart.errorbars.capped.width'] = 0.001;halfwidth = 0.0005;\n    }\n    co.lineWidth = prop['chart.errorbars.linewidth'];for (var i = 0; i < coords.length; ++i) {\n      var halfwidth = prop['chart.errorbars.capped.width'] / 2 || 5,\n          color = prop['chart.errorbars.color'] || 'black';if (errorbars[i] && typeof errorbars[i][3] === 'number') {\n        co.lineWidth = errorbars[i][3];\n      } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n        co.lineWidth = prop['chart.errorbars.linewidth'];\n      } else {\n        co.lineWidth = 1;\n      }\n      if (typeof errorbars === 'number' || typeof errorbars[i] === 'number') {\n        if (typeof errorbars === 'number') {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars),\n              negativeLength = positiveLength;\n        } else {\n          var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i]),\n              negativeLength = positiveLength;\n        }\n        if (positiveLength || negativeLength) {\n          pa2(co, 'lj miter lc square b m % % l % % m % % l % % l % % m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, coords[i][0], coords[i][1] + negativeLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, coords[i][1] - positiveLength, coords[i][0], coords[i][1] - positiveLength, coords[i][0] + halfwidth, coords[i][1] - positiveLength, color);pa2(co, 'lj miter lc square b m % % l % % s %', coords[i][0] - halfwidth, coords[i][1] + negativeLength, coords[i][0] + halfwidth, coords[i][1] + negativeLength, color);\n        }\n      } else if (_typeof(errorbars[i]) === 'object' && !RG.isNull(errorbars[i])) {\n        var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][0]),\n            negativeLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][1]);if (typeof errorbars[i][2] === 'string') {\n          color = errorbars[i][2];\n        }\n        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : halfwidth;if (_typeof(errorbars[i]) === 'object' && typeof errorbars[i][3] === 'number') {\n          co.lineWidth = errorbars[i][3];\n        } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\n          co.lineWidth = prop['chart.errorbars.linewidth'];\n        } else {\n          co.lineWidth = 1;\n        }\n        if (!RG.isNull(errorbars[i][0])) {\n          pa2(co, 'lc square b  m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] - positiveLength, coords[i][0] - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0], ma.round(coords[i][1] - positiveLength), coords[i][0] + halfwidth, ma.round(coords[i][1] - positiveLength), color);\n        }\n        if (typeof errorbars[i][1] === 'number') {\n          var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));pa2(co, 'b m % % l % % l % % m % % l % % s %', coords[i][0], coords[i][1], coords[i][0], coords[i][1] + negativeLength, coords[i][0] - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0], ma.round(coords[i][1] + negativeLength), coords[i][0] + halfwidth, ma.round(coords[i][1] + negativeLength), color);\n        }\n      }\n    }\n    co.restore();\n  };this.hide = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = false;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = false;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = false;\n      }\n    }\n    RG.redraw();return this;\n  };this.show = function () {\n    if (typeof arguments[0] === 'number') {\n      prop['chart.line.visible'][arguments[0]] = true;\n    } else if (_typeof(arguments[0]) === 'object') {\n      for (var i = 0; i < arguments[0].length; ++i) {\n        prop['chart.line.visible'][arguments[0][i]] = true;\n      }\n    } else {\n      for (var i = 0; i < this.original_data.length; ++i) {\n        prop['chart.line.visible'][i] = true;\n      }\n    }\n    RG.redraw();return this;\n  };this.hidden = function (index) {\n    return !prop['chart.line.visible'][index];\n  };this.unfold = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var initial = prop['chart.animation.unfold.initial'];prop['chart.animation.factor'] = prop['chart.animation.unfold.initial'];function iterator() {\n      prop['chart.animation.factor'] = (1 - initial) * (frame / frames) + initial;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = this.trace2 = function () {\n    var obj = this;var callback = arguments[2];var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.Set('animation.trace.clip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.foldtocenter = this.foldToCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};var center_value = obj.scale2.max / 2;obj.Set('chart.ymax', obj.scale2.max);var original_data = RG.array_clone(obj.original_data);function iterator() {\n      for (var i = 0, len = obj.data.length; i < len; ++i) {\n        if (obj.data[i].length) {\n          for (var j = 0, len2 = obj.data[i].length; j < len2; ++j) {\n            var dataset = obj.original_data[i];if (dataset[j] > center_value) {\n              dataset[j] = original_data[i][j] - (original_data[i][j] - center_value) * (frame / frames);\n            } else {\n              dataset[j] = original_data[i][j] + (center_value - original_data[i][j]) / frames * frame;\n            }\n          }\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);\n      if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.unfoldFromCenterTrace = this.unfoldFromCenterTrace2 = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        data = RG.arrayClone(obj.original_data),\n        callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var unfoldCallback = function unfoldCallback() {\n      obj.original_data = data;obj.unfoldFromCenter({ frames: frames / 2 }, callback);\n    };var half = obj.Get('chart.xaxispos') == 'center' ? obj.min : (obj.max - obj.min) / 2 + obj.min;obj.Set('chart.ymax', obj.max);for (var i = 0, len = obj.original_data.length; i < len; ++i) {\n      for (var j = 0; j < obj.original_data[i].length; ++j) {\n        obj.original_data[i][j] = obj.Get('chart.filled') && obj.Get('chart.filled.accumulative') && i > 0 ? 0 : half;\n      }\n    }\n    RG.clear(obj.canvas);obj.trace2({ frames: frames / 2 }, unfoldCallback);return obj;\n  };this.unfoldFromCenter = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] || function () {};obj.canvas.style.visibility = 'hidden';obj.Draw();var max = obj.scale2.max;RG.clear(obj.canvas);obj.canvas.style.visibility = 'visible';var center_value = obj.Get('chart.xaxispos') === 'center' ? prop['chart.ymin'] : (obj.max - obj.min) / 2 + obj.min;var original_data = RG.array_clone(obj.original_data);var steps = null;obj.Set('chart.ymax', max);if (!steps) {\n      steps = [];for (var dataset = 0, len = original_data.length; dataset < len; ++dataset) {\n        steps[dataset] = [];\n        for (var i = 0, len2 = original_data[dataset].length; i < len2; ++i) {\n          if (prop['chart.filled'] && prop['chart.filled.accumulative'] && dataset > 0) {\n            steps[dataset][i] = original_data[dataset][i] / frames;obj.original_data[dataset][i] = center_value;\n          } else {\n            steps[dataset][i] = (original_data[dataset][i] - center_value) / frames;obj.original_data[dataset][i] = center_value;\n          }\n        }\n      }\n    }\n    function unfoldFromCenter() {\n      for (var dataset = 0; dataset < original_data.length; ++dataset) {\n        for (var i = 0; i < original_data[dataset].length; ++i) {\n          obj.original_data[dataset][i] += steps[dataset][i];\n        }\n      }\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (--frames > 0) {\n        RG.Effects.updateCanvas(unfoldFromCenter);\n      } else {\n        obj.original_data = RG.array_clone(original_data);RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    unfoldFromCenter();return this;\n  };RG.att(ca);this.isAdjustable = function (shape) {\n    if (RG.isNull(prop['chart.adjustable.only'])) {\n      return true;\n    }\n    if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\n      return true;\n    }\n    return false;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  for (var i = 0; i < this.original_data.length; ++i) {\n    prop['chart.line.visible'][i] = true;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5saW5lLmpzP2YxOWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguTGluZSA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIHZhciBfcHJvcGVydGllcztcblxuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZDt2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBkYXRhID0gY29uZi5kYXRhO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ2xpbmUnO3RoaXMubWF4ID0gMDt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO3RoaXMuY29vcmRzLmtleSA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMuY29vcmRzU3BsaW5lID0gW107dGhpcy5jb29yZHNBeGVzID0geyB4YXhpczogW10sIHlheGlzOiBbXSB9O3RoaXMuaGFzbmVnYXRpdmV2YWx1ZXMgPSBmYWxzZTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnByb3BlcnRpZXMgPSAoX3Byb3BlcnRpZXMgPSB7ICdjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkJzogMSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC53aWR0aCc6IDEsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaHNpemUnOiAyNSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC52c2l6ZSc6IDI1LCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzogJyNkZGQnLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQuYWxpZ24nOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzogNSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGFzaGVkJzogZmFsc2UsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZG90dGVkJzogZmFsc2UsICdjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5zdHJldGNoJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueCc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnknOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS53JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuaCc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLmFsaWduJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5ib2xkJzogZmFsc2UsICdjaGFydC5sYWJlbHMuY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzLmluZ3JhcGgnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlJzogZmFsc2UsICdjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSc6IDgsICdjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5iYWNrZ3JvdW5kJzogJ3doaXRlJywgJ2NoYXJ0LmxhYmVscy5hYm92ZS5mb250JzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5hYm92ZS5ib3JkZXInOiB0cnVlLCAnY2hhcnQubGFiZWxzLmFib3ZlLm9mZnNldHknOiA1LCAnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSc6ICcnLCAnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LmxhYmVscy5hYm92ZS5zcGVjaWZpYyc6IG51bGwsICdjaGFydC5sYWJlbHMub2Zmc2V0eCc6IDAsICdjaGFydC5sYWJlbHMub2Zmc2V0eSc6IDAsICdjaGFydC54dGlja2dhcCc6IDIwLCAnY2hhcnQuc21hbGx4dGlja3MnOiAzLCAnY2hhcnQubGFyZ2V4dGlja3MnOiA1LCAnY2hhcnQueXRpY2tnYXAnOiAyMCwgJ2NoYXJ0LnNtYWxseXRpY2tzJzogMywgJ2NoYXJ0LmxhcmdleXRpY2tzJzogNSwgJ2NoYXJ0Lm51bXl0aWNrcyc6IDEwLCAnY2hhcnQubGluZXdpZHRoJzogMi4wMSwgJ2NoYXJ0LmNvbG9ycyc6IFsncmVkJywgJyMwZjAnLCAnIzAwZicsICcjZjBmJywgJyNmZjAnLCAnIzBmZicsICdncmVlbicsICdwaW5rJywgJ2JsdWUnLCAnYmxhY2snXSwgJ2NoYXJ0LmhtYXJnaW4nOiAwLCAnY2hhcnQudGlja21hcmtzLmRvdC5zdHJva2UnOiAnd2hpdGUnLCAnY2hhcnQudGlja21hcmtzLmRvdC5maWxsJzogbnVsbCwgJ2NoYXJ0LnRpY2ttYXJrcy5kb3QubGluZXdpZHRoJzogMywgJ2NoYXJ0LnRpY2ttYXJrcyc6ICdlbmRjaXJjbGUnLCAnY2hhcnQudGlja21hcmtzLmxpbmV3aWR0aCc6IG51bGwsICdjaGFydC50aWNrbWFya3MuaW1hZ2UnOiBudWxsLCAnY2hhcnQudGlja21hcmtzLmltYWdlLmhhbGlnbic6ICdjZW50ZXInLCAnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbic6ICdjZW50ZXInLCAnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHgnOiAwLCAnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHknOiAwLCAnY2hhcnQudGlja3NpemUnOiAzLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDMwLCAnY2hhcnQudGlja2RpcmVjdGlvbic6IC0xLCAnY2hhcnQueWF4aXNwb2ludHMnOiA1LCAnY2hhcnQuZmlsbHN0eWxlJzogbnVsbCwgJ2NoYXJ0LnhheGlzcG9zJzogJ2JvdHRvbScsICdjaGFydC54YXhpc3Bvcy52YWx1ZSc6IDAsICdjaGFydC55YXhpc3Bvcyc6ICdsZWZ0JywgJ2NoYXJ0Lnh0aWNrcyc6IG51bGwsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuYW5nbGUnOiAwLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC55bWluJzogMCwgJ2NoYXJ0LnltYXgnOiBudWxsLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcyc6ICcnLCAnY2hhcnQudGl0bGUueGF4aXMuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS54YXhpcy5zaXplJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMuY29sb3InOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMnOiAnJywgJ2NoYXJ0LnRpdGxlLnlheGlzLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueWF4aXMuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLnBvcyc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5wb3MnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMueCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAyLCAnY2hhcnQuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJ3JnYmEoMTI4LDEyOCwxMjgsMC41KScsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5ob3RzcG90Lnhvbmx5JzogZmFsc2UsICdjaGFydC50b29sdGlwcy5ob3RzcG90LnNpemUnOiA1LCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzogJ2ZhZGUnLCAnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzogJ1JHcmFwaF90b29sdGlwJywgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29ubW91c2Vtb3ZlJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC50b29sdGlwcy5jb29yZHMucGFnZSc6IGZhbHNlLCAnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJzogbnVsbCwgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAnZ3JheScsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICd3aGl0ZScsICdjaGFydC5zdGVwcGVkJzogZmFsc2UsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiBudWxsLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOiAncmdiYSgyNTUsMCwwLDAuMyknLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5sYWJlbCc6ICdyZ2JhKDI1NSwwLDAsMC4yKScsICdjaGFydC5rZXkudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC5jb250ZXh0bWVudSc6IG51bGwsICdjaGFydC55bGFiZWxzJzogdHJ1ZSwgJ2NoYXJ0LnlsYWJlbHMuY291bnQnOiA1LCAnY2hhcnQueWxhYmVscy5pbnNpZGUnOiBmYWxzZSwgJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eCc6IDAsICdjaGFydC55bGFiZWxzLm9mZnNldHknOiAwLCAnY2hhcnQuc2NhbGUuaW52ZXJ0JzogZmFsc2UsICdjaGFydC54bGFiZWxzLmluc2lkZSc6IGZhbHNlLCAnY2hhcnQueGxhYmVscy5pbnNpZGUuY29sb3InOiAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJywgJ2NoYXJ0Lm5vYXhlcyc6IGZhbHNlLCAnY2hhcnQubm95YXhpcyc6IGZhbHNlLCAnY2hhcnQubm94YXhpcyc6IGZhbHNlLCAnY2hhcnQubm9lbmR4dGljayc6IGZhbHNlLCAnY2hhcnQubm9lbmR5dGljayc6IGZhbHNlLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQudW5pdHMucHJlJzogJycsICdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOiB0cnVlLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiBudWxsLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5zY2FsZS50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LmNyb3NzaGFpcnMnOiBmYWxzZSwgJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InOiAnIzMzMycsICdjaGFydC5jcm9zc2hhaXJzLmhsaW5lJzogdHJ1ZSwgJ2NoYXJ0LmNyb3NzaGFpcnMudmxpbmUnOiB0cnVlLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmF4ZXNvbnRvcCc6IGZhbHNlLCAnY2hhcnQuZmlsbGVkJzogZmFsc2UsICdjaGFydC5maWxsZWQucmFuZ2UnOiBmYWxzZSwgJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQnOiBudWxsLCAnY2hhcnQuZmlsbGVkLnJhbmdlLnRocmVzaG9sZC5jb2xvcnMnOiBbJ3JlZCcsICdncmVlbiddLCAnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSc6IHRydWUsICdjaGFydC52YXJpYW50JzogbnVsbCwgJ2NoYXJ0LmF4aXMuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuYXhpcy5saW5ld2lkdGgnOiAxLCAnY2hhcnQubnVteHRpY2tzJzogZGF0YSAmJiB0eXBlb2YgZGF0YVswXSA9PSAnbnVtYmVyJyA/IGRhdGEubGVuZ3RoIC0gMSA6IF90eXBlb2YoZGF0YVswXSkgPT09ICdvYmplY3QnICYmIGRhdGFbMF0gJiYgdHlwZW9mIGRhdGFbMF1bMF0gPT09ICdudW1iZXInID8gZGF0YVswXS5sZW5ndGggLSAxIDogMjAgfSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubnVteXRpY2tzJywgMTApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhY3RvcicsIDEuNSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uZmFkZS5pbicsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhZGUub3V0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uaGRpcicsICdyaWdodCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLnZkaXInLCAnZG93bicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZyYW1lcycsIDI1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5kZWxheScsIDE2LjY2NiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uc2hhZG93JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmFjdGlvbicsICd6b29tJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmJhY2tkcm9wJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5iYWNrZHJvcC5zaXplJywgMzApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5iYWNrZHJvcC5hbHBoYScsIDAuMiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJlc2l6YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnLCBbMCwgMF0pLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYWRqdXN0YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYWRqdXN0YWJsZS5vbmx5JywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lm5vcmVkcmF3JywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5vdXRvZmJvdW5kcycsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQub3V0b2Zib3VuZHMuY2xpcCcsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuY2hyb21lZml4JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFuaW1hdGlvbi5mYWN0b3InLCAxKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC54JywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hbmltYXRpb24udW5mb2xkLnknLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC5pbml0aWFsJywgMiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmN1cnZ5JywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5saW5lLnZpc2libGUnLCBbXSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmV2ZW50cy5jbGljaycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmVycm9yYmFycycsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXJyb3JiYXJzLmNvbG9yJywgJ2JsYWNrJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZC53aWR0aCcsIDEyKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXJyb3JiYXJzLmxpbmV3aWR0aCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdCcsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jb21iaW5lZGNoYXJ0LmVmZmVjdC5vcHRpb25zJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNvbWJpbmVkY2hhcnQuZWZmZWN0LmNhbGxiYWNrJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5kb3R0ZWQnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmRhc2hlZCcsIGZhbHNlKSwgX3Byb3BlcnRpZXMpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09ICdudWxsJyB8fCAhYXJndW1lbnRzW2ldKSB7XG4gICAgICBhcmd1bWVudHNbaV0gPSBbXTtcbiAgICB9XG4gIH1cbiAgdGhpcy5vcmlnaW5hbF9kYXRhID0gW107aWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiBjb25mLmRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGNvbmYuZGF0YVswXSA9PT0gJ251bWJlcicgfHwgUkdyYXBoLmlzTnVsbChjb25mLmRhdGFbMF0pKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2RhdGFbMF0gPSBSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmYuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsX2RhdGFbaV0gPSBSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSAmJiBfdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT0gJ29iamVjdCcgJiYgYXJndW1lbnRzWzFdWzBdICYmIF90eXBlb2YoYXJndW1lbnRzWzFdWzBdKSA9PSAnb2JqZWN0JyAmJiBhcmd1bWVudHNbMV1bMF0ubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0bXAgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c1sxXS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRtcFtpXSA9IFJHcmFwaC5hcnJheV9jbG9uZShhcmd1bWVudHNbMV1baV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG1wLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbF9kYXRhW2pdID0gUkdyYXBoLmFycmF5X2Nsb25lKHRtcFtqXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxfZGF0YVtpIC0gMV0gPSBSR3JhcGguYXJyYXlfY2xvbmUoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbTElORV0gRmF0YWwgZXJyb3I6IG5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcmlnaW5hbF9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm9yaWdpbmFsX2RhdGFbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcmlnaW5hbF9kYXRhW2ldW2pdID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsX2RhdGFbaV1bal0gPSBwYXJzZUZsb2F0KHRoaXMub3JpZ2luYWxfZGF0YVtpXVtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YV9hcnIgPSBSR3JhcGguYXJyYXlMaW5lYXJpemUodGhpcy5vcmlnaW5hbF9kYXRhKTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YV9hcnIubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzWyckJyArIGldID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnRvb2x0aXBzJyAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09ICdvYmplY3QnICYmIHZhbHVlKSB7XG4gICAgICB2YXIgdG9vbHRpcHMgPSBbXTtmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX3R5cGVvZihhcmd1bWVudHNbaV0pID09ICdvYmplY3QnICYmIGFyZ3VtZW50c1tpXVswXSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJndW1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0b29sdGlwcy5wdXNoKGFyZ3VtZW50c1tpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvb2x0aXBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvb2x0aXBzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b29sdGlwcztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LmxpbmV3aWR0aCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lLykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSAxKSB7XG4gICAgICAgIHZhbHVlID0gMS4wMTtcbiAgICAgIH0gZWxzZSBpZiAoUkdyYXBoLmlzX2FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSA9PSAnbnVtYmVyJyAmJiB2YWx1ZVtpXSA9PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZVtpXSA9IDEuMDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC54YXhpc3BvcycpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSAnYm90dG9tJyAmJiB2YWx1ZSAhPSAnY2VudGVyJyAmJiB2YWx1ZSAhPSAndG9wJykge1xuICAgICAgICBhbGVydCgnW0xJTkVdICgnICsgdGhpcy5pZCArICcpIGNoYXJ0LnhheGlzcG9zIHNob3VsZCBiZSB0b3AsIGNlbnRlciBvciBib3R0b20uIFRyaWVkIHRvIHNldCBpdCB0bzogJyArIHZhbHVlICsgJyBDaGFuZ2luZyBpdCB0byBjZW50ZXInKTt2YWx1ZSA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQueHRpY2tzJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5udW14dGlja3MnO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQuc3BsaW5lJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5jdXJ2eSc7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC55bGFiZWxzLmludmVydCcpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuc2NhbGUuaW52ZXJ0JztcbiAgICB9XG4gICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQuc3BsaW5lJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5jdXJ2eSc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UnXSA9PSAnc3RyaW5nJykge1xuICAgICAgUkcuRHJhd0JhY2tncm91bmRJbWFnZSh0aGlzKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmRhdGEgPSBSRy5hcnJheV9jbG9uZSh0aGlzLm9yaWdpbmFsX2RhdGEpO3RoaXMubWF4ID0gMDtpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgIXByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddICYmIHRoaXMuZGF0YS5sZW5ndGggPiAxICYmIHByb3BbJ2NoYXJ0LmZpbGxlZC5hY2N1bXVsYXRpdmUnXSkge1xuICAgICAgdmFyIGFjY3VtdWxhdGlvbiA9IFtdO2ZvciAodmFyIHNldCA9IDA7IHNldCA8IHRoaXMuZGF0YS5sZW5ndGg7ICsrc2V0KSB7XG4gICAgICAgIGZvciAodmFyIHBvaW50ID0gMDsgcG9pbnQgPCB0aGlzLmRhdGFbc2V0XS5sZW5ndGg7ICsrcG9pbnQpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbc2V0XVtwb2ludF0gPSBOdW1iZXIoYWNjdW11bGF0aW9uW3BvaW50XSA/IGFjY3VtdWxhdGlvbltwb2ludF0gOiAwKSArIHRoaXMuZGF0YVtzZXRdW3BvaW50XTthY2N1bXVsYXRpb25bcG9pbnRdID0gdGhpcy5kYXRhW3NldF1bcG9pbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC55bWF4J10pIHtcbiAgICAgIHRoaXMubWF4ID0gcHJvcFsnY2hhcnQueW1heCddO3RoaXMubWluID0gcHJvcFsnY2hhcnQueW1pbiddID8gcHJvcFsnY2hhcnQueW1pbiddIDogMDt0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiB0aGlzLm1heCwgJ21pbic6IHByb3BbJ2NoYXJ0LnltaW4nXSwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQueWxhYmVscy5jb3VudCddLCAnc2NhbGUucm91bmQnOiBwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCAndW5pdHMucHJlJzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sICd1bml0cy5wb3N0JzogcHJvcFsnY2hhcnQudW5pdHMucG9zdCddIH0pO3RoaXMubWF4ID0gdGhpcy5zY2FsZTIubWF4ID8gdGhpcy5zY2FsZTIubWF4IDogMDtpZiAoIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10pIHtcbiAgICAgICAgZm9yIChkYXRhc2V0ID0gMDsgZGF0YXNldCA8IHRoaXMuZGF0YS5sZW5ndGg7ICsrZGF0YXNldCkge1xuICAgICAgICAgIGlmIChSR3JhcGguaXNBcnJheSh0aGlzLmRhdGFbZGF0YXNldF0pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYXRhcG9pbnQgPSAwOyBkYXRhcG9pbnQgPCB0aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoOyBkYXRhcG9pbnQrKykge1xuICAgICAgICAgICAgICB0aGlzLmhhc25lZ2F0aXZldmFsdWVzID0gdGhpcy5kYXRhW2RhdGFzZXRdW2RhdGFwb2ludF0gPCAwIHx8IHRoaXMuaGFzbmVnYXRpdmV2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWluID0gcHJvcFsnY2hhcnQueW1pbiddID8gcHJvcFsnY2hhcnQueW1pbiddIDogMDtmb3IgKGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgdGhpcy5kYXRhLmxlbmd0aDsgKytkYXRhc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGRhdGFwb2ludCA9IDA7IGRhdGFwb2ludCA8IHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7IGRhdGFwb2ludCsrKSB7XG4gICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5kYXRhW2RhdGFzZXRdW2RhdGFwb2ludF0gPyBNYXRoLmFicyhwYXJzZUZsb2F0KHRoaXMuZGF0YVtkYXRhc2V0XVtkYXRhcG9pbnRdKSkgOiAwKTtpZiAoIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10pIHtcbiAgICAgICAgICAgIHRoaXMuaGFzbmVnYXRpdmV2YWx1ZXMgPSB0aGlzLmRhdGFbZGF0YXNldF1bZGF0YXBvaW50XSA8IDAgfHwgdGhpcy5oYXNuZWdhdGl2ZXZhbHVlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHRoaXMubWF4LCAnbWluJzogcHJvcFsnY2hhcnQueW1pbiddLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUuZGVjaW1hbHMnOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCAneWxhYmVscy5jb3VudCc6IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSB9KTt0aGlzLm1heCA9IHRoaXMuc2NhbGUyLm1heCA/IHRoaXMuc2NhbGUyLm1heCA6IDA7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLmdyYXBoYXJlYSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5oYWxmZ3JhcGhhcmVhID0gdGhpcy5ncmFwaGFyZWEgLyAyO3RoaXMuaGFsZlRleHRIZWlnaHQgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSAvIDI7aWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnM2QnKSB7XG4gICAgICBSRy5EcmF3M0RBeGVzKHRoaXMpO1xuICAgIH1cbiAgICBSRy5iYWNrZ3JvdW5kLkRyYXcodGhpcyk7aWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXSAmJiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJ10ubGVuZ3RoID4gMCkge1xuICAgICAgUkcuRHJhd0JhcnModGhpcyk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5heGVzb250b3AnXSA9PSBmYWxzZSkge1xuICAgICAgdGhpcy5EcmF3QXhlcygpO1xuICAgIH1cbiAgICBjby5zYXZlKCk7XG4gICAgY28uYmVnaW5QYXRoKCk7Y28ucmVjdCgwLCAwLCBjYS53aWR0aCAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJ10sIGNhLmhlaWdodCk7Y28uY2xpcCgpO2ZvciAodmFyIGkgPSAwLCBqID0gMCwgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrLCBqKyspIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2lmICghcHJvcFsnY2hhcnQuZmlsbGVkJ10pIHtcbiAgICAgICAgdGhpcy5TZXRTaGFkb3coaSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pIHtcbiAgICAgICAgaWYgKF90eXBlb2YocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddW2pdKSB7XG4gICAgICAgICAgdmFyIGZpbGwgPSBwcm9wWydjaGFydC5maWxsc3R5bGUnXVtqXTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddKSA9PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5maWxsc3R5bGUnXS50b1N0cmluZygpLmluZGV4T2YoJ0dyYWRpZW50JykgPiAwKSB7XG4gICAgICAgICAgdmFyIGZpbGwgPSBwcm9wWydjaGFydC5maWxsc3R5bGUnXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgZmlsbCA9IHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmZpbGxlZCddKSB7XG4gICAgICAgIHZhciBmaWxsID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bal07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmlsbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQudGlja21hcmtzJ10gJiYgX3R5cGVvZihwcm9wWydjaGFydC50aWNrbWFya3MnXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHRpY2ttYXJrcyA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddW2ldO1xuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC50aWNrbWFya3MnXSAmJiB0eXBlb2YgcHJvcFsnY2hhcnQudGlja21hcmtzJ10gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRpY2ttYXJrcyA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddO1xuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC50aWNrbWFya3MnXSAmJiB0eXBlb2YgcHJvcFsnY2hhcnQudGlja21hcmtzJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGlja21hcmtzID0gcHJvcFsnY2hhcnQudGlja21hcmtzJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGlja21hcmtzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5vdXRvZmJvdW5kcy5jbGlwJ10pIHtcbiAgICAgICAgcGEyKGNvLCAnc2EgYiByICUgJSAlICUgY2wgYicsIDAsIHRoaXMuZ3V0dGVyVG9wLCBjYS53aWR0aCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdMaW5lKHRoaXMuZGF0YVtpXSwgcHJvcFsnY2hhcnQuY29sb3JzJ11bal0sIGZpbGwsIHRoaXMuZ2V0TGluZVdpZHRoKGopLCB0aWNrbWFya3MsIGkpO2lmIChwcm9wWydjaGFydC5vdXRvZmJvdW5kcy5jbGlwJ10pIHtcbiAgICAgICAgY28ucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5vdXRvZmJvdW5kcy5jbGlwJ10pIHtcbiAgICAgIHBhMihjbywgJ3NhIGIgciAlICUgJSAlIGNsIGInLCAwLCB0aGlzLmd1dHRlclRvcCwgY2Eud2lkdGgsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgcHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddICYmICFwcm9wWydjaGFydC5jdXJ2eSddKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29vcmRzMi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGggPSB0aGlzLkdldExpbmVXaWR0aChpKTtjby5zdHJva2VTdHlsZSA9ICF0aGlzLmhpZGRlbihpKSA/IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldIDogJ3JnYmEoMCwwLDAsMCknO2ZvciAodmFyIGogPSAwLCBsZW4gPSB0aGlzLmNvb3JkczJbaV0ubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICBpZiAoaiA9PSAwIHx8IHRoaXMuY29vcmRzMltpXVtqXVsxXSA9PSBudWxsIHx8IHRoaXMuY29vcmRzMltpXVtqIC0gMV0gJiYgdGhpcy5jb29yZHMyW2ldW2ogLSAxXVsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8odGhpcy5jb29yZHMyW2ldW2pdWzBdLCB0aGlzLmNvb3JkczJbaV1bal1bMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuc3RlcHBlZCddKSB7XG4gICAgICAgICAgICAgIGNvLmxpbmVUbyh0aGlzLmNvb3JkczJbaV1bal1bMF0sIHRoaXMuY29vcmRzMltpXVtqIC0gMV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzMltpXVtqXVswXSwgdGhpcy5jb29yZHMyW2ldW2pdWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQudGlja21hcmtzJ10pIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gJ3doaXRlJztmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVtpXTtmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29vcmRzMltpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYgKF90eXBlb2YodGhpcy5jb29yZHMyW2ldW2pdKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhpcy5jb29yZHMyW2ldW2pdWzBdID09ICdudW1iZXInICYmIHR5cGVvZiB0aGlzLmNvb3JkczJbaV1bal1bMV0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdmFyIHRpY2ttYXJrcyA9IF90eXBlb2YocHJvcFsnY2hhcnQudGlja21hcmtzJ10pID09ICdvYmplY3QnID8gcHJvcFsnY2hhcnQudGlja21hcmtzJ11baV0gOiBwcm9wWydjaGFydC50aWNrbWFya3MnXTt0aGlzLkRyYXdUaWNrKHRoaXMuY29vcmRzMltpXSwgdGhpcy5jb29yZHMyW2ldW2pdWzBdLCB0aGlzLmNvb3JkczJbaV1bal1bMV0sIGNvLnN0cm9rZVN0eWxlLCBmYWxzZSwgaiA9PSAwID8gMCA6IHRoaXMuY29vcmRzMltpXVtqIC0gMV1bMF0sIGogPT0gMCA/IDAgOiB0aGlzLmNvb3JkczJbaV1baiAtIDFdWzFdLCB0aWNrbWFya3MsIGosIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5maWxsZWQnXSAmJiBwcm9wWydjaGFydC5maWxsZWQuYWNjdW11bGF0aXZlJ10gJiYgcHJvcFsnY2hhcnQuY3VydnknXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3Jkc1NwbGluZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO2NvLmxpbmVXaWR0aCA9IHRoaXMuR2V0TGluZVdpZHRoKGkpO2ZvciAodmFyIGogPSAwLCBsZW4gPSB0aGlzLmNvb3Jkc1NwbGluZVtpXS5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuY29vcmRzU3BsaW5lW2ldW2pdO2ogPT0gMCA/IGNvLm1vdmVUbyhwb2ludFswXSwgcG9pbnRbMV0pIDogY28ubGluZVRvKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gdGhpcy5jb29yZHMyW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraikge1xuICAgICAgICAgIGlmIChfdHlwZW9mKHRoaXMuY29vcmRzMltpXVtqXSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaXMuY29vcmRzMltpXVtqXVswXSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpcy5jb29yZHMyW2ldW2pdWzFdID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgdGlja21hcmtzID0gX3R5cGVvZihwcm9wWydjaGFydC50aWNrbWFya3MnXSkgPT0gJ29iamVjdCcgJiYgIVJHcmFwaC5pc19udWxsKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKSA/IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddW2ldIDogcHJvcFsnY2hhcnQudGlja21hcmtzJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5jb2xvcnMnXVtpXTt0aGlzLkRyYXdUaWNrKHRoaXMuY29vcmRzMltpXSwgdGhpcy5jb29yZHMyW2ldW2pdWzBdLCB0aGlzLmNvb3JkczJbaV1bal1bMV0sIHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldLCBmYWxzZSwgaiA9PSAwID8gMCA6IHRoaXMuY29vcmRzMltpXVtqIC0gMV1bMF0sIGogPT0gMCA/IDAgOiB0aGlzLmNvb3JkczJbaV1baiAtIDFdWzFdLCB0aWNrbWFya3MsIGosIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQub3V0b2Zib3VuZHMuY2xpcCddKSB7XG4gICAgICBjby5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGNvLnJlc3RvcmUoKTtjby5iZWdpblBhdGgoKTtpZiAocHJvcFsnY2hhcnQuYXhlc29udG9wJ10pIHtcbiAgICAgIHRoaXMuRHJhd0F4ZXMoKTtcbiAgICB9XG4gICAgdGhpcy5EcmF3TGFiZWxzKCk7dGhpcy5EcmF3UmFuZ2UoKTtpZiAocHJvcFsnY2hhcnQua2V5J10gJiYgcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoICYmIFJHLkRyYXdLZXkpIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywgcHJvcFsnY2hhcnQua2V5J10sIHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZSddKSB7XG4gICAgICB0aGlzLmRyYXdBYm92ZUxhYmVscygpO1xuICAgIH1cbiAgICBSRy5EcmF3SW5HcmFwaExhYmVscyh0aGlzKTtpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgcHJvcFsnY2hhcnQuZmlsbGVkLnJhbmdlJ10gJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSAyKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTt2YXIgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoIC8gMjtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5zdHJva2VTdHlsZSA9IHRoaXMuaGlkZGVuKDApID8gJ3JnYmEoMCwwLDAsMCknIDogcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoIVJHLmlzTnVsbCh0aGlzLmNvb3Jkc1tpXVsxXSkpIHtcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8odGhpcy5jb29yZHNbaV1bMF0sIHRoaXMuY29vcmRzW2ldWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzW2ldWzBdLCB0aGlzLmNvb3Jkc1tpXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtpZiAocHJvcFsnY2hhcnQuY29sb3JzJ11bMV0pIHtcbiAgICAgICAgY28uc3Ryb2tlU3R5bGUgPSB0aGlzLmhpZGRlbigxKSA/ICdyZ2JhKDAsMCwwLDApJyA6IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY29vcmRzLmxlbmd0aCAtIDE7IGkgPj0gbGVuOyAtLWkpIHtcbiAgICAgICAgaWYgKCFSRy5pc19udWxsKHRoaXMuY29vcmRzW2ldWzFdKSkge1xuICAgICAgICAgIGlmIChpID09IHRoaXMuY29vcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvLm1vdmVUbyh0aGlzLmNvb3Jkc1tpXVswXSwgdGhpcy5jb29yZHNbaV1bMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjby5saW5lVG8odGhpcy5jb29yZHNbaV1bMF0sIHRoaXMuY29vcmRzW2ldWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgcHJvcFsnY2hhcnQuZmlsbGVkLnJhbmdlJ10pIHtcbiAgICAgIGFsZXJ0KCdbTElORV0gWW91IG11c3QgaGF2ZSBvbmx5IHR3byBzZXRzIG9mIGRhdGEgZm9yIGEgZmlsbGVkIHJhbmdlIGNoYXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5yZXNpemFibGUnXSkge1xuICAgICAgUkcuQWxsb3dSZXNpemluZyh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0F4ZXMgPSB0aGlzLkRyYXdBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5ub2F4ZXMnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSRy5ub1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddICsgMC4wMDE7Y28ubGluZUNhcCA9ICdzcXVhcmUnO2NvLmxpbmVKb2luID0gJ21pdGVyJztjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXTtjb29yZHMgPSB7IHhheGlzOiB7fSwgeWF4aXM6IHt9IH07Y28uYmVnaW5QYXRoKCk7aWYgKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSA9PSBmYWxzZSkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY29vcmRzLnhheGlzID0gW3RoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQodGhpcy5ncmFwaGFyZWEgLyAyICsgdGhpcy5ndXR0ZXJUb3ApLCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIG1hLnJvdW5kKHRoaXMuZ3JhcGhhcmVhIC8gMiArIHRoaXMuZ3V0dGVyVG9wKV07XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT09ICd0b3AnKSB7XG4gICAgICAgIGNvb3Jkcy54YXhpcyA9IFt0aGlzLmd1dHRlckxlZnQsIHRoaXMuZ3V0dGVyVG9wLCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIHRoaXMuZ3V0dGVyVG9wXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gbWEucm91bmQodGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddICE9IDAgPyBwcm9wWydjaGFydC55bWluJ10gOiAwKSk7aWYgKHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddICYmIHByb3BbJ2NoYXJ0LnltaW4nXSA9PT0gMCkge1xuICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlMi5tYXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddIHx8IHByb3BbJ2NoYXJ0LnltaW4nXSA8IDApIHtcbiAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzLnhheGlzID0gW3RoaXMuZ3V0dGVyTGVmdCwgeSwgY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCB5XTtcbiAgICAgIH1cbiAgICAgIGNvLm1vdmVUbyhjb29yZHMueGF4aXNbMF0sIGNvb3Jkcy54YXhpc1sxXSk7Y28ubGluZVRvKGNvb3Jkcy54YXhpc1syXSwgY29vcmRzLnhheGlzWzNdKTt0aGlzLmNvb3Jkc0F4ZXMgPSBjb29yZHM7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0Jykge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28ubW92ZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgdGhpcy5ndXR0ZXJUb3ApO2NvLmxpbmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSA9PSBmYWxzZSAmJiBwcm9wWydjaGFydC5udW14dGlja3MnXSA+IDApIHtcbiAgICAgIHZhciB4VGlja0ludGVydmFsID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyBwcm9wWydjaGFydC5udW14dGlja3MnXTtpZiAoIXhUaWNrSW50ZXJ2YWwgfHwgeFRpY2tJbnRlcnZhbCA8PSAwKSB7XG4gICAgICAgIHhUaWNrSW50ZXJ2YWwgPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIChwcm9wWydjaGFydC5sYWJlbHMnXSAmJiBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggPyBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggLSAxIDogMTApO1xuICAgICAgfVxuICAgICAgZm9yICh4ID0gdGhpcy5ndXR0ZXJMZWZ0ICsgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8geFRpY2tJbnRlcnZhbCA6IDApOyB4IDw9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDE7IHggKz0geFRpY2tJbnRlcnZhbCkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnICYmIHggPj0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5ub2VuZHh0aWNrJ10pIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgJiYgeCA+PSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0JyAmJiB4ID09IHRoaXMuZ3V0dGVyTGVmdCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB5U3RhcnQgPSBwcm9wWydjaGFydC54YXhpc3BvcyddID09PSAnY2VudGVyJyA/IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyIC0gMyA6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tO3ZhciB5RW5kID0gcHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PT0gJ2NlbnRlcicgPyB5U3RhcnQgKyA2IDogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSAoeCAlIDYwID09IDAgPyBwcm9wWydjaGFydC5sYXJnZXh0aWNrcyddICogcHJvcFsnY2hhcnQudGlja2RpcmVjdGlvbiddIDogcHJvcFsnY2hhcnQuc21hbGx4dGlja3MnXSAqIHByb3BbJ2NoYXJ0LnRpY2tkaXJlY3Rpb24nXSk7aWYgKHByb3BbJ2NoYXJ0LnltaW4nXSA+PSAwICYmIHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdmFyIHlTdGFydCA9IHRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LnltaW4nXSkgLSAocHJvcFsnY2hhcnQueW1pbiddID49IDAgPyAwIDogMyksXG4gICAgICAgICAgICAgIHlFbmQgPSB0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pICsgMztpZiAocHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10pIHtcbiAgICAgICAgICAgIHlTdGFydCA9IGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt5RW5kID0geVN0YXJ0ICsgMztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgICAgIHZhciB5U3RhcnQgPSBNYXRoLnJvdW5kKHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyKSAtIDMsXG4gICAgICAgICAgICAgIHlFbmQgPSB5U3RhcnQgKyA2O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB2YXIgeVN0YXJ0ID0gdGhpcy5nZXRZQ29vcmQoMCkgLSAocHJvcFsnY2hhcnQueW1pbiddICE9PSAwID8gMyA6IDApLFxuICAgICAgICAgICAgICB5RW5kID0gdGhpcy5nZXRZQ29vcmQoMCkgLSAoeCAlIDYwID09IDAgPyBwcm9wWydjaGFydC5sYXJnZXh0aWNrcyddICogcHJvcFsnY2hhcnQudGlja2RpcmVjdGlvbiddIDogcHJvcFsnY2hhcnQuc21hbGx4dGlja3MnXSAqIHByb3BbJ2NoYXJ0LnRpY2tkaXJlY3Rpb24nXSk7eUVuZCArPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgICB5U3RhcnQgPSB0aGlzLmd1dHRlclRvcCAtIDM7eUVuZCA9IHRoaXMuZ3V0dGVyVG9wO1xuICAgICAgICB9XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4KSwgeVN0YXJ0KTtjby5saW5lVG8obWEucm91bmQoeCksIHlFbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQubm95YXhpcyddID09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddID4gMCkge1xuICAgICAgaWYgKCFwcm9wWydjaGFydC5ub2VuZHl0aWNrJ10pIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgTWF0aC5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQgLSBwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddLCBNYXRoLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28ubW92ZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgTWF0aC5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyBwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddLCBNYXRoLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG51bXl0aWNrcyA9IHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddO2lmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UgJiYgbnVteXRpY2tzID4gMCkge1xuICAgICAgdmFyIGNvdW50ZXIgPSAwLFxuICAgICAgICAgIGFkanVzdG1lbnQgPSAwO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdyaWdodCcpIHtcbiAgICAgICAgYWRqdXN0bWVudCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuZ3JhcGhhcmVhIC8gbnVteXRpY2tzO3ZhciBsaW5ldG8gPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIHByb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ107Zm9yICh5ID0gdGhpcy5ndXR0ZXJUb3A7IHkgPCB0aGlzLmdyYXBoYXJlYSAvIDIgKyB0aGlzLmd1dHRlclRvcDsgeSArPSBpbnRlcnZhbCkge1xuICAgICAgICAgIGlmICh5IDwgdGhpcy5ncmFwaGFyZWEgLyAyICsgdGhpcy5ndXR0ZXJUb3ApIHtcbiAgICAgICAgICAgIGNvLm1vdmVUbyhwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCAtIHByb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ10gOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyhsaW5ldG8sIE1hdGgucm91bmQoeSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHkgPSB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGFsZmdyYXBoYXJlYSArIGludGVydmFsOyB5IDw9IHRoaXMuZ3JhcGhhcmVhICsgdGhpcy5ndXR0ZXJUb3A7IHkgKz0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICBjby5tb3ZlVG8ocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSBwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddIDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCBNYXRoLnJvdW5kKHkpKTtjby5saW5lVG8obGluZXRvLCBNYXRoLnJvdW5kKHkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuZ3JhcGhhcmVhIC8gbnVteXRpY2tzO3ZhciBsaW5ldG8gPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIHByb3BbJ2NoYXJ0LnNtYWxseXRpY2tzJ107Zm9yICh5ID0gdGhpcy5ndXR0ZXJUb3AgKyBpbnRlcnZhbDsgeSA8PSB0aGlzLmdyYXBoYXJlYSArIHRoaXMuZ3V0dGVyQm90dG9tOyB5ICs9IGludGVydmFsKSB7XG4gICAgICAgICAgY28ubW92ZVRvKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0IC0gcHJvcFsnY2hhcnQuc21hbGx5dGlja3MnXSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgTWF0aC5yb3VuZCh5KSk7Y28ubGluZVRvKGxpbmV0bywgTWF0aC5yb3VuZCh5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSAmJiBwcm9wWydjaGFydC5ub2VuZHl0aWNrJ10gPT0gZmFsc2UpIHtcbiAgICAgICAgICBjby5tb3ZlVG8ocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSBwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddIDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGxpbmV0bywgdGhpcy5ndXR0ZXJUb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGluZXRvID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSBwcm9wWydjaGFydC5zbWFsbHl0aWNrcyddIDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgcHJvcFsnY2hhcnQuc21hbGx5dGlja3MnXTtmb3IgKHkgPSB0aGlzLmd1dHRlclRvcDsgeSA8IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICYmIGNvdW50ZXIgPCBudW15dGlja3M7IHkgKz0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gbnVteXRpY2tzKSB7XG4gICAgICAgICAgaWYgKG1hLnJvdW5kKHkpICE9PSBtYS5yb3VuZCh0aGlzLmNvb3Jkc0F4ZXMueGF4aXNbMV0pKSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0ICsgYWRqdXN0bWVudCwgbWEucm91bmQoeSkpO2NvLmxpbmVUbyhsaW5ldG8sIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQueW1pbiddIDwgMCkge1xuICAgICAgICAgIGNvLm1vdmVUbyhwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgbWEucm91bmQoeSkpO2NvLmxpbmVUbyhsaW5ldG8sIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID4gMCkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgIGNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsIHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcgPyB0aGlzLmd1dHRlclRvcCA6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LCBwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnID8gdGhpcy5ndXR0ZXJUb3AgLSBwcm9wWydjaGFydC5zbWFsbHh0aWNrcyddIDogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBwcm9wWydjaGFydC5zbWFsbHh0aWNrcyddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIHByb3BbJ2NoYXJ0LnNtYWxseHRpY2tzJ10pO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtcbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5saW5lV2lkdGggPSAxO1JHLk5vU2hhZG93KHRoaXMpO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciBkZWNpbWFscyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107dmFyIGNvbnRleHQgPSBjbzt2YXIgY2FudmFzID0gY2E7dmFyIHltaW4gPSBwcm9wWydjaGFydC55bWluJ107aWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMnXSAmJiBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10gPT0gbnVsbCkge1xuICAgICAgdmFyIHVuaXRzX3ByZSA9IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciB4cG9zID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSA1IDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgNTt2YXIgYWxpZ24gPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7dmFyIG51bVlMYWJlbHMgPSB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoO3ZhciBib3VuZGluZyA9IGZhbHNlO3ZhciBiZ2NvbG9yID0gcHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXSA/IHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlLmNvbG9yJ10gOiBudWxsO3ZhciBvZmZzZXR4ID0gcHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J107dmFyIG9mZnNldHkgPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHknXTtpZiAocHJvcFsnY2hhcnQueWxhYmVscy5pbnNpZGUnXSA9PSB0cnVlICYmIGFsaWduID09ICdsZWZ0Jykge1xuICAgICAgICB4cG9zIC09IDEwO2FsaWduID0gJ3JpZ2h0Jztib3VuZGluZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10gPT0gdHJ1ZSAmJiBhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHhwb3MgKz0gMTA7YWxpZ24gPSAnbGVmdCc7Ym91bmRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIGhhbGYgPSB0aGlzLmdyYXBoYXJlYSAvIDI7Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeHBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyBoYWxmIC0gKGkgKyAxKSAvIG51bVlMYWJlbHMgKiBoYWxmICsgb2Zmc2V0eSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3VuZGluZyc6IGJvdW5kaW5nLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgaGFsZiArIChpICsgMSkgLyBudW1ZTGFiZWxzICogaGFsZiArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0ZXh0JzogJy0nICsgdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IHRydWUgfHwgeW1pbiAhPSAwIHx8IHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKSB7XG4gICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgaGFsZiArIG9mZnNldHksICd0ZXh0JzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10gKyB5bWluLnRvRml4ZWQoeW1pbiA9PT0gMCA/IDAgOiBkZWNpbWFscykgKyBwcm9wWydjaGFydC51bml0cy5wb3N0J10sICdib3VuZGluZyc6IGJvdW5kaW5nLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgdmFyIGhhbGYgPSB0aGlzLmdyYXBoYXJlYSAvIDI7aWYgKHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiB0aGlzLmd1dHRlclRvcCArIGkgLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoICogdGhpcy5ncmFwaGFyZWEgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm91bmRpbmcsICdib3VuZGluZ0ZpbGwnOiBiZ2NvbG9yLCAndGV4dCc6ICctJyArIHRoaXMuc2NhbGUyLmxhYmVsc1t0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoIC0gKGkgKyAxKV0sICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgKGkgKyAxKSAvIG51bVlMYWJlbHMgKiB0aGlzLmdyYXBoYXJlYSArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0ZXh0JzogJy0nICsgdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnltaW4nXSAhPSAwIHx8IHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSB8fCBwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSB8fCBwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSkge1xuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4cG9zICsgb2Zmc2V0eCwgJ3knOiBwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSA/IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgb2Zmc2V0eSA6IHRoaXMuZ3V0dGVyVG9wICsgb2Zmc2V0eSwgJ3RleHQnOiAocHJvcFsnY2hhcnQueW1pbiddICE9IDAgPyAnLScgOiAnJykgKyBSRy5udW1iZXJGb3JtYXQodGhpcywgcHJvcFsnY2hhcnQueW1pbiddLnRvRml4ZWQoeW1pbiA9PT0gMCA/IDAgOiBkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10pIHtcbiAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeHBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm91bmRpbmcsICdib3VuZGluZ0ZpbGwnOiBiZ2NvbG9yLCAndGV4dCc6IFJHLm51bWJlckZvcm1hdCh0aGlzLCB0aGlzLm1pbi50b0ZpeGVkKHByb3BbJ2NoYXJ0LnltaW4nXSA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ3RhZyc6ICdzY2FsZScgfSk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgKGkgKyAxKSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggKiB0aGlzLmdyYXBoYXJlYSArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgaSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggKiB0aGlzLmdyYXBoYXJlYSArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggLSAoaSArIDEpXSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWydjaGFydC55bWluJ10gIT0gMCAmJiAhcHJvcFsnY2hhcnQuc2NhbGUuaW52ZXJ0J10gfHwgcHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10gfHwgcHJvcFsnY2hhcnQubm94YXhpcyddKSB7XG4gICAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddID8gdGhpcy5ndXR0ZXJUb3AgKyBvZmZzZXR5IDogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBvZmZzZXR5LCAndGV4dCc6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBwcm9wWydjaGFydC55bWluJ10udG9GaXhlZChwcm9wWydjaGFydC55bWluJ10gPT09IDAgPyAwIDogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IHRydWUgJiYgcHJvcFsnY2hhcnQueW1pbiddID09IG51bGwgJiYgcHJvcFsnY2hhcnQueGF4aXNwb3MnXSAhPSAnY2VudGVyJyAmJiBwcm9wWydjaGFydC5ub2VuZHl0aWNrJ10gPT0gZmFsc2UpIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhwb3MgKyBvZmZzZXR4LCAneSc6IHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcgPyB0aGlzLmd1dHRlclRvcCArIG9mZnNldHkgOiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSwgJ3RleHQnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSArIE51bWJlcigwKS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pICsgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddICsgb2Zmc2V0eSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3VuZGluZyc6IGJvdW5kaW5nLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC55bGFiZWxzJ10gJiYgX3R5cGVvZihwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pID09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgZ2FwID0gdGhpcy5ncmFwaGFyZWEgLyBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoO3ZhciBoYWxpZ24gPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7dmFyIGJvdW5kaW5nID0gZmFsc2U7dmFyIGJnY29sb3IgPSBudWxsO3ZhciB5bWluID0gcHJvcFsnY2hhcnQueW1pbiddICE9IG51bGwgJiYgcHJvcFsnY2hhcnQueW1pbiddO2lmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0Jykge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ3V0dGVyTGVmdCAtIDU7aWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10pIHtcbiAgICAgICAgICB4ICs9IDEwO2hhbGlnbiA9ICdsZWZ0Jztib3VuZGluZyA9IHRydWU7Ymdjb2xvciA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICB2YXIgeCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDU7aWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW5zaWRlJ10pIHtcbiAgICAgICAgICB4IC09IDEwO2hhbGlnbiA9ICdyaWdodCc7Ym91bmRpbmcgPSB0cnVlO2JnY29sb3IgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9mZnNldHggPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXTt2YXIgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLmd1dHRlclRvcCArIHRoaXMuZ3JhcGhhcmVhIC8gKChwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoIC0gMSkgKiAyKSAqIGk7aWYgKHltaW4gJiYgeW1pbiA+IDApIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5ncmFwaGFyZWEgLyAyIC8gKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGggLSAoeW1pbiA/IDEgOiAwKSkgKiBpO3kgKz0gdGhpcy5ndXR0ZXJUb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4ICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBTdHJpbmcocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddW2ldKSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogaGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0YWcnOiAneWxhYmVscy5zcGVjaWZpYycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldmVyc2VkX2xhYmVscyA9IFJHLmFycmF5X3JldmVyc2UocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddKTtmb3IgKHZhciBpID0gMDsgaSA8IHJldmVyc2VkX2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5ncmFwaGFyZWEgLyAyICsgdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmdyYXBoYXJlYSAvICgocmV2ZXJzZWRfbGFiZWxzLmxlbmd0aCAtIDEpICogMikgKiBpO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4ICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBpID09IDAgPyAnJyA6IFN0cmluZyhyZXZlcnNlZF9sYWJlbHNbaV0pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBoYWxpZ24sICdib3VuZGluZyc6IGJvdW5kaW5nLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ3RhZyc6ICd5bGFiZWxzLnNwZWNpZmljJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICAgIHZhciByZXZlcnNlZF9sYWJlbHMgPSBSRy5hcnJheV9yZXZlcnNlKHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSk7Zm9yICh2YXIgaSA9IDA7IGkgPCByZXZlcnNlZF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMuZ3JhcGhhcmVhIC8gKHJldmVyc2VkX2xhYmVscy5sZW5ndGggLSAxKSAqIGk7eSA9IHkgKyB0aGlzLmd1dHRlclRvcDtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeCArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd0ZXh0JzogU3RyaW5nKHJldmVyc2VkX2xhYmVsc1tpXSksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGhhbGlnbiwgJ2JvdW5kaW5nJzogYm91bmRpbmcsICdib3VuZGluZ0ZpbGwnOiBiZ2NvbG9yLCAndGFnJzogJ3lsYWJlbHMuc3BlY2lmaWMnIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmdyYXBoYXJlYSAvIChwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10ubGVuZ3RoIC0gMSkgKiBpO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ3gnOiB4ICsgb2Zmc2V0eCwgJ3knOiB5ICsgb2Zmc2V0eSwgJ3RleHQnOiBTdHJpbmcocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddW2ldKSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogaGFsaWduLCAnYm91bmRpbmcnOiBib3VuZGluZywgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICd0YWcnOiAneWxhYmVscy5zcGVjaWZpYycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscyddICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB5T2Zmc2V0ID0gNSxcbiAgICAgICAgICBib3JkZXJlZCA9IGZhbHNlLFxuICAgICAgICAgIGJnY29sb3IgPSBudWxsO1xuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBhbmdsZSA9IDAsXG4gICAgICAgICAgdmFsaWduID0gJ3RvcCcsXG4gICAgICAgICAgaGFsaWduID0gJ2NlbnRlcicsXG4gICAgICAgICAgYm9sZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ107XG4gICAgICBpZiAocHJvcFsnY2hhcnQueGxhYmVscy5pbnNpZGUnXSkge1xuICAgICAgICB5T2Zmc2V0ID0gLTU7Ym9yZGVyZWQgPSB0cnVlO2JnY29sb3IgPSBwcm9wWydjaGFydC54bGFiZWxzLmluc2lkZS5jb2xvciddO3ZhbGlnbiA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgdmFsaWduID0gJ2JvdHRvbSc7eU9mZnNldCArPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ10gPT0gJ251bWJlcicgJiYgcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddID4gMCkge1xuICAgICAgICBhbmdsZSA9IC0xICogcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddO3ZhbGlnbiA9ICdjZW50ZXInO2hhbGlnbiA9ICdyaWdodCc7eU9mZnNldCA9IDEwO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICAgICAgeU9mZnNldCA9IDEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbnVtTGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldHggPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddLFxuICAgICAgICAgIG9mZnNldHkgPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddO2ZvciAoaSA9IDA7IGkgPCBudW1MYWJlbHM7ICsraSkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzJ11baV0pIHtcbiAgICAgICAgICB2YXIgbGFiZWxYID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCAtIDIgKiBwcm9wWydjaGFydC5obWFyZ2luJ10pIC8gKG51bUxhYmVscyAtIDEpICogaTtsYWJlbFggKz0gdGhpcy5ndXR0ZXJMZWZ0ICsgcHJvcFsnY2hhcnQuaG1hcmdpbiddO2lmICh0aGlzLmRhdGEubGVuZ3RoID09PSAwIHx8ICF0aGlzLmRhdGFbMF0gfHwgcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoICE9IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhYmVsWCA9IHRoaXMuZ3V0dGVyTGVmdCArIHByb3BbJ2NoYXJ0LmhtYXJnaW4nXSArIChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSAyICogcHJvcFsnY2hhcnQuaG1hcmdpbiddKSAqIChpIC8gKHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsYWJlbFgpIHtcbiAgICAgICAgICAgIGxhYmVsWCA9IHRoaXMuZ3V0dGVyTGVmdCArIHByb3BbJ2NoYXJ0LmhtYXJnaW4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcgJiYgcHJvcFsnY2hhcnQudGV4dC5hbmdsZSddID4gMCkge1xuICAgICAgICAgICAgaGFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQudGV4dC5hbmdsZSddICE9IDApIHtcbiAgICAgICAgICAgIGhhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ2JvbGQnOiBib2xkLCAneCc6IGxhYmVsWCArIG9mZnNldHgsICd5JzogcHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAndG9wJyA/IHRoaXMuZ3V0dGVyVG9wIC0geU9mZnNldCAtIChwcm9wWydjaGFydC54bGFiZWxzLmluc2lkZSddID8gLTIyIDogMCkgKyBvZmZzZXR5IDogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyB5T2Zmc2V0ICsgb2Zmc2V0eSwgJ3RleHQnOiBTdHJpbmcocHJvcFsnY2hhcnQubGFiZWxzJ11baV0pLCAndmFsaWduJzogdmFsaWduLCAnaGFsaWduJzogaGFsaWduLCAnYm91bmRpbmcnOiBib3JkZXJlZCwgJ2JvdW5kaW5nRmlsbCc6IGJnY29sb3IsICdhbmdsZSc6IGFuZ2xlLCAndGFnJzogJ2xhYmVscycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICB9O1xuICB0aGlzLmRyYXdMaW5lID0gdGhpcy5EcmF3TGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgY29sb3IsIGZpbGwsIGxpbmV3aWR0aCwgdGlja21hcmtzLCBpbmRleCkge1xuICAgIGlmIChwcm9wWydjaGFydC5hbmltYXRpb24udW5mb2xkLnknXSAmJiBwcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ10gIT0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBsaW5lRGF0YVtpXSAqPSBwcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ107XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwZW5VcCA9IGZhbHNlO3ZhciB5UG9zID0gbnVsbDt2YXIgeFBvcyA9IDA7Y28ubGluZVdpZHRoID0gMTt2YXIgbGluZUNvb3JkcyA9IFtdO2lmIChpbmRleCA+IDApIHtcbiAgICAgIHZhciBwcmV2TGluZUNvb3JkcyA9IHRoaXMuY29vcmRzMltpbmRleCAtIDFdO1xuICAgIH1cbiAgICB2YXIgeEludGVydmFsID0gKGNhLndpZHRoIC0gMiAqIHByb3BbJ2NoYXJ0LmhtYXJnaW4nXSAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gKGxpbmVEYXRhLmxlbmd0aCAtIDEpO2ZvciAoaSA9IDAsIGxlbiA9IGxpbmVEYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB2YXIgZGF0YV9wb2ludCA9IGxpbmVEYXRhW2ldO3ZhciB5UG9zID0gdGhpcy5nZXRZQ29vcmQoZGF0YV9wb2ludCk7aWYgKGxpbmVEYXRhW2ldID09IG51bGwgfHwgcHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnYm90dG9tJyAmJiBsaW5lRGF0YVtpXSA8IHRoaXMubWluICYmICFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddIHx8IHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicgJiYgbGluZURhdGFbaV0gPCAtMSAqIHRoaXMubWF4ICYmICFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddIHx8IChsaW5lRGF0YVtpXSA8IHRoaXMubWluICYmIHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gIT09ICdjZW50ZXInIHx8IGxpbmVEYXRhW2ldID4gdGhpcy5tYXgpICYmICFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddKSB7XG4gICAgICAgIHlQb3MgPSBudWxsO1xuICAgICAgfVxuICAgICAgY28ubGluZUNhcCA9ICdyb3VuZCc7Y28ubGluZUpvaW4gPSAncm91bmQnO2lmIChpID4gMCkge1xuICAgICAgICB4UG9zID0geFBvcyArIHhJbnRlcnZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhQb3MgPSBwcm9wWydjaGFydC5obWFyZ2luJ10gKyB0aGlzLmd1dHRlckxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC54J10pIHtcbiAgICAgICAgeFBvcyAqPSBwcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ107aWYgKHhQb3MgPCBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddKSB7XG4gICAgICAgICAgeFBvcyA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY29vcmRzLnB1c2goW3hQb3MsIHlQb3NdKTtsaW5lQ29vcmRzLnB1c2goW3hQb3MsIHlQb3NdKTtcbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7dGhpcy5jb29yZHMyW2luZGV4XSA9IGxpbmVDb29yZHM7aWYgKFJHLklTT0xEICYmIHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICB0aGlzLkRyYXdJRVNoYWRvdyhsaW5lQ29vcmRzLCBjby5zaGFkb3dDb2xvcik7XG4gICAgfVxuICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO2lmIChmaWxsKSB7XG4gICAgICBjby5maWxsU3R5bGUgPSBmaWxsO1xuICAgIH1cbiAgICB2YXIgaXNTdGVwcGVkID0gcHJvcFsnY2hhcnQuc3RlcHBlZCddO3ZhciBpc0ZpbGxlZCA9IHByb3BbJ2NoYXJ0LmZpbGxlZCddO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICB2YXIgeEF4aXNQb3MgPSB0aGlzLmd1dHRlclRvcDtcbiAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIHZhciB4QXhpc1BvcyA9IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnYm90dG9tJykge1xuICAgICAgdmFyIHhBeGlzUG9zID0gdGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVDb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHhQb3MgPSBsaW5lQ29vcmRzW2ldWzBdO3lQb3MgPSBsaW5lQ29vcmRzW2ldWzFdO3ZhciBzZXQgPSBpbmRleDt2YXIgcHJldlkgPSBsaW5lQ29vcmRzW2kgLSAxXSA/IGxpbmVDb29yZHNbaSAtIDFdWzFdIDogbnVsbDt2YXIgaXNMYXN0ID0gaSArIDEgPT0gbGluZUNvb3Jkcy5sZW5ndGg7aWYgKCFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddICYmIChwcmV2WSA8IHRoaXMuZ3V0dGVyVG9wIHx8IHByZXZZID4gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKSB7XG4gICAgICAgIHBlblVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09IDAgfHwgcGVuVXAgfHwgIXlQb3MgfHwgIXByZXZZIHx8IHByZXZZIDwgdGhpcy5ndXR0ZXJUb3ApIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmZpbGxlZCddICYmICFwcm9wWydjaGFydC5maWxsZWQucmFuZ2UnXSkge1xuICAgICAgICAgIGlmICghcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSB8fCBwcmV2WSA9PT0gbnVsbCB8fCB5UG9zID09PSBudWxsKSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8oeFBvcyArIDEsIHhBeGlzUG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIGNvLm1vdmVUbyh4UG9zICsgMSwgeEF4aXNQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNTdGVwcGVkICYmIGkgPiAwKSB7XG4gICAgICAgICAgICBjby5saW5lVG8oeFBvcywgbGluZUNvb3Jkc1tpIC0gMV1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFJHLklTT0xEICYmIHlQb3MgPT0gbnVsbCkge30gZWxzZSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8oeFBvcyArIDEsIHlQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeVBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgcGVuVXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlblVwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N0ZXBwZWQpIHtcbiAgICAgICAgICBjby5saW5lVG8oeFBvcywgbGluZUNvb3Jkc1tpIC0gMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5UG9zID49IHRoaXMuZ3V0dGVyVG9wICYmIHlQb3MgPD0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gfHwgcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSkge1xuICAgICAgICAgIGlmIChpc0xhc3QgJiYgcHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgIXByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgeFBvcyAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3RlcHBlZCB8fCAhaXNMYXN0KSB7XG4gICAgICAgICAgICBjby5saW5lVG8oeFBvcywgeVBvcyk7aWYgKGlzRmlsbGVkICYmIGxpbmVDb29yZHNbaSArIDFdICYmIGxpbmVDb29yZHNbaSArIDFdWzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY28ubGluZVRvKHhQb3MsIHhBeGlzUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RlcHBlZCAmJiBpc0xhc3QpIHtcbiAgICAgICAgICAgIGNvLmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGVuVXAgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZW5VcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmZpbGxlZCddICYmICFwcm9wWydjaGFydC5maWxsZWQucmFuZ2UnXSAmJiAhcHJvcFsnY2hhcnQuY3VydnknXSkge1xuICAgICAgdmFyIGZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddO2lmIChpbmRleCA+IDAgJiYgcHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddKSB7XG4gICAgICAgIGNvLmxpbmVUbyh4UG9zLCBwcmV2TGluZUNvb3JkcyA/IHByZXZMaW5lQ29vcmRzW2kgLSAxXVsxXSA6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gMSArIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInID8gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiA6IDApKTtmb3IgKHZhciBrID0gaSAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICAgICAgY28ubGluZVRvKGsgPT0gMCA/IHByZXZMaW5lQ29vcmRzW2tdWzBdICsgMSA6IHByZXZMaW5lQ29vcmRzW2tdWzBdLCBwcmV2TGluZUNvb3Jkc1trXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICd0b3AnKSB7XG4gICAgICAgICAgY28ubGluZVRvKHhQb3MsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSArIDEpO2NvLmxpbmVUbyhsaW5lQ29vcmRzWzBdWzBdLCBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGluZUNvb3Jkc1tpIC0gMV1bMV0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgeVBvc2l0aW9uID0gdGhpcy5nZXRZQ29vcmQoMCk7Y28ubGluZVRvKHhQb3MsIHlQb3NpdGlvbik7Y28ubGluZVRvKGxpbmVDb29yZHNbMF1bMF0sIHlQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvLmZpbGxTdHlsZSA9ICF0aGlzLmhpZGRlbihpbmRleCkgPyBmaWxsIDogJ3JnYmEoMCwwLDAsMCknO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtcbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7aWYgKHByb3BbJ2NoYXJ0LmJhY2tkcm9wJ10pIHtcbiAgICAgIHRoaXMuRHJhd0JhY2tkcm9wKGxpbmVDb29yZHMsIGNvbG9yKTtcbiAgICB9XG4gICAgY28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QoMCwgMCwgY2Eud2lkdGggKiBwcm9wWydjaGFydC5hbmltYXRpb24udHJhY2UuY2xpcCddLCBjYS5oZWlnaHQpO2NvLmNsaXAoKTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmVycm9yYmFycyddICE9PSAnbnVsbCcpIHtcbiAgICAgIHRoaXMuZHJhd0Vycm9yYmFycygpO1xuICAgIH1cbiAgICB0aGlzLlNldFNoYWRvdyhpbmRleCk7dGhpcy5yZWRyYXdMaW5lKGxpbmVDb29yZHMsIGNvbG9yLCBsaW5ld2lkdGgsIGluZGV4KTtjby5zdHJva2UoKTtSRy5Ob1NoYWRvdyh0aGlzKTtmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVDb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGkgPSBOdW1iZXIoaSk7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtpZiAoaXNTdGVwcGVkICYmIGkgPT0gbGluZUNvb3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRpY2ttYXJrcyAhPSAnZW5kY2lyY2xlJyAmJiB0aWNrbWFya3MgIT0gJ2VuZHNxdWFyZScgJiYgdGlja21hcmtzICE9ICdmaWxsZWRlbmRzcXVhcmUnICYmIHRpY2ttYXJrcyAhPSAnZW5kdGljaycgJiYgdGlja21hcmtzICE9ICdlbmR0cmlhbmdsZScgJiYgdGlja21hcmtzICE9ICdhcnJvdycgJiYgdGlja21hcmtzICE9ICdmaWxsZWRhcnJvdycgfHwgaSA9PSAwICYmIHRpY2ttYXJrcyAhPSAnYXJyb3cnICYmIHRpY2ttYXJrcyAhPSAnZmlsbGVkYXJyb3cnIHx8IGkgPT0gbGluZUNvb3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBwcmV2WCA9IGkgPD0gMCA/IG51bGwgOiBsaW5lQ29vcmRzW2kgLSAxXVswXTt2YXIgcHJldlkgPSBpIDw9IDAgPyBudWxsIDogbGluZUNvb3Jkc1tpIC0gMV1bMV07dGhpcy5EcmF3VGljayhsaW5lRGF0YSwgbGluZUNvb3Jkc1tpXVswXSwgbGluZUNvb3Jkc1tpXVsxXSwgY29sb3IsIGZhbHNlLCBwcmV2WCwgcHJldlksIHRpY2ttYXJrcywgaSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5yZXN0b3JlKCk7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKGNhLndpZHRoICsgNTAwMDAsIGNhLmhlaWdodCArIDUwMDAwLCAyLCAwLCA2LjM4LCAxKTtcbiAgfTt0aGlzLmRyYXdUaWNrID0gdGhpcy5EcmF3VGljayA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgeFBvcywgeVBvcywgY29sb3IsIGlzU2hhZG93LCBwcmV2WCwgcHJldlksIHRpY2ttYXJrcywgaW5kZXgsIGRhdGFzZXQpIHtcbiAgICBpZiAodGhpcy5oaWRkZW4oZGF0YXNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKFJHLmlzX251bGwoeVBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHlQb3MgPiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSAmJiAhcHJvcFsnY2hhcnQub3V0b2Zib3VuZHMnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoeVBvcyA8IHRoaXMuZ3V0dGVyVG9wICYmICFwcm9wWydjaGFydC5vdXRvZmJvdW5kcyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvLmJlZ2luUGF0aCgpO3ZhciBvZmZzZXQgPSAwO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5saW5ld2lkdGgnXSA/IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5saW5ld2lkdGgnXSA6IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLnN0cm9rZVN0eWxlID0gaXNTaGFkb3cgPyBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSA6IGNvLnN0cm9rZVN0eWxlO2NvLmZpbGxTdHlsZSA9IGlzU2hhZG93ID8gcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10gOiBjby5zdHJva2VTdHlsZTtpZiAodGlja21hcmtzID09ICdjaXJjbGUnIHx8IHRpY2ttYXJrcyA9PSAnZmlsbGVkY2lyY2xlJyB8fCB0aWNrbWFya3MgPT0gJ2VuZGNpcmNsZScpIHtcbiAgICAgIGlmICh0aWNrbWFya3MgPT0gJ2NpcmNsZScgfHwgdGlja21hcmtzID09ICdmaWxsZWRjaXJjbGUnIHx8IHRpY2ttYXJrcyA9PSAnZW5kY2lyY2xlJyAmJiAoaW5kZXggPT0gMCB8fCBpbmRleCA9PSBsaW5lRGF0YS5sZW5ndGggLSAxKSkge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5hcmMoeFBvcyArIG9mZnNldCwgeVBvcyArIG9mZnNldCwgcHJvcFsnY2hhcnQudGlja3NpemUnXSwgMCwgMzYwIC8gKDE4MCAvIFJHLlBJKSwgZmFsc2UpO2lmICh0aWNrbWFya3MgPT0gJ2ZpbGxlZGNpcmNsZScpIHtcbiAgICAgICAgICBjby5maWxsU3R5bGUgPSBpc1NoYWRvdyA/IHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddIDogY28uc3Ryb2tlU3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gaXNTaGFkb3cgPyBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSA6ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgY28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdoYWxmdGljaycpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyhNYXRoLnJvdW5kKHhQb3MpLCB5UG9zKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4UG9zKSwgeVBvcyArIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLnN0cm9rZSgpO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICd0aWNrJykge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcyksIHlQb3MgLSBwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4UG9zKSwgeVBvcyArIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLnN0cm9rZSgpO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdlbmR0aWNrJyAmJiAoaW5kZXggPT0gMCB8fCBpbmRleCA9PSBsaW5lRGF0YS5sZW5ndGggLSAxKSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcyksIHlQb3MgLSBwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4UG9zKSwgeVBvcyArIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pO2NvLnN0cm9rZSgpO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdjcm9zcycpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciB0aWNrc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpY2tzaXplJ107Y28ubW92ZVRvKHhQb3MgLSB0aWNrc2l6ZSwgeVBvcyAtIHRpY2tzaXplKTtjby5saW5lVG8oeFBvcyArIHRpY2tzaXplLCB5UG9zICsgdGlja3NpemUpO2NvLm1vdmVUbyh4UG9zICsgdGlja3NpemUsIHlQb3MgLSB0aWNrc2l6ZSk7Y28ubGluZVRvKHhQb3MgLSB0aWNrc2l6ZSwgeVBvcyArIHRpY2tzaXplKTtjby5zdHJva2UoKTtcbiAgICB9IGVsc2UgaWYgKHRpY2ttYXJrcyA9PSAndHJpYW5nbGUnIHx8IHRpY2ttYXJrcyA9PSAnZmlsbGVkdHJpYW5nbGUnIHx8IHRpY2ttYXJrcyA9PSAnZW5kdHJpYW5nbGUnICYmIChpbmRleCA9PSAwIHx8IGluZGV4ID09IGxpbmVEYXRhLmxlbmd0aCAtIDEpKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtpZiAodGlja21hcmtzID09ICdmaWxsZWR0cmlhbmdsZScpIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gaXNTaGFkb3cgPyBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSA6IGNvLnN0cm9rZVN0eWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIH1cbiAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4UG9zIC0gcHJvcFsnY2hhcnQudGlja3NpemUnXSksIHlQb3MgKyBwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8obWEucm91bmQoeFBvcyksIHlQb3MgLSBwcm9wWydjaGFydC50aWNrc2l6ZSddKTtjby5saW5lVG8obWEucm91bmQoeFBvcyArIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pLCB5UG9zICsgcHJvcFsnY2hhcnQudGlja3NpemUnXSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdib3JkZXJlZGNpcmNsZScgfHwgdGlja21hcmtzID09ICdkb3QnKSB7XG4gICAgICBjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC50aWNrbWFya3MuZG90LmxpbmV3aWR0aCddIHx8IDAuMDAwMDAwMDE7cGEyKGNvLCBbJ2InLCAnYScsIHhQb3MsIHlQb3MsIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10sIDAsIDM2MCAvICgxODAgLyBSRy5QSSksIGZhbHNlLCAnYycsICdmJywgcHJvcFsnY2hhcnQudGlja21hcmtzLmRvdC5maWxsJ10gfHwgY29sb3IsICdzJywgcHJvcFsnY2hhcnQudGlja21hcmtzLmRvdC5zdHJva2UnXSB8fCBjb2xvcl0pO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdzcXVhcmUnIHx8IHRpY2ttYXJrcyA9PSAnZmlsbGVkc3F1YXJlJyB8fCB0aWNrbWFya3MgPT0gJ2VuZHNxdWFyZScgJiYgKGluZGV4ID09IDAgfHwgaW5kZXggPT0gbGluZURhdGEubGVuZ3RoIC0gMSkgfHwgdGlja21hcmtzID09ICdmaWxsZWRlbmRzcXVhcmUnICYmIChpbmRleCA9PSAwIHx8IGluZGV4ID09IGxpbmVEYXRhLmxlbmd0aCAtIDEpKSB7XG4gICAgICBjby5maWxsU3R5bGUgPSAnd2hpdGUnO2NvLnN0cm9rZVN0eWxlID0gY28uc3Ryb2tlU3R5bGU7Y28uYmVnaW5QYXRoKCk7Y28ucmVjdChNYXRoLnJvdW5kKHhQb3MgLSBwcm9wWydjaGFydC50aWNrc2l6ZSddKSwgTWF0aC5yb3VuZCh5UG9zIC0gcHJvcFsnY2hhcnQudGlja3NpemUnXSksIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10gKiAyLCBwcm9wWydjaGFydC50aWNrc2l6ZSddICogMik7aWYgKHRpY2ttYXJrcyA9PSAnZmlsbGVkc3F1YXJlJyB8fCB0aWNrbWFya3MgPT0gJ2ZpbGxlZGVuZHNxdWFyZScpIHtcbiAgICAgICAgY28uZmlsbFN0eWxlID0gaXNTaGFkb3cgPyBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSA6IGNvLnN0cm9rZVN0eWxlO2NvLnJlY3QoTWF0aC5yb3VuZCh4UG9zIC0gcHJvcFsnY2hhcnQudGlja3NpemUnXSksIE1hdGgucm91bmQoeVBvcyAtIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10pLCBwcm9wWydjaGFydC50aWNrc2l6ZSddICogMiwgcHJvcFsnY2hhcnQudGlja3NpemUnXSAqIDIpO1xuICAgICAgfSBlbHNlIGlmICh0aWNrbWFya3MgPT0gJ3NxdWFyZScgfHwgdGlja21hcmtzID09ICdlbmRzcXVhcmUnKSB7XG4gICAgICAgIGNvLmZpbGxTdHlsZSA9IGlzU2hhZG93ID8gcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10gOiAnd2hpdGUnO2NvLnJlY3QoTWF0aC5yb3VuZCh4UG9zIC0gcHJvcFsnY2hhcnQudGlja3NpemUnXSArIDEpLCBNYXRoLnJvdW5kKHlQb3MgLSBwcm9wWydjaGFydC50aWNrc2l6ZSddICsgMSksIHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10gKiAyIC0gMiwgcHJvcFsnY2hhcnQudGlja3NpemUnXSAqIDIgLSAyKTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICB9IGVsc2UgaWYgKHRpY2ttYXJrcyA9PSAnZmlsbGVkYXJyb3cnKSB7XG4gICAgICB2YXIgeCA9IE1hdGguYWJzKHhQb3MgLSBwcmV2WCk7dmFyIHkgPSBNYXRoLmFicyh5UG9zIC0gcHJldlkpO2lmICh5UG9zIDwgcHJldlkpIHtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmF0YW4oeCAvIHkpICsgMS41NztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhID0gTWF0aC5hdGFuKHkgLyB4KSArIDMuMTQ7XG4gICAgICB9XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4UG9zKSwgTWF0aC5yb3VuZCh5UG9zKSk7Y28uYXJjKE1hdGgucm91bmQoeFBvcyksIE1hdGgucm91bmQoeVBvcyksIDcsIGEgLSAwLjUsIGEgKyAwLjUsIGZhbHNlKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7XG4gICAgfSBlbHNlIGlmICh0aWNrbWFya3MgPT0gJ2Fycm93Jykge1xuICAgICAgdmFyIG9yaWdfbGluZXdpZHRoID0gY28ubGluZVdpZHRoO3ZhciB4ID0gTWF0aC5hYnMoeFBvcyAtIHByZXZYKTt2YXIgeSA9IE1hdGguYWJzKHlQb3MgLSBwcmV2WSk7Y28ubGluZVdpZHRoO2lmICh5UG9zIDwgcHJldlkpIHtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmF0YW4oeCAvIHkpICsgMS41NztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhID0gTWF0aC5hdGFuKHkgLyB4KSArIDMuMTQ7XG4gICAgICB9XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh4UG9zKSwgTWF0aC5yb3VuZCh5UG9zKSk7Y28uYXJjKE1hdGgucm91bmQoeFBvcyksIE1hdGgucm91bmQoeVBvcyksIDcsIGEgLSAwLjUgLSAoZG9jLmFsbCA/IDAuMSA6IDAuMDEpLCBhIC0gMC40LCBmYWxzZSk7Y28ubW92ZVRvKE1hdGgucm91bmQoeFBvcyksIE1hdGgucm91bmQoeVBvcykpO2NvLmFyYyhNYXRoLnJvdW5kKHhQb3MpLCBNYXRoLnJvdW5kKHlQb3MpLCA3LCBhICsgMC41ICsgKGRvYy5hbGwgPyAwLjEgOiAwLjAxKSwgYSArIDAuNSwgdHJ1ZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmxpbmVXaWR0aCA9IG9yaWdfbGluZXdpZHRoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpY2ttYXJrcyA9PT0gJ3N0cmluZycgJiYgKHRpY2ttYXJrcy5zdWJzdHIoMCwgNikgPT09ICdpbWFnZTonIHx8IHRpY2ttYXJrcy5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOicgfHwgdGlja21hcmtzLnN1YnN0cigwLCAxKSA9PT0gJy8nIHx8IHRpY2ttYXJrcy5zdWJzdHIoMCwgMykgPT09ICcuLi8nIHx8IHRpY2ttYXJrcy5zdWJzdHIoMCwgNykgPT09ICdpbWFnZXMvJykpIHtcbiAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtpZiAodGlja21hcmtzLnN1YnN0cigwLCA2KSA9PT0gJ2ltYWdlOicpIHtcbiAgICAgICAgaW1nLnNyYyA9IHRpY2ttYXJrcy5zdWJzdHIoNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWcuc3JjID0gdGlja21hcmtzO1xuICAgICAgfVxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5oYWxpZ24nXSA9PT0gJ2NlbnRlcicpIHhQb3MgLT0gdGhpcy53aWR0aCAvIDI7aWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5oYWxpZ24nXSA9PT0gJ3JpZ2h0JykgeFBvcyAtPSB0aGlzLndpZHRoO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UudmFsaWduJ10gPT09ICdjZW50ZXInKSB5UG9zIC09IHRoaXMuaGVpZ2h0IC8gMjtpZiAocHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbiddID09PSAnYm90dG9tJykgeVBvcyAtPSB0aGlzLmhlaWdodDt4UG9zICs9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR4J107eVBvcyArPSBwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2Uub2Zmc2V0eSddO2NvLmRyYXdJbWFnZSh0aGlzLCB4UG9zLCB5UG9zKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGlja21hcmtzID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRpY2ttYXJrcyh0aGlzLCBsaW5lRGF0YSwgbGluZURhdGFbaW5kZXhdLCBpbmRleCwgeFBvcywgeVBvcywgY29sb3IsIHByZXZYLCBwcmV2WSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd1JhbmdlID0gdGhpcy5EcmF3UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddICYmIHByb3BbJ2NoYXJ0LmZpbGxlZCddKSB7XG4gICAgICBpZiAoUkcuaXNOdWxsKHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQnXSkpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuZmlsbGVkLnJhbmdlLnRocmVzaG9sZCddID0gdGhpcy55bWluO1xuICAgICAgICBwcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkLmNvbG9ycyddID0gW3Byb3BbJ2NoYXJ0LmZpbGxzdHlsZSddLCBwcm9wWydjaGFydC5maWxsc3R5bGUnXV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCAyOyArK2lkeCkge1xuICAgICAgICB2YXIgdGhyZXNob2xkX2NvbG9ycyA9IHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQuY29sb3JzJ107dmFyIHkgPSB0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC5maWxsZWQucmFuZ2UudGhyZXNob2xkJ10pO1xuICAgICAgICBjby5zYXZlKCk7aWYgKGlkeCA9PSAwKSB7XG4gICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28ucmVjdCgwLCAwLCBjYS53aWR0aCwgeSk7Y28uY2xpcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnJlY3QoMCwgeSwgY2Eud2lkdGgsIGNhLmhlaWdodCk7Y28uY2xpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGlkeCA9PSAxID8gcHJvcFsnY2hhcnQuZmlsbGVkLnJhbmdlLnRocmVzaG9sZC5jb2xvcnMnXVsxXSA6IHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZS50aHJlc2hvbGQuY29sb3JzJ11bMF07Y28ubGluZVdpZHRoID0gIXRoaXMuaGlkZGVuKGlkeCkgPyAxIDogMDt2YXIgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoIC8gMjtmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgaWYgKCFSRy5pc19udWxsKHRoaXMuY29vcmRzW2ldWzFdKSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICBjby5tb3ZlVG8odGhpcy5jb29yZHNbaV1bMF0sIHRoaXMuY29vcmRzW2ldWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVswXSwgdGhpcy5jb29yZHNbaV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jb29yZHMubGVuZ3RoIC0gMTsgaSA+PSBsZW47IC0taSkge1xuICAgICAgICAgIGlmIChSRy5pc19udWxsKHRoaXMuY29vcmRzW2ldWzFdKSkge1xuICAgICAgICAgICAgY28ubW92ZVRvKHRoaXMuY29vcmRzW2ldWzBdLCB0aGlzLmNvb3Jkc1tpXVsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvLmxpbmVUbyh0aGlzLmNvb3Jkc1tpXVswXSwgdGhpcy5jb29yZHNbaV1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjby5maWxsKCk7Y28ucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLnJlZHJhd0xpbmUgPSB0aGlzLlJlZHJhd0xpbmUgPSBmdW5jdGlvbiAoY29vcmRzLCBjb2xvciwgbGluZXdpZHRoLCBpbmRleCkge1xuICAgIGlmIChwcm9wWydjaGFydC5ub3JlZHJhdyddIHx8IHByb3BbJ2NoYXJ0LmZpbGxlZC5yYW5nZSddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvLnN0cm9rZVN0eWxlID0gKHR5cGVvZiBjb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29sb3IpKSA9PSAnb2JqZWN0JyAmJiBjb2xvciAmJiBjb2xvci50b1N0cmluZygpLmluZGV4T2YoJ0NhbnZhc0dyYWRpZW50JykgPT0gLTEgPyBjb2xvclswXSA6IGNvbG9yO2NvLmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtpZiAocHJvcFsnY2hhcnQuZGFzaGVkJ10pIHtcbiAgICAgIGNvLnNldExpbmVEYXNoKFsyLCA2XSk7XG4gICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5kb3R0ZWQnXSkge1xuICAgICAgY28uc2V0TGluZURhc2goWzEsIDVdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGlkZGVuKGluZGV4KSkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgfVxuICAgIGlmICghUkcuSVNPTEQgJiYgKHByb3BbJ2NoYXJ0LmN1cnZ5J10gfHwgcHJvcFsnY2hhcnQuc3BsaW5lJ10pKSB7XG4gICAgICB0aGlzLkRyYXdDdXJ2eUxpbmUoY29vcmRzLCB0aGlzLmhpZGRlbihpbmRleCkgPyAncmdiYSgwLDAsMCwwKScgOiBjb2xvciwgbGluZXdpZHRoLCBpbmRleCk7cmV0dXJuO1xuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTt2YXIgbGVuID0gY29vcmRzLmxlbmd0aDt2YXIgd2lkdGggPSBjYS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2EuaGVpZ2h0O3ZhciBwZW5VcCA9IGZhbHNlO2ZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciB4UG9zID0gY29vcmRzW2ldWzBdO3ZhciB5UG9zID0gY29vcmRzW2ldWzFdO2lmIChpID4gMCkge1xuICAgICAgICB2YXIgcHJldlggPSBjb29yZHNbaSAtIDFdWzBdO3ZhciBwcmV2WSA9IGNvb3Jkc1tpIC0gMV1bMV07XG4gICAgICB9XG4gICAgICBpZiAoKGkgPT0gMCAmJiBjb29yZHNbaV0gfHwgeVBvcyA8IHRoaXMuZ3V0dGVyVG9wIHx8IHByZXZZIDwgdGhpcy5ndXR0ZXJUb3AgfHwgeVBvcyA+IGhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIHx8IGkgPiAwICYmIHByZXZYID4gd2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IHx8IGkgPiAwICYmIHByZXZZID4gaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gfHwgcHJldlkgPT0gbnVsbCB8fCBwZW5VcCA9PSB0cnVlKSAmJiAoIXByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10gfHwgeVBvcyA9PSBudWxsIHx8IHByZXZZID09IG51bGwpKSB7XG4gICAgICAgIGlmIChSRy5JU09MRCAmJiB5UG9zID09IG51bGwpIHt9IGVsc2Uge1xuICAgICAgICAgIGNvLm1vdmVUbyhjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuVXAgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC5zdGVwcGVkJ10gJiYgaSA+IDApIHtcbiAgICAgICAgICBjby5saW5lVG8oY29vcmRzW2ldWzBdLCBjb29yZHNbaSAtIDFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjby5saW5lVG8oY29vcmRzW2ldWzBdLCBjb29yZHNbaV1bMV0pO3BlblVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb2xvcnMuYWx0ZXJuYXRlJ10gJiYgKHR5cGVvZiBjb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29sb3IpKSA9PSAnb2JqZWN0JyAmJiBjb2xvclswXSAmJiBjb2xvclsxXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgcHJldlggPSBjb29yZHNbaSAtIDFdWzBdO3ZhciBwcmV2WSA9IGNvb3Jkc1tpIC0gMV1bMV07aWYgKHByZXZZICE9IG51bGwgJiYgY29vcmRzW2ldWzFdICE9IG51bGwpIHtcbiAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IGNvbG9yW2Nvb3Jkc1tpXVsxXSA8IHByZXZZID8gMCA6IDFdO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLm1vdmVUbyhwcmV2WCwgcHJldlkpO2NvLmxpbmVUbyhjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSk7Y28uc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmRhc2hlZCddIHx8IHByb3BbJ2NoYXJ0LmRvdHRlZCddKSB7XG4gICAgICBjby5zZXRMaW5lRGFzaChbMSwgMF0pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdJRVNoYWRvdyA9IHRoaXMuRHJhd0lFU2hhZG93ID0gZnVuY3Rpb24gKGNvb3JkcywgY29sb3IpIHtcbiAgICB2YXIgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J107dmFyIG9mZnNldHkgPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLnN0cm9rZVN0eWxlID0gY29sb3I7Y28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBpc051bGwgPSBSRy5pc051bGwoY29vcmRzW2ldWzFdKTt2YXIgcHJldklzTnVsbCA9IFJHLmlzTnVsbChjb29yZHNbaSAtIDFdKSB8fCBSRy5pc051bGwoY29vcmRzW2kgLSAxXVsxXSk7aWYgKGkgPT0gMCB8fCBpc051bGwgfHwgcHJldklzTnVsbCkge1xuICAgICAgICBpZiAoIWlzTnVsbCkge1xuICAgICAgICAgIGNvLm1vdmVUbyhjb29yZHNbaV1bMF0gKyBvZmZzZXR4LCBjb29yZHNbaV1bMV0gKyBvZmZzZXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28ubGluZVRvKGNvb3Jkc1tpXVswXSArIG9mZnNldHgsIGNvb3Jkc1tpXVsxXSArIG9mZnNldHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5zdHJva2UoKTtcbiAgfTt0aGlzLmRyYXdCYWNrZHJvcCA9IHRoaXMuRHJhd0JhY2tkcm9wID0gZnVuY3Rpb24gKGNvb3JkcywgY29sb3IpIHtcbiAgICB2YXIgc2l6ZSA9IHByb3BbJ2NoYXJ0LmJhY2tkcm9wLnNpemUnXTtjby5saW5lV2lkdGggPSBzaXplO2NvLmdsb2JhbEFscGhhID0gcHJvcFsnY2hhcnQuYmFja2Ryb3AuYWxwaGEnXTtjby5zdHJva2VTdHlsZSA9IGNvbG9yO3ZhciB5Q29vcmRzID0gW107Y28uYmVnaW5QYXRoKCk7aWYgKHByb3BbJ2NoYXJ0LmN1cnZ5J10gJiYgIVJHLklTT0xEKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB5Q29vcmRzLnB1c2goY29vcmRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuRHJhd1NwbGluZShjbywgeUNvb3JkcywgY29sb3IsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby5tb3ZlVG8oY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0pO2ZvciAodmFyIGogPSAxOyBqIDwgY29vcmRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNvLmxpbmVUbyhjb29yZHNbal1bMF0sIGNvb3Jkc1tqXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO2NvLmdsb2JhbEFscGhhID0gMTtSRy5Ob1NoYWRvdyh0aGlzKTtcbiAgfTt0aGlzLmdldExpbmVXaWR0aCA9IHRoaXMuR2V0TGluZVdpZHRoID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgbGluZXdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107aWYgKHR5cGVvZiBsaW5ld2lkdGggPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBsaW5ld2lkdGg7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGxpbmV3aWR0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobGluZXdpZHRoKSkgPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChsaW5ld2lkdGhbaV0pIHtcbiAgICAgICAgcmV0dXJuIGxpbmV3aWR0aFtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsaW5ld2lkdGhbMF07XG4gICAgICB9XG4gICAgICBhbGVydCgnW0xJTkVdIEVycm9yISBjaGFydC5saW5ld2lkdGggc2hvdWxkIGJlIGEgc2luZ2xlIG51bWJlciBvciBhbiBhcnJheSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzJyk7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgUkcgPSBSR3JhcGgsXG4gICAgICAgIGNhID0gY2FudmFzID0gZS50YXJnZXQsXG4gICAgICAgIGNvID0gY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllczt2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgb2JqID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB4ID0gb2JqLmNvb3Jkc1tpXVswXTt2YXIgeSA9IG9iai5jb29yZHNbaV1bMV07aWYgKG1vdXNlWCA8PSB4ICsgcHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC5zaXplJ10gJiYgbW91c2VYID49IHggLSBwcm9wWydjaGFydC50b29sdGlwcy5ob3RzcG90LnNpemUnXSAmJiBtb3VzZVkgPD0geSArIHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3Quc2l6ZSddICYmIG1vdXNlWSA+PSB5IC0gcHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC5zaXplJ10pIHtcbiAgICAgICAgaWYgKFJHLnBhcnNlVG9vbHRpcFRleHQpIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcCA9IFJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFzZXQgPSAwO3ZhciBpZHggPSBpO3doaWxlIChpZHggKyAxID4gdGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aCkge1xuICAgICAgICAgIGlkeCAtPSB0aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoO2RhdGFzZXQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAwOiBvYmosIDE6IHgsIDI6IHksIDM6IGksICdvYmplY3QnOiBvYmosICd4JzogeCwgJ3knOiB5LCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAsICdkYXRhc2V0JzogZGF0YXNldCwgJ2luZGV4X2FkanVzdGVkJzogaWR4IH07XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3QueG9ubHknXSA9PSB0cnVlICYmIG1vdXNlWCA8PSB4ICsgcHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdC5zaXplJ10gJiYgbW91c2VYID49IHggLSBwcm9wWydjaGFydC50b29sdGlwcy5ob3RzcG90LnNpemUnXSkge1xuICAgICAgICB2YXIgdG9vbHRpcCA9IFJHLnBhcnNlVG9vbHRpcFRleHQocHJvcFsnY2hhcnQudG9vbHRpcHMnXSwgaSk7cmV0dXJuIHsgMDogb2JqLCAxOiB4LCAyOiB5LCAzOiBpLCAnb2JqZWN0Jzogb2JqLCAneCc6IHgsICd5JzogeSwgJ2luZGV4JzogaSwgJ3Rvb2x0aXAnOiB0b29sdGlwIH07XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd0Fib3ZlTGFiZWxzID0gdGhpcy5EcmF3QWJvdmVMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSddLFxuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmZvbnQnXSB8fCBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnByZSddLFxuICAgICAgICB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLnVuaXRzLnBvc3QnXSxcbiAgICAgICAgZGVjaW1hbHMgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnXSxcbiAgICAgICAgY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuY29sb3InXSB8fCBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10sXG4gICAgICAgIGJnY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuYmFja2dyb3VuZCddIHx8ICd3aGl0ZScsXG4gICAgICAgIGJvcmRlciA9IHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuYm9yZGVyJ10gPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmJvcmRlciddID09PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmxhYmVscy5hYm92ZS5ib3JkZXInXSA6IHRydWUsXG4gICAgICAgIG9mZnNldHkgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUub2Zmc2V0eSddICsgc2l6ZSxcbiAgICAgICAgc3BlY2lmaWMgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc3BlY2lmaWMnXTtjby5iZWdpblBhdGgoKTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmNvb3Jkc1tpXTtSRy50ZXh0Mih0aGlzLCB7IGNvbG9yOiBjb2xvciwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY29vcmRzWzBdLCAneSc6IGNvb3Jkc1sxXSAtIG9mZnNldHksICd0ZXh0Jzogc3BlY2lmaWMgJiYgc3BlY2lmaWNbaV0gPyBzcGVjaWZpY1tpXSA6IHNwZWNpZmljID8gbnVsbCA6IFJHLm51bWJlckZvcm1hdCh0aGlzLCB0eXBlb2YgZGVjaW1hbHMgPT09ICdudW1iZXInID8gdGhpcy5kYXRhX2FycltpXS50b0ZpeGVkKGRlY2ltYWxzKSA6IHRoaXMuZGF0YV9hcnJbaV0sIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmdGaWxsJzogYmdjb2xvciwgJ2JvdW5kaW5nU3Ryb2tlJzogYm9yZGVyID8gJ2JsYWNrJyA6ICdyZ2JhKDAsMCwwLDApJywgJ3RhZyc6ICdsYWJlbHMuYWJvdmUnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdDdXJ2eUxpbmUgPSB0aGlzLkRyYXdDdXJ2eUxpbmUgPSBmdW5jdGlvbiAoY29vcmRzLCBjb2xvciwgbGluZXdpZHRoLCBpbmRleCkge1xuICAgIHZhciB5Q29vcmRzID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHlDb29yZHMucHVzaChjb29yZHNbaV1bMV0pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10pIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciB4YXhpc1kgPSB0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pO2NvLm1vdmVUbyhjb29yZHNbMF1bMF0sIHhheGlzWSk7dGhpcy5kcmF3U3BsaW5lKGNvLCB5Q29vcmRzLCBjb2xvciwgaW5kZXgpO2lmIChwcm9wWydjaGFydC5maWxsZWQuYWNjdW11bGF0aXZlJ10gJiYgaW5kZXggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleCAtIDFdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzU3BsaW5lW2luZGV4IC0gMV1baV1bMF0sIHRoaXMuY29vcmRzU3BsaW5lW2luZGV4IC0gMV1baV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5saW5lVG8oY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXVswXSwgeGF4aXNZKTtcbiAgICAgIH1cbiAgICAgIGNvLmZpbGwoKTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7dGhpcy5EcmF3U3BsaW5lKGNvLCB5Q29vcmRzLCBjb2xvciwgaW5kZXgpO2NvLnN0cm9rZSgpO1xuICB9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGFyZy5sZW5ndGggPT0gMikge1xuICAgICAgdmFyIG1vdXNlWCA9IGFyZ1swXTt2YXIgbW91c2VZID0gYXJnWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW91c2VDb29yZHMgPSBSRy5nZXRNb3VzZVhZKGFyZyk7dmFyIG1vdXNlWCA9IG1vdXNlQ29vcmRzWzBdO3ZhciBtb3VzZVkgPSBtb3VzZUNvb3Jkc1sxXTtcbiAgICB9XG4gICAgdmFyIG9iaiA9IHRoaXM7dmFyIHhheGlzcG9zID0gcHJvcFsnY2hhcnQueGF4aXNwb3MnXTtpZiAobW91c2VZIDwgcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKSB7XG4gICAgICByZXR1cm4geGF4aXNwb3MgPT0gJ2JvdHRvbScgfHwgeGF4aXNwb3MgPT0gJ2NlbnRlcicgPyB0aGlzLm1heCA6IHRoaXMubWluO1xuICAgIH0gZWxzZSBpZiAobW91c2VZID4gY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKSB7XG4gICAgICByZXR1cm4geGF4aXNwb3MgPT0gJ2JvdHRvbScgPyB0aGlzLm1pbiA6IHRoaXMubWF4O1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgdmFyIHZhbHVlID0gKG9iai5ncmFwaGFyZWEgLyAyIC0gKG1vdXNlWSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpIC8gb2JqLmdyYXBoYXJlYSAqIChvYmoubWF4IC0gb2JqLm1pbik7dmFsdWUgKj0gMjt2YWx1ZSA+IDAgPyB2YWx1ZSArPSB0aGlzLm1pbiA6IHZhbHVlIC09IHRoaXMubWluO3JldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ3RvcCcpIHtcbiAgICAgIHZhciB2YWx1ZSA9IChvYmouZ3JhcGhhcmVhIC0gKG1vdXNlWSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSkpIC8gb2JqLmdyYXBoYXJlYSAqIChvYmoubWF4IC0gb2JqLm1pbik7dmFsdWUgPSBNYXRoLmFicyhvYmoubWF4IC0gdmFsdWUpICogLTE7cmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUgPSAob2JqLmdyYXBoYXJlYSAtIChtb3VzZVkgLSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10pKSAvIG9iai5ncmFwaGFyZWEgKiAob2JqLm1heCAtIG9iai5taW4pO1xuICAgICAgdmFsdWUgKz0gb2JqLm1pbjtyZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2hhbG8nKSB7XG4gICAgICAgIHZhciBvYmogPSBzaGFwZS5vYmplY3QsXG4gICAgICAgICAgICBjb2xvciA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW3NoYXBlLmRhdGFzZXRdO1JHLnBhdGgyKG9iai5jb250ZXh0LCAnYiBhICUgJSAxMyAwIDYuMjgzMCBmYWxzZSBmIHJnYmEoMjU1LDI1NSwyNTUsMC43NSknLCBzaGFwZS54LCBzaGFwZS55KTtSRy5wYXRoMihvYmouY29udGV4dCwgJ2dhIDAuMTUgYiBhICUgJSAxMyAwIDYuMjgzMCBmYWxzZSBmICUgZ2EgMScsIHNoYXBlLngsIHNoYXBlLnksIGNvbG9yKTtSRy5wYXRoMihvYmouY29udGV4dCwgJ2IgYSAlICUgNyAwIDYuMjgzMCBmYWxzZSBmIHdoaXRlJywgc2hhcGUueCwgc2hhcGUueSk7UkcucGF0aDIob2JqLmNvbnRleHQsICdiIGEgJSAlIDUgMCA2LjI4MzAgZmFsc2UgZiAlJywgc2hhcGUueCwgc2hhcGUueSwgY29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcuSGlnaGxpZ2h0LlBvaW50KHRoaXMsIHNoYXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7aWYgKG1vdXNlWFlbMF0gPiBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddIC0gNSAmJiBtb3VzZVhZWzBdIDwgY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSArIDUgJiYgbW91c2VYWVsxXSA+IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSAtIDUgJiYgbW91c2VYWVsxXSA8IGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSArIDUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRoaXMuZ2V0VmFsdWUoZSkpO3ZhciBzaGFwZSA9IFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJyk7aWYgKHNoYXBlKSB7XG4gICAgICAgIFJHLlJlZ2lzdHJ5LlNldCgnY2hhcnQuYWRqdXN0aW5nLnNoYXBlJywgc2hhcGUpO3RoaXMub3JpZ2luYWxfZGF0YVtzaGFwZVsnZGF0YXNldCddXVtzaGFwZVsnaW5kZXhfYWRqdXN0ZWQnXV0gPSBOdW1iZXIodmFsdWUpO1JHLnJlZHJhd0NhbnZhcyhlLnRhcmdldCk7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmFkanVzdCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldFlDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgeTt2YXIgeGF4aXNwb3MgPSBwcm9wWydjaGFydC54YXhpc3BvcyddO2lmICh4YXhpc3BvcyA9PSAndG9wJykge1xuICAgICAgeSA9ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMuZ3JhcGhhcmVhO2lmIChwcm9wWydjaGFydC5zY2FsZS5pbnZlcnQnXSkge1xuICAgICAgICB5ID0gdGhpcy5ncmFwaGFyZWEgLSB5O1xuICAgICAgfVxuICAgICAgeSA9IHkgKyB0aGlzLmd1dHRlclRvcDtcbiAgICB9IGVsc2UgaWYgKHhheGlzcG9zID09ICdjZW50ZXInKSB7XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHRoaXMuZ3JhcGhhcmVhIC8gMik7eSA9IHRoaXMuZ3JhcGhhcmVhIC8gMiAtIHk7eSArPSB0aGlzLmd1dHRlclRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCh2YWx1ZSA8IHRoaXMubWluIHx8IHZhbHVlID4gdGhpcy5tYXgpICYmIHByb3BbJ2NoYXJ0Lm91dG9mYm91bmRzJ10gPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogdGhpcy5ncmFwaGFyZWE7aWYgKHByb3BbJ2NoYXJ0LnNjYWxlLmludmVydCddKSB7XG4gICAgICAgIHkgPSB0aGlzLmdyYXBoYXJlYSAtIHk7XG4gICAgICB9XG4gICAgICB5ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gLSB5O1xuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfTt0aGlzLmRyYXdTcGxpbmUgPSB0aGlzLkRyYXdTcGxpbmUgPSBmdW5jdGlvbiAoY29udGV4dCwgY29vcmRzLCBjb2xvciwgaW5kZXgpIHtcbiAgICB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF0gPSBbXTt2YXIgeENvb3JkcyA9IFtdO3ZhciBndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt2YXIgZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt2YXIgaG1hcmdpbiA9IHByb3BbJ2NoYXJ0LmhtYXJnaW4nXTt2YXIgaW50ZXJ2YWwgPSAoY2Eud2lkdGggLSAoZ3V0dGVyTGVmdCArIGd1dHRlclJpZ2h0KSAtIDIgKiBobWFyZ2luKSAvIChjb29yZHMubGVuZ3RoIC0gMSk7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoX3R5cGVvZihjb29yZHNbaV0pID09ICdvYmplY3QnICYmIGNvb3Jkc1tpXSAmJiBjb29yZHNbaV0ubGVuZ3RoID09IDIpIHtcbiAgICAgICAgY29vcmRzW2ldID0gTnVtYmVyKGNvb3Jkc1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBQID0gW2Nvb3Jkc1swXV07Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIFAucHVzaChjb29yZHNbaV0pO1xuICAgIH1cbiAgICBQLnB1c2goY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXSArIChjb29yZHNbY29vcmRzLmxlbmd0aCAtIDFdIC0gY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAyXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgUC5sZW5ndGggLSAyOyArK2opIHtcbiAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTA7ICsrdCkge1xuICAgICAgICB2YXIgeUNvb3JkID0gU3BsaW5lKHQgLyAxMCwgUFtqIC0gMV0sIFBbal0sIFBbaiArIDFdLCBQW2ogKyAyXSk7eENvb3Jkcy5wdXNoKChqIC0gMSkgKiBpbnRlcnZhbCArIHQgKiAoaW50ZXJ2YWwgLyAxMCkgKyBndXR0ZXJMZWZ0ICsgaG1hcmdpbik7Y28ubGluZVRvKHhDb29yZHNbeENvb3Jkcy5sZW5ndGggLSAxXSwgeUNvb3JkKTtpZiAodHlwZW9mIGluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLnB1c2goW3hDb29yZHNbeENvb3Jkcy5sZW5ndGggLSAxXSwgeUNvb3JkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY28ubGluZVRvKChqIC0gMSkgKiBpbnRlcnZhbCArIGd1dHRlckxlZnQgKyBobWFyZ2luLCBQW2pdKTtpZiAodHlwZW9mIGluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF0ucHVzaChbKGogLSAxKSAqIGludGVydmFsICsgZ3V0dGVyTGVmdCArIGhtYXJnaW4sIFBbal1dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU3BsaW5lKHQsIFAwLCBQMSwgUDIsIFAzKSB7XG4gICAgICByZXR1cm4gMC41ICogKDIgKiBQMSArICgwIC0gUDAgKyBQMikgKiB0ICsgKCgyICogUDAgLSA1ICogUDEgKyA0ICogUDIgLSBQMykgKiAodCAqIHQpICsgKDAgLSBQMCArIDMgKiBQMSAtIDMgKiBQMiArIFAzKSAqICh0ICogdCAqIHQpKSk7XG4gICAgfVxuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkdyYXBoLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZmlsbHN0eWxlJ10gPSBSR3JhcGguYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ10gPSBSR3JhcGguYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10gPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRleHQuY29sb3InXSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddID0gcHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5hbm5vdGF0ZS5jb2xvciddID0gcHJvcFsnY2hhcnQuYW5ub3RhdGUuY29sb3InXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGl0bGUuY29sb3InXSA9IHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ107dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJ10gPSBwcm9wWydjaGFydC50aXRsZS55YXhpcy5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuYmFja2dyb3VuZCddID0gcHJvcFsnY2hhcnQua2V5LmJhY2tncm91bmQnXTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYXhpcy5jb2xvciddID0gcHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5jb2xvcnMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKF90eXBlb2YocHJvcFsnY2hhcnQuY29sb3JzJ11baV0pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzBdICYmIHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzFdKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzBdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11baV1bMF0pO3Byb3BbJ2NoYXJ0LmNvbG9ycyddW2ldWzFdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY29sb3JzJ11baV1bMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuY29sb3JzJ11baV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5maWxsc3R5bGUnXSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5maWxsc3R5bGUnXSA9PSAnc3RyaW5nJykge1xuICAgICAgICBwcm9wWydjaGFydC5maWxsc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddLCAndmVydGljYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQuZmlsbHN0eWxlJ10ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBwcm9wWydjaGFydC5maWxsc3R5bGUnXVtpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmZpbGxzdHlsZSddW2ldLCAndmVydGljYWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIVJHLmlzX251bGwocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5rZXkuY29sb3JzJ10ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQua2V5LmNvbG9ycyddW2ldID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByb3BlcnRpZXMgPSBbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJywgJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcicsICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJywgJ2NoYXJ0LnRleHQuY29sb3InLCAnY2hhcnQuY3Jvc3NoYWlycy5jb2xvcicsICdjaGFydC5hbm5vdGF0ZS5jb2xvcicsICdjaGFydC50aXRsZS5jb2xvcicsICdjaGFydC50aXRsZS55YXhpcy5jb2xvcicsICdjaGFydC5rZXkuYmFja2dyb3VuZCcsICdjaGFydC5heGlzLmNvbG9yJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwcm9wW3Byb3BlcnRpZXNbaV1dID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFtwcm9wZXJ0aWVzW2ldXSk7XG4gICAgfVxuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIHZhciBkaXIgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09ICdzdHJpbmcnID8gYXJndW1lbnRzWzFdIDogJ3ZlcnRpY2FsJztpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO2lmIChkaXIgPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2Eud2lkdGgsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIDAsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7XG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5zZXRTaGFkb3cgPSB0aGlzLlNldFNoYWRvdyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICB2YXIgc2hhZG93Q29sb3IgPSBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXTtpZiAoKHR5cGVvZiBzaGFkb3dDb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc2hhZG93Q29sb3IpKSA9PSAnb2JqZWN0JyAmJiBzaGFkb3dDb2xvcltpIC0gMV0pIHtcbiAgICAgICAgY28uc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcltpXTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBzaGFkb3dDb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc2hhZG93Q29sb3IpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBjby5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yWzBdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2hhZG93Q29sb3IgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY28uc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcbiAgICAgIH1cbiAgICAgIGNvLnNoYWRvd0JsdXIgPSBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddO2NvLnNoYWRvd09mZnNldFggPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddO2NvLnNoYWRvd09mZnNldFkgPSBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddO1xuICAgIH1cbiAgfTt0aGlzLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzMltpbmRleF07aWYgKGNvb3Jkcykge1xuICAgICAgdmFyIHByZV9saW5ld2lkdGggPSBjby5saW5lV2lkdGg7dmFyIHByZV9saW5lY2FwID0gY28ubGluZUNhcDtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXSArIDEwO2NvLmxpbmVDYXAgPSAncm91bmQnO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5iZWdpblBhdGgoKTtpZiAocHJvcFsnY2hhcnQuY3VydnknXSkge1xuICAgICAgICB0aGlzLkRyYXdTcGxpbmUoY28sIGNvb3JkcywgcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydCddLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA9PSAwIHx8IFJHLmlzX251bGwoY29vcmRzW2ldWzFdKSB8fCBfdHlwZW9mKGNvb3Jkc1tpIC0gMV1bMV0pICE9IHVuZGVmaW5lZCAmJiBSRy5pc19udWxsKGNvb3Jkc1tpIC0gMV1bMV0pKSB7XG4gICAgICAgICAgICBjby5tb3ZlVG8oY29vcmRzW2ldWzBdLCBjb29yZHNbaV1bMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjby5saW5lVG8oY29vcmRzW2ldWzBdLCBjb29yZHNbaV1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gcHJlX2xpbmV3aWR0aDtjby5saW5lQ2FwID0gcHJlX2xpbmVjYXA7XG4gICAgfVxuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmRyYXdFcnJvcmJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uc2F2ZSgpO1JHLm5vU2hhZG93KHRoaXMpO3ZhciBjb29yZHMgPSB0aGlzLmNvb3JkcyxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIGVycm9yYmFycyA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycyddLFxuICAgICAgICBsZW5ndGggPSAwO2lmICghcHJvcFsnY2hhcnQuZXJyb3JiYXJzLmNhcHBlZCddKSB7XG4gICAgICBwcm9wWydjaGFydC5lcnJvcmJhcnMuY2FwcGVkLndpZHRoJ10gPSAwLjAwMTtoYWxmd2lkdGggPSAwLjAwMDU7XG4gICAgfVxuICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGhhbGZ3aWR0aCA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5jYXBwZWQud2lkdGgnXSAvIDIgfHwgNSxcbiAgICAgICAgICBjb2xvciA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5jb2xvciddIHx8ICdibGFjayc7aWYgKGVycm9yYmFyc1tpXSAmJiB0eXBlb2YgZXJyb3JiYXJzW2ldWzNdID09PSAnbnVtYmVyJykge1xuICAgICAgICBjby5saW5lV2lkdGggPSBlcnJvcmJhcnNbaV1bM107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5lcnJvcmJhcnMubGluZXdpZHRoJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvLmxpbmVXaWR0aCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVycm9yYmFycyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVycm9yYmFyc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcmJhcnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aXZlTGVuZ3RoID0gdGhpcy5nZXRZQ29vcmQodGhpcy5taW4pIC0gdGhpcy5nZXRZQ29vcmQodGhpcy5taW4gKyBlcnJvcmJhcnMpLFxuICAgICAgICAgICAgICBuZWdhdGl2ZUxlbmd0aCA9IHBvc2l0aXZlTGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3NpdGl2ZUxlbmd0aCA9IHRoaXMuZ2V0WUNvb3JkKHRoaXMubWluKSAtIHRoaXMuZ2V0WUNvb3JkKHRoaXMubWluICsgZXJyb3JiYXJzW2ldKSxcbiAgICAgICAgICAgICAgbmVnYXRpdmVMZW5ndGggPSBwb3NpdGl2ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpdmVMZW5ndGggfHwgbmVnYXRpdmVMZW5ndGgpIHtcbiAgICAgICAgICBwYTIoY28sICdsaiBtaXRlciBsYyBzcXVhcmUgYiBtICUgJSBsICUgJSBtICUgJSBsICUgJSBsICUgJSBtICUgJSBsICUgJSBzICUnLCBjb29yZHNbaV1bMF0gLSBoYWxmd2lkdGgsIGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0gKyBoYWxmd2lkdGgsIGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSAtIHBvc2l0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0gLSBoYWxmd2lkdGgsIGNvb3Jkc1tpXVsxXSAtIHBvc2l0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSAtIHBvc2l0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0gKyBoYWxmd2lkdGgsIGNvb3Jkc1tpXVsxXSAtIHBvc2l0aXZlTGVuZ3RoLCBjb2xvcik7cGEyKGNvLCAnbGogbWl0ZXIgbGMgc3F1YXJlIGIgbSAlICUgbCAlICUgcyAlJywgY29vcmRzW2ldWzBdIC0gaGFsZndpZHRoLCBjb29yZHNbaV1bMV0gKyBuZWdhdGl2ZUxlbmd0aCwgY29vcmRzW2ldWzBdICsgaGFsZndpZHRoLCBjb29yZHNbaV1bMV0gKyBuZWdhdGl2ZUxlbmd0aCwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YoZXJyb3JiYXJzW2ldKSA9PT0gJ29iamVjdCcgJiYgIVJHLmlzTnVsbChlcnJvcmJhcnNbaV0pKSB7XG4gICAgICAgIHZhciBwb3NpdGl2ZUxlbmd0aCA9IHRoaXMuZ2V0WUNvb3JkKHRoaXMubWluKSAtIHRoaXMuZ2V0WUNvb3JkKHRoaXMubWluICsgZXJyb3JiYXJzW2ldWzBdKSxcbiAgICAgICAgICAgIG5lZ2F0aXZlTGVuZ3RoID0gdGhpcy5nZXRZQ29vcmQodGhpcy5taW4pIC0gdGhpcy5nZXRZQ29vcmQodGhpcy5taW4gKyBlcnJvcmJhcnNbaV1bMV0pO2lmICh0eXBlb2YgZXJyb3JiYXJzW2ldWzJdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbG9yID0gZXJyb3JiYXJzW2ldWzJdO1xuICAgICAgICB9XG4gICAgICAgIGhhbGZ3aWR0aCA9IHR5cGVvZiBlcnJvcmJhcnNbaV1bNF0gPT09ICdudW1iZXInID8gZXJyb3JiYXJzW2ldWzRdIC8gMiA6IGhhbGZ3aWR0aDtpZiAoX3R5cGVvZihlcnJvcmJhcnNbaV0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3JiYXJzW2ldWzNdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvLmxpbmVXaWR0aCA9IGVycm9yYmFyc1tpXVszXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuZXJyb3JiYXJzLmxpbmV3aWR0aCddID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmVycm9yYmFycy5saW5ld2lkdGgnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5saW5lV2lkdGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghUkcuaXNOdWxsKGVycm9yYmFyc1tpXVswXSkpIHtcbiAgICAgICAgICBwYTIoY28sICdsYyBzcXVhcmUgYiAgbSAlICUgbCAlICUgbCAlICUgbSAlICUgbCAlICUgcyAlJywgY29vcmRzW2ldWzBdLCBjb29yZHNbaV1bMV0sIGNvb3Jkc1tpXVswXSwgY29vcmRzW2ldWzFdIC0gcG9zaXRpdmVMZW5ndGgsIGNvb3Jkc1tpXVswXSAtIGhhbGZ3aWR0aCwgbWEucm91bmQoY29vcmRzW2ldWzFdIC0gcG9zaXRpdmVMZW5ndGgpLCBjb29yZHNbaV1bMF0sIG1hLnJvdW5kKGNvb3Jkc1tpXVsxXSAtIHBvc2l0aXZlTGVuZ3RoKSwgY29vcmRzW2ldWzBdICsgaGFsZndpZHRoLCBtYS5yb3VuZChjb29yZHNbaV1bMV0gLSBwb3NpdGl2ZUxlbmd0aCksIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yYmFyc1tpXVsxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgbmVnYXRpdmVMZW5ndGggPSBtYS5hYnModGhpcy5nZXRZQ29vcmQoZXJyb3JiYXJzW2ldWzFdKSAtIHRoaXMuZ2V0WUNvb3JkKDApKTtwYTIoY28sICdiIG0gJSAlIGwgJSAlIGwgJSAlIG0gJSAlIGwgJSAlIHMgJScsIGNvb3Jkc1tpXVswXSwgY29vcmRzW2ldWzFdLCBjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoLCBjb29yZHNbaV1bMF0gLSBoYWxmd2lkdGgsIG1hLnJvdW5kKGNvb3Jkc1tpXVsxXSArIG5lZ2F0aXZlTGVuZ3RoKSwgY29vcmRzW2ldWzBdLCBtYS5yb3VuZChjb29yZHNbaV1bMV0gKyBuZWdhdGl2ZUxlbmd0aCksIGNvb3Jkc1tpXVswXSArIGhhbGZ3aWR0aCwgbWEucm91bmQoY29vcmRzW2ldWzFdICsgbmVnYXRpdmVMZW5ndGgpLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY28ucmVzdG9yZSgpO1xuICB9O3RoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2FyZ3VtZW50c1swXV0gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmxpbmUudmlzaWJsZSddW2FyZ3VtZW50c1swXVtpXV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsX2RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11baV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgUkcucmVkcmF3KCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11bYXJndW1lbnRzWzBdXSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGFyZ3VtZW50c1swXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c1swXS5sZW5ndGg7ICsraSkge1xuICAgICAgICBwcm9wWydjaGFydC5saW5lLnZpc2libGUnXVthcmd1bWVudHNbMF1baV1dID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsX2RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11baV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBSRy5yZWRyYXcoKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmhpZGRlbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiAhcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11baW5kZXhdO1xuICB9O3RoaXMudW5mb2xkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyA/IG9wdC5mcmFtZXMgOiAzMDt2YXIgZnJhbWUgPSAwO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O3ZhciBpbml0aWFsID0gcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC5pbml0aWFsJ107cHJvcFsnY2hhcnQuYW5pbWF0aW9uLmZhY3RvciddID0gcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnVuZm9sZC5pbml0aWFsJ107ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBwcm9wWydjaGFydC5hbmltYXRpb24uZmFjdG9yJ10gPSAoMSAtIGluaXRpYWwpICogKGZyYW1lIC8gZnJhbWVzKSArIGluaXRpYWw7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSA8IGZyYW1lcykge1xuICAgICAgICBmcmFtZSsrO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy50cmFjZSA9IHRoaXMudHJhY2UyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1syXTt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O29iai5TZXQoJ2FuaW1hdGlvbi50cmFjZS5jbGlwJywgMCk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgb2JqLlNldCgnYW5pbWF0aW9uLnRyYWNlLmNsaXAnLCBmcmFtZSAvIGZyYW1lcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZvbGR0b2NlbnRlciA9IHRoaXMuZm9sZFRvQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIGNlbnRlcl92YWx1ZSA9IG9iai5zY2FsZTIubWF4IC8gMjtvYmouU2V0KCdjaGFydC55bWF4Jywgb2JqLnNjYWxlMi5tYXgpO3ZhciBvcmlnaW5hbF9kYXRhID0gUkcuYXJyYXlfY2xvbmUob2JqLm9yaWdpbmFsX2RhdGEpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChvYmouZGF0YVtpXS5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IG9iai5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraikge1xuICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSBvYmoub3JpZ2luYWxfZGF0YVtpXTtpZiAoZGF0YXNldFtqXSA+IGNlbnRlcl92YWx1ZSkge1xuICAgICAgICAgICAgICBkYXRhc2V0W2pdID0gb3JpZ2luYWxfZGF0YVtpXVtqXSAtIChvcmlnaW5hbF9kYXRhW2ldW2pdIC0gY2VudGVyX3ZhbHVlKSAqIChmcmFtZSAvIGZyYW1lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhc2V0W2pdID0gb3JpZ2luYWxfZGF0YVtpXVtqXSArIChjZW50ZXJfdmFsdWUgLSBvcmlnaW5hbF9kYXRhW2ldW2pdKSAvIGZyYW1lcyAqIGZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1xuICAgICAgaWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgUkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLnVuZm9sZEZyb21DZW50ZXJUcmFjZSA9IHRoaXMudW5mb2xkRnJvbUNlbnRlclRyYWNlMiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGRhdGEgPSBSRy5hcnJheUNsb25lKG9iai5vcmlnaW5hbF9kYXRhKSxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307b2JqLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7b2JqLmRyYXcoKTt2YXIgbWF4ID0gb2JqLnNjYWxlMi5tYXg7UkcuY2xlYXIob2JqLmNhbnZhcyk7b2JqLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO3ZhciB1bmZvbGRDYWxsYmFjayA9IGZ1bmN0aW9uIHVuZm9sZENhbGxiYWNrKCkge1xuICAgICAgb2JqLm9yaWdpbmFsX2RhdGEgPSBkYXRhO29iai51bmZvbGRGcm9tQ2VudGVyKHsgZnJhbWVzOiBmcmFtZXMgLyAyIH0sIGNhbGxiYWNrKTtcbiAgICB9O3ZhciBoYWxmID0gb2JqLkdldCgnY2hhcnQueGF4aXNwb3MnKSA9PSAnY2VudGVyJyA/IG9iai5taW4gOiAob2JqLm1heCAtIG9iai5taW4pIC8gMiArIG9iai5taW47b2JqLlNldCgnY2hhcnQueW1heCcsIG9iai5tYXgpO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoub3JpZ2luYWxfZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoub3JpZ2luYWxfZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICBvYmoub3JpZ2luYWxfZGF0YVtpXVtqXSA9IG9iai5HZXQoJ2NoYXJ0LmZpbGxlZCcpICYmIG9iai5HZXQoJ2NoYXJ0LmZpbGxlZC5hY2N1bXVsYXRpdmUnKSAmJiBpID4gMCA/IDAgOiBoYWxmO1xuICAgICAgfVxuICAgIH1cbiAgICBSRy5jbGVhcihvYmouY2FudmFzKTtvYmoudHJhY2UyKHsgZnJhbWVzOiBmcmFtZXMgLyAyIH0sIHVuZm9sZENhbGxiYWNrKTtyZXR1cm4gb2JqO1xuICB9O3RoaXMudW5mb2xkRnJvbUNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O29iai5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO29iai5EcmF3KCk7dmFyIG1heCA9IG9iai5zY2FsZTIubWF4O1JHLmNsZWFyKG9iai5jYW52YXMpO29iai5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJzt2YXIgY2VudGVyX3ZhbHVlID0gb2JqLkdldCgnY2hhcnQueGF4aXNwb3MnKSA9PT0gJ2NlbnRlcicgPyBwcm9wWydjaGFydC55bWluJ10gOiAob2JqLm1heCAtIG9iai5taW4pIC8gMiArIG9iai5taW47dmFyIG9yaWdpbmFsX2RhdGEgPSBSRy5hcnJheV9jbG9uZShvYmoub3JpZ2luYWxfZGF0YSk7dmFyIHN0ZXBzID0gbnVsbDtvYmouU2V0KCdjaGFydC55bWF4JywgbWF4KTtpZiAoIXN0ZXBzKSB7XG4gICAgICBzdGVwcyA9IFtdO2ZvciAodmFyIGRhdGFzZXQgPSAwLCBsZW4gPSBvcmlnaW5hbF9kYXRhLmxlbmd0aDsgZGF0YXNldCA8IGxlbjsgKytkYXRhc2V0KSB7XG4gICAgICAgIHN0ZXBzW2RhdGFzZXRdID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4yID0gb3JpZ2luYWxfZGF0YVtkYXRhc2V0XS5sZW5ndGg7IGkgPCBsZW4yOyArK2kpIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuZmlsbGVkJ10gJiYgcHJvcFsnY2hhcnQuZmlsbGVkLmFjY3VtdWxhdGl2ZSddICYmIGRhdGFzZXQgPiAwKSB7XG4gICAgICAgICAgICBzdGVwc1tkYXRhc2V0XVtpXSA9IG9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV0gLyBmcmFtZXM7b2JqLm9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV0gPSBjZW50ZXJfdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXBzW2RhdGFzZXRdW2ldID0gKG9yaWdpbmFsX2RhdGFbZGF0YXNldF1baV0gLSBjZW50ZXJfdmFsdWUpIC8gZnJhbWVzO29iai5vcmlnaW5hbF9kYXRhW2RhdGFzZXRdW2ldID0gY2VudGVyX3ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmZvbGRGcm9tQ2VudGVyKCkge1xuICAgICAgZm9yICh2YXIgZGF0YXNldCA9IDA7IGRhdGFzZXQgPCBvcmlnaW5hbF9kYXRhLmxlbmd0aDsgKytkYXRhc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxfZGF0YVtkYXRhc2V0XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG9iai5vcmlnaW5hbF9kYXRhW2RhdGFzZXRdW2ldICs9IHN0ZXBzW2RhdGFzZXRdW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKC0tZnJhbWVzID4gMCkge1xuICAgICAgICBSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyh1bmZvbGRGcm9tQ2VudGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5vcmlnaW5hbF9kYXRhID0gUkcuYXJyYXlfY2xvbmUob3JpZ2luYWxfZGF0YSk7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHVuZm9sZEZyb21DZW50ZXIoKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5hdHQoY2EpO3RoaXMuaXNBZGp1c3RhYmxlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKFJHLmlzTnVsbChwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoUkcuaXNBcnJheShwcm9wWydjaGFydC5hZGp1c3RhYmxlLm9ubHknXSkgJiYgcHJvcFsnY2hhcnQuYWRqdXN0YWJsZS5vbmx5J11bc2hhcGUuaW5kZXhdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcmlnaW5hbF9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ11baV0gPSB0cnVlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///194\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Meter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'meter';this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.centerx = null;this.centery = null;this.radius = null;this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.image.url': null, 'chart.background.image.offsetx': 0, 'chart.background.image.offsety': 0, 'chart.background.image.stretch': true, 'chart.background.color': 'white', 'chart.gutter.left': 15, 'chart.gutter.right': 15, 'chart.gutter.top': 15, 'chart.gutter.bottom': 20, 'chart.linewidth': 1, 'chart.linewidth.segments': 0, 'chart.strokestyle': null, 'chart.border': true, 'chart.border.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.valign': 'center', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.value.text.decimals': 0, 'chart.value.text.units.pre': '', 'chart.value.text.units.post': '', 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.green.start': (this.max - this.min) * 0.35 + this.min, 'chart.green.end': this.max, 'chart.green.color': '#207A20', 'chart.yellow.start': (this.max - this.min) * 0.1 + this.min, 'chart.yellow.end': (this.max - this.min) * 0.35 + this.min, 'chart.yellow.color': '#D0AC41', 'chart.red.start': this.min, 'chart.red.end': (this.max - this.min) * 0.1 + this.min, 'chart.red.color': '#9E1E1E', 'chart.colors.ranges': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.contextmenu': null, 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.tickmarks.small.num': 100, 'chart.tickmarks.big.num': 10, 'chart.tickmarks.small.color': '#bbb', 'chart.tickmarks.big.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.labels': true, 'chart.labels.count': 10, 'chart.labels.specific': null, 'chart.segment.radius.start': 0, 'chart.needle.radius': null, 'chart.needle.tail': false, 'chart.needle.head': true, 'chart.needle.color': 'black', 'chart.needle.image.url': null, 'chart.needle.image.offsetx': 0, 'chart.needle.image.offsety': 0, 'chart.adjustable': false, 'chart.angles.start': RGraph.PI, 'chart.angles.end': RGraph.TWOPI, 'chart.centerpin.stroke': 'black', 'chart.centerpin.fill': 'white', 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[METER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (this.value > this.max) this.value = this.max;if (this.value < this.min) this.value = this.min;this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, ca.height - this.gutterTop - this.gutterBottom);this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.drawBackground();this.drawLabels();this.drawNeedle();this.drawReadout();RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (typeof prop['chart.background.image.url'] === 'string' && !this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];var img = new Image();this.__background_image__ = img;img.src = prop['chart.background.image.url'];img.onload = function () {\n        if (prop['chart.background.image.stretch']) {\n          co.drawImage(this, x, y, ca.width, ca.height);\n        } else {\n          co.drawImage(this, x, y);\n        }\n        RG.redraw();\n      };\n    } else if (this.__background_image__) {\n      var x = 0 + prop['chart.background.image.offsetx'];var y = 0 + prop['chart.background.image.offsety'];if (prop['chart.background.image.stretch']) {\n        co.drawImage(this.__background_image__, x, y, ca.width, ca.height);\n      } else {\n        co.drawImage(this.__background_image__, x, y);\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];if (prop['chart.shadow']) {\n      RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.fill();RG.NoShadow(this);if (prop['chart.shadow']) {\n      co.beginPath();var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();RG.NoShadow(this);\n    }\n    if (prop['chart.tickmarks.small.num']) {\n      for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += RG.PI / prop['chart.tickmarks.small.num']) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.small.color'];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);co.stroke();\n      }\n      co.beginPath();co.fillStyle = prop['chart.background.color'];co.arc(this.centerx, this.centery, this.radius - 4, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();\n    }\n    if (prop['chart.tickmarks.big.num']) {\n      var colors = ['white', 'white', prop['chart.tickmarks.big.color']];for (var j = 0; j < colors.length; ++j) {\n        for (var i = 0; i < prop['chart.angles.end'] - prop['chart.angles.start']; i += (prop['chart.angles.end'] - prop['chart.angles.start']) / prop['chart.tickmarks.big.num']) {\n          co.beginPath();co.strokeStyle = colors[j];co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.001, 0);co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.0001, 0);co.stroke();\n        }\n      }\n    }\n    co.beginPath();co.fillStyle = prop['chart.background.color'];co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius - 7, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();co.fill();var ranges = prop['chart.colors.ranges'];if (RG.is_array(prop['chart.colors.ranges'])) {\n      var ranges = prop['chart.colors.ranges'];for (var i = 0; i < ranges.length; ++i) {\n        co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : ranges[i][2];co.fillStyle = ranges[i][2];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n          co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (ranges[i][1] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (ranges[i][0] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n        } else {\n          co.lineTo(this.centerx, this.centery);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n      co.beginPath();\n    } else {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.green.color'];co.fillStyle = prop['chart.green.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - this.properties['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.green.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.green.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.yellow.color'];co.fillStyle = prop['chart.yellow.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.yellow.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.yellow.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.red.color'];co.fillStyle = prop['chart.red.color'];co.lineWidth = prop['chart.linewidth.segments'];co.beginPath();co.arc(this.centerx, this.centery, this.radius * 0.85, (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], false);if (prop['chart.segment.radius.start'] > 0) {\n        co.arc(this.centerx, this.centery, prop['chart.segment.radius.start'], (prop['chart.red.end'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], (prop['chart.red.start'] - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'], true);\n      } else {\n        co.lineTo(this.centerx, this.centery);\n      }\n      co.closePath();co.stroke();co.fill();co.lineWidth = 1;\n    }\n    if (prop['chart.border']) {\n      co.strokeStyle = prop['chart.border.color'];co.lineWidth = prop['chart.linewidth'];co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end'], false);co.closePath();\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawNeedle = this.DrawNeedle = function () {\n    var a = (this.value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];if (typeof prop['chart.needle.image.url'] === 'string' && !this.__needle_image__) {\n      var img = new Image();this.__needle_image__ = img;img.src = prop['chart.needle.image.url'];img.onload = function () {\n        co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();RG.redraw();\n      };\n    } else if (this.__needle_image__) {\n      co.save();RG.rotateCanvas(ca, this.centerx, this.centery, a);co.drawImage(this.__needle_image__, this.centerx + prop['chart.needle.image.offsetx'], this.centery + prop['chart.needle.image.offsety']);co.restore();\n    }\n    var needleRadius = typeof prop['chart.needle.radius'] == 'number' ? prop['chart.needle.radius'] : this.radius * 0.7;co.fillStyle = 'black';co.lineWidth = this.radius >= 200 ? 7 : 3;co.lineCap = 'round';co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];co.arc(this.centerx, this.centery, needleRadius, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();if (prop['chart.needle.head']) {\n      co.fillStyle = prop['chart.needle.color'];co.beginPath();co.lineWidth = 1;co.arc(this.centerx, this.centery, needleRadius + 15, a, a + 0.001, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a + 0.087, a + 0.087999, 0);co.arc(this.centerx, this.centery, needleRadius - 15, a - 0.087, a - 0.087999, 1);co.fill();\n    }\n    if (prop['chart.needle.tail']) {\n      co.beginPath();co.strokeStyle = prop['chart.needle.color'];if (typeof prop['chart.needle.linewidth'] == 'number') co.lineWidth = prop['chart.needle.linewidth'];var a = (this.value - this.min) / (this.max - this.min) * (this.properties['chart.angles.end'] - this.properties['chart.angles.start']) + this.properties['chart.angles.start'] + RG.PI;co.arc(this.centerx, this.centery, 25, a, a + 0.001, false);co.lineTo(this.centerx, this.centery);co.stroke();\n    }\n    var r = this.radius * 0.06 > 40 ? 40 : this.radius * 0.06;co.beginPath();co.fillStyle = prop['chart.centerpin.stroke'];co.arc(this.centerx, this.centery, r, 0 + 0.001, RG.TWOPI, 0);co.fill();co.fillStyle = prop['chart.centerpin.fill'];co.beginPath();co.arc(this.centerx, this.centery, r - 2, 0 + 0.001, RG.TWOPI, 0);co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!prop['chart.labels']) {\n      return;\n    }\n    var radius = this.radius,\n        text_size = prop['chart.text.size'],\n        text_font = prop['chart.text.font'],\n        units_post = prop['chart.units.post'],\n        units_pre = prop['chart.units.pre'],\n        centerx = this.centerx,\n        centery = this.centery,\n        min = this.min,\n        max = this.max,\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        specific = prop['chart.labels.specific'];\n    if (specific) {\n      for (var i = 0; i < specific.length; ++i) {\n        var angle = this.getAngle(specific[i][1]),\n            angle_degrees = angle * (180 / RG.PI),\n            text = specific[i][0].toString(),\n            coords = RG.getRadiusEndPoint(this.centerx, this.centery, angle, this.radius * 0.925);\n        RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': text, 'halign': 'center', 'valign': 'center', 'angle': angle_degrees + 90, 'bounding': false, 'tag': 'labels-specific', color: 'black' });\n      }\n      return;\n    }\n    co.fillStyle = prop['chart.text.color'];co.lineWidth = 1;co.beginPath();for (var i = 0; i <= numLabels; ++i) {\n      var angle = (prop['chart.angles.end'] - prop['chart.angles.start']) * (i / numLabels) + prop['chart.angles.start'];var coords = RG.getRadiusEndPoint(centerx, centery, angle + ((i == 0 || i == numLabels) && prop['chart.border'] ? i == 0 ? 0.05 : -0.05 : 0), this.radius * 0.925 - (prop['chart.text.valign'] === 'bottom' ? 15 : 0));var angleStart = prop['chart.angles.start'],\n          angleEnd = prop['chart.angles.end'],\n          angleRange = angleEnd - angleStart,\n          angleStart_degrees = angleStart * (180 / RG.PI),\n          angleEnd_degrees = angleEnd * (180 / RG.PI),\n          angleRange_degrees = angleRange * (180 / RG.PI);\n      valign = prop['chart.text.valign'];if (prop['chart.border']) {\n        if (i == 0) {\n          halign = 'left';\n        } else if (i == numLabels) {\n          halign = 'right';\n        } else {\n          halign = 'center';\n        }\n      } else {\n        halign = 'center';\n      }\n      var value = (this.max - this.min) * (i / numLabels) + this.min;RG.text2(this, { 'font': text_font, 'size': text_size, 'x': coords[0], 'y': coords[1], 'text': RG.numberFormat(this, value.toFixed(value === 0 ? 0 : decimals), units_pre, units_post), 'halign': halign, 'valign': valign, 'angle': angleRange_degrees * (1 / numLabels) * i + angleStart_degrees - 270, 'bounding': false, 'boundingFill': i == 0 || i == numLabels ? 'white' : null, 'tag': 'scale' });\n    }\n  };this.drawReadout = this.DrawReadout = function () {\n    if (prop['chart.value.text']) {\n      co.beginPath();co.fillStyle = prop['chart.text.color'];RG.Text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': this.centerx, 'y': this.centery - prop['chart.text.size'] - 15, 'text': prop['chart.value.text.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.text.units.post'], 'halign': 'center', 'valign': 'bottom', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });co.stroke();co.fill();\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (radius > this.radius) {\n      return null;\n    }\n    if (angle < RG.HALFPI) {\n      angle += RG.TWOPI;\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = Math.max(value, this.min);value = Math.min(value, this.max);return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(this.canvas);RG.redrawCanvas(this.canvas);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * (prop['chart.angles.end'] - prop['chart.angles.start']) + prop['chart.angles.start'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);var ranges = prop['chart.colors.ranges'];if (ranges && ranges.length) {\n      for (var i = 0; i < ranges.length; ++i) {\n        ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2]);\n      }\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, prop['chart.segment.radius.start'], this.centerx, this.centery, this.radius * 0.85);var diff = 1 / (parts.length - 1);for (var j = 0; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;obj.currentValue = obj.currentValue || obj.min;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var diff = obj.value - obj.currentValue;var step = diff / frames;var callback = arguments[1] || function () {};var initial = obj.currentValue;function iterator() {\n      obj.value = initial + frame++ * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame <= frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5tZXRlci5qcz9jNjU0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLk1ldGVyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZDtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW4gPSBjb25mLm1pbjt2YXIgbWF4ID0gY29uZi5tYXg7dmFyIHZhbHVlID0gY29uZi52YWx1ZTt2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkID0gY29uZjt2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO3ZhciBtaW4gPSBhcmd1bWVudHNbMV07dmFyIG1heCA9IGFyZ3VtZW50c1syXTt2YXIgdmFsdWUgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQgPyB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaWQpKSA9PT0gJ29iamVjdCcgJiYgaWQuYWxwaGEgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlIH0pIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnR5cGUgPSAnbWV0ZXInO3RoaXMubWluID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWluKTt0aGlzLm1heCA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1heCk7dGhpcy52YWx1ZSA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmNlbnRlcnggPSBudWxsO3RoaXMuY2VudGVyeSA9IG51bGw7dGhpcy5yYWRpdXMgPSBudWxsO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMuY3VycmVudFZhbHVlID0gbnVsbDt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnVybCc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLm9mZnNldHgnOiAwLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5vZmZzZXR5JzogMCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzogJ3doaXRlJywgJ2NoYXJ0Lmd1dHRlci5sZWZ0JzogMTUsICdjaGFydC5ndXR0ZXIucmlnaHQnOiAxNSwgJ2NoYXJ0Lmd1dHRlci50b3AnOiAxNSwgJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOiAyMCwgJ2NoYXJ0LmxpbmV3aWR0aCc6IDEsICdjaGFydC5saW5ld2lkdGguc2VnbWVudHMnOiAwLCAnY2hhcnQuc3Ryb2tlc3R5bGUnOiBudWxsLCAnY2hhcnQuYm9yZGVyJzogdHJ1ZSwgJ2NoYXJ0LmJvcmRlci5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LnZhbGlnbic6ICdjZW50ZXInLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogZmFsc2UsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC52YWx1ZS50ZXh0LmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnZhbHVlLnRleHQudW5pdHMucHJlJzogJycsICdjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnRpdGxlJzogJycsICdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUudnBvcyc6IG51bGwsICdjaGFydC50aXRsZS5jb2xvcic6ICdibGFjaycsICdjaGFydC50aXRsZS5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhhbGlnbic6IG51bGwsICdjaGFydC50aXRsZS52YWxpZ24nOiBudWxsLCAnY2hhcnQuZ3JlZW4uc3RhcnQnOiAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAwLjM1ICsgdGhpcy5taW4sICdjaGFydC5ncmVlbi5lbmQnOiB0aGlzLm1heCwgJ2NoYXJ0LmdyZWVuLmNvbG9yJzogJyMyMDdBMjAnLCAnY2hhcnQueWVsbG93LnN0YXJ0JzogKHRoaXMubWF4IC0gdGhpcy5taW4pICogMC4xICsgdGhpcy5taW4sICdjaGFydC55ZWxsb3cuZW5kJzogKHRoaXMubWF4IC0gdGhpcy5taW4pICogMC4zNSArIHRoaXMubWluLCAnY2hhcnQueWVsbG93LmNvbG9yJzogJyNEMEFDNDEnLCAnY2hhcnQucmVkLnN0YXJ0JzogdGhpcy5taW4sICdjaGFydC5yZWQuZW5kJzogKHRoaXMubWF4IC0gdGhpcy5taW4pICogMC4xICsgdGhpcy5taW4sICdjaGFydC5yZWQuY29sb3InOiAnIzlFMUUxRScsICdjaGFydC5jb2xvcnMucmFuZ2VzJzogbnVsbCwgJ2NoYXJ0LnVuaXRzLnByZSc6ICcnLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQuem9vbS5hY3Rpb24nOiAnem9vbScsICdjaGFydC5hbm5vdGF0YWJsZSc6IGZhbHNlLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuc2hhZG93JzogZmFsc2UsICdjaGFydC5zaGFkb3cuY29sb3InOiAncmdiYSgwLDAsMCwwLjUpJywgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogMywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMywgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMywgJ2NoYXJ0LnJlc2l6YWJsZSc6IGZhbHNlLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOiBbMCwgMF0sICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGlja21hcmtzLnNtYWxsLm51bSc6IDEwMCwgJ2NoYXJ0LnRpY2ttYXJrcy5iaWcubnVtJzogMTAsICdjaGFydC50aWNrbWFya3Muc21hbGwuY29sb3InOiAnI2JiYicsICdjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnNjYWxlLnBvaW50JzogJy4nLCAnY2hhcnQuc2NhbGUudGhvdXNhbmQnOiAnLCcsICdjaGFydC5yYWRpdXMnOiBudWxsLCAnY2hhcnQuY2VudGVyeCc6IG51bGwsICdjaGFydC5jZW50ZXJ5JzogbnVsbCwgJ2NoYXJ0LmxhYmVscyc6IHRydWUsICdjaGFydC5sYWJlbHMuY291bnQnOiAxMCwgJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyc6IG51bGwsICdjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCc6IDAsICdjaGFydC5uZWVkbGUucmFkaXVzJzogbnVsbCwgJ2NoYXJ0Lm5lZWRsZS50YWlsJzogZmFsc2UsICdjaGFydC5uZWVkbGUuaGVhZCc6IHRydWUsICdjaGFydC5uZWVkbGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQubmVlZGxlLmltYWdlLnVybCc6IG51bGwsICdjaGFydC5uZWVkbGUuaW1hZ2Uub2Zmc2V0eCc6IDAsICdjaGFydC5uZWVkbGUuaW1hZ2Uub2Zmc2V0eSc6IDAsICdjaGFydC5hZGp1c3RhYmxlJzogZmFsc2UsICdjaGFydC5hbmdsZXMuc3RhcnQnOiBSR3JhcGguUEksICdjaGFydC5hbmdsZXMuZW5kJzogUkdyYXBoLlRXT1BJLCAnY2hhcnQuY2VudGVycGluLnN0cm9rZSc6ICdibGFjaycsICdjaGFydC5jZW50ZXJwaW4uZmlsbCc6ICd3aGl0ZScsICdjaGFydC5jbGVhcnRvJzogJ3JnYmEoMCwwLDAsMCknIH07XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW01FVEVSXSBObyBjYW52YXMgc3VwcG9ydCcpO3JldHVybjtcbiAgfVxuICBpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzFdIHx8IG51bGw7aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC52YWx1ZScpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtyZXR1cm47XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC52YWx1ZScpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAodGhpcy52YWx1ZSA+IHRoaXMubWF4KSB0aGlzLnZhbHVlID0gdGhpcy5tYXg7aWYgKHRoaXMudmFsdWUgPCB0aGlzLm1pbikgdGhpcy52YWx1ZSA9IHRoaXMubWluO3RoaXMuY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTt0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLmNlbnRlcnggPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDIgKyB0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b207dGhpcy5yYWRpdXMgPSBNYXRoLm1pbigoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDIsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pO3RoaXMuY29vcmRzVGV4dCA9IFtdO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeCddID09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT0gJ251bWJlcicpIHRoaXMuY2VudGVyeSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTt0aGlzLmRyYXdMYWJlbHMoKTt0aGlzLmRyYXdOZWVkbGUoKTt0aGlzLmRyYXdSZWFkb3V0KCk7UkcuRHJhd1RpdGxlKHRoaXMsIHByb3BbJ2NoYXJ0LnRpdGxlJ10sIHRoaXMuZ3V0dGVyVG9wLCBudWxsLCBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gPyBwcm9wWydjaGFydC50aXRsZS5zaXplJ10gOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSArIDIpO2lmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3QmFja2dyb3VuZCA9IHRoaXMuRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnVybCddID09PSAnc3RyaW5nJyAmJiAhdGhpcy5fX2JhY2tncm91bmRfaW1hZ2VfXykge1xuICAgICAgdmFyIHggPSAwICsgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5vZmZzZXR4J107dmFyIHkgPSAwICsgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5vZmZzZXR5J107dmFyIGltZyA9IG5ldyBJbWFnZSgpO3RoaXMuX19iYWNrZ3JvdW5kX2ltYWdlX18gPSBpbWc7aW1nLnNyYyA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UudXJsJ107aW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2Uuc3RyZXRjaCddKSB7XG4gICAgICAgICAgY28uZHJhd0ltYWdlKHRoaXMsIHgsIHksIGNhLndpZHRoLCBjYS5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLmRyYXdJbWFnZSh0aGlzLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBSRy5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9fYmFja2dyb3VuZF9pbWFnZV9fKSB7XG4gICAgICB2YXIgeCA9IDAgKyBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLm9mZnNldHgnXTt2YXIgeSA9IDAgKyBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlLm9mZnNldHknXTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5zdHJldGNoJ10pIHtcbiAgICAgICAgY28uZHJhd0ltYWdlKHRoaXMuX19iYWNrZ3JvdW5kX2ltYWdlX18sIHgsIHksIGNhLndpZHRoLCBjYS5oZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28uZHJhd0ltYWdlKHRoaXMuX19iYWNrZ3JvdW5kX2ltYWdlX18sIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBSRy5TZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO1xuICAgIH1cbiAgICBjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCBwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10sIGZhbHNlKTtjby5maWxsKCk7UkcuTm9TaGFkb3codGhpcyk7aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTt2YXIgciA9IHRoaXMucmFkaXVzICogMC4wNiA+IDQwID8gNDAgOiB0aGlzLnJhZGl1cyAqIDAuMDY7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCByLCAwLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudGlja21hcmtzLnNtYWxsLm51bSddKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddOyBpICs9IFJHLlBJIC8gcHJvcFsnY2hhcnQudGlja21hcmtzLnNtYWxsLm51bSddKSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQudGlja21hcmtzLnNtYWxsLmNvbG9yJ107Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gKyBpLCBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSArIGkgKyAwLjAwMDAxLCAwKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNSwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gKyBpLCBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSArIGkgKyAwLjAwMDAxLCAwKTtjby5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNCwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSwgZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcubnVtJ10pIHtcbiAgICAgIHZhciBjb2xvcnMgPSBbJ3doaXRlJywgJ3doaXRlJywgcHJvcFsnY2hhcnQudGlja21hcmtzLmJpZy5jb2xvciddXTtmb3IgKHZhciBqID0gMDsgaiA8IGNvbG9ycy5sZW5ndGg7ICsraikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddOyBpICs9IChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgLyBwcm9wWydjaGFydC50aWNrbWFya3MuYmlnLm51bSddKSB7XG4gICAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcnNbal07Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gKyBpLCBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSArIGkgKyAwLjAwMSwgMCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDUsIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddICsgaSwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gKyBpICsgMC4wMDAxLCAwKTtjby5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28ubW92ZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNywgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSwgZmFsc2UpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTt2YXIgcmFuZ2VzID0gcHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddO2lmIChSRy5pc19hcnJheShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gcHJvcFsnY2hhcnQuY29sb3JzLnJhbmdlcyddO2ZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA/IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gOiByYW5nZXNbaV1bMl07Y28uZmlsbFN0eWxlID0gcmFuZ2VzW2ldWzJdO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyddO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgKiAwLjg1LCAocmFuZ2VzW2ldWzBdIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCAocmFuZ2VzW2ldWzFdIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCBmYWxzZSk7aWYgKHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10gPiAwKSB7XG4gICAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddLCAocmFuZ2VzW2ldWzFdIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCAocmFuZ2VzW2ldWzBdIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGNvLmJlZ2luUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPyBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddIDogcHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5ncmVlbi5jb2xvciddO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyddO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgKiAwLjg1LCAocHJvcFsnY2hhcnQuZ3JlZW4uc3RhcnQnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSB0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCAocHJvcFsnY2hhcnQuZ3JlZW4uZW5kJ10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIGZhbHNlKTtpZiAocHJvcFsnY2hhcnQuc2VnbWVudC5yYWRpdXMuc3RhcnQnXSA+IDApIHtcbiAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddLCAocHJvcFsnY2hhcnQuZ3JlZW4uZW5kJ10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIChwcm9wWydjaGFydC5ncmVlbi5zdGFydCddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7XG4gICAgICB9XG4gICAgICBjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddID8gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA6IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aC5zZWdtZW50cyddO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgKiAwLjg1LCAocHJvcFsnY2hhcnQueWVsbG93LnN0YXJ0J10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIChwcm9wWydjaGFydC55ZWxsb3cuZW5kJ10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIGZhbHNlKTtpZiAocHJvcFsnY2hhcnQuc2VnbWVudC5yYWRpdXMuc3RhcnQnXSA+IDApIHtcbiAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddLCAocHJvcFsnY2hhcnQueWVsbG93LmVuZCddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCAocHJvcFsnY2hhcnQueWVsbG93LnN0YXJ0J10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtcbiAgICAgIH1cbiAgICAgIGNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPyBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddIDogcHJvcFsnY2hhcnQucmVkLmNvbG9yJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQucmVkLmNvbG9yJ107Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoLnNlZ21lbnRzJ107Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAqIDAuODUsIChwcm9wWydjaGFydC5yZWQuc3RhcnQnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgKyBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSwgKHByb3BbJ2NoYXJ0LnJlZC5lbmQnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgKyBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSwgZmFsc2UpO2lmIChwcm9wWydjaGFydC5zZWdtZW50LnJhZGl1cy5zdGFydCddID4gMCkge1xuICAgICAgICBjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10sIChwcm9wWydjaGFydC5yZWQuZW5kJ10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIChwcm9wWydjaGFydC5yZWQuc3RhcnQnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgKyBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO1xuICAgICAgfVxuICAgICAgY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmxpbmVXaWR0aCA9IDE7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5ib3JkZXIuY29sb3InXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLCBwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10sIGZhbHNlKTtjby5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gMTtcbiAgfTt0aGlzLmRyYXdOZWVkbGUgPSB0aGlzLkRyYXdOZWVkbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSAodGhpcy52YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgKyBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0Lm5lZWRsZS5pbWFnZS51cmwnXSA9PT0gJ3N0cmluZycgJiYgIXRoaXMuX19uZWVkbGVfaW1hZ2VfXykge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO3RoaXMuX19uZWVkbGVfaW1hZ2VfXyA9IGltZztpbWcuc3JjID0gcHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLnVybCddO2ltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvLnNhdmUoKTtSRy5yb3RhdGVDYW52YXMoY2EsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBhKTtjby5kcmF3SW1hZ2UodGhpcywgdGhpcy5jZW50ZXJ4ICsgcHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLm9mZnNldHgnXSwgdGhpcy5jZW50ZXJ5ICsgcHJvcFsnY2hhcnQubmVlZGxlLmltYWdlLm9mZnNldHknXSk7Y28ucmVzdG9yZSgpO1JHLnJlZHJhdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19uZWVkbGVfaW1hZ2VfXykge1xuICAgICAgY28uc2F2ZSgpO1JHLnJvdGF0ZUNhbnZhcyhjYSwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIGEpO2NvLmRyYXdJbWFnZSh0aGlzLl9fbmVlZGxlX2ltYWdlX18sIHRoaXMuY2VudGVyeCArIHByb3BbJ2NoYXJ0Lm5lZWRsZS5pbWFnZS5vZmZzZXR4J10sIHRoaXMuY2VudGVyeSArIHByb3BbJ2NoYXJ0Lm5lZWRsZS5pbWFnZS5vZmZzZXR5J10pO2NvLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdmFyIG5lZWRsZVJhZGl1cyA9IHR5cGVvZiBwcm9wWydjaGFydC5uZWVkbGUucmFkaXVzJ10gPT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5uZWVkbGUucmFkaXVzJ10gOiB0aGlzLnJhZGl1cyAqIDAuNztjby5maWxsU3R5bGUgPSAnYmxhY2snO2NvLmxpbmVXaWR0aCA9IHRoaXMucmFkaXVzID49IDIwMCA/IDcgOiAzO2NvLmxpbmVDYXAgPSAncm91bmQnO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5uZWVkbGUubGluZXdpZHRoJ10gPT0gJ251bWJlcicpIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0Lm5lZWRsZS5saW5ld2lkdGgnXTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG5lZWRsZVJhZGl1cywgYSwgYSArIDAuMDAxLCBmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTtpZiAocHJvcFsnY2hhcnQubmVlZGxlLmhlYWQnXSkge1xuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gMTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG5lZWRsZVJhZGl1cyArIDE1LCBhLCBhICsgMC4wMDEsIDApO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbmVlZGxlUmFkaXVzIC0gMTUsIGEgKyAwLjA4NywgYSArIDAuMDg3OTk5LCAwKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG5lZWRsZVJhZGl1cyAtIDE1LCBhIC0gMC4wODcsIGEgLSAwLjA4Nzk5OSwgMSk7Y28uZmlsbCgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubmVlZGxlLnRhaWwnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5uZWVkbGUuY29sb3InXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0Lm5lZWRsZS5saW5ld2lkdGgnXSA9PSAnbnVtYmVyJykgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubmVlZGxlLmxpbmV3aWR0aCddO3ZhciBhID0gKHRoaXMudmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAodGhpcy5wcm9wZXJ0aWVzWydjaGFydC5hbmdsZXMuZW5kJ10gLSB0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSArIHRoaXMucHJvcGVydGllc1snY2hhcnQuYW5nbGVzLnN0YXJ0J10gKyBSRy5QSTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIDI1LCBhLCBhICsgMC4wMDEsIGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgICB2YXIgciA9IHRoaXMucmFkaXVzICogMC4wNiA+IDQwID8gNDAgOiB0aGlzLnJhZGl1cyAqIDAuMDY7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY2VudGVycGluLnN0cm9rZSddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgciwgMCArIDAuMDAxLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJ107Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCByIC0gMiwgMCArIDAuMDAxLCBSRy5UV09QSSwgMCk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXByb3BbJ2NoYXJ0LmxhYmVscyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgdGV4dF9zaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIHRleHRfZm9udCA9IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLFxuICAgICAgICB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddLFxuICAgICAgICB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSxcbiAgICAgICAgY2VudGVyeCA9IHRoaXMuY2VudGVyeCxcbiAgICAgICAgY2VudGVyeSA9IHRoaXMuY2VudGVyeSxcbiAgICAgICAgbWluID0gdGhpcy5taW4sXG4gICAgICAgIG1heCA9IHRoaXMubWF4LFxuICAgICAgICBkZWNpbWFscyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sXG4gICAgICAgIG51bUxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddLFxuICAgICAgICBzcGVjaWZpYyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddO1xuICAgIGlmIChzcGVjaWZpYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpYy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmdldEFuZ2xlKHNwZWNpZmljW2ldWzFdKSxcbiAgICAgICAgICAgIGFuZ2xlX2RlZ3JlZXMgPSBhbmdsZSAqICgxODAgLyBSRy5QSSksXG4gICAgICAgICAgICB0ZXh0ID0gc3BlY2lmaWNbaV1bMF0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGNvb3JkcyA9IFJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBhbmdsZSwgdGhpcy5yYWRpdXMgKiAwLjkyNSk7XG4gICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiB0ZXh0X2ZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IGNvb3Jkc1swXSwgJ3knOiBjb29yZHNbMV0sICd0ZXh0JzogdGV4dCwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2NlbnRlcicsICdhbmdsZSc6IGFuZ2xlX2RlZ3JlZXMgKyA5MCwgJ2JvdW5kaW5nJzogZmFsc2UsICd0YWcnOiAnbGFiZWxzLXNwZWNpZmljJywgY29sb3I6ICdibGFjaycgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5saW5lV2lkdGggPSAxO2NvLmJlZ2luUGF0aCgpO2ZvciAodmFyIGkgPSAwOyBpIDw9IG51bUxhYmVsczsgKytpKSB7XG4gICAgICB2YXIgYW5nbGUgPSAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICogKGkgLyBudW1MYWJlbHMpICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J107dmFyIGNvb3JkcyA9IFJHLmdldFJhZGl1c0VuZFBvaW50KGNlbnRlcngsIGNlbnRlcnksIGFuZ2xlICsgKChpID09IDAgfHwgaSA9PSBudW1MYWJlbHMpICYmIHByb3BbJ2NoYXJ0LmJvcmRlciddID8gaSA9PSAwID8gMC4wNSA6IC0wLjA1IDogMCksIHRoaXMucmFkaXVzICogMC45MjUgLSAocHJvcFsnY2hhcnQudGV4dC52YWxpZ24nXSA9PT0gJ2JvdHRvbScgPyAxNSA6IDApKTt2YXIgYW5nbGVTdGFydCA9IHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddLFxuICAgICAgICAgIGFuZ2xlRW5kID0gcHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddLFxuICAgICAgICAgIGFuZ2xlUmFuZ2UgPSBhbmdsZUVuZCAtIGFuZ2xlU3RhcnQsXG4gICAgICAgICAgYW5nbGVTdGFydF9kZWdyZWVzID0gYW5nbGVTdGFydCAqICgxODAgLyBSRy5QSSksXG4gICAgICAgICAgYW5nbGVFbmRfZGVncmVlcyA9IGFuZ2xlRW5kICogKDE4MCAvIFJHLlBJKSxcbiAgICAgICAgICBhbmdsZVJhbmdlX2RlZ3JlZXMgPSBhbmdsZVJhbmdlICogKDE4MCAvIFJHLlBJKTtcbiAgICAgIHZhbGlnbiA9IHByb3BbJ2NoYXJ0LnRleHQudmFsaWduJ107aWYgKHByb3BbJ2NoYXJ0LmJvcmRlciddKSB7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICBoYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PSBudW1MYWJlbHMpIHtcbiAgICAgICAgICBoYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLm1heCAtIHRoaXMubWluKSAqIChpIC8gbnVtTGFiZWxzKSArIHRoaXMubWluO1JHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiB0ZXh0X2ZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IGNvb3Jkc1swXSwgJ3knOiBjb29yZHNbMV0sICd0ZXh0JzogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHZhbHVlLnRvRml4ZWQodmFsdWUgPT09IDAgPyAwIDogZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAnaGFsaWduJzogaGFsaWduLCAndmFsaWduJzogdmFsaWduLCAnYW5nbGUnOiBhbmdsZVJhbmdlX2RlZ3JlZXMgKiAoMSAvIG51bUxhYmVscykgKiBpICsgYW5nbGVTdGFydF9kZWdyZWVzIC0gMjcwLCAnYm91bmRpbmcnOiBmYWxzZSwgJ2JvdW5kaW5nRmlsbCc6IGkgPT0gMCB8fCBpID09IG51bUxhYmVscyA/ICd3aGl0ZScgOiBudWxsLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICB9XG4gIH07dGhpcy5kcmF3UmVhZG91dCA9IHRoaXMuRHJhd1JlYWRvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSwgJ3NpemUnOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgJ3gnOiB0aGlzLmNlbnRlcngsICd5JzogdGhpcy5jZW50ZXJ5IC0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gLSAxNSwgJ3RleHQnOiBwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnByZSddICsgdGhpcy52YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuZGVjaW1hbHMnXSkgKyBwcm9wWydjaGFydC52YWx1ZS50ZXh0LnVuaXRzLnBvc3QnXSwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2JvdHRvbScsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGFnJzogJ3ZhbHVlLnRleHQnIH0pO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IGZ1bmN0aW9uIChlKSB7fTt0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIGFuZ2xlID0gUkcuZ2V0QW5nbGVCeVhZKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKTt2YXIgcmFkaXVzID0gUkcuZ2V0SHlwTGVuZ3RoKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBtb3VzZVhZWzBdLCBtb3VzZVhZWzFdKTtpZiAocmFkaXVzID4gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoYW5nbGUgPCBSRy5IQUxGUEkpIHtcbiAgICAgIGFuZ2xlICs9IFJHLlRXT1BJO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSAoYW5nbGUgLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgLyAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICogKHRoaXMubWF4IC0gdGhpcy5taW4pICsgdGhpcy5taW47dmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5taW4pO3ZhbHVlID0gTWF0aC5taW4odmFsdWUsIHRoaXMubWF4KTtyZXR1cm4gdmFsdWU7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHcmFwaC5nZXRNb3VzZVhZKGUpO3ZhciByYWRpdXMgPSBSRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG1vdXNlWFlbMF0sIG1vdXNlWFlbMV0pO2lmIChtb3VzZVhZWzBdID4gdGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMgJiYgbW91c2VYWVswXSA8IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzICYmIG1vdXNlWFlbMV0gPiB0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzFdIDwgdGhpcy5jZW50ZXJ5ICsgdGhpcy5yYWRpdXMgJiYgcmFkaXVzIDw9IHRoaXMucmFkaXVzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlID0gdGhpcy5BZGp1c3RpbmdfbW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddICYmIFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykgJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQgPT0gdGhpcy51aWQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKGUpO1JHLmNsZWFyKHRoaXMuY2FudmFzKTtSRy5yZWRyYXdDYW52YXModGhpcy5jYW52YXMpO1JHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25hZGp1c3QnKTtcbiAgICB9XG4gIH07dGhpcy5nZXRBbmdsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA+IHRoaXMubWF4IHx8IHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYW5nbGUgPSAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pICsgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J107cmV0dXJuIGFuZ2xlO1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQueWVsbG93LmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnJlZC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQucmVkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMucmFuZ2VzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMucmFuZ2VzJ10pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC5ncmVlbi5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuZ3JlZW4uY29sb3InXSk7cHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSk7cHJvcFsnY2hhcnQucmVkLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5yZWQuY29sb3InXSk7dmFyIHJhbmdlcyA9IHByb3BbJ2NoYXJ0LmNvbG9ycy5yYW5nZXMnXTtpZiAocmFuZ2VzICYmIHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJhbmdlc1tpXVsyXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHJhbmdlc1tpXVsyXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHByb3BbJ2NoYXJ0LnNlZ21lbnQucmFkaXVzLnN0YXJ0J10sIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAqIDAuODUpO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXM7b2JqLmN1cnJlbnRWYWx1ZSA9IG9iai5jdXJyZW50VmFsdWUgfHwgb2JqLm1pbjt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIGRpZmYgPSBvYmoudmFsdWUgLSBvYmouY3VycmVudFZhbHVlO3ZhciBzdGVwID0gZGlmZiAvIGZyYW1lczt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307dmFyIGluaXRpYWwgPSBvYmouY3VycmVudFZhbHVlO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgb2JqLnZhbHVlID0gaW5pdGlhbCArIGZyYW1lKysgKiBzdGVwO1JHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoZnJhbWUgPD0gZnJhbWVzKSB7XG4gICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuYXR0KGNhKTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubWV0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///195\n")},function(module,exports){eval("\nModalDialog = { dialog: null, background: null, offset: 50, events: [], Show: function Show(id, width) {\n    ModalDialog.id = id;ModalDialog.width = width;ModalDialog.ShowBackground();ModalDialog.ShowDialog();window.onresize = ModalDialog.Resize;document.body.addEventListener('keydown', function (e) {\n      if (e.keyCode === 27) {\n        ModalDialog.hide();\n      }\n    }, false);ModalDialog.Resize();if (typeof ModalDialog.onmodaldialog == 'function') {\n      ModalDialog.onmodaldialog();\n    }\n    ModalDialog.FireCustomEvent('onmodaldialog');\n  }, ShowBackground: function ShowBackground() {\n    ModalDialog.background = document.createElement('DIV');ModalDialog.background.className = 'ModalDialog_background';ModalDialog.background.style.position = 'fixed';ModalDialog.background.style.top = 0;ModalDialog.background.style.left = 0;ModalDialog.background.style.width = screen.width + 100 + 'px';ModalDialog.background.style.height = screen.height + 100 + 'px';ModalDialog.background.style.backgroundColor = 'rgb(204,204,204)';ModalDialog.background.style.opacity = 0;ModalDialog.background.style.zIndex = 3276;ModalDialog.background.style.filter = \"Alpha(opacity=50)\";document.body.appendChild(ModalDialog.background);ModalDialog.background.style.visibility = 'visible';\n  }, ShowDialog: function ShowDialog() {\n    if (!ModalDialog.dialog || true) {\n      ModalDialog.dialog = document.createElement('DIV');ModalDialog.dialog.id = 'ModalDialog_dialog';ModalDialog.dialog.className = 'ModalDialog_dialog';var borderRadius = '15px';ModalDialog.dialog.style.borderRadius = borderRadius;ModalDialog.dialog.style.MozBorderRadius = borderRadius;ModalDialog.dialog.style.WebkitBorderRadius = borderRadius;ModalDialog.dialog.style.boxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.MozBoxShadow = '3px 3px 3px rgba(96,96,96,0.5)';ModalDialog.dialog.style.WebkitBoxShadow = 'rgba(96,96,96,0.5) 3px 3px 3px';ModalDialog.dialog.style.position = 'fixed';ModalDialog.dialog.style.backgroundColor = 'white';ModalDialog.dialog.style.width = parseInt(ModalDialog.width) + 'px';ModalDialog.dialog.style.border = '2px solid #999';ModalDialog.dialog.style.zIndex = 32767;ModalDialog.dialog.style.padding = '5px';ModalDialog.dialog.style.paddingTop = '25px';ModalDialog.dialog.style.opacity = 0;if (document.all) {\n        ModalDialog.dialog.style.zIndex = 32767;\n      }\n      if (navigator.userAgent.indexOf('Opera') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('MSIE') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      } else if (navigator.userAgent.indexOf('Safari') != -1) {\n        ModalDialog.dialog.style.paddingTop = '25px';\n      }\n      document.body.appendChild(ModalDialog.dialog);var bar = document.createElement('DIV');bar.className = 'ModalDialog_topbar';bar.style.top = 0;bar.style.left = 0;bar.style.width = '100%';bar.style.height = '20px';bar.style.backgroundColor = '#bbb';bar.style.borderBottom = '2px solid #999';bar.style.position = 'absolute';var borderRadius = '11px';bar.style.WebkitBorderTopLeftRadius = borderRadius;bar.style.WebkitBorderTopRightRadius = borderRadius;bar.style.MozBorderRadiusTopleft = borderRadius;bar.style.MozBorderRadiusTopright = borderRadius;bar.style.borderTopRightRadius = borderRadius;bar.style.borderTopLeftRadius = borderRadius;ModalDialog.dialog.appendChild(bar);var content = document.createElement('DIV');content.style.width = '100%';content.style.height = '100%';ModalDialog.dialog.appendChild(content);if (ModalDialog.id.toLowerCase().substring(0, 7) == 'string:') {\n        content.innerHTML = ModalDialog.id.substring(7);\n      } else {\n        content.innerHTML = document.getElementById(ModalDialog.id).innerHTML;\n      }\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';ModalDialog.dialog.style.top = '30%';\n    }\n    ModalDialog.dialog.style.visibility = 'visible';setTimeout('ModalDialog.dialog.style.opacity = 0.2', 50);setTimeout('ModalDialog.dialog.style.opacity = 0.4', 100);setTimeout('ModalDialog.dialog.style.opacity = 0.6', 150);setTimeout('ModalDialog.dialog.style.opacity = 0.8', 200);setTimeout('ModalDialog.dialog.style.opacity = 1', 250);setTimeout('ModalDialog.background.style.opacity = 0.1', 50);setTimeout('ModalDialog.background.style.opacity = 0.2', 100);setTimeout('ModalDialog.background.style.opacity = 0.3', 150);setTimeout('ModalDialog.background.style.opacity = 0.4', 200);setTimeout('ModalDialog.background.style.opacity = 0.5', 250);\n  }, Close: function Close() {\n    if (ModalDialog.dialog) {\n      if (document.getElementById(ModalDialog.dialog.id)) {\n        document.body.removeChild(ModalDialog.dialog);\n      }\n      ModalDialog.dialog.style.visibility = 'hidden';ModalDialog.dialog.style.opacity = 0;\n    }\n    if (ModalDialog.background) {\n      ModalDialog.background.style.visibility = 'hidden';ModalDialog.background.style.opacity = 0;if (document.getElementById(ModalDialog.background.id)) {\n        document.body.removeChild(ModalDialog.background);\n      }\n    }\n  }, Resize: function Resize() {\n    if (ModalDialog.dialog) {\n      ModalDialog.dialog.style.left = document.body.offsetWidth / 2 - ModalDialog.dialog.offsetWidth / 2 + 'px';\n    }\n    ModalDialog.background.style.width = '2500px';ModalDialog.background.style.height = '2500px';\n  }, AddCustomEventListener: function AddCustomEventListener(name, func) {\n    if (typeof ModalDialog.events == 'undefined') {\n      ModalDialog.events = [];\n    }\n    ModalDialog.events.push([name, func]);\n  }, FireCustomEvent: function FireCustomEvent(name) {\n    for (var i = 0; i < ModalDialog.events.length; ++i) {\n      if (typeof ModalDialog.events[i][0] == 'string' && ModalDialog.events[i][0] == name && typeof ModalDialog.events[i][1] == 'function') {\n        ModalDialog.events[i][1]();\n      }\n    }\n  }, isIE8: function isIE8() {\n    return document.all && navigator.userAgent.indexOf('MSIE 8') > 0;\n  } };ModalDialog.show = ModalDialog.Show;ModalDialog.draw = ModalDialog.Show;ModalDialog.Hide = ModalDialog.Close;ModalDialog.hide = ModalDialog.Close;ModalDialog.close = ModalDialog.Close;for (i in ModalDialog) {\n  if (typeof ModalDialog[i] === 'function') {\n    ModalDialog[i.toLowerCase()] = ModalDialog[i];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5tb2RhbGRpYWxvZy5qcz9lMzI1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuTW9kYWxEaWFsb2cgPSB7IGRpYWxvZzogbnVsbCwgYmFja2dyb3VuZDogbnVsbCwgb2Zmc2V0OiA1MCwgZXZlbnRzOiBbXSwgU2hvdzogZnVuY3Rpb24gU2hvdyhpZCwgd2lkdGgpIHtcbiAgICBNb2RhbERpYWxvZy5pZCA9IGlkO01vZGFsRGlhbG9nLndpZHRoID0gd2lkdGg7TW9kYWxEaWFsb2cuU2hvd0JhY2tncm91bmQoKTtNb2RhbERpYWxvZy5TaG93RGlhbG9nKCk7d2luZG93Lm9ucmVzaXplID0gTW9kYWxEaWFsb2cuUmVzaXplO2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICBNb2RhbERpYWxvZy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO01vZGFsRGlhbG9nLlJlc2l6ZSgpO2lmICh0eXBlb2YgTW9kYWxEaWFsb2cub25tb2RhbGRpYWxvZyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBNb2RhbERpYWxvZy5vbm1vZGFsZGlhbG9nKCk7XG4gICAgfVxuICAgIE1vZGFsRGlhbG9nLkZpcmVDdXN0b21FdmVudCgnb25tb2RhbGRpYWxvZycpO1xuICB9LCBTaG93QmFja2dyb3VuZDogZnVuY3Rpb24gU2hvd0JhY2tncm91bmQoKSB7XG4gICAgTW9kYWxEaWFsb2cuYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO01vZGFsRGlhbG9nLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ01vZGFsRGlhbG9nX2JhY2tncm91bmQnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUudG9wID0gMDtNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSAwO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUud2lkdGggPSBzY3JlZW4ud2lkdGggKyAxMDAgKyAncHgnO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ID0gc2NyZWVuLmhlaWdodCArIDEwMCArICdweCc7TW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiKDIwNCwyMDQsMjA0KSc7TW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gMDtNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLnpJbmRleCA9IDMyNzY7TW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5maWx0ZXIgPSBcIkFscGhhKG9wYWNpdHk9NTApXCI7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChNb2RhbERpYWxvZy5iYWNrZ3JvdW5kKTtNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gIH0sIFNob3dEaWFsb2c6IGZ1bmN0aW9uIFNob3dEaWFsb2coKSB7XG4gICAgaWYgKCFNb2RhbERpYWxvZy5kaWFsb2cgfHwgdHJ1ZSkge1xuICAgICAgTW9kYWxEaWFsb2cuZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7TW9kYWxEaWFsb2cuZGlhbG9nLmlkID0gJ01vZGFsRGlhbG9nX2RpYWxvZyc7TW9kYWxEaWFsb2cuZGlhbG9nLmNsYXNzTmFtZSA9ICdNb2RhbERpYWxvZ19kaWFsb2cnO3ZhciBib3JkZXJSYWRpdXMgPSAnMTVweCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmJvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUuTW96Qm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5XZWJraXRCb3JkZXJSYWRpdXMgPSBib3JkZXJSYWRpdXM7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLmJveFNoYWRvdyA9ICczcHggM3B4IDNweCByZ2JhKDk2LDk2LDk2LDAuNSknO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5Nb3pCb3hTaGFkb3cgPSAnM3B4IDNweCAzcHggcmdiYSg5Niw5Niw5NiwwLjUpJztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUuV2Via2l0Qm94U2hhZG93ID0gJ3JnYmEoOTYsOTYsOTYsMC41KSAzcHggM3B4IDNweCc7TW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUud2lkdGggPSBwYXJzZUludChNb2RhbERpYWxvZy53aWR0aCkgKyAncHgnO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICM5OTknO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS56SW5kZXggPSAzMjc2NztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUucGFkZGluZyA9ICc1cHgnO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5wYWRkaW5nVG9wID0gJzI1cHgnO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMDtpZiAoZG9jdW1lbnQuYWxsKSB7XG4gICAgICAgIE1vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS56SW5kZXggPSAzMjc2NztcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09wZXJhJykgIT0gLTEpIHtcbiAgICAgICAgTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLnBhZGRpbmdUb3AgPSAnMjVweCc7XG4gICAgICB9IGVsc2UgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9IC0xKSB7XG4gICAgICAgIE1vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5wYWRkaW5nVG9wID0gJzI1cHgnO1xuICAgICAgfSBlbHNlIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpICE9IC0xKSB7XG4gICAgICAgIE1vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5wYWRkaW5nVG9wID0gJzI1cHgnO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChNb2RhbERpYWxvZy5kaWFsb2cpO3ZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtiYXIuY2xhc3NOYW1lID0gJ01vZGFsRGlhbG9nX3RvcGJhcic7YmFyLnN0eWxlLnRvcCA9IDA7YmFyLnN0eWxlLmxlZnQgPSAwO2Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztiYXIuc3R5bGUuaGVpZ2h0ID0gJzIwcHgnO2Jhci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2JiYic7YmFyLnN0eWxlLmJvcmRlckJvdHRvbSA9ICcycHggc29saWQgIzk5OSc7YmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzt2YXIgYm9yZGVyUmFkaXVzID0gJzExcHgnO2Jhci5zdHlsZS5XZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzID0gYm9yZGVyUmFkaXVzO2Jhci5zdHlsZS5XZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1cyA9IGJvcmRlclJhZGl1cztiYXIuc3R5bGUuTW96Qm9yZGVyUmFkaXVzVG9wbGVmdCA9IGJvcmRlclJhZGl1cztiYXIuc3R5bGUuTW96Qm9yZGVyUmFkaXVzVG9wcmlnaHQgPSBib3JkZXJSYWRpdXM7YmFyLnN0eWxlLmJvcmRlclRvcFJpZ2h0UmFkaXVzID0gYm9yZGVyUmFkaXVzO2Jhci5zdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzID0gYm9yZGVyUmFkaXVzO01vZGFsRGlhbG9nLmRpYWxvZy5hcHBlbmRDaGlsZChiYXIpO3ZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7Y29udGVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztjb250ZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztNb2RhbERpYWxvZy5kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGVudCk7aWYgKE1vZGFsRGlhbG9nLmlkLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDcpID09ICdzdHJpbmc6Jykge1xuICAgICAgICBjb250ZW50LmlubmVySFRNTCA9IE1vZGFsRGlhbG9nLmlkLnN1YnN0cmluZyg3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoTW9kYWxEaWFsb2cuaWQpLmlubmVySFRNTDtcbiAgICAgIH1cbiAgICAgIE1vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5sZWZ0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIDIgLSBNb2RhbERpYWxvZy5kaWFsb2cub2Zmc2V0V2lkdGggLyAyICsgJ3B4JztNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUudG9wID0gJzMwJSc7XG4gICAgfVxuICAgIE1vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMC4yJywgNTApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMC40JywgMTAwKTtzZXRUaW1lb3V0KCdNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUub3BhY2l0eSA9IDAuNicsIDE1MCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSAwLjgnLCAyMDApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMScsIDI1MCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gMC4xJywgNTApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDAuMicsIDEwMCk7c2V0VGltZW91dCgnTW9kYWxEaWFsb2cuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gMC4zJywgMTUwKTtzZXRUaW1lb3V0KCdNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSAwLjQnLCAyMDApO3NldFRpbWVvdXQoJ01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDAuNScsIDI1MCk7XG4gIH0sIENsb3NlOiBmdW5jdGlvbiBDbG9zZSgpIHtcbiAgICBpZiAoTW9kYWxEaWFsb2cuZGlhbG9nKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoTW9kYWxEaWFsb2cuZGlhbG9nLmlkKSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKE1vZGFsRGlhbG9nLmRpYWxvZyk7XG4gICAgICB9XG4gICAgICBNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO01vZGFsRGlhbG9nLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICB9XG4gICAgaWYgKE1vZGFsRGlhbG9nLmJhY2tncm91bmQpIHtcbiAgICAgIE1vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO01vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IDA7aWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1vZGFsRGlhbG9nLmJhY2tncm91bmQuaWQpKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoTW9kYWxEaWFsb2cuYmFja2dyb3VuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBSZXNpemU6IGZ1bmN0aW9uIFJlc2l6ZSgpIHtcbiAgICBpZiAoTW9kYWxEaWFsb2cuZGlhbG9nKSB7XG4gICAgICBNb2RhbERpYWxvZy5kaWFsb2cuc3R5bGUubGVmdCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLyAyIC0gTW9kYWxEaWFsb2cuZGlhbG9nLm9mZnNldFdpZHRoIC8gMiArICdweCc7XG4gICAgfVxuICAgIE1vZGFsRGlhbG9nLmJhY2tncm91bmQuc3R5bGUud2lkdGggPSAnMjUwMHB4JztNb2RhbERpYWxvZy5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCA9ICcyNTAwcHgnO1xuICB9LCBBZGRDdXN0b21FdmVudExpc3RlbmVyOiBmdW5jdGlvbiBBZGRDdXN0b21FdmVudExpc3RlbmVyKG5hbWUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZW9mIE1vZGFsRGlhbG9nLmV2ZW50cyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgTW9kYWxEaWFsb2cuZXZlbnRzID0gW107XG4gICAgfVxuICAgIE1vZGFsRGlhbG9nLmV2ZW50cy5wdXNoKFtuYW1lLCBmdW5jXSk7XG4gIH0sIEZpcmVDdXN0b21FdmVudDogZnVuY3Rpb24gRmlyZUN1c3RvbUV2ZW50KG5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1vZGFsRGlhbG9nLmV2ZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiBNb2RhbERpYWxvZy5ldmVudHNbaV1bMF0gPT0gJ3N0cmluZycgJiYgTW9kYWxEaWFsb2cuZXZlbnRzW2ldWzBdID09IG5hbWUgJiYgdHlwZW9mIE1vZGFsRGlhbG9nLmV2ZW50c1tpXVsxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIE1vZGFsRGlhbG9nLmV2ZW50c1tpXVsxXSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgaXNJRTg6IGZ1bmN0aW9uIGlzSUU4KCkge1xuICAgIHJldHVybiBkb2N1bWVudC5hbGwgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDgnKSA+IDA7XG4gIH0gfTtNb2RhbERpYWxvZy5zaG93ID0gTW9kYWxEaWFsb2cuU2hvdztNb2RhbERpYWxvZy5kcmF3ID0gTW9kYWxEaWFsb2cuU2hvdztNb2RhbERpYWxvZy5IaWRlID0gTW9kYWxEaWFsb2cuQ2xvc2U7TW9kYWxEaWFsb2cuaGlkZSA9IE1vZGFsRGlhbG9nLkNsb3NlO01vZGFsRGlhbG9nLmNsb3NlID0gTW9kYWxEaWFsb2cuQ2xvc2U7Zm9yIChpIGluIE1vZGFsRGlhbG9nKSB7XG4gIGlmICh0eXBlb2YgTW9kYWxEaWFsb2dbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBNb2RhbERpYWxvZ1tpLnRvTG93ZXJDYXNlKCldID0gTW9kYWxEaWFsb2dbaV07XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgubW9kYWxkaWFsb2cuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///196\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Odometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.value !== 'undefined' && typeof conf.id === 'string') {\n    var id = conf.id;\n    var canvas = document.getElementById(id);var min = conf.min;var max = conf.max;var value = conf.value;var parseConfObjectForOptions = true;\n  } else {\n    var id = conf;var canvas = document.getElementById(id);var min = arguments[1];var max = arguments[2];var value = arguments[3];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.type = 'odo';this.isRGraph = true;this.min = RGraph.stringsToNumbers(min);this.max = RGraph.stringsToNumbers(max);this.value = RGraph.stringsToNumbers(value);this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.border': 'black', 'chart.background.color': '#eee', 'chart.background.lines.color': '#ddd', 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.value.text': false, 'chart.value.text.decimals': 0, 'chart.needle.color': 'black', 'chart.needle.width': 2, 'chart.needle.head': true, 'chart.needle.tail': true, 'chart.needle.type': 'pointer', 'chart.needle.extra': [], 'chart.needle.triangle.border': '#aaa', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': false, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.green.max': max * 0.75, 'chart.red.min': max * 0.9, 'chart.green.color': 'Gradient(white:#0c0)', 'chart.yellow.color': 'Gradient(white:#ff0)', 'chart.red.color': 'Gradient(white:#f00)', 'chart.label.area': 35, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.font': null, 'chart.title.bold': true, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.contextmenu': null, 'chart.linewidth': 1, 'chart.shadow.inner': false, 'chart.shadow.inner.color': 'black', 'chart.shadow.inner.offsetx': 3, 'chart.shadow.inner.offsety': 3, 'chart.shadow.inner.blur': 6, 'chart.shadow.outer': false, 'chart.shadow.outer.color': 'black', 'chart.shadow.outer.offsetx': 3, 'chart.shadow.outer.offsety': 3, 'chart.shadow.outer.blur': 6, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.border': false, 'chart.border.color1': '#BEBCB0', 'chart.border.color2': '#F0EFEA', 'chart.border.color3': '#BEBCB0', 'chart.tickmarks': true, 'chart.tickmarks.highlighted': false, 'chart.tickmarks.big.color': '#999', 'chart.zerostart': false, 'chart.labels': null }, _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.value.units.pre', ''), _defineProperty(_properties, 'chart.value.units.post', ''), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.text.size', 10), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.adjustable', false), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = arguments[1] || null;if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.needle.style') {\n      alert('[RGRAPH] The RGraph property chart.needle.style has changed to chart.needle.color');\n    }\n    if (name == 'chart.needle.thickness') {\n      name = 'chart.needle.width';\n    }\n    if (name == 'chart.value') {\n      this.value = value;return;\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.value') {\n      return this.value;\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.currentValue = this.value;if (this.value > this.max) {\n      this.value = this.max;\n    }\n    if (this.value < this.min) {\n      this.value = this.min;\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min((ca.width - this.gutterLeft - this.gutterRight) / 2, (ca.height - this.gutterTop - this.gutterBottom) / 2) - (prop['chart.border'] ? 25 : 0);this.diameter = 2 * this.radius;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.range = this.max - this.min;this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && ca.width > ca.height) this.centerx = 5 + this.radius;if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];if (prop['chart.border']) {\n        this.radius -= 25;\n      }\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    co.lineWidth = prop['chart.linewidth'];this.DrawBackground();this.DrawLabels();this.DrawNeedle(this.value, prop['chart.needle.color']);if (prop['chart.needle.extra'].length > 0) {\n      for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n        var needle = prop['chart.needle.extra'][i];this.DrawNeedle(needle[0], needle[1], needle[2]);\n      }\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0) {\n      var colors = [prop['chart.needle.color']];if (prop['chart.needle.extra'].length > 0) {\n        for (var i = 0; i < prop['chart.needle.extra'].length; ++i) {\n          var needle = prop['chart.needle.extra'][i];colors.push(needle[1]);\n        }\n      }\n      RG.DrawKey(this, prop['chart.key'], colors);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.beginPath();if (prop['chart.shadow.outer']) {\n      RG.setShadow(this, prop['chart.shadow.outer.color'], prop['chart.shadow.outer.offsetx'], prop['chart.shadow.outer.offsety'], prop['chart.shadow.outer.blur']);\n    }\n    var backgroundColor = prop['chart.background.color'];co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0.0001, RG.TWOPI, false);co.fill();RG.noShadow(this);co.strokeStyle = '#666';co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fillStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.fill();if (prop['chart.tickmarks']) {\n      co.beginPath();co.strokeStyle = '#bbb';for (var i = 0; i <= 360; i += 3) {\n        co.arc(this.centerx, this.centery, this.radius, 0, i / 57.3, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    co.beginPath();co.lineWidth = 1;co.strokeStyle = 'black';co.fillStyle = backgroundColor;co.strokeStyle = backgroundColor;co.arc(this.centerx, this.centery, this.radius - 5, 0, RG.TWOPI, false);co.fill();co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.lines.color'];for (var i = 0; i < 360; i += 18) {\n      co.arc(this.centerx, this.centery, this.radius, 0, RG.degrees2Radians(i), false);co.lineTo(this.centerx, this.centery);\n    }\n    co.stroke();co.beginPath();co.strokeStyle = prop['chart.background.border'];co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false);co.stroke();if (prop['chart.shadow.inner']) {\n      co.beginPath();RG.SetShadow(this, prop['chart.shadow.inner.color'], prop['chart.shadow.inner.offsetx'], prop['chart.shadow.inner.offsety'], prop['chart.shadow.inner.blur']);co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0, RG.TWOPI, 0);co.fill();co.stroke();RG.NoShadow(this);\n    }\n    var greengrad = prop['chart.green.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - 2.5, -1 * RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = greengrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], 0 - RG.HALFPI, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var yellowgrad = prop['chart.yellow.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = yellowgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.green.max'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();var redgrad = prop['chart.red.color'];if (prop['chart.tickmarks.highlighted']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - 2.5, (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, 0);co.stroke();co.lineWidth = 1;\n    }\n    co.beginPath();co.fillStyle = redgrad;co.strokeStyle = redgrad;co.arc(this.centerx, this.centery, this.radius - prop['chart.label.area'], (prop['chart.red.min'] - this.min) / (this.max - this.min) * RG.TWOPI - RG.HALFPI, RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.fill();if (prop['chart.border']) {\n      var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius + 20);grad.addColorStop(0, prop['chart.border.color1']);grad.addColorStop(0.5, prop['chart.border.color2']);grad.addColorStop(1, prop['chart.border.color3']);co.beginPath();co.fillStyle = grad;co.strokeStyle = 'rgba(0,0,0,0)';\n      co.lineWidth = 0.001;co.arc(this.centerx, this.centery, this.radius + 20, 0, RG.TWOPI, 0);co.arc(this.centerx, this.centery, this.radius - 2, RG.TWOPI, 0, 1);co.fill();\n    }\n    co.lineWidth = prop['chart.linewidth'];if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (!prop['chart.tickmarks.highlighted']) {\n      for (var i = 18; i <= 360; i += 36) {\n        co.beginPath();co.strokeStyle = prop['chart.tickmarks.big.color'];co.lineWidth = 2;co.arc(this.centerx, this.centery, this.radius - 1, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.arc(this.centerx, this.centery, this.radius - 7, RG.degrees2Radians(i), RG.degrees2Radians(i + 0.01), false);co.stroke();\n      }\n    }\n  };this.drawNeedle = this.DrawNeedle = function (value, color) {\n    var length = arguments[2] ? arguments[2] : this.radius - prop['chart.label.area'];co.fillStyle = '#999';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 10, 0, RG.TWOPI, false);co.fill();co.closePath();co.fill();co.fillStyle = color;\n    co.strokeStyle = '#666';co.beginPath();co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 8, 0, RG.TWOPI, false);co.fill();co.closePath();co.stroke();co.fill();if (prop['chart.needle.type'] == 'pointer') {\n      co.strokeStyle = color;co.lineWidth = prop['chart.needle.width'];co.lineCap = 'round';co.lineJoin = 'round';co.beginPath();co.beginPath();co.moveTo(this.centerx, this.centery);if (prop['chart.needle.tail']) {\n        co.arc(this.centerx, this.centery, 20, (value / this.range * 360 + 90) / (180 / RG.PI), (value / this.range * 360 + 90 + 0.01) / (180 / RG.PI), false);\n      }\n      co.arc(this.centerx, this.centery, length - 10, (value / this.range * 360 - 90) / (180 / RG.PI), (value / this.range * 360 - 90 + 0.1) / (180 / RG.PI), false);co.closePath();\n    } else if (prop['chart.needle.type'] == 'triangle') {\n      co.lineWidth = 0.01;co.lineEnd = 'square';co.lineJoin = 'miter';co.beginPath();co.fillStyle = prop['chart.needle.triangle.border'];co.arc(this.centerx, this.centery, 11, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 11, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 15, 0, RG.TWOPI, 0);co.closePath();co.fill();co.beginPath();co.strokeStyle = 'black';co.fillStyle = color;co.arc(this.centerx, this.centery, 7, value / this.range * 360 / 57.3, (value / this.range * 360 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, 7, (value / this.range * 360 + 180) / 57.3, (value / this.range * 360 + 180 + 0.01) / 57.3, 0);co.arc(this.centerx, this.centery, length - 13, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90) / 57.3 + 0.01, 0);co.closePath();co.stroke();co.fill();co.beginPath();co.arc(this.centerx, this.centery, 7, 0, RG.TWOPI, 0);co.closePath();co.fill();\n    }\n    co.stroke();co.fill();co.beginPath();co.fillStyle = color;co.arc(this.centerx, this.centery, prop['chart.needle.type'] == 'pointer' ? 7 : 12, 0.01, RG.TWOPI, false);co.fill();if (prop['chart.needle.head'] && prop['chart.needle.type'] == 'pointer') {\n      co.lineWidth = 1;co.fillStyle = color;co.lineJoin = 'miter';co.lineCap = 'butt';co.beginPath();co.arc(this.centerx, this.centery, length - 5, (value / this.range * 360 - 90) / 57.3, (value / this.range * 360 - 90 + 0.1) / 57.3, false);co.arc(this.centerx, this.centery, length - 20, RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 80 : 85)), RG.degrees2Radians(value / this.range * 360 - (length < 60 ? 100 : 95)), 1);co.closePath();co.fill();\n    }\n    co.beginPath();co.fillStyle = 'gray';co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, 2, 0, 6.2795, false);co.closePath();co.fill();\n  };this.drawLabels = this.DrawLabels = function () {\n    var size = prop['chart.text.size'];var font = prop['chart.text.font'];var centerx = this.centerx;var centery = this.centery;var r = this.radius - prop['chart.label.area'] / 2;var start = this.min;var end = this.max;var decimals = prop['chart.scale.decimals'];var labels = prop['chart.labels'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];co.beginPath();co.fillStyle = prop['chart.text.color'];if (labels) {\n      for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + Math.cos(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'y': centery + Math.sin(i / labels.length * RG.TWOPI - RG.HALFPI) * (this.radius - prop['chart.label.area'] / 2), 'text': String(labels[i]), 'valign': 'center', 'halign': 'center', 'tag': 'labels' });\n      }\n    } else {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (1 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 36, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (2 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 72, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.949 * r, 'y': centery + 0.31 * r, 'text': RG.number_format(this, ((end - start) * (3 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 108, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (4 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 144, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery + r, 'text': RG.number_format(this, ((end - start) * (5 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 180, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery + 0.809 * r, 'text': RG.number_format(this, ((end - start) * (6 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 216, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.949 * r, 'y': centery + 0.300 * r, 'text': RG.number_format(this, ((end - start) * (7 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 252, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.951 * r, 'y': centery - 0.309 * r, 'text': RG.number_format(this, ((end - start) * (8 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 288, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 0.588 * r, 'y': centery - 0.809 * r, 'text': RG.number_format(this, ((end - start) * (9 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'angle': 324, 'tag': 'scale' });RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery - r, 'text': prop['chart.zerostart'] ? RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post) : RG.number_format(this, ((end - start) * (10 / 10) + start).toFixed(decimals), units_pre, units_post), 'halign': 'center', 'valign': 'center', 'tag': 'scale' });\n    }\n    co.fill();if (prop['chart.value.text']) {\n      co.strokeStyle = 'black';RG.Text2(this, { 'font': font, 'size': size + 2, 'x': centerx, 'y': centery + size + 15, 'text': String(prop['chart.value.units.pre'] + this.value.toFixed(prop['chart.value.text.decimals']) + prop['chart.value.units.post']), 'halign': 'center', 'valign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'value.text' });\n    }\n  };this.getShape = function (e) {};this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e);\n    var angle = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);angle += RG.HALFPI;if (mouseXY[0] >= this.centerx && mouseXY[1] <= this.centery) {\n      angle -= RG.TWOPI;\n    }\n    var value = angle / RG.TWOPI * (this.max - this.min) + this.min;return value;\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      this.value = this.getValue(e);RG.clear(ca);RG.redrawCanvas(ca);RG.fireCustomEvent(this, 'onadjust');\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = (value - this.min) / (this.max - this.min) * RG.TWOPI;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.green.color'] = RG.array_clone(prop['chart.green.color']);this.original_colors['chart.yellow.color'] = RG.array_clone(prop['chart.yellow.color']);this.original_colors['chart.red.color'] = RG.array_clone(prop['chart.red.color']);\n    }\n    prop['chart.green.color'] = this.parseSingleColorForGradient(prop['chart.green.color']);prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);prop['chart.red.color'] = this.parseSingleColorForGradient(prop['chart.red.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 30;var frame = 0;var current = obj.currentValue || 0;var origValue = Number(obj.currentValue);var newValue = obj.value;var diff = newValue - origValue;var step = diff / frames;var callback = arguments[1] || function () {};function iterator() {\n      obj.value = origValue + frame * step;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5vZG8uanM/MjM0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5PZG9tZXRlciA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIHZhciBfcHJvcGVydGllcztcblxuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLnZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaWQgPSBjb25mLmlkO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbiA9IGNvbmYubWluO3ZhciBtYXggPSBjb25mLm1heDt2YXIgdmFsdWUgPSBjb25mLnZhbHVlO3ZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mO3ZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7dmFyIG1pbiA9IGFyZ3VtZW50c1sxXTt2YXIgbWF4ID0gYXJndW1lbnRzWzJdO3ZhciB2YWx1ZSA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB0aGlzLmlkID0gaWQ7dGhpcy5jYW52YXMgPSBjYW52YXM7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCA/IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpZCkpID09PSAnb2JqZWN0JyAmJiBpZC5hbHBoYSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUgfSkgOiBudWxsO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMudHlwZSA9ICdvZG8nO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMubWluID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMobWluKTt0aGlzLm1heCA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKG1heCk7dGhpcy52YWx1ZSA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKHZhbHVlKTt0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7dGhpcy51aWQgPSBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jYW52YXMudWlkID0gdGhpcy5jYW52YXMudWlkID8gdGhpcy5jYW52YXMudWlkIDogUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5vcmlnaW5hbF9jb2xvcnMgPSBbXTt0aGlzLmZpcnN0RHJhdyA9IHRydWU7dGhpcy5wcm9wZXJ0aWVzID0gKF9wcm9wZXJ0aWVzID0geyAnY2hhcnQuYmFja2dyb3VuZC5ib3JkZXInOiAnYmxhY2snLCAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6ICcjZWVlJywgJ2NoYXJ0LmJhY2tncm91bmQubGluZXMuY29sb3InOiAnI2RkZCcsICdjaGFydC5jZW50ZXJ4JzogbnVsbCwgJ2NoYXJ0LmNlbnRlcnknOiBudWxsLCAnY2hhcnQucmFkaXVzJzogbnVsbCwgJ2NoYXJ0LnZhbHVlLnRleHQnOiBmYWxzZSwgJ2NoYXJ0LnZhbHVlLnRleHQuZGVjaW1hbHMnOiAwLCAnY2hhcnQubmVlZGxlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0Lm5lZWRsZS53aWR0aCc6IDIsICdjaGFydC5uZWVkbGUuaGVhZCc6IHRydWUsICdjaGFydC5uZWVkbGUudGFpbCc6IHRydWUsICdjaGFydC5uZWVkbGUudHlwZSc6ICdwb2ludGVyJywgJ2NoYXJ0Lm5lZWRsZS5leHRyYSc6IFtdLCAnY2hhcnQubmVlZGxlLnRyaWFuZ2xlLmJvcmRlcic6ICcjYWFhJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IGZhbHNlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuZ3JlZW4ubWF4JzogbWF4ICogMC43NSwgJ2NoYXJ0LnJlZC5taW4nOiBtYXggKiAwLjksICdjaGFydC5ncmVlbi5jb2xvcic6ICdHcmFkaWVudCh3aGl0ZTojMGMwKScsICdjaGFydC55ZWxsb3cuY29sb3InOiAnR3JhZGllbnQod2hpdGU6I2ZmMCknLCAnY2hhcnQucmVkLmNvbG9yJzogJ0dyYWRpZW50KHdoaXRlOiNmMDApJywgJ2NoYXJ0LmxhYmVsLmFyZWEnOiAzNSwgJ2NoYXJ0Lmd1dHRlci5sZWZ0JzogMjUsICdjaGFydC5ndXR0ZXIucmlnaHQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci50b3AnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5ib3R0b20nOiAyNSwgJ2NoYXJ0LnRpdGxlJzogJycsICdjaGFydC50aXRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUudnBvcyc6IG51bGwsICdjaGFydC50aXRsZS5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhhbGlnbic6IG51bGwsICdjaGFydC50aXRsZS52YWxpZ24nOiBudWxsLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQubGluZXdpZHRoJzogMSwgJ2NoYXJ0LnNoYWRvdy5pbm5lcic6IGZhbHNlLCAnY2hhcnQuc2hhZG93LmlubmVyLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnNoYWRvdy5pbm5lci5vZmZzZXR4JzogMywgJ2NoYXJ0LnNoYWRvdy5pbm5lci5vZmZzZXR5JzogMywgJ2NoYXJ0LnNoYWRvdy5pbm5lci5ibHVyJzogNiwgJ2NoYXJ0LnNoYWRvdy5vdXRlcic6IGZhbHNlLCAnY2hhcnQuc2hhZG93Lm91dGVyLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnNoYWRvdy5vdXRlci5vZmZzZXR4JzogMywgJ2NoYXJ0LnNoYWRvdy5vdXRlci5vZmZzZXR5JzogMywgJ2NoYXJ0LnNoYWRvdy5vdXRlci5ibHVyJzogNiwgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycsICdjaGFydC5zY2FsZS5kZWNpbWFscyc6IDAsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQuem9vbS5hY3Rpb24nOiAnem9vbScsICdjaGFydC5yZXNpemFibGUnOiBmYWxzZSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzogWzAsIDBdLCAnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LnVuaXRzLnByZSc6ICcnLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQuYm9yZGVyJzogZmFsc2UsICdjaGFydC5ib3JkZXIuY29sb3IxJzogJyNCRUJDQjAnLCAnY2hhcnQuYm9yZGVyLmNvbG9yMic6ICcjRjBFRkVBJywgJ2NoYXJ0LmJvcmRlci5jb2xvcjMnOiAnI0JFQkNCMCcsICdjaGFydC50aWNrbWFya3MnOiB0cnVlLCAnY2hhcnQudGlja21hcmtzLmhpZ2hsaWdodGVkJzogZmFsc2UsICdjaGFydC50aWNrbWFya3MuYmlnLmNvbG9yJzogJyM5OTknLCAnY2hhcnQuemVyb3N0YXJ0JzogZmFsc2UsICdjaGFydC5sYWJlbHMnOiBudWxsIH0sIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnVuaXRzLnByZScsICcnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudW5pdHMucG9zdCcsICcnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudmFsdWUudW5pdHMucHJlJywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC52YWx1ZS51bml0cy5wb3N0JywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXknLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmJhY2tncm91bmQnLCAnd2hpdGUnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnBvc2l0aW9uJywgJ2dyYXBoJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5zaGFkb3cnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5zaGFkb3cuY29sb3InLCAnIzY2NicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuc2hhZG93LmJsdXInLCAzKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR4JywgMiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eScsIDIpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkucG9zaXRpb24uZ3V0dGVyLmJveGVkJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkucG9zaXRpb24ueCcsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkucG9zaXRpb24ueScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuaGFsaWduJywgJ3JpZ2h0JyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZScsICdzcXVhcmUnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnJvdW5kZWQnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnRleHQuc2l6ZScsIDEwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmNvbG9ycycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkudGV4dC5jb2xvcicsICdibGFjaycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hZGp1c3RhYmxlJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jbGVhcnRvJywgJ3JnYmEoMCwwLDAsMCknKSwgX3Byb3BlcnRpZXMpO1xuICBpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1sxXSB8fCBudWxsO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubmVlZGxlLnN0eWxlJykge1xuICAgICAgYWxlcnQoJ1tSR1JBUEhdIFRoZSBSR3JhcGggcHJvcGVydHkgY2hhcnQubmVlZGxlLnN0eWxlIGhhcyBjaGFuZ2VkIHRvIGNoYXJ0Lm5lZWRsZS5jb2xvcicpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubmVlZGxlLnRoaWNrbmVzcycpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQubmVlZGxlLndpZHRoJztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnZhbHVlJykge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO3JldHVybjtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnZhbHVlJykge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7dGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlO2lmICh0aGlzLnZhbHVlID4gdGhpcy5tYXgpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICB0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnJhZGl1cyA9IE1hdGgubWluKChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiwgKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMikgLSAocHJvcFsnY2hhcnQuYm9yZGVyJ10gPyAyNSA6IDApO3RoaXMuZGlhbWV0ZXIgPSAyICogdGhpcy5yYWRpdXM7dGhpcy5jZW50ZXJ4ID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeSA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDIgKyB0aGlzLmd1dHRlclRvcDt0aGlzLnJhbmdlID0gdGhpcy5tYXggLSB0aGlzLm1pbjt0aGlzLmNvb3Jkc1RleHQgPSBbXTtpZiAocHJvcFsnY2hhcnQua2V5J10gJiYgcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoID4gMCAmJiBjYS53aWR0aCA+IGNhLmhlaWdodCkgdGhpcy5jZW50ZXJ4ID0gNSArIHRoaXMucmFkaXVzO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeCddID09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT0gJ251bWJlcicpIHRoaXMuY2VudGVyeSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgICB0aGlzLnJhZGl1cyAtPSAyNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107dGhpcy5EcmF3QmFja2dyb3VuZCgpO3RoaXMuRHJhd0xhYmVscygpO3RoaXMuRHJhd05lZWRsZSh0aGlzLnZhbHVlLCBwcm9wWydjaGFydC5uZWVkbGUuY29sb3InXSk7aWYgKHByb3BbJ2NoYXJ0Lm5lZWRsZS5leHRyYSddLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQubmVlZGxlLmV4dHJhJ10ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5lZWRsZSA9IHByb3BbJ2NoYXJ0Lm5lZWRsZS5leHRyYSddW2ldO3RoaXMuRHJhd05lZWRsZShuZWVkbGVbMF0sIG5lZWRsZVsxXSwgbmVlZGxlWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmtleSddICYmIHByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBjb2xvcnMgPSBbcHJvcFsnY2hhcnQubmVlZGxlLmNvbG9yJ11dO2lmIChwcm9wWydjaGFydC5uZWVkbGUuZXh0cmEnXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQubmVlZGxlLmV4dHJhJ10ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgbmVlZGxlID0gcHJvcFsnY2hhcnQubmVlZGxlLmV4dHJhJ11baV07Y29sb3JzLnB1c2gobmVlZGxlWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUkcuRHJhd0tleSh0aGlzLCBwcm9wWydjaGFydC5rZXknXSwgY29sb3JzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdCYWNrZ3JvdW5kID0gdGhpcy5EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjby5iZWdpblBhdGgoKTtpZiAocHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyJ10pIHtcbiAgICAgIFJHLnNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cub3V0ZXIuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyLm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyLm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm91dGVyLmJsdXInXSk7XG4gICAgfVxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28uZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIDAuMDAwMSwgUkcuVFdPUEksIGZhbHNlKTtjby5maWxsKCk7Ukcubm9TaGFkb3codGhpcyk7Y28uc3Ryb2tlU3R5bGUgPSAnIzY2Nic7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgMCwgUkcuVFdPUEksIGZhbHNlKTtjby5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgMCwgUkcuVFdPUEksIGZhbHNlKTtjby5maWxsKCk7aWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9ICcjYmJiJztmb3IgKHZhciBpID0gMDsgaSA8PSAzNjA7IGkgKz0gMykge1xuICAgICAgICBjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzLCAwLCBpIC8gNTcuMywgZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7XG4gICAgICB9XG4gICAgICBjby5zdHJva2UoKTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gMTtjby5zdHJva2VTdHlsZSA9ICdibGFjayc7Y28uZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO2NvLnN0cm9rZVN0eWxlID0gYmFja2dyb3VuZENvbG9yO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSA1LCAwLCBSRy5UV09QSSwgZmFsc2UpO2NvLmZpbGwoKTtjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQubGluZXMuY29sb3InXTtmb3IgKHZhciBpID0gMDsgaSA8IDM2MDsgaSArPSAxOCkge1xuICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgMCwgUkcuZGVncmVlczJSYWRpYW5zKGkpLCBmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtcbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJvcmRlciddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIDAsIFJHLlRXT1BJLCBmYWxzZSk7Y28uc3Ryb2tlKCk7aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdy5pbm5lciddKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtSRy5TZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmlubmVyLmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5pbm5lci5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5pbm5lci5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5pbm5lci5ibHVyJ10pO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSBwcm9wWydjaGFydC5sYWJlbC5hcmVhJ10sIDAsIFJHLlRXT1BJLCAwKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7UkcuTm9TaGFkb3codGhpcyk7XG4gICAgfVxuICAgIHZhciBncmVlbmdyYWQgPSBwcm9wWydjaGFydC5ncmVlbi5jb2xvciddO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MuaGlnaGxpZ2h0ZWQnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gNTtjby5zdHJva2VTdHlsZSA9IGdyZWVuZ3JhZDtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMi41LCAtMSAqIFJHLkhBTEZQSSwgKHByb3BbJ2NoYXJ0LmdyZWVuLm1heCddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogUkcuVFdPUEkgLSBSRy5IQUxGUEksIDApO2NvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aCA9IDE7XG4gICAgfVxuICAgIGNvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGdyZWVuZ3JhZDtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQubGFiZWwuYXJlYSddLCAwIC0gUkcuSEFMRlBJLCAocHJvcFsnY2hhcnQuZ3JlZW4ubWF4J10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiBSRy5UV09QSSAtIFJHLkhBTEZQSSwgZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO3ZhciB5ZWxsb3dncmFkID0gcHJvcFsnY2hhcnQueWVsbG93LmNvbG9yJ107aWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5oaWdobGlnaHRlZCddKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5saW5lV2lkdGggPSA1O2NvLnN0cm9rZVN0eWxlID0geWVsbG93Z3JhZDtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMi41LCAocHJvcFsnY2hhcnQuZ3JlZW4ubWF4J10gLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiBSRy5UV09QSSAtIFJHLkhBTEZQSSwgKHByb3BbJ2NoYXJ0LnJlZC5taW4nXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJLCAwKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGggPSAxO1xuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSB5ZWxsb3dncmFkO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSBwcm9wWydjaGFydC5sYWJlbC5hcmVhJ10sIChwcm9wWydjaGFydC5ncmVlbi5tYXgnXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJLCAocHJvcFsnY2hhcnQucmVkLm1pbiddIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogUkcuVFdPUEkgLSBSRy5IQUxGUEksIGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTt2YXIgcmVkZ3JhZCA9IHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MuaGlnaGxpZ2h0ZWQnXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gNTtjby5zdHJva2VTdHlsZSA9IHJlZGdyYWQ7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIDIuNSwgKHByb3BbJ2NoYXJ0LnJlZC5taW4nXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJLCBSRy5UV09QSSAtIFJHLkhBTEZQSSwgMCk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gMTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcmVkZ3JhZDtjby5zdHJva2VTdHlsZSA9IHJlZGdyYWQ7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LmxhYmVsLmFyZWEnXSwgKHByb3BbJ2NoYXJ0LnJlZC5taW4nXSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJLCBSRy5UV09QSSAtIFJHLkhBTEZQSSwgZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2lmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgdmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyArIDIwKTtncmFkLmFkZENvbG9yU3RvcCgwLCBwcm9wWydjaGFydC5ib3JkZXIuY29sb3IxJ10pO2dyYWQuYWRkQ29sb3JTdG9wKDAuNSwgcHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yMiddKTtncmFkLmFkZENvbG9yU3RvcCgxLCBwcm9wWydjaGFydC5ib3JkZXIuY29sb3IzJ10pO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGdyYWQ7Y28uc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICBjby5saW5lV2lkdGggPSAwLjAwMTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzICsgMjAsIDAsIFJHLlRXT1BJLCAwKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gMiwgUkcuVFdPUEksIDAsIDEpO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107aWYgKHByb3BbJ2NoYXJ0LnRpdGxlJ10pIHtcbiAgICAgIFJHLkRyYXdUaXRsZSh0aGlzLCBwcm9wWydjaGFydC50aXRsZSddLCB0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cywgbnVsbCwgcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddID8gcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wWydjaGFydC50aWNrbWFya3MuaGlnaGxpZ2h0ZWQnXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDE4OyBpIDw9IDM2MDsgaSArPSAzNikge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5iaWcuY29sb3InXTtjby5saW5lV2lkdGggPSAyO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSAxLCBSRy5kZWdyZWVzMlJhZGlhbnMoaSksIFJHLmRlZ3JlZXMyUmFkaWFucyhpICsgMC4wMSksIGZhbHNlKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gNywgUkcuZGVncmVlczJSYWRpYW5zKGkpLCBSRy5kZWdyZWVzMlJhZGlhbnMoaSArIDAuMDEpLCBmYWxzZSk7Y28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd05lZWRsZSA9IHRoaXMuRHJhd05lZWRsZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29sb3IpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogdGhpcy5yYWRpdXMgLSBwcm9wWydjaGFydC5sYWJlbC5hcmVhJ107Y28uZmlsbFN0eWxlID0gJyM5OTknO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAxMCwgMCwgUkcuVFdPUEksIGZhbHNlKTtjby5maWxsKCk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvLnN0cm9rZVN0eWxlID0gJyM2NjYnO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCA4LCAwLCBSRy5UV09QSSwgZmFsc2UpO2NvLmZpbGwoKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7aWYgKHByb3BbJ2NoYXJ0Lm5lZWRsZS50eXBlJ10gPT0gJ3BvaW50ZXInKSB7XG4gICAgICBjby5zdHJva2VTdHlsZSA9IGNvbG9yO2NvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0Lm5lZWRsZS53aWR0aCddO2NvLmxpbmVDYXAgPSAncm91bmQnO2NvLmxpbmVKb2luID0gJ3JvdW5kJztjby5iZWdpblBhdGgoKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2lmIChwcm9wWydjaGFydC5uZWVkbGUudGFpbCddKSB7XG4gICAgICAgIGNvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMjAsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgKyA5MCkgLyAoMTgwIC8gUkcuUEkpLCAodmFsdWUgLyB0aGlzLnJhbmdlICogMzYwICsgOTAgKyAwLjAxKSAvICgxODAgLyBSRy5QSSksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbGVuZ3RoIC0gMTAsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgLSA5MCkgLyAoMTgwIC8gUkcuUEkpLCAodmFsdWUgLyB0aGlzLnJhbmdlICogMzYwIC0gOTAgKyAwLjEpIC8gKDE4MCAvIFJHLlBJKSwgZmFsc2UpO2NvLmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQubmVlZGxlLnR5cGUnXSA9PSAndHJpYW5nbGUnKSB7XG4gICAgICBjby5saW5lV2lkdGggPSAwLjAxO2NvLmxpbmVFbmQgPSAnc3F1YXJlJztjby5saW5lSm9pbiA9ICdtaXRlcic7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQubmVlZGxlLnRyaWFuZ2xlLmJvcmRlciddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMTEsIHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAvIDU3LjMsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgKyAwLjAxKSAvIDU3LjMsIDApO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMTEsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgKyAxODApIC8gNTcuMywgKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCArIDE4MCArIDAuMDEpIC8gNTcuMywgMCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBsZW5ndGggLSA1LCAodmFsdWUgLyB0aGlzLnJhbmdlICogMzYwIC0gOTApIC8gNTcuMywgKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAtIDkwKSAvIDU3LjMgKyAwLjAxLCAwKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAxNSwgMCwgUkcuVFdPUEksIDApO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9ICdibGFjayc7Y28uZmlsbFN0eWxlID0gY29sb3I7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCA3LCB2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgLyA1Ny4zLCAodmFsdWUgLyB0aGlzLnJhbmdlICogMzYwICsgMC4wMSkgLyA1Ny4zLCAwKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIDcsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgKyAxODApIC8gNTcuMywgKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCArIDE4MCArIDAuMDEpIC8gNTcuMywgMCk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBsZW5ndGggLSAxMywgKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAtIDkwKSAvIDU3LjMsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgLSA5MCkgLyA1Ny4zICsgMC4wMSwgMCk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgNywgMCwgUkcuVFdPUEksIDApO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgY28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGNvbG9yO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgcHJvcFsnY2hhcnQubmVlZGxlLnR5cGUnXSA9PSAncG9pbnRlcicgPyA3IDogMTIsIDAuMDEsIFJHLlRXT1BJLCBmYWxzZSk7Y28uZmlsbCgpO2lmIChwcm9wWydjaGFydC5uZWVkbGUuaGVhZCddICYmIHByb3BbJ2NoYXJ0Lm5lZWRsZS50eXBlJ10gPT0gJ3BvaW50ZXInKSB7XG4gICAgICBjby5saW5lV2lkdGggPSAxO2NvLmZpbGxTdHlsZSA9IGNvbG9yO2NvLmxpbmVKb2luID0gJ21pdGVyJztjby5saW5lQ2FwID0gJ2J1dHQnO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbGVuZ3RoIC0gNSwgKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAtIDkwKSAvIDU3LjMsICh2YWx1ZSAvIHRoaXMucmFuZ2UgKiAzNjAgLSA5MCArIDAuMSkgLyA1Ny4zLCBmYWxzZSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBsZW5ndGggLSAyMCwgUkcuZGVncmVlczJSYWRpYW5zKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAtIChsZW5ndGggPCA2MCA/IDgwIDogODUpKSwgUkcuZGVncmVlczJSYWRpYW5zKHZhbHVlIC8gdGhpcy5yYW5nZSAqIDM2MCAtIChsZW5ndGggPCA2MCA/IDEwMCA6IDk1KSksIDEpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gJ2dyYXknO2NvLm1vdmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAyLCAwLCA2LjI3OTUsIGZhbHNlKTtjby5jbG9zZVBhdGgoKTtjby5maWxsKCk7XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgY2VudGVyeCA9IHRoaXMuY2VudGVyeDt2YXIgY2VudGVyeSA9IHRoaXMuY2VudGVyeTt2YXIgciA9IHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQubGFiZWwuYXJlYSddIC8gMjt2YXIgc3RhcnQgPSB0aGlzLm1pbjt2YXIgZW5kID0gdGhpcy5tYXg7dmFyIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTt2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzJ107dmFyIHVuaXRzX3ByZSA9IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtpZiAobGFiZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggKyBNYXRoLmNvcyhpIC8gbGFiZWxzLmxlbmd0aCAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJKSAqICh0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LmxhYmVsLmFyZWEnXSAvIDIpLCAneSc6IGNlbnRlcnkgKyBNYXRoLnNpbihpIC8gbGFiZWxzLmxlbmd0aCAqIFJHLlRXT1BJIC0gUkcuSEFMRlBJKSAqICh0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LmxhYmVsLmFyZWEnXSAvIDIpLCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaV0pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdsYWJlbHMnIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggKyAwLjU4OCAqIHIsICd5JzogY2VudGVyeSAtIDAuODA5ICogciwgJ3RleHQnOiBSRy5udW1iZXJfZm9ybWF0KHRoaXMsICgoZW5kIC0gc3RhcnQpICogKDEgLyAxMCkgKyBzdGFydCkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAnYW5nbGUnOiAzNiwgJ3RhZyc6ICdzY2FsZScgfSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4ICsgMC45NTEgKiByLCAneSc6IGNlbnRlcnkgLSAwLjMwOSAqIHIsICd0ZXh0JzogUkcubnVtYmVyX2Zvcm1hdCh0aGlzLCAoKGVuZCAtIHN0YXJ0KSAqICgyIC8gMTApICsgc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ2FuZ2xlJzogNzIsICd0YWcnOiAnc2NhbGUnIH0pO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCArIDAuOTQ5ICogciwgJ3knOiBjZW50ZXJ5ICsgMC4zMSAqIHIsICd0ZXh0JzogUkcubnVtYmVyX2Zvcm1hdCh0aGlzLCAoKGVuZCAtIHN0YXJ0KSAqICgzIC8gMTApICsgc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ2FuZ2xlJzogMTA4LCAndGFnJzogJ3NjYWxlJyB9KTtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggKyAwLjU4OCAqIHIsICd5JzogY2VudGVyeSArIDAuODA5ICogciwgJ3RleHQnOiBSRy5udW1iZXJfZm9ybWF0KHRoaXMsICgoZW5kIC0gc3RhcnQpICogKDQgLyAxMCkgKyBzdGFydCkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAnYW5nbGUnOiAxNDQsICd0YWcnOiAnc2NhbGUnIH0pO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCwgJ3knOiBjZW50ZXJ5ICsgciwgJ3RleHQnOiBSRy5udW1iZXJfZm9ybWF0KHRoaXMsICgoZW5kIC0gc3RhcnQpICogKDUgLyAxMCkgKyBzdGFydCkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAnYW5nbGUnOiAxODAsICd0YWcnOiAnc2NhbGUnIH0pO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIDAuNTg4ICogciwgJ3knOiBjZW50ZXJ5ICsgMC44MDkgKiByLCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgKChlbmQgLSBzdGFydCkgKiAoNiAvIDEwKSArIHN0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2NlbnRlcicsICdhbmdsZSc6IDIxNiwgJ3RhZyc6ICdzY2FsZScgfSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4IC0gMC45NDkgKiByLCAneSc6IGNlbnRlcnkgKyAwLjMwMCAqIHIsICd0ZXh0JzogUkcubnVtYmVyX2Zvcm1hdCh0aGlzLCAoKGVuZCAtIHN0YXJ0KSAqICg3IC8gMTApICsgc3RhcnQpLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ2FuZ2xlJzogMjUyLCAndGFnJzogJ3NjYWxlJyB9KTtSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggLSAwLjk1MSAqIHIsICd5JzogY2VudGVyeSAtIDAuMzA5ICogciwgJ3RleHQnOiBSRy5udW1iZXJfZm9ybWF0KHRoaXMsICgoZW5kIC0gc3RhcnQpICogKDggLyAxMCkgKyBzdGFydCkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAnYW5nbGUnOiAyODgsICd0YWcnOiAnc2NhbGUnIH0pO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIDAuNTg4ICogciwgJ3knOiBjZW50ZXJ5IC0gMC44MDkgKiByLCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgKChlbmQgLSBzdGFydCkgKiAoOSAvIDEwKSArIHN0YXJ0KS50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ2hhbGlnbic6ICdjZW50ZXInLCAndmFsaWduJzogJ2NlbnRlcicsICdhbmdsZSc6IDMyNCwgJ3RhZyc6ICdzY2FsZScgfSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4LCAneSc6IGNlbnRlcnkgLSByLCAndGV4dCc6IHByb3BbJ2NoYXJ0Lnplcm9zdGFydCddID8gUkcubnVtYmVyX2Zvcm1hdCh0aGlzLCB0aGlzLm1pbi50b0ZpeGVkKGRlY2ltYWxzKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSA6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgKChlbmQgLSBzdGFydCkgKiAoMTAgLyAxMCkgKyBzdGFydCkudG9GaXhlZChkZWNpbWFscyksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICdoYWxpZ24nOiAnY2VudGVyJywgJ3ZhbGlnbic6ICdjZW50ZXInLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICB9XG4gICAgY28uZmlsbCgpO2lmIChwcm9wWydjaGFydC52YWx1ZS50ZXh0J10pIHtcbiAgICAgIGNvLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplICsgMiwgJ3gnOiBjZW50ZXJ4LCAneSc6IGNlbnRlcnkgKyBzaXplICsgMTUsICd0ZXh0JzogU3RyaW5nKHByb3BbJ2NoYXJ0LnZhbHVlLnVuaXRzLnByZSddICsgdGhpcy52YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnZhbHVlLnRleHQuZGVjaW1hbHMnXSkgKyBwcm9wWydjaGFydC52YWx1ZS51bml0cy5wb3N0J10pLCAnaGFsaWduJzogJ2NlbnRlcicsICd2YWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nRmlsbCc6ICd3aGl0ZScsICd0YWcnOiAndmFsdWUudGV4dCcgfSk7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoZSkge307dGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO1xuICAgIHZhciBhbmdsZSA9IFJHLmdldEFuZ2xlQnlYWSh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYWVswXSwgbW91c2VYWVsxXSk7YW5nbGUgKz0gUkcuSEFMRlBJO2lmIChtb3VzZVhZWzBdID49IHRoaXMuY2VudGVyeCAmJiBtb3VzZVhZWzFdIDw9IHRoaXMuY2VudGVyeSkge1xuICAgICAgYW5nbGUgLT0gUkcuVFdPUEk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGFuZ2xlIC8gUkcuVFdPUEkgKiAodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbjtyZXR1cm4gdmFsdWU7XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIHJhZGl1cyA9IFJHLmdldEh5cExlbmd0aCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgbW91c2VYWVswXSwgbW91c2VYWVsxXSk7aWYgKG1vdXNlWFlbMF0gPiB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzBdIDwgdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgJiYgbW91c2VYWVsxXSA+IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICYmIG1vdXNlWFlbMV0gPCB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyAmJiByYWRpdXMgPD0gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZSk7UkcuY2xlYXIoY2EpO1JHLnJlZHJhd0NhbnZhcyhjYSk7UkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmFkanVzdCcpO1xuICAgIH1cbiAgfTt0aGlzLmdldEFuZ2xlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID4gdGhpcy5tYXggfHwgdmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhbmdsZSA9ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlRXT1BJO2FuZ2xlIC09IFJHLkhBTEZQSTtyZXR1cm4gYW5nbGU7XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZ3JlZW4uY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC55ZWxsb3cuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQucmVkLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5yZWQuY29sb3InXSk7XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmdyZWVuLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5ncmVlbi5jb2xvciddKTtwcm9wWydjaGFydC55ZWxsb3cuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnllbGxvdy5jb2xvciddKTtwcm9wWydjaGFydC5yZWQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnJlZC5jb2xvciddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAwLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMpO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDt2YXIgY3VycmVudCA9IG9iai5jdXJyZW50VmFsdWUgfHwgMDt2YXIgb3JpZ1ZhbHVlID0gTnVtYmVyKG9iai5jdXJyZW50VmFsdWUpO3ZhciBuZXdWYWx1ZSA9IG9iai52YWx1ZTt2YXIgZGlmZiA9IG5ld1ZhbHVlIC0gb3JpZ1ZhbHVlO3ZhciBzdGVwID0gZGlmZiAvIGZyYW1lczt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge307ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBvYmoudmFsdWUgPSBvcmlnVmFsdWUgKyBmcmFtZSAqIHN0ZXA7UkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuYXR0KGNhKTtSRy5yZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgub2RvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///197\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Pie = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var id = conf.id,\n        canvas = document.getElementById(id),\n        data = conf.data,\n        parseConfObjectForOptions = true;\n  } else {\n    var id = conf,\n        canvas = document.getElementById(id),\n        data = arguments[1];\n  }\n  this.id = id;this.canvas = canvas;this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\", { alpha: (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object' && id.alpha === false ? false : true }) : null;this.canvas.__object__ = this;this.total = 0;this.subTotal = 0;this.angles = [];this.data = data;this.properties = [];this.type = 'pie';this.isRGraph = true;this.coords = [];this.coords.key = [];this.coordsSticks = [];this.coordsText = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.original_colors = [];this.firstDraw = true;this.exploding = null;for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  this.properties = { 'chart.centerx.adjust': 0, 'chart.centery.adjust': 0, 'chart.colors': ['red', '#ccc', '#cfc', 'blue', 'pink', 'yellow', 'black', 'orange', 'cyan', 'purple', '#78CAEA', '#E284E9', 'white', 'blue', '#9E7BF6'], 'chart.strokestyle': 'white', 'chart.linewidth': 3, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.sticks': false, 'chart.labels.sticks.length': 7, 'chart.labels.sticks.colors': null, 'chart.labels.sticks.usecolors': true, 'chart.labels.sticks.linewidth': 1, 'chart.labels.sticks.hlength': 5, 'chart.labels.sticks.list': false, 'chart.labels.ingraph': null, 'chart.labels.ingraph.color': null, 'chart.labels.ingraph.font': null, 'chart.labels.ingraph.size': null, 'chart.labels.ingraph.bounding': true, 'chart.labels.ingraph.bounding.fill': 'white', 'chart.labels.ingraph.specific': null, 'chart.labels.ingraph.units.pre': '', 'chart.labels.ingraph.units.post': '', 'chart.labels.ingraph.radius': null, 'chart.labels.center': null, 'chart.labels.center.size': 26, 'chart.labels.center.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.labels.center.color': 'black', 'chart.labels.center.italic': false, 'chart.labels.center.bold': false, 'chart.labels.center.units.pre': '', 'chart.labels.center.units.post': '', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': 0.5, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.shadow': true, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.style': '2d', 'chart.highlight.style.twod.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.style.twod.stroke': 'rgba(255,255,255,0.7)', 'chart.highlight.style.outline.width': null, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.border': false, 'chart.border.color': 'rgba(255,255,255,0.5)', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.variant': 'pie', 'chart.variant.donut.width': null, 'chart.variant.threed.depth': 20, 'chart.exploded': [], 'chart.effect.roundrobin.multiplier': 1, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.centerpin': null, 'chart.centerpin.fill': 'gray', 'chart.centerpin.stroke': 'white', 'chart.origin': 0 - Math.PI / 2, 'chart.events': true, 'chart.labels.colors': [], 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, len = data.length; i < len; i++) {\n    this.total += data[i];this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    if (name == 'chart.labels.spaced') {\n      name = 'chart.labels.sticks.list';\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.highlight.style.twod.color') {\n      name = 'chart.highlight.style.twod.fill';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = this.getRadius();this.centerx = this.graph.width / 2 + this.gutterLeft + prop['chart.centerx.adjust'];this.centery = this.graph.height / 2 + this.gutterTop + prop['chart.centery.adjust'];this.subTotal = this.properties['chart.origin'];this.angles = [];this.coordsText = [];if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (this.radius <= 0) {\n      return;\n    }\n    if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.labels.colors'][prop['chart.labels.colors'].length - 1]);\n      }\n    } else {\n      if (typeof prop['chart.labels.colors'] === 'undefined') {\n        prop['chart.labels.colors'] = [];\n      }\n      while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\n        prop['chart.labels.colors'].push(prop['chart.text.color']);\n      }\n    }\n    if (prop['chart.variant'].indexOf('3d') > 0) {\n      return this.draw3d();\n    }\n    RG.DrawTitle(this, prop['chart.title'], ca.height / 2 - this.radius - 5, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);this.total = RG.array_sum(this.data);var tot = this.total;var data = this.data;for (var i = 0, len = this.data.length; i < len; i++) {\n      var angle = data[i] / tot * RG.TWOPI;this.DrawSegment(angle, prop['chart.colors'][i], i == len - 1, i);\n    }\n    RG.NoShadow(this);if (prop['chart.linewidth'] > 0) {\n      this.DrawBorders();\n    }\n    var len = this.angles.length;var r = this.radius;for (var action = 0; action < 2; action += 1) {\n      for (var i = 0; i < len; i++) {\n        co.beginPath();var segment = this.angles[i];if (action === 1) {\n          co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' ? prop['chart.strokestyle'][i] : prop['chart.strokestyle'];\n        }\n        prop['chart.colors'][i] ? co.fillStyle = prop['chart.colors'][i] : null;co.lineJoin = 'round';co.arc(segment[2], segment[3], r, segment[0], segment[1], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(segment[2], segment[3], typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, segment[1], segment[0], true);\n        } else {\n          co.lineTo(segment[2], segment[3]);\n        }\n        co.closePath();action === 0 ? co.fill() : co.stroke();\n      }\n    }\n    if (prop['chart.labels.sticks']) {\n      this.DrawSticks();var strokeStyle = prop['chart.strokestyle'];\n    }\n    if (prop['chart.labels']) {\n      this.DrawLabels();\n    }\n    if (prop['chart.centerpin']) {\n      this.DrawCenterpin();\n    }\n    if (prop['chart.labels.ingraph']) {\n      this.DrawInGraphLabels();\n    }\n    if (!RG.isNull(prop['chart.labels.center'])) {\n      this.drawCenterLabel(prop['chart.labels.center']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.border']) {\n      co.beginPath();co.lineWidth = 5;co.strokeStyle = prop['chart.border.color'];co.arc(this.centerx, this.centery, this.radius - 2, 0, RG.TWOPI, 0);co.stroke();\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    RG.NoShadow(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.events'] == true) {\n      RG.InstallEventListeners(this);\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawSegment = this.DrawSegment = function (radians, color, last, index) {\n    if (RGraph.ISOLD && radians == RG.TWOPI) {\n      radians -= 0.0001;\n    } else if (RGraph.ISOLD && radians == 0) {\n      radians = 0.001;\n    }\n    var subTotal = this.subTotal;radians = radians * prop['chart.effect.roundrobin.multiplier'];co.beginPath();color ? co.fillStyle = color : null;co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = 0;if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    if (_typeof(prop['chart.exploded']) == 'object' && prop['chart.exploded'][index] > 0 || typeof prop['chart.exploded'] == 'number') {\n      var explosion = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][index];var x = 0;var y = 0;var h = explosion;var t = subTotal + radians / 2;var x = Math.cos(t) * explosion;var y = Math.sin(t) * explosion;var r = this.radius;co.moveTo(this.centerx + x, this.centery + y);\n    } else {\n      var x = 0;var y = 0;var r = this.radius;\n    }\n    var startAngle = subTotal;var endAngle = subTotal + radians;co.arc(this.centerx + x, this.centery + y, r, startAngle, endAngle, 0);if (prop['chart.variant'] == 'donut') {\n      co.arc(this.centerx + x, this.centery + y, typeof prop['chart.variant.donut.width'] == 'number' ? r - prop['chart.variant.donut.width'] : r / 2, endAngle, startAngle, true);\n    } else {\n      co.lineTo(this.centerx + x, this.centery + y);\n    }\n    co.closePath();this.angles.push([subTotal, subTotal + radians, this.centerx + x, this.centery + y]);co.fill();this.subTotal += radians;\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.labels'].length && prop['chart.labels.sticks.list']) {\n      return this.drawLabelsList();\n    }\n    var hAlignment = 'left',\n        vAlignment = 'center',\n        labels = prop['chart.labels'],\n        context = co,\n        font = prop['chart.text.font'],\n        bold = prop['chart.labels.bold'],\n        text_size = prop['chart.text.size'],\n        cx = this.centerx,\n        cy = this.centery,\n        r = this.radius;RG.noShadow(this);co.fillStyle = 'black';co.beginPath();if (labels && labels.length) {\n      for (i = 0; i < this.angles.length; ++i) {\n        var segment = this.angles[i];if (typeof labels[i] != 'string' && typeof labels[i] != 'number') {\n          continue;\n        }\n        co.moveTo(cx, cy);var a = segment[0] + (segment[1] - segment[0]) / 2,\n            angle = (segment[1] - segment[0]) / 2 + segment[0];if (_typeof(prop['chart.exploded']) === 'object' && prop['chart.exploded'][i] || typeof prop['chart.exploded'] == 'number') {\n          var t = (segment[1] - segment[0]) / 2,\n              seperation = typeof prop['chart.exploded'] == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i];var explosion_offsetx = Math.cos(angle) * seperation,\n              explosion_offsety = Math.sin(angle) * seperation;\n        } else {\n          var explosion_offsetx = 0,\n              explosion_offsety = 0;\n        }\n        if (prop['chart.labels.sticks']) {\n          explosion_offsetx += ma.cos(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);explosion_offsety += ma.sin(angle) * (_typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']);\n        }\n        var x = cx + explosion_offsetx + (r + 10) * Math.cos(a) + (prop['chart.labels.sticks'] ? a < RG.HALFPI || a > RG.TWOPI + RG.HALFPI ? 2 : -2 : 0),\n            y = cy + explosion_offsety + (r + 10) * Math.sin(a);if (this.coordsSticks && this.coordsSticks[i]) {\n          var x = this.coordsSticks[i][4][0] + (x < cx ? -5 : 5),\n              y = this.coordsSticks[i][4][1];\n        }\n        vAlignment = 'center';hAlignment = x < cx ? 'right' : 'left';co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels.colors']) === 'object' && prop['chart.labels.colors'] && prop['chart.labels.colors'][i]) {\n          co.fillStyle = prop['chart.labels.colors'][i];\n        }\n        RG.text2(this, { font: font, size: text_size, x: x, y: y, text: labels[i], valign: vAlignment, halign: hAlignment, tag: 'labels', bold: bold, color: prop['chart.labels.sticks.usecolors'] ? prop['chart.colors'][i] : 'black' });\n      }\n      co.fill();\n    }\n  };this.drawLabelsList = function () {\n    var segment = this.angles[i],\n        labels = prop['chart.labels'],\n        labels_right = [],\n        labels_left = [],\n        text_font = prop['chart.text.font'],\n        text_size = prop['chart.text.size'],\n        text_color = prop['chart.text.color'],\n        left = [],\n        right = [],\n        centerx = this.centerx,\n        centery = this.centery,\n        radius = this.radius,\n        offset = 50;\n    for (var i = 0; i < this.angles.length; ++i) {\n      var angle = this.angles[i][0] + (this.angles[i][1] - this.angles[i][0]) / 2,\n          endpoint_inner = RG.getRadiusEndPoint(centerx, centery, angle, radius + 5),\n          endpoint_outer = RG.getRadiusEndPoint(centerx, centery, angle, radius + 10),\n          explosion = [typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i], ma.cos(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i]), ma.sin(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i])];\n      if (_typeof(prop['chart.labels.sticks.colors']) === 'object' && prop['chart.labels.sticks.colors'] && prop['chart.labels.sticks.colors'][i]) {\n        var color = prop['chart.labels.sticks.colors'][i];\n      } else if (prop['chart.labels.sticks.usecolors'] && prop['chart.colors'][i]) {\n        var color = prop['chart.colors'][i];\n      } else {\n        var color = prop['chart.text.color'];\n      }\n      if (angle > -1 * RG.HALFPI && angle < RG.HALFPI) {\n        labels_right.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      } else {\n        labels_left.push([i, angle, labels[i] ? labels[i] : '', endpoint_inner, endpoint_outer, color, RG.arrayClone(explosion)]);\n      }\n    }\n    var vspace_right = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_right.length;\n    for (var i = 0, y = prop['chart.gutter.top'] + vspace_right / 2; i < labels_right.length; y += vspace_right, i++) {\n      if (labels_right[i][2]) {\n        var x = this.centerx + this.radius + offset,\n            idx = labels_right[i][0],\n            explosionX = labels_right[i][6][0] ? labels_right[i][6][1] : 0,\n            explosionY = labels_right[i][6][0] ? labels_right[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_right[i][2], valign: 'center', halign: 'left', tag: 'labels', color: labels_right[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_right[i][0];\n        }\n        pa2(co, 'lc round lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_right[i][3][0] + explosionX, labels_right[i][3][1] + explosionY, labels_right[i][4][0] + explosionX, labels_right[i][4][1] + explosionY, this.centerx + this.radius + 25 + explosionX, ma.round(labels_right[i][4][1] + explosionY), ret.x - 5, ret.y + ret.height / 2, labels_right[i][5]);\n      }\n    }\n    var vspace_left = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_left.length;\n    for (var i = labels_left.length - 1, y = prop['chart.gutter.top'] + vspace_left / 2; i >= 0; y += vspace_left, i--) {\n      if (labels_left[i][2]) {\n        var x = this.centerx - this.radius - offset,\n            idx = labels_left[i][0],\n            explosionX = labels_left[i][6][0] ? labels_left[i][6][1] : 0,\n            explosionY = labels_left[i][6][0] ? labels_left[i][6][2] : 0;\n        var ret = RG.text2(this, { font: text_font, size: text_size, x: x + explosionX, y: y + explosionY, text: labels_left[i][2], valign: 'center', halign: 'right', tag: 'labels', color: labels_left[i][5] });if (ret && ret.node) {\n          ret.node.__index__ = labels_left[i][0];\n        }\n        pa2(co, 'lw % b m % % l % % l % % l % % s %', prop['chart.labels.sticks.linewidth'], labels_left[i][3][0] + explosionX, labels_left[i][3][1] + explosionY, labels_left[i][4][0] + explosionX, labels_left[i][4][1] + explosionY, this.centerx - this.radius - 25 + explosionX, ma.round(labels_left[i][4][1] + explosionY), ret.x + 5 + ret.width, ret.y + ret.height / 2, labels_left[i][5]);\n      }\n    }\n  };this.drawSticks = this.DrawSticks = function () {\n    var offset = prop['chart.linewidth'] / 2,\n        exploded = prop['chart.exploded'],\n        sticks = prop['chart.labels.sticks'],\n        colors = prop['chart.colors'],\n        cx = this.centerx,\n        cy = this.centery,\n        radius = this.radius,\n        points = [],\n        linewidth = prop['chart.labels.sticks.linewidth'];\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      var segment = this.angles[i];if ((typeof sticks === 'undefined' ? 'undefined' : _typeof(sticks)) === 'object' && !sticks[i]) {\n        continue;\n      }\n      var radians = segment[1] - segment[0];co.beginPath();co.strokeStyle = typeof prop['chart.labels.sticks.colors'] === 'string' ? prop['chart.labels.sticks.colors'] : !RG.isNull(prop['chart.labels.sticks.colors']) ? prop['chart.labels.sticks.colors'][i] : 'gray';co.lineWidth = linewidth;if (typeof prop['chart.labels.sticks.color'] === 'string') {\n        co.strokeStyle = prop['chart.labels.sticks.color'];\n      }\n      if (prop['chart.labels.sticks.usecolors']) {\n        co.strokeStyle = prop['chart.colors'][i];\n      }\n      var midpoint = segment[0] + radians / 2;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && exploded[i]) {\n        var extra = exploded[i];\n      } else if (typeof exploded === 'number') {\n        var extra = exploded;\n      } else {\n        var extra = 0;\n      }\n      var stickLength = _typeof(prop['chart.labels.sticks.length']) === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length'];points[0] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + extra + offset);points[1] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra - 5);points[2] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);points[3][0] += points[3][0] > cx ? 5 : -5;points[4] = [points[2][0] + (points[2][0] > cx ? 5 + prop['chart.labels.sticks.hlength'] : -5 - prop['chart.labels.sticks.hlength']), points[2][1]];co.moveTo(points[0][0], points[0][1]);co.quadraticCurveTo(points[2][0], points[2][1], points[4][0], points[4][1]);co.stroke();this.coordsSticks[i] = [points[0], points[1], points[2], points[3], points[4]];\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.FixEventObject(e);var accuracy = arguments[1] ? arguments[1] : 0;var canvas = ca;var context = co;var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var r = this.radius;var angles = this.angles;var ret = [];for (var i = 0, len = angles.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = 'rgba(0,0,0,0)';co.arc(angles[i][2], angles[i][3], this.radius, angles[i][0], angles[i][1], false);if (this.type == 'pie' && prop['chart.variant'] == 'donut') {\n        co.arc(angles[i][2], angles[i][3], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2, angles[i][1], angles[i][0], true);\n      } else {\n        co.lineTo(angles[i][2], angles[i][3]);\n      }\n      co.closePath();if (!co.isPointInPath(mouseX, mouseY)) {\n        continue;\n      }\n      ret[0] = angles[i][2];ret[1] = angles[i][3];ret[2] = this.radius;ret[3] = angles[i][0] - RG.TWOPI;ret[4] = angles[i][1];ret[5] = i;if (ret[3] < 0) ret[3] += RG.TWOPI;if (ret[4] > RG.TWOPI) ret[4] -= RG.TWOPI;var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], ret[5]) : null;ret['object'] = this;ret['x'] = ret[0];ret['y'] = ret[1];ret['radius'] = ret[2];ret['angle.start'] = ret[3];ret['angle.end'] = ret[4];ret['index'] = ret[5];ret['tooltip'] = tooltip;return ret;\n    }\n    return null;\n  };this.drawBorders = this.DrawBorders = function () {\n    if (prop['chart.linewidth'] > 0) {\n      co.lineWidth = prop['chart.linewidth'];co.strokeStyle = prop['chart.strokestyle'];var r = this.radius;for (var i = 0, len = this.angles.length; i < len; ++i) {\n        var segment = this.angles[i];co.beginPath();co.arc(segment[2], segment[3], r, segment[0], segment[0] + 0.001, 0);co.arc(segment[2], segment[3], prop['chart.variant'] == 'donut' ? typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : r / 2 : r, segment[0], segment[0] + 0.0001, 0);co.closePath();co.stroke();\n      }\n    }\n  };this.getRadius = function () {\n    this.graph = { width: ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], height: ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'] };\n    if (typeof prop['chart.radius'] == 'number') {\n      this.radius = prop['chart.radius'];\n    } else {\n      this.radius = Math.min(this.graph.width, this.graph.height) / 2;\n    }\n    return this.radius;\n  };this.explodeSegment = this.Explode = function (index, size) {\n    if (typeof this.exploding === 'number' && this.exploding === index) {\n      return;\n    }\n    if (!prop['chart.exploded']) {\n      prop['chart.exploded'] = [];\n    }\n    if (typeof prop['chart.exploded'] == 'number') {\n      var original_explode = prop['chart.exploded'];var exploded = prop['chart.exploded'];prop['chart.exploded'] = [];for (var i = 0, len = this.data.length; i < len; ++i) {\n        prop['chart.exploded'][i] = exploded;\n      }\n    }\n    prop['chart.exploded'][index] = typeof original_explode == 'number' ? original_explode : 0;this.exploding = index;var delay = RG.ISIE && !RG.ISIE10 ? 25 : 16.666;for (var o = 0; o < size; ++o) {\n      setTimeout(function () {\n        prop['chart.exploded'][index] += 1;RG.Clear(ca);RG.RedrawCanvas(ca);\n      }, o * delay);\n    }\n    var obj = this;setTimeout(function () {\n      obj.exploding = null;\n    }, size * delay);\n  };this.highlight_segment = function (segment) {\n    co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];co.moveTo(segment[0], segment[1]);co.arc(segment[0], segment[1], segment[2], this.angles[segment[5]][0], this.angles[segment[5]][1], 0);co.lineTo(segment[0], segment[1]);co.closePath();co.stroke();co.fill();\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);\n      } else if (prop['chart.highlight.style'] == '3d') {\n        co.lineWidth = 1;var extent = 2;co.beginPath();RG.NoShadow(this);co.fillStyle = 'rgba(0,0,0,0)';co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'], shape['y'], shape['radius'] / 5, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.fill();co.beginPath();co.shadowColor = '#666';co.shadowBlur = 3;co.shadowOffsetX = 3;co.shadowOffsetY = 3;co.fillStyle = prop['chart.colors'][shape['index']];co.strokeStyle = prop['chart.strokestyle'];co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'], shape['angle.start'], shape['angle.end'], false);if (prop['chart.variant'] == 'donut') {\n          co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.lineTo(shape['x'] - extent, shape['y'] - extent);\n        }\n        co.closePath();co.stroke();co.fill();RG.NoShadow(this);if (prop['chart.border']) {\n          co.beginPath();co.strokeStyle = prop['chart.border.color'];co.lineWidth = 5;co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] - 2, shape['angle.start'], shape['angle.end'], false);co.stroke();\n        }\n      } else if (prop['chart.highlight.style'] === 'outline') {\n        var tooltip = RG.Registry.get('chart.tooltip'),\n            index = tooltip.__index__,\n            coords = this.angles[index],\n            color = this.get('colors')[index];\n        width = this.radius / 12.5;if (typeof prop['chart.highlight.style.outline.width'] === 'number') {\n          width = prop['chart.highlight.style.outline.width'];\n        }\n        RGraph.path2(co, 'ga 0.25 b a % % % % % false a % % % % % true c f % ga 1', coords[2], coords[3], this.radius + 2 + width, coords[0], coords[1], coords[2], coords[3], this.radius + 2, coords[1], coords[0], color);\n      } else {\n        co.beginPath();co.strokeStyle = prop['chart.highlight.style.twod.stroke'];co.fillStyle = prop['chart.highlight.style.twod.fill'];if (prop['chart.variant'].indexOf('donut') > -1) {\n          co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);co.arc(shape['x'], shape['y'], typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\n        } else {\n          co.arc(shape['x'], shape['y'], shape['radius'] + 1, shape['angle.start'], shape['angle.end'], false);co.lineTo(shape['x'], shape['y']);\n        }\n        co.closePath();co.stroke();co.fill();\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    if (this.getShape(e)) {\n      return this;\n    }\n  };this.drawCenterpin = this.DrawCenterpin = function () {\n    if (typeof prop['chart.centerpin'] == 'number' && prop['chart.centerpin'] > 0) {\n      var cx = this.centerx;var cy = this.centery;co.beginPath();co.strokeStyle = prop['chart.centerpin.stroke'] ? prop['chart.centerpin.stroke'] : prop['chart.strokestyle'];co.fillStyle = prop['chart.centerpin.fill'] ? prop['chart.centerpin.fill'] : prop['chart.strokestyle'];co.moveTo(cx, cy);co.arc(cx, cy, prop['chart.centerpin'], 0, RG.TWOPI, false);co.stroke();co.fill();\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function () {\n    var context = co;var cx = this.centerx;var cy = this.centery;var radius = prop['chart.labels.ingraph.radius'];if (radius <= 2 && radius > 0) {\n      radiusFactor = radius;\n    } else {\n      radiusFactor = 0.5;\n    }\n    if (prop['chart.variant'] == 'donut') {\n      var r = this.radius * (0.5 + radiusFactor * 0.5);if (typeof prop['chart.variant.donut.width'] == 'number') {\n        var r = this.radius - prop['chart.variant.donut.width'] + prop['chart.variant.donut.width'] / 2;\n      }\n    } else {\n      var r = this.radius * radiusFactor;\n    }\n    if (radius > 2) {\n      r = radius;\n    }\n    for (var i = 0, len = this.angles.length; i < len; ++i) {\n      if (_typeof(prop['chart.exploded']) == 'object' && typeof prop['chart.exploded'][i] == 'number') {\n        var explosion = prop['chart.exploded'][i];\n      } else if (typeof prop['chart.exploded'] == 'number') {\n        var explosion = parseInt(prop['chart.exploded']);\n      } else {\n        var explosion = 0;\n      }\n      var angleStart = this.angles[i][0];var angleEnd = this.angles[i][1];var angleCenter = (angleEnd - angleStart) / 2 + angleStart;var coords = RG.getRadiusEndPoint(this.centerx, this.centery, angleCenter, r + (explosion ? explosion : 0));var x = coords[0];var y = coords[1];var text = prop['chart.labels.ingraph.specific'] && typeof prop['chart.labels.ingraph.specific'][i] == 'string' ? prop['chart.labels.ingraph.specific'][i] : RG.number_format(this, this.data[i], prop['chart.labels.ingraph.units.pre'], prop['chart.labels.ingraph.units.post']);if (text) {\n        co.beginPath();var font = typeof prop['chart.labels.ingraph.font'] === 'string' ? prop['chart.labels.ingraph.font'] : prop['chart.text.font'];var size = typeof prop['chart.labels.ingraph.size'] === 'number' ? prop['chart.labels.ingraph.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.labels.ingraph.color'] ? prop['chart.labels.ingraph.color'] : 'black';RG.Text2(this, { 'font': font, 'size': size, 'x': x, 'y': y, 'text': text, 'valign': 'center', 'halign': 'center', 'bounding': prop['chart.labels.ingraph.bounding'], 'bounding.fill': prop['chart.labels.ingraph.bounding.fill'], 'tag': 'labels.ingraph' });co.stroke();\n      }\n    }\n  };this.drawCenterLabel = function (label) {\n    var font = prop['chart.labels.center.font'],\n        size = prop['chart.labels.center.size'],\n        color = prop['chart.labels.center.color'],\n        unitsPre = prop['chart.labels.center.units.pre'],\n        unitsPost = prop['chart.labels.center.units.post'],\n        bold = prop['chart.labels.center.bold'],\n        italic = prop['chart.labels.center.italic'];RG.text2(this, { color: color, bold: bold, italic: italic, font: font, size: size, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', text: RG.numberFormat(this, label, unitsPre, unitsPost) });\n  };\n  this.getAngle = function (value) {\n    if (value > this.total) {\n      return null;\n    }\n    var angle = value / this.total * RG.TWOPI;angle += prop['chart.origin'];return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.arrayClone(prop['chart.key.colors']);this.original_colors['chart.strokestyle'] = RG.arrayClone(prop['chart.strokestyle']);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.style.twod.fill'] = RG.arrayClone(prop['chart.highlight.style.twod.fill']);this.original_colors['chart.highlight.style.twod.stroke'] = RG.arrayClone(prop['chart.highlight.style.twod.stroke']);this.original_colors['chart.ingraph.bounding.fill'] = RG.arrayClone(prop['chart.ingraph.bounding.fill']);this.original_colors['chart.ingraph.color'] = RG.arrayClone(prop['chart.ingraph.color']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (keyColors) {\n      for (var i = 0; i < keyColors.length; ++i) {\n        keyColors[i] = this.parseSingleColorForGradient(keyColors[i]);\n      }\n    }\n    prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.style.twod.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.fill']);prop['chart.highlight.style.twod.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.stroke']);prop['chart.labels.ingraph.bounding.fill'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.bounding.fill']);prop['chart.labels.ingraph.color'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');if (prop['chart.variant'] == 'donut') {\n        var radius_start = typeof prop['chart.variant.donut.width'] == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2;\n      } else {\n        var radius_start = 0;\n      }\n      var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, Math.min(ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / 2);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.angles && this.angles[index]) {\n      var segment = this.angles[index];var x = segment[2];var y = segment[3];var start = segment[0];var end = segment[1];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.lineWidth = 2;co.lineJoin = 'bevel';co.beginPath();co.moveTo(x, y);co.arc(x, y, this.radius, start, end, false);co.closePath();co.fill();co.stroke();\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.draw3d = function () {\n    var scaleX = 1.5,\n        depth = prop['chart.variant.threed.depth'],\n        prop_shadow = prop['chart.shadow'],\n        prop_labels = prop['chart.labels'],\n        prop_labelsSticks = prop['chart.labels.sticks'];\n    this.set({ labels: [], labelsSticks: false, strokestyle: 'rgba(0,0,0,0)' });this.set({ variant: this.get('variant').replace(/3d/, '') });this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);for (var i = depth; i > 0; i -= 1) {\n      this.set({ centeryAdjust: i });if (i === parseInt(depth / 2)) {\n        this.set({ labels: prop_labels, labelsSticks: prop_labelsSticks });\n      }\n      if (i === 0) {\n        this.set({ shadow: prop_shadow });\n      }\n      this.draw();this.set('shadow', false);if (i <= parseInt(depth / 2)) {\n        this.set({ labels: [], labelsSticks: false });\n      }\n      if (i > 1) {\n        if (prop['chart.variant'].indexOf('donut') !== -1) {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'a', this.angles[j][2], this.angles[j][3], this.radius / 2, this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], this.angles[j][0], true, 'f', 'rgba(0,0,0,0.15)']);\n          }\n        } else {\n          for (var j = 0; j < this.angles.length; ++j) {\n            pa2(co, ['b', 'm', this.angles[j][2], this.angles[j][3], 'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false, 'c', 'f', 'rgba(0,0,0,0.15)']);\n          }\n        }\n      }\n    }\n    this.set({ variant: this.get('variant') + '3d', shadow: prop_shadow, labels: prop_labels, labelsSticks: prop_labelsSticks });return this;\n  };this.explode = function () {\n    var obj = this;var opt = arguments[0] ? arguments[0] : {};var callback = arguments[1] ? arguments[1] : function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var maxExplode = Number(typeof opt.radius === 'number' ? opt.radius : ma.max(ca.width, ca.height));var currentExplode = Number(obj.get('exploded')) || 0;var step = (maxExplode - currentExplode) / frames;var iterator = function iterator() {\n      obj.set('exploded', currentExplode + step * frame);RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    };\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames || 30;var frame = 0;var callback = arguments[1] ? arguments[1] : function () {};var radius = obj.getRadius();prop['chart.radius'] = 0;var iterator = function iterator() {\n      obj.set('chart.radius', frame / frames * radius);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frame = 0,\n        frames = opt.frames || 30,\n        radius = obj.getRadius(),\n        labels = obj.get('labels');\n    obj.Set('chart.events', false);obj.Set('chart.labels', []);var iterator = function iterator() {\n      obj.set('effect.roundrobin.multiplier', RG.Effects.getEasingMultiplier(frames, frame));RGraph.redrawCanvas(ca);if (frame++ < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        obj.set({ events: true, labels: labels });RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);this.implode = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        callback = arguments[1] || function () {},\n        frames = opt.frames || 30,\n        frame = 0,\n        explodedMax = ma.max(ca.width, ca.height),\n        exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5waWUuanM/NmE1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5QaWUgPSBmdW5jdGlvbiAoY29uZikge1xuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGlkID0gY29uZi5pZCxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgICBkYXRhID0gY29uZi5kYXRhLFxuICAgICAgICBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWQgPSBjb25mLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGlkO3RoaXMuY2FudmFzID0gY2FudmFzO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQgPyB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaWQpKSA9PT0gJ29iamVjdCcgJiYgaWQuYWxwaGEgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlIH0pIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnRvdGFsID0gMDt0aGlzLnN1YlRvdGFsID0gMDt0aGlzLmFuZ2xlcyA9IFtdO3RoaXMuZGF0YSA9IGRhdGE7dGhpcy5wcm9wZXJ0aWVzID0gW107dGhpcy50eXBlID0gJ3BpZSc7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkcy5rZXkgPSBbXTt0aGlzLmNvb3Jkc1N0aWNrcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMuZXhwbG9kaW5nID0gbnVsbDtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5kYXRhW2ldID0gcGFyc2VGbG9hdCh0aGlzLmRhdGFbaV0pO1xuICAgIH1cbiAgfVxuICB0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5jZW50ZXJ4LmFkanVzdCc6IDAsICdjaGFydC5jZW50ZXJ5LmFkanVzdCc6IDAsICdjaGFydC5jb2xvcnMnOiBbJ3JlZCcsICcjY2NjJywgJyNjZmMnLCAnYmx1ZScsICdwaW5rJywgJ3llbGxvdycsICdibGFjaycsICdvcmFuZ2UnLCAnY3lhbicsICdwdXJwbGUnLCAnIzc4Q0FFQScsICcjRTI4NEU5JywgJ3doaXRlJywgJ2JsdWUnLCAnIzlFN0JGNiddLCAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAnd2hpdGUnLCAnY2hhcnQubGluZXdpZHRoJzogMywgJ2NoYXJ0LmxhYmVscyc6IFtdLCAnY2hhcnQubGFiZWxzLmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5zdGlja3MnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJzogNywgJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5zdGlja3MudXNlY29sb3JzJzogdHJ1ZSwgJ2NoYXJ0LmxhYmVscy5zdGlja3MubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmxhYmVscy5zdGlja3MuaGxlbmd0aCc6IDUsICdjaGFydC5sYWJlbHMuc3RpY2tzLmxpc3QnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5pbmdyYXBoJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmZvbnQnOiBudWxsLCAnY2hhcnQubGFiZWxzLmluZ3JhcGguc2l6ZSc6IG51bGwsICdjaGFydC5sYWJlbHMuaW5ncmFwaC5ib3VuZGluZyc6IHRydWUsICdjaGFydC5sYWJlbHMuaW5ncmFwaC5ib3VuZGluZy5maWxsJzogJ3doaXRlJywgJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnNwZWNpZmljJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnByZSc6ICcnLCAnY2hhcnQubGFiZWxzLmluZ3JhcGgudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQubGFiZWxzLmluZ3JhcGgucmFkaXVzJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5jZW50ZXInOiBudWxsLCAnY2hhcnQubGFiZWxzLmNlbnRlci5zaXplJzogMjYsICdjaGFydC5sYWJlbHMuY2VudGVyLmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LmxhYmVscy5jZW50ZXIuY29sb3InOiAnYmxhY2snLCAnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5jZW50ZXIuYm9sZCc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LmxhYmVscy5jZW50ZXIudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogMC41LCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLngnOiBudWxsLCAnY2hhcnQudGl0bGUueSc6IG51bGwsICdjaGFydC50aXRsZS5oYWxpZ24nOiBudWxsLCAnY2hhcnQudGl0bGUudmFsaWduJzogbnVsbCwgJ2NoYXJ0LnNoYWRvdyc6IHRydWUsICdjaGFydC5zaGFkb3cuY29sb3InOiAnI2FhYScsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDAsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDAsICdjaGFydC5zaGFkb3cuYmx1cic6IDE1LCAnY2hhcnQudGV4dC5zaXplJzogMTIsICdjaGFydC50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRleHQuZm9udCc6ICdTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6ICd2aXNpYmxlJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzogdHJ1ZSwgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzogJ2ZhZGUnLCAnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzogJ1JHcmFwaF90b29sdGlwJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC5oaWdobGlnaHQuc3R5bGUnOiAnMmQnLCAnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5oaWdobGlnaHQuc3R5bGUub3V0bGluZS53aWR0aCc6IG51bGwsICdjaGFydC5jZW50ZXJ4JzogbnVsbCwgJ2NoYXJ0LmNlbnRlcnknOiBudWxsLCAnY2hhcnQucmFkaXVzJzogbnVsbCwgJ2NoYXJ0LmJvcmRlcic6IGZhbHNlLCAnY2hhcnQuYm9yZGVyLmNvbG9yJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC41KScsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOiAnYmxhY2snLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJzogJ3JnYmEoMjU1LDAsMCwwLjIpJywgJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycsICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uaGRpcic6ICdyaWdodCcsICdjaGFydC56b29tLnZkaXInOiAnZG93bicsICdjaGFydC56b29tLmZyYW1lcyc6IDI1LCAnY2hhcnQuem9vbS5kZWxheSc6IDE2LjY2NiwgJ2NoYXJ0Lnpvb20uc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6IHRydWUsICdjaGFydC56b29tLmFjdGlvbic6ICd6b29tJywgJ2NoYXJ0LnJlc2l6YWJsZSc6IGZhbHNlLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOiBbMCwgMF0sICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudmFyaWFudCc6ICdwaWUnLCAnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCc6IG51bGwsICdjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCc6IDIwLCAnY2hhcnQuZXhwbG9kZWQnOiBbXSwgJ2NoYXJ0LmVmZmVjdC5yb3VuZHJvYmluLm11bHRpcGxpZXInOiAxLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQuY2VudGVycGluJzogbnVsbCwgJ2NoYXJ0LmNlbnRlcnBpbi5maWxsJzogJ2dyYXknLCAnY2hhcnQuY2VudGVycGluLnN0cm9rZSc6ICd3aGl0ZScsICdjaGFydC5vcmlnaW4nOiAwIC0gTWF0aC5QSSAvIDIsICdjaGFydC5ldmVudHMnOiB0cnVlLCAnY2hhcnQubGFiZWxzLmNvbG9ycyc6IFtdLCAnY2hhcnQuY2xlYXJ0byc6ICdyZ2JhKDAsMCwwLDApJyB9O1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRoaXMudG90YWwgKz0gZGF0YVtpXTt0aGlzWyckJyArIGldID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmNvbG9yJykge1xuICAgICAgbmFtZSA9ICdjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LmxhYmVscy5zcGFjZWQnKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LmxhYmVscy5zdGlja3MubGlzdCc7XG4gICAgfVxuICAgIHByb3BbbmFtZV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5jb2xvcicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMucmFkaXVzID0gdGhpcy5nZXRSYWRpdXMoKTt0aGlzLmNlbnRlcnggPSB0aGlzLmdyYXBoLndpZHRoIC8gMiArIHRoaXMuZ3V0dGVyTGVmdCArIHByb3BbJ2NoYXJ0LmNlbnRlcnguYWRqdXN0J107dGhpcy5jZW50ZXJ5ID0gdGhpcy5ncmFwaC5oZWlnaHQgLyAyICsgdGhpcy5ndXR0ZXJUb3AgKyBwcm9wWydjaGFydC5jZW50ZXJ5LmFkanVzdCddO3RoaXMuc3ViVG90YWwgPSB0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0Lm9yaWdpbiddO3RoaXMuYW5nbGVzID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5yYWRpdXMnXSA9PT0gJ251bWJlcicpIHRoaXMucmFkaXVzID0gcHJvcFsnY2hhcnQucmFkaXVzJ107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ4J10gPT09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT09ICdudW1iZXInKSB0aGlzLmNlbnRlcnkgPSBwcm9wWydjaGFydC5jZW50ZXJ5J107aWYgKHRoaXMucmFkaXVzIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXS5sZW5ndGggPCBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGgpIHtcbiAgICAgIHdoaWxlIChwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10ubGVuZ3RoIDwgcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXS5wdXNoKHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXVtwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10ubGVuZ3RoIC0gMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAocHJvcFsnY2hhcnQubGFiZWxzLmNvbG9ycyddLmxlbmd0aCA8IHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCkge1xuICAgICAgICBwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ10ucHVzaChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJzNkJykgPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3M2QoKTtcbiAgICB9XG4gICAgUkcuRHJhd1RpdGxlKHRoaXMsIHByb3BbJ2NoYXJ0LnRpdGxlJ10sIGNhLmhlaWdodCAvIDIgLSB0aGlzLnJhZGl1cyAtIDUsIHRoaXMuY2VudGVyeCwgcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddID8gcHJvcFsnY2hhcnQudGl0bGUuc2l6ZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyKTt0aGlzLnRvdGFsID0gUkcuYXJyYXlfc3VtKHRoaXMuZGF0YSk7dmFyIHRvdCA9IHRoaXMudG90YWw7dmFyIGRhdGEgPSB0aGlzLmRhdGE7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFuZ2xlID0gZGF0YVtpXSAvIHRvdCAqIFJHLlRXT1BJO3RoaXMuRHJhd1NlZ21lbnQoYW5nbGUsIHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldLCBpID09IGxlbiAtIDEsIGkpO1xuICAgIH1cbiAgICBSRy5Ob1NoYWRvdyh0aGlzKTtpZiAocHJvcFsnY2hhcnQubGluZXdpZHRoJ10gPiAwKSB7XG4gICAgICB0aGlzLkRyYXdCb3JkZXJzKCk7XG4gICAgfVxuICAgIHZhciBsZW4gPSB0aGlzLmFuZ2xlcy5sZW5ndGg7dmFyIHIgPSB0aGlzLnJhZGl1cztmb3IgKHZhciBhY3Rpb24gPSAwOyBhY3Rpb24gPCAyOyBhY3Rpb24gKz0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjby5iZWdpblBhdGgoKTt2YXIgc2VnbWVudCA9IHRoaXMuYW5nbGVzW2ldO2lmIChhY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICBjby5zdHJva2VTdHlsZSA9IF90eXBlb2YocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSkgPT0gJ29iamVjdCcgPyBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddW2ldIDogcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wWydjaGFydC5jb2xvcnMnXVtpXSA/IGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldIDogbnVsbDtjby5saW5lSm9pbiA9ICdyb3VuZCc7Y28uYXJjKHNlZ21lbnRbMl0sIHNlZ21lbnRbM10sIHIsIHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0sIGZhbHNlKTtpZiAocHJvcFsnY2hhcnQudmFyaWFudCddID09ICdkb251dCcpIHtcbiAgICAgICAgICBjby5hcmMoc2VnbWVudFsyXSwgc2VnbWVudFszXSwgdHlwZW9mIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA9PSAnbnVtYmVyJyA/IHIgLSBwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10gOiByIC8gMiwgc2VnbWVudFsxXSwgc2VnbWVudFswXSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28ubGluZVRvKHNlZ21lbnRbMl0sIHNlZ21lbnRbM10pO1xuICAgICAgICB9XG4gICAgICAgIGNvLmNsb3NlUGF0aCgpO2FjdGlvbiA9PT0gMCA/IGNvLmZpbGwoKSA6IGNvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddKSB7XG4gICAgICB0aGlzLkRyYXdTdGlja3MoKTt2YXIgc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzJ10pIHtcbiAgICAgIHRoaXMuRHJhd0xhYmVscygpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuY2VudGVycGluJ10pIHtcbiAgICAgIHRoaXMuRHJhd0NlbnRlcnBpbigpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGgnXSkge1xuICAgICAgdGhpcy5EcmF3SW5HcmFwaExhYmVscygpO1xuICAgIH1cbiAgICBpZiAoIVJHLmlzTnVsbChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pKSB7XG4gICAgICB0aGlzLmRyYXdDZW50ZXJMYWJlbChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSkge1xuICAgICAgUkcuU2hvd0NvbnRleHQodGhpcyk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubGluZVdpZHRoID0gNTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmJvcmRlci5jb2xvciddO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMgLSAyLCAwLCBSRy5UV09QSSwgMCk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5rZXknXSAmJiBwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywgcHJvcFsnY2hhcnQua2V5J10sIHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgUkcuTm9TaGFkb3codGhpcyk7aWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuZXZlbnRzJ10gPT0gdHJ1ZSkge1xuICAgICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdTZWdtZW50ID0gdGhpcy5EcmF3U2VnbWVudCA9IGZ1bmN0aW9uIChyYWRpYW5zLCBjb2xvciwgbGFzdCwgaW5kZXgpIHtcbiAgICBpZiAoUkdyYXBoLklTT0xEICYmIHJhZGlhbnMgPT0gUkcuVFdPUEkpIHtcbiAgICAgIHJhZGlhbnMgLT0gMC4wMDAxO1xuICAgIH0gZWxzZSBpZiAoUkdyYXBoLklTT0xEICYmIHJhZGlhbnMgPT0gMCkge1xuICAgICAgcmFkaWFucyA9IDAuMDAxO1xuICAgIH1cbiAgICB2YXIgc3ViVG90YWwgPSB0aGlzLnN1YlRvdGFsO3JhZGlhbnMgPSByYWRpYW5zICogcHJvcFsnY2hhcnQuZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllciddO2NvLmJlZ2luUGF0aCgpO2NvbG9yID8gY28uZmlsbFN0eWxlID0gY29sb3IgOiBudWxsO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGggPSAwO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcuc2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICB9XG4gICAgaWYgKF90eXBlb2YocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpbmRleF0gPiAwIHx8IHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddID09ICdudW1iZXInKSB7XG4gICAgICB2YXIgZXhwbG9zaW9uID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10gPT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5leHBsb2RlZCddIDogcHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpbmRleF07dmFyIHggPSAwO3ZhciB5ID0gMDt2YXIgaCA9IGV4cGxvc2lvbjt2YXIgdCA9IHN1YlRvdGFsICsgcmFkaWFucyAvIDI7dmFyIHggPSBNYXRoLmNvcyh0KSAqIGV4cGxvc2lvbjt2YXIgeSA9IE1hdGguc2luKHQpICogZXhwbG9zaW9uO3ZhciByID0gdGhpcy5yYWRpdXM7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCArIHgsIHRoaXMuY2VudGVyeSArIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeCA9IDA7dmFyIHkgPSAwO3ZhciByID0gdGhpcy5yYWRpdXM7XG4gICAgfVxuICAgIHZhciBzdGFydEFuZ2xlID0gc3ViVG90YWw7dmFyIGVuZEFuZ2xlID0gc3ViVG90YWwgKyByYWRpYW5zO2NvLmFyYyh0aGlzLmNlbnRlcnggKyB4LCB0aGlzLmNlbnRlcnkgKyB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgMCk7aWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnZG9udXQnKSB7XG4gICAgICBjby5hcmModGhpcy5jZW50ZXJ4ICsgeCwgdGhpcy5jZW50ZXJ5ICsgeSwgdHlwZW9mIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA9PSAnbnVtYmVyJyA/IHIgLSBwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10gOiByIC8gMiwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjby5saW5lVG8odGhpcy5jZW50ZXJ4ICsgeCwgdGhpcy5jZW50ZXJ5ICsgeSk7XG4gICAgfVxuICAgIGNvLmNsb3NlUGF0aCgpO3RoaXMuYW5nbGVzLnB1c2goW3N1YlRvdGFsLCBzdWJUb3RhbCArIHJhZGlhbnMsIHRoaXMuY2VudGVyeCArIHgsIHRoaXMuY2VudGVyeSArIHldKTtjby5maWxsKCk7dGhpcy5zdWJUb3RhbCArPSByYWRpYW5zO1xuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoICYmIHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGlzdCddKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3TGFiZWxzTGlzdCgpO1xuICAgIH1cbiAgICB2YXIgaEFsaWdubWVudCA9ICdsZWZ0JyxcbiAgICAgICAgdkFsaWdubWVudCA9ICdjZW50ZXInLFxuICAgICAgICBsYWJlbHMgPSBwcm9wWydjaGFydC5sYWJlbHMnXSxcbiAgICAgICAgY29udGV4dCA9IGNvLFxuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIGJvbGQgPSBwcm9wWydjaGFydC5sYWJlbHMuYm9sZCddLFxuICAgICAgICB0ZXh0X3NpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgY3ggPSB0aGlzLmNlbnRlcngsXG4gICAgICAgIGN5ID0gdGhpcy5jZW50ZXJ5LFxuICAgICAgICByID0gdGhpcy5yYWRpdXM7Ukcubm9TaGFkb3codGhpcyk7Y28uZmlsbFN0eWxlID0gJ2JsYWNrJztjby5iZWdpblBhdGgoKTtpZiAobGFiZWxzICYmIGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFuZ2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRoaXMuYW5nbGVzW2ldO2lmICh0eXBlb2YgbGFiZWxzW2ldICE9ICdzdHJpbmcnICYmIHR5cGVvZiBsYWJlbHNbaV0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjby5tb3ZlVG8oY3gsIGN5KTt2YXIgYSA9IHNlZ21lbnRbMF0gKyAoc2VnbWVudFsxXSAtIHNlZ21lbnRbMF0pIC8gMixcbiAgICAgICAgICAgIGFuZ2xlID0gKHNlZ21lbnRbMV0gLSBzZWdtZW50WzBdKSAvIDIgKyBzZWdtZW50WzBdO2lmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pID09PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5leHBsb2RlZCddW2ldIHx8IHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddID09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFyIHQgPSAoc2VnbWVudFsxXSAtIHNlZ21lbnRbMF0pIC8gMixcbiAgICAgICAgICAgICAgc2VwZXJhdGlvbiA9IHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA6IHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV07dmFyIGV4cGxvc2lvbl9vZmZzZXR4ID0gTWF0aC5jb3MoYW5nbGUpICogc2VwZXJhdGlvbixcbiAgICAgICAgICAgICAgZXhwbG9zaW9uX29mZnNldHkgPSBNYXRoLnNpbihhbmdsZSkgKiBzZXBlcmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBleHBsb3Npb25fb2Zmc2V0eCA9IDAsXG4gICAgICAgICAgICAgIGV4cGxvc2lvbl9vZmZzZXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddKSB7XG4gICAgICAgICAgZXhwbG9zaW9uX29mZnNldHggKz0gbWEuY29zKGFuZ2xlKSAqIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ10pID09PSAnb2JqZWN0JyA/IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ11baV0gOiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmxlbmd0aCddKTtleHBsb3Npb25fb2Zmc2V0eSArPSBtYS5zaW4oYW5nbGUpICogKF90eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXSkgPT09ICdvYmplY3QnID8gcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXVtpXSA6IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gY3ggKyBleHBsb3Npb25fb2Zmc2V0eCArIChyICsgMTApICogTWF0aC5jb3MoYSkgKyAocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcyddID8gYSA8IFJHLkhBTEZQSSB8fCBhID4gUkcuVFdPUEkgKyBSRy5IQUxGUEkgPyAyIDogLTIgOiAwKSxcbiAgICAgICAgICAgIHkgPSBjeSArIGV4cGxvc2lvbl9vZmZzZXR5ICsgKHIgKyAxMCkgKiBNYXRoLnNpbihhKTtpZiAodGhpcy5jb29yZHNTdGlja3MgJiYgdGhpcy5jb29yZHNTdGlja3NbaV0pIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuY29vcmRzU3RpY2tzW2ldWzRdWzBdICsgKHggPCBjeCA/IC01IDogNSksXG4gICAgICAgICAgICAgIHkgPSB0aGlzLmNvb3Jkc1N0aWNrc1tpXVs0XVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2QWxpZ25tZW50ID0gJ2NlbnRlcic7aEFsaWdubWVudCA9IHggPCBjeCA/ICdyaWdodCcgOiAnbGVmdCc7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2lmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSkgPT09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvcnMnXSAmJiBwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ11baV0pIHtcbiAgICAgICAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3JzJ11baV07XG4gICAgICAgIH1cbiAgICAgICAgUkcudGV4dDIodGhpcywgeyBmb250OiBmb250LCBzaXplOiB0ZXh0X3NpemUsIHg6IHgsIHk6IHksIHRleHQ6IGxhYmVsc1tpXSwgdmFsaWduOiB2QWxpZ25tZW50LCBoYWxpZ246IGhBbGlnbm1lbnQsIHRhZzogJ2xhYmVscycsIGJvbGQ6IGJvbGQsIGNvbG9yOiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLnVzZWNvbG9ycyddID8gcHJvcFsnY2hhcnQuY29sb3JzJ11baV0gOiAnYmxhY2snIH0pO1xuICAgICAgfVxuICAgICAgY28uZmlsbCgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdMYWJlbHNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWdtZW50ID0gdGhpcy5hbmdsZXNbaV0sXG4gICAgICAgIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscyddLFxuICAgICAgICBsYWJlbHNfcmlnaHQgPSBbXSxcbiAgICAgICAgbGFiZWxzX2xlZnQgPSBbXSxcbiAgICAgICAgdGV4dF9mb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICB0ZXh0X2NvbG9yID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddLFxuICAgICAgICBsZWZ0ID0gW10sXG4gICAgICAgIHJpZ2h0ID0gW10sXG4gICAgICAgIGNlbnRlcnggPSB0aGlzLmNlbnRlcngsXG4gICAgICAgIGNlbnRlcnkgPSB0aGlzLmNlbnRlcnksXG4gICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICBvZmZzZXQgPSA1MDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5nbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlc1tpXVswXSArICh0aGlzLmFuZ2xlc1tpXVsxXSAtIHRoaXMuYW5nbGVzW2ldWzBdKSAvIDIsXG4gICAgICAgICAgZW5kcG9pbnRfaW5uZXIgPSBSRy5nZXRSYWRpdXNFbmRQb2ludChjZW50ZXJ4LCBjZW50ZXJ5LCBhbmdsZSwgcmFkaXVzICsgNSksXG4gICAgICAgICAgZW5kcG9pbnRfb3V0ZXIgPSBSRy5nZXRSYWRpdXNFbmRQb2ludChjZW50ZXJ4LCBjZW50ZXJ5LCBhbmdsZSwgcmFkaXVzICsgMTApLFxuICAgICAgICAgIGV4cGxvc2lvbiA9IFt0eXBlb2YgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5leHBsb2RlZCddIDogcHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpXSwgbWEuY29zKGFuZ2xlKSAqICh0eXBlb2YgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5leHBsb2RlZCddIDogcHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpXSksIG1hLnNpbihhbmdsZSkgKiAodHlwZW9mIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10gPT09ICdudW1iZXInID8gcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA6IHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baV0pXTtcbiAgICAgIGlmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJ10pID09PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddICYmIHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJ11baV0pIHtcbiAgICAgICAgdmFyIGNvbG9yID0gcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5jb2xvcnMnXVtpXTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy51c2Vjb2xvcnMnXSAmJiBwcm9wWydjaGFydC5jb2xvcnMnXVtpXSkge1xuICAgICAgICB2YXIgY29sb3IgPSBwcm9wWydjaGFydC5jb2xvcnMnXVtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb2xvciA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmdsZSA+IC0xICogUkcuSEFMRlBJICYmIGFuZ2xlIDwgUkcuSEFMRlBJKSB7XG4gICAgICAgIGxhYmVsc19yaWdodC5wdXNoKFtpLCBhbmdsZSwgbGFiZWxzW2ldID8gbGFiZWxzW2ldIDogJycsIGVuZHBvaW50X2lubmVyLCBlbmRwb2ludF9vdXRlciwgY29sb3IsIFJHLmFycmF5Q2xvbmUoZXhwbG9zaW9uKV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxzX2xlZnQucHVzaChbaSwgYW5nbGUsIGxhYmVsc1tpXSA/IGxhYmVsc1tpXSA6ICcnLCBlbmRwb2ludF9pbm5lciwgZW5kcG9pbnRfb3V0ZXIsIGNvbG9yLCBSRy5hcnJheUNsb25lKGV4cGxvc2lvbildKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZzcGFjZV9yaWdodCA9IChjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ10gLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10pIC8gbGFiZWxzX3JpZ2h0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgeSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSArIHZzcGFjZV9yaWdodCAvIDI7IGkgPCBsYWJlbHNfcmlnaHQubGVuZ3RoOyB5ICs9IHZzcGFjZV9yaWdodCwgaSsrKSB7XG4gICAgICBpZiAobGFiZWxzX3JpZ2h0W2ldWzJdKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgKyBvZmZzZXQsXG4gICAgICAgICAgICBpZHggPSBsYWJlbHNfcmlnaHRbaV1bMF0sXG4gICAgICAgICAgICBleHBsb3Npb25YID0gbGFiZWxzX3JpZ2h0W2ldWzZdWzBdID8gbGFiZWxzX3JpZ2h0W2ldWzZdWzFdIDogMCxcbiAgICAgICAgICAgIGV4cGxvc2lvblkgPSBsYWJlbHNfcmlnaHRbaV1bNl1bMF0gPyBsYWJlbHNfcmlnaHRbaV1bNl1bMl0gOiAwO1xuICAgICAgICB2YXIgcmV0ID0gUkcudGV4dDIodGhpcywgeyBmb250OiB0ZXh0X2ZvbnQsIHNpemU6IHRleHRfc2l6ZSwgeDogeCArIGV4cGxvc2lvblgsIHk6IHkgKyBleHBsb3Npb25ZLCB0ZXh0OiBsYWJlbHNfcmlnaHRbaV1bMl0sIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogJ2xlZnQnLCB0YWc6ICdsYWJlbHMnLCBjb2xvcjogbGFiZWxzX3JpZ2h0W2ldWzVdIH0pO2lmIChyZXQgJiYgcmV0Lm5vZGUpIHtcbiAgICAgICAgICByZXQubm9kZS5fX2luZGV4X18gPSBsYWJlbHNfcmlnaHRbaV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgcGEyKGNvLCAnbGMgcm91bmQgbHcgJSBiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsIHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGluZXdpZHRoJ10sIGxhYmVsc19yaWdodFtpXVszXVswXSArIGV4cGxvc2lvblgsIGxhYmVsc19yaWdodFtpXVszXVsxXSArIGV4cGxvc2lvblksIGxhYmVsc19yaWdodFtpXVs0XVswXSArIGV4cGxvc2lvblgsIGxhYmVsc19yaWdodFtpXVs0XVsxXSArIGV4cGxvc2lvblksIHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzICsgMjUgKyBleHBsb3Npb25YLCBtYS5yb3VuZChsYWJlbHNfcmlnaHRbaV1bNF1bMV0gKyBleHBsb3Npb25ZKSwgcmV0LnggLSA1LCByZXQueSArIHJldC5oZWlnaHQgLyAyLCBsYWJlbHNfcmlnaHRbaV1bNV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdnNwYWNlX2xlZnQgPSAoY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKSAvIGxhYmVsc19sZWZ0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gbGFiZWxzX2xlZnQubGVuZ3RoIC0gMSwgeSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSArIHZzcGFjZV9sZWZ0IC8gMjsgaSA+PSAwOyB5ICs9IHZzcGFjZV9sZWZ0LCBpLS0pIHtcbiAgICAgIGlmIChsYWJlbHNfbGVmdFtpXVsyXSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzIC0gb2Zmc2V0LFxuICAgICAgICAgICAgaWR4ID0gbGFiZWxzX2xlZnRbaV1bMF0sXG4gICAgICAgICAgICBleHBsb3Npb25YID0gbGFiZWxzX2xlZnRbaV1bNl1bMF0gPyBsYWJlbHNfbGVmdFtpXVs2XVsxXSA6IDAsXG4gICAgICAgICAgICBleHBsb3Npb25ZID0gbGFiZWxzX2xlZnRbaV1bNl1bMF0gPyBsYWJlbHNfbGVmdFtpXVs2XVsyXSA6IDA7XG4gICAgICAgIHZhciByZXQgPSBSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHRleHRfZm9udCwgc2l6ZTogdGV4dF9zaXplLCB4OiB4ICsgZXhwbG9zaW9uWCwgeTogeSArIGV4cGxvc2lvblksIHRleHQ6IGxhYmVsc19sZWZ0W2ldWzJdLCB2YWxpZ246ICdjZW50ZXInLCBoYWxpZ246ICdyaWdodCcsIHRhZzogJ2xhYmVscycsIGNvbG9yOiBsYWJlbHNfbGVmdFtpXVs1XSB9KTtpZiAocmV0ICYmIHJldC5ub2RlKSB7XG4gICAgICAgICAgcmV0Lm5vZGUuX19pbmRleF9fID0gbGFiZWxzX2xlZnRbaV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgcGEyKGNvLCAnbHcgJSBiIG0gJSAlIGwgJSAlIGwgJSAlIGwgJSAlIHMgJScsIHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGluZXdpZHRoJ10sIGxhYmVsc19sZWZ0W2ldWzNdWzBdICsgZXhwbG9zaW9uWCwgbGFiZWxzX2xlZnRbaV1bM11bMV0gKyBleHBsb3Npb25ZLCBsYWJlbHNfbGVmdFtpXVs0XVswXSArIGV4cGxvc2lvblgsIGxhYmVsc19sZWZ0W2ldWzRdWzFdICsgZXhwbG9zaW9uWSwgdGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMgLSAyNSArIGV4cGxvc2lvblgsIG1hLnJvdW5kKGxhYmVsc19sZWZ0W2ldWzRdWzFdICsgZXhwbG9zaW9uWSksIHJldC54ICsgNSArIHJldC53aWR0aCwgcmV0LnkgKyByZXQuaGVpZ2h0IC8gMiwgbGFiZWxzX2xlZnRbaV1bNV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdTdGlja3MgPSB0aGlzLkRyYXdTdGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldCA9IHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddIC8gMixcbiAgICAgICAgZXhwbG9kZWQgPSBwcm9wWydjaGFydC5leHBsb2RlZCddLFxuICAgICAgICBzdGlja3MgPSBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzJ10sXG4gICAgICAgIGNvbG9ycyA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddLFxuICAgICAgICBjeCA9IHRoaXMuY2VudGVyeCxcbiAgICAgICAgY3kgPSB0aGlzLmNlbnRlcnksXG4gICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICBwb2ludHMgPSBbXSxcbiAgICAgICAgbGluZXdpZHRoID0gcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5saW5ld2lkdGgnXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hbmdsZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5hbmdsZXNbaV07aWYgKCh0eXBlb2Ygc3RpY2tzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdGlja3MpKSA9PT0gJ29iamVjdCcgJiYgIXN0aWNrc1tpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciByYWRpYW5zID0gc2VnbWVudFsxXSAtIHNlZ21lbnRbMF07Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSB0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5jb2xvcnMnXSA9PT0gJ3N0cmluZycgPyBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddIDogIVJHLmlzTnVsbChwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmNvbG9ycyddKSA/IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3JzJ11baV0gOiAnZ3JheSc7Y28ubGluZVdpZHRoID0gbGluZXdpZHRoO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5jb2xvciddID09PSAnc3RyaW5nJykge1xuICAgICAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MuY29sb3InXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLnVzZWNvbG9ycyddKSB7XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11baV07XG4gICAgICB9XG4gICAgICB2YXIgbWlkcG9pbnQgPSBzZWdtZW50WzBdICsgcmFkaWFucyAvIDI7aWYgKCh0eXBlb2YgZXhwbG9kZWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4cGxvZGVkKSkgPT09ICdvYmplY3QnICYmIGV4cGxvZGVkW2ldKSB7XG4gICAgICAgIHZhciBleHRyYSA9IGV4cGxvZGVkW2ldO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwbG9kZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBleHRyYSA9IGV4cGxvZGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4dHJhID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBzdGlja0xlbmd0aCA9IF90eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXSkgPT09ICdvYmplY3QnID8gcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5sZW5ndGgnXVtpXSA6IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MubGVuZ3RoJ107cG9pbnRzWzBdID0gUkcuZ2V0UmFkaXVzRW5kUG9pbnQoY3gsIGN5LCBtaWRwb2ludCwgcmFkaXVzICsgZXh0cmEgKyBvZmZzZXQpO3BvaW50c1sxXSA9IFJHLmdldFJhZGl1c0VuZFBvaW50KGN4LCBjeSwgbWlkcG9pbnQsIHJhZGl1cyArIHN0aWNrTGVuZ3RoICsgZXh0cmEgLSA1KTtwb2ludHNbMl0gPSBSRy5nZXRSYWRpdXNFbmRQb2ludChjeCwgY3ksIG1pZHBvaW50LCByYWRpdXMgKyBzdGlja0xlbmd0aCArIGV4dHJhKTtwb2ludHNbM10gPSBSRy5nZXRSYWRpdXNFbmRQb2ludChjeCwgY3ksIG1pZHBvaW50LCByYWRpdXMgKyBzdGlja0xlbmd0aCArIGV4dHJhKTtwb2ludHNbM11bMF0gKz0gcG9pbnRzWzNdWzBdID4gY3ggPyA1IDogLTU7cG9pbnRzWzRdID0gW3BvaW50c1syXVswXSArIChwb2ludHNbMl1bMF0gPiBjeCA/IDUgKyBwcm9wWydjaGFydC5sYWJlbHMuc3RpY2tzLmhsZW5ndGgnXSA6IC01IC0gcHJvcFsnY2hhcnQubGFiZWxzLnN0aWNrcy5obGVuZ3RoJ10pLCBwb2ludHNbMl1bMV1dO2NvLm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7Y28ucXVhZHJhdGljQ3VydmVUbyhwb2ludHNbMl1bMF0sIHBvaW50c1syXVsxXSwgcG9pbnRzWzRdWzBdLCBwb2ludHNbNF1bMV0pO2NvLnN0cm9rZSgpO3RoaXMuY29vcmRzU3RpY2tzW2ldID0gW3BvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdXTtcbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IHRoaXMuZ2V0U2VnbWVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgUkcuRml4RXZlbnRPYmplY3QoZSk7dmFyIGFjY3VyYWN5ID0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMDt2YXIgY2FudmFzID0gY2E7dmFyIGNvbnRleHQgPSBjbzt2YXIgbW91c2VDb29yZHMgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBtb3VzZVggPSBtb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZID0gbW91c2VDb29yZHNbMV07dmFyIHIgPSB0aGlzLnJhZGl1czt2YXIgYW5nbGVzID0gdGhpcy5hbmdsZXM7dmFyIHJldCA9IFtdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBhbmdsZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO2NvLmFyYyhhbmdsZXNbaV1bMl0sIGFuZ2xlc1tpXVszXSwgdGhpcy5yYWRpdXMsIGFuZ2xlc1tpXVswXSwgYW5nbGVzW2ldWzFdLCBmYWxzZSk7aWYgKHRoaXMudHlwZSA9PSAncGllJyAmJiBwcm9wWydjaGFydC52YXJpYW50J10gPT0gJ2RvbnV0Jykge1xuICAgICAgICBjby5hcmMoYW5nbGVzW2ldWzJdLCBhbmdsZXNbaV1bM10sIHR5cGVvZiBwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10gPT0gJ251bWJlcicgPyB0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA6IHRoaXMucmFkaXVzIC8gMiwgYW5nbGVzW2ldWzFdLCBhbmdsZXNbaV1bMF0sIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY28ubGluZVRvKGFuZ2xlc1tpXVsyXSwgYW5nbGVzW2ldWzNdKTtcbiAgICAgIH1cbiAgICAgIGNvLmNsb3NlUGF0aCgpO2lmICghY28uaXNQb2ludEluUGF0aChtb3VzZVgsIG1vdXNlWSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXRbMF0gPSBhbmdsZXNbaV1bMl07cmV0WzFdID0gYW5nbGVzW2ldWzNdO3JldFsyXSA9IHRoaXMucmFkaXVzO3JldFszXSA9IGFuZ2xlc1tpXVswXSAtIFJHLlRXT1BJO3JldFs0XSA9IGFuZ2xlc1tpXVsxXTtyZXRbNV0gPSBpO2lmIChyZXRbM10gPCAwKSByZXRbM10gKz0gUkcuVFdPUEk7aWYgKHJldFs0XSA+IFJHLlRXT1BJKSByZXRbNF0gLT0gUkcuVFdPUEk7dmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0ID8gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCByZXRbNV0pIDogbnVsbDtyZXRbJ29iamVjdCddID0gdGhpcztyZXRbJ3gnXSA9IHJldFswXTtyZXRbJ3knXSA9IHJldFsxXTtyZXRbJ3JhZGl1cyddID0gcmV0WzJdO3JldFsnYW5nbGUuc3RhcnQnXSA9IHJldFszXTtyZXRbJ2FuZ2xlLmVuZCddID0gcmV0WzRdO3JldFsnaW5kZXgnXSA9IHJldFs1XTtyZXRbJ3Rvb2x0aXAnXSA9IHRvb2x0aXA7cmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07dGhpcy5kcmF3Qm9yZGVycyA9IHRoaXMuRHJhd0JvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddID4gMCkge1xuICAgICAgY28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO3ZhciByID0gdGhpcy5yYWRpdXM7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYW5nbGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5hbmdsZXNbaV07Y28uYmVnaW5QYXRoKCk7Y28uYXJjKHNlZ21lbnRbMl0sIHNlZ21lbnRbM10sIHIsIHNlZ21lbnRbMF0sIHNlZ21lbnRbMF0gKyAwLjAwMSwgMCk7Y28uYXJjKHNlZ21lbnRbMl0sIHNlZ21lbnRbM10sIHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnZG9udXQnID8gdHlwZW9mIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA9PSAnbnVtYmVyJyA/IHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddIDogciAvIDIgOiByLCBzZWdtZW50WzBdLCBzZWdtZW50WzBdICsgMC4wMDAxLCAwKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncmFwaCA9IHsgd2lkdGg6IGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLCBoZWlnaHQ6IGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSB9O1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQucmFkaXVzJ10gPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gcHJvcFsnY2hhcnQucmFkaXVzJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5taW4odGhpcy5ncmFwaC53aWR0aCwgdGhpcy5ncmFwaC5oZWlnaHQpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzO1xuICB9O3RoaXMuZXhwbG9kZVNlZ21lbnQgPSB0aGlzLkV4cGxvZGUgPSBmdW5jdGlvbiAoaW5kZXgsIHNpemUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZXhwbG9kaW5nID09PSAnbnVtYmVyJyAmJiB0aGlzLmV4cGxvZGluZyA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwcm9wWydjaGFydC5leHBsb2RlZCddKSB7XG4gICAgICBwcm9wWydjaGFydC5leHBsb2RlZCddID0gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG9yaWdpbmFsX2V4cGxvZGUgPSBwcm9wWydjaGFydC5leHBsb2RlZCddO3ZhciBleHBsb2RlZCA9IHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ107cHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA9IFtdO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXVtpXSA9IGV4cGxvZGVkO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wWydjaGFydC5leHBsb2RlZCddW2luZGV4XSA9IHR5cGVvZiBvcmlnaW5hbF9leHBsb2RlID09ICdudW1iZXInID8gb3JpZ2luYWxfZXhwbG9kZSA6IDA7dGhpcy5leHBsb2RpbmcgPSBpbmRleDt2YXIgZGVsYXkgPSBSRy5JU0lFICYmICFSRy5JU0lFMTAgPyAyNSA6IDE2LjY2Njtmb3IgKHZhciBvID0gMDsgbyA8IHNpemU7ICsrbykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ11baW5kZXhdICs9IDE7UkcuQ2xlYXIoY2EpO1JHLlJlZHJhd0NhbnZhcyhjYSk7XG4gICAgICB9LCBvICogZGVsYXkpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gdGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5leHBsb2RpbmcgPSBudWxsO1xuICAgIH0sIHNpemUgKiBkZWxheSk7XG4gIH07dGhpcy5oaWdobGlnaHRfc2VnbWVudCA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJ107Y28ubW92ZVRvKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO2NvLmFyYyhzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCB0aGlzLmFuZ2xlc1tzZWdtZW50WzVdXVswXSwgdGhpcy5hbmdsZXNbc2VnbWVudFs1XV1bMV0sIDApO2NvLmxpbmVUbyhzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmIChwcm9wWydjaGFydC50b29sdGlwcy5oaWdobGlnaHQnXSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXShzaGFwZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09ICczZCcpIHtcbiAgICAgICAgY28ubGluZVdpZHRoID0gMTt2YXIgZXh0ZW50ID0gMjtjby5iZWdpblBhdGgoKTtSRy5Ob1NoYWRvdyh0aGlzKTtjby5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7Y28uYXJjKHNoYXBlWyd4J10sIHNoYXBlWyd5J10sIHNoYXBlWydyYWRpdXMnXSwgc2hhcGVbJ2FuZ2xlLnN0YXJ0J10sIHNoYXBlWydhbmdsZS5lbmQnXSwgZmFsc2UpO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT0gJ2RvbnV0Jykge1xuICAgICAgICAgIGNvLmFyYyhzaGFwZVsneCddLCBzaGFwZVsneSddLCBzaGFwZVsncmFkaXVzJ10gLyA1LCBzaGFwZVsnYW5nbGUuZW5kJ10sIHNoYXBlWydhbmdsZS5zdGFydCddLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5saW5lVG8oc2hhcGVbJ3gnXSwgc2hhcGVbJ3knXSk7XG4gICAgICAgIH1cbiAgICAgICAgY28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2NvLnNoYWRvd0NvbG9yID0gJyM2NjYnO2NvLnNoYWRvd0JsdXIgPSAzO2NvLnNoYWRvd09mZnNldFggPSAzO2NvLnNoYWRvd09mZnNldFkgPSAzO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW3NoYXBlWydpbmRleCddXTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uYXJjKHNoYXBlWyd4J10gLSBleHRlbnQsIHNoYXBlWyd5J10gLSBleHRlbnQsIHNoYXBlWydyYWRpdXMnXSwgc2hhcGVbJ2FuZ2xlLnN0YXJ0J10sIHNoYXBlWydhbmdsZS5lbmQnXSwgZmFsc2UpO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT0gJ2RvbnV0Jykge1xuICAgICAgICAgIGNvLmFyYyhzaGFwZVsneCddIC0gZXh0ZW50LCBzaGFwZVsneSddIC0gZXh0ZW50LCBzaGFwZVsncmFkaXVzJ10gLyAyLCBzaGFwZVsnYW5nbGUuZW5kJ10sIHNoYXBlWydhbmdsZS5zdGFydCddLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5saW5lVG8oc2hhcGVbJ3gnXSAtIGV4dGVudCwgc2hhcGVbJ3knXSAtIGV4dGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1JHLk5vU2hhZG93KHRoaXMpO2lmIChwcm9wWydjaGFydC5ib3JkZXInXSkge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYm9yZGVyLmNvbG9yJ107Y28ubGluZVdpZHRoID0gNTtjby5hcmMoc2hhcGVbJ3gnXSAtIGV4dGVudCwgc2hhcGVbJ3knXSAtIGV4dGVudCwgc2hhcGVbJ3JhZGl1cyddIC0gMiwgc2hhcGVbJ2FuZ2xlLnN0YXJ0J10sIHNoYXBlWydhbmdsZS5lbmQnXSwgZmFsc2UpO2NvLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09PSAnb3V0bGluZScpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LnRvb2x0aXAnKSxcbiAgICAgICAgICAgIGluZGV4ID0gdG9vbHRpcC5fX2luZGV4X18sXG4gICAgICAgICAgICBjb29yZHMgPSB0aGlzLmFuZ2xlc1tpbmRleF0sXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuZ2V0KCdjb2xvcnMnKVtpbmRleF07XG4gICAgICAgIHdpZHRoID0gdGhpcy5yYWRpdXMgLyAxMi41O2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLm91dGxpbmUud2lkdGgnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB3aWR0aCA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS5vdXRsaW5lLndpZHRoJ107XG4gICAgICAgIH1cbiAgICAgICAgUkdyYXBoLnBhdGgyKGNvLCAnZ2EgMC4yNSBiIGEgJSAlICUgJSAlIGZhbHNlIGEgJSAlICUgJSAlIHRydWUgYyBmICUgZ2EgMScsIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB0aGlzLnJhZGl1cyArIDIgKyB3aWR0aCwgY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB0aGlzLnJhZGl1cyArIDIsIGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb2xvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLnN0cm9rZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmZpbGwnXTtpZiAocHJvcFsnY2hhcnQudmFyaWFudCddLmluZGV4T2YoJ2RvbnV0JykgPiAtMSkge1xuICAgICAgICAgIGNvLmFyYyhzaGFwZVsneCddLCBzaGFwZVsneSddLCBzaGFwZVsncmFkaXVzJ10sIHNoYXBlWydhbmdsZS5zdGFydCddLCBzaGFwZVsnYW5nbGUuZW5kJ10sIGZhbHNlKTtjby5hcmMoc2hhcGVbJ3gnXSwgc2hhcGVbJ3knXSwgdHlwZW9mIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA9PSAnbnVtYmVyJyA/IHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddIDogc2hhcGVbJ3JhZGl1cyddIC8gMiwgc2hhcGVbJ2FuZ2xlLmVuZCddLCBzaGFwZVsnYW5nbGUuc3RhcnQnXSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28uYXJjKHNoYXBlWyd4J10sIHNoYXBlWyd5J10sIHNoYXBlWydyYWRpdXMnXSArIDEsIHNoYXBlWydhbmdsZS5zdGFydCddLCBzaGFwZVsnYW5nbGUuZW5kJ10sIGZhbHNlKTtjby5saW5lVG8oc2hhcGVbJ3gnXSwgc2hhcGVbJ3knXSk7XG4gICAgICAgIH1cbiAgICAgICAgY28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldE9iamVjdEJ5WFkgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0aGlzLmdldFNoYXBlKGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5kcmF3Q2VudGVycGluID0gdGhpcy5EcmF3Q2VudGVycGluID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVycGluJ10gPT0gJ251bWJlcicgJiYgcHJvcFsnY2hhcnQuY2VudGVycGluJ10gPiAwKSB7XG4gICAgICB2YXIgY3ggPSB0aGlzLmNlbnRlcng7dmFyIGN5ID0gdGhpcy5jZW50ZXJ5O2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuY2VudGVycGluLnN0cm9rZSddID8gcHJvcFsnY2hhcnQuY2VudGVycGluLnN0cm9rZSddIDogcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5jZW50ZXJwaW4uZmlsbCddID8gcHJvcFsnY2hhcnQuY2VudGVycGluLmZpbGwnXSA6IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28ubW92ZVRvKGN4LCBjeSk7Y28uYXJjKGN4LCBjeSwgcHJvcFsnY2hhcnQuY2VudGVycGluJ10sIDAsIFJHLlRXT1BJLCBmYWxzZSk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdJbkdyYXBoTGFiZWxzID0gdGhpcy5EcmF3SW5HcmFwaExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dCA9IGNvO3ZhciBjeCA9IHRoaXMuY2VudGVyeDt2YXIgY3kgPSB0aGlzLmNlbnRlcnk7dmFyIHJhZGl1cyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnJhZGl1cyddO2lmIChyYWRpdXMgPD0gMiAmJiByYWRpdXMgPiAwKSB7XG4gICAgICByYWRpdXNGYWN0b3IgPSByYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZGl1c0ZhY3RvciA9IDAuNTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSA9PSAnZG9udXQnKSB7XG4gICAgICB2YXIgciA9IHRoaXMucmFkaXVzICogKDAuNSArIHJhZGl1c0ZhY3RvciAqIDAuNSk7aWYgKHR5cGVvZiBwcm9wWydjaGFydC52YXJpYW50LmRvbnV0LndpZHRoJ10gPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cyAtIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSArIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSAvIDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByID0gdGhpcy5yYWRpdXMgKiByYWRpdXNGYWN0b3I7XG4gICAgfVxuICAgIGlmIChyYWRpdXMgPiAyKSB7XG4gICAgICByID0gcmFkaXVzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hbmdsZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9wWydjaGFydC5leHBsb2RlZCddW2ldID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBleHBsb3Npb24gPSBwcm9wWydjaGFydC5leHBsb2RlZCddW2ldO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuZXhwbG9kZWQnXSA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgZXhwbG9zaW9uID0gcGFyc2VJbnQocHJvcFsnY2hhcnQuZXhwbG9kZWQnXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwbG9zaW9uID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVN0YXJ0ID0gdGhpcy5hbmdsZXNbaV1bMF07dmFyIGFuZ2xlRW5kID0gdGhpcy5hbmdsZXNbaV1bMV07dmFyIGFuZ2xlQ2VudGVyID0gKGFuZ2xlRW5kIC0gYW5nbGVTdGFydCkgLyAyICsgYW5nbGVTdGFydDt2YXIgY29vcmRzID0gUkcuZ2V0UmFkaXVzRW5kUG9pbnQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIGFuZ2xlQ2VudGVyLCByICsgKGV4cGxvc2lvbiA/IGV4cGxvc2lvbiA6IDApKTt2YXIgeCA9IGNvb3Jkc1swXTt2YXIgeSA9IGNvb3Jkc1sxXTt2YXIgdGV4dCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnNwZWNpZmljJ10gJiYgdHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnNwZWNpZmljJ11baV0gPT0gJ3N0cmluZycgPyBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5zcGVjaWZpYyddW2ldIDogUkcubnVtYmVyX2Zvcm1hdCh0aGlzLCB0aGlzLmRhdGFbaV0sIHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLnVuaXRzLnByZSddLCBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC51bml0cy5wb3N0J10pO2lmICh0ZXh0KSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciBmb250ID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmZvbnQnXSA9PT0gJ3N0cmluZycgPyBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5mb250J10gOiBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZSA9IHR5cGVvZiBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5zaXplJ10gPT09ICdudW1iZXInID8gcHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguc2l6ZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10gKyAyO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJ10gPyBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5jb2xvciddIDogJ2JsYWNrJztSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHgsICd5JzogeSwgJ3RleHQnOiB0ZXh0LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogcHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguYm91bmRpbmcnXSwgJ2JvdW5kaW5nLmZpbGwnOiBwcm9wWydjaGFydC5sYWJlbHMuaW5ncmFwaC5ib3VuZGluZy5maWxsJ10sICd0YWcnOiAnbGFiZWxzLmluZ3JhcGgnIH0pO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdDZW50ZXJMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIHZhciBmb250ID0gcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5mb250J10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLnNpemUnXSxcbiAgICAgICAgY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJ10sXG4gICAgICAgIHVuaXRzUHJlID0gcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wcmUnXSxcbiAgICAgICAgdW5pdHNQb3N0ID0gcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci51bml0cy5wb3N0J10sXG4gICAgICAgIGJvbGQgPSBwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmJvbGQnXSxcbiAgICAgICAgaXRhbGljID0gcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnXTtSRy50ZXh0Mih0aGlzLCB7IGNvbG9yOiBjb2xvciwgYm9sZDogYm9sZCwgaXRhbGljOiBpdGFsaWMsIGZvbnQ6IGZvbnQsIHNpemU6IHNpemUsIHg6IHRoaXMuY2VudGVyeCwgeTogdGhpcy5jZW50ZXJ5LCBoYWxpZ246ICdjZW50ZXInLCB2YWxpZ246ICdjZW50ZXInLCB0ZXh0OiBSRy5udW1iZXJGb3JtYXQodGhpcywgbGFiZWwsIHVuaXRzUHJlLCB1bml0c1Bvc3QpIH0pO1xuICB9O1xuICB0aGlzLmdldEFuZ2xlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID4gdGhpcy50b3RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhbmdsZSA9IHZhbHVlIC8gdGhpcy50b3RhbCAqIFJHLlRXT1BJO2FuZ2xlICs9IHByb3BbJ2NoYXJ0Lm9yaWdpbiddO3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLmZpbGwnXSA9IFJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2QuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaW5ncmFwaC5ib3VuZGluZy5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmluZ3JhcGguYm91bmRpbmcuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaW5ncmFwaC5jb2xvciddID0gUkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5pbmdyYXBoLmNvbG9yJ10pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LmNvbG9ycyddLmxlbmd0aDsgKytpKSB7XG4gICAgICBwcm9wWydjaGFydC5jb2xvcnMnXVtpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldKTtcbiAgICB9XG4gICAgdmFyIGtleUNvbG9ycyA9IHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXTtpZiAoa2V5Q29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXlDb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChrZXlDb2xvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUudHdvZC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZS50d29kLnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlLnR3b2Quc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmJvdW5kaW5nLmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmJvdW5kaW5nLmZpbGwnXSk7cHJvcFsnY2hhcnQubGFiZWxzLmluZ3JhcGguY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmxhYmVscy5pbmdyYXBoLmNvbG9yJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO2lmIChwcm9wWydjaGFydC52YXJpYW50J10gPT0gJ2RvbnV0Jykge1xuICAgICAgICB2YXIgcmFkaXVzX3N0YXJ0ID0gdHlwZW9mIHByb3BbJ2NoYXJ0LnZhcmlhbnQuZG9udXQud2lkdGgnXSA9PSAnbnVtYmVyJyA/IHRoaXMucmFkaXVzIC0gcHJvcFsnY2hhcnQudmFyaWFudC5kb251dC53aWR0aCddIDogdGhpcy5yYWRpdXMgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZGl1c19zdGFydCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCByYWRpdXNfc3RhcnQsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBNYXRoLm1pbihjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J10gLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddKSAvIDIpO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLmludGVyYWN0aXZlS2V5SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuYW5nbGVzICYmIHRoaXMuYW5nbGVzW2luZGV4XSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLmFuZ2xlc1tpbmRleF07dmFyIHggPSBzZWdtZW50WzJdO3ZhciB5ID0gc2VnbWVudFszXTt2YXIgc3RhcnQgPSBzZWdtZW50WzBdO3ZhciBlbmQgPSBzZWdtZW50WzFdO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5saW5lV2lkdGggPSAyO2NvLmxpbmVKb2luID0gJ2JldmVsJztjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCwgeSk7Y28uYXJjKHgsIHksIHRoaXMucmFkaXVzLCBzdGFydCwgZW5kLCBmYWxzZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5kcmF3M2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjYWxlWCA9IDEuNSxcbiAgICAgICAgZGVwdGggPSBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCddLFxuICAgICAgICBwcm9wX3NoYWRvdyA9IHByb3BbJ2NoYXJ0LnNoYWRvdyddLFxuICAgICAgICBwcm9wX2xhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscyddLFxuICAgICAgICBwcm9wX2xhYmVsc1N0aWNrcyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zdGlja3MnXTtcbiAgICB0aGlzLnNldCh7IGxhYmVsczogW10sIGxhYmVsc1N0aWNrczogZmFsc2UsIHN0cm9rZXN0eWxlOiAncmdiYSgwLDAsMCwwKScgfSk7dGhpcy5zZXQoeyB2YXJpYW50OiB0aGlzLmdldCgndmFyaWFudCcpLnJlcGxhY2UoLzNkLywgJycpIH0pO3RoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCAxLCAoY2Eud2lkdGggKiBzY2FsZVggLSBjYS53aWR0aCkgKiAtMC41LCAwKTtmb3IgKHZhciBpID0gZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgIHRoaXMuc2V0KHsgY2VudGVyeUFkanVzdDogaSB9KTtpZiAoaSA9PT0gcGFyc2VJbnQoZGVwdGggLyAyKSkge1xuICAgICAgICB0aGlzLnNldCh7IGxhYmVsczogcHJvcF9sYWJlbHMsIGxhYmVsc1N0aWNrczogcHJvcF9sYWJlbHNTdGlja3MgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldCh7IHNoYWRvdzogcHJvcF9zaGFkb3cgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXcoKTt0aGlzLnNldCgnc2hhZG93JywgZmFsc2UpO2lmIChpIDw9IHBhcnNlSW50KGRlcHRoIC8gMikpIHtcbiAgICAgICAgdGhpcy5zZXQoeyBsYWJlbHM6IFtdLCBsYWJlbHNTdGlja3M6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignZG9udXQnKSAhPT0gLTEpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYW5nbGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBwYTIoY28sIFsnYicsICdhJywgdGhpcy5hbmdsZXNbal1bMl0sIHRoaXMuYW5nbGVzW2pdWzNdLCB0aGlzLnJhZGl1cyArIDEsIHRoaXMuYW5nbGVzW2pdWzBdLCB0aGlzLmFuZ2xlc1tqXVsxXSAqIHByb3BbJ2NoYXJ0LmVmZmVjdC5yb3VuZHJvYmluLm11bHRpcGxpZXInXSwgZmFsc2UsICdhJywgdGhpcy5hbmdsZXNbal1bMl0sIHRoaXMuYW5nbGVzW2pdWzNdLCB0aGlzLnJhZGl1cyAvIDIsIHRoaXMuYW5nbGVzW2pdWzFdICogcHJvcFsnY2hhcnQuZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllciddLCB0aGlzLmFuZ2xlc1tqXVswXSwgdHJ1ZSwgJ2YnLCAncmdiYSgwLDAsMCwwLjE1KSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmFuZ2xlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgcGEyKGNvLCBbJ2InLCAnbScsIHRoaXMuYW5nbGVzW2pdWzJdLCB0aGlzLmFuZ2xlc1tqXVszXSwgJ2EnLCB0aGlzLmFuZ2xlc1tqXVsyXSwgdGhpcy5hbmdsZXNbal1bM10sIHRoaXMucmFkaXVzICsgMSwgdGhpcy5hbmdsZXNbal1bMF0sIHRoaXMuYW5nbGVzW2pdWzFdICogcHJvcFsnY2hhcnQuZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllciddLCBmYWxzZSwgJ2MnLCAnZicsICdyZ2JhKDAsMCwwLDAuMTUpJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldCh7IHZhcmlhbnQ6IHRoaXMuZ2V0KCd2YXJpYW50JykgKyAnM2QnLCBzaGFkb3c6IHByb3Bfc2hhZG93LCBsYWJlbHM6IHByb3BfbGFiZWxzLCBsYWJlbHNTdGlja3M6IHByb3BfbGFiZWxzU3RpY2tzIH0pO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhwbG9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgPyBvcHQuZnJhbWVzIDogMzA7dmFyIGZyYW1lID0gMDt2YXIgbWF4RXhwbG9kZSA9IE51bWJlcih0eXBlb2Ygb3B0LnJhZGl1cyA9PT0gJ251bWJlcicgPyBvcHQucmFkaXVzIDogbWEubWF4KGNhLndpZHRoLCBjYS5oZWlnaHQpKTt2YXIgY3VycmVudEV4cGxvZGUgPSBOdW1iZXIob2JqLmdldCgnZXhwbG9kZWQnKSkgfHwgMDt2YXIgc3RlcCA9IChtYXhFeHBsb2RlIC0gY3VycmVudEV4cGxvZGUpIC8gZnJhbWVzO3ZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgb2JqLnNldCgnZXhwbG9kZWQnLCBjdXJyZW50RXhwbG9kZSArIHN0ZXAgKiBmcmFtZSk7UkdyYXBoLmNsZWFyKG9iai5jYW52YXMpO1JHcmFwaC5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgUkdyYXBoLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgY2FudmFzID0gb2JqLmNhbnZhczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTt2YXIgcmFkaXVzID0gb2JqLmdldFJhZGl1cygpO3Byb3BbJ2NoYXJ0LnJhZGl1cyddID0gMDt2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIG9iai5zZXQoJ2NoYXJ0LnJhZGl1cycsIGZyYW1lIC8gZnJhbWVzICogcmFkaXVzKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH07aXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLnJvdW5kcm9iaW4gPSB0aGlzLnJvdW5kUm9iaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMCxcbiAgICAgICAgcmFkaXVzID0gb2JqLmdldFJhZGl1cygpLFxuICAgICAgICBsYWJlbHMgPSBvYmouZ2V0KCdsYWJlbHMnKTtcbiAgICBvYmouU2V0KCdjaGFydC5ldmVudHMnLCBmYWxzZSk7b2JqLlNldCgnY2hhcnQubGFiZWxzJywgW10pO3ZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgb2JqLnNldCgnZWZmZWN0LnJvdW5kcm9iaW4ubXVsdGlwbGllcicsIFJHLkVmZmVjdHMuZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKSk7UkdyYXBoLnJlZHJhd0NhbnZhcyhjYSk7aWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgUkdyYXBoLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5zZXQoeyBldmVudHM6IHRydWUsIGxhYmVsczogbGFiZWxzIH0pO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH07aXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5hdHQoY2EpO3RoaXMuaW1wbG9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBleHBsb2RlZE1heCA9IG1hLm1heChjYS53aWR0aCwgY2EuaGVpZ2h0KSxcbiAgICAgICAgZXhwbG9kZWQgPSBleHBsb2RlZE1heDtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGV4cGxvZGVkID0gZXhwbG9kZWRNYXggLSBmcmFtZSAvIGZyYW1lcyAqIGV4cGxvZGVkTWF4O29iai5TZXQoJ2V4cGxvZGVkJywgZXhwbG9kZWQpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLmNsZWFyKG9iai5jYW52YXMpO1JHLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLnJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5waWUuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///198\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Radar = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;if (typeof conf.data[0] === 'number' || typeof conf.data[0] === 'string') {\n      conf.data = [conf.data];\n    }\n  } else {\n    var conf = { id: conf, data: [] };if (_typeof(arguments[1]) === 'object' && typeof arguments[1][0] === 'number') {\n      for (var i = 1; i < arguments.length; ++i) {\n        conf.data.push(RGraph.arrayClone(arguments[i]));\n      }\n    } else if (_typeof(arguments[1]) === 'object' && _typeof(arguments[1][0]) === 'object' && typeof arguments[1][0][0] === 'number') {\n      conf.data = RGraph.arrayClone(arguments[1]);\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(conf.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'radar';this.isRGraph = true;this.data = [];this.max = 0;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coords = [];this.coordsText = [];this.original_data = [];this.original_colors = [];this.firstDraw = true;for (var i = 0, len = conf.data.length; i < len; ++i) {\n    for (var j = 0; j < conf.data[i].length; ++j) {\n      if (typeof conf.data[i][j] === 'string') {\n        conf.data[i][j] = parseFloat(conf.data[i][j]);\n      }\n    }\n    this.original_data.push(RGraph.arrayClone(conf.data[i]));this.data.push(RGraph.arrayClone(conf.data[i]));this.max = Math.max(this.max, RGraph.arrayMax(conf.data[i]));\n  }\n  this.properties = (_properties = { 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.linewidth': 1, 'chart.colors': ['rgba(255,255,0,0.25)', 'rgba(0,255,255,0.25)', 'rgba(255,0,0,0.5)', 'red', 'green', 'blue', 'pink', 'aqua', 'brown', 'orange', 'grey'], 'chart.colors.alpha': null, 'chart.circle': 0, 'chart.circle.fill': 'red', 'chart.circle.stroke': 'black', 'chart.labels': [], 'chart.labels.color': null, 'chart.labels.offset': 10, 'chart.labels.axes': '', 'chart.labels.background.fill': 'white', 'chart.labels.boxed': false, 'chart.labels.axes.bold': [], 'chart.labels.axes.boxed': null, 'chart.labels.axes.boxed.zero': true, 'chart.labels.axes.boxed.background': 'rgba(255,255,255,0.9)', 'chart.labels.specific': [], 'chart.labels.count': 5, 'chart.background.circles': true, 'chart.background.circles.count': null, 'chart.background.circles.color': '#ddd', 'chart.background.circles.poly': true, 'chart.background.circles.spokes': 24, 'chart.text.size': 12, 'chart.text.size.scale': null, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.color': 'black', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.color': 'black', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null }, _defineProperty(_properties, 'chart.linewidth', 1), _defineProperty(_properties, 'chart.key', null), _defineProperty(_properties, 'chart.key.background', 'white'), _defineProperty(_properties, 'chart.key.shadow', false), _defineProperty(_properties, 'chart.key.shadow.color', '#666'), _defineProperty(_properties, 'chart.key.shadow.blur', 3), _defineProperty(_properties, 'chart.key.shadow.offsetx', 2), _defineProperty(_properties, 'chart.key.shadow.offsety', 2), _defineProperty(_properties, 'chart.key.position', 'graph'), _defineProperty(_properties, 'chart.key.halign', 'right'), _defineProperty(_properties, 'chart.key.position.gutter.boxed', false), _defineProperty(_properties, 'chart.key.position.x', null), _defineProperty(_properties, 'chart.key.position.y', null), _defineProperty(_properties, 'chart.key.color.shape', 'square'), _defineProperty(_properties, 'chart.key.rounded', true), _defineProperty(_properties, 'chart.key.linewidth', 1), _defineProperty(_properties, 'chart.key.colors', null), _defineProperty(_properties, 'chart.key.interactive', false), _defineProperty(_properties, 'chart.key.interactive.highlight.chart.stroke', 'rgba(255,0,0,0.3)'), _defineProperty(_properties, 'chart.key.interactive.highlight.label', 'rgba(255,0,0,0.2)'), _defineProperty(_properties, 'chart.key.text.color', 'black'), _defineProperty(_properties, 'chart.contextmenu', null), _defineProperty(_properties, 'chart.annotatable', false), _defineProperty(_properties, 'chart.annotate.color', 'black'), _defineProperty(_properties, 'chart.zoom.factor', 1.5), _defineProperty(_properties, 'chart.zoom.fade.in', true), _defineProperty(_properties, 'chart.zoom.fade.out', true), _defineProperty(_properties, 'chart.zoom.hdir', 'right'), _defineProperty(_properties, 'chart.zoom.vdir', 'down'), _defineProperty(_properties, 'chart.zoom.frames', 25), _defineProperty(_properties, 'chart.zoom.delay', 16.666), _defineProperty(_properties, 'chart.zoom.shadow', true), _defineProperty(_properties, 'chart.zoom.background', true), _defineProperty(_properties, 'chart.zoom.action', 'zoom'), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.tooltips.css.class', 'RGraph_tooltip'), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.highlight.stroke', 'gray'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.highlight.point.radius', 2), _defineProperty(_properties, 'chart.resizable', false), _defineProperty(_properties, 'chart.resize.handle.adjust', [0, 0]), _defineProperty(_properties, 'chart.resize.handle.background', null), _defineProperty(_properties, 'chart.ymax', null), _defineProperty(_properties, 'chart.accumulative', false), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.units.pre', ''), _defineProperty(_properties, 'chart.units.post', ''), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.event', 'onmousemove'), _defineProperty(_properties, 'chart.centerx', null), _defineProperty(_properties, 'chart.centery', null), _defineProperty(_properties, 'chart.radius', null), _defineProperty(_properties, 'chart.numxticks', 5), _defineProperty(_properties, 'chart.numyticks', 5), _defineProperty(_properties, 'chart.axes.color', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlights', false), _defineProperty(_properties, 'chart.highlights.stroke', '#ddd'), _defineProperty(_properties, 'chart.highlights.fill', null), _defineProperty(_properties, 'chart.highlights.radius', 3), _defineProperty(_properties, 'chart.fill.click', null), _defineProperty(_properties, 'chart.fill.mousemove', null), _defineProperty(_properties, 'chart.fill.tooltips', null), _defineProperty(_properties, 'chart.fill.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.fill.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.fill.mousemove.redraw', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    if (this.data[dataset].length < 3) {\n      alert('[RADAR] You must specify at least 3 data points');return;\n    }\n  }\n  var idx = 0;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n    for (var i = 0, len = this.data[dataset].length; i < len; ++i) {\n      this['$' + idx++] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    if (name == 'chart.color') {\n      this.properties['chart.colors'] = [value];\n    }\n    prop[name] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.text.diameter') {\n      name = 'chart.text.size';\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.coords = [];this.coords2 = [];this.coordsText = [];this.data = RG.arrayClone(this.original_data);if (prop['chart.accumulative']) {\n      for (var i = 0; i < this.data.length; ++i) {\n        if (this.data[i].length != this.data[0].length) {\n          alert('[RADAR] Error! When the radar has chart.accumulative set to true all the datasets must have the same number of elements');\n        }\n      }\n    }\n    if (RG.isNull(prop['chart.labels.axes.boxed'])) {\n      prop['chart.labels.axes.boxed'] = [];for (var i = 0; i < (prop['chart.labels.specific'].length || prop['chart.labels.count'] || 5); ++i) {\n        prop['chart.labels.axes.boxed'][i] = false;\n      }\n    }\n    this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;if (typeof prop['chart.centerx'] == 'number') this.centerx = 2 * prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = 2 * prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (!prop['chart.ymax']) {\n      if (prop['chart.accumulative']) {\n        var accumulation = [];var len = this.original_data[0].length;\n        for (var i = 1; i < this.original_data.length; ++i) {\n          if (this.original_data[i].length != len) {\n            alert('[RADAR] Error! Stacked Radar chart datasets must all be the same size!');\n          }\n          for (var j = 0; j < this.original_data[i].length; ++j) {\n            this.data[i][j] += this.data[i - 1][j];this.max = Math.max(this.max, this.data[i][j]);\n          }\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, 'min': 0, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'min': 0, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    this.drawBackground();this.drawAxes();this.drawCircle();this.drawLabels();co.save();co.beginPath();co.arc(this.centerx, this.centery, this.radius * 2, -RG.HALFPI, RG.TWOPI * prop['chart.animation.trace.clip'] - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.closePath();co.clip();this.DrawChart();this.DrawHighlights();co.restore();this.drawAxisLabels();if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.diameter'] ? prop['chart.title.diameter'] : null);\n    }\n    if (prop['chart.key']) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if ((prop['chart.fill.click'] || prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) && !this.__fill_click_listeners_installed__) {\n      this.AddFillListeners();this.__fill_click_listeners_installed__ = true;\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RGraph.FireCustomEvent(this, 'ondraw');return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    var color = prop['chart.background.circles.color'];var poly = prop['chart.background.circles.poly'];var spacing = prop['chart.background.circles.spacing'];var spokes = prop['chart.background.circles.spokes'];co.lineWidth = 1;if (prop['chart.background.circles'] && poly == false) {\n      co.strokeStyle = color;co.beginPath();var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.moveTo(this.centerx, this.centery);co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.strokeStyle = color;for (var i = 0; i < 360; i += 360 / spokes) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI, (i + 0.001) / 360 * RG.TWOPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n    } else if (prop['chart.background.circles'] && poly == true) {\n      co.strokeStyle = color;var increment = 360 / this.data[0].length;\n      for (var i = 0; i < 360; i += increment) {\n        co.beginPath();co.arc(this.centerx, this.centery, this.radius, i / 360 * RG.TWOPI - RG.HALFPI, (i + 0.001) / 360 * RG.TWOPI - RG.HALFPI, false);co.lineTo(this.centerx, this.centery);co.stroke();\n      }\n      co.strokeStyle = color;var numrings = typeof prop['chart.background.circles.count'] == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];for (var r = 0; r <= this.radius; r += this.radius / numrings) {\n        co.beginPath();for (var a = 0; a <= 360; a += 360 / this.data[0].length) {\n          co.arc(this.centerx, this.centery, r, RG.degrees2Radians(a) - RG.HALFPI, RG.degrees2Radians(a) + 0.001 - RG.HALFPI, false);\n        }\n        co.closePath();co.stroke();\n      }\n    }\n  };this.drawAxes = this.DrawAxes = function () {\n    co.strokeStyle = prop['chart.axes.color'];var halfsize = this.radius;co.beginPath();co.moveTo(Math.round(this.centerx), this.centery + this.radius);co.lineTo(Math.round(this.centerx), this.centery - this.radius);co.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));co.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));co.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));for (var y = this.centery - this.radius; y < this.centery + this.radius; y += this.radius / prop['chart.numyticks']) {\n      co.moveTo(this.centerx - 3, Math.round(y));co.lineTo(this.centerx + 3, Math.round(y));\n    }\n    co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));co.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);co.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);co.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);for (var x = this.centerx - this.radius; x < this.centerx + this.radius; x += this.radius / prop['chart.numxticks']) {\n      co.moveTo(Math.round(x), this.centery - 3);co.lineTo(Math.round(x), this.centery + 3);\n    }\n    co.stroke();\n  };this.drawChart = this.DrawChart = function () {\n    var alpha = prop['chart.colors.alpha'];if (typeof alpha == 'number') {\n      var oldAlpha = co.globalAlpha;co.globalAlpha = alpha;\n    }\n    var numDatasets = this.data.length;for (var dataset = 0; dataset < this.data.length; ++dataset) {\n      co.beginPath();var coords_dataset = [];for (var i = 0; i < this.data[dataset].length; ++i) {\n        var coords = this.GetCoordinates(dataset, i);if (coords_dataset == null) {\n          coords_dataset = [];\n        }\n        coords_dataset.push(coords);this.coords.push(coords);\n      }\n      this.coords2[dataset] = coords_dataset;co.strokeStyle = _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][dataset] ? prop['chart.colors'][dataset] : 'rgba(0,0,0,0)';if (co.fillStyle === 'transparent') {\n        co.fillStyle = 'rgba(0,0,0,0)';\n      }\n      co.lineWidth = prop['chart.linewidth'];for (i = 0; i < coords_dataset.length; ++i) {\n        if (i == 0) {\n          co.moveTo(coords_dataset[i][0], coords_dataset[i][1]);\n        } else {\n          co.lineTo(coords_dataset[i][0], coords_dataset[i][1]);\n        }\n      }\n      if (prop['chart.accumulative'] && dataset > 0) {\n        co.lineTo(coords_dataset[0][0], coords_dataset[0][1]);co.moveTo(last_coords[0][0], last_coords[0][1]);for (var i = coords_dataset.length - 1; i >= 0; --i) {\n          co.lineTo(last_coords[i][0], last_coords[i][1]);\n        }\n      }\n      var last_coords = coords_dataset;co.closePath();co.stroke();co.fill();\n    }\n    if (typeof alpha == 'number') {\n      co.globalAlpha = oldAlpha;\n    }\n  };this.getCoordinates = this.GetCoordinates = function (dataset, index) {\n    var len = this.data[dataset].length;var mag = this.data[dataset][index] / this.max * this.radius;var angle = RG.TWOPI / len * index;angle -= RG.HALFPI;var x = Math.cos(angle) * mag;var y = Math.sin(angle) * mag;x = this.centerx + x;y = this.centery + y;return [x, y];\n  };this.drawLabels = this.DrawLabels = function () {\n    var labels = prop['chart.labels'];if (labels && labels.length > 0) {\n      co.lineWidth = 1;co.strokeStyle = 'gray';co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];var bgFill = prop['chart.labels.background.fill'],\n          bold = prop['chart.labels.bold'],\n          bgBoxed = prop['chart.labels.boxed'],\n          offset = prop['chart.labels.offset'],\n          font = prop['chart.text.font'],\n          size = prop['chart.text.size'],\n          radius = this.radius,\n          color = prop['chart.labels.color'] || prop['chart.text.color'];\n      for (var i = 0; i < labels.length; ++i) {\n        var angle = RG.TWOPI / prop['chart.labels'].length * i;angle -= RG.HALFPI;var x = this.centerx + ma.cos(angle) * (radius + offset);var y = this.centery + ma.sin(angle) * (radius + offset);var halign = x < this.centerx ? 'right' : 'left';if (i == 0 || i / labels.length == 0.5) halign = 'center';if (labels[i] && labels[i].length) {\n          RG.text2(this, { 'color': color, 'font': font, 'size': size, 'x': x, 'y': y, 'text': labels[i], 'valign': 'center', 'halign': halign, 'bounding': bgBoxed, 'boundingFill': bgFill, 'bold': bold, 'tag': 'labels' });\n        }\n      }\n    }\n  };this.drawCircle = this.DrawCircle = function () {\n    var circle = {};circle.limit = prop['chart.circle'];circle.fill = prop['chart.circle.fill'];circle.stroke = prop['chart.circle.stroke'];if (circle.limit) {\n      var r = circle.limit / this.max * this.radius;co.fillStyle = circle.fill;co.strokeStyle = circle.stroke;co.beginPath();co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);co.fill();co.stroke();\n    }\n  };this.drawAxisLabels = this.DrawAxisLabels = function () {\n    if (RG.isArray(prop['chart.labels.specific']) && prop['chart.labels.specific'].length) {\n      this.drawSpecificAxisLabels();return;\n    }\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var r = this.radius,\n        font = prop['chart.text.font'],\n        size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        color = prop['chart.labels.axes.boxed.background'],\n        drawzero = false,\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        bold = prop['chart.labels.axes.bold'],\n        boxed = prop['chart.labels.axes.boxed'],\n        centerx = this.centerx,\n        centery = this.centery,\n        scale = this.scale;co.fillStyle = prop['chart.text.color'];if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery - r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx, 'y': centery + r * ((i + 1) / this.scale2.labels.length), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < this.scale2.labels.length; ++i) {\n        RG.Text2(this, { 'bold': bold[i], 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / this.scale2.labels.length), 'y': centery, 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i] || color, 'boundingFill': color, 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n      drawzero = true;\n    }\n    if (drawzero) {\n      RG.Text2(this, { font: font, size: size, x: centerx, y: centery, text: RG.numberFormat(this, Number(0).toFixed(), units_pre, units_post), valign: 'center', halign: 'center', bounding: prop['chart.labels.axes.boxed.zero'], boundingFill: color, boundingStroke: 'rgba(0,0,0,0)', bold: prop['chart.labels.axes.bold.zero'], tag: 'scale' });\n    }\n  };this.drawSpecificAxisLabels = this.DrawSpecificAxisLabels = function () {\n    var labels = prop['chart.labels.specific'];var bold = RG.array_pad(prop['chart.labels.axes.bold'], labels.length);var boxed = RG.array_pad(prop['chart.labels.axes.boxed'], labels.length);var reversed_labels = RG.array_reverse(labels);var reversed_bold = RG.array_reverse(bold);var reversed_boxed = RG.array_reverse(boxed);var font = prop['chart.text.font'];var size = typeof prop['chart.text.size.scale'] == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n      if (axes.indexOf('n') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery - this.radius + this.radius / labels.length * i, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('s') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx, 'y': this.centery + this.radius / labels.length * (i + 1), 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });if (axes.indexOf('w') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': reversed_bold[i], 'font': font, 'size': size, 'x': this.centerx - this.radius + this.radius / labels.length * i, 'y': this.centery, 'text': reversed_labels[i], 'valign': 'center', 'halign': 'center', 'bounding': reversed_boxed[i], 'boundingFill': 'white' });if (axes.indexOf('e') > -1) RG.Text2(this, { 'tag': 'labels.specific', 'bold': bold[i], 'font': font, 'size': size, 'x': this.centerx + this.radius / labels.length * (i + 1), 'y': this.centery, 'text': labels[i], 'valign': 'center', 'halign': 'center', 'bounding': boxed[i], 'boundingFill': 'white' });\n    }\n  };this.getShape = this.getPoint = function (e) {\n    for (var i = 0; i < this.coords.length; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltips = prop['chart.tooltips'];var index = Number(i);var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX < x + 5 && mouseX > x - 5 && mouseY > y - 5 && mouseY < y + 5) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], index);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: null, 'dataset': null, 4: index, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius) {\n      return this;\n    }\n  };this.drawHighlights = this.DrawHighlights = function () {\n    if (prop['chart.highlights']) {\n      var sequentialIdx = 0;var dataset = 0;var index = 0;var radius = prop['chart.highlights.radius'];for (var dataset = 0; dataset < this.data.length; ++dataset) {\n        for (var index = 0; index < this.data[dataset].length; ++index) {\n          co.beginPath();co.strokeStyle = prop['chart.highlights.stroke'];co.fillStyle = prop['chart.highlights.fill'] ? prop['chart.highlights.fill'] : _typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset] ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];co.arc(this.coords[sequentialIdx][0], this.coords[sequentialIdx][1], radius, 0, RG.TWOPI, false);co.stroke();co.fill();++sequentialIdx;\n        }\n      }\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var radius = value / this.max * this.radius;return radius;\n  };this.getAngle = function (numitems, index) {\n    var angle = RG.TWOPI / numitems * index;angle -= RG.HALFPI;return angle;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.circle.fill'] = RG.array_clone(prop['chart.circle.fill']);this.original_colors['chart.circle.stroke'] = RG.array_clone(prop['chart.circle.stroke']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    var keyColors = prop['chart.key.colors'];if (typeof keyColors != 'null' && keyColors && keyColors.length) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.circle.fill'] = this.parseSingleColorForGradient(prop['chart.circle.fill']);prop['chart.circle.stroke'] = this.parseSingleColorForGradient(prop['chart.circle.stroke']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.addFillListeners = this.AddFillListeners = function (e) {\n    var obj = this;var func = function func(e) {\n      var coords = this.coords;var coords2 = this.coords2;var mouseXY = RG.getMouseXY(e);var dataset = 0;if (e.type == 'mousemove' && prop['chart.fill.mousemove.redraw']) {\n        RG.RedrawCanvas(ca);\n      }\n      for (var dataset = obj.coords2.length - 1; dataset >= 0; --dataset) {\n        co.beginPath();co.moveTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);for (var j = 0; j < obj.coords2[dataset].length; ++j) {\n          co.lineTo(obj.coords2[dataset][j][0], obj.coords2[dataset][j][1]);\n        }\n        co.lineTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n          co.lineTo(obj.coords2[dataset - 1][0][0], obj.coords2[dataset - 1][0][1]);for (var j = obj.coords2[dataset - 1].length - 1; j >= 0; --j) {\n            co.lineTo(obj.coords2[dataset - 1][j][0], obj.coords2[dataset - 1][j][1]);\n          }\n        }\n        co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n          var inPath = true;break;\n        }\n      }\n      if (inPath) {\n        var fillTooltips = prop['chart.fill.tooltips'];if (e.type == 'click') {\n          if (prop['chart.fill.click']) {\n            prop['chart.fill.click'](e, dataset);\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            obj.DatasetTooltip(e, dataset);\n          }\n        }\n        if (e.type == 'mousemove') {\n          if (prop['chart.fill.mousemove']) {\n            prop['chart.fill.mousemove'](e, dataset);\n          }\n          if (!RG.is_null(fillTooltips)) {\n            e.target.style.cursor = 'pointer';\n          }\n          if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {\n            e.target.style.cursor = 'pointer';\n          }\n        }\n        e.stopPropagation();\n      } else if (e.type == 'mousemove') {\n        ca.style.cursor = 'default';\n      }\n    };if (prop['chart.fill.click'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('click', func, false);\n    }\n    if (prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) {\n      ca.addEventListener('mousemove', func, false);\n    }\n  };this.highlightDataset = this.HighlightDataset = function (dataset) {\n    co.beginPath();for (var j = 0; j < this.coords2[dataset].length; ++j) {\n      if (j == 0) {\n        co.moveTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);\n      } else {\n        co.lineTo(this.coords2[dataset][j][0], this.coords2[dataset][j][1]);\n      }\n    }\n    co.lineTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);if (prop['chart.accumulative'] && dataset > 0) {\n      co.lineTo(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]);for (var j = this.coords2[dataset - 1].length - 1; j >= 0; --j) {\n        co.lineTo(this.coords2[dataset - 1][j][0], this.coords2[dataset - 1][j][1]);\n      }\n    }\n    co.strokeStyle = prop['chart.fill.highlight.stroke'];co.fillStyle = prop['chart.fill.highlight.fill'];co.stroke();co.fill();\n  };this.datasetTooltip = this.DatasetTooltip = function (e, dataset) {\n    this.HighlightDataset(dataset);var text = prop['chart.fill.tooltips'][dataset];var x = 0;var y = this.coords2[dataset][0][1] + RG.getCanvasXY(ca)[1];RG.Tooltip(this, text, x, y, 0, e);\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords2[index];if (coords) {\n      var pre_linewidth = co.lineWidth;var pre_linecap = co.lineCap;co.lineWidth = prop['chart.linewidth'] + 10;co.lineCap = 'round';co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.beginPath();for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (i == 0) {\n          co.moveTo(coords[i][0], coords[i][1]);\n        } else {\n          co.lineTo(coords[i][0], coords[i][1]);\n        }\n      }\n      co.closePath();co.stroke();co.lineWidth = pre_linewidth;co.lineCap = pre_linecap;\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this;var callback = arguments[1] ? arguments[1] : function () {};var opt = arguments[0] ? arguments[0] : {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var data = RG.array_clone(obj.data);function iterator() {\n      for (var i = 0, len = data.length; i < len; ++i) {\n        for (var j = 0, len2 = data[i].length; j < len2; ++j) {\n          obj.original_data[i][j] = frame / frames * data[i][j];\n        }\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.trace = function () {\n    var obj = this;var opt = arguments[0] || {};var frames = opt.frames || 60;var frame = 0;var callback = arguments[1] || function () {};obj.Set('animation.trace.clip', 0);var iterator = function iterator() {\n      if (frame < frames) {\n        obj.Set('animation.trace.clip', frame / frames);frame++;RG.redrawCanvas(obj.canvas);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.Set('animation.trace.clip', 1);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    };iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5yYWRhci5qcz8zNTYxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlJhZGFyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgdmFyIF9wcm9wZXJ0aWVzO1xuXG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihjb25mLmRhdGEpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7aWYgKHR5cGVvZiBjb25mLmRhdGFbMF0gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb25mLmRhdGFbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25mLmRhdGEgPSBbY29uZi5kYXRhXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbmYgPSB7IGlkOiBjb25mLCBkYXRhOiBbXSB9O2lmIChfdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmd1bWVudHNbMV1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25mLmRhdGEucHVzaChSR3JhcGguYXJyYXlDbG9uZShhcmd1bWVudHNbaV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYXJndW1lbnRzWzFdKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihhcmd1bWVudHNbMV1bMF0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdWzBdWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZi5kYXRhID0gUkdyYXBoLmFycmF5Q2xvbmUoYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5pZCA9IGNvbmYuaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnR5cGUgPSAncmFkYXInO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMuZGF0YSA9IFtdO3RoaXMubWF4ID0gMDt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfZGF0YSA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBjb25mLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbmYuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHR5cGVvZiBjb25mLmRhdGFbaV1bal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmYuZGF0YVtpXVtqXSA9IHBhcnNlRmxvYXQoY29uZi5kYXRhW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbF9kYXRhLnB1c2goUkdyYXBoLmFycmF5Q2xvbmUoY29uZi5kYXRhW2ldKSk7dGhpcy5kYXRhLnB1c2goUkdyYXBoLmFycmF5Q2xvbmUoY29uZi5kYXRhW2ldKSk7dGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgUkdyYXBoLmFycmF5TWF4KGNvbmYuZGF0YVtpXSkpO1xuICB9XG4gIHRoaXMucHJvcGVydGllcyA9IChfcHJvcGVydGllcyA9IHsgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJyNhYWEnLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmNvbG9ycyc6IFsncmdiYSgyNTUsMjU1LDAsMC4yNSknLCAncmdiYSgwLDI1NSwyNTUsMC4yNSknLCAncmdiYSgyNTUsMCwwLDAuNSknLCAncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAncGluaycsICdhcXVhJywgJ2Jyb3duJywgJ29yYW5nZScsICdncmV5J10sICdjaGFydC5jb2xvcnMuYWxwaGEnOiBudWxsLCAnY2hhcnQuY2lyY2xlJzogMCwgJ2NoYXJ0LmNpcmNsZS5maWxsJzogJ3JlZCcsICdjaGFydC5jaXJjbGUuc3Ryb2tlJzogJ2JsYWNrJywgJ2NoYXJ0LmxhYmVscyc6IFtdLCAnY2hhcnQubGFiZWxzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5vZmZzZXQnOiAxMCwgJ2NoYXJ0LmxhYmVscy5heGVzJzogJycsICdjaGFydC5sYWJlbHMuYmFja2dyb3VuZC5maWxsJzogJ3doaXRlJywgJ2NoYXJ0LmxhYmVscy5ib3hlZCc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLmF4ZXMuYm9sZCc6IFtdLCAnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQnOiBudWxsLCAnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQuemVybyc6IHRydWUsICdjaGFydC5sYWJlbHMuYXhlcy5ib3hlZC5iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC45KScsICdjaGFydC5sYWJlbHMuc3BlY2lmaWMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5jb3VudCc6IDUsICdjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLmNvdW50JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5jb2xvcic6ICcjZGRkJywgJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5wb2x5JzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5zcG9rZXMnOiAyNCwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5zaXplLnNjYWxlJzogbnVsbCwgJ2NoYXJ0LnRleHQuZm9udCc6ICdTZWdvZSBVSSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwgfSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubGluZXdpZHRoJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuYmFja2dyb3VuZCcsICd3aGl0ZScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuc2hhZG93JywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuc2hhZG93LmNvbG9yJywgJyM2NjYnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnNoYWRvdy5ibHVyJywgMyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCcsIDIpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknLCAyKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnBvc2l0aW9uJywgJ2dyYXBoJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5oYWxpZ24nLCAncmlnaHQnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCcsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnBvc2l0aW9uLngnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LnBvc2l0aW9uLnknLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmNvbG9yLnNoYXBlJywgJ3NxdWFyZScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkucm91bmRlZCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkubGluZXdpZHRoJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS5jb2xvcnMnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQua2V5LmludGVyYWN0aXZlJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZScsICdyZ2JhKDI1NSwwLDAsMC4zKScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmxhYmVsJywgJ3JnYmEoMjU1LDAsMCwwLjIpJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmtleS50ZXh0LmNvbG9yJywgJ2JsYWNrJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNvbnRleHRtZW51JywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFubm90YXRhYmxlJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hbm5vdGF0ZS5jb2xvcicsICdibGFjaycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhY3RvcicsIDEuNSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uZmFkZS5pbicsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZhZGUub3V0JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uaGRpcicsICdyaWdodCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLnZkaXInLCAnZG93bicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmZyYW1lcycsIDI1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuem9vbS5kZWxheScsIDE2LjY2NiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uc2hhZG93JywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC56b29tLmFjdGlvbicsICd6b29tJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCcsICdmYWRlJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JywgJ29ubW91c2Vtb3ZlJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcycsICdSR3JhcGhfdG9vbHRpcCcpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZScsICdncmF5JyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJywgJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5oaWdobGlnaHQucG9pbnQucmFkaXVzJywgMiksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJlc2l6YWJsZScsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnLCBbMCwgMF0pLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueW1heCcsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hY2N1bXVsYXRpdmUnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnJhZGl1cycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMuY2xpY2snLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZScsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS5kZWNpbWFscycsIDApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS5wb2ludCcsICcuJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJywgJywnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQudW5pdHMucHJlJywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC51bml0cy5wb3N0JywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcy5ldmVudCcsICdvbm1vdXNlbW92ZScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jZW50ZXJ4JywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNlbnRlcnknLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQucmFkaXVzJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0Lm51bXh0aWNrcycsIDUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5udW15dGlja3MnLCA1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYXhlcy5jb2xvcicsICdyZ2JhKDAsMCwwLDApJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmhpZ2hsaWdodHMnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmhpZ2hsaWdodHMuc3Ryb2tlJywgJyNkZGQnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuaGlnaGxpZ2h0cy5maWxsJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmhpZ2hsaWdodHMucmFkaXVzJywgMyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmZpbGwuY2xpY2snLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZmlsbC5tb3VzZW1vdmUnLCBudWxsKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuZmlsbC50b29sdGlwcycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5maWxsLmhpZ2hsaWdodC5maWxsJywgJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5maWxsLmhpZ2hsaWdodC5zdHJva2UnLCAncmdiYSgwLDAsMCwwKScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5maWxsLm1vdXNlbW92ZS5yZWRyYXcnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfcHJvcGVydGllcyk7XG4gIGZvciAodmFyIGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgdGhpcy5kYXRhLmxlbmd0aDsgKytkYXRhc2V0KSB7XG4gICAgaWYgKHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGggPCAzKSB7XG4gICAgICBhbGVydCgnW1JBREFSXSBZb3UgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IDMgZGF0YSBwb2ludHMnKTtyZXR1cm47XG4gICAgfVxuICB9XG4gIHZhciBpZHggPSAwO2ZvciAodmFyIGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgdGhpcy5kYXRhLmxlbmd0aDsgKytkYXRhc2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGhpc1snJCcgKyBpZHgrK10gPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18pIHtcbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTt0aGlzLmNhbnZhcy5fX3JncmFwaF9hYV90cmFuc2xhdGVkX18gPSB0cnVlO1xuICB9XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIGNhID0gdGhpcy5jYW52YXMsXG4gICAgICBjbyA9IGNhLmdldENvbnRleHQoJzJkJyksXG4gICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcGEyID0gUkcucGF0aDIsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIG1hID0gTWF0aDtcbiAgaWYgKFJHLkVmZmVjdHMgJiYgdHlwZW9mIFJHLkVmZmVjdHMuZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSRy5FZmZlY3RzLmRlY29yYXRlKHRoaXMpO1xuICB9XG4gIHRoaXMuc2V0ID0gdGhpcy5TZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC50ZXh0LmRpYW1ldGVyJykge1xuICAgICAgbmFtZSA9ICdjaGFydC50ZXh0LnNpemUnO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQuY29sb3InKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXNbJ2NoYXJ0LmNvbG9ycyddID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgcHJvcFtuYW1lXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnRleHQuZGlhbWV0ZXInKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LnRleHQuc2l6ZSc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWVdO1xuICB9O3RoaXMuZHJhdyA9IHRoaXMuRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO3RoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHMyID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5kYXRhID0gUkcuYXJyYXlDbG9uZSh0aGlzLm9yaWdpbmFsX2RhdGEpO2lmIChwcm9wWydjaGFydC5hY2N1bXVsYXRpdmUnXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXS5sZW5ndGggIT0gdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuICAgICAgICAgIGFsZXJ0KCdbUkFEQVJdIEVycm9yISBXaGVuIHRoZSByYWRhciBoYXMgY2hhcnQuYWNjdW11bGF0aXZlIHNldCB0byB0cnVlIGFsbCB0aGUgZGF0YXNldHMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChSRy5pc051bGwocHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQnXSkpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJ10gPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IChwcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGggfHwgcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10gfHwgNSk7ICsraSkge1xuICAgICAgICBwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5ib3hlZCddW2ldID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuY2VudGVyeCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiArIHRoaXMuZ3V0dGVyTGVmdDt0aGlzLmNlbnRlcnkgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3A7dGhpcy5yYWRpdXMgPSBNYXRoLm1pbihjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMjtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXSA9PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ4ID0gMiAqIHByb3BbJ2NoYXJ0LmNlbnRlcngnXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcnknXSA9PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ5ID0gMiAqIHByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghcHJvcFsnY2hhcnQueW1heCddKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10pIHtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGlvbiA9IFtdO3ZhciBsZW4gPSB0aGlzLm9yaWdpbmFsX2RhdGFbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMub3JpZ2luYWxfZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0aGlzLm9yaWdpbmFsX2RhdGFbaV0ubGVuZ3RoICE9IGxlbikge1xuICAgICAgICAgICAgYWxlcnQoJ1tSQURBUl0gRXJyb3IhIFN0YWNrZWQgUmFkYXIgY2hhcnQgZGF0YXNldHMgbXVzdCBhbGwgYmUgdGhlIHNhbWUgc2l6ZSEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm9yaWdpbmFsX2RhdGFbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXSArPSB0aGlzLmRhdGFbaSAtIDFdW2pdO3RoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMuZGF0YVtpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiB0eXBlb2YgcHJvcFsnY2hhcnQueW1heCddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQueW1heCddIDogdGhpcy5tYXgsICdtaW4nOiAwLCAnc2NhbGUuZGVjaW1hbHMnOiBOdW1iZXIocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5bWF4ID0gcHJvcFsnY2hhcnQueW1heCddO3RoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHltYXgsICdtaW4nOiAwLCAnc3RyaWN0JzogdHJ1ZSwgJ3NjYWxlLmRlY2ltYWxzJzogTnVtYmVyKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucm91bmQnOiBwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCAndW5pdHMucHJlJzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sICd1bml0cy5wb3N0JzogcHJvcFsnY2hhcnQudW5pdHMucG9zdCddLCAneWxhYmVscy5jb3VudCc6IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddIH0pO3RoaXMubWF4ID0gdGhpcy5zY2FsZTIubWF4O1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7dGhpcy5kcmF3QXhlcygpO3RoaXMuZHJhd0NpcmNsZSgpO3RoaXMuZHJhd0xhYmVscygpO2NvLnNhdmUoKTtjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzICogMiwgLVJHLkhBTEZQSSwgUkcuVFdPUEkgKiBwcm9wWydjaGFydC5hbmltYXRpb24udHJhY2UuY2xpcCddIC0gUkcuSEFMRlBJLCBmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5jbG9zZVBhdGgoKTtjby5jbGlwKCk7dGhpcy5EcmF3Q2hhcnQoKTt0aGlzLkRyYXdIaWdobGlnaHRzKCk7Y28ucmVzdG9yZSgpO3RoaXMuZHJhd0F4aXNMYWJlbHMoKTtpZiAocHJvcFsnY2hhcnQudGl0bGUnXSkge1xuICAgICAgUkcuRHJhd1RpdGxlKHRoaXMsIHByb3BbJ2NoYXJ0LnRpdGxlJ10sIHRoaXMuZ3V0dGVyVG9wLCBudWxsLCBwcm9wWydjaGFydC50aXRsZS5kaWFtZXRlciddID8gcHJvcFsnY2hhcnQudGl0bGUuZGlhbWV0ZXInXSA6IG51bGwpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQua2V5J10pIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywgcHJvcFsnY2hhcnQua2V5J10sIHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmNvbnRleHRtZW51J10pIHtcbiAgICAgIFJHLlNob3dDb250ZXh0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAoKHByb3BbJ2NoYXJ0LmZpbGwuY2xpY2snXSB8fCBwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZSddIHx8ICFSRy5pc19udWxsKHByb3BbJ2NoYXJ0LmZpbGwudG9vbHRpcHMnXSkpICYmICF0aGlzLl9fZmlsbF9jbGlja19saXN0ZW5lcnNfaW5zdGFsbGVkX18pIHtcbiAgICAgIHRoaXMuQWRkRmlsbExpc3RlbmVycygpO3RoaXMuX19maWxsX2NsaWNrX2xpc3RlbmVyc19pbnN0YWxsZWRfXyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHcmFwaC5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdCYWNrZ3JvdW5kID0gdGhpcy5EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29sb3IgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuY29sb3InXTt2YXIgcG9seSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5wb2x5J107dmFyIHNwYWNpbmcgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuc3BhY2luZyddO3ZhciBzcG9rZXMgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuc3Bva2VzJ107Y28ubGluZVdpZHRoID0gMTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzJ10gJiYgcG9seSA9PSBmYWxzZSkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtjby5iZWdpblBhdGgoKTt2YXIgbnVtcmluZ3MgPSB0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzLmNvdW50J10gPT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuY291bnQnXSA6IHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddO2ZvciAodmFyIHIgPSAwOyByIDw9IHRoaXMucmFkaXVzOyByICs9IHRoaXMucmFkaXVzIC8gbnVtcmluZ3MpIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHIsIDAsIFJHLlRXT1BJLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjby5zdHJva2UoKTtjby5zdHJva2VTdHlsZSA9IGNvbG9yO2ZvciAodmFyIGkgPSAwOyBpIDwgMzYwOyBpICs9IDM2MCAvIHNwb2tlcykge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5hcmModGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzLCBpIC8gMzYwICogUkcuVFdPUEksIChpICsgMC4wMDEpIC8gMzYwICogUkcuVFdPUEksIGZhbHNlKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5jaXJjbGVzJ10gJiYgcG9seSA9PSB0cnVlKSB7XG4gICAgICBjby5zdHJva2VTdHlsZSA9IGNvbG9yO3ZhciBpbmNyZW1lbnQgPSAzNjAgLyB0aGlzLmRhdGFbMF0ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzNjA7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIGkgLyAzNjAgKiBSRy5UV09QSSAtIFJHLkhBTEZQSSwgKGkgKyAwLjAwMSkgLyAzNjAgKiBSRy5UV09QSSAtIFJHLkhBTEZQSSwgZmFsc2UpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSk7Y28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjby5zdHJva2VTdHlsZSA9IGNvbG9yO3ZhciBudW1yaW5ncyA9IHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNpcmNsZXMuY291bnQnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY2lyY2xlcy5jb3VudCddIDogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107Zm9yICh2YXIgciA9IDA7IHIgPD0gdGhpcy5yYWRpdXM7IHIgKz0gdGhpcy5yYWRpdXMgLyBudW1yaW5ncykge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtmb3IgKHZhciBhID0gMDsgYSA8PSAzNjA7IGEgKz0gMzYwIC8gdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuICAgICAgICAgIGNvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgciwgUkcuZGVncmVlczJSYWRpYW5zKGEpIC0gUkcuSEFMRlBJLCBSRy5kZWdyZWVzMlJhZGlhbnMoYSkgKyAwLjAwMSAtIFJHLkhBTEZQSSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdBeGVzID0gdGhpcy5EcmF3QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmF4ZXMuY29sb3InXTt2YXIgaGFsZnNpemUgPSB0aGlzLnJhZGl1cztjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh0aGlzLmNlbnRlcngpLCB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyk7Y28ubGluZVRvKE1hdGgucm91bmQodGhpcy5jZW50ZXJ4KSwgdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXMpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSA1LCBNYXRoLnJvdW5kKHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCArIDUsIE1hdGgucm91bmQodGhpcy5jZW50ZXJ5ICsgdGhpcy5yYWRpdXMpKTtjby5tb3ZlVG8odGhpcy5jZW50ZXJ4IC0gNSwgTWF0aC5yb3VuZCh0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cykpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyA1LCBNYXRoLnJvdW5kKHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzKSk7Zm9yICh2YXIgeSA9IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzOyB5IDwgdGhpcy5jZW50ZXJ5ICsgdGhpcy5yYWRpdXM7IHkgKz0gdGhpcy5yYWRpdXMgLyBwcm9wWydjaGFydC5udW15dGlja3MnXSkge1xuICAgICAgY28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIDMsIE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyAzLCBNYXRoLnJvdW5kKHkpKTtcbiAgICB9XG4gICAgY28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzLCBNYXRoLnJvdW5kKHRoaXMuY2VudGVyeSkpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cywgTWF0aC5yb3VuZCh0aGlzLmNlbnRlcnkpKTtjby5tb3ZlVG8oTWF0aC5yb3VuZCh0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSAtIDUpO2NvLmxpbmVUbyhNYXRoLnJvdW5kKHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzKSwgdGhpcy5jZW50ZXJ5ICsgNSk7Y28ubW92ZVRvKE1hdGgucm91bmQodGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMpLCB0aGlzLmNlbnRlcnkgLSA1KTtjby5saW5lVG8oTWF0aC5yb3VuZCh0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSArIDUpO2ZvciAodmFyIHggPSB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1czsgeCA8IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzOyB4ICs9IHRoaXMucmFkaXVzIC8gcHJvcFsnY2hhcnQubnVteHRpY2tzJ10pIHtcbiAgICAgIGNvLm1vdmVUbyhNYXRoLnJvdW5kKHgpLCB0aGlzLmNlbnRlcnkgLSAzKTtjby5saW5lVG8oTWF0aC5yb3VuZCh4KSwgdGhpcy5jZW50ZXJ5ICsgMyk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1xuICB9O3RoaXMuZHJhd0NoYXJ0ID0gdGhpcy5EcmF3Q2hhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFscGhhID0gcHJvcFsnY2hhcnQuY29sb3JzLmFscGhhJ107aWYgKHR5cGVvZiBhbHBoYSA9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG9sZEFscGhhID0gY28uZ2xvYmFsQWxwaGE7Y28uZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgdmFyIG51bURhdGFzZXRzID0gdGhpcy5kYXRhLmxlbmd0aDtmb3IgKHZhciBkYXRhc2V0ID0gMDsgZGF0YXNldCA8IHRoaXMuZGF0YS5sZW5ndGg7ICsrZGF0YXNldCkge1xuICAgICAgY28uYmVnaW5QYXRoKCk7dmFyIGNvb3Jkc19kYXRhc2V0ID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFbZGF0YXNldF0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuR2V0Q29vcmRpbmF0ZXMoZGF0YXNldCwgaSk7aWYgKGNvb3Jkc19kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICBjb29yZHNfZGF0YXNldCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvb3Jkc19kYXRhc2V0LnB1c2goY29vcmRzKTt0aGlzLmNvb3Jkcy5wdXNoKGNvb3Jkcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvb3JkczJbZGF0YXNldF0gPSBjb29yZHNfZGF0YXNldDtjby5zdHJva2VTdHlsZSA9IF90eXBlb2YocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSkgPT0gJ29iamVjdCcgJiYgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXVtkYXRhc2V0XSA/IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ11bZGF0YXNldF0gOiBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2RhdGFzZXRdID8gcHJvcFsnY2hhcnQuY29sb3JzJ11bZGF0YXNldF0gOiAncmdiYSgwLDAsMCwwKSc7aWYgKGNvLmZpbGxTdHlsZSA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjby5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICB9XG4gICAgICBjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXTtmb3IgKGkgPSAwOyBpIDwgY29vcmRzX2RhdGFzZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgIGNvLm1vdmVUbyhjb29yZHNfZGF0YXNldFtpXVswXSwgY29vcmRzX2RhdGFzZXRbaV1bMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLmxpbmVUbyhjb29yZHNfZGF0YXNldFtpXVswXSwgY29vcmRzX2RhdGFzZXRbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYWNjdW11bGF0aXZlJ10gJiYgZGF0YXNldCA+IDApIHtcbiAgICAgICAgY28ubGluZVRvKGNvb3Jkc19kYXRhc2V0WzBdWzBdLCBjb29yZHNfZGF0YXNldFswXVsxXSk7Y28ubW92ZVRvKGxhc3RfY29vcmRzWzBdWzBdLCBsYXN0X2Nvb3Jkc1swXVsxXSk7Zm9yICh2YXIgaSA9IGNvb3Jkc19kYXRhc2V0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgY28ubGluZVRvKGxhc3RfY29vcmRzW2ldWzBdLCBsYXN0X2Nvb3Jkc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBsYXN0X2Nvb3JkcyA9IGNvb3Jkc19kYXRhc2V0O2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbHBoYSA9PSAnbnVtYmVyJykge1xuICAgICAgY28uZ2xvYmFsQWxwaGEgPSBvbGRBbHBoYTtcbiAgICB9XG4gIH07dGhpcy5nZXRDb29yZGluYXRlcyA9IHRoaXMuR2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZGF0YXNldCwgaW5kZXgpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDt2YXIgbWFnID0gdGhpcy5kYXRhW2RhdGFzZXRdW2luZGV4XSAvIHRoaXMubWF4ICogdGhpcy5yYWRpdXM7dmFyIGFuZ2xlID0gUkcuVFdPUEkgLyBsZW4gKiBpbmRleDthbmdsZSAtPSBSRy5IQUxGUEk7dmFyIHggPSBNYXRoLmNvcyhhbmdsZSkgKiBtYWc7dmFyIHkgPSBNYXRoLnNpbihhbmdsZSkgKiBtYWc7eCA9IHRoaXMuY2VudGVyeCArIHg7eSA9IHRoaXMuY2VudGVyeSArIHk7cmV0dXJuIFt4LCB5XTtcbiAgfTt0aGlzLmRyYXdMYWJlbHMgPSB0aGlzLkRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscyddO2lmIChsYWJlbHMgJiYgbGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvLmxpbmVXaWR0aCA9IDE7Y28uc3Ryb2tlU3R5bGUgPSAnZ3JheSc7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBiZ0ZpbGwgPSBwcm9wWydjaGFydC5sYWJlbHMuYmFja2dyb3VuZC5maWxsJ10sXG4gICAgICAgICAgYm9sZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ10sXG4gICAgICAgICAgYmdCb3hlZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5ib3hlZCddLFxuICAgICAgICAgIG9mZnNldCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQnXSxcbiAgICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gUkcuVFdPUEkgLyBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggKiBpO2FuZ2xlIC09IFJHLkhBTEZQSTt2YXIgeCA9IHRoaXMuY2VudGVyeCArIG1hLmNvcyhhbmdsZSkgKiAocmFkaXVzICsgb2Zmc2V0KTt2YXIgeSA9IHRoaXMuY2VudGVyeSArIG1hLnNpbihhbmdsZSkgKiAocmFkaXVzICsgb2Zmc2V0KTt2YXIgaGFsaWduID0geCA8IHRoaXMuY2VudGVyeCA/ICdyaWdodCcgOiAnbGVmdCc7aWYgKGkgPT0gMCB8fCBpIC8gbGFiZWxzLmxlbmd0aCA9PSAwLjUpIGhhbGlnbiA9ICdjZW50ZXInO2lmIChsYWJlbHNbaV0gJiYgbGFiZWxzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2NvbG9yJzogY29sb3IsICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHgsICd5JzogeSwgJ3RleHQnOiBsYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGhhbGlnbiwgJ2JvdW5kaW5nJzogYmdCb3hlZCwgJ2JvdW5kaW5nRmlsbCc6IGJnRmlsbCwgJ2JvbGQnOiBib2xkLCAndGFnJzogJ2xhYmVscycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3Q2lyY2xlID0gdGhpcy5EcmF3Q2lyY2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaXJjbGUgPSB7fTtjaXJjbGUubGltaXQgPSBwcm9wWydjaGFydC5jaXJjbGUnXTtjaXJjbGUuZmlsbCA9IHByb3BbJ2NoYXJ0LmNpcmNsZS5maWxsJ107Y2lyY2xlLnN0cm9rZSA9IHByb3BbJ2NoYXJ0LmNpcmNsZS5zdHJva2UnXTtpZiAoY2lyY2xlLmxpbWl0KSB7XG4gICAgICB2YXIgciA9IGNpcmNsZS5saW1pdCAvIHRoaXMubWF4ICogdGhpcy5yYWRpdXM7Y28uZmlsbFN0eWxlID0gY2lyY2xlLmZpbGw7Y28uc3Ryb2tlU3R5bGUgPSBjaXJjbGUuc3Ryb2tlO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgciwgMCwgUkcuVFdPUEksIDApO2NvLmZpbGwoKTtjby5zdHJva2UoKTtcbiAgICB9XG4gIH07dGhpcy5kcmF3QXhpc0xhYmVscyA9IHRoaXMuRHJhd0F4aXNMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJHLmlzQXJyYXkocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10pICYmIHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddLmxlbmd0aCkge1xuICAgICAgdGhpcy5kcmF3U3BlY2lmaWNBeGlzTGFiZWxzKCk7cmV0dXJuO1xuICAgIH1cbiAgICBjby5saW5lV2lkdGggPSAxO2NvLmZpbGxTdHlsZSA9ICdibGFjayc7Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO3ZhciByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgc2l6ZSA9IHR5cGVvZiBwcm9wWydjaGFydC50ZXh0LnNpemUuc2NhbGUnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZS5zY2FsZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIGF4ZXMgPSBwcm9wWydjaGFydC5sYWJlbHMuYXhlcyddLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbG9yID0gcHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQuYmFja2dyb3VuZCddLFxuICAgICAgICBkcmF3emVybyA9IGZhbHNlLFxuICAgICAgICB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSxcbiAgICAgICAgdW5pdHNfcG9zdCA9IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxcbiAgICAgICAgZGVjaW1hbHMgPSBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLFxuICAgICAgICBib2xkID0gcHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm9sZCddLFxuICAgICAgICBib3hlZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJveGVkJ10sXG4gICAgICAgIGNlbnRlcnggPSB0aGlzLmNlbnRlcngsXG4gICAgICAgIGNlbnRlcnkgPSB0aGlzLmNlbnRlcnksXG4gICAgICAgIHNjYWxlID0gdGhpcy5zY2FsZTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYgKGF4ZXMuaW5kZXhPZignbicpID4gLTEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2JvbGQnOiBib2xkW2ldLCAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4LCAneSc6IGNlbnRlcnkgLSByICogKChpICsgMSkgLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoKSwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiBib3hlZFtpXSB8fCBjb2xvciwgJ2JvdW5kaW5nRmlsbCc6IGNvbG9yLCAnYm91bmRpbmdTdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgICAgZHJhd3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYXhlcy5pbmRleE9mKCdzJykgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnYm9sZCc6IGJvbGRbaV0sICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcngsICd5JzogY2VudGVyeSArIHIgKiAoKGkgKyAxKSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICdib3VuZGluZyc6IGJveGVkW2ldIHx8IGNvbG9yLCAnYm91bmRpbmdGaWxsJzogY29sb3IsICdib3VuZGluZ1N0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9XG4gICAgICBkcmF3emVybyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChheGVzLmluZGV4T2YoJ2UnKSA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdib2xkJzogYm9sZFtpXSwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCArIHIgKiAoKGkgKyAxKSAvIHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGgpLCAneSc6IGNlbnRlcnksICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogYm94ZWRbaV0gfHwgY29sb3IsICdib3VuZGluZ0ZpbGwnOiBjb2xvciwgJ2JvdW5kaW5nU3Ryb2tlJzogJ3JnYmEoMCwwLDAsMCknLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGRyYXd6ZXJvID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGF4ZXMuaW5kZXhPZigndycpID4gLTEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2JvbGQnOiBib2xkW2ldLCAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4IC0gciAqICgoaSArIDEpIC8gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aCksICd5JzogY2VudGVyeSwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiBib3hlZFtpXSB8fCBjb2xvciwgJ2JvdW5kaW5nRmlsbCc6IGNvbG9yLCAnYm91bmRpbmdTdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgICAgZHJhd3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZHJhd3plcm8pIHtcbiAgICAgIFJHLlRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogY2VudGVyeCwgeTogY2VudGVyeSwgdGV4dDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIE51bWJlcigwKS50b0ZpeGVkKCksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogJ2NlbnRlcicsIGJvdW5kaW5nOiBwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5ib3hlZC56ZXJvJ10sIGJvdW5kaW5nRmlsbDogY29sb3IsIGJvdW5kaW5nU3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsIGJvbGQ6IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJvbGQuemVybyddLCB0YWc6ICdzY2FsZScgfSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd1NwZWNpZmljQXhpc0xhYmVscyA9IHRoaXMuRHJhd1NwZWNpZmljQXhpc0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ107dmFyIGJvbGQgPSBSRy5hcnJheV9wYWQocHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm9sZCddLCBsYWJlbHMubGVuZ3RoKTt2YXIgYm94ZWQgPSBSRy5hcnJheV9wYWQocHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYm94ZWQnXSwgbGFiZWxzLmxlbmd0aCk7dmFyIHJldmVyc2VkX2xhYmVscyA9IFJHLmFycmF5X3JldmVyc2UobGFiZWxzKTt2YXIgcmV2ZXJzZWRfYm9sZCA9IFJHLmFycmF5X3JldmVyc2UoYm9sZCk7dmFyIHJldmVyc2VkX2JveGVkID0gUkcuYXJyYXlfcmV2ZXJzZShib3hlZCk7dmFyIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZSA9IHR5cGVvZiBwcm9wWydjaGFydC50ZXh0LnNpemUuc2NhbGUnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZS5zY2FsZSddIDogcHJvcFsnY2hhcnQudGV4dC5zaXplJ107dmFyIGF4ZXMgPSBwcm9wWydjaGFydC5sYWJlbHMuYXhlcyddLnRvTG93ZXJDYXNlKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2ZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKCduJykgPiAtMSkgUkcuVGV4dDIodGhpcywgeyAndGFnJzogJ2xhYmVscy5zcGVjaWZpYycsICdib2xkJzogcmV2ZXJzZWRfYm9sZFtpXSwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogdGhpcy5jZW50ZXJ4LCAneSc6IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICsgdGhpcy5yYWRpdXMgLyBsYWJlbHMubGVuZ3RoICogaSwgJ3RleHQnOiByZXZlcnNlZF9sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiByZXZlcnNlZF9ib3hlZFtpXSwgJ2JvdW5kaW5nRmlsbCc6ICd3aGl0ZScgfSk7aWYgKGF4ZXMuaW5kZXhPZigncycpID4gLTEpIFJHLlRleHQyKHRoaXMsIHsgJ3RhZyc6ICdsYWJlbHMuc3BlY2lmaWMnLCAnYm9sZCc6IGJvbGRbaV0sICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuY2VudGVyeCwgJ3knOiB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyAvIGxhYmVscy5sZW5ndGggKiAoaSArIDEpLCAndGV4dCc6IGxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICdib3VuZGluZyc6IGJveGVkW2ldLCAnYm91bmRpbmdGaWxsJzogJ3doaXRlJyB9KTtpZiAoYXhlcy5pbmRleE9mKCd3JykgPiAtMSkgUkcuVGV4dDIodGhpcywgeyAndGFnJzogJ2xhYmVscy5zcGVjaWZpYycsICdib2xkJzogcmV2ZXJzZWRfYm9sZFtpXSwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogdGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAvIGxhYmVscy5sZW5ndGggKiBpLCAneSc6IHRoaXMuY2VudGVyeSwgJ3RleHQnOiByZXZlcnNlZF9sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiByZXZlcnNlZF9ib3hlZFtpXSwgJ2JvdW5kaW5nRmlsbCc6ICd3aGl0ZScgfSk7aWYgKGF4ZXMuaW5kZXhPZignZScpID4gLTEpIFJHLlRleHQyKHRoaXMsIHsgJ3RhZyc6ICdsYWJlbHMuc3BlY2lmaWMnLCAnYm9sZCc6IGJvbGRbaV0sICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzIC8gbGFiZWxzLmxlbmd0aCAqIChpICsgMSksICd5JzogdGhpcy5jZW50ZXJ5LCAndGV4dCc6IGxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogJ2NlbnRlcicsICdib3VuZGluZyc6IGJveGVkW2ldLCAnYm91bmRpbmdGaWxsJzogJ3doaXRlJyB9KTtcbiAgICB9XG4gIH07dGhpcy5nZXRTaGFwZSA9IHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5jb29yZHNbaV1bMF07dmFyIHkgPSB0aGlzLmNvb3Jkc1tpXVsxXTt2YXIgdG9vbHRpcHMgPSBwcm9wWydjaGFydC50b29sdGlwcyddO3ZhciBpbmRleCA9IE51bWJlcihpKTt2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKG1vdXNlWCA8IHggKyA1ICYmIG1vdXNlWCA+IHggLSA1ICYmIG1vdXNlWSA+IHkgLSA1ICYmIG1vdXNlWSA8IHkgKyA1KSB7XG4gICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCBpbmRleCk7cmV0dXJuIHsgMDogdGhpcywgJ29iamVjdCc6IHRoaXMsIDE6IHgsICd4JzogeCwgMjogeSwgJ3knOiB5LCAzOiBudWxsLCAnZGF0YXNldCc6IG51bGwsIDQ6IGluZGV4LCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlBvaW50KHRoaXMsIHNoYXBlKTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7aWYgKG1vdXNlWFlbMF0gPiB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzBdIDwgdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgJiYgbW91c2VYWVsxXSA+IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICYmIG1vdXNlWFlbMV0gPCB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZHJhd0hpZ2hsaWdodHMgPSB0aGlzLkRyYXdIaWdobGlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5oaWdobGlnaHRzJ10pIHtcbiAgICAgIHZhciBzZXF1ZW50aWFsSWR4ID0gMDt2YXIgZGF0YXNldCA9IDA7dmFyIGluZGV4ID0gMDt2YXIgcmFkaXVzID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0cy5yYWRpdXMnXTtmb3IgKHZhciBkYXRhc2V0ID0gMDsgZGF0YXNldCA8IHRoaXMuZGF0YS5sZW5ndGg7ICsrZGF0YXNldCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0cy5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5oaWdobGlnaHRzLmZpbGwnXSA/IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodHMuZmlsbCddIDogX3R5cGVvZihwcm9wWydjaGFydC5zdHJva2VzdHlsZSddKSA9PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddW2RhdGFzZXRdID8gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXVtkYXRhc2V0XSA6IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uYXJjKHRoaXMuY29vcmRzW3NlcXVlbnRpYWxJZHhdWzBdLCB0aGlzLmNvb3Jkc1tzZXF1ZW50aWFsSWR4XVsxXSwgcmFkaXVzLCAwLCBSRy5UV09QSSwgZmFsc2UpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTsrK3NlcXVlbnRpYWxJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRSYWRpdXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy5tYXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmFkaXVzID0gdmFsdWUgLyB0aGlzLm1heCAqIHRoaXMucmFkaXVzO3JldHVybiByYWRpdXM7XG4gIH07dGhpcy5nZXRBbmdsZSA9IGZ1bmN0aW9uIChudW1pdGVtcywgaW5kZXgpIHtcbiAgICB2YXIgYW5nbGUgPSBSRy5UV09QSSAvIG51bWl0ZW1zICogaW5kZXg7YW5nbGUgLT0gUkcuSEFMRlBJO3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQua2V5LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQua2V5LmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQudGl0bGUuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50ZXh0LmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNpcmNsZS5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jaXJjbGUuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY2lyY2xlLnN0cm9rZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY2lyY2xlLnN0cm9rZSddKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5jb2xvcnMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgcHJvcFsnY2hhcnQuY29sb3JzJ11baV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVtpXSk7XG4gICAgfVxuICAgIHZhciBrZXlDb2xvcnMgPSBwcm9wWydjaGFydC5rZXkuY29sb3JzJ107aWYgKHR5cGVvZiBrZXlDb2xvcnMgIT0gJ251bGwnICYmIGtleUNvbG9ycyAmJiBrZXlDb2xvcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgICBwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wWydjaGFydC50aXRsZS5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSk7cHJvcFsnY2hhcnQudGV4dC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQudGV4dC5jb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wWydjaGFydC5jaXJjbGUuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY2lyY2xlLmZpbGwnXSk7cHJvcFsnY2hhcnQuY2lyY2xlLnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY2lyY2xlLnN0cm9rZSddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCAwLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMpO3ZhciBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTtncmFkLmFkZENvbG9yU3RvcCgwLCBSRy50cmltKHBhcnRzWzBdKSk7Zm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLmFkZEZpbGxMaXN0ZW5lcnMgPSB0aGlzLkFkZEZpbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBmdW5jID0gZnVuY3Rpb24gZnVuYyhlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHM7dmFyIGNvb3JkczIgPSB0aGlzLmNvb3JkczI7dmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO3ZhciBkYXRhc2V0ID0gMDtpZiAoZS50eXBlID09ICdtb3VzZW1vdmUnICYmIHByb3BbJ2NoYXJ0LmZpbGwubW91c2Vtb3ZlLnJlZHJhdyddKSB7XG4gICAgICAgIFJHLlJlZHJhd0NhbnZhcyhjYSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBkYXRhc2V0ID0gb2JqLmNvb3JkczIubGVuZ3RoIC0gMTsgZGF0YXNldCA+PSAwOyAtLWRhdGFzZXQpIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKG9iai5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLCBvYmouY29vcmRzMltkYXRhc2V0XVswXVsxXSk7Zm9yICh2YXIgaiA9IDA7IGogPCBvYmouY29vcmRzMltkYXRhc2V0XS5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGNvLmxpbmVUbyhvYmouY29vcmRzMltkYXRhc2V0XVtqXVswXSwgb2JqLmNvb3JkczJbZGF0YXNldF1bal1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvLmxpbmVUbyhvYmouY29vcmRzMltkYXRhc2V0XVswXVswXSwgb2JqLmNvb3JkczJbZGF0YXNldF1bMF1bMV0pO2lmIChwcm9wWydjaGFydC5hY2N1bXVsYXRpdmUnXSAmJiBkYXRhc2V0ID4gMCkge1xuICAgICAgICAgIGNvLmxpbmVUbyhvYmouY29vcmRzMltkYXRhc2V0IC0gMV1bMF1bMF0sIG9iai5jb29yZHMyW2RhdGFzZXQgLSAxXVswXVsxXSk7Zm9yICh2YXIgaiA9IG9iai5jb29yZHMyW2RhdGFzZXQgLSAxXS5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgY28ubGluZVRvKG9iai5jb29yZHMyW2RhdGFzZXQgLSAxXVtqXVswXSwgb2JqLmNvb3JkczJbZGF0YXNldCAtIDFdW2pdWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY28uY2xvc2VQYXRoKCk7aWYgKGNvLmlzUG9pbnRJblBhdGgobW91c2VYWVswXSwgbW91c2VYWVsxXSkpIHtcbiAgICAgICAgICB2YXIgaW5QYXRoID0gdHJ1ZTticmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluUGF0aCkge1xuICAgICAgICB2YXIgZmlsbFRvb2x0aXBzID0gcHJvcFsnY2hhcnQuZmlsbC50b29sdGlwcyddO2lmIChlLnR5cGUgPT0gJ2NsaWNrJykge1xuICAgICAgICAgIGlmIChwcm9wWydjaGFydC5maWxsLmNsaWNrJ10pIHtcbiAgICAgICAgICAgIHByb3BbJ2NoYXJ0LmZpbGwuY2xpY2snXShlLCBkYXRhc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LmZpbGwudG9vbHRpcHMnXSAmJiBwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ11bZGF0YXNldF0pIHtcbiAgICAgICAgICAgIG9iai5EYXRhc2V0VG9vbHRpcChlLCBkYXRhc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudHlwZSA9PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgIGlmIChwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZSddKSB7XG4gICAgICAgICAgICBwcm9wWydjaGFydC5maWxsLm1vdXNlbW92ZSddKGUsIGRhdGFzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVJHLmlzX251bGwoZmlsbFRvb2x0aXBzKSkge1xuICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQuZmlsbC50b29sdGlwcyddICYmIHByb3BbJ2NoYXJ0LmZpbGwudG9vbHRpcHMnXVtkYXRhc2V0XSkge1xuICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgY2Euc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgIH07aWYgKHByb3BbJ2NoYXJ0LmZpbGwuY2xpY2snXSB8fCAhUkcuaXNfbnVsbChwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ10pKSB7XG4gICAgICBjYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmMsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmZpbGwubW91c2Vtb3ZlJ10gfHwgIVJHLmlzX251bGwocHJvcFsnY2hhcnQuZmlsbC50b29sdGlwcyddKSkge1xuICAgICAgY2EuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuYywgZmFsc2UpO1xuICAgIH1cbiAgfTt0aGlzLmhpZ2hsaWdodERhdGFzZXQgPSB0aGlzLkhpZ2hsaWdodERhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGNvLmJlZ2luUGF0aCgpO2ZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb29yZHMyW2RhdGFzZXRdLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgIGNvLm1vdmVUbyh0aGlzLmNvb3JkczJbZGF0YXNldF1bMF1bMF0sIHRoaXMuY29vcmRzMltkYXRhc2V0XVswXVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5saW5lVG8odGhpcy5jb29yZHMyW2RhdGFzZXRdW2pdWzBdLCB0aGlzLmNvb3JkczJbZGF0YXNldF1bal1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5saW5lVG8odGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzBdLCB0aGlzLmNvb3JkczJbZGF0YXNldF1bMF1bMV0pO2lmIChwcm9wWydjaGFydC5hY2N1bXVsYXRpdmUnXSAmJiBkYXRhc2V0ID4gMCkge1xuICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzMltkYXRhc2V0IC0gMV1bMF1bMF0sIHRoaXMuY29vcmRzMltkYXRhc2V0IC0gMV1bMF1bMV0pO2ZvciAodmFyIGogPSB0aGlzLmNvb3JkczJbZGF0YXNldCAtIDFdLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIGNvLmxpbmVUbyh0aGlzLmNvb3JkczJbZGF0YXNldCAtIDFdW2pdWzBdLCB0aGlzLmNvb3JkczJbZGF0YXNldCAtIDFdW2pdWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5maWxsLmhpZ2hsaWdodC5zdHJva2UnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5maWxsLmhpZ2hsaWdodC5maWxsJ107Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICB9O3RoaXMuZGF0YXNldFRvb2x0aXAgPSB0aGlzLkRhdGFzZXRUb29sdGlwID0gZnVuY3Rpb24gKGUsIGRhdGFzZXQpIHtcbiAgICB0aGlzLkhpZ2hsaWdodERhdGFzZXQoZGF0YXNldCk7dmFyIHRleHQgPSBwcm9wWydjaGFydC5maWxsLnRvb2x0aXBzJ11bZGF0YXNldF07dmFyIHggPSAwO3ZhciB5ID0gdGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzFdICsgUkcuZ2V0Q2FudmFzWFkoY2EpWzFdO1JHLlRvb2x0aXAodGhpcywgdGV4dCwgeCwgeSwgMCwgZSk7XG4gIH07dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBjb29yZHMgPSB0aGlzLmNvb3JkczJbaW5kZXhdO2lmIChjb29yZHMpIHtcbiAgICAgIHZhciBwcmVfbGluZXdpZHRoID0gY28ubGluZVdpZHRoO3ZhciBwcmVfbGluZWNhcCA9IGNvLmxpbmVDYXA7Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ10gKyAxMDtjby5saW5lQ2FwID0gJ3JvdW5kJztjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuc3Ryb2tlJ107Y28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgY28ubW92ZVRvKGNvb3Jkc1tpXVswXSwgY29vcmRzW2ldWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjby5saW5lVG8oY29vcmRzW2ldWzBdLCBjb29yZHNbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5saW5lV2lkdGggPSBwcmVfbGluZXdpZHRoO2NvLmxpbmVDYXAgPSBwcmVfbGluZWNhcDtcbiAgICB9XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTt2YXIgb3B0ID0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307dmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgPyBvcHQuZnJhbWVzIDogMzA7dmFyIGZyYW1lID0gMDt2YXIgZGF0YSA9IFJHLmFycmF5X2Nsb25lKG9iai5kYXRhKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gZGF0YVtpXS5sZW5ndGg7IGogPCBsZW4yOyArK2opIHtcbiAgICAgICAgICBvYmoub3JpZ2luYWxfZGF0YVtpXVtqXSA9IGZyYW1lIC8gZnJhbWVzICogZGF0YVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUkdyYXBoLmNsZWFyKG9iai5jYW52YXMpO1JHcmFwaC5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgIGZyYW1lKys7UkdyYXBoLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy50cmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO3ZhciBmcmFtZSA9IDA7dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O29iai5TZXQoJ2FuaW1hdGlvbi50cmFjZS5jbGlwJywgMCk7dmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgb2JqLlNldCgnYW5pbWF0aW9uLnRyYWNlLmNsaXAnLCBmcmFtZSAvIGZyYW1lcyk7ZnJhbWUrKztSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLlNldCgnYW5pbWF0aW9uLnRyYWNlLmNsaXAnLCAxKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7Y2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9O2l0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucmFkYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///199\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Effects = RGraph.Effects || {};RGraph.Effects.Rose = RGraph.Effects.Rose || {};RGraph.Rose = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.data = conf.data;this.canvas.__object__ = this;this.type = 'rose';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;this.angles = [];this.angles2 = [];this.properties = { 'chart.background.axes': true, 'chart.background.axes.color': 'black', 'chart.background.grid': true, 'chart.background.grid.color': '#ccc', 'chart.background.grid.size': null, 'chart.background.grid.radials': null, 'chart.background.grid.count': 5, 'chart.centerx': null, 'chart.centery': null, 'chart.radius': null, 'chart.angles.start': 0, 'chart.colors': ['rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)', 'rgba(0,255,255,0.5)', 'rgb(0,255,0)', 'gray', 'blue', 'rgb(255,128,255)', 'green', 'pink', 'gray', 'aqua'], 'chart.linewidth': 1, 'chart.colors.sequential': false, 'chart.colors.alpha': null, 'chart.margin': 0, 'chart.strokestyle': '#aaa', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.shadow': false, 'chart.shadow.color': '#aaa', 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.position': 'center', 'chart.labels.axes': 'nsew', 'chart.labels.boxed': false, 'chart.labels.offset': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': 'black', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onclick', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.variant': 'stacked', 'chart.variant.threed.depth': 10, 'chart.exploded': 0, 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.animation.roundrobin.factor': 1, 'chart.animation.roundrobin.radius': true, 'chart.animation.grow.multiplier': 1, 'chart.labels.count': 5, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0; i < this.data.length; ++i) {\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    } else if (_typeof(this.data[i]) === 'object') {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j] === 'string') {\n          this.data[i][j] = parseFloat(this.data[i][j]);\n        }\n      }\n    }\n  }\n  var linear_data = RGraph.arrayLinearize(this.data);for (var i = 0; i < linear_data.length; ++i) {\n    this[\"$\" + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.background.grid.spokes') name = 'chart.background.grid.radials';if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.angles = [];this.angles2 = [];this.total = 0;this.startRadians = prop['chart.angles.start'];this.coordsText = [];if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - this.gutterRight + 5;\n    }\n    if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    if (prop['chart.variant'].indexOf('3d') !== -1) {\n      var scaleX = 1.5;this.context.setTransform(scaleX, 0, 0, 1, (ca.width * scaleX - ca.width) * -0.5, 0);\n    }\n    this.drawBackground();if (prop['chart.variant'].indexOf('3d') !== -1) {\n      RG.setShadow(this, 'rgba(0,0,0,0.35)', 0, 15, 25);for (var i = prop['chart.variant.threed.depth']; i > 0; i -= 1) {\n        this.centery -= 1;this.drawRose({ storeAngles: false });RG.setShadow(this, 'rgba(0,0,0,0)', 0, 0, 0);for (var j = 0, len = this.angles.length; j < len; j += 1) {\n          var a = this.angles[j];pa2(co, ['b', 'm', a[4], a[5], 'a', a[4], a[5], a[3] + 1.5, a[0] - 0.01, a[1] + 0.01, false, 'c', 'f', 'rgba(0,0,0,0.1)']);\n        }\n      }\n    }\n    this.drawRose();this.drawLabels();co.strokeStyle = 'rgba(0,0,0,0)';\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    if (prop['chart.adjustable']) {\n      RG.AllowAdjusting(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      if (!RG.allowSegmentHighlight) {\n        alert('[WARNING] The segment highlight function does not exist - have you included the dynamic library?');\n      }\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : this.data.length, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    co.lineWidth = 1;if (prop['chart.background.grid']) {\n      if (typeof prop['chart.background.grid.count'] == 'number') {\n        prop['chart.background.grid.size'] = this.radius / prop['chart.background.grid.count'];\n      }\n      co.beginPath();co.strokeStyle = prop['chart.background.grid.color'];for (var i = prop['chart.background.grid.size']; i <= this.radius; i += prop['chart.background.grid.size']) {\n        co.moveTo(this.centerx + i, this.centery);co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, false);\n      }\n      co.stroke();co.beginPath();if (typeof prop['chart.background.grid.radials'] !== 'number') {\n        prop['chart.background.grid.radials'] = this.data.length;\n      }\n      var num = 360 / prop['chart.background.grid.radials'];for (var i = num; i <= 360; i += num) {\n        co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI + this.startRadians, (i + 0.0001) / (180 / RG.PI) - RG.HALFPI + this.startRadians, false);co.lineTo(this.centerx, this.centery);\n      }\n      co.stroke();\n    }\n    if (prop['chart.background.axes']) {\n      co.beginPath();co.strokeStyle = prop['chart.background.axes.color'];co.moveTo(this.centerx - this.radius, ma.round(this.centery));co.lineTo(this.centerx + this.radius, ma.round(this.centery));co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / 5) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3.5);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / 5) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n      co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));co.closePath();co.stroke();\n    }\n    pa2(co, 'b c');\n  };this.drawRose = this.DrawRose = function () {\n    var max = 0,\n        data = this.data,\n        margin = RG.degrees2Radians(prop['chart.margin']),\n        opt = arguments[0] || {};co.lineWidth = prop['chart.linewidth'];if (RG.isNull(prop['chart.ymax'])) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] == 'number') {\n          max = ma.max(max, data[i]);\n        } else if (_typeof(data[i]) == 'object' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n          max = ma.max(max, data[i][0]);\n        } else {\n          max = ma.max(max, RG.arraySum(data[i]));\n        }\n      }\n      this.scale2 = RG.getScale2(this, { 'max': max, 'min': 0, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    } else {\n      var ymax = prop['chart.ymax'];this.scale2 = RG.getScale2(this, { 'max': ymax, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;\n    }\n    this.sum = RG.arraySum(data);co.moveTo(this.centerx, this.centery);co.stroke();if (prop['chart.colors.alpha']) {\n      co.globalAlpha = prop['chart.colors.alpha'];\n    }\n    var sequentialIndex = 0;if (typeof prop['chart.variant'] == 'string' && prop['chart.variant'].indexOf('non-equi-angular') !== -1) {\n      var total = 0;for (var i = 0; i < data.length; ++i) {\n        total += data[i][1];\n      }\n      if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = this.data[i][1] / total * RG.TWOPI;var radius = (this.data[i][0] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n          co.fillStyle = prop['chart.colors'][i];\n        }\n        co.beginPath();var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = (this.startRadians + segmentRadians) * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[i] = [startAngle, endAngle, 0, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);this.redrawRose();\n      }\n    } else {\n      var sequentialColorIndex = 0;if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        var segmentRadians = 1 / this.data.length * RG.TWOPI;if (typeof this.data[i] == 'number') {\n          co.beginPath();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][0];if (prop['chart.colors.sequential']) {\n            co.fillStyle = prop['chart.colors'][i];\n          }\n          var radius = (this.data[i] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;radius = radius * prop['chart.animation.grow.multiplier'];var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();co.beginPath();if (endAngle == 0) {}\n          this.angles[i] = [startAngle, endAngle, 0, radius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];sequentialIndex++;\n        } else if (_typeof(this.data[i]) == 'object') {\n          var margin = prop['chart.margin'] / (180 / RG.PI);if (!this.angles2[i]) {\n            this.angles2[i] = [];\n          }\n          for (var j = 0; j < this.data[i].length; ++j) {\n            var startAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI + margin;var endAngle = this.startRadians * prop['chart.animation.roundrobin.factor'] + segmentRadians * prop['chart.animation.roundrobin.factor'] - RG.HALFPI - margin;var exploded = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);var explodedX = exploded[0];var explodedY = exploded[1];co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.colors'][j];if (prop['chart.colors.sequential']) {\n              co.fillStyle = prop['chart.colors'][sequentialColorIndex++];\n            }\n            if (j == 0) {\n              co.beginPath();var startRadius = 0;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, prop['chart.animation.roundrobin.radius'] ? endRadius * prop['chart.animation.roundrobin.factor'] : endRadius, startAngle, endAngle, 0);co.lineTo(this.centerx + explodedX, this.centery + explodedY);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, 0, endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            } else {\n              co.beginPath();var startRadius = endRadius;var endRadius = (this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin']) * this.radius + startRadius;endRadius = endRadius * prop['chart.animation.grow.multiplier'];co.arc(this.centerx + explodedX, this.centery + explodedY, startRadius * prop['chart.animation.roundrobin.factor'], startAngle, endAngle, 0);co.arc(this.centerx + explodedX, this.centery + explodedY, endRadius * prop['chart.animation.roundrobin.factor'], endAngle, startAngle, true);co.closePath();co.stroke();co.fill();this.angles[sequentialIndex++] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];this.angles2[i][j] = [startAngle, endAngle, startRadius * prop['chart.animation.roundrobin.factor'], endRadius * prop['chart.animation.roundrobin.factor'], this.centerx + explodedX, this.centery + explodedY, co.strokeStyle, co.fillStyle];\n            }\n          }\n        }\n        this.startRadians += segmentRadians;\n      }\n      if (prop['chart.shadow']) {\n        RG.noShadow(this);\n      }\n      if (prop['chart.shadow']) {\n        this.redrawRose();\n      }\n    }\n    if (prop['chart.colors.alpha']) {\n      co.globalAlpha = 1;\n    }\n    if (prop['chart.title']) {\n      RG.drawTitle(this, prop['chart.title'], ca.height / 2 - this.radius, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n  };this.redrawRose = function () {\n    var angles = this.angles;for (var i = 0; i < angles.length; ++i) {\n      pa2(co, 'b a % % % % % false a % % % % % true c f % f % ', angles[i][4], angles[i][5], angles[i][2], angles[i][0], angles[i][1], angles[i][4], angles[i][5], angles[i][3], angles[i][1], angles[i][0], angles[i][6], angles[i][7]);\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;var key = prop['chart.key'];if (key && key.length) {\n      RG.DrawKey(this, key, prop['chart.colors']);\n    }\n    co.fillStyle = prop['chart.text.color'];co.strokeStyle = 'black';var radius = this.radius,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        axes = prop['chart.labels.axes'].toLowerCase(),\n        decimals = prop['chart.scale.decimals'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0);if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, radius + 10);\n    }\n    if (typeof prop['chart.text.size.scale'] == 'number') {\n      size = prop['chart.text.size.scale'];\n    }\n    var color = 'rgba(255,255,255,0.8)';if (axes.indexOf('n') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery - radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('s') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - 10, 'y': centery + radius * ((i + 1) / prop['chart.labels.count']), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': 'right', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('e') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx + radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (axes.indexOf('w') > -1) {\n      for (var i = 0; i < prop['chart.labels.count']; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': centerx - radius * ((i + 1) / prop['chart.labels.count']), 'y': centery + 10, 'text': this.scale2.labels[i], 'valign': 'top', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n      }\n    }\n    if (RG.trim(axes).length > 0) {\n      RG.Text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': typeof prop['chart.ymin'] === 'number' ? RG.numberFormat(this, Number(prop['chart.ymin']).toFixed(prop['chart.ymin'] === 0 ? '0' : prop['chart.scale.decimals']), units_pre, units_post) : '0', 'valign': 'center', 'halign': 'center', 'bounding': true, 'bounding.fill': color, 'bounding.stroke': prop['chart.labels.boxed'] ? 'black' : 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (co, labels, font, size, radius) {\n    var variant = prop['chart.variant'],\n        position = prop['chart.labels.position'],\n        radius = radius + 5 + prop['chart.labels.offset'],\n        centerx = this.centerx,\n        centery = this.centery + (prop['chart.variant'].indexOf('3d') !== -1 ? prop['chart.variant.threed.depth'] : 0),\n        labelsColor = prop['chart.labels.color'] || prop['chart.text.color'],\n        angles = this.angles;\n    for (var i = 0; i < this.data.length; ++i) {\n      if (typeof variant == 'string' && variant.indexOf('non-equi-angular') !== -1) {\n        var a = Number(angles[i][0]) + (angles[i][1] - angles[i][0]) / 2;\n      } else {\n        var a = RG.TWOPI / this.data.length * (i + 1) - RG.TWOPI / (this.data.length * 2);var a = a - RG.HALFPI + (prop['chart.labels.position'] == 'edge' ? RG.TWOPI / this.data.length / 2 : 0);\n      }\n      var x = centerx + ma.cos(a) * radius;var y = centery + ma.sin(a) * radius;if (x > centerx) {\n        halign = 'left';\n      } else if (Math.round(x) == centerx) {\n        halign = 'center';\n      } else {\n        halign = 'right';\n      }\n      RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'x': x, 'y': y, 'text': String(labels[i]), 'halign': halign, 'valign': 'center', 'tag': 'labels' });\n    }\n  };this.getShape = this.getSegment = function (e) {\n    RG.fixEventObject(e);var angles = this.angles;var ret = [];var opt = arguments[1] ? arguments[1] : { radius: true };for (var i = 0; i < angles.length; ++i) {\n      var angleStart = angles[i][0];var angleEnd = angles[i][1];var radiusStart = opt.radius === false ? 0 : angles[i][2];var radiusEnd = opt.radius === false ? this.radius : angles[i][3];var centerX = angles[i][4];var centerY = angles[i][5];var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0] - centerX;var mouseY = mouseXY[1] - centerY;co.beginPath();co.arc(centerX, centerY, radiusStart ? radiusStart : 0.01, angleStart, angleEnd, false);co.arc(centerX, centerY, radiusEnd, angleEnd, angleStart, true);co.closePath();if (co.isPointInPath(mouseXY[0], mouseXY[1])) {\n        angles[i][6] = i;if (RG.parseTooltipText) {\n          var tooltip = RG.parseTooltipText(prop['chart.tooltips'], angles[i][6]);\n        }\n        angles[i]['object'] = this;angles[i]['x'] = angles[i][4];angles[i]['y'] = angles[i][5];angles[i]['angle.start'] = angles[i][0];angles[i]['angle.end'] = angles[i][1];angles[i]['radius.start'] = angles[i][2];angles[i]['radius.end'] = angles[i][3];angles[i]['index'] = angles[i][6];angles[i]['tooltip'] = tooltip ? tooltip : null;return angles[i];\n      }\n    }\n    return null;\n  };this.getExploded = this.getexploded = function (index, startAngle, endAngle, exploded) {\n    var explodedx, explodedy;if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) == 'object' && typeof exploded[index] == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded[index];explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded[index];\n    } else if (typeof exploded == 'number') {\n      explodedx = Math.cos((endAngle - startAngle) / 2 + startAngle) * exploded;explodedy = Math.sin((endAngle - startAngle) / 2 + startAngle) * exploded;\n    } else {\n      explodedx = 0;explodedy = 0;\n    }\n    return [explodedx, explodedy];\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      co.beginPath();co.strokeStyle = prop['chart.highlight.stroke'];co.fillStyle = prop['chart.highlight.fill'];co.arc(shape['x'], shape['y'], shape['radius.end'], shape['angle.start'], shape['angle.end'], false);if (shape['radius.start'] > 0) {\n        co.arc(shape['x'], shape['y'], shape['radius.start'], shape['angle.end'], shape['angle.start'], true);\n      } else {\n        co.lineTo(shape['x'], shape['y']);\n      }\n      co.closePath();co.stroke();co.fill();\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);if (prop['chart.variant'].indexOf('3d') !== -1) {\n      radius /= -1;\n    }\n    if (mouseXY[0] > this.centerx - this.radius && mouseXY[0] < this.centerx + this.radius && mouseXY[1] > this.centery - this.radius && mouseXY[1] < this.centery + this.radius && radius <= this.radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    if (value < 0 || value > this.max) {\n      return null;\n    }\n    var r = value / this.max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.text.color'] = RG.array_clone(prop['chart.text.color']);this.original_colors['chart.title.color'] = RG.array_clone(prop['chart.title.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);\n    }\n    for (var i = 0; i < prop['chart.colors'].length; ++i) {\n      prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\n    }\n    if (!RG.is_null(prop['chart.key.colors'])) {\n      for (var i = 0; i < prop['chart.key.colors'].length; ++i) {\n        prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\n      }\n    }\n    prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);prop['chart.title.color'] = this.parseSingleColorForGradient(prop['chart.title.color']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    var segments = this.angles2;for (var i = 0; i < this.angles2.length; i += 1) {\n      co.beginPath();co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][2], segments[i][index][0], segments[i][index][1], false);co.arc(segments[i][index][4], segments[i][index][5], segments[i][index][3], segments[i][index][1], segments[i][index][0], true);co.closePath();co.fill();co.stroke();\n    }\n    return;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.explode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames ? opt.frames : 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = Number(this.Get('exploded'));function iterator() {\n      exploded = frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.roundrobin = this.roundRobin = function () {\n    var obj = this;var opt = arguments[0] || {};\n    var frames = opt.frames || 30;var frame = 0;var original_margin = prop['chart.margin'];var margin = 360 / this.data.length / 2;var callback = arguments[1] || function () {};this.Set('chart.margin', margin);this.Set('chart.animation.roundrobin.factor', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animation.roundrobin.factor', frame / frames);obj.set('margin', frame / frames * original_margin);RG.Effects.updateCanvas(iterator);\n      } else {\n        obj.set('animation.roundrobin.factor', 1);obj.set('margin', original_margin);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.implode = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;var explodedMax = ma.max(ca.width, ca.height);var exploded = explodedMax;function iterator() {\n      exploded = explodedMax - frame / frames * explodedMax;obj.Set('exploded', exploded);RG.clear(ca);RG.redrawCanvas(ca);if (frame++ < frames) {\n        RG.Effects.updateCanvas(iterator);\n      } else {\n        RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.grow = function () {\n    var obj = this;var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var frame = 0;function iterator() {\n      obj.Set('animation.grow.multiplier', frame / frames);RG.clear(ca);RG.redrawCanvas(ca);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5yb3NlLmpzPzFkN2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguRWZmZWN0cyA9IFJHcmFwaC5FZmZlY3RzIHx8IHt9O1JHcmFwaC5FZmZlY3RzLlJvc2UgPSBSR3JhcGguRWZmZWN0cy5Sb3NlIHx8IHt9O1JHcmFwaC5Sb3NlID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYuZGF0YSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29uZiA9IHsgaWQ6IGNvbmYgfTtjb25mLmRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdGhpcy5pZCA9IGNvbmYuaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIDogbnVsbDt0aGlzLmRhdGEgPSBjb25mLmRhdGE7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ3Jvc2UnO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMuY2VudGVyeCA9IDA7dGhpcy5jZW50ZXJ5ID0gMDt0aGlzLnJhZGl1cyA9IDA7dGhpcy5tYXggPSAwO3RoaXMuYW5nbGVzID0gW107dGhpcy5hbmdsZXMyID0gW107dGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuYmFja2dyb3VuZC5heGVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuYXhlcy5jb2xvcic6ICdibGFjaycsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzogJyNjY2MnLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNpemUnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvdW50JzogNSwgJ2NoYXJ0LmNlbnRlcngnOiBudWxsLCAnY2hhcnQuY2VudGVyeSc6IG51bGwsICdjaGFydC5yYWRpdXMnOiBudWxsLCAnY2hhcnQuYW5nbGVzLnN0YXJ0JzogMCwgJ2NoYXJ0LmNvbG9ycyc6IFsncmdiYSgyNTUsMCwwLDAuNSknLCAncmdiYSgyNTUsMjU1LDAsMC41KScsICdyZ2JhKDAsMjU1LDI1NSwwLjUpJywgJ3JnYigwLDI1NSwwKScsICdncmF5JywgJ2JsdWUnLCAncmdiKDI1NSwxMjgsMjU1KScsICdncmVlbicsICdwaW5rJywgJ2dyYXknLCAnYXF1YSddLCAnY2hhcnQubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJzogZmFsc2UsICdjaGFydC5jb2xvcnMuYWxwaGEnOiBudWxsLCAnY2hhcnQubWFyZ2luJzogMCwgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJyNhYWEnLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQuc2hhZG93JzogZmFsc2UsICdjaGFydC5zaGFkb3cuY29sb3InOiAnI2FhYScsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDAsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDAsICdjaGFydC5zaGFkb3cuYmx1cic6IDE1LCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5sYWJlbHMnOiBudWxsLCAnY2hhcnQubGFiZWxzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbic6ICdjZW50ZXInLCAnY2hhcnQubGFiZWxzLmF4ZXMnOiAnbnNldycsICdjaGFydC5sYWJlbHMuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5vZmZzZXQnOiAwLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6ICd2aXNpYmxlJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzogdHJ1ZSwgJ2NoYXJ0LmtleSc6IG51bGwsICdjaGFydC5rZXkuYmFja2dyb3VuZCc6ICd3aGl0ZScsICdjaGFydC5rZXkucG9zaXRpb24nOiAnZ3JhcGgnLCAnY2hhcnQua2V5LmhhbGlnbic6ICdyaWdodCcsICdjaGFydC5rZXkuc2hhZG93JzogZmFsc2UsICdjaGFydC5rZXkuc2hhZG93LmNvbG9yJzogJyM2NjYnLCAnY2hhcnQua2V5LnNoYWRvdy5ibHVyJzogMywgJ2NoYXJ0LmtleS5zaGFkb3cub2Zmc2V0eCc6IDIsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHknOiAyLCAnY2hhcnQua2V5LnBvc2l0aW9uLmd1dHRlci5ib3hlZCc6IGZhbHNlLCAnY2hhcnQua2V5LnBvc2l0aW9uLngnOiBudWxsLCAnY2hhcnQua2V5LnBvc2l0aW9uLnknOiBudWxsLCAnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzogJ3NxdWFyZScsICdjaGFydC5rZXkucm91bmRlZCc6IHRydWUsICdjaGFydC5rZXkubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmtleS5jb2xvcnMnOiBudWxsLCAnY2hhcnQua2V5LmludGVyYWN0aXZlJzogZmFsc2UsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSc6ICdibGFjaycsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOiAncmdiYSgyNTUsMCwwLDAuMiknLCAnY2hhcnQua2V5LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0Lnpvb20uZmFjdG9yJzogMS41LCAnY2hhcnQuem9vbS5mYWRlLmluJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOiB0cnVlLCAnY2hhcnQuem9vbS5oZGlyJzogJ3JpZ2h0JywgJ2NoYXJ0Lnpvb20udmRpcic6ICdkb3duJywgJ2NoYXJ0Lnpvb20uZnJhbWVzJzogMjUsICdjaGFydC56b29tLmRlbGF5JzogMTYuNjY2LCAnY2hhcnQuem9vbS5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYWN0aW9uJzogJ3pvb20nLCAnY2hhcnQucmVzaXphYmxlJzogZmFsc2UsICdjaGFydC5yZXNpemUuaGFuZGxlLmFkanVzdCc6IFswLCAwXSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC5hZGp1c3RhYmxlJzogZmFsc2UsICdjaGFydC55bWF4JzogbnVsbCwgJ2NoYXJ0LnltaW4nOiAwLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnOiBudWxsLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5zY2FsZS50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LnZhcmlhbnQnOiAnc3RhY2tlZCcsICdjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCc6IDEwLCAnY2hhcnQuZXhwbG9kZWQnOiAwLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJzogMSwgJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLnJhZGl1cyc6IHRydWUsICdjaGFydC5hbmltYXRpb24uZ3Jvdy5tdWx0aXBsaWVyJzogMSwgJ2NoYXJ0LmxhYmVscy5jb3VudCc6IDUsICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodCc6IGZhbHNlLCAnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuY291bnQnOiBudWxsLCAnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDAsMjU1LDAsMC41KScsICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5jbGVhcnRvJzogJ3JnYmEoMCwwLDAsMCknIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBwYXJzZUZsb2F0KHRoaXMuZGF0YVtpXSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbaV1bal0gPSBwYXJzZUZsb2F0KHRoaXMuZGF0YVtpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGxpbmVhcl9kYXRhID0gUkdyYXBoLmFycmF5TGluZWFyaXplKHRoaXMuZGF0YSk7Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lYXJfZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHRoaXNbXCIkXCIgKyBpXSA9IHt9O1xuICB9XG4gIGlmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNwb2tlcycpIG5hbWUgPSAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnO2lmIChuYW1lID09PSAnY2hhcnQuc2VnbWVudHMuaGlnaGxpZ2h0JykgbmFtZSA9ICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodCc7aWYgKG5hbWUgPT09ICdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuZmlsbCcpIG5hbWUgPSAnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc7aWYgKG5hbWUgPT09ICdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuc3Ryb2tlJykgbmFtZSA9ICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnO3Byb3BbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTt0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnJhZGl1cyA9IG1hLm1pbihjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMjt0aGlzLmNlbnRlcnggPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDIgKyB0aGlzLmd1dHRlckxlZnQ7dGhpcy5jZW50ZXJ5ID0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiArIHRoaXMuZ3V0dGVyVG9wO3RoaXMuYW5nbGVzID0gW107dGhpcy5hbmdsZXMyID0gW107dGhpcy50b3RhbCA9IDA7dGhpcy5zdGFydFJhZGlhbnMgPSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTtpZiAocHJvcFsnY2hhcnQua2V5J10gJiYgcHJvcFsnY2hhcnQua2V5J10ubGVuZ3RoID4gMCAmJiBwcm9wWydjaGFydC5rZXknXS5sZW5ndGggPj0gMykge1xuICAgICAgdGhpcy5jZW50ZXJ4ID0gdGhpcy5jZW50ZXJ4IC0gdGhpcy5ndXR0ZXJSaWdodCArIDU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeCddID09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT0gJ251bWJlcicpIHRoaXMuY2VudGVyeSA9IHByb3BbJ2NoYXJ0LmNlbnRlcnknXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnJhZGl1cyddID09ICdudW1iZXInKSB0aGlzLnJhZGl1cyA9IHByb3BbJ2NoYXJ0LnJhZGl1cyddO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignM2QnKSAhPT0gLTEpIHtcbiAgICAgIHZhciBzY2FsZVggPSAxLjU7dGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybShzY2FsZVgsIDAsIDAsIDEsIChjYS53aWR0aCAqIHNjYWxlWCAtIGNhLndpZHRoKSAqIC0wLjUsIDApO1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7aWYgKHByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCczZCcpICE9PSAtMSkge1xuICAgICAgUkcuc2V0U2hhZG93KHRoaXMsICdyZ2JhKDAsMCwwLDAuMzUpJywgMCwgMTUsIDI1KTtmb3IgKHZhciBpID0gcHJvcFsnY2hhcnQudmFyaWFudC50aHJlZWQuZGVwdGgnXTsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICB0aGlzLmNlbnRlcnkgLT0gMTt0aGlzLmRyYXdSb3NlKHsgc3RvcmVBbmdsZXM6IGZhbHNlIH0pO1JHLnNldFNoYWRvdyh0aGlzLCAncmdiYSgwLDAsMCwwKScsIDAsIDAsIDApO2ZvciAodmFyIGogPSAwLCBsZW4gPSB0aGlzLmFuZ2xlcy5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5hbmdsZXNbal07cGEyKGNvLCBbJ2InLCAnbScsIGFbNF0sIGFbNV0sICdhJywgYVs0XSwgYVs1XSwgYVszXSArIDEuNSwgYVswXSAtIDAuMDEsIGFbMV0gKyAwLjAxLCBmYWxzZSwgJ2MnLCAnZicsICdyZ2JhKDAsMCwwLDAuMSknXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kcmF3Um9zZSgpO3RoaXMuZHJhd0xhYmVscygpO2NvLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd0FkanVzdGluZyh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmIChwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodCddKSB7XG4gICAgICBpZiAoIVJHLmFsbG93U2VnbWVudEhpZ2hsaWdodCkge1xuICAgICAgICBhbGVydCgnW1dBUk5JTkddIFRoZSBzZWdtZW50IGhpZ2hsaWdodCBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGluY2x1ZGVkIHRoZSBkeW5hbWljIGxpYnJhcnk/Jyk7XG4gICAgICB9XG4gICAgICBSRy5hbGxvd1NlZ21lbnRIaWdobGlnaHQoeyBvYmplY3Q6IHRoaXMsIGNvdW50OiB0eXBlb2YgcHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuY291bnQnXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCddIDogdGhpcy5kYXRhLmxlbmd0aCwgZmlsbDogcHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCddLCBzdHJva2U6IHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSddIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0JhY2tncm91bmQgPSB0aGlzLkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLmxpbmVXaWR0aCA9IDE7aWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZCddKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb3VudCddID09ICdudW1iZXInKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5zaXplJ10gPSB0aGlzLnJhZGl1cyAvIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb3VudCddO1xuICAgICAgfVxuICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXTtmb3IgKHZhciBpID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnNpemUnXTsgaSA8PSB0aGlzLnJhZGl1czsgaSArPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuc2l6ZSddKSB7XG4gICAgICAgIGNvLm1vdmVUbyh0aGlzLmNlbnRlcnggKyBpLCB0aGlzLmNlbnRlcnkpO2NvLmFyYyh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgaSwgMCwgUkcuVFdPUEksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnXSA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgbnVtID0gMzYwIC8gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnXTtmb3IgKHZhciBpID0gbnVtOyBpIDw9IDM2MDsgaSArPSBudW0pIHtcbiAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgaSAvICgxODAgLyBSRy5QSSkgLSBSRy5IQUxGUEkgKyB0aGlzLnN0YXJ0UmFkaWFucywgKGkgKyAwLjAwMDEpIC8gKDE4MCAvIFJHLlBJKSAtIFJHLkhBTEZQSSArIHRoaXMuc3RhcnRSYWRpYW5zLCBmYWxzZSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5heGVzJ10pIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5heGVzLmNvbG9yJ107Y28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzLCBtYS5yb3VuZCh0aGlzLmNlbnRlcnkpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMsIG1hLnJvdW5kKHRoaXMuY2VudGVyeSkpO2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSAtIDUpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSArIDUpO2NvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSAtIDUpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyksIHRoaXMuY2VudGVyeSArIDUpO2ZvciAodmFyIGkgPSB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1czsgaSA8IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzOyBpICs9IHRoaXMucmFkaXVzIC8gNSkge1xuICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoaSksIHRoaXMuY2VudGVyeSAtIDMpO2NvLmxpbmVUbyhtYS5yb3VuZChpKSwgdGhpcy5jZW50ZXJ5ICsgMy41KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1czsgaSA8IHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzOyBpICs9IHRoaXMucmFkaXVzIC8gNSkge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5jZW50ZXJ4IC0gMywgbWEucm91bmQoaSkpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyAzLCBtYS5yb3VuZChpKSk7XG4gICAgICB9XG4gICAgICBjby5tb3ZlVG8obWEucm91bmQodGhpcy5jZW50ZXJ4KSwgdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXMpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngpLCB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIDUsIG1hLnJvdW5kKHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCArIDUsIG1hLnJvdW5kKHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzKSk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCAtIDUsIG1hLnJvdW5kKHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzKSk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCArIDUsIG1hLnJvdW5kKHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzKSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIHBhMihjbywgJ2IgYycpO1xuICB9O3RoaXMuZHJhd1Jvc2UgPSB0aGlzLkRyYXdSb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXggPSAwLFxuICAgICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBtYXJnaW4gPSBSRy5kZWdyZWVzMlJhZGlhbnMocHJvcFsnY2hhcnQubWFyZ2luJ10pLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ107aWYgKFJHLmlzTnVsbChwcm9wWydjaGFydC55bWF4J10pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldID09ICdudW1iZXInKSB7XG4gICAgICAgICAgbWF4ID0gbWEubWF4KG1heCwgZGF0YVtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkYXRhW2ldKSA9PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignbm9uLWVxdWktYW5ndWxhcicpICE9PSAtMSkge1xuICAgICAgICAgIG1heCA9IG1hLm1heChtYXgsIGRhdGFbaV1bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heCA9IG1hLm1heChtYXgsIFJHLmFycmF5U3VtKGRhdGFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyAnbWF4JzogbWF4LCAnbWluJzogMCwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLmRlY2ltYWxzJzogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSB9KTt0aGlzLm1heCA9IHRoaXMuc2NhbGUyLm1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHltYXggPSBwcm9wWydjaGFydC55bWF4J107dGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyAnbWF4JzogeW1heCwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7XG4gICAgfVxuICAgIHRoaXMuc3VtID0gUkcuYXJyYXlTdW0oZGF0YSk7Y28ubW92ZVRvKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5KTtjby5zdHJva2UoKTtpZiAocHJvcFsnY2hhcnQuY29sb3JzLmFscGhhJ10pIHtcbiAgICAgIGNvLmdsb2JhbEFscGhhID0gcHJvcFsnY2hhcnQuY29sb3JzLmFscGhhJ107XG4gICAgfVxuICAgIHZhciBzZXF1ZW50aWFsSW5kZXggPSAwO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQudmFyaWFudCddID09ICdzdHJpbmcnICYmIHByb3BbJ2NoYXJ0LnZhcmlhbnQnXS5pbmRleE9mKCdub24tZXF1aS1hbmd1bGFyJykgIT09IC0xKSB7XG4gICAgICB2YXIgdG90YWwgPSAwO2ZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0b3RhbCArPSBkYXRhW2ldWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICAgIFJHLnNldFNoYWRvdyh0aGlzLCBwcm9wWydjaGFydC5zaGFkb3cuY29sb3InXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHgnXSwgcHJvcFsnY2hhcnQuc2hhZG93Lm9mZnNldHknXSwgcHJvcFsnY2hhcnQuc2hhZG93LmJsdXInXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudFJhZGlhbnMgPSB0aGlzLmRhdGFbaV1bMV0gLyB0b3RhbCAqIFJHLlRXT1BJO3ZhciByYWRpdXMgPSAodGhpcy5kYXRhW2ldWzBdIC0gcHJvcFsnY2hhcnQueW1pbiddKSAvICh0aGlzLm1heCAtIHByb3BbJ2NoYXJ0LnltaW4nXSkgKiB0aGlzLnJhZGl1cztyYWRpdXMgPSByYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24uZ3Jvdy5tdWx0aXBsaWVyJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzBdO2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11baV07XG4gICAgICAgIH1cbiAgICAgICAgY28uYmVnaW5QYXRoKCk7dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0UmFkaWFucyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIC0gUkcuSEFMRlBJICsgbWFyZ2luO3ZhciBlbmRBbmdsZSA9ICh0aGlzLnN0YXJ0UmFkaWFucyArIHNlZ21lbnRSYWRpYW5zKSAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIC0gUkcuSEFMRlBJIC0gbWFyZ2luO3ZhciBleHBsb2RlZCA9IHRoaXMuZ2V0ZXhwbG9kZWQoaSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pO3ZhciBleHBsb2RlZFggPSBleHBsb2RlZFswXTt2YXIgZXhwbG9kZWRZID0gZXhwbG9kZWRbMV07Y28uYXJjKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5yYWRpdXMnXSA/IHJhZGl1cyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIDogcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgMCk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7dGhpcy5hbmdsZXNbaV0gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGUsIDAsIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLnJhZGl1cyddID8gcmFkaXVzICogcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10gOiByYWRpdXMsIHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBjby5zdHJva2VTdHlsZSwgY28uZmlsbFN0eWxlXTtzZXF1ZW50aWFsSW5kZXgrKzt0aGlzLnN0YXJ0UmFkaWFucyArPSBzZWdtZW50UmFkaWFucztcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICBSRy5ub1NoYWRvdyh0aGlzKTt0aGlzLnJlZHJhd1Jvc2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlcXVlbnRpYWxDb2xvckluZGV4ID0gMDtpZiAocHJvcFsnY2hhcnQuc2hhZG93J10pIHtcbiAgICAgICAgUkcuc2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50UmFkaWFucyA9IDEgLyB0aGlzLmRhdGEubGVuZ3RoICogUkcuVFdPUEk7aWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07aWYgKHByb3BbJ2NoYXJ0LmNvbG9ycy5zZXF1ZW50aWFsJ10pIHtcbiAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmFkaXVzID0gKHRoaXMuZGF0YVtpXSAtIHByb3BbJ2NoYXJ0LnltaW4nXSkgLyAodGhpcy5tYXggLSBwcm9wWydjaGFydC55bWluJ10pICogdGhpcy5yYWRpdXM7cmFkaXVzID0gcmFkaXVzICogcHJvcFsnY2hhcnQuYW5pbWF0aW9uLmdyb3cubXVsdGlwbGllciddO3ZhciBzdGFydEFuZ2xlID0gdGhpcy5zdGFydFJhZGlhbnMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSAtIFJHLkhBTEZQSSArIG1hcmdpbjt2YXIgZW5kQW5nbGUgPSB0aGlzLnN0YXJ0UmFkaWFucyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddICsgc2VnbWVudFJhZGlhbnMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSAtIFJHLkhBTEZQSSAtIG1hcmdpbjt2YXIgZXhwbG9kZWQgPSB0aGlzLmdldGV4cGxvZGVkKGksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBwcm9wWydjaGFydC5leHBsb2RlZCddKTt2YXIgZXhwbG9kZWRYID0gZXhwbG9kZWRbMF07dmFyIGV4cGxvZGVkWSA9IGV4cGxvZGVkWzFdO2NvLmFyYyh0aGlzLmNlbnRlcnggKyBleHBsb2RlZFgsIHRoaXMuY2VudGVyeSArIGV4cGxvZGVkWSwgcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4ucmFkaXVzJ10gPyByYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSA6IHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIDApO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyBleHBsb2RlZFgsIHRoaXMuY2VudGVyeSArIGV4cGxvZGVkWSk7Y28uY2xvc2VQYXRoKCk7Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO2NvLmJlZ2luUGF0aCgpO2lmIChlbmRBbmdsZSA9PSAwKSB7fVxuICAgICAgICAgIHRoaXMuYW5nbGVzW2ldID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAwLCByYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSwgdGhpcy5jZW50ZXJ4ICsgZXhwbG9kZWRYLCB0aGlzLmNlbnRlcnkgKyBleHBsb2RlZFksIGNvLnN0cm9rZVN0eWxlLCBjby5maWxsU3R5bGVdO3NlcXVlbnRpYWxJbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSBwcm9wWydjaGFydC5tYXJnaW4nXSAvICgxODAgLyBSRy5QSSk7aWYgKCF0aGlzLmFuZ2xlczJbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuYW5nbGVzMltpXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0UmFkaWFucyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIC0gUkcuSEFMRlBJICsgbWFyZ2luO3ZhciBlbmRBbmdsZSA9IHRoaXMuc3RhcnRSYWRpYW5zICogcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10gKyBzZWdtZW50UmFkaWFucyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIC0gUkcuSEFMRlBJIC0gbWFyZ2luO3ZhciBleHBsb2RlZCA9IHRoaXMuZ2V0ZXhwbG9kZWQoaSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHByb3BbJ2NoYXJ0LmV4cGxvZGVkJ10pO3ZhciBleHBsb2RlZFggPSBleHBsb2RlZFswXTt2YXIgZXhwbG9kZWRZID0gZXhwbG9kZWRbMV07Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2pdO2lmIChwcm9wWydjaGFydC5jb2xvcnMuc2VxdWVudGlhbCddKSB7XG4gICAgICAgICAgICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW3NlcXVlbnRpYWxDb2xvckluZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT0gMCkge1xuICAgICAgICAgICAgICBjby5iZWdpblBhdGgoKTt2YXIgc3RhcnRSYWRpdXMgPSAwO3ZhciBlbmRSYWRpdXMgPSAodGhpcy5kYXRhW2ldW2pdIC0gcHJvcFsnY2hhcnQueW1pbiddKSAvICh0aGlzLm1heCAtIHByb3BbJ2NoYXJ0LnltaW4nXSkgKiB0aGlzLnJhZGl1cztlbmRSYWRpdXMgPSBlbmRSYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24uZ3Jvdy5tdWx0aXBsaWVyJ107Y28uYXJjKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5yYWRpdXMnXSA/IGVuZFJhZGl1cyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddIDogZW5kUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgMCk7Y28ubGluZVRvKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7dGhpcy5hbmdsZXNbc2VxdWVudGlhbEluZGV4KytdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAwLCBlbmRSYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSwgdGhpcy5jZW50ZXJ4ICsgZXhwbG9kZWRYLCB0aGlzLmNlbnRlcnkgKyBleHBsb2RlZFksIGNvLnN0cm9rZVN0eWxlLCBjby5maWxsU3R5bGVdO3RoaXMuYW5nbGVzMltpXVtqXSA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgMCwgZW5kUmFkaXVzICogcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sIHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBjby5zdHJva2VTdHlsZSwgY28uZmlsbFN0eWxlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvLmJlZ2luUGF0aCgpO3ZhciBzdGFydFJhZGl1cyA9IGVuZFJhZGl1czt2YXIgZW5kUmFkaXVzID0gKHRoaXMuZGF0YVtpXVtqXSAtIHByb3BbJ2NoYXJ0LnltaW4nXSkgLyAodGhpcy5tYXggLSBwcm9wWydjaGFydC55bWluJ10pICogdGhpcy5yYWRpdXMgKyBzdGFydFJhZGl1cztlbmRSYWRpdXMgPSBlbmRSYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24uZ3Jvdy5tdWx0aXBsaWVyJ107Y28uYXJjKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBzdGFydFJhZGl1cyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgMCk7Y28uYXJjKHRoaXMuY2VudGVyeCArIGV4cGxvZGVkWCwgdGhpcy5jZW50ZXJ5ICsgZXhwbG9kZWRZLCBlbmRSYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt0aGlzLmFuZ2xlc1tzZXF1ZW50aWFsSW5kZXgrK10gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHN0YXJ0UmFkaXVzICogcHJvcFsnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJ10sIGVuZFJhZGl1cyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLCB0aGlzLmNlbnRlcnggKyBleHBsb2RlZFgsIHRoaXMuY2VudGVyeSArIGV4cGxvZGVkWSwgY28uc3Ryb2tlU3R5bGUsIGNvLmZpbGxTdHlsZV07dGhpcy5hbmdsZXMyW2ldW2pdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBzdGFydFJhZGl1cyAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi5yb3VuZHJvYmluLmZhY3RvciddLCBlbmRSYWRpdXMgKiBwcm9wWydjaGFydC5hbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InXSwgdGhpcy5jZW50ZXJ4ICsgZXhwbG9kZWRYLCB0aGlzLmNlbnRlcnkgKyBleHBsb2RlZFksIGNvLnN0cm9rZVN0eWxlLCBjby5maWxsU3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0UmFkaWFucyArPSBzZWdtZW50UmFkaWFucztcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICBSRy5ub1NoYWRvdyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICB0aGlzLnJlZHJhd1Jvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmNvbG9ycy5hbHBoYSddKSB7XG4gICAgICBjby5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC50aXRsZSddKSB7XG4gICAgICBSRy5kcmF3VGl0bGUodGhpcywgcHJvcFsnY2hhcnQudGl0bGUnXSwgY2EuaGVpZ2h0IC8gMiAtIHRoaXMucmFkaXVzLCB0aGlzLmNlbnRlcngsIHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA/IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICsgMik7XG4gICAgfVxuICB9O3RoaXMucmVkcmF3Um9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW5nbGVzID0gdGhpcy5hbmdsZXM7Zm9yICh2YXIgaSA9IDA7IGkgPCBhbmdsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBhMihjbywgJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZSBjIGYgJSBmICUgJywgYW5nbGVzW2ldWzRdLCBhbmdsZXNbaV1bNV0sIGFuZ2xlc1tpXVsyXSwgYW5nbGVzW2ldWzBdLCBhbmdsZXNbaV1bMV0sIGFuZ2xlc1tpXVs0XSwgYW5nbGVzW2ldWzVdLCBhbmdsZXNbaV1bM10sIGFuZ2xlc1tpXVsxXSwgYW5nbGVzW2ldWzBdLCBhbmdsZXNbaV1bNl0sIGFuZ2xlc1tpXVs3XSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjby5saW5lV2lkdGggPSAxO3ZhciBrZXkgPSBwcm9wWydjaGFydC5rZXknXTtpZiAoa2V5ICYmIGtleS5sZW5ndGgpIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywga2V5LCBwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtjby5zdHJva2VTdHlsZSA9ICdibGFjayc7dmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgYXhlcyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzJ10udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZGVjaW1hbHMgPSBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLFxuICAgICAgICB1bml0c19wcmUgPSBwcm9wWydjaGFydC51bml0cy5wcmUnXSxcbiAgICAgICAgdW5pdHNfcG9zdCA9IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSxcbiAgICAgICAgY2VudGVyeCA9IHRoaXMuY2VudGVyeCxcbiAgICAgICAgY2VudGVyeSA9IHRoaXMuY2VudGVyeSArIChwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignM2QnKSAhPT0gLTEgPyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCddIDogMCk7aWYgKF90eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddKSB7XG4gICAgICB0aGlzLkRyYXdDaXJjdWxhckxhYmVscyhjbywgcHJvcFsnY2hhcnQubGFiZWxzJ10sIGZvbnQsIHNpemUsIHJhZGl1cyArIDEwKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC50ZXh0LnNpemUuc2NhbGUnXSA9PSAnbnVtYmVyJykge1xuICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZS5zY2FsZSddO1xuICAgIH1cbiAgICB2YXIgY29sb3IgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjgpJztpZiAoYXhlcy5pbmRleE9mKCduJykgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXTsgKytpKSB7XG4gICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIDEwLCAneSc6IGNlbnRlcnkgLSByYWRpdXMgKiAoKGkgKyAxKSAvIHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddKSwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdyaWdodCcsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZy5maWxsJzogY29sb3IsICdib3VuZGluZy5zdHJva2UnOiBwcm9wWydjaGFydC5sYWJlbHMuYm94ZWQnXSA/ICdibGFjaycgOiAncmdiYSgwLDAsMCwwKScsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXhlcy5pbmRleE9mKCdzJykgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXTsgKytpKSB7XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIDEwLCAneSc6IGNlbnRlcnkgKyByYWRpdXMgKiAoKGkgKyAxKSAvIHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddKSwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdyaWdodCcsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZy5maWxsJzogY29sb3IsICdib3VuZGluZy5zdHJva2UnOiBwcm9wWydjaGFydC5sYWJlbHMuYm94ZWQnXSA/ICdibGFjaycgOiAncmdiYSgwLDAsMCwwKScsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXhlcy5pbmRleE9mKCdlJykgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXTsgKytpKSB7XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCArIHJhZGl1cyAqICgoaSArIDEpIC8gcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10pLCAneSc6IGNlbnRlcnkgKyAxMCwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAndG9wJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmcuZmlsbCc6IGNvbG9yLCAnYm91bmRpbmcuc3Ryb2tlJzogcHJvcFsnY2hhcnQubGFiZWxzLmJveGVkJ10gPyAnYmxhY2snIDogJ3JnYmEoMCwwLDAsMCknLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF4ZXMuaW5kZXhPZigndycpID4gLTEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107ICsraSkge1xuICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggLSByYWRpdXMgKiAoKGkgKyAxKSAvIHByb3BbJ2NoYXJ0LmxhYmVscy5jb3VudCddKSwgJ3knOiBjZW50ZXJ5ICsgMTAsICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogJ3RvcCcsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nLmZpbGwnOiBjb2xvciwgJ2JvdW5kaW5nLnN0cm9rZSc6IHByb3BbJ2NoYXJ0LmxhYmVscy5ib3hlZCddID8gJ2JsYWNrJyA6ICdyZ2JhKDAsMCwwLDApJywgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChSRy50cmltKGF4ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCwgJ3knOiBjZW50ZXJ5LCAndGV4dCc6IHR5cGVvZiBwcm9wWydjaGFydC55bWluJ10gPT09ICdudW1iZXInID8gUkcubnVtYmVyRm9ybWF0KHRoaXMsIE51bWJlcihwcm9wWydjaGFydC55bWluJ10pLnRvRml4ZWQocHJvcFsnY2hhcnQueW1pbiddID09PSAwID8gJzAnIDogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCkgOiAnMCcsICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmcuZmlsbCc6IGNvbG9yLCAnYm91bmRpbmcuc3Ryb2tlJzogcHJvcFsnY2hhcnQubGFiZWxzLmJveGVkJ10gPyAnYmxhY2snIDogJ3JnYmEoMCwwLDAsMCknLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICB9XG4gIH07dGhpcy5kcmF3Q2lyY3VsYXJMYWJlbHMgPSB0aGlzLkRyYXdDaXJjdWxhckxhYmVscyA9IGZ1bmN0aW9uIChjbywgbGFiZWxzLCBmb250LCBzaXplLCByYWRpdXMpIHtcbiAgICB2YXIgdmFyaWFudCA9IHByb3BbJ2NoYXJ0LnZhcmlhbnQnXSxcbiAgICAgICAgcG9zaXRpb24gPSBwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSxcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzICsgNSArIHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXQnXSxcbiAgICAgICAgY2VudGVyeCA9IHRoaXMuY2VudGVyeCxcbiAgICAgICAgY2VudGVyeSA9IHRoaXMuY2VudGVyeSArIChwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignM2QnKSAhPT0gLTEgPyBwcm9wWydjaGFydC52YXJpYW50LnRocmVlZC5kZXB0aCddIDogMCksXG4gICAgICAgIGxhYmVsc0NvbG9yID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddLFxuICAgICAgICBhbmdsZXMgPSB0aGlzLmFuZ2xlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiB2YXJpYW50ID09ICdzdHJpbmcnICYmIHZhcmlhbnQuaW5kZXhPZignbm9uLWVxdWktYW5ndWxhcicpICE9PSAtMSkge1xuICAgICAgICB2YXIgYSA9IE51bWJlcihhbmdsZXNbaV1bMF0pICsgKGFuZ2xlc1tpXVsxXSAtIGFuZ2xlc1tpXVswXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGEgPSBSRy5UV09QSSAvIHRoaXMuZGF0YS5sZW5ndGggKiAoaSArIDEpIC0gUkcuVFdPUEkgLyAodGhpcy5kYXRhLmxlbmd0aCAqIDIpO3ZhciBhID0gYSAtIFJHLkhBTEZQSSArIChwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSA9PSAnZWRnZScgPyBSRy5UV09QSSAvIHRoaXMuZGF0YS5sZW5ndGggLyAyIDogMCk7XG4gICAgICB9XG4gICAgICB2YXIgeCA9IGNlbnRlcnggKyBtYS5jb3MoYSkgKiByYWRpdXM7dmFyIHkgPSBjZW50ZXJ5ICsgbWEuc2luKGEpICogcmFkaXVzO2lmICh4ID4gY2VudGVyeCkge1xuICAgICAgICBoYWxpZ24gPSAnbGVmdCc7XG4gICAgICB9IGVsc2UgaWYgKE1hdGgucm91bmQoeCkgPT0gY2VudGVyeCkge1xuICAgICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbGlnbiA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBSRy50ZXh0Mih0aGlzLCB7ICdjb2xvcic6IGxhYmVsc0NvbG9yLCAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4LCAneSc6IHksICd0ZXh0JzogU3RyaW5nKGxhYmVsc1tpXSksICdoYWxpZ24nOiBoYWxpZ24sICd2YWxpZ24nOiAnY2VudGVyJywgJ3RhZyc6ICdsYWJlbHMnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmdldFNoYXBlID0gdGhpcy5nZXRTZWdtZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBSRy5maXhFdmVudE9iamVjdChlKTt2YXIgYW5nbGVzID0gdGhpcy5hbmdsZXM7dmFyIHJldCA9IFtdO3ZhciBvcHQgPSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7IHJhZGl1czogdHJ1ZSB9O2ZvciAodmFyIGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYW5nbGVTdGFydCA9IGFuZ2xlc1tpXVswXTt2YXIgYW5nbGVFbmQgPSBhbmdsZXNbaV1bMV07dmFyIHJhZGl1c1N0YXJ0ID0gb3B0LnJhZGl1cyA9PT0gZmFsc2UgPyAwIDogYW5nbGVzW2ldWzJdO3ZhciByYWRpdXNFbmQgPSBvcHQucmFkaXVzID09PSBmYWxzZSA/IHRoaXMucmFkaXVzIDogYW5nbGVzW2ldWzNdO3ZhciBjZW50ZXJYID0gYW5nbGVzW2ldWzRdO3ZhciBjZW50ZXJZID0gYW5nbGVzW2ldWzVdO3ZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYID0gbW91c2VYWVswXSAtIGNlbnRlclg7dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV0gLSBjZW50ZXJZO2NvLmJlZ2luUGF0aCgpO2NvLmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXNTdGFydCA/IHJhZGl1c1N0YXJ0IDogMC4wMSwgYW5nbGVTdGFydCwgYW5nbGVFbmQsIGZhbHNlKTtjby5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzRW5kLCBhbmdsZUVuZCwgYW5nbGVTdGFydCwgdHJ1ZSk7Y28uY2xvc2VQYXRoKCk7aWYgKGNvLmlzUG9pbnRJblBhdGgobW91c2VYWVswXSwgbW91c2VYWVsxXSkpIHtcbiAgICAgICAgYW5nbGVzW2ldWzZdID0gaTtpZiAoUkcucGFyc2VUb29sdGlwVGV4dCkge1xuICAgICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCBhbmdsZXNbaV1bNl0pO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlc1tpXVsnb2JqZWN0J10gPSB0aGlzO2FuZ2xlc1tpXVsneCddID0gYW5nbGVzW2ldWzRdO2FuZ2xlc1tpXVsneSddID0gYW5nbGVzW2ldWzVdO2FuZ2xlc1tpXVsnYW5nbGUuc3RhcnQnXSA9IGFuZ2xlc1tpXVswXTthbmdsZXNbaV1bJ2FuZ2xlLmVuZCddID0gYW5nbGVzW2ldWzFdO2FuZ2xlc1tpXVsncmFkaXVzLnN0YXJ0J10gPSBhbmdsZXNbaV1bMl07YW5nbGVzW2ldWydyYWRpdXMuZW5kJ10gPSBhbmdsZXNbaV1bM107YW5nbGVzW2ldWydpbmRleCddID0gYW5nbGVzW2ldWzZdO2FuZ2xlc1tpXVsndG9vbHRpcCddID0gdG9vbHRpcCA/IHRvb2x0aXAgOiBudWxsO3JldHVybiBhbmdsZXNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuZ2V0RXhwbG9kZWQgPSB0aGlzLmdldGV4cGxvZGVkID0gZnVuY3Rpb24gKGluZGV4LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZXhwbG9kZWQpIHtcbiAgICB2YXIgZXhwbG9kZWR4LCBleHBsb2RlZHk7aWYgKCh0eXBlb2YgZXhwbG9kZWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4cGxvZGVkKSkgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGxvZGVkW2luZGV4XSA9PSAnbnVtYmVyJykge1xuICAgICAgZXhwbG9kZWR4ID0gTWF0aC5jb3MoKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAyICsgc3RhcnRBbmdsZSkgKiBleHBsb2RlZFtpbmRleF07ZXhwbG9kZWR5ID0gTWF0aC5zaW4oKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAyICsgc3RhcnRBbmdsZSkgKiBleHBsb2RlZFtpbmRleF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwbG9kZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGV4cGxvZGVkeCA9IE1hdGguY29zKChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gMiArIHN0YXJ0QW5nbGUpICogZXhwbG9kZWQ7ZXhwbG9kZWR5ID0gTWF0aC5zaW4oKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAyICsgc3RhcnRBbmdsZSkgKiBleHBsb2RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwbG9kZWR4ID0gMDtleHBsb2RlZHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gW2V4cGxvZGVkeCwgZXhwbG9kZWR5XTtcbiAgfTt0aGlzLmFsbG93VG9vbHRpcHMgPSB0aGlzLkFsbG93VG9vbHRpcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuUHJlTG9hZFRvb2x0aXBJbWFnZXModGhpcyk7UkcuSW5zdGFsbFdpbmRvd01vdXNlZG93blRvb2x0aXBMaXN0ZW5lcih0aGlzKTtSRy5JbnN0YWxsQ2FudmFzTW91c2Vtb3ZlVG9vbHRpcExpc3RlbmVyKHRoaXMpO1JHLkluc3RhbGxDYW52YXNNb3VzZXVwVG9vbHRpcExpc3RlbmVyKHRoaXMpO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO3JldHVybjtcbiAgICAgIH1cbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ107Y28uYXJjKHNoYXBlWyd4J10sIHNoYXBlWyd5J10sIHNoYXBlWydyYWRpdXMuZW5kJ10sIHNoYXBlWydhbmdsZS5zdGFydCddLCBzaGFwZVsnYW5nbGUuZW5kJ10sIGZhbHNlKTtpZiAoc2hhcGVbJ3JhZGl1cy5zdGFydCddID4gMCkge1xuICAgICAgICBjby5hcmMoc2hhcGVbJ3gnXSwgc2hhcGVbJ3knXSwgc2hhcGVbJ3JhZGl1cy5zdGFydCddLCBzaGFwZVsnYW5nbGUuZW5kJ10sIHNoYXBlWydhbmdsZS5zdGFydCddLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvLmxpbmVUbyhzaGFwZVsneCddLCBzaGFwZVsneSddKTtcbiAgICAgIH1cbiAgICAgIGNvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHcmFwaC5nZXRNb3VzZVhZKGUpO3ZhciByYWRpdXMgPSBSRy5nZXRIeXBMZW5ndGgodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG1vdXNlWFlbMF0sIG1vdXNlWFlbMV0pO2lmIChwcm9wWydjaGFydC52YXJpYW50J10uaW5kZXhPZignM2QnKSAhPT0gLTEpIHtcbiAgICAgIHJhZGl1cyAvPSAtMTtcbiAgICB9XG4gICAgaWYgKG1vdXNlWFlbMF0gPiB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyAmJiBtb3VzZVhZWzBdIDwgdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgJiYgbW91c2VYWVsxXSA+IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzICYmIG1vdXNlWFlbMV0gPCB0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cyAmJiByYWRpdXMgPD0gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFJhZGl1cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByID0gdmFsdWUgLyB0aGlzLm1heCAqIHRoaXMucmFkaXVzO3JldHVybiByO1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5rZXkuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50ZXh0LmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50aXRsZS5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQudGl0bGUuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wWydjaGFydC5jb2xvcnMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgcHJvcFsnY2hhcnQuY29sb3JzJ11baV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVtpXSk7XG4gICAgfVxuICAgIGlmICghUkcuaXNfbnVsbChwcm9wWydjaGFydC5rZXkuY29sb3JzJ10pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXS5sZW5ndGg7ICsraSkge1xuICAgICAgICBwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5rZXkuY29sb3JzJ11baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50ZXh0LmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnRpdGxlLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC50aXRsZS5jb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSddKTtwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10pO1xuICB9O3RoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIDAsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmFuZ2xlczI7Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuZ2xlczIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmxpbmVXaWR0aCA9IDI7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LnN0cm9rZSddO2NvLmFyYyhzZWdtZW50c1tpXVtpbmRleF1bNF0sIHNlZ21lbnRzW2ldW2luZGV4XVs1XSwgc2VnbWVudHNbaV1baW5kZXhdWzJdLCBzZWdtZW50c1tpXVtpbmRleF1bMF0sIHNlZ21lbnRzW2ldW2luZGV4XVsxXSwgZmFsc2UpO2NvLmFyYyhzZWdtZW50c1tpXVtpbmRleF1bNF0sIHNlZ21lbnRzW2ldW2luZGV4XVs1XSwgc2VnbWVudHNbaV1baW5kZXhdWzNdLCBzZWdtZW50c1tpXVtpbmRleF1bMV0sIHNlZ21lbnRzW2ldW2luZGV4XVswXSwgdHJ1ZSk7Y28uY2xvc2VQYXRoKCk7Y28uZmlsbCgpO2NvLnN0cm9rZSgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMuZXhwbG9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt2YXIgZnJhbWVzID0gb3B0LmZyYW1lcyA/IG9wdC5mcmFtZXMgOiAzMDt2YXIgZnJhbWUgPSAwO3ZhciBleHBsb2RlZE1heCA9IG1hLm1heChjYS53aWR0aCwgY2EuaGVpZ2h0KTt2YXIgZXhwbG9kZWQgPSBOdW1iZXIodGhpcy5HZXQoJ2V4cGxvZGVkJykpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZXhwbG9kZWQgPSBmcmFtZSAvIGZyYW1lcyAqIGV4cGxvZGVkTWF4O29iai5TZXQoJ2V4cGxvZGVkJywgZXhwbG9kZWQpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgIFJHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5yb3VuZHJvYmluID0gdGhpcy5yb3VuZFJvYmluID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307XG4gICAgdmFyIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzA7dmFyIGZyYW1lID0gMDt2YXIgb3JpZ2luYWxfbWFyZ2luID0gcHJvcFsnY2hhcnQubWFyZ2luJ107dmFyIG1hcmdpbiA9IDM2MCAvIHRoaXMuZGF0YS5sZW5ndGggLyAyO3ZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTt0aGlzLlNldCgnY2hhcnQubWFyZ2luJywgbWFyZ2luKTt0aGlzLlNldCgnY2hhcnQuYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJywgMCk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgb2JqLnNldCgnYW5pbWF0aW9uLnJvdW5kcm9iaW4uZmFjdG9yJywgZnJhbWUgLyBmcmFtZXMpO29iai5zZXQoJ21hcmdpbicsIGZyYW1lIC8gZnJhbWVzICogb3JpZ2luYWxfbWFyZ2luKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmouc2V0KCdhbmltYXRpb24ucm91bmRyb2Jpbi5mYWN0b3InLCAxKTtvYmouc2V0KCdtYXJnaW4nLCBvcmlnaW5hbF9tYXJnaW4pO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5pbXBsb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7dmFyIGV4cGxvZGVkTWF4ID0gbWEubWF4KGNhLndpZHRoLCBjYS5oZWlnaHQpO3ZhciBleHBsb2RlZCA9IGV4cGxvZGVkTWF4O2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZXhwbG9kZWQgPSBleHBsb2RlZE1heCAtIGZyYW1lIC8gZnJhbWVzICogZXhwbG9kZWRNYXg7b2JqLlNldCgnZXhwbG9kZWQnLCBleHBsb2RlZCk7UkcuY2xlYXIoY2EpO1JHLnJlZHJhd0NhbnZhcyhjYSk7aWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgUkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzO3ZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBvYmouU2V0KCdhbmltYXRpb24uZ3Jvdy5tdWx0aXBsaWVyJywgZnJhbWUgLyBmcmFtZXMpO1JHLmNsZWFyKGNhKTtSRy5yZWRyYXdDYW52YXMoY2EpO2lmIChmcmFtZSA8IGZyYW1lcykge1xuICAgICAgICBmcmFtZSsrO1JHLkVmZmVjdHMudXBkYXRlQ2FudmFzKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnJvc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///200\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.RScatter = RGraph.Rscatter = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && typeof conf.data[0][0] === 'number') {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = arguments[1][i];\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  this.id = conf.id;\n  this.canvas = document.getElementById(this.id);\n  this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'rscatter';this.hasTooltips = false;this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.centerx = 0;this.centery = 0;this.radius = 0;this.max = 0;for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (typeof this.data[i][j][0] === 'string') {\n        this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n      }\n      if (typeof this.data[i][j][1] === 'string') {\n        this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n      }\n    }\n  }\n  this.properties = { 'chart.background.color': 'transparent', 'chart.background.grid': true, 'chart.background.grid.diagonals': true, 'chart.background.grid.diagonals.count': null, 'chart.background.grid.radials': true, 'chart.background.grid.radials.count': null, 'chart.background.grid.linewidth': 1, 'chart.background.grid.color': '#ccc', 'chart.radius': null, 'chart.colors': [], 'chart.colors.default': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': null, 'chart.labels.color': null, 'chart.labels.axes': 'nsew', 'chart.labels.axes.background': 'rgba(255,255,255,0.8)', 'chart.labels.count': 5, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.contextmenu': null, 'chart.tooltips': null, 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.hotspot': 3, 'chart.tooltips.coords.page': false, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.ymax': null, 'chart.ymin': 0, 'chart.tickmarks': 'cross', 'chart.ticksize': 3, 'chart.scale.decimals': null, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.round': false, 'chart.scale.zerostart': true, 'chart.units.pre': '', 'chart.units.post': '', 'chart.events.mousemove': null, 'chart.events.click': null, 'chart.highlight.stroke': 'transparent', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.highlight.point.radius': 3, 'chart.axes.color': 'black', 'chart.axes.numticks': null, 'chart.axes.caps': true, 'chart.segment.highlight': false, 'chart.segment.highlight.count': null, 'chart.segment.highlight.fill': 'rgba(0,255,0,0.5)', 'chart.segment.highlight.stroke': 'rgba(0,0,0,0)', 'chart.line': false, 'chart.line.close': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['black'], 'chart.line.shadow': false, 'chart.line.shadow.color': 'black', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.clearto': 'rgba(0,0,0,0)' };\n  for (var i = 0, idx = 0; i < this.data.length; ++i) {\n    for (var j = 0, len = this.data[i].length; j < len; j += 1, idx += 1) {\n      this['$' + idx] = {};\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name === 'chart.segments.highlight') name = 'chart.segment.highlight';if (name === 'chart.segments.highlight.count') name = 'chart.segment.highlight.count';if (name === 'chart.segments.highlight.fill') name = 'chart.segment.highlight.fill';if (name === 'chart.segments.highlight.stroke') name = 'chart.segment.highlight.stroke';prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.coords = [];this.coords2 = [];this.coordsText = [];if (typeof prop['chart.centerx'] == 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] == 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.radius'] == 'number') this.radius = prop['chart.radius'];if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    var max = prop['chart.ymax'];var min = prop['chart.ymin'];if (typeof max == 'number') {\n      this.max = max;this.scale2 = RG.getScale2(this, { 'max': max, 'min': min, 'strict': true, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });\n    } else {\n      for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          this.max = Math.max(this.max, this.data[i][j][1]);\n        }\n      }\n      this.min = prop['chart.ymin'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': min, 'scale.decimals': Number(prop['chart.scale.decimals']), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.labels.count'] });this.max = this.scale2.max;\n    }\n    if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {\n      this.centerx = this.centerx - prop['chart.gutter.right'] + 5;\n    }\n    if (_typeof(prop['chart.key']) == 'object' && RG.is_array(prop['chart.key']) && prop['chart.key'][0]) {\n      prop['chart.colors'] = [];for (var i = 0; i < this.data.length; i += 1) {\n        for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n          if (typeof this.data[i][j][2] == 'string') {\n            prop['chart.colors'].push(this.data[i][j][2]);\n          }\n        }\n      }\n    }\n    this.Set('chart.tooltips', []);for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        if (typeof this.data[i][j][3] == 'string') {\n          prop['chart.tooltips'].push(this.data[i][j][3]);\n        }\n      }\n    }\n    co.beginPath();this.DrawBackground();this.DrawRscatter();this.DrawLabels();if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.title']) {\n      RG.DrawTitle(this, prop['chart.title'], this.centery - this.radius - 10, this.centerx, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.segment.highlight']) {\n      RG.allowSegmentHighlight({ object: this, count: typeof prop['chart.segment.highlight.count'] === 'number' ? prop['chart.segment.highlight.count'] : prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8, fill: prop['chart.segment.highlight.fill'], stroke: prop['chart.segment.highlight.stroke'] });\n    }\n    if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.background.color'] != 'transparent') {\n      pa2(co, ['b', 'a', this.centerx, this.centery, this.radius, 0, 2 * ma.PI, -1, 'f', prop['chart.background.color']]);\n    }\n    var gridEnabled = prop['chart.background.grid'];if (gridEnabled) {\n      co.lineWidth = prop['chart.background.grid.linewidth'];if (prop['chart.background.grid.radials']) {\n        co.strokeStyle = prop['chart.background.grid.color'];if (RG.isNull(prop['chart.background.grid.radials.count'])) {\n          prop['chart.background.grid.radials.count'] = prop['chart.labels.count'];\n        }\n        var r = this.radius / prop['chart.background.grid.radials.count'];for (var i = 0, len = this.radius; i <= len; i += r) {\n          co.arc(this.centerx, this.centery, i, 0, RG.TWOPI, 0);\n        }\n        co.stroke();\n      }\n      if (prop['chart.background.grid.diagonals']) {\n        co.strokeStyle = prop['chart.background.grid.color'];co.beginPath();var inc = 360 / (prop['chart.background.grid.diagonals.count'] ? prop['chart.background.grid.diagonals.count'] : prop['chart.labels'] ? prop['chart.labels'].length : 8);for (var i = inc; i < 360; i += inc) {\n          co.arc(this.centerx, this.centery, this.radius, i / (180 / RG.PI) - RG.HALFPI, (i + 0.01) / (180 / RG.PI) - RG.HALFPI, 0);co.lineTo(this.centerx, this.centery);\n        }\n        co.stroke();\n      }\n    }\n    co.lineWidth = 1;co.beginPath();co.strokeStyle = prop['chart.axes.color'];co.moveTo(this.centerx - this.radius, Math.round(this.centery));co.lineTo(this.centerx + this.radius, Math.round(this.centery));if (prop['chart.axes.caps']) {\n      co.moveTo(ma.round(this.centerx - this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx - this.radius), this.centery + 5);co.moveTo(ma.round(this.centerx + this.radius), this.centery - 5);co.lineTo(ma.round(this.centerx + this.radius), this.centery + 5);\n    }\n    if (!RG.isNull(prop['chart.axes.numticks'])) {\n      var numticks = prop['chart.axes.numticks'];\n    } else {\n      var numticks = prop['chart.labels.count'];\n    }\n    var caps = prop['chart.axes.caps'];if (numticks) {\n      for (var i = this.centerx - this.radius; i < this.centerx + this.radius; i += this.radius / numticks) {\n        co.moveTo(ma.round(i), this.centery - 3);co.lineTo(ma.round(i), this.centery + 3);\n      }\n      for (var i = this.centery - this.radius; i < this.centery + this.radius; i += this.radius / numticks) {\n        co.moveTo(this.centerx - 3, ma.round(i));co.lineTo(this.centerx + 3, ma.round(i));\n      }\n    }\n    co.moveTo(ma.round(this.centerx), this.centery - this.radius);co.lineTo(ma.round(this.centerx), this.centery + this.radius);if (prop['chart.axes.caps']) {\n      co.moveTo(this.centerx - 5, ma.round(this.centery - this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery - this.radius));co.moveTo(this.centerx - 5, ma.round(this.centery + this.radius));co.lineTo(this.centerx + 5, ma.round(this.centery + this.radius));\n    }\n    co.closePath();co.stroke();\n  };this.drawRscatter = this.DrawRscatter = function () {\n    for (var dataset = 0; dataset < this.data.length; dataset += 1) {\n      var data = this.data[dataset];this.coords2[dataset] = [];var drawPoints = function drawPoints(obj) {\n        for (var i = 0; i < data.length; ++i) {\n          var d1 = data[i][0],\n              d2 = data[i][1],\n              a = d1 / (180 / RG.PI),\n              r = (d2 - prop['chart.ymin']) / (obj.scale2.max - obj.scale2.min) * obj.radius,\n              x = ma.sin(a) * r,\n              y = ma.cos(a) * r,\n              color = data[i][2] ? data[i][2] : prop['chart.colors.default'],\n              tooltip = data[i][3] ? data[i][3] : null;\n          if (tooltip && String(tooltip).length) {\n            obj.hasTooltips = true;\n          }\n          x = x + obj.centerx;y = obj.centery - y;obj.drawTick(x, y, color);obj.coords.push([x, y, color, tooltip]);obj.coords2[dataset].push([x, y, color, tooltip]);\n        }\n      };\n      drawPoints(this);if (prop['chart.line']) {\n        this.drawLine(dataset);\n      }\n    }\n  };this.drawLine = function (idx) {\n    var opt = { dataset: idx, coords: this.coords2[idx], color: prop['chart.line.colors'][idx], shadow: prop['chart.line.shadow'], shadowColor: prop['chart.line.shadow.color'], shadowOffsetX: prop['chart.line.shadow.offsetx'], shadowOffsetY: prop['chart.line.shadow.offsety'], shadowBlur: prop['chart.line.shadow.blur'], linewidth: prop['chart.line.linewidth'] };co.beginPath();co.strokeStyle = this.parseSingleColorForGradient(opt.color);co.lineWidth = _typeof(prop['chart.line.linewidth']) === 'object' ? prop['chart.line.linewidth'][idx] : prop['chart.line.linewidth'];co.lineCap = 'round';if (opt.shadow) {\n      RG.setShadow(this, opt.shadowColor, opt.shadowOffsetX, opt.shadowOffsetY, opt.shadowBlur);\n    }\n    for (var i = 0; i < this.coords2[idx].length; ++i) {\n      if (i === 0) {\n        co.moveTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);var startCoords = RG.arrayClone(this.coords2[idx]);\n      } else {\n        co.lineTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);\n      }\n    }\n    if (typeof prop['chart.line.close'] === 'boolean' && prop['chart.line.close'] || _typeof(prop['chart.line.close']) === 'object' && prop['chart.line.close'][idx]) {\n      co.lineTo(this.coords2[idx][0][0], this.coords2[idx][0][1]);\n    }\n    co.stroke();RG.noShadow(this);\n  };this.drawLabels = this.DrawLabels = function () {\n    co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';var key = prop['chart.key'];var r = this.radius;var axesColor = prop['chart.axes.color'];var color = prop['chart.text.color'];var font = prop['chart.text.font'];var size = prop['chart.text.size'];var axes = prop['chart.labels.axes'].toLowerCase();var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var decimals = prop['chart.scale.decimals'];var centerx = this.centerx;var centery = this.centery;co.fillStyle = prop['chart.text.color'];if (_typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {\n      this.DrawCircularLabels(co, prop['chart.labels'], font, size, r);\n    }\n    var offset = 10;var centered = false;if (axesColor === 'rgba(0,0,0,0)' || axesColor === 'rgb(0,0,0)' || axesColor === 'transparent') {\n      offset = 0;centered = true;\n    }\n    for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n      if (axes.indexOf('n') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery - r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('s') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - offset, 'y': centery + r * ((i + 1) / len), 'text': this.scale2.labels[i], 'valign': 'center', 'halign': centered ? 'center' : 'right', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('e') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx + r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });if (axes.indexOf('w') > -1) RG.text2(this, { 'tag': 'scale', 'font': font, 'size': size, 'x': centerx - r * ((i + 1) / len), 'y': centery + offset, 'text': this.scale2.labels[i], 'valign': centered ? 'center' : 'top', 'halign': 'center', bounding: true, boundingFill: prop['chart.labels.axes.background'], boundingStroke: 'rgba(0,0,0,0)' });\n    }\n    if (prop['chart.labels.axes'].length > 0 && prop['chart.scale.zerostart']) {\n      RG.text2(this, { 'font': font, 'size': size, 'x': centerx, 'y': centery, 'text': RG.numberFormat(this, Number(this.scale2.min).toFixed(this.scale2.decimals), this.scale2.units_pre, this.scale2.units_post), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': prop['chart.labels.axes.background'], 'boundingStroke': 'rgba(0,0,0,0)', 'tag': 'scale' });\n    }\n    if (key && key.length) {\n      RG.drawKey(this, key, prop['chart.colors']);\n    }\n  };this.drawCircularLabels = this.DrawCircularLabels = function (context, labels, font_face, font_size, r) {\n    var r = r + 10,\n        color = prop['chart.labels.color'];for (var i = 0; i < labels.length; ++i) {\n      var a = 360 / labels.length * (i + 1) - 360 / (labels.length * 2);var a = a - 90 + (prop['chart.labels.position'] == 'edge' ? 360 / labels.length / 2 : 0);var x = ma.cos(a / (180 / RG.PI)) * r;var y = ma.sin(a / (180 / RG.PI)) * r;RG.Text2(this, { 'color': color, 'font': font_face, 'size': font_size, 'x': this.centerx + x, 'y': this.centery + y, 'text': String(labels[i]), 'valign': 'center', 'halign': this.centerx + x > this.centerx ? 'left' : 'right', 'tag': 'labels' });\n    }\n  };this.drawTick = this.DrawTick = function (x, y, color) {\n    var tickmarks = prop['chart.tickmarks'];var ticksize = prop['chart.ticksize'];co.strokeStyle = color;co.fillStyle = color;var prevLinewidth = co.lineWidth;co.lineWidth = 1;if (tickmarks == 'cross') {\n      co.beginPath();co.moveTo(x + ticksize, y + ticksize);co.lineTo(x - ticksize, y - ticksize);co.stroke();co.beginPath();co.moveTo(x - ticksize, y + ticksize);co.lineTo(x + ticksize, y - ticksize);co.stroke();\n    } else if (tickmarks == 'circle') {\n      co.beginPath();co.arc(x, y, ticksize, 0, 6.2830, false);co.fill();\n    } else if (tickmarks == 'square') {\n      co.beginPath();co.fillRect(x - ticksize, y - ticksize, 2 * ticksize, 2 * ticksize);co.fill();\n    } else if (tickmarks == 'diamond') {\n      co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x + ticksize, y);co.lineTo(x, y + ticksize);co.lineTo(x - ticksize, y);co.closePath();co.fill();\n    } else if (tickmarks == 'plus') {\n      co.lineWidth = 1;co.beginPath();co.moveTo(x, y - ticksize);co.lineTo(x, y + ticksize);co.moveTo(x - ticksize, y);co.lineTo(x + ticksize, y);co.stroke();\n    }\n    co.lineWidth = prevLinewidth;\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var i = 0, len = this.coords.length; i < len; ++i) {\n      var x = this.coords[i][0];var y = this.coords[i][1];var tooltip = this.coords[i][3];if (mouseX < x + offset && mouseX > x - offset && mouseY < y + offset && mouseY > y - offset) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 1: x, 2: y, 3: i, 'object': this, 'x': x, 'y': y, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Point(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var centerx = this.centerx;var centery = this.centery;var radius = this.radius;if (mouseX > centerx - radius && mouseX < centerx + radius && mouseY > centery - radius && mouseY < centery + radius) {\n      return this;\n    }\n  };this.getRadius = function (value) {\n    var max = this.max;if (value < 0 || value > max) {\n      return null;\n    }\n    var r = value / max * this.radius;return r;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.arrayClone(prop['chart.highlight.fill']);this.original_colors['chart.colors.default'] = RG.arrayClone(prop['chart.colors.default']);this.original_colors['chart.background.grid.color'] = RG.arrayClone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.arrayClone(prop['chart.background.color']);this.original_colors['chart.segment.highlight.stroke'] = RG.arrayClone(prop['chart.segment.highlight.stroke']);this.original_colors['chart.segment.highlight.fill'] = RG.arrayClone(prop['chart.segment.highlight.fill']);\n    }\n    for (var i = 0; i < this.data.length; i += 1) {\n      for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n        this.data[i][j][2] = this.parseSingleColorForGradient(this.data[i][j][2]);\n      }\n    }\n    prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.colors.default'] = this.parseSingleColorForGradient(prop['chart.colors.default']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.segment.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.stroke']);prop['chart.segment.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.segment.highlight.fill']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords2 && this.coords2[index] && this.coords2[index].length) {\n      this.coords2[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 2, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);\n      }\n    }\n  };this.firstDrawFunc = function () {};RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5yc2NhdHRlci5qcz85NjE3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlJTY2F0dGVyID0gUkdyYXBoLlJzY2F0dGVyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYuZGF0YSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTt0aGlzLmRhdGEgPSBuZXcgQXJyYXkoY29uZi5kYXRhLmxlbmd0aCk7dGhpcy5kYXRhID0gUkdyYXBoLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtpZiAoX3R5cGVvZihjb25mLmRhdGEpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYuZGF0YVswXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmRhdGFbMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdG1wID0gUkdyYXBoLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtjb25mLmRhdGEgPSBuZXcgQXJyYXkoKTtjb25mLmRhdGFbMF0gPSBSR3JhcGguYXJyYXlDbG9uZSh0bXApO3RoaXMuZGF0YSA9IFJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb25mID0geyBpZDogY29uZiB9O2NvbmYuZGF0YSA9IGFyZ3VtZW50c1sxXTt0aGlzLmRhdGEgPSBbXTtpZiAoYXJndW1lbnRzWzFdWzBdICYmIGFyZ3VtZW50c1sxXVswXVswXSAmJiBfdHlwZW9mKGFyZ3VtZW50c1sxXVswXVswXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzWzFdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IGFyZ3VtZW50c1sxXVtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5kYXRhW2kgLSAxXSA9IFJHcmFwaC5hcnJheUNsb25lKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuaWQgPSBjb25mLmlkO1xuICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO1xuICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnR5cGUgPSAncnNjYXR0ZXInO3RoaXMuaGFzVG9vbHRpcHMgPSBmYWxzZTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLmNlbnRlcnggPSAwO3RoaXMuY2VudGVyeSA9IDA7dGhpcy5yYWRpdXMgPSAwO3RoaXMubWF4ID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5kYXRhW2ldW2pdWzBdID0gcGFyc2VGbG9hdCh0aGlzLmRhdGFbaV1bal1bMF0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV1bal1bMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpXVtqXVsxXSA9IHBhcnNlRmxvYXQodGhpcy5kYXRhW2ldW2pdWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5wcm9wZXJ0aWVzID0geyAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6ICd0cmFuc3BhcmVudCcsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGlhZ29uYWxzLmNvdW50JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzLmNvdW50JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5saW5ld2lkdGgnOiAxLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzogJyNjY2MnLCAnY2hhcnQucmFkaXVzJzogbnVsbCwgJ2NoYXJ0LmNvbG9ycyc6IFtdLCAnY2hhcnQuY29sb3JzLmRlZmF1bHQnOiAnYmxhY2snLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5sYWJlbHMnOiBudWxsLCAnY2hhcnQubGFiZWxzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5heGVzJzogJ25zZXcnLCAnY2hhcnQubGFiZWxzLmF4ZXMuYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuOCknLCAnY2hhcnQubGFiZWxzLmNvdW50JzogNSwgJ2NoYXJ0LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzogJ3JnYmEoMjU1LDAsMCwwLjkpJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOiAncmdiYSgyNTUsMCwwLDAuMiknLCAnY2hhcnQua2V5LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMnOiBudWxsLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25tb3VzZW1vdmUnLCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzogJ2ZhZGUnLCAnY2hhcnQudG9vbHRpcHMuY3NzLmNsYXNzJzogJ1JHcmFwaF90b29sdGlwJywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCc6IHRydWUsICdjaGFydC50b29sdGlwcy5ob3RzcG90JzogMywgJ2NoYXJ0LnRvb2x0aXBzLmNvb3Jkcy5wYWdlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0YWJsZSc6IGZhbHNlLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQuem9vbS5hY3Rpb24nOiAnem9vbScsICdjaGFydC5yZXNpemFibGUnOiBmYWxzZSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC55bWF4JzogbnVsbCwgJ2NoYXJ0LnltaW4nOiAwLCAnY2hhcnQudGlja21hcmtzJzogJ2Nyb3NzJywgJ2NoYXJ0LnRpY2tzaXplJzogMywgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogbnVsbCwgJ2NoYXJ0LnNjYWxlLnBvaW50JzogJy4nLCAnY2hhcnQuc2NhbGUudGhvdXNhbmQnOiAnLCcsICdjaGFydC5zY2FsZS5yb3VuZCc6IGZhbHNlLCAnY2hhcnQuc2NhbGUuemVyb3N0YXJ0JzogdHJ1ZSwgJ2NoYXJ0LnVuaXRzLnByZSc6ICcnLCAnY2hhcnQudW5pdHMucG9zdCc6ICcnLCAnY2hhcnQuZXZlbnRzLm1vdXNlbW92ZSc6IG51bGwsICdjaGFydC5ldmVudHMuY2xpY2snOiBudWxsLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICd0cmFuc3BhcmVudCcsICdjaGFydC5oaWdobGlnaHQuZmlsbCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCAnY2hhcnQuaGlnaGxpZ2h0LnBvaW50LnJhZGl1cyc6IDMsICdjaGFydC5heGVzLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmF4ZXMubnVtdGlja3MnOiBudWxsLCAnY2hhcnQuYXhlcy5jYXBzJzogdHJ1ZSwgJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0JzogZmFsc2UsICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCc6IG51bGwsICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMCwyNTUsMCwwLjUpJywgJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmxpbmUnOiBmYWxzZSwgJ2NoYXJ0LmxpbmUuY2xvc2UnOiBmYWxzZSwgJ2NoYXJ0LmxpbmUubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmxpbmUuY29sb3JzJzogWydibGFjayddLCAnY2hhcnQubGluZS5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LmxpbmUuc2hhZG93LmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmxpbmUuc2hhZG93LmJsdXInOiAyLCAnY2hhcnQubGluZS5zaGFkb3cub2Zmc2V0eCc6IDMsICdjaGFydC5saW5lLnNoYWRvdy5vZmZzZXR5JzogMywgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgZm9yICh2YXIgaSA9IDAsIGlkeCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gdGhpcy5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjsgaiArPSAxLCBpZHggKz0gMSkge1xuICAgICAgdGhpc1snJCcgKyBpZHhdID0ge307XG4gICAgfVxuICB9XG4gIGlmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NoYXJ0LnNlZ21lbnRzLmhpZ2hsaWdodCcpIG5hbWUgPSAnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQnO2lmIChuYW1lID09PSAnY2hhcnQuc2VnbWVudHMuaGlnaGxpZ2h0LmNvdW50JykgbmFtZSA9ICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCc7aWYgKG5hbWUgPT09ICdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuZmlsbCcpIG5hbWUgPSAnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuZmlsbCc7aWYgKG5hbWUgPT09ICdjaGFydC5zZWdtZW50cy5oaWdobGlnaHQuc3Ryb2tlJykgbmFtZSA9ICdjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnO3Byb3BbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTt0aGlzLmd1dHRlckxlZnQgPSBwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddO3RoaXMuZ3V0dGVyUmlnaHQgPSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt0aGlzLmd1dHRlclRvcCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXTt0aGlzLmd1dHRlckJvdHRvbSA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXTt0aGlzLnJhZGl1cyA9IE1hdGgubWluKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyO3RoaXMuY2VudGVyeCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gMiArIHRoaXMuZ3V0dGVyTGVmdDt0aGlzLmNlbnRlcnkgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3A7dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3JkczIgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmNlbnRlcngnXSA9PSAnbnVtYmVyJykgdGhpcy5jZW50ZXJ4ID0gcHJvcFsnY2hhcnQuY2VudGVyeCddO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQuY2VudGVyeSddID09ICdudW1iZXInKSB0aGlzLmNlbnRlcnkgPSBwcm9wWydjaGFydC5jZW50ZXJ5J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5yYWRpdXMnXSA9PSAnbnVtYmVyJykgdGhpcy5yYWRpdXMgPSBwcm9wWydjaGFydC5yYWRpdXMnXTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgbWF4ID0gcHJvcFsnY2hhcnQueW1heCddO3ZhciBtaW4gPSBwcm9wWydjaGFydC55bWluJ107aWYgKHR5cGVvZiBtYXggPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubWF4ID0gbWF4O3RoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IG1heCwgJ21pbic6IG1pbiwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS5kZWNpbWFscyc6IE51bWJlcihwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHRoaXMuZGF0YVtpXS5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMuZGF0YVtpXVtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWluID0gcHJvcFsnY2hhcnQueW1pbiddO3RoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHRoaXMubWF4LCAnbWluJzogbWluLCAnc2NhbGUuZGVjaW1hbHMnOiBOdW1iZXIocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5rZXknXSAmJiBwcm9wWydjaGFydC5rZXknXS5sZW5ndGggPiAwICYmIHByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCA+PSAzKSB7XG4gICAgICB0aGlzLmNlbnRlcnggPSB0aGlzLmNlbnRlcnggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSArIDU7XG4gICAgfVxuICAgIGlmIChfdHlwZW9mKHByb3BbJ2NoYXJ0LmtleSddKSA9PSAnb2JqZWN0JyAmJiBSRy5pc19hcnJheShwcm9wWydjaGFydC5rZXknXSkgJiYgcHJvcFsnY2hhcnQua2V5J11bMF0pIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmNvbG9ycyddID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHRoaXMuZGF0YVtpXS5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzJdID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwcm9wWydjaGFydC5jb2xvcnMnXS5wdXNoKHRoaXMuZGF0YVtpXVtqXVsyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuU2V0KCdjaGFydC50b29sdGlwcycsIFtdKTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHRoaXMuZGF0YVtpXS5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXVszXSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10ucHVzaCh0aGlzLmRhdGFbaV1bal1bM10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvLmJlZ2luUGF0aCgpO3RoaXMuRHJhd0JhY2tncm91bmQoKTt0aGlzLkRyYXdSc2NhdHRlcigpO3RoaXMuRHJhd0xhYmVscygpO2lmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRpdGxlJ10pIHtcbiAgICAgIFJHLkRyYXdUaXRsZSh0aGlzLCBwcm9wWydjaGFydC50aXRsZSddLCB0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cyAtIDEwLCB0aGlzLmNlbnRlcngsIHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA/IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA6IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddICsgMik7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5yZXNpemFibGUnXSkge1xuICAgICAgUkcuQWxsb3dSZXNpemluZyh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmIChwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodCddKSB7XG4gICAgICBSRy5hbGxvd1NlZ21lbnRIaWdobGlnaHQoeyBvYmplY3Q6IHRoaXMsIGNvdW50OiB0eXBlb2YgcHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuY291bnQnXSA9PT0gJ251bWJlcicgPyBwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5jb3VudCddIDogcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscy5jb3VudCddID8gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscy5jb3VudCddIDogcHJvcFsnY2hhcnQubGFiZWxzJ10gPyBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggOiA4LCBmaWxsOiBwcm9wWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10sIHN0cm9rZTogcHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ10gfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3QmFja2dyb3VuZCA9IHRoaXMuRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSAhPSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICBwYTIoY28sIFsnYicsICdhJywgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzLCAwLCAyICogbWEuUEksIC0xLCAnZicsIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXV0pO1xuICAgIH1cbiAgICB2YXIgZ3JpZEVuYWJsZWQgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQnXTtpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIGNvLmxpbmVXaWR0aCA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5saW5ld2lkdGgnXTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMnXSkge1xuICAgICAgICBjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddO2lmIChSRy5pc051bGwocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnJhZGlhbHMuY291bnQnXSkpIHtcbiAgICAgICAgICBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQucmFkaWFscy5jb3VudCddID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cyAvIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5yYWRpYWxzLmNvdW50J107Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucmFkaXVzOyBpIDw9IGxlbjsgaSArPSByKSB7XG4gICAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBpLCAwLCBSRy5UV09QSSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY28uc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmRpYWdvbmFscyddKSB7XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ107Y28uYmVnaW5QYXRoKCk7dmFyIGluYyA9IDM2MCAvIChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGlhZ29uYWxzLmNvdW50J10gPyBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuZGlhZ29uYWxzLmNvdW50J10gOiBwcm9wWydjaGFydC5sYWJlbHMnXSA/IHByb3BbJ2NoYXJ0LmxhYmVscyddLmxlbmd0aCA6IDgpO2ZvciAodmFyIGkgPSBpbmM7IGkgPCAzNjA7IGkgKz0gaW5jKSB7XG4gICAgICAgICAgY28uYXJjKHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgaSAvICgxODAgLyBSRy5QSSkgLSBSRy5IQUxGUEksIChpICsgMC4wMSkgLyAoMTgwIC8gUkcuUEkpIC0gUkcuSEFMRlBJLCAwKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5saW5lV2lkdGggPSAxO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYXhlcy5jb2xvciddO2NvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cywgTWF0aC5yb3VuZCh0aGlzLmNlbnRlcnkpKTtjby5saW5lVG8odGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMsIE1hdGgucm91bmQodGhpcy5jZW50ZXJ5KSk7aWYgKHByb3BbJ2NoYXJ0LmF4ZXMuY2FwcyddKSB7XG4gICAgICBjby5tb3ZlVG8obWEucm91bmQodGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMpLCB0aGlzLmNlbnRlcnkgLSA1KTtjby5saW5lVG8obWEucm91bmQodGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMpLCB0aGlzLmNlbnRlcnkgKyA1KTtjby5tb3ZlVG8obWEucm91bmQodGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMpLCB0aGlzLmNlbnRlcnkgLSA1KTtjby5saW5lVG8obWEucm91bmQodGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMpLCB0aGlzLmNlbnRlcnkgKyA1KTtcbiAgICB9XG4gICAgaWYgKCFSRy5pc051bGwocHJvcFsnY2hhcnQuYXhlcy5udW10aWNrcyddKSkge1xuICAgICAgdmFyIG51bXRpY2tzID0gcHJvcFsnY2hhcnQuYXhlcy5udW10aWNrcyddO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbnVtdGlja3MgPSBwcm9wWydjaGFydC5sYWJlbHMuY291bnQnXTtcbiAgICB9XG4gICAgdmFyIGNhcHMgPSBwcm9wWydjaGFydC5heGVzLmNhcHMnXTtpZiAobnVtdGlja3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1czsgaSA8IHRoaXMuY2VudGVyeCArIHRoaXMucmFkaXVzOyBpICs9IHRoaXMucmFkaXVzIC8gbnVtdGlja3MpIHtcbiAgICAgICAgY28ubW92ZVRvKG1hLnJvdW5kKGkpLCB0aGlzLmNlbnRlcnkgLSAzKTtjby5saW5lVG8obWEucm91bmQoaSksIHRoaXMuY2VudGVyeSArIDMpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzOyBpIDwgdGhpcy5jZW50ZXJ5ICsgdGhpcy5yYWRpdXM7IGkgKz0gdGhpcy5yYWRpdXMgLyBudW10aWNrcykge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5jZW50ZXJ4IC0gMywgbWEucm91bmQoaSkpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyAzLCBtYS5yb3VuZChpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmNlbnRlcngpLCB0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cyk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuY2VudGVyeCksIHRoaXMuY2VudGVyeSArIHRoaXMucmFkaXVzKTtpZiAocHJvcFsnY2hhcnQuYXhlcy5jYXBzJ10pIHtcbiAgICAgIGNvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSA1LCBtYS5yb3VuZCh0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cykpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyA1LCBtYS5yb3VuZCh0aGlzLmNlbnRlcnkgLSB0aGlzLnJhZGl1cykpO2NvLm1vdmVUbyh0aGlzLmNlbnRlcnggLSA1LCBtYS5yb3VuZCh0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cykpO2NvLmxpbmVUbyh0aGlzLmNlbnRlcnggKyA1LCBtYS5yb3VuZCh0aGlzLmNlbnRlcnkgKyB0aGlzLnJhZGl1cykpO1xuICAgIH1cbiAgICBjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtcbiAgfTt0aGlzLmRyYXdSc2NhdHRlciA9IHRoaXMuRHJhd1JzY2F0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgdGhpcy5kYXRhLmxlbmd0aDsgZGF0YXNldCArPSAxKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVtkYXRhc2V0XTt0aGlzLmNvb3JkczJbZGF0YXNldF0gPSBbXTt2YXIgZHJhd1BvaW50cyA9IGZ1bmN0aW9uIGRyYXdQb2ludHMob2JqKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBkMSA9IGRhdGFbaV1bMF0sXG4gICAgICAgICAgICAgIGQyID0gZGF0YVtpXVsxXSxcbiAgICAgICAgICAgICAgYSA9IGQxIC8gKDE4MCAvIFJHLlBJKSxcbiAgICAgICAgICAgICAgciA9IChkMiAtIHByb3BbJ2NoYXJ0LnltaW4nXSkgLyAob2JqLnNjYWxlMi5tYXggLSBvYmouc2NhbGUyLm1pbikgKiBvYmoucmFkaXVzLFxuICAgICAgICAgICAgICB4ID0gbWEuc2luKGEpICogcixcbiAgICAgICAgICAgICAgeSA9IG1hLmNvcyhhKSAqIHIsXG4gICAgICAgICAgICAgIGNvbG9yID0gZGF0YVtpXVsyXSA/IGRhdGFbaV1bMl0gOiBwcm9wWydjaGFydC5jb2xvcnMuZGVmYXVsdCddLFxuICAgICAgICAgICAgICB0b29sdGlwID0gZGF0YVtpXVszXSA/IGRhdGFbaV1bM10gOiBudWxsO1xuICAgICAgICAgIGlmICh0b29sdGlwICYmIFN0cmluZyh0b29sdGlwKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5oYXNUb29sdGlwcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHggPSB4ICsgb2JqLmNlbnRlcng7eSA9IG9iai5jZW50ZXJ5IC0geTtvYmouZHJhd1RpY2soeCwgeSwgY29sb3IpO29iai5jb29yZHMucHVzaChbeCwgeSwgY29sb3IsIHRvb2x0aXBdKTtvYmouY29vcmRzMltkYXRhc2V0XS5wdXNoKFt4LCB5LCBjb2xvciwgdG9vbHRpcF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZHJhd1BvaW50cyh0aGlzKTtpZiAocHJvcFsnY2hhcnQubGluZSddKSB7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZGF0YXNldCk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd0xpbmUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIG9wdCA9IHsgZGF0YXNldDogaWR4LCBjb29yZHM6IHRoaXMuY29vcmRzMltpZHhdLCBjb2xvcjogcHJvcFsnY2hhcnQubGluZS5jb2xvcnMnXVtpZHhdLCBzaGFkb3c6IHByb3BbJ2NoYXJ0LmxpbmUuc2hhZG93J10sIHNoYWRvd0NvbG9yOiBwcm9wWydjaGFydC5saW5lLnNoYWRvdy5jb2xvciddLCBzaGFkb3dPZmZzZXRYOiBwcm9wWydjaGFydC5saW5lLnNoYWRvdy5vZmZzZXR4J10sIHNoYWRvd09mZnNldFk6IHByb3BbJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHknXSwgc2hhZG93Qmx1cjogcHJvcFsnY2hhcnQubGluZS5zaGFkb3cuYmx1ciddLCBsaW5ld2lkdGg6IHByb3BbJ2NoYXJ0LmxpbmUubGluZXdpZHRoJ10gfTtjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KG9wdC5jb2xvcik7Y28ubGluZVdpZHRoID0gX3R5cGVvZihwcm9wWydjaGFydC5saW5lLmxpbmV3aWR0aCddKSA9PT0gJ29iamVjdCcgPyBwcm9wWydjaGFydC5saW5lLmxpbmV3aWR0aCddW2lkeF0gOiBwcm9wWydjaGFydC5saW5lLmxpbmV3aWR0aCddO2NvLmxpbmVDYXAgPSAncm91bmQnO2lmIChvcHQuc2hhZG93KSB7XG4gICAgICBSRy5zZXRTaGFkb3codGhpcywgb3B0LnNoYWRvd0NvbG9yLCBvcHQuc2hhZG93T2Zmc2V0WCwgb3B0LnNoYWRvd09mZnNldFksIG9wdC5zaGFkb3dCbHVyKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3JkczJbaWR4XS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuY29vcmRzMltpZHhdW2ldWzBdLCB0aGlzLmNvb3JkczJbaWR4XVtpXVsxXSk7dmFyIHN0YXJ0Q29vcmRzID0gUkcuYXJyYXlDbG9uZSh0aGlzLmNvb3JkczJbaWR4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5saW5lVG8odGhpcy5jb29yZHMyW2lkeF1baV1bMF0sIHRoaXMuY29vcmRzMltpZHhdW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5saW5lLmNsb3NlJ10gPT09ICdib29sZWFuJyAmJiBwcm9wWydjaGFydC5saW5lLmNsb3NlJ10gfHwgX3R5cGVvZihwcm9wWydjaGFydC5saW5lLmNsb3NlJ10pID09PSAnb2JqZWN0JyAmJiBwcm9wWydjaGFydC5saW5lLmNsb3NlJ11baWR4XSkge1xuICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzMltpZHhdWzBdWzBdLCB0aGlzLmNvb3JkczJbaWR4XVswXVsxXSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1JHLm5vU2hhZG93KHRoaXMpO1xuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjby5saW5lV2lkdGggPSAxO2NvLmZpbGxTdHlsZSA9ICdibGFjayc7Y28uc3Ryb2tlU3R5bGUgPSAnYmxhY2snO3ZhciBrZXkgPSBwcm9wWydjaGFydC5rZXknXTt2YXIgciA9IHRoaXMucmFkaXVzO3ZhciBheGVzQ29sb3IgPSBwcm9wWydjaGFydC5heGVzLmNvbG9yJ107dmFyIGNvbG9yID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgYXhlcyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzJ10udG9Mb3dlckNhc2UoKTt2YXIgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ107dmFyIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J107dmFyIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTt2YXIgY2VudGVyeCA9IHRoaXMuY2VudGVyeDt2YXIgY2VudGVyeSA9IHRoaXMuY2VudGVyeTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC50ZXh0LmNvbG9yJ107aWYgKF90eXBlb2YocHJvcFsnY2hhcnQubGFiZWxzJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LmxhYmVscyddKSB7XG4gICAgICB0aGlzLkRyYXdDaXJjdWxhckxhYmVscyhjbywgcHJvcFsnY2hhcnQubGFiZWxzJ10sIGZvbnQsIHNpemUsIHIpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gMTA7dmFyIGNlbnRlcmVkID0gZmFsc2U7aWYgKGF4ZXNDb2xvciA9PT0gJ3JnYmEoMCwwLDAsMCknIHx8IGF4ZXNDb2xvciA9PT0gJ3JnYigwLDAsMCknIHx8IGF4ZXNDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgb2Zmc2V0ID0gMDtjZW50ZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoJ24nKSA+IC0xKSBSRy50ZXh0Mih0aGlzLCB7ICd0YWcnOiAnc2NhbGUnLCAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiBjZW50ZXJ4IC0gb2Zmc2V0LCAneSc6IGNlbnRlcnkgLSByICogKChpICsgMSkgLyBsZW4pLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogY2VudGVyZWQgPyAnY2VudGVyJyA6ICdyaWdodCcsIGJvdW5kaW5nOiB0cnVlLCBib3VuZGluZ0ZpbGw6IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJhY2tncm91bmQnXSwgYm91bmRpbmdTdHJva2U6ICdyZ2JhKDAsMCwwLDApJyB9KTtpZiAoYXhlcy5pbmRleE9mKCdzJykgPiAtMSkgUkcudGV4dDIodGhpcywgeyAndGFnJzogJ3NjYWxlJywgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIG9mZnNldCwgJ3knOiBjZW50ZXJ5ICsgciAqICgoaSArIDEpIC8gbGVuKSwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGNlbnRlcmVkID8gJ2NlbnRlcicgOiAncmlnaHQnLCBib3VuZGluZzogdHJ1ZSwgYm91bmRpbmdGaWxsOiBwcm9wWydjaGFydC5sYWJlbHMuYXhlcy5iYWNrZ3JvdW5kJ10sIGJvdW5kaW5nU3Ryb2tlOiAncmdiYSgwLDAsMCwwKScgfSk7aWYgKGF4ZXMuaW5kZXhPZignZScpID4gLTEpIFJHLnRleHQyKHRoaXMsIHsgJ3RhZyc6ICdzY2FsZScsICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcnggKyByICogKChpICsgMSkgLyBsZW4pLCAneSc6IGNlbnRlcnkgKyBvZmZzZXQsICd0ZXh0JzogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCAndmFsaWduJzogY2VudGVyZWQgPyAnY2VudGVyJyA6ICd0b3AnLCAnaGFsaWduJzogJ2NlbnRlcicsIGJvdW5kaW5nOiB0cnVlLCBib3VuZGluZ0ZpbGw6IHByb3BbJ2NoYXJ0LmxhYmVscy5heGVzLmJhY2tncm91bmQnXSwgYm91bmRpbmdTdHJva2U6ICdyZ2JhKDAsMCwwLDApJyB9KTtpZiAoYXhlcy5pbmRleE9mKCd3JykgPiAtMSkgUkcudGV4dDIodGhpcywgeyAndGFnJzogJ3NjYWxlJywgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogY2VudGVyeCAtIHIgKiAoKGkgKyAxKSAvIGxlbiksICd5JzogY2VudGVyeSArIG9mZnNldCwgJ3RleHQnOiB0aGlzLnNjYWxlMi5sYWJlbHNbaV0sICd2YWxpZ24nOiBjZW50ZXJlZCA/ICdjZW50ZXInIDogJ3RvcCcsICdoYWxpZ24nOiAnY2VudGVyJywgYm91bmRpbmc6IHRydWUsIGJvdW5kaW5nRmlsbDogcHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYmFja2dyb3VuZCddLCBib3VuZGluZ1N0cm9rZTogJ3JnYmEoMCwwLDAsMCknIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMnXS5sZW5ndGggPiAwICYmIHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKSB7XG4gICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiBzaXplLCAneCc6IGNlbnRlcngsICd5JzogY2VudGVyeSwgJ3RleHQnOiBSRy5udW1iZXJGb3JtYXQodGhpcywgTnVtYmVyKHRoaXMuc2NhbGUyLm1pbikudG9GaXhlZCh0aGlzLnNjYWxlMi5kZWNpbWFscyksIHRoaXMuc2NhbGUyLnVuaXRzX3ByZSwgdGhpcy5zY2FsZTIudW5pdHNfcG9zdCksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYm91bmRpbmcnOiB0cnVlLCAnYm91bmRpbmdGaWxsJzogcHJvcFsnY2hhcnQubGFiZWxzLmF4ZXMuYmFja2dyb3VuZCddLCAnYm91bmRpbmdTdHJva2UnOiAncmdiYSgwLDAsMCwwKScsICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgIH1cbiAgICBpZiAoa2V5ICYmIGtleS5sZW5ndGgpIHtcbiAgICAgIFJHLmRyYXdLZXkodGhpcywga2V5LCBwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICB9O3RoaXMuZHJhd0NpcmN1bGFyTGFiZWxzID0gdGhpcy5EcmF3Q2lyY3VsYXJMYWJlbHMgPSBmdW5jdGlvbiAoY29udGV4dCwgbGFiZWxzLCBmb250X2ZhY2UsIGZvbnRfc2l6ZSwgcikge1xuICAgIHZhciByID0gciArIDEwLFxuICAgICAgICBjb2xvciA9IHByb3BbJ2NoYXJ0LmxhYmVscy5jb2xvciddO2ZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYSA9IDM2MCAvIGxhYmVscy5sZW5ndGggKiAoaSArIDEpIC0gMzYwIC8gKGxhYmVscy5sZW5ndGggKiAyKTt2YXIgYSA9IGEgLSA5MCArIChwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSA9PSAnZWRnZScgPyAzNjAgLyBsYWJlbHMubGVuZ3RoIC8gMiA6IDApO3ZhciB4ID0gbWEuY29zKGEgLyAoMTgwIC8gUkcuUEkpKSAqIHI7dmFyIHkgPSBtYS5zaW4oYSAvICgxODAgLyBSRy5QSSkpICogcjtSRy5UZXh0Mih0aGlzLCB7ICdjb2xvcic6IGNvbG9yLCAnZm9udCc6IGZvbnRfZmFjZSwgJ3NpemUnOiBmb250X3NpemUsICd4JzogdGhpcy5jZW50ZXJ4ICsgeCwgJ3knOiB0aGlzLmNlbnRlcnkgKyB5LCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaV0pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiB0aGlzLmNlbnRlcnggKyB4ID4gdGhpcy5jZW50ZXJ4ID8gJ2xlZnQnIDogJ3JpZ2h0JywgJ3RhZyc6ICdsYWJlbHMnIH0pO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdUaWNrID0gdGhpcy5EcmF3VGljayA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvcikge1xuICAgIHZhciB0aWNrbWFya3MgPSBwcm9wWydjaGFydC50aWNrbWFya3MnXTt2YXIgdGlja3NpemUgPSBwcm9wWydjaGFydC50aWNrc2l6ZSddO2NvLnN0cm9rZVN0eWxlID0gY29sb3I7Y28uZmlsbFN0eWxlID0gY29sb3I7dmFyIHByZXZMaW5ld2lkdGggPSBjby5saW5lV2lkdGg7Y28ubGluZVdpZHRoID0gMTtpZiAodGlja21hcmtzID09ICdjcm9zcycpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4ICsgdGlja3NpemUsIHkgKyB0aWNrc2l6ZSk7Y28ubGluZVRvKHggLSB0aWNrc2l6ZSwgeSAtIHRpY2tzaXplKTtjby5zdHJva2UoKTtjby5iZWdpblBhdGgoKTtjby5tb3ZlVG8oeCAtIHRpY2tzaXplLCB5ICsgdGlja3NpemUpO2NvLmxpbmVUbyh4ICsgdGlja3NpemUsIHkgLSB0aWNrc2l6ZSk7Y28uc3Ryb2tlKCk7XG4gICAgfSBlbHNlIGlmICh0aWNrbWFya3MgPT0gJ2NpcmNsZScpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLmFyYyh4LCB5LCB0aWNrc2l6ZSwgMCwgNi4yODMwLCBmYWxzZSk7Y28uZmlsbCgpO1xuICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdzcXVhcmUnKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsUmVjdCh4IC0gdGlja3NpemUsIHkgLSB0aWNrc2l6ZSwgMiAqIHRpY2tzaXplLCAyICogdGlja3NpemUpO2NvLmZpbGwoKTtcbiAgICB9IGVsc2UgaWYgKHRpY2ttYXJrcyA9PSAnZGlhbW9uZCcpIHtcbiAgICAgIGNvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LCB5IC0gdGlja3NpemUpO2NvLmxpbmVUbyh4ICsgdGlja3NpemUsIHkpO2NvLmxpbmVUbyh4LCB5ICsgdGlja3NpemUpO2NvLmxpbmVUbyh4IC0gdGlja3NpemUsIHkpO2NvLmNsb3NlUGF0aCgpO2NvLmZpbGwoKTtcbiAgICB9IGVsc2UgaWYgKHRpY2ttYXJrcyA9PSAncGx1cycpIHtcbiAgICAgIGNvLmxpbmVXaWR0aCA9IDE7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgsIHkgLSB0aWNrc2l6ZSk7Y28ubGluZVRvKHgsIHkgKyB0aWNrc2l6ZSk7Y28ubW92ZVRvKHggLSB0aWNrc2l6ZSwgeSk7Y28ubGluZVRvKHggKyB0aWNrc2l6ZSwgeSk7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvLmxpbmVXaWR0aCA9IHByZXZMaW5ld2lkdGg7XG4gIH07dGhpcy5nZXRTaGFwZSA9IHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYID0gbW91c2VYWVswXTt2YXIgbW91c2VZID0gbW91c2VYWVsxXTt2YXIgb3ZlckhvdHNwb3QgPSBmYWxzZTt2YXIgb2Zmc2V0ID0gcHJvcFsnY2hhcnQudG9vbHRpcHMuaG90c3BvdCddO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIHggPSB0aGlzLmNvb3Jkc1tpXVswXTt2YXIgeSA9IHRoaXMuY29vcmRzW2ldWzFdO3ZhciB0b29sdGlwID0gdGhpcy5jb29yZHNbaV1bM107aWYgKG1vdXNlWCA8IHggKyBvZmZzZXQgJiYgbW91c2VYID4geCAtIG9mZnNldCAmJiBtb3VzZVkgPCB5ICsgb2Zmc2V0ICYmIG1vdXNlWSA+IHkgLSBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGkpO3JldHVybiB7IDA6IHRoaXMsIDE6IHgsIDI6IHksIDM6IGksICdvYmplY3QnOiB0aGlzLCAneCc6IHgsICd5JzogeSwgJ2luZGV4JzogaSwgJ3Rvb2x0aXAnOiB0b29sdGlwIH07XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuYWxsb3dUb29sdGlwcyA9IHRoaXMuQWxsb3dUb29sdGlwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBSRy5QcmVMb2FkVG9vbHRpcEltYWdlcyh0aGlzKTtSRy5JbnN0YWxsV2luZG93TW91c2Vkb3duVG9vbHRpcExpc3RlbmVyKHRoaXMpO1JHLkluc3RhbGxDYW52YXNNb3VzZW1vdmVUb29sdGlwTGlzdGVuZXIodGhpcyk7UkcuSW5zdGFsbENhbnZhc01vdXNldXBUb29sdGlwTGlzdGVuZXIodGhpcyk7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuSGlnaGxpZ2h0LlBvaW50KHRoaXMsIHNoYXBlKTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07dmFyIGNlbnRlcnggPSB0aGlzLmNlbnRlcng7dmFyIGNlbnRlcnkgPSB0aGlzLmNlbnRlcnk7dmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO2lmIChtb3VzZVggPiBjZW50ZXJ4IC0gcmFkaXVzICYmIG1vdXNlWCA8IGNlbnRlcnggKyByYWRpdXMgJiYgbW91c2VZID4gY2VudGVyeSAtIHJhZGl1cyAmJiBtb3VzZVkgPCBjZW50ZXJ5ICsgcmFkaXVzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07dGhpcy5nZXRSYWRpdXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7aWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByID0gdmFsdWUgLyBtYXggKiB0aGlzLnJhZGl1cztyZXR1cm4gcjtcbiAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsX2NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ10gPSBSRy5hcnJheV9jbG9uZSh0aGlzLmRhdGEpO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5jb2xvcnMuZGVmYXVsdCddID0gUkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMuZGVmYXVsdCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5jb2xvciddID0gUkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5Q2xvbmUocHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zZWdtZW50LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gdGhpcy5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjsgaiArPSAxKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpXVtqXVsyXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHRoaXMuZGF0YVtpXVtqXVsyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmNvbG9ycy5kZWZhdWx0J10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMuZGVmYXVsdCddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc2VnbWVudC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnNlZ21lbnQuaGlnaGxpZ2h0LmZpbGwnXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgMCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmICh0aGlzLmNvb3JkczIgJiYgdGhpcy5jb29yZHMyW2luZGV4XSAmJiB0aGlzLmNvb3JkczJbaW5kZXhdLmxlbmd0aCkge1xuICAgICAgdGhpcy5jb29yZHMyW2luZGV4XS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4LCBhcnIpIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJ107Y28uYXJjKHZhbHVlWzBdLCB2YWx1ZVsxXSwgcHJvcFsnY2hhcnQudGlja3NpemUnXSArIDIsIDAsIFJHLlRXT1BJLCBmYWxzZSk7Y28uZmlsbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSB0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraikge1xuICAgICAgICB0aGlzLmRhdGFbaV1bal1bMl0gPSBSRy5hcnJheV9jbG9uZSh0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddW2ldW2pdWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307UkcuYXR0KGNhKTtSRy5SZWdpc3Rlcih0aGlzKTtpZiAocGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucykge1xuICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgY29uZi5vcHRpb25zKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgucnNjYXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///201\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Scatter = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;this.data = new Array(conf.data.length);this.data = RGraph.arrayClone(conf.data);if (_typeof(conf.data) === 'object' && _typeof(conf.data[0]) === 'object' && (typeof conf.data[0][0] === 'number' || typeof conf.data[0][0] === 'string')) {\n      var tmp = RGraph.arrayClone(conf.data);conf.data = new Array();conf.data[0] = RGraph.arrayClone(tmp);this.data = RGraph.arrayClone(conf.data);\n    }\n  } else {\n    var conf = { id: conf };conf.data = arguments[1];this.data = [];if (arguments[1][0] && arguments[1][0][0] && _typeof(arguments[1][0][0]) == 'object') {\n      for (var i = 0; i < arguments[1].length; ++i) {\n        this.data[i] = RGraph.arrayClone(arguments[1][i]);\n      }\n    } else {\n      for (var i = 1; i < arguments.length; ++i) {\n        this.data[i - 1] = RGraph.arrayClone(arguments[i]);\n      }\n    }\n  }\n  if (!RGraph.isArray(this.data[0][0])) {\n    this.data = [this.data];\n  }\n  for (var i = 0, len = this.data.length; i < len; ++i) {\n    for (var j = 0, len2 = this.data[i].length; j < len2; ++j) {\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][0] === 'string') {\n        if (this.data[i][j][0].match(/^[.0-9]+$/)) {\n          this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n        } else if (this.data[i][j][0] === '') {\n          this.data[i][j][0] = 0;\n        }\n      }\n      if (_typeof(this.data[i][j]) === 'object' && !RGraph.isNull(this.data[i][j]) && typeof this.data[i][j][1] === 'string') {\n        if (this.data[i][j][1].match(/[.0-9]+/)) {\n          this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n        } else if (this.data[i][j][1] === '') {\n          this.data[i][j][1] = 0;\n        }\n      }\n    }\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.canvas.__object__ = this;this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.max = 0;this.coords = [];this.type = 'scatter';this.isRGraph = true;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.width': 1, 'chart.background.grid.color': '#ddd', 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.hbars': null, 'chart.background.vbars': null, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.image.stretch': true, 'chart.background.image.x': null, 'chart.background.image.y': null, 'chart.background.image.w': null, 'chart.background.image.h': null, 'chart.background.image.align': null, 'chart.background.color': null, 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.tooltips': [], 'chart.tooltips.effect': 'fade', 'chart.tooltips.event': 'onmousemove', 'chart.tooltips.hotspot': 3, 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.coords.page': false, 'chart.units.pre': '', 'chart.units.post': '', 'chart.numyticks': 10, 'chart.tickmarks': 'cross', 'chart.tickmarks.image.halign': 'center', 'chart.tickmarks.image.valign': 'center', 'chart.tickmarks.image.offsetx': 0, 'chart.tickmarks.image.offsety': 0, 'chart.ticksize': 5, 'chart.numxticks': true, 'chart.xaxis': true, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 30, 'chart.colors.bubble.graduated': true, 'chart.xmin': 0, 'chart.xmax': 0, 'chart.ymax': null, 'chart.ymin': 0, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.title': '', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.color': null, 'chart.labels.ingraph': null, 'chart.labels.above': false, 'chart.labels.above.size': 8, 'chart.labels.above.decimals': 0, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.ylabels.count': 5, 'chart.ylabels.invert': false, 'chart.ylabels.specific': null, 'chart.ylabels.inside': false, 'chart.contextmenu': null, 'chart.defaultcolor': 'black', 'chart.xaxispos': 'bottom', 'chart.yaxispos': 'left', 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.linewidth': 1, 'chart.crosshairs.coords': false, 'chart.crosshairs.coords.fixed': true, 'chart.crosshairs.coords.fadeout': false, 'chart.crosshairs.coords.labels.x': 'X', 'chart.crosshairs.coords.labels.y': 'Y', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.line': false, 'chart.line.linewidth': 1, 'chart.line.colors': ['green', 'red'], 'chart.line.shadow.color': 'rgba(0,0,0,0)', 'chart.line.shadow.blur': 2, 'chart.line.shadow.offsetx': 3, 'chart.line.shadow.offsety': 3, 'chart.line.stepped': false, 'chart.line.visible': true, 'chart.noaxes': false, 'chart.noyaxis': false, 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.fill': 'rgba(255,0,0,0.9)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.text.color': 'black', 'chart.axis.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.boxplot.width': 1, 'chart.boxplot.capped': true, 'chart.resizable': false, 'chart.resize.handle.background': null }, _defineProperty(_properties, 'chart.xmin', 0), _defineProperty(_properties, 'chart.labels.specific.align', 'left'), _defineProperty(_properties, 'chart.xscale', false), _defineProperty(_properties, 'chart.xscale.units.pre', ''), _defineProperty(_properties, 'chart.xscale.units.post', ''), _defineProperty(_properties, 'chart.xscale.numlabels', 10), _defineProperty(_properties, 'chart.xscale.formatter', null), _defineProperty(_properties, 'chart.xscale.decimals', 0), _defineProperty(_properties, 'chart.xscale.thousand', ','), _defineProperty(_properties, 'chart.xscale.point', '.'), _defineProperty(_properties, 'chart.noendxtick', false), _defineProperty(_properties, 'chart.noendytick', true), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.animation.trace', false), _defineProperty(_properties, 'chart.animation.trace.clip', 1), _properties);\n  for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      if (RGraph.isNull(this.data[i][j])) {\n        this.data[i][j] = [];\n      }\n      if (this.data[i][j] && typeof this.data[i][j][0] == 'string') {\n        this.data[i][j][0] = RGraph.parseDate(this.data[i][j][0]);\n      }\n    }\n  }\n  this.data_arr = [];for (var i = 0; i < this.data.length; ++i) {\n    for (var j = 0; j < this.data[i].length; ++j) {\n      this.data_arr.push(this.data[i][j]);\n    }\n  }\n  for (var i = 0; i < this.data_arr.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas) {\n    alert('[SCATTER] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.xticks') {\n      name == 'chart.numxticks';\n    }\n    if (name == 'chart.line.colors') {\n      prop['chart.colors'] = value;\n    }\n    if (name == 'chart.tooltip.hotspot') {\n      name = 'chart.tooltips.hotspot';\n    }\n    if (name == 'chart.yaxispos' && value != 'left' && value != 'right') {\n      alert(\"[SCATTER] chart.yaxispos should be left or right. You've set it to: '\" + value + \"' Changing it to left\");value = 'left';\n    }\n    if (name == 'chart.xaxispos') {\n      if (value != 'bottom' && value != 'center') {\n        alert('[SCATTER] (' + this.id + ') chart.xaxispos should be center or bottom. Tried to set it to: ' + value + ' Changing it to center');value = 'center';\n      }\n    }\n    if (name == 'chart.noxaxis') {\n      name = 'chart.xaxis';value = !value;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    if (typeof prop['chart.background.image'] === 'string') {\n      RG.DrawBackgroundImage(this);\n    }\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.hasTooltips = false;var overHotspot = false;this.coords = [];if (typeof prop['chart.xmin'] == 'string') prop['chart.xmin'] = RG.parseDate(prop['chart.xmin']);if (typeof prop['chart.xmax'] == 'string') prop['chart.xmax'] = RG.parseDate(prop['chart.xmax']);if (!RGraph.ISOLD) {\n      this.Set('chart.tooltips', []);for (var i = 0, len = this.data.length; i < len; i += 1) {\n        for (var j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (this.data[i][j] && this.data[i][j][3]) {\n            prop['chart.tooltips'].push(this.data[i][j][3]);this.hasTooltips = true;\n          } else {\n            prop['chart.tooltips'].push(null);\n          }\n        }\n      }\n    }\n    this.max = 0;if (typeof prop['chart.ymax'] === 'number') {\n      this.max = prop['chart.ymax'];this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;var decimals = prop['chart.scale.decimals'];\n    } else {\n      var i = 0;var j = 0;for (i = 0, len = this.data.length; i < len; i += 1) {\n        for (j = 0, len2 = this.data[i].length; j < len2; j += 1) {\n          if (!RG.isNull(this.data[i][j]) && this.data[i][j][1] != null) {\n            this.max = Math.max(this.max, _typeof(this.data[i][j][1]) == 'object' ? RG.array_max(this.data[i][j][1]) : Math.abs(this.data[i][j][1]));\n          }\n        }\n      }\n      this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.ylabels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.max = this.scale2.max;this.min = this.scale2.min;\n    }\n    this.grapharea = ca.height - this.gutterTop - this.gutterBottom;RG.background.Draw(this);if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length) {\n      RG.DrawBars(this);\n    }\n    if (prop['chart.background.vbars'] && prop['chart.background.vbars'].length) {\n      this.DrawVBars();\n    }\n    if (!prop['chart.noaxes']) {\n      this.DrawAxes();\n    }\n    this.DrawLabels();if (prop['chart.animation.trace']) {\n      co.save();co.beginPath();co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);co.clip();\n    }\n    for (i = 0; i < this.data.length; ++i) {\n      this.DrawMarks(i);co.shadowColor = prop['chart.line.shadow.color'];co.shadowOffsetX = prop['chart.line.shadow.offsetx'];co.shadowOffsetY = prop['chart.line.shadow.offsety'];co.shadowBlur = prop['chart.line.shadow.blur'];this.DrawLine(i);RG.NoShadow(this);\n    }\n    if (prop['chart.line']) {\n      for (var i = 0, len = this.data.length; i < len; i += 1) {\n        this.DrawMarks(i);\n      }\n    }\n    if (prop['chart.animation.trace']) {\n      co.restore();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.line.colors']);\n    }\n    if (prop['chart.labels.above']) {\n      this.DrawAboveLabels();\n    }\n    this.DrawInGraphLabels(this);if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };\n  this.drawAxes = this.DrawAxes = function () {\n    var graphHeight = ca.height - this.gutterTop - this.gutterBottom;co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = (prop['chart.axis.linewidth'] || 1) + 0.001;if (prop['chart.noyaxis'] == false) {\n      if (prop['chart.yaxispos'] == 'left') {\n        co.moveTo(this.gutterLeft, this.gutterTop);co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\n      } else {\n        co.moveTo(ca.width - this.gutterRight, this.gutterTop);co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\n      }\n    }\n    if (prop['chart.xaxis']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));co.lineTo(ca.width - this.gutterRight, ma.round(this.gutterTop + (ca.height - this.gutterTop - this.gutterBottom) / 2));\n      } else {\n        var y = this.getYCoord(this.scale2.min > 0 ? this.scale2.min : 0);co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    if (prop['chart.noyaxis'] === false) {\n      var numyticks = prop['chart.numyticks'];for (i = 0; i < numyticks; ++i) {\n        var y = (ca.height - this.gutterTop - this.gutterBottom) / numyticks * i;y = y + this.gutterTop;if (prop['chart.xaxispos'] == 'center' && i == numyticks / 2) {\n          continue;\n        }\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, Math.round(y));co.lineTo(ca.width - this.gutterRight, Math.round(y));\n        }\n      }\n      if (prop['chart.numyticks'] > 0) {\n        if (prop['chart.xaxispos'] == 'center' && prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n        } else if (prop['chart.xaxispos'] == 'center') {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));\n        }\n      }\n      if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'left') {\n        co.moveTo(this.gutterLeft, ma.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft - 3, ma.round(ca.height - this.gutterBottom));\n      } else if (prop['chart.xaxis'] === false && prop['chart.yaxispos'] === 'right') {\n        co.moveTo(ca.width - this.gutterRight, ma.round(ca.height - this.gutterBottom));co.lineTo(ca.width - this.gutterRight + 3, ma.round(ca.height - this.gutterBottom));\n      }\n      if (prop['chart.xaxispos'] === 'bottom' && prop['chart.numyticks'] > 0) {\n        if (prop['chart.yaxispos'] == 'left') {\n          co.moveTo(this.gutterLeft, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(this.gutterLeft - 3, ma.round(this.getYCoord(prop['chart.ymin'])));\n        } else {\n          co.moveTo(ca.width - this.gutterRight + 3, ma.round(this.getYCoord(prop['chart.ymin'])));co.lineTo(ca.width - this.gutterRight, ma.round(this.getYCoord(prop['chart.ymin'])));\n        }\n      }\n    }\n    if (prop['chart.numxticks'] > 0 && prop['chart.xaxis']) {\n      var x = 0,\n          y = this.getYCoord(prop['chart.ylabels.invert'] ? this.scale2.max : this.scale2.max > 0 && this.scale2.min > 0 ? this.scale2.min : 0) - 3,\n          size = 3;if (prop['chart.ymin'] === 0 && prop['chart.xaxispos'] === 'bottom') {\n        y += 3;\n      }\n      if (this.scale2.max > 0 && this.scale2.min > 0) {\n        y += 3;\n      }\n      this.xTickGap = prop['chart.labels'] && prop['chart.labels'].length ? (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length : (ca.width - this.gutterLeft - this.gutterRight) / 10;if (typeof prop['chart.numxticks'] == 'number') {\n        this.xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\n      }\n      for (x = this.gutterLeft + (prop['chart.yaxispos'] == 'left' && prop['chart.noyaxis'] == false ? this.xTickGap : 0); x <= ca.width - this.gutterRight - (prop['chart.yaxispos'] == 'left' || prop['chart.noyaxis'] == true ? -1 : 1); x += this.xTickGap) {\n        if (prop['chart.yaxispos'] == 'left' && prop['chart.noendxtick'] == true && x == ca.width - this.gutterRight) {\n          continue;\n        } else if (prop['chart.yaxispos'] == 'right' && prop['chart.noendxtick'] == true && x == this.gutterLeft) {\n          continue;\n        }\n        co.moveTo(ma.round(x), y);co.lineTo(ma.round(x), y + (prop['chart.xaxispos'] === 'center' || prop['chart.ymin'] < 0 ? size * 2 : size));\n      }\n    }\n    co.stroke();co.lineWidth = 1;\n  };this.drawLabels = this.DrawLabels = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        xMin = prop['chart.xmin'],\n        xMax = prop['chart.xmax'],\n        yMax = this.scale2.max,\n        yMin = prop['chart.ymin'] ? prop['chart.ymin'] : 0,\n        text_size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        numYLabels = prop['chart.ylabels.count'],\n        invert = prop['chart.ylabels.invert'],\n        inside = prop['chart.ylabels.inside'],\n        context = co,\n        canvas = ca,\n        boxed = false,\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];\n    this.halfTextHeight = text_size / 2;this.halfGraphHeight = (ca.height - this.gutterTop - this.gutterBottom) / 2;if (prop['chart.ylabels']) {\n      var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n        if (prop['chart.yaxispos'] == 'left') {\n          xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n        } else {\n          xPos = ca.width - prop['chart.gutter.right'] - 5;align = 'right';boxed = true;\n        }\n      }\n      if (prop['chart.xaxispos'] == 'center') {\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific'] != null && prop['chart.ylabels.specific'].length) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 0) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0; i < labels.length; ++i) {\n            var y = this.gutterTop + i * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          var reversed_labels = RG.array_reverse(labels);for (var i = 0; i < reversed_labels.length; ++i) {\n            var y = this.gutterTop + this.grapharea / 2 + (i + 1) * (this.grapharea / (labels.length * 2));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': reversed_labels[i], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n          if (prop['chart.ymin'] != 0) {\n            RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.grapharea / 2 + this.gutterTop + offsety, 'text': prop['chart.ylabels.specific'][prop['chart.ylabels.specific'].length - 1], 'valign': 'center', 'halign': align, 'bounding': boxed, 'tag': 'labels.specific' });\n          }\n        }\n        if (!prop['chart.ylabels.specific'] && typeof numYLabels == 'number') {\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n            } else {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[this.scale2.labels.length - (i + 1)], 'tag': 'scale' });\n            }\n          }\n          for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n            if (!invert) {\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - i / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[len - (i + 1)], 'tag': 'scale' });\n            } else {\n              if (i == len - 1 && invert) {\n                continue;\n              }\n              RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight + this.halfGraphHeight - (i + 1) / numYLabels * this.halfGraphHeight + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + this.scale2.labels[i], 'tag': 'scale' });\n            }\n          }\n          if (!invert && (yMin > 0 || prop['chart.scale.zerostart'])) {\n            RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: this.gutterTop + this.halfGraphHeight + offsety, valign: 'center', halign: align, bounding: boxed, boundingFill: 'white', text: RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n          }\n          if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.number_format(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.halfGraphHeight * 2 + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': '-' + RG.numberFormat(this, yMin.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      } else {\n        var xPos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;var align = prop['chart.yaxispos'] == 'right' ? 'left' : 'right';if (inside) {\n          if (prop['chart.yaxispos'] == 'left') {\n            xPos = prop['chart.gutter.left'] + 5;align = 'left';boxed = true;\n          } else {\n            xPos = ca.width - this.gutterRight - 5;align = 'right';boxed = true;\n          }\n        }\n        if (_typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {\n          var labels = prop['chart.ylabels.specific'];if (prop['chart.ymin'] > 9999) {\n            labels = [];for (var i = 0; i < prop['chart.ylabels.specific'].length - 1; ++i) {\n              labels.push(prop['chart.ylabels.specific'][i]);\n            }\n          }\n          for (var i = 0, len = labels.length; i < len; i += 1) {\n            var y = this.gutterTop + i * (this.grapharea / (len - 1));RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': y + offsety, 'text': labels[i], 'halign': align, 'valign': 'center', 'bounding': boxed, 'tag': 'scale' });\n          }\n        } else {\n          if (typeof numYLabels == 'number') {\n            if (invert) {\n              for (var i = 0; i < numYLabels; ++i) {\n                var interval = (ca.height - this.gutterTop - this.gutterBottom) / numYLabels;RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + (i + 1) * interval + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && !prop['chart.ymin']) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, this.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n              }\n            } else {\n              for (var i = 0, len = this.scale2.labels.length; i < len; i += 1) {\n                RG.Text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + this.grapharea - (i + 1) / this.scale2.labels.length * this.grapharea + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': this.scale2.labels[i], 'tag': 'scale' });\n              }\n              if (!prop['chart.xaxis'] && prop['chart.ymin'] == 0) {\n                RG.text2(this, { font: font, size: text_size, x: xPos + offsetx, y: ca.height - this.gutterBottom + offsety, valign: 'center', halign: align, boundin: boxed, boundingFill: 'white', text: RG.numberFormat(this, 0 .toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), tag: 'scale' });\n              }\n            }\n          }\n          if ((prop['chart.ymin'] || prop['chart.scale.zerostart']) && !invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': ca.height - this.gutterBottom + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          } else if (invert) {\n            RG.text2(this, { 'font': font, 'size': text_size, 'x': xPos + offsetx, 'y': this.gutterTop + offsety, 'valign': 'center', 'halign': align, 'bounding': boxed, 'boundingFill': 'white', 'text': RG.numberFormat(this, prop['chart.ymin'].toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post), 'tag': 'scale' });\n          }\n        }\n      }\n    }\n    if (prop['chart.xscale']) {\n      var numXLabels = prop['chart.xscale.numlabels'],\n          y = ca.height - this.gutterBottom + 5 + text_size / 2,\n          units_pre_x = prop['chart.xscale.units.pre'],\n          units_post_x = prop['chart.xscale.units.post'],\n          decimals = prop['chart.xscale.decimals'],\n          point = prop['chart.xscale.point'],\n          thousand = prop['chart.xscale.thousand'],\n          color = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      if (!prop['chart.xmax']) {\n        var xmax = 0;var xmin = prop['chart.xmin'];for (var ds = 0, len = this.data.length; ds < len; ds += 1) {\n          for (var point = 0, len2 = this.data[ds].length; point < len2; point += 1) {\n            xmax = Math.max(xmax, this.data[ds][point][0]);\n          }\n        }\n      } else {\n        xmax = prop['chart.xmax'];xmin = prop['chart.xmin'];\n      }\n      this.xscale2 = RG.getScale2(this, { 'max': xmax, 'min': xmin, 'scale.decimals': decimals, 'scale.point': point, 'scale.thousand': thousand, 'units.pre': units_pre_x, 'units.post': units_post_x, 'ylabels.count': numXLabels, 'strict': true });this.Set('chart.xmax', this.xscale2.max);var interval = (ca.width - this.gutterLeft - this.gutterRight) / this.xscale2.labels.length;for (var i = 0, len = this.xscale2.labels.length; i < len; i += 1) {\n        var num = (prop['chart.xmax'] - prop['chart.xmin']) * ((i + 1) / numXLabels) + (xmin || 0),\n            x = this.gutterLeft + (i + 1) * interval,\n            text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, num)) : this.xscale2.labels[i];RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': x + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n      }\n      var text = typeof prop['chart.xscale.formatter'] === 'function' ? String(prop['chart.xscale.formatter'](this, prop['chart.xmin'])) : String(prop['chart.xmin']);RG.text2(this, { 'color': color, 'font': font, 'size': text_size, 'bold': bold, 'x': this.gutterLeft + offsetx, 'y': y + offsety, 'valign': 'center', 'halign': 'center', 'text': text, 'tag': 'xscale' });\n    } else {\n      var graphArea = ca.width - this.gutterLeft - this.gutterRight;var xInterval = graphArea / prop['chart.labels'].length;var xPos = this.gutterLeft;var yPos = ca.height - this.gutterBottom + 3;var labels = prop['chart.labels'];var color = prop['chart.labels.color'];var bold = prop['chart.labels.bold'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];var angle = 0;var valign = 'top';var halign = 'center';if (prop['chart.text.angle'] > 0) {\n        angle = -1 * prop['chart.text.angle'];valign = 'center';halign = 'right';yPos += 10;\n      }\n      for (i = 0; i < labels.length; ++i) {\n        if (_typeof(labels[i]) == 'object') {\n          if (prop['chart.labels.specific.align'] == 'center') {\n            var rightEdge = 0;if (labels[i + 1] && labels[i + 1][1]) {\n              rightEdge = labels[i + 1][1];\n            } else {\n              rightEdge = prop['chart.xmax'];\n            }\n            var offset = (this.getXCoord(rightEdge) - this.getXCoord(labels[i][1])) / 2;\n          } else {\n            var offset = 5;\n          }\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': this.getXCoord(labels[i][1]) + offset + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': angle != 0 ? 'right' : prop['chart.labels.specific.align'] == 'center' ? 'center' : 'left', 'text': String(labels[i][0]), 'angle': angle, 'marker': false, 'tag': 'labels.specific' });co.beginPath();co.strokeStyle = '#bbb';co.moveTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom);co.lineTo(ma.round(this.gutterLeft + graphArea * ((labels[i][1] - xMin) / (prop['chart.xmax'] - xMin))), ca.height - this.gutterBottom + 20);co.stroke();\n        } else {\n          RG.text2(this, { 'color': color, 'font': font, 'size': prop['chart.text.size'], 'bold': bold, 'x': xPos + xInterval / 2 + offsetx, 'y': yPos + offsety, 'valign': valign, 'halign': halign, 'text': String(labels[i]), 'angle': angle, 'tag': 'labels' });\n        }\n        xPos += xInterval;\n      }\n      if (_typeof(labels[0]) == 'object') {\n        co.beginPath();co.strokeStyle = '#bbb';co.moveTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom);co.lineTo(this.gutterLeft + graphArea, ca.height - this.gutterBottom + 20);co.stroke();\n      }\n    }\n  };this.drawMarks = this.DrawMarks = function (i) {\n    this.coords[i] = [];var xmax = prop['chart.xmax'];var default_color = prop['chart.defaultcolor'];for (var j = 0, len = this.data[i].length; j < len; j += 1) {\n      var data_points = this.data[i];if (RG.isNull(data_points[j])) {\n        continue;\n      }\n      var xCoord = data_points[j][0];var yCoord = data_points[j][1];var color = data_points[j][2] ? data_points[j][2] : default_color;var tooltip = data_points[j] && data_points[j][3] ? data_points[j][3] : null;this.DrawMark(i, xCoord, yCoord, xmax, this.scale2.max, color, tooltip, this.coords[i], data_points, j);\n    }\n  };this.drawMark = this.DrawMark = function (data_set_index, x, y, xMax, yMax, color, tooltip, coords, data, data_index) {\n    var tickmarks = prop['chart.tickmarks'],\n        tickSize = prop['chart.ticksize'],\n        xMin = prop['chart.xmin'],\n        x = (x - xMin) / (xMax - xMin) * (ca.width - this.gutterLeft - this.gutterRight),\n        originalX = x,\n        originalY = y;if (tickmarks && (typeof tickmarks === 'undefined' ? 'undefined' : _typeof(tickmarks)) == 'object') {\n      tickmarks = tickmarks[data_set_index];\n    }\n    if ((typeof tickSize === 'undefined' ? 'undefined' : _typeof(tickSize)) == 'object') {\n      var tickSize = tickSize[data_set_index];var halfTickSize = tickSize / 2;\n    } else {\n      var halfTickSize = tickSize / 2;\n    }\n    if (y && (typeof y === 'undefined' ? 'undefined' : _typeof(y)) === 'object' && typeof y[0] === 'number' && typeof y[1] === 'number' && typeof y[2] === 'number' && typeof y[3] === 'number' && typeof y[4] === 'number') {\n      this.Set('chart.boxplot', true);var y0 = this.getYCoord(y[0]),\n          y1 = this.getYCoord(y[1]),\n          y2 = this.getYCoord(y[2]),\n          y3 = this.getYCoord(y[3]),\n          y4 = this.getYCoord(y[4]),\n          col1 = y[5],\n          col2 = y[6],\n          boxWidth = typeof y[7] == 'number' ? y[7] : prop['chart.boxplot.width'];\n    } else {\n      var yCoord = this.getYCoord(y);\n    }\n    x += this.gutterLeft;co.beginPath();co.strokeStyle = color;if (prop['chart.boxplot']) {\n      boxWidth = boxWidth / prop['chart.xmax'] * (ca.width - this.gutterLeft - this.gutterRight);var halfBoxWidth = boxWidth / 2;if (prop['chart.line.visible']) {\n        co.beginPath();if (typeof y[8] === 'string') {\n          co.strokeStyle = y[8];\n        }\n        co.strokeRect(x - halfBoxWidth, y1, boxWidth, y3 - y1);if (col1) {\n          co.fillStyle = col1;co.fillRect(x - halfBoxWidth, y1, boxWidth, y2 - y1);\n        }\n        if (col2) {\n          co.fillStyle = col2;co.fillRect(x - halfBoxWidth, y2, boxWidth, y3 - y2);\n        }\n        co.stroke();co.beginPath();if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y0));co.lineTo(x + halfBoxWidth, ma.round(y0));\n        }\n        co.moveTo(ma.round(x), y0);co.lineTo(ma.round(x), y1);if (prop['chart.boxplot.capped']) {\n          co.moveTo(x - halfBoxWidth, ma.round(y4));co.lineTo(x + halfBoxWidth, ma.round(y4));\n        }\n        co.moveTo(ma.round(x), y4);co.lineTo(ma.round(x), y3);co.stroke();\n      }\n    }\n    if (prop['chart.line.visible'] && typeof y == 'number' && !y0 && !y1 && !y2 && !y3 && !y4) {\n      if (tickmarks == 'circle') {\n        co.arc(x, yCoord, halfTickSize, 0, 6.28, 0);co.fillStyle = color;co.fill();\n      } else if (tickmarks == 'plus') {\n        co.moveTo(x, yCoord - halfTickSize);co.lineTo(x, yCoord + halfTickSize);co.moveTo(x - halfTickSize, yCoord);co.lineTo(x + halfTickSize, yCoord);co.stroke();\n      } else if (tickmarks == 'square') {\n        co.strokeStyle = color;co.fillStyle = color;co.fillRect(x - halfTickSize, yCoord - halfTickSize, tickSize, tickSize);\n      } else if (tickmarks == 'cross') {\n        co.moveTo(x - halfTickSize, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord + halfTickSize);co.moveTo(x + halfTickSize, yCoord - halfTickSize);co.lineTo(x - halfTickSize, yCoord + halfTickSize);co.stroke();\n      } else if (tickmarks == 'diamond') {\n        co.fillStyle = co.strokeStyle;co.moveTo(x, yCoord - halfTickSize);co.lineTo(x + halfTickSize, yCoord);co.lineTo(x, yCoord + halfTickSize);co.lineTo(x - halfTickSize, yCoord);co.lineTo(x, yCoord - halfTickSize);co.fill();co.stroke();\n      } else if (typeof tickmarks == 'function') {\n        var graphWidth = ca.width - this.gutterLeft - this.gutterRight,\n            graphheight = ca.height - this.gutterTop - this.gutterBottom,\n            xVal = (x - this.gutterLeft) / graphWidth * xMax,\n            yVal = (graphheight - (yCoord - this.gutterTop)) / graphheight * yMax;tickmarks(this, data, x, yCoord, xVal, yVal, xMax, yMax, color, data_set_index, data_index);\n      } else if (typeof tickmarks === 'string' && (tickmarks.substr(0, 6) === 'image:' || tickmarks.substr(0, 5) === 'data:' || tickmarks.substr(0, 1) === '/' || tickmarks.substr(0, 3) === '../' || tickmarks.substr(0, 7) === 'images/')) {\n        var img = new Image();if (tickmarks.substr(0, 6) === 'image:') {\n          img.src = tickmarks.substr(6);\n        } else {\n          img.src = tickmarks;\n        }\n        img.onload = function () {\n          if (prop['chart.tickmarks.image.halign'] === 'center') x -= this.width / 2;if (prop['chart.tickmarks.image.halign'] === 'right') x -= this.width;if (prop['chart.tickmarks.image.valign'] === 'center') yCoord -= this.height / 2;if (prop['chart.tickmarks.image.valign'] === 'bottom') yCoord -= this.height;x += prop['chart.tickmarks.image.offsetx'];yCoord += prop['chart.tickmarks.image.offsety'];co.drawImage(this, x, yCoord);\n        };\n      } else if (tickmarks === null) {} else {\n        alert('[SCATTER] (' + this.id + ') Unknown tickmark style: ' + tickmarks);\n      }\n    }\n    if (prop['chart.boxplot'] && typeof y0 === 'number' && typeof y1 === 'number' && typeof y2 === 'number' && typeof y3 === 'number' && typeof y4 === 'number') {\n      x = [x - halfBoxWidth, x + halfBoxWidth];yCoord = [y0, y1, y2, y3, y4];\n    }\n    coords.push([x, yCoord, tooltip]);\n  };this.drawLine = this.DrawLine = function (i) {\n    if (typeof prop['chart.line.visible'] == 'boolean' && prop['chart.line.visible'] == false) {\n      return;\n    }\n    if (prop['chart.line'] && this.coords[i].length >= 2) {\n      if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash(prop['chart.line.dash']);\n      }\n      co.lineCap = 'round';co.lineJoin = 'round';co.lineWidth = this.getLineWidth(i);co.strokeStyle = prop['chart.line.colors'][i];co.beginPath();var prevY = null;var currY = null;for (var j = 0, len = this.coords[i].length; j < len; j += 1) {\n        var xPos = this.coords[i][j][0];var yPos = this.coords[i][j][1];if (j > 0) prevY = this.coords[i][j - 1][1];currY = yPos;if (j == 0 || RG.is_null(prevY) || RG.is_null(currY)) {\n          co.moveTo(xPos, yPos);\n        } else {\n          var stepped = prop['chart.line.stepped'];if (typeof stepped == 'boolean' && stepped || (typeof stepped === 'undefined' ? 'undefined' : _typeof(stepped)) == 'object' && stepped[i]) {\n            co.lineTo(this.coords[i][j][0], this.coords[i][j - 1][1]);\n          }\n          co.lineTo(xPos, yPos);\n        }\n      }\n      co.stroke();if (prop['chart.line.dash'] && typeof co.setLineDash === 'function') {\n        co.setLineDash([1, 0]);\n      }\n    }\n    co.lineWidth = 1;\n  };this.getLineWidth = this.GetLineWidth = function (i) {\n    var linewidth = prop['chart.line.linewidth'];if (typeof linewidth == 'number') {\n      return linewidth;\n    } else if ((typeof linewidth === 'undefined' ? 'undefined' : _typeof(linewidth)) == 'object') {\n      if (linewidth[i]) {\n        return linewidth[i];\n      } else {\n        return linewidth[0];\n      }\n      alert('[SCATTER] Error! chart.linewidth should be a single number or an array of one or more numbers');\n    }\n  };this.drawVBars = this.DrawVBars = function () {\n    var vbars = prop['chart.background.vbars'];var graphWidth = ca.width - this.gutterLeft - this.gutterRight;if (vbars) {\n      var xmax = prop['chart.xmax'];var xmin = prop['chart.xmin'];for (var i = 0, len = vbars.length; i < len; i += 1) {\n        var key = i;var value = vbars[key];if (typeof value[0] == 'string') value[0] = RG.parseDate(value[0]);if (typeof value[1] == 'string') value[1] = RG.parseDate(value[1]) - value[0];var x = (value[0] - xmin) / (xmax - xmin) * graphWidth + this.gutterLeft;var width = value[1] / (xmax - xmin) * graphWidth;co.fillStyle = value[2];co.fillRect(x, this.gutterTop, width, ca.height - this.gutterTop - this.gutterBottom);\n      }\n    }\n  };this.drawInGraphLabels = this.DrawInGraphLabels = function (obj) {\n    var labels = obj.Get('chart.labels.ingraph');var labels_processed = [];if (!labels) {\n      return;\n    }\n    var fgcolor = 'black';var bgcolor = 'white';var direction = 1;for (var i = 0, len = labels.length; i < len; i += 1) {\n      if (typeof labels[i] == 'number') {\n        for (var j = 0; j < labels[i]; ++j) {\n          labels_processed.push(null);\n        }\n      } else if (typeof labels[i] == 'string' || _typeof(labels[i]) == 'object') {\n        labels_processed.push(labels[i]);\n      } else {\n        labels_processed.push('');\n      }\n    }\n    RG.NoShadow(obj);if (labels_processed && labels_processed.length > 0) {\n      var i = 0;for (var set = 0; set < obj.coords.length; ++set) {\n        for (var point = 0; point < obj.coords[set].length; ++point) {\n          if (labels_processed[i]) {\n            var x = obj.coords[set][point][0];var y = obj.coords[set][point][1];var length = typeof labels_processed[i][4] == 'number' ? labels_processed[i][4] : 25;var text_x = x;var text_y = y - 5 - length;co.moveTo(x, y - 5);co.lineTo(x, y - 5 - length);co.stroke();co.beginPath();co.moveTo(x, y - 5);co.lineTo(x - 3, y - 10);co.lineTo(x + 3, y - 10);co.closePath();co.beginPath();co.fillStyle = _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][1] == 'string' ? labels_processed[i][1] : 'black';RG.text2(this, { 'font': obj.Get('chart.text.font'), 'size': obj.Get('chart.text.size'), 'x': text_x, 'y': text_y, 'text': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][0] == 'string' ? labels_processed[i][0] : labels_processed[i], 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'bounding.fill': _typeof(labels_processed[i]) == 'object' && typeof labels_processed[i][2] == 'string' ? labels_processed[i][2] : 'white', 'tag': 'labels.ingraph' });co.fill();\n          }\n          i++;\n        }\n      }\n    }\n  };this.getShape = this.getPoint = function (e) {\n    var mouseXY = RG.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];var overHotspot = false;var offset = prop['chart.tooltips.hotspot'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var i = 0, len2 = this.coords[set].length; i < len2; ++i) {\n        var x = this.coords[set][i][0];var y = this.coords[set][i][1];var tooltip = this.data[set][i][3];if (typeof y == 'number') {\n          if (mouseX <= x + offset && mouseX >= x - offset && mouseY <= y + offset && mouseY >= y - offset) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);var index_adjusted = i;for (var ds = set - 1; ds >= 0; --ds) {\n              index_adjusted += this.data[ds].length;\n            }\n            return { 0: this, 1: x, 2: y, 3: set, 4: i, 5: this.data[set][i][3], 'object': this, 'x': x, 'y': y, 'dataset': set, 'index': i, 'tooltip': tooltip, 'index_adjusted': index_adjusted };\n          }\n        } else if (RG.is_null(y)) {} else {\n          var mark = this.data[set][i];var width = prop['chart.boxplot.width'];if (typeof mark[1][7] == 'number') {\n            width = mark[1][7];\n          }\n          if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) == 'object' && mouseX > x[0] && mouseX < x[1] && mouseY < y[1] && mouseY > y[3]) {\n            var tooltip = RG.parseTooltipText(this.data[set][i][3], 0);return { 0: this, 1: x[0], 2: x[1] - x[0], 3: y[1], 4: y[3] - y[1], 5: set, 6: i, 7: this.data[set][i][3], 'object': this, 'x': x[0], 'y': y[1], 'width': x[1] - x[0], 'height': y[3] - y[1], 'dataset': set, 'index': i, 'tooltip': tooltip };\n          }\n        }\n      }\n    }\n  };this.drawAboveLabels = this.DrawAboveLabels = function () {\n    var size = prop['chart.labels.above.size'];var font = prop['chart.text.font'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];for (var set = 0, len = this.coords.length; set < len; ++set) {\n      for (var point = 0, len2 = this.coords[set].length; point < len2; ++point) {\n        var x_val = this.data[set][point][0];var y_val = this.data[set][point][1];if (!RG.is_null(y_val)) {\n          if (RG.is_array(y_val)) {\n            var max = 0;for (var i = 0; i < y_val; ++i) {\n              max = Math.max(max, y_val[i]);\n            }\n            y_val = max;\n          }\n          var x_pos = this.coords[set][point][0];var y_pos = this.coords[set][point][1];RG.Text2(this, { 'font': font, 'size': size, 'x': x_pos, 'y': y_pos - 5 - size, 'text': x_val.toFixed(prop['chart.labels.above.decimals']) + ', ' + y_val.toFixed(prop['chart.labels.above.decimals']), 'valign': 'center', 'halign': 'center', 'bounding': true, 'boundingFill': 'rgba(255, 255, 255, 0.7)', 'tag': 'labels.above' });\n        }\n      }\n    }\n  };this.getYValue = this.getValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseCoords = RG.getMouseXY(arg);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    if (prop['chart.xaxispos'] == 'center') {\n      var value = (this.grapharea / 2 - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value *= 2;if (value >= 0) {\n        value += this.min;\n        if (prop['chart.ylabels.invert']) {\n          value -= this.min;value = this.max - value;\n        }\n      } else {\n        value -= this.min;if (prop['chart.ylabels.invert']) {\n          value += this.min;value = this.max + value;value *= -1;\n        }\n      }\n    } else {\n      var value = (this.grapharea - (mouseY - this.gutterTop)) / this.grapharea * (this.max - this.min);\n      value += this.min;if (prop['chart.ylabels.invert']) {\n        value -= this.min;value = this.max - value;\n      }\n    }\n    return value;\n  };this.getXValue = function (arg) {\n    if (arg.length == 2) {\n      var mouseX = arg[0];var mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg);var mouseX = mouseXY[0];var mouseY = mouseXY[1];\n    }\n    var obj = this;if (mouseY < this.gutterTop || mouseY > ca.height - this.gutterBottom || mouseX < this.gutterLeft || mouseX > ca.width - this.gutterRight) {\n      return null;\n    }\n    var width = ca.width - this.gutterLeft - this.gutterRight;var value = (mouseX - this.gutterLeft) / width * (prop['chart.xmax'] - prop['chart.xmin']);\n    value += prop['chart.xmin'];return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      if (shape['height']) {\n        RG.Highlight.Rect(this, shape);\n      } else {\n        RG.Highlight.Point(this, shape);\n      }\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft - 3 && mouseXY[0] < ca.width - this.gutterRight + 3 && mouseXY[1] > this.gutterTop - 3 && mouseXY[1] < ca.height - this.gutterBottom + 3) {\n      return this;\n    }\n  };this.getXCoord = function (value) {\n    if (typeof value != 'number' && typeof value != 'string') {\n      return null;\n    }\n    if (typeof value === 'string') {\n      value = RG.parseDate(value);\n    }\n    var xmin = prop['chart.xmin'];var xmax = prop['chart.xmax'];var x;if (value < xmin) return null;if (value > xmax) return null;var gutterRight = this.gutterRight;var gutterLeft = this.gutterLeft;if (prop['chart.yaxispos'] == 'right') {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = ca.width - gutterRight - x;\n    } else {\n      x = (value - xmin) / (xmax - xmin) * (ca.width - gutterLeft - gutterRight);x = x + gutterLeft;\n    }\n    return x;\n  };this.getYCoord = this.getYCoordFromValue = function (value) {\n    if (typeof value != 'number') {\n      return null;\n    }\n    var invert = prop['chart.ylabels.invert'];var xaxispos = prop['chart.xaxispos'];var graphHeight = ca.height - this.gutterTop - this.gutterBottom;var halfGraphHeight = graphHeight / 2;var ymax = this.max;var ymin = prop['chart.ymin'];var coord = 0;if (value > ymax || prop['chart.xaxispos'] == 'bottom' && value < ymin || prop['chart.xaxispos'] == 'center' && (value > 0 && value < ymin || value < 0 && value > -1 * ymin)) {\n      return null;\n    }\n    if (xaxispos == 'center') {\n      coord = (Math.abs(value) - ymin) / (ymax - ymin) * halfGraphHeight;if (invert) {\n        coord = halfGraphHeight - coord;\n      }\n      if (value < 0) {\n        coord += this.gutterTop;coord += halfGraphHeight;\n      } else {\n        coord = halfGraphHeight - coord;coord += this.gutterTop;\n      }\n    } else {\n      coord = (value - ymin) / (ymax - ymin) * graphHeight;if (invert) {\n        coord = graphHeight - coord;\n      }\n      coord = graphHeight - coord;coord = this.gutterTop + coord;\n    }\n    return coord;\n  };RG.Scatter.Bubble = function (scatter, min, max, width, data) {\n    this.scatter = scatter;this.min = min;this.max = max;this.width = width;this.data = data;this.coords = [];this.type = 'scatter.bubble';\n    this.set = this.Set = function (name, value) {\n      this.scatter.set(name, value);return this;\n    };this.get = this.Get = function (name) {\n      this.scatter.get(name);\n    };this.draw = this.Draw = function () {\n      var bubble_min = this.min,\n          bubble_max = this.max,\n          bubble_data = this.data,\n          bubble_max_width = this.width;var obj_bubble = this,\n          obj_scatter = this.scatter;this.scatter.ondraw = function (obj) {\n        for (var i = 0; i < obj.coords[0].length; ++i) {\n          bubble_data[i] = ma.max(bubble_data[i], bubble_min);bubble_data[i] = ma.min(bubble_data[i], bubble_max);var r = (bubble_data[i] - bubble_min) / (bubble_max - bubble_min) * bubble_max_width,\n              color = obj_scatter.data[0][i][2] ? obj_scatter.data[0][i][2] : obj_scatter.properties['chart.defaultcolor'];co.beginPath();co.fillStyle = RG.radialGradient(obj, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, 0, obj_scatter.coords[0][i][0] + r / 2.5, obj_scatter.coords[0][i][1] - r / 2.5, r, prop['chart.colors.bubble.graduated'] ? 'white' : color, color);co.arc(obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, 0, RG.TWOPI, false);co.fill();obj_bubble.coords[i] = [obj_scatter.coords[0][i][0], obj_scatter.coords[0][i][1], r, co.fillStyle];\n        }\n      };\n      this.scatter.Draw();return this;\n    };\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['data'] = RG.array_clone(this.data);this.original_colors['chart.background.vbars'] = RG.array_clone(prop['chart.background.vbars']);this.original_colors['chart.background.hbars'] = RG.array_clone(prop['chart.background.hbars']);this.original_colors['chart.line.colors'] = RG.array_clone(prop['chart.line.colors']);this.original_colors['chart.defaultcolor'] = RG.array_clone(prop['chart.defaultcolor']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var data = this.data;if (data) {\n      for (var dataset = 0; dataset < data.length; ++dataset) {\n        for (var i = 0; i < this.data[dataset].length; ++i) {\n          if (this.data[dataset][i] && _typeof(this.data[dataset][i][1]) == 'object' && this.data[dataset][i][1]) {\n            if (typeof this.data[dataset][i][1][5] == 'string') this.data[dataset][i][1][5] = this.parseSingleColorForGradient(this.data[dataset][i][1][5]);if (typeof this.data[dataset][i][1][6] == 'string') this.data[dataset][i][1][6] = this.parseSingleColorForGradient(this.data[dataset][i][1][6]);\n          }\n          if (!RG.isNull(this.data[dataset][i])) {\n            this.data[dataset][i][2] = this.parseSingleColorForGradient(this.data[dataset][i][2]);\n          }\n        }\n      }\n    }\n    var hbars = prop['chart.background.hbars'];if (hbars) {\n      for (i = 0; i < hbars.length; ++i) {\n        hbars[i][2] = this.parseSingleColorForGradient(hbars[i][2]);\n      }\n    }\n    var vbars = prop['chart.background.vbars'];if (vbars) {\n      for (i = 0; i < vbars.length; ++i) {\n        vbars[i][2] = this.parseSingleColorForGradient(vbars[i][2]);\n      }\n    }\n    var colors = prop['chart.line.colors'];if (colors) {\n      for (i = 0; i < colors.length; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.defaultcolor'] = this.parseSingleColorForGradient(prop['chart.defaultcolor']);prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.interactiveKeyHighlight = function (index) {\n    if (this.coords && this.coords[index] && this.coords[index].length) {\n      this.coords[index].forEach(function (value, idx, arr) {\n        co.beginPath();co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.arc(value[0], value[1], prop['chart.ticksize'] + 3, 0, RG.TWOPI, false);co.fill();\n      });\n    }\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.trace = this.trace2 = function () {\n    var obj = this,\n        callback = arguments[2],\n        opt = arguments[0] || {},\n        frames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {};\n    obj.Set('animationTrace', true);obj.Set('animationTraceClip', 0);function iterator() {\n      RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame++ < frames) {\n        obj.set('animationTraceClip', frame / frames);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };this.resetColorsToOriginalValues = function () {\n    for (var i = 0, len = this.original_colors['data'].length; i < len; ++i) {\n      for (var j = 0, len2 = this.original_colors['data'][i].length; j < len2; ++j) {\n        this.data[i][j][2] = RG.array_clone(this.original_colors['data'][i][j][2]);if (_typeof(this.data[i][j][1]) === 'object') {\n          this.data[i][j][1][5] = RG.array_clone(this.original_colors['data'][i][j][1][5]);this.data[i][j][1][6] = RG.array_clone(this.original_colors['data'][i][j][1][6]);\n        }\n      }\n    }\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zY2F0dGVyLmpzPzI4OGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguU2NhdHRlciA9IGZ1bmN0aW9uIChjb25mKSB7XG4gIHZhciBfcHJvcGVydGllcztcblxuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO3RoaXMuZGF0YSA9IG5ldyBBcnJheShjb25mLmRhdGEubGVuZ3RoKTt0aGlzLmRhdGEgPSBSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO2lmIChfdHlwZW9mKGNvbmYuZGF0YSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoY29uZi5kYXRhWzBdKSA9PT0gJ29iamVjdCcgJiYgKHR5cGVvZiBjb25mLmRhdGFbMF1bMF0gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb25mLmRhdGFbMF1bMF0gPT09ICdzdHJpbmcnKSkge1xuICAgICAgdmFyIHRtcCA9IFJHcmFwaC5hcnJheUNsb25lKGNvbmYuZGF0YSk7Y29uZi5kYXRhID0gbmV3IEFycmF5KCk7Y29uZi5kYXRhWzBdID0gUkdyYXBoLmFycmF5Q2xvbmUodG1wKTt0aGlzLmRhdGEgPSBSR3JhcGguYXJyYXlDbG9uZShjb25mLmRhdGEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29uZiA9IHsgaWQ6IGNvbmYgfTtjb25mLmRhdGEgPSBhcmd1bWVudHNbMV07dGhpcy5kYXRhID0gW107aWYgKGFyZ3VtZW50c1sxXVswXSAmJiBhcmd1bWVudHNbMV1bMF1bMF0gJiYgX3R5cGVvZihhcmd1bWVudHNbMV1bMF1bMF0pID09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c1sxXS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSBSR3JhcGguYXJyYXlDbG9uZShhcmd1bWVudHNbMV1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRhdGFbaSAtIDFdID0gUkdyYXBoLmFycmF5Q2xvbmUoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFSR3JhcGguaXNBcnJheSh0aGlzLmRhdGFbMF1bMF0pKSB7XG4gICAgdGhpcy5kYXRhID0gW3RoaXMuZGF0YV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gdGhpcy5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraikge1xuICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldW2pdKSA9PT0gJ29iamVjdCcgJiYgIVJHcmFwaC5pc051bGwodGhpcy5kYXRhW2ldW2pdKSAmJiB0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldW2pdWzBdLm1hdGNoKC9eWy4wLTldKyQvKSkge1xuICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXVswXSA9IHBhcnNlRmxvYXQodGhpcy5kYXRhW2ldW2pdWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbaV1bal1bMF0gPT09ICcnKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW2ldW2pdWzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldW2pdKSA9PT0gJ29iamVjdCcgJiYgIVJHcmFwaC5pc051bGwodGhpcy5kYXRhW2ldW2pdKSAmJiB0eXBlb2YgdGhpcy5kYXRhW2ldW2pdWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldW2pdWzFdLm1hdGNoKC9bLjAtOV0rLykpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbaV1bal1bMV0gPSBwYXJzZUZsb2F0KHRoaXMuZGF0YVtpXVtqXVsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhW2ldW2pdWzFdID09PSAnJykge1xuICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXVsxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5pZCA9IGNvbmYuaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0ID8gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGw7dGhpcy5tYXggPSAwO3RoaXMuY29vcmRzID0gW107dGhpcy50eXBlID0gJ3NjYXR0ZXInO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMucHJvcGVydGllcyA9IChfcHJvcGVydGllcyA9IHsgJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLndpZHRoJzogMSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvcic6ICcjZGRkJywgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6IDIwLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZzaXplJzogMjAsICdjaGFydC5iYWNrZ3JvdW5kLmhiYXJzJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZsaW5lcyc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuaGxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5ib3JkZXInOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQuYWxpZ24nOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtaGxpbmVzJzogNSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5hdXRvZml0Lm51bXZsaW5lcyc6IDIwLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZSc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLnN0cmV0Y2gnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS54JzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UueSc6IG51bGwsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlLncnOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5pbWFnZS5oJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaW1hZ2UuYWxpZ24nOiBudWxsLCAnY2hhcnQuYmFja2dyb3VuZC5jb2xvcic6IG51bGwsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuYW5nbGUnOiAwLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC50b29sdGlwcyc6IFtdLCAnY2hhcnQudG9vbHRpcHMuZWZmZWN0JzogJ2ZhZGUnLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25tb3VzZW1vdmUnLCAnY2hhcnQudG9vbHRpcHMuaG90c3BvdCc6IDMsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmNvb3Jkcy5wYWdlJzogZmFsc2UsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0Lm51bXl0aWNrcyc6IDEwLCAnY2hhcnQudGlja21hcmtzJzogJ2Nyb3NzJywgJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5oYWxpZ24nOiAnY2VudGVyJywgJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS52YWxpZ24nOiAnY2VudGVyJywgJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR4JzogMCwgJ2NoYXJ0LnRpY2ttYXJrcy5pbWFnZS5vZmZzZXR5JzogMCwgJ2NoYXJ0LnRpY2tzaXplJzogNSwgJ2NoYXJ0Lm51bXh0aWNrcyc6IHRydWUsICdjaGFydC54YXhpcyc6IHRydWUsICdjaGFydC5ndXR0ZXIubGVmdCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMjUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMzAsICdjaGFydC5jb2xvcnMuYnViYmxlLmdyYWR1YXRlZCc6IHRydWUsICdjaGFydC54bWluJzogMCwgJ2NoYXJ0LnhtYXgnOiAwLCAnY2hhcnQueW1heCc6IG51bGwsICdjaGFydC55bWluJzogMCwgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnNjYWxlLnBvaW50JzogJy4nLCAnY2hhcnQuc2NhbGUudGhvdXNhbmQnOiAnLCcsICdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOiB0cnVlLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQudGl0bGUuaHBvcyc6IG51bGwsICdjaGFydC50aXRsZS52cG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcyc6ICcnLCAnY2hhcnQudGl0bGUueGF4aXMuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS54YXhpcy5zaXplJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMuY29sb3InOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMnOiAnJywgJ2NoYXJ0LnRpdGxlLnlheGlzLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueWF4aXMuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLnBvcyc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5wb3MnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMueCc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnknOiBudWxsLCAnY2hhcnQudGl0bGUuaGFsaWduJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZhbGlnbic6IG51bGwsICdjaGFydC5sYWJlbHMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5ib2xkJzogZmFsc2UsICdjaGFydC5sYWJlbHMuY29sb3InOiBudWxsLCAnY2hhcnQubGFiZWxzLmluZ3JhcGgnOiBudWxsLCAnY2hhcnQubGFiZWxzLmFib3ZlJzogZmFsc2UsICdjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSc6IDgsICdjaGFydC5sYWJlbHMuYWJvdmUuZGVjaW1hbHMnOiAwLCAnY2hhcnQubGFiZWxzLm9mZnNldHgnOiAwLCAnY2hhcnQubGFiZWxzLm9mZnNldHknOiAwLCAnY2hhcnQueWxhYmVscy5vZmZzZXR4JzogMCwgJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSc6IDAsICdjaGFydC55bGFiZWxzJzogdHJ1ZSwgJ2NoYXJ0LnlsYWJlbHMuY291bnQnOiA1LCAnY2hhcnQueWxhYmVscy5pbnZlcnQnOiBmYWxzZSwgJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnOiBudWxsLCAnY2hhcnQueWxhYmVscy5pbnNpZGUnOiBmYWxzZSwgJ2NoYXJ0LmNvbnRleHRtZW51JzogbnVsbCwgJ2NoYXJ0LmRlZmF1bHRjb2xvcic6ICdibGFjaycsICdjaGFydC54YXhpc3Bvcyc6ICdib3R0b20nLCAnY2hhcnQueWF4aXNwb3MnOiAnbGVmdCcsICdjaGFydC5jcm9zc2hhaXJzJzogZmFsc2UsICdjaGFydC5jcm9zc2hhaXJzLmNvbG9yJzogJyMzMzMnLCAnY2hhcnQuY3Jvc3NoYWlycy5saW5ld2lkdGgnOiAxLCAnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMnOiBmYWxzZSwgJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmZpeGVkJzogdHJ1ZSwgJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmZhZGVvdXQnOiBmYWxzZSwgJ2NoYXJ0LmNyb3NzaGFpcnMuY29vcmRzLmxhYmVscy54JzogJ1gnLCAnY2hhcnQuY3Jvc3NoYWlycy5jb29yZHMubGFiZWxzLnknOiAnWScsICdjaGFydC5jcm9zc2hhaXJzLmhsaW5lJzogdHJ1ZSwgJ2NoYXJ0LmNyb3NzaGFpcnMudmxpbmUnOiB0cnVlLCAnY2hhcnQuYW5ub3RhdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmFubm90YXRlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmxpbmUnOiBmYWxzZSwgJ2NoYXJ0LmxpbmUubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmxpbmUuY29sb3JzJzogWydncmVlbicsICdyZWQnXSwgJ2NoYXJ0LmxpbmUuc2hhZG93LmNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQubGluZS5zaGFkb3cuYmx1cic6IDIsICdjaGFydC5saW5lLnNoYWRvdy5vZmZzZXR4JzogMywgJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQubGluZS5zdGVwcGVkJzogZmFsc2UsICdjaGFydC5saW5lLnZpc2libGUnOiB0cnVlLCAnY2hhcnQubm9heGVzJzogZmFsc2UsICdjaGFydC5ub3lheGlzJzogZmFsc2UsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5maWxsJzogJ3JnYmEoMjU1LDAsMCwwLjkpJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOiAncmdiYSgyNTUsMCwwLDAuMiknLCAnY2hhcnQua2V5LmNvbG9yLnNoYXBlJzogJ3NxdWFyZScsICdjaGFydC5rZXkucm91bmRlZCc6IHRydWUsICdjaGFydC5rZXkubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmtleS5jb2xvcnMnOiBudWxsLCAnY2hhcnQua2V5LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuYXhpcy5jb2xvcic6ICdibGFjaycsICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uaGRpcic6ICdyaWdodCcsICdjaGFydC56b29tLnZkaXInOiAnZG93bicsICdjaGFydC56b29tLmZyYW1lcyc6IDI1LCAnY2hhcnQuem9vbS5kZWxheSc6IDE2LjY2NiwgJ2NoYXJ0Lnpvb20uc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6IHRydWUsICdjaGFydC56b29tLmFjdGlvbic6ICd6b29tJywgJ2NoYXJ0LmJveHBsb3Qud2lkdGgnOiAxLCAnY2hhcnQuYm94cGxvdC5jYXBwZWQnOiB0cnVlLCAnY2hhcnQucmVzaXphYmxlJzogZmFsc2UsICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsIH0sIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnhtaW4nLCAwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubGFiZWxzLnNwZWNpZmljLmFsaWduJywgJ2xlZnQnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueHNjYWxlJywgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC54c2NhbGUudW5pdHMucHJlJywgJycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC54c2NhbGUudW5pdHMucG9zdCcsICcnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueHNjYWxlLm51bWxhYmVscycsIDEwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueHNjYWxlLmZvcm1hdHRlcicsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC54c2NhbGUuZGVjaW1hbHMnLCAwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueHNjYWxlLnRob3VzYW5kJywgJywnKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueHNjYWxlLnBvaW50JywgJy4nKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubm9lbmR4dGljaycsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubm9lbmR5dGljaycsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmV2ZW50cy5jbGljaycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJywgJ3JnYmEoMCwwLDAsMCknKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnLCAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmNsZWFydG8nLCAncmdiYSgwLDAsMCwwKScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5hbmltYXRpb24udHJhY2UnLCBmYWxzZSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJywgMSksIF9wcm9wZXJ0aWVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKFJHcmFwaC5pc051bGwodGhpcy5kYXRhW2ldW2pdKSkge1xuICAgICAgICB0aGlzLmRhdGFbaV1bal0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGFbaV1bal0gJiYgdHlwZW9mIHRoaXMuZGF0YVtpXVtqXVswXSA9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmRhdGFbaV1bal1bMF0gPSBSR3JhcGgucGFyc2VEYXRlKHRoaXMuZGF0YVtpXVtqXVswXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YV9hcnIgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICB0aGlzLmRhdGFfYXJyLnB1c2godGhpcy5kYXRhW2ldW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFfYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpc1snJCcgKyBpXSA9IHt9O1xuICB9XG4gIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICBhbGVydCgnW1NDQVRURVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGlmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC54dGlja3MnKSB7XG4gICAgICBuYW1lID09ICdjaGFydC5udW14dGlja3MnO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQubGluZS5jb2xvcnMnKSB7XG4gICAgICBwcm9wWydjaGFydC5jb2xvcnMnXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQudG9vbHRpcC5ob3RzcG90Jykge1xuICAgICAgbmFtZSA9ICdjaGFydC50b29sdGlwcy5ob3RzcG90JztcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnlheGlzcG9zJyAmJiB2YWx1ZSAhPSAnbGVmdCcgJiYgdmFsdWUgIT0gJ3JpZ2h0Jykge1xuICAgICAgYWxlcnQoXCJbU0NBVFRFUl0gY2hhcnQueWF4aXNwb3Mgc2hvdWxkIGJlIGxlZnQgb3IgcmlnaHQuIFlvdSd2ZSBzZXQgaXQgdG86ICdcIiArIHZhbHVlICsgXCInIENoYW5naW5nIGl0IHRvIGxlZnRcIik7dmFsdWUgPSAnbGVmdCc7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC54YXhpc3BvcycpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSAnYm90dG9tJyAmJiB2YWx1ZSAhPSAnY2VudGVyJykge1xuICAgICAgICBhbGVydCgnW1NDQVRURVJdICgnICsgdGhpcy5pZCArICcpIGNoYXJ0LnhheGlzcG9zIHNob3VsZCBiZSBjZW50ZXIgb3IgYm90dG9tLiBUcmllZCB0byBzZXQgaXQgdG86ICcgKyB2YWx1ZSArICcgQ2hhbmdpbmcgaXQgdG8gY2VudGVyJyk7dmFsdWUgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0Lm5veGF4aXMnKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LnhheGlzJzt2YWx1ZSA9ICF2YWx1ZTtcbiAgICB9XG4gICAgcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmltYWdlJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICBSRy5EcmF3QmFja2dyb3VuZEltYWdlKHRoaXMpO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO2lmICghdGhpcy5jb2xvcnNQYXJzZWQpIHtcbiAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMuZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMuaGFzVG9vbHRpcHMgPSBmYWxzZTt2YXIgb3ZlckhvdHNwb3QgPSBmYWxzZTt0aGlzLmNvb3JkcyA9IFtdO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQueG1pbiddID09ICdzdHJpbmcnKSBwcm9wWydjaGFydC54bWluJ10gPSBSRy5wYXJzZURhdGUocHJvcFsnY2hhcnQueG1pbiddKTtpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnhtYXgnXSA9PSAnc3RyaW5nJykgcHJvcFsnY2hhcnQueG1heCddID0gUkcucGFyc2VEYXRlKHByb3BbJ2NoYXJ0LnhtYXgnXSk7aWYgKCFSR3JhcGguSVNPTEQpIHtcbiAgICAgIHRoaXMuU2V0KCdjaGFydC50b29sdGlwcycsIFtdKTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gdGhpcy5kYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV1bal0gJiYgdGhpcy5kYXRhW2ldW2pdWzNdKSB7XG4gICAgICAgICAgICBwcm9wWydjaGFydC50b29sdGlwcyddLnB1c2godGhpcy5kYXRhW2ldW2pdWzNdKTt0aGlzLmhhc1Rvb2x0aXBzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcFsnY2hhcnQudG9vbHRpcHMnXS5wdXNoKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1heCA9IDA7aWYgKHR5cGVvZiBwcm9wWydjaGFydC55bWF4J10gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm1heCA9IHByb3BbJ2NoYXJ0LnltYXgnXTt0aGlzLm1pbiA9IHByb3BbJ2NoYXJ0LnltaW4nXSA/IHByb3BbJ2NoYXJ0LnltaW4nXSA6IDA7dGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyAnbWF4JzogdGhpcy5tYXgsICdtaW4nOiB0aGlzLm1pbiwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQueWxhYmVscy5jb3VudCddLCAnc2NhbGUucm91bmQnOiBwcm9wWydjaGFydC5zY2FsZS5yb3VuZCddLCAndW5pdHMucHJlJzogcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sICd1bml0cy5wb3N0JzogcHJvcFsnY2hhcnQudW5pdHMucG9zdCddIH0pO3RoaXMubWF4ID0gdGhpcy5zY2FsZTIubWF4O3RoaXMubWluID0gdGhpcy5zY2FsZTIubWluO3ZhciBkZWNpbWFscyA9IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpID0gMDt2YXIgaiA9IDA7Zm9yIChpID0gMCwgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSB0aGlzLmRhdGFbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFSRy5pc051bGwodGhpcy5kYXRhW2ldW2pdKSAmJiB0aGlzLmRhdGFbaV1bal1bMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgX3R5cGVvZih0aGlzLmRhdGFbaV1bal1bMV0pID09ICdvYmplY3QnID8gUkcuYXJyYXlfbWF4KHRoaXMuZGF0YVtpXVtqXVsxXSkgOiBNYXRoLmFicyh0aGlzLmRhdGFbaV1bal1bMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWluID0gcHJvcFsnY2hhcnQueW1pbiddID8gcHJvcFsnY2hhcnQueW1pbiddIDogMDt0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiB0aGlzLm1heCwgJ21pbic6IHRoaXMubWluLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUuZGVjaW1hbHMnOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCAneWxhYmVscy5jb3VudCc6IHByb3BbJ2NoYXJ0LnlsYWJlbHMuY291bnQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSB9KTt0aGlzLm1heCA9IHRoaXMuc2NhbGUyLm1heDt0aGlzLm1pbiA9IHRoaXMuc2NhbGUyLm1pbjtcbiAgICB9XG4gICAgdGhpcy5ncmFwaGFyZWEgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tO1JHLmJhY2tncm91bmQuRHJhdyh0aGlzKTtpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5oYmFycyddICYmIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXS5sZW5ndGgpIHtcbiAgICAgIFJHLkRyYXdCYXJzKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYmFja2dyb3VuZC52YmFycyddICYmIHByb3BbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuRHJhd1ZCYXJzKCk7XG4gICAgfVxuICAgIGlmICghcHJvcFsnY2hhcnQubm9heGVzJ10pIHtcbiAgICAgIHRoaXMuRHJhd0F4ZXMoKTtcbiAgICB9XG4gICAgdGhpcy5EcmF3TGFiZWxzKCk7aWYgKHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZSddKSB7XG4gICAgICBjby5zYXZlKCk7Y28uYmVnaW5QYXRoKCk7Y28ucmVjdCgwLCAwLCBjYS53aWR0aCAqIHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZS5jbGlwJ10sIGNhLmhlaWdodCk7Y28uY2xpcCgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLkRyYXdNYXJrcyhpKTtjby5zaGFkb3dDb2xvciA9IHByb3BbJ2NoYXJ0LmxpbmUuc2hhZG93LmNvbG9yJ107Y28uc2hhZG93T2Zmc2V0WCA9IHByb3BbJ2NoYXJ0LmxpbmUuc2hhZG93Lm9mZnNldHgnXTtjby5zaGFkb3dPZmZzZXRZID0gcHJvcFsnY2hhcnQubGluZS5zaGFkb3cub2Zmc2V0eSddO2NvLnNoYWRvd0JsdXIgPSBwcm9wWydjaGFydC5saW5lLnNoYWRvdy5ibHVyJ107dGhpcy5EcmF3TGluZShpKTtSRy5Ob1NoYWRvdyh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxpbmUnXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLkRyYXdNYXJrcyhpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmFuaW1hdGlvbi50cmFjZSddKSB7XG4gICAgICBjby5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmtleSddICYmIHByb3BbJ2NoYXJ0LmtleSddLmxlbmd0aCkge1xuICAgICAgUkcuRHJhd0tleSh0aGlzLCBwcm9wWydjaGFydC5rZXknXSwgcHJvcFsnY2hhcnQubGluZS5jb2xvcnMnXSk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUnXSkge1xuICAgICAgdGhpcy5EcmF3QWJvdmVMYWJlbHMoKTtcbiAgICB9XG4gICAgdGhpcy5EcmF3SW5HcmFwaExhYmVscyh0aGlzKTtpZiAocHJvcFsnY2hhcnQucmVzaXphYmxlJ10pIHtcbiAgICAgIFJHLkFsbG93UmVzaXppbmcodGhpcyk7XG4gICAgfVxuICAgIFJHLkluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5GaXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O1xuICB0aGlzLmRyYXdBeGVzID0gdGhpcy5EcmF3QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3JhcGhIZWlnaHQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuYXhpcy5jb2xvciddO2NvLmxpbmVXaWR0aCA9IChwcm9wWydjaGFydC5heGlzLmxpbmV3aWR0aCddIHx8IDEpICsgMC4wMDE7aWYgKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSA9PSBmYWxzZSkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgIGNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsIHRoaXMuZ3V0dGVyVG9wKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0LCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjby5tb3ZlVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQueGF4aXMnXSkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQodGhpcy5ndXR0ZXJUb3AgKyAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgbWEucm91bmQodGhpcy5ndXR0ZXJUb3AgKyAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0WUNvb3JkKHRoaXMuc2NhbGUyLm1pbiA+IDAgPyB0aGlzLnNjYWxlMi5taW4gOiAwKTtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCB5KTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBudW15dGlja3MgPSBwcm9wWydjaGFydC5udW15dGlja3MnXTtmb3IgKGkgPSAwOyBpIDwgbnVteXRpY2tzOyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyBudW15dGlja3MgKiBpO3kgPSB5ICsgdGhpcy5ndXR0ZXJUb3A7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicgJiYgaSA9PSBudW15dGlja3MgLyAyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQgLSAzLCBtYS5yb3VuZCh5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY28ubW92ZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDMsIE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIE1hdGgucm91bmQoeSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQubnVteXRpY2tzJ10gPiAwKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0IC0gMywgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgY28ubW92ZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDMsIG1hLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgbWEucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzJ10gPT09IGZhbHNlICYmIHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT09ICdsZWZ0Jykge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQgLSAzLCBtYS5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC54YXhpcyddID09PSBmYWxzZSAmJiBwcm9wWydjaGFydC55YXhpc3BvcyddID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIG1hLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDMsIG1hLnJvdW5kKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PT0gJ2JvdHRvbScgJiYgcHJvcFsnY2hhcnQubnVteXRpY2tzJ10gPiAwKSB7XG4gICAgICAgIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0Jykge1xuICAgICAgICAgIGNvLm1vdmVUbyh0aGlzLmd1dHRlckxlZnQsIG1hLnJvdW5kKHRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LnltaW4nXSkpKTtjby5saW5lVG8odGhpcy5ndXR0ZXJMZWZ0IC0gMywgbWEucm91bmQodGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyAzLCBtYS5yb3VuZCh0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bWluJ10pKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgbWEucm91bmQodGhpcy5nZXRZQ29vcmQocHJvcFsnY2hhcnQueW1pbiddKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5udW14dGlja3MnXSA+IDAgJiYgcHJvcFsnY2hhcnQueGF4aXMnXSkge1xuICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZChwcm9wWydjaGFydC55bGFiZWxzLmludmVydCddID8gdGhpcy5zY2FsZTIubWF4IDogdGhpcy5zY2FsZTIubWF4ID4gMCAmJiB0aGlzLnNjYWxlMi5taW4gPiAwID8gdGhpcy5zY2FsZTIubWluIDogMCkgLSAzLFxuICAgICAgICAgIHNpemUgPSAzO2lmIChwcm9wWydjaGFydC55bWluJ10gPT09IDAgJiYgcHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSArPSAzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2NhbGUyLm1heCA+IDAgJiYgdGhpcy5zY2FsZTIubWluID4gMCkge1xuICAgICAgICB5ICs9IDM7XG4gICAgICB9XG4gICAgICB0aGlzLnhUaWNrR2FwID0gcHJvcFsnY2hhcnQubGFiZWxzJ10gJiYgcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoID8gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyBwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggOiAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIDEwO2lmICh0eXBlb2YgcHJvcFsnY2hhcnQubnVteHRpY2tzJ10gPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy54VGlja0dhcCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gcHJvcFsnY2hhcnQubnVteHRpY2tzJ107XG4gICAgICB9XG4gICAgICBmb3IgKHggPSB0aGlzLmd1dHRlckxlZnQgKyAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgJiYgcHJvcFsnY2hhcnQubm95YXhpcyddID09IGZhbHNlID8gdGhpcy54VGlja0dhcCA6IDApOyB4IDw9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAtIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyB8fCBwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gdHJ1ZSA/IC0xIDogMSk7IHggKz0gdGhpcy54VGlja0dhcCkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcgJiYgcHJvcFsnY2hhcnQubm9lbmR4dGljayddID09IHRydWUgJiYgeCA9PSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdyaWdodCcgJiYgcHJvcFsnY2hhcnQubm9lbmR4dGljayddID09IHRydWUgJiYgeCA9PSB0aGlzLmd1dHRlckxlZnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIHkpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSwgeSArIChwcm9wWydjaGFydC54YXhpc3BvcyddID09PSAnY2VudGVyJyB8fCBwcm9wWydjaGFydC55bWluJ10gPCAwID8gc2l6ZSAqIDIgOiBzaXplKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aCA9IDE7XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTt2YXIgZm9udCA9IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLFxuICAgICAgICB4TWluID0gcHJvcFsnY2hhcnQueG1pbiddLFxuICAgICAgICB4TWF4ID0gcHJvcFsnY2hhcnQueG1heCddLFxuICAgICAgICB5TWF4ID0gdGhpcy5zY2FsZTIubWF4LFxuICAgICAgICB5TWluID0gcHJvcFsnY2hhcnQueW1pbiddID8gcHJvcFsnY2hhcnQueW1pbiddIDogMCxcbiAgICAgICAgdGV4dF9zaXplID0gcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sXG4gICAgICAgIHVuaXRzX3ByZSA9IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLFxuICAgICAgICB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddLFxuICAgICAgICBudW1ZTGFiZWxzID0gcHJvcFsnY2hhcnQueWxhYmVscy5jb3VudCddLFxuICAgICAgICBpbnZlcnQgPSBwcm9wWydjaGFydC55bGFiZWxzLmludmVydCddLFxuICAgICAgICBpbnNpZGUgPSBwcm9wWydjaGFydC55bGFiZWxzLmluc2lkZSddLFxuICAgICAgICBjb250ZXh0ID0gY28sXG4gICAgICAgIGNhbnZhcyA9IGNhLFxuICAgICAgICBib3hlZCA9IGZhbHNlLFxuICAgICAgICBvZmZzZXR4ID0gcHJvcFsnY2hhcnQueWxhYmVscy5vZmZzZXR4J10sXG4gICAgICAgIG9mZnNldHkgPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHknXTtcbiAgICB0aGlzLmhhbGZUZXh0SGVpZ2h0ID0gdGV4dF9zaXplIC8gMjt0aGlzLmhhbGZHcmFwaEhlaWdodCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIDI7aWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMnXSkge1xuICAgICAgdmFyIHhQb3MgPSBwcm9wWydjaGFydC55YXhpc3BvcyddID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCAtIDUgOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyA1O3ZhciBhbGlnbiA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7aWYgKGluc2lkZSkge1xuICAgICAgICBpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAnbGVmdCcpIHtcbiAgICAgICAgICB4UG9zID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSArIDU7YWxpZ24gPSAnbGVmdCc7Ym94ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhQb3MgPSBjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddIC0gNTthbGlnbiA9ICdyaWdodCc7Ym94ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcFsnY2hhcnQueGF4aXNwb3MnXSA9PSAnY2VudGVyJykge1xuICAgICAgICBpZiAoX3R5cGVvZihwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSAhPSBudWxsICYmIHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddO2lmIChwcm9wWydjaGFydC55bWluJ10gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbHMgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2gocHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyBpICogKHRoaXMuZ3JhcGhhcmVhIC8gKGxhYmVscy5sZW5ndGggKiAyKSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHkgKyBvZmZzZXR5LCAndGV4dCc6IGxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3VuZGluZyc6IGJveGVkLCAndGFnJzogJ2xhYmVscy5zcGVjaWZpYycgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXZlcnNlZF9sYWJlbHMgPSBSRy5hcnJheV9yZXZlcnNlKGxhYmVscyk7Zm9yICh2YXIgaSA9IDA7IGkgPCByZXZlcnNlZF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmdyYXBoYXJlYSAvIDIgKyAoaSArIDEpICogKHRoaXMuZ3JhcGhhcmVhIC8gKGxhYmVscy5sZW5ndGggKiAyKSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHkgKyBvZmZzZXR5LCAndGV4dCc6IHJldmVyc2VkX2xhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3VuZGluZyc6IGJveGVkLCAndGFnJzogJ2xhYmVscy5zcGVjaWZpYycgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wWydjaGFydC55bWluJ10gIT0gMCkge1xuICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3JhcGhhcmVhIC8gMiArIHRoaXMuZ3V0dGVyVG9wICsgb2Zmc2V0eSwgJ3RleHQnOiBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11bcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aCAtIDFdLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICd0YWcnOiAnbGFiZWxzLnNwZWNpZmljJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10gJiYgdHlwZW9mIG51bVlMYWJlbHMgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludmVydCkge1xuICAgICAgICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZHcmFwaEhlaWdodCAtIChpICsgMSkgLyBudW1ZTGFiZWxzICogdGhpcy5oYWxmR3JhcGhIZWlnaHQgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZHcmFwaEhlaWdodCAtIGkgLyBudW1ZTGFiZWxzICogdGhpcy5oYWxmR3JhcGhIZWlnaHQgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1t0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoIC0gKGkgKyAxKV0sICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zY2FsZTIubGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludmVydCkge1xuICAgICAgICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZHcmFwaEhlaWdodCArIHRoaXMuaGFsZkdyYXBoSGVpZ2h0IC0gaSAvIG51bVlMYWJlbHMgKiB0aGlzLmhhbGZHcmFwaEhlaWdodCArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGFsaWduLCAnYm91bmRpbmcnOiBib3hlZCwgJ2JvdW5kaW5nRmlsbCc6ICd3aGl0ZScsICd0ZXh0JzogJy0nICsgdGhpcy5zY2FsZTIubGFiZWxzW2xlbiAtIChpICsgMSldLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpID09IGxlbiAtIDEgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmR3JhcGhIZWlnaHQgKyB0aGlzLmhhbGZHcmFwaEhlaWdodCAtIChpICsgMSkgLyBudW1ZTGFiZWxzICogdGhpcy5oYWxmR3JhcGhIZWlnaHQgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6ICctJyArIHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaW52ZXJ0ICYmICh5TWluID4gMCB8fCBwcm9wWydjaGFydC5zY2FsZS56ZXJvc3RhcnQnXSkpIHtcbiAgICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogdGV4dF9zaXplLCB4OiB4UG9zICsgb2Zmc2V0eCwgeTogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmhhbGZHcmFwaEhlaWdodCArIG9mZnNldHksIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogYWxpZ24sIGJvdW5kaW5nOiBib3hlZCwgYm91bmRpbmdGaWxsOiAnd2hpdGUnLCB0ZXh0OiBSRy5udW1iZXJGb3JtYXQodGhpcywgeU1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbiA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IFJHLm51bWJlcl9mb3JtYXQodGhpcywgeU1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbiA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ3RhZyc6ICdzY2FsZScgfSk7UkcudGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oYWxmR3JhcGhIZWlnaHQgKiAyICsgb2Zmc2V0eSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogYWxpZ24sICdib3VuZGluZyc6IGJveGVkLCAnYm91bmRpbmdGaWxsJzogJ3doaXRlJywgJ3RleHQnOiAnLScgKyBSRy5udW1iZXJGb3JtYXQodGhpcywgeU1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbiA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeFBvcyA9IHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0IC0gNSA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDU7dmFyIGFsaWduID0gcHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlheGlzcG9zJ10gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB4UG9zID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSArIDU7YWxpZ24gPSAnbGVmdCc7Ym94ZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4UG9zID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gNTthbGlnbiA9ICdyaWdodCc7Ym94ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGVvZihwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ10pID09ICdvYmplY3QnICYmIHByb3BbJ2NoYXJ0LnlsYWJlbHMuc3BlY2lmaWMnXSkge1xuICAgICAgICAgIHZhciBsYWJlbHMgPSBwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ107aWYgKHByb3BbJ2NoYXJ0LnltaW4nXSA+IDk5OTkpIHtcbiAgICAgICAgICAgIGxhYmVscyA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFsnY2hhcnQueWxhYmVscy5zcGVjaWZpYyddLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBsYWJlbHMucHVzaChwcm9wWydjaGFydC55bGFiZWxzLnNwZWNpZmljJ11baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuZ3V0dGVyVG9wICsgaSAqICh0aGlzLmdyYXBoYXJlYSAvIChsZW4gLSAxKSk7UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogdGV4dF9zaXplLCAneCc6IHhQb3MgKyBvZmZzZXR4LCAneSc6IHkgKyBvZmZzZXR5LCAndGV4dCc6IGxhYmVsc1tpXSwgJ2hhbGlnbic6IGFsaWduLCAndmFsaWduJzogJ2NlbnRlcicsICdib3VuZGluZyc6IGJveGVkLCAndGFnJzogJ3NjYWxlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBudW1ZTGFiZWxzID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtWUxhYmVsczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gbnVtWUxhYmVscztSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyAoaSArIDEpICogaW50ZXJ2YWwgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwcm9wWydjaGFydC54YXhpcyddICYmICFwcm9wWydjaGFydC55bWluJ10pIHtcbiAgICAgICAgICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IFJHLm51bWJlckZvcm1hdCh0aGlzLCB0aGlzLm1pbi50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbiA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBSRy5UZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmdyYXBoYXJlYSAtIChpICsgMSkgLyB0aGlzLnNjYWxlMi5sYWJlbHMubGVuZ3RoICogdGhpcy5ncmFwaGFyZWEgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IHRoaXMuc2NhbGUyLmxhYmVsc1tpXSwgJ3RhZyc6ICdzY2FsZScgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwcm9wWydjaGFydC54YXhpcyddICYmIHByb3BbJ2NoYXJ0LnltaW4nXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgUkcudGV4dDIodGhpcywgeyBmb250OiBmb250LCBzaXplOiB0ZXh0X3NpemUsIHg6IHhQb3MgKyBvZmZzZXR4LCB5OiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIG9mZnNldHksIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogYWxpZ24sIGJvdW5kaW46IGJveGVkLCBib3VuZGluZ0ZpbGw6ICd3aGl0ZScsIHRleHQ6IFJHLm51bWJlckZvcm1hdCh0aGlzLCAwIC50b0ZpeGVkKHRoaXMuc2NhbGUyLm1pbiA9PT0gMCA/IDAgOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgdW5pdHNfcHJlLCB1bml0c19wb3N0KSwgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgocHJvcFsnY2hhcnQueW1pbiddIHx8IHByb3BbJ2NoYXJ0LnNjYWxlLnplcm9zdGFydCddKSAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBwcm9wWydjaGFydC55bWluJ10udG9GaXhlZCh0aGlzLnNjYWxlMi5taW4gPT09IDAgPyAwIDogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgICBSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogZm9udCwgJ3NpemUnOiB0ZXh0X3NpemUsICd4JzogeFBvcyArIG9mZnNldHgsICd5JzogdGhpcy5ndXR0ZXJUb3AgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiBhbGlnbiwgJ2JvdW5kaW5nJzogYm94ZWQsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGV4dCc6IFJHLm51bWJlckZvcm1hdCh0aGlzLCBwcm9wWydjaGFydC55bWluJ10udG9GaXhlZCh0aGlzLnNjYWxlMi5taW4gPT09IDAgPyAwIDogcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSksIHVuaXRzX3ByZSwgdW5pdHNfcG9zdCksICd0YWcnOiAnc2NhbGUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQueHNjYWxlJ10pIHtcbiAgICAgIHZhciBudW1YTGFiZWxzID0gcHJvcFsnY2hhcnQueHNjYWxlLm51bWxhYmVscyddLFxuICAgICAgICAgIHkgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIDUgKyB0ZXh0X3NpemUgLyAyLFxuICAgICAgICAgIHVuaXRzX3ByZV94ID0gcHJvcFsnY2hhcnQueHNjYWxlLnVuaXRzLnByZSddLFxuICAgICAgICAgIHVuaXRzX3Bvc3RfeCA9IHByb3BbJ2NoYXJ0LnhzY2FsZS51bml0cy5wb3N0J10sXG4gICAgICAgICAgZGVjaW1hbHMgPSBwcm9wWydjaGFydC54c2NhbGUuZGVjaW1hbHMnXSxcbiAgICAgICAgICBwb2ludCA9IHByb3BbJ2NoYXJ0LnhzY2FsZS5wb2ludCddLFxuICAgICAgICAgIHRob3VzYW5kID0gcHJvcFsnY2hhcnQueHNjYWxlLnRob3VzYW5kJ10sXG4gICAgICAgICAgY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3InXSxcbiAgICAgICAgICBib2xkID0gcHJvcFsnY2hhcnQubGFiZWxzLmJvbGQnXSxcbiAgICAgICAgICBvZmZzZXR4ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxcbiAgICAgICAgICBvZmZzZXR5ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHknXTtcbiAgICAgIGlmICghcHJvcFsnY2hhcnQueG1heCddKSB7XG4gICAgICAgIHZhciB4bWF4ID0gMDt2YXIgeG1pbiA9IHByb3BbJ2NoYXJ0LnhtaW4nXTtmb3IgKHZhciBkcyA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGRzIDwgbGVuOyBkcyArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgcG9pbnQgPSAwLCBsZW4yID0gdGhpcy5kYXRhW2RzXS5sZW5ndGg7IHBvaW50IDwgbGVuMjsgcG9pbnQgKz0gMSkge1xuICAgICAgICAgICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIHRoaXMuZGF0YVtkc11bcG9pbnRdWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhtYXggPSBwcm9wWydjaGFydC54bWF4J107eG1pbiA9IHByb3BbJ2NoYXJ0LnhtaW4nXTtcbiAgICAgIH1cbiAgICAgIHRoaXMueHNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7ICdtYXgnOiB4bWF4LCAnbWluJzogeG1pbiwgJ3NjYWxlLmRlY2ltYWxzJzogZGVjaW1hbHMsICdzY2FsZS5wb2ludCc6IHBvaW50LCAnc2NhbGUudGhvdXNhbmQnOiB0aG91c2FuZCwgJ3VuaXRzLnByZSc6IHVuaXRzX3ByZV94LCAndW5pdHMucG9zdCc6IHVuaXRzX3Bvc3RfeCwgJ3lsYWJlbHMuY291bnQnOiBudW1YTGFiZWxzLCAnc3RyaWN0JzogdHJ1ZSB9KTt0aGlzLlNldCgnY2hhcnQueG1heCcsIHRoaXMueHNjYWxlMi5tYXgpO3ZhciBpbnRlcnZhbCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gdGhpcy54c2NhbGUyLmxhYmVscy5sZW5ndGg7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMueHNjYWxlMi5sYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG51bSA9IChwcm9wWydjaGFydC54bWF4J10gLSBwcm9wWydjaGFydC54bWluJ10pICogKChpICsgMSkgLyBudW1YTGFiZWxzKSArICh4bWluIHx8IDApLFxuICAgICAgICAgICAgeCA9IHRoaXMuZ3V0dGVyTGVmdCArIChpICsgMSkgKiBpbnRlcnZhbCxcbiAgICAgICAgICAgIHRleHQgPSB0eXBlb2YgcHJvcFsnY2hhcnQueHNjYWxlLmZvcm1hdHRlciddID09PSAnZnVuY3Rpb24nID8gU3RyaW5nKHByb3BbJ2NoYXJ0LnhzY2FsZS5mb3JtYXR0ZXInXSh0aGlzLCBudW0pKSA6IHRoaXMueHNjYWxlMi5sYWJlbHNbaV07UkcudGV4dDIodGhpcywgeyAnY29sb3InOiBjb2xvciwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ2JvbGQnOiBib2xkLCAneCc6IHggKyBvZmZzZXR4LCAneSc6IHkgKyBvZmZzZXR5LCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ3RleHQnOiB0ZXh0LCAndGFnJzogJ3hzY2FsZScgfSk7XG4gICAgICB9XG4gICAgICB2YXIgdGV4dCA9IHR5cGVvZiBwcm9wWydjaGFydC54c2NhbGUuZm9ybWF0dGVyJ10gPT09ICdmdW5jdGlvbicgPyBTdHJpbmcocHJvcFsnY2hhcnQueHNjYWxlLmZvcm1hdHRlciddKHRoaXMsIHByb3BbJ2NoYXJ0LnhtaW4nXSkpIDogU3RyaW5nKHByb3BbJ2NoYXJ0LnhtaW4nXSk7UkcudGV4dDIodGhpcywgeyAnY29sb3InOiBjb2xvciwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHRleHRfc2l6ZSwgJ2JvbGQnOiBib2xkLCAneCc6IHRoaXMuZ3V0dGVyTGVmdCArIG9mZnNldHgsICd5JzogeSArIG9mZnNldHksICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6ICdjZW50ZXInLCAndGV4dCc6IHRleHQsICd0YWcnOiAneHNjYWxlJyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdyYXBoQXJlYSA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDt2YXIgeEludGVydmFsID0gZ3JhcGhBcmVhIC8gcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoO3ZhciB4UG9zID0gdGhpcy5ndXR0ZXJMZWZ0O3ZhciB5UG9zID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyAzO3ZhciBsYWJlbHMgPSBwcm9wWydjaGFydC5sYWJlbHMnXTt2YXIgY29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3InXTt2YXIgYm9sZCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5ib2xkJ107dmFyIG9mZnNldHggPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eCddO3ZhciBvZmZzZXR5ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHknXTt2YXIgYW5nbGUgPSAwO3ZhciB2YWxpZ24gPSAndG9wJzt2YXIgaGFsaWduID0gJ2NlbnRlcic7aWYgKHByb3BbJ2NoYXJ0LnRleHQuYW5nbGUnXSA+IDApIHtcbiAgICAgICAgYW5nbGUgPSAtMSAqIHByb3BbJ2NoYXJ0LnRleHQuYW5nbGUnXTt2YWxpZ24gPSAnY2VudGVyJztoYWxpZ24gPSAncmlnaHQnO3lQb3MgKz0gMTA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKGxhYmVsc1tpXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljLmFsaWduJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHZhciByaWdodEVkZ2UgPSAwO2lmIChsYWJlbHNbaSArIDFdICYmIGxhYmVsc1tpICsgMV1bMV0pIHtcbiAgICAgICAgICAgICAgcmlnaHRFZGdlID0gbGFiZWxzW2kgKyAxXVsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHByb3BbJ2NoYXJ0LnhtYXgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAodGhpcy5nZXRYQ29vcmQocmlnaHRFZGdlKSAtIHRoaXMuZ2V0WENvb3JkKGxhYmVsc1tpXVsxXSkpIC8gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2NvbG9yJzogY29sb3IsICdmb250JzogZm9udCwgJ3NpemUnOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgJ2JvbGQnOiBib2xkLCAneCc6IHRoaXMuZ2V0WENvb3JkKGxhYmVsc1tpXVsxXSkgKyBvZmZzZXQgKyBvZmZzZXR4LCAneSc6IHlQb3MgKyBvZmZzZXR5LCAndmFsaWduJzogdmFsaWduLCAnaGFsaWduJzogYW5nbGUgIT0gMCA/ICdyaWdodCcgOiBwcm9wWydjaGFydC5sYWJlbHMuc3BlY2lmaWMuYWxpZ24nXSA9PSAnY2VudGVyJyA/ICdjZW50ZXInIDogJ2xlZnQnLCAndGV4dCc6IFN0cmluZyhsYWJlbHNbaV1bMF0pLCAnYW5nbGUnOiBhbmdsZSwgJ21hcmtlcic6IGZhbHNlLCAndGFnJzogJ2xhYmVscy5zcGVjaWZpYycgfSk7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSAnI2JiYic7Y28ubW92ZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCArIGdyYXBoQXJlYSAqICgobGFiZWxzW2ldWzFdIC0geE1pbikgLyAocHJvcFsnY2hhcnQueG1heCddIC0geE1pbikpKSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQgKyBncmFwaEFyZWEgKiAoKGxhYmVsc1tpXVsxXSAtIHhNaW4pIC8gKHByb3BbJ2NoYXJ0LnhtYXgnXSAtIHhNaW4pKSksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMjApO2NvLnN0cm9rZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgJ2NvbG9yJzogY29sb3IsICdmb250JzogZm9udCwgJ3NpemUnOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgJ2JvbGQnOiBib2xkLCAneCc6IHhQb3MgKyB4SW50ZXJ2YWwgLyAyICsgb2Zmc2V0eCwgJ3knOiB5UG9zICsgb2Zmc2V0eSwgJ3ZhbGlnbic6IHZhbGlnbiwgJ2hhbGlnbic6IGhhbGlnbiwgJ3RleHQnOiBTdHJpbmcobGFiZWxzW2ldKSwgJ2FuZ2xlJzogYW5nbGUsICd0YWcnOiAnbGFiZWxzJyB9KTtcbiAgICAgICAgfVxuICAgICAgICB4UG9zICs9IHhJbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGlmIChfdHlwZW9mKGxhYmVsc1swXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSAnI2JiYic7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCArIGdyYXBoQXJlYSwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQgKyBncmFwaEFyZWEsIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgMjApO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdNYXJrcyA9IHRoaXMuRHJhd01hcmtzID0gZnVuY3Rpb24gKGkpIHtcbiAgICB0aGlzLmNvb3Jkc1tpXSA9IFtdO3ZhciB4bWF4ID0gcHJvcFsnY2hhcnQueG1heCddO3ZhciBkZWZhdWx0X2NvbG9yID0gcHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ107Zm9yICh2YXIgaiA9IDAsIGxlbiA9IHRoaXMuZGF0YVtpXS5sZW5ndGg7IGogPCBsZW47IGogKz0gMSkge1xuICAgICAgdmFyIGRhdGFfcG9pbnRzID0gdGhpcy5kYXRhW2ldO2lmIChSRy5pc051bGwoZGF0YV9wb2ludHNbal0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHhDb29yZCA9IGRhdGFfcG9pbnRzW2pdWzBdO3ZhciB5Q29vcmQgPSBkYXRhX3BvaW50c1tqXVsxXTt2YXIgY29sb3IgPSBkYXRhX3BvaW50c1tqXVsyXSA/IGRhdGFfcG9pbnRzW2pdWzJdIDogZGVmYXVsdF9jb2xvcjt2YXIgdG9vbHRpcCA9IGRhdGFfcG9pbnRzW2pdICYmIGRhdGFfcG9pbnRzW2pdWzNdID8gZGF0YV9wb2ludHNbal1bM10gOiBudWxsO3RoaXMuRHJhd01hcmsoaSwgeENvb3JkLCB5Q29vcmQsIHhtYXgsIHRoaXMuc2NhbGUyLm1heCwgY29sb3IsIHRvb2x0aXAsIHRoaXMuY29vcmRzW2ldLCBkYXRhX3BvaW50cywgaik7XG4gICAgfVxuICB9O3RoaXMuZHJhd01hcmsgPSB0aGlzLkRyYXdNYXJrID0gZnVuY3Rpb24gKGRhdGFfc2V0X2luZGV4LCB4LCB5LCB4TWF4LCB5TWF4LCBjb2xvciwgdG9vbHRpcCwgY29vcmRzLCBkYXRhLCBkYXRhX2luZGV4KSB7XG4gICAgdmFyIHRpY2ttYXJrcyA9IHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddLFxuICAgICAgICB0aWNrU2l6ZSA9IHByb3BbJ2NoYXJ0LnRpY2tzaXplJ10sXG4gICAgICAgIHhNaW4gPSBwcm9wWydjaGFydC54bWluJ10sXG4gICAgICAgIHggPSAoeCAtIHhNaW4pIC8gKHhNYXggLSB4TWluKSAqIChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpLFxuICAgICAgICBvcmlnaW5hbFggPSB4LFxuICAgICAgICBvcmlnaW5hbFkgPSB5O2lmICh0aWNrbWFya3MgJiYgKHR5cGVvZiB0aWNrbWFya3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRpY2ttYXJrcykpID09ICdvYmplY3QnKSB7XG4gICAgICB0aWNrbWFya3MgPSB0aWNrbWFya3NbZGF0YV9zZXRfaW5kZXhdO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiB0aWNrU2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGlja1NpemUpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHRpY2tTaXplID0gdGlja1NpemVbZGF0YV9zZXRfaW5kZXhdO3ZhciBoYWxmVGlja1NpemUgPSB0aWNrU2l6ZSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoYWxmVGlja1NpemUgPSB0aWNrU2l6ZSAvIDI7XG4gICAgfVxuICAgIGlmICh5ICYmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoeSkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgeVswXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlbMV0gPT09ICdudW1iZXInICYmIHR5cGVvZiB5WzJdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeVszXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlbNF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLlNldCgnY2hhcnQuYm94cGxvdCcsIHRydWUpO3ZhciB5MCA9IHRoaXMuZ2V0WUNvb3JkKHlbMF0pLFxuICAgICAgICAgIHkxID0gdGhpcy5nZXRZQ29vcmQoeVsxXSksXG4gICAgICAgICAgeTIgPSB0aGlzLmdldFlDb29yZCh5WzJdKSxcbiAgICAgICAgICB5MyA9IHRoaXMuZ2V0WUNvb3JkKHlbM10pLFxuICAgICAgICAgIHk0ID0gdGhpcy5nZXRZQ29vcmQoeVs0XSksXG4gICAgICAgICAgY29sMSA9IHlbNV0sXG4gICAgICAgICAgY29sMiA9IHlbNl0sXG4gICAgICAgICAgYm94V2lkdGggPSB0eXBlb2YgeVs3XSA9PSAnbnVtYmVyJyA/IHlbN10gOiBwcm9wWydjaGFydC5ib3hwbG90LndpZHRoJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5Q29vcmQgPSB0aGlzLmdldFlDb29yZCh5KTtcbiAgICB9XG4gICAgeCArPSB0aGlzLmd1dHRlckxlZnQ7Y28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBjb2xvcjtpZiAocHJvcFsnY2hhcnQuYm94cGxvdCddKSB7XG4gICAgICBib3hXaWR0aCA9IGJveFdpZHRoIC8gcHJvcFsnY2hhcnQueG1heCddICogKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCk7dmFyIGhhbGZCb3hXaWR0aCA9IGJveFdpZHRoIC8gMjtpZiAocHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ10pIHtcbiAgICAgICAgY28uYmVnaW5QYXRoKCk7aWYgKHR5cGVvZiB5WzhdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvLnN0cm9rZVN0eWxlID0geVs4XTtcbiAgICAgICAgfVxuICAgICAgICBjby5zdHJva2VSZWN0KHggLSBoYWxmQm94V2lkdGgsIHkxLCBib3hXaWR0aCwgeTMgLSB5MSk7aWYgKGNvbDEpIHtcbiAgICAgICAgICBjby5maWxsU3R5bGUgPSBjb2wxO2NvLmZpbGxSZWN0KHggLSBoYWxmQm94V2lkdGgsIHkxLCBib3hXaWR0aCwgeTIgLSB5MSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbDIpIHtcbiAgICAgICAgICBjby5maWxsU3R5bGUgPSBjb2wyO2NvLmZpbGxSZWN0KHggLSBoYWxmQm94V2lkdGgsIHkyLCBib3hXaWR0aCwgeTMgLSB5Mik7XG4gICAgICAgIH1cbiAgICAgICAgY28uc3Ryb2tlKCk7Y28uYmVnaW5QYXRoKCk7aWYgKHByb3BbJ2NoYXJ0LmJveHBsb3QuY2FwcGVkJ10pIHtcbiAgICAgICAgICBjby5tb3ZlVG8oeCAtIGhhbGZCb3hXaWR0aCwgbWEucm91bmQoeTApKTtjby5saW5lVG8oeCArIGhhbGZCb3hXaWR0aCwgbWEucm91bmQoeTApKTtcbiAgICAgICAgfVxuICAgICAgICBjby5tb3ZlVG8obWEucm91bmQoeCksIHkwKTtjby5saW5lVG8obWEucm91bmQoeCksIHkxKTtpZiAocHJvcFsnY2hhcnQuYm94cGxvdC5jYXBwZWQnXSkge1xuICAgICAgICAgIGNvLm1vdmVUbyh4IC0gaGFsZkJveFdpZHRoLCBtYS5yb3VuZCh5NCkpO2NvLmxpbmVUbyh4ICsgaGFsZkJveFdpZHRoLCBtYS5yb3VuZCh5NCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4KSwgeTQpO2NvLmxpbmVUbyhtYS5yb3VuZCh4KSwgeTMpO2NvLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ10gJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgIXkwICYmICF5MSAmJiAheTIgJiYgIXkzICYmICF5NCkge1xuICAgICAgaWYgKHRpY2ttYXJrcyA9PSAnY2lyY2xlJykge1xuICAgICAgICBjby5hcmMoeCwgeUNvb3JkLCBoYWxmVGlja1NpemUsIDAsIDYuMjgsIDApO2NvLmZpbGxTdHlsZSA9IGNvbG9yO2NvLmZpbGwoKTtcbiAgICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdwbHVzJykge1xuICAgICAgICBjby5tb3ZlVG8oeCwgeUNvb3JkIC0gaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCwgeUNvb3JkICsgaGFsZlRpY2tTaXplKTtjby5tb3ZlVG8oeCAtIGhhbGZUaWNrU2l6ZSwgeUNvb3JkKTtjby5saW5lVG8oeCArIGhhbGZUaWNrU2l6ZSwgeUNvb3JkKTtjby5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdzcXVhcmUnKSB7XG4gICAgICAgIGNvLnN0cm9rZVN0eWxlID0gY29sb3I7Y28uZmlsbFN0eWxlID0gY29sb3I7Y28uZmlsbFJlY3QoeCAtIGhhbGZUaWNrU2l6ZSwgeUNvb3JkIC0gaGFsZlRpY2tTaXplLCB0aWNrU2l6ZSwgdGlja1NpemUpO1xuICAgICAgfSBlbHNlIGlmICh0aWNrbWFya3MgPT0gJ2Nyb3NzJykge1xuICAgICAgICBjby5tb3ZlVG8oeCAtIGhhbGZUaWNrU2l6ZSwgeUNvb3JkIC0gaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCArIGhhbGZUaWNrU2l6ZSwgeUNvb3JkICsgaGFsZlRpY2tTaXplKTtjby5tb3ZlVG8oeCArIGhhbGZUaWNrU2l6ZSwgeUNvb3JkIC0gaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCAtIGhhbGZUaWNrU2l6ZSwgeUNvb3JkICsgaGFsZlRpY2tTaXplKTtjby5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09ICdkaWFtb25kJykge1xuICAgICAgICBjby5maWxsU3R5bGUgPSBjby5zdHJva2VTdHlsZTtjby5tb3ZlVG8oeCwgeUNvb3JkIC0gaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCArIGhhbGZUaWNrU2l6ZSwgeUNvb3JkKTtjby5saW5lVG8oeCwgeUNvb3JkICsgaGFsZlRpY2tTaXplKTtjby5saW5lVG8oeCAtIGhhbGZUaWNrU2l6ZSwgeUNvb3JkKTtjby5saW5lVG8oeCwgeUNvb3JkIC0gaGFsZlRpY2tTaXplKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aWNrbWFya3MgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZ3JhcGhXaWR0aCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCxcbiAgICAgICAgICAgIGdyYXBoaGVpZ2h0ID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSxcbiAgICAgICAgICAgIHhWYWwgPSAoeCAtIHRoaXMuZ3V0dGVyTGVmdCkgLyBncmFwaFdpZHRoICogeE1heCxcbiAgICAgICAgICAgIHlWYWwgPSAoZ3JhcGhoZWlnaHQgLSAoeUNvb3JkIC0gdGhpcy5ndXR0ZXJUb3ApKSAvIGdyYXBoaGVpZ2h0ICogeU1heDt0aWNrbWFya3ModGhpcywgZGF0YSwgeCwgeUNvb3JkLCB4VmFsLCB5VmFsLCB4TWF4LCB5TWF4LCBjb2xvciwgZGF0YV9zZXRfaW5kZXgsIGRhdGFfaW5kZXgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGlja21hcmtzID09PSAnc3RyaW5nJyAmJiAodGlja21hcmtzLnN1YnN0cigwLCA2KSA9PT0gJ2ltYWdlOicgfHwgdGlja21hcmtzLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6JyB8fCB0aWNrbWFya3Muc3Vic3RyKDAsIDEpID09PSAnLycgfHwgdGlja21hcmtzLnN1YnN0cigwLCAzKSA9PT0gJy4uLycgfHwgdGlja21hcmtzLnN1YnN0cigwLCA3KSA9PT0gJ2ltYWdlcy8nKSkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7aWYgKHRpY2ttYXJrcy5zdWJzdHIoMCwgNikgPT09ICdpbWFnZTonKSB7XG4gICAgICAgICAgaW1nLnNyYyA9IHRpY2ttYXJrcy5zdWJzdHIoNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1nLnNyYyA9IHRpY2ttYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UuaGFsaWduJ10gPT09ICdjZW50ZXInKSB4IC09IHRoaXMud2lkdGggLyAyO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MuaW1hZ2UuaGFsaWduJ10gPT09ICdyaWdodCcpIHggLT0gdGhpcy53aWR0aDtpZiAocHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbiddID09PSAnY2VudGVyJykgeUNvb3JkIC09IHRoaXMuaGVpZ2h0IC8gMjtpZiAocHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLnZhbGlnbiddID09PSAnYm90dG9tJykgeUNvb3JkIC09IHRoaXMuaGVpZ2h0O3ggKz0gcHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHgnXTt5Q29vcmQgKz0gcHJvcFsnY2hhcnQudGlja21hcmtzLmltYWdlLm9mZnNldHknXTtjby5kcmF3SW1hZ2UodGhpcywgeCwgeUNvb3JkKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodGlja21hcmtzID09PSBudWxsKSB7fSBlbHNlIHtcbiAgICAgICAgYWxlcnQoJ1tTQ0FUVEVSXSAoJyArIHRoaXMuaWQgKyAnKSBVbmtub3duIHRpY2ttYXJrIHN0eWxlOiAnICsgdGlja21hcmtzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmJveHBsb3QnXSAmJiB0eXBlb2YgeTAgPT09ICdudW1iZXInICYmIHR5cGVvZiB5MSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkyID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeTMgPT09ICdudW1iZXInICYmIHR5cGVvZiB5NCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHggPSBbeCAtIGhhbGZCb3hXaWR0aCwgeCArIGhhbGZCb3hXaWR0aF07eUNvb3JkID0gW3kwLCB5MSwgeTIsIHkzLCB5NF07XG4gICAgfVxuICAgIGNvb3Jkcy5wdXNoKFt4LCB5Q29vcmQsIHRvb2x0aXBdKTtcbiAgfTt0aGlzLmRyYXdMaW5lID0gdGhpcy5EcmF3TGluZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5saW5lLnZpc2libGUnXSA9PSAnYm9vbGVhbicgJiYgcHJvcFsnY2hhcnQubGluZS52aXNpYmxlJ10gPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmxpbmUnXSAmJiB0aGlzLmNvb3Jkc1tpXS5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LmxpbmUuZGFzaCddICYmIHR5cGVvZiBjby5zZXRMaW5lRGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjby5zZXRMaW5lRGFzaChwcm9wWydjaGFydC5saW5lLmRhc2gnXSk7XG4gICAgICB9XG4gICAgICBjby5saW5lQ2FwID0gJ3JvdW5kJztjby5saW5lSm9pbiA9ICdyb3VuZCc7Y28ubGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5saW5lLmNvbG9ycyddW2ldO2NvLmJlZ2luUGF0aCgpO3ZhciBwcmV2WSA9IG51bGw7dmFyIGN1cnJZID0gbnVsbDtmb3IgKHZhciBqID0gMCwgbGVuID0gdGhpcy5jb29yZHNbaV0ubGVuZ3RoOyBqIDwgbGVuOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHhQb3MgPSB0aGlzLmNvb3Jkc1tpXVtqXVswXTt2YXIgeVBvcyA9IHRoaXMuY29vcmRzW2ldW2pdWzFdO2lmIChqID4gMCkgcHJldlkgPSB0aGlzLmNvb3Jkc1tpXVtqIC0gMV1bMV07Y3VyclkgPSB5UG9zO2lmIChqID09IDAgfHwgUkcuaXNfbnVsbChwcmV2WSkgfHwgUkcuaXNfbnVsbChjdXJyWSkpIHtcbiAgICAgICAgICBjby5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0ZXBwZWQgPSBwcm9wWydjaGFydC5saW5lLnN0ZXBwZWQnXTtpZiAodHlwZW9mIHN0ZXBwZWQgPT0gJ2Jvb2xlYW4nICYmIHN0ZXBwZWQgfHwgKHR5cGVvZiBzdGVwcGVkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdGVwcGVkKSkgPT0gJ29iamVjdCcgJiYgc3RlcHBlZFtpXSkge1xuICAgICAgICAgICAgY28ubGluZVRvKHRoaXMuY29vcmRzW2ldW2pdWzBdLCB0aGlzLmNvb3Jkc1tpXVtqIC0gMV1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjby5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO2lmIChwcm9wWydjaGFydC5saW5lLmRhc2gnXSAmJiB0eXBlb2YgY28uc2V0TGluZURhc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY28uc2V0TGluZURhc2goWzEsIDBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY28ubGluZVdpZHRoID0gMTtcbiAgfTt0aGlzLmdldExpbmVXaWR0aCA9IHRoaXMuR2V0TGluZVdpZHRoID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgbGluZXdpZHRoID0gcHJvcFsnY2hhcnQubGluZS5saW5ld2lkdGgnXTtpZiAodHlwZW9mIGxpbmV3aWR0aCA9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGxpbmV3aWR0aDtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbGluZXdpZHRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihsaW5ld2lkdGgpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGxpbmV3aWR0aFtpXSkge1xuICAgICAgICByZXR1cm4gbGluZXdpZHRoW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxpbmV3aWR0aFswXTtcbiAgICAgIH1cbiAgICAgIGFsZXJ0KCdbU0NBVFRFUl0gRXJyb3IhIGNoYXJ0LmxpbmV3aWR0aCBzaG91bGQgYmUgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5IG9mIG9uZSBvciBtb3JlIG51bWJlcnMnKTtcbiAgICB9XG4gIH07dGhpcy5kcmF3VkJhcnMgPSB0aGlzLkRyYXdWQmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmJhcnMgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLnZiYXJzJ107dmFyIGdyYXBoV2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7aWYgKHZiYXJzKSB7XG4gICAgICB2YXIgeG1heCA9IHByb3BbJ2NoYXJ0LnhtYXgnXTt2YXIgeG1pbiA9IHByb3BbJ2NoYXJ0LnhtaW4nXTtmb3IgKHZhciBpID0gMCwgbGVuID0gdmJhcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGk7dmFyIHZhbHVlID0gdmJhcnNba2V5XTtpZiAodHlwZW9mIHZhbHVlWzBdID09ICdzdHJpbmcnKSB2YWx1ZVswXSA9IFJHLnBhcnNlRGF0ZSh2YWx1ZVswXSk7aWYgKHR5cGVvZiB2YWx1ZVsxXSA9PSAnc3RyaW5nJykgdmFsdWVbMV0gPSBSRy5wYXJzZURhdGUodmFsdWVbMV0pIC0gdmFsdWVbMF07dmFyIHggPSAodmFsdWVbMF0gLSB4bWluKSAvICh4bWF4IC0geG1pbikgKiBncmFwaFdpZHRoICsgdGhpcy5ndXR0ZXJMZWZ0O3ZhciB3aWR0aCA9IHZhbHVlWzFdIC8gKHhtYXggLSB4bWluKSAqIGdyYXBoV2lkdGg7Y28uZmlsbFN0eWxlID0gdmFsdWVbMl07Y28uZmlsbFJlY3QoeCwgdGhpcy5ndXR0ZXJUb3AsIHdpZHRoLCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5kcmF3SW5HcmFwaExhYmVscyA9IHRoaXMuRHJhd0luR3JhcGhMYWJlbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGxhYmVscyA9IG9iai5HZXQoJ2NoYXJ0LmxhYmVscy5pbmdyYXBoJyk7dmFyIGxhYmVsc19wcm9jZXNzZWQgPSBbXTtpZiAoIWxhYmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZmdjb2xvciA9ICdibGFjayc7dmFyIGJnY29sb3IgPSAnd2hpdGUnO3ZhciBkaXJlY3Rpb24gPSAxO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgbGFiZWxzW2ldID09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGFiZWxzW2ldOyArK2opIHtcbiAgICAgICAgICBsYWJlbHNfcHJvY2Vzc2VkLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsc1tpXSA9PSAnc3RyaW5nJyB8fCBfdHlwZW9mKGxhYmVsc1tpXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbGFiZWxzX3Byb2Nlc3NlZC5wdXNoKGxhYmVsc1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbHNfcHJvY2Vzc2VkLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBSRy5Ob1NoYWRvdyhvYmopO2lmIChsYWJlbHNfcHJvY2Vzc2VkICYmIGxhYmVsc19wcm9jZXNzZWQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSAwO2ZvciAodmFyIHNldCA9IDA7IHNldCA8IG9iai5jb29yZHMubGVuZ3RoOyArK3NldCkge1xuICAgICAgICBmb3IgKHZhciBwb2ludCA9IDA7IHBvaW50IDwgb2JqLmNvb3Jkc1tzZXRdLmxlbmd0aDsgKytwb2ludCkge1xuICAgICAgICAgIGlmIChsYWJlbHNfcHJvY2Vzc2VkW2ldKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG9iai5jb29yZHNbc2V0XVtwb2ludF1bMF07dmFyIHkgPSBvYmouY29vcmRzW3NldF1bcG9pbnRdWzFdO3ZhciBsZW5ndGggPSB0eXBlb2YgbGFiZWxzX3Byb2Nlc3NlZFtpXVs0XSA9PSAnbnVtYmVyJyA/IGxhYmVsc19wcm9jZXNzZWRbaV1bNF0gOiAyNTt2YXIgdGV4dF94ID0geDt2YXIgdGV4dF95ID0geSAtIDUgLSBsZW5ndGg7Y28ubW92ZVRvKHgsIHkgLSA1KTtjby5saW5lVG8oeCwgeSAtIDUgLSBsZW5ndGgpO2NvLnN0cm9rZSgpO2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LCB5IC0gNSk7Y28ubGluZVRvKHggLSAzLCB5IC0gMTApO2NvLmxpbmVUbyh4ICsgMywgeSAtIDEwKTtjby5jbG9zZVBhdGgoKTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBfdHlwZW9mKGxhYmVsc19wcm9jZXNzZWRbaV0pID09ICdvYmplY3QnICYmIHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzFdID09ICdzdHJpbmcnID8gbGFiZWxzX3Byb2Nlc3NlZFtpXVsxXSA6ICdibGFjayc7UkcudGV4dDIodGhpcywgeyAnZm9udCc6IG9iai5HZXQoJ2NoYXJ0LnRleHQuZm9udCcpLCAnc2l6ZSc6IG9iai5HZXQoJ2NoYXJ0LnRleHQuc2l6ZScpLCAneCc6IHRleHRfeCwgJ3knOiB0ZXh0X3ksICd0ZXh0JzogX3R5cGVvZihsYWJlbHNfcHJvY2Vzc2VkW2ldKSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGFiZWxzX3Byb2Nlc3NlZFtpXVswXSA9PSAnc3RyaW5nJyA/IGxhYmVsc19wcm9jZXNzZWRbaV1bMF0gOiBsYWJlbHNfcHJvY2Vzc2VkW2ldLCAndmFsaWduJzogJ2JvdHRvbScsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nLmZpbGwnOiBfdHlwZW9mKGxhYmVsc19wcm9jZXNzZWRbaV0pID09ICdvYmplY3QnICYmIHR5cGVvZiBsYWJlbHNfcHJvY2Vzc2VkW2ldWzJdID09ICdzdHJpbmcnID8gbGFiZWxzX3Byb2Nlc3NlZFtpXVsyXSA6ICd3aGl0ZScsICd0YWcnOiAnbGFiZWxzLmluZ3JhcGgnIH0pO2NvLmZpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07dmFyIG92ZXJIb3RzcG90ID0gZmFsc2U7dmFyIG9mZnNldCA9IHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhvdHNwb3QnXTtmb3IgKHZhciBzZXQgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IHNldCA8IGxlbjsgKytzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4yID0gdGhpcy5jb29yZHNbc2V0XS5sZW5ndGg7IGkgPCBsZW4yOyArK2kpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmNvb3Jkc1tzZXRdW2ldWzBdO3ZhciB5ID0gdGhpcy5jb29yZHNbc2V0XVtpXVsxXTt2YXIgdG9vbHRpcCA9IHRoaXMuZGF0YVtzZXRdW2ldWzNdO2lmICh0eXBlb2YgeSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmIChtb3VzZVggPD0geCArIG9mZnNldCAmJiBtb3VzZVggPj0geCAtIG9mZnNldCAmJiBtb3VzZVkgPD0geSArIG9mZnNldCAmJiBtb3VzZVkgPj0geSAtIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHRoaXMuZGF0YVtzZXRdW2ldWzNdLCAwKTt2YXIgaW5kZXhfYWRqdXN0ZWQgPSBpO2ZvciAodmFyIGRzID0gc2V0IC0gMTsgZHMgPj0gMDsgLS1kcykge1xuICAgICAgICAgICAgICBpbmRleF9hZGp1c3RlZCArPSB0aGlzLmRhdGFbZHNdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IDA6IHRoaXMsIDE6IHgsIDI6IHksIDM6IHNldCwgNDogaSwgNTogdGhpcy5kYXRhW3NldF1baV1bM10sICdvYmplY3QnOiB0aGlzLCAneCc6IHgsICd5JzogeSwgJ2RhdGFzZXQnOiBzZXQsICdpbmRleCc6IGksICd0b29sdGlwJzogdG9vbHRpcCwgJ2luZGV4X2FkanVzdGVkJzogaW5kZXhfYWRqdXN0ZWQgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuaXNfbnVsbCh5KSkge30gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmsgPSB0aGlzLmRhdGFbc2V0XVtpXTt2YXIgd2lkdGggPSBwcm9wWydjaGFydC5ib3hwbG90LndpZHRoJ107aWYgKHR5cGVvZiBtYXJrWzFdWzddID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG1hcmtbMV1bN107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgodHlwZW9mIHggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHgpKSA9PSAnb2JqZWN0JyAmJiBtb3VzZVggPiB4WzBdICYmIG1vdXNlWCA8IHhbMV0gJiYgbW91c2VZIDwgeVsxXSAmJiBtb3VzZVkgPiB5WzNdKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcCA9IFJHLnBhcnNlVG9vbHRpcFRleHQodGhpcy5kYXRhW3NldF1baV1bM10sIDApO3JldHVybiB7IDA6IHRoaXMsIDE6IHhbMF0sIDI6IHhbMV0gLSB4WzBdLCAzOiB5WzFdLCA0OiB5WzNdIC0geVsxXSwgNTogc2V0LCA2OiBpLCA3OiB0aGlzLmRhdGFbc2V0XVtpXVszXSwgJ29iamVjdCc6IHRoaXMsICd4JzogeFswXSwgJ3knOiB5WzFdLCAnd2lkdGgnOiB4WzFdIC0geFswXSwgJ2hlaWdodCc6IHlbM10gLSB5WzFdLCAnZGF0YXNldCc6IHNldCwgJ2luZGV4JzogaSwgJ3Rvb2x0aXAnOiB0b29sdGlwIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd0Fib3ZlTGFiZWxzID0gdGhpcy5EcmF3QWJvdmVMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSBwcm9wWydjaGFydC5sYWJlbHMuYWJvdmUuc2l6ZSddO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHVuaXRzX3ByZSA9IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddO2ZvciAodmFyIHNldCA9IDAsIGxlbiA9IHRoaXMuY29vcmRzLmxlbmd0aDsgc2V0IDwgbGVuOyArK3NldCkge1xuICAgICAgZm9yICh2YXIgcG9pbnQgPSAwLCBsZW4yID0gdGhpcy5jb29yZHNbc2V0XS5sZW5ndGg7IHBvaW50IDwgbGVuMjsgKytwb2ludCkge1xuICAgICAgICB2YXIgeF92YWwgPSB0aGlzLmRhdGFbc2V0XVtwb2ludF1bMF07dmFyIHlfdmFsID0gdGhpcy5kYXRhW3NldF1bcG9pbnRdWzFdO2lmICghUkcuaXNfbnVsbCh5X3ZhbCkpIHtcbiAgICAgICAgICBpZiAoUkcuaXNfYXJyYXkoeV92YWwpKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IHlfdmFsOyArK2kpIHtcbiAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB5X3ZhbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5X3ZhbCA9IG1heDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHhfcG9zID0gdGhpcy5jb29yZHNbc2V0XVtwb2ludF1bMF07dmFyIHlfcG9zID0gdGhpcy5jb29yZHNbc2V0XVtwb2ludF1bMV07UkcuVGV4dDIodGhpcywgeyAnZm9udCc6IGZvbnQsICdzaXplJzogc2l6ZSwgJ3gnOiB4X3BvcywgJ3knOiB5X3BvcyAtIDUgLSBzaXplLCAndGV4dCc6IHhfdmFsLnRvRml4ZWQocHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmRlY2ltYWxzJ10pICsgJywgJyArIHlfdmFsLnRvRml4ZWQocHJvcFsnY2hhcnQubGFiZWxzLmFib3ZlLmRlY2ltYWxzJ10pLCAndmFsaWduJzogJ2NlbnRlcicsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvdW5kaW5nJzogdHJ1ZSwgJ2JvdW5kaW5nRmlsbCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLCAndGFnJzogJ2xhYmVscy5hYm92ZScgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRZVmFsdWUgPSB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChhcmcubGVuZ3RoID09IDIpIHtcbiAgICAgIHZhciBtb3VzZVggPSBhcmdbMF07dmFyIG1vdXNlWSA9IGFyZ1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gUkcuZ2V0TW91c2VYWShhcmcpO3ZhciBtb3VzZVggPSBtb3VzZUNvb3Jkc1swXTt2YXIgbW91c2VZID0gbW91c2VDb29yZHNbMV07XG4gICAgfVxuICAgIHZhciBvYmogPSB0aGlzO2lmIChtb3VzZVkgPCB0aGlzLmd1dHRlclRvcCB8fCBtb3VzZVkgPiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSB8fCBtb3VzZVggPCB0aGlzLmd1dHRlckxlZnQgfHwgbW91c2VYID4gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLmdyYXBoYXJlYSAvIDIgLSAobW91c2VZIC0gdGhpcy5ndXR0ZXJUb3ApKSAvIHRoaXMuZ3JhcGhhcmVhICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgICAgdmFsdWUgKj0gMjtpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICB2YWx1ZSArPSB0aGlzLm1pbjtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnlsYWJlbHMuaW52ZXJ0J10pIHtcbiAgICAgICAgICB2YWx1ZSAtPSB0aGlzLm1pbjt2YWx1ZSA9IHRoaXMubWF4IC0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlIC09IHRoaXMubWluO2lmIChwcm9wWydjaGFydC55bGFiZWxzLmludmVydCddKSB7XG4gICAgICAgICAgdmFsdWUgKz0gdGhpcy5taW47dmFsdWUgPSB0aGlzLm1heCArIHZhbHVlO3ZhbHVlICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLmdyYXBoYXJlYSAtIChtb3VzZVkgLSB0aGlzLmd1dHRlclRvcCkpIC8gdGhpcy5ncmFwaGFyZWEgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICB2YWx1ZSArPSB0aGlzLm1pbjtpZiAocHJvcFsnY2hhcnQueWxhYmVscy5pbnZlcnQnXSkge1xuICAgICAgICB2YWx1ZSAtPSB0aGlzLm1pbjt2YWx1ZSA9IHRoaXMubWF4IC0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTt0aGlzLmdldFhWYWx1ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoYXJnLmxlbmd0aCA9PSAyKSB7XG4gICAgICB2YXIgbW91c2VYID0gYXJnWzBdO3ZhciBtb3VzZVkgPSBhcmdbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShhcmcpO3ZhciBtb3VzZVggPSBtb3VzZVhZWzBdO3ZhciBtb3VzZVkgPSBtb3VzZVhZWzFdO1xuICAgIH1cbiAgICB2YXIgb2JqID0gdGhpcztpZiAobW91c2VZIDwgdGhpcy5ndXR0ZXJUb3AgfHwgbW91c2VZID4gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gfHwgbW91c2VYIDwgdGhpcy5ndXR0ZXJMZWZ0IHx8IG1vdXNlWCA+IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodDt2YXIgdmFsdWUgPSAobW91c2VYIC0gdGhpcy5ndXR0ZXJMZWZ0KSAvIHdpZHRoICogKHByb3BbJ2NoYXJ0LnhtYXgnXSAtIHByb3BbJ2NoYXJ0LnhtaW4nXSk7XG4gICAgdmFsdWUgKz0gcHJvcFsnY2hhcnQueG1pbiddO3JldHVybiB2YWx1ZTtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVbJ2hlaWdodCddKSB7XG4gICAgICAgIFJHLkhpZ2hsaWdodC5SZWN0KHRoaXMsIHNoYXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLkhpZ2hsaWdodC5Qb2ludCh0aGlzLCBzaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO2lmIChtb3VzZVhZWzBdID4gdGhpcy5ndXR0ZXJMZWZ0IC0gMyAmJiBtb3VzZVhZWzBdIDwgY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgMyAmJiBtb3VzZVhZWzFdID4gdGhpcy5ndXR0ZXJUb3AgLSAzICYmIG1vdXNlWFlbMV0gPCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIDMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmdldFhDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gUkcucGFyc2VEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHhtaW4gPSBwcm9wWydjaGFydC54bWluJ107dmFyIHhtYXggPSBwcm9wWydjaGFydC54bWF4J107dmFyIHg7aWYgKHZhbHVlIDwgeG1pbikgcmV0dXJuIG51bGw7aWYgKHZhbHVlID4geG1heCkgcmV0dXJuIG51bGw7dmFyIGd1dHRlclJpZ2h0ID0gdGhpcy5ndXR0ZXJSaWdodDt2YXIgZ3V0dGVyTGVmdCA9IHRoaXMuZ3V0dGVyTGVmdDtpZiAocHJvcFsnY2hhcnQueWF4aXNwb3MnXSA9PSAncmlnaHQnKSB7XG4gICAgICB4ID0gKHZhbHVlIC0geG1pbikgLyAoeG1heCAtIHhtaW4pICogKGNhLndpZHRoIC0gZ3V0dGVyTGVmdCAtIGd1dHRlclJpZ2h0KTt4ID0gY2Eud2lkdGggLSBndXR0ZXJSaWdodCAtIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAodmFsdWUgLSB4bWluKSAvICh4bWF4IC0geG1pbikgKiAoY2Eud2lkdGggLSBndXR0ZXJMZWZ0IC0gZ3V0dGVyUmlnaHQpO3ggPSB4ICsgZ3V0dGVyTGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH07dGhpcy5nZXRZQ29vcmQgPSB0aGlzLmdldFlDb29yZEZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaW52ZXJ0ID0gcHJvcFsnY2hhcnQueWxhYmVscy5pbnZlcnQnXTt2YXIgeGF4aXNwb3MgPSBwcm9wWydjaGFydC54YXhpc3BvcyddO3ZhciBncmFwaEhlaWdodCA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b207dmFyIGhhbGZHcmFwaEhlaWdodCA9IGdyYXBoSGVpZ2h0IC8gMjt2YXIgeW1heCA9IHRoaXMubWF4O3ZhciB5bWluID0gcHJvcFsnY2hhcnQueW1pbiddO3ZhciBjb29yZCA9IDA7aWYgKHZhbHVlID4geW1heCB8fCBwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdib3R0b20nICYmIHZhbHVlIDwgeW1pbiB8fCBwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInICYmICh2YWx1ZSA+IDAgJiYgdmFsdWUgPCB5bWluIHx8IHZhbHVlIDwgMCAmJiB2YWx1ZSA+IC0xICogeW1pbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoeGF4aXNwb3MgPT0gJ2NlbnRlcicpIHtcbiAgICAgIGNvb3JkID0gKE1hdGguYWJzKHZhbHVlKSAtIHltaW4pIC8gKHltYXggLSB5bWluKSAqIGhhbGZHcmFwaEhlaWdodDtpZiAoaW52ZXJ0KSB7XG4gICAgICAgIGNvb3JkID0gaGFsZkdyYXBoSGVpZ2h0IC0gY29vcmQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIGNvb3JkICs9IHRoaXMuZ3V0dGVyVG9wO2Nvb3JkICs9IGhhbGZHcmFwaEhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvb3JkID0gaGFsZkdyYXBoSGVpZ2h0IC0gY29vcmQ7Y29vcmQgKz0gdGhpcy5ndXR0ZXJUb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkID0gKHZhbHVlIC0geW1pbikgLyAoeW1heCAtIHltaW4pICogZ3JhcGhIZWlnaHQ7aWYgKGludmVydCkge1xuICAgICAgICBjb29yZCA9IGdyYXBoSGVpZ2h0IC0gY29vcmQ7XG4gICAgICB9XG4gICAgICBjb29yZCA9IGdyYXBoSGVpZ2h0IC0gY29vcmQ7Y29vcmQgPSB0aGlzLmd1dHRlclRvcCArIGNvb3JkO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmQ7XG4gIH07UkcuU2NhdHRlci5CdWJibGUgPSBmdW5jdGlvbiAoc2NhdHRlciwgbWluLCBtYXgsIHdpZHRoLCBkYXRhKSB7XG4gICAgdGhpcy5zY2F0dGVyID0gc2NhdHRlcjt0aGlzLm1pbiA9IG1pbjt0aGlzLm1heCA9IG1heDt0aGlzLndpZHRoID0gd2lkdGg7dGhpcy5kYXRhID0gZGF0YTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMudHlwZSA9ICdzY2F0dGVyLmJ1YmJsZSc7XG4gICAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5zY2F0dGVyLnNldChuYW1lLCB2YWx1ZSk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXMuc2NhdHRlci5nZXQobmFtZSk7XG4gICAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYnViYmxlX21pbiA9IHRoaXMubWluLFxuICAgICAgICAgIGJ1YmJsZV9tYXggPSB0aGlzLm1heCxcbiAgICAgICAgICBidWJibGVfZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBidWJibGVfbWF4X3dpZHRoID0gdGhpcy53aWR0aDt2YXIgb2JqX2J1YmJsZSA9IHRoaXMsXG4gICAgICAgICAgb2JqX3NjYXR0ZXIgPSB0aGlzLnNjYXR0ZXI7dGhpcy5zY2F0dGVyLm9uZHJhdyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouY29vcmRzWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYnViYmxlX2RhdGFbaV0gPSBtYS5tYXgoYnViYmxlX2RhdGFbaV0sIGJ1YmJsZV9taW4pO2J1YmJsZV9kYXRhW2ldID0gbWEubWluKGJ1YmJsZV9kYXRhW2ldLCBidWJibGVfbWF4KTt2YXIgciA9IChidWJibGVfZGF0YVtpXSAtIGJ1YmJsZV9taW4pIC8gKGJ1YmJsZV9tYXggLSBidWJibGVfbWluKSAqIGJ1YmJsZV9tYXhfd2lkdGgsXG4gICAgICAgICAgICAgIGNvbG9yID0gb2JqX3NjYXR0ZXIuZGF0YVswXVtpXVsyXSA/IG9ial9zY2F0dGVyLmRhdGFbMF1baV1bMl0gOiBvYmpfc2NhdHRlci5wcm9wZXJ0aWVzWydjaGFydC5kZWZhdWx0Y29sb3InXTtjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBSRy5yYWRpYWxHcmFkaWVudChvYmosIG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVswXSArIHIgLyAyLjUsIG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVsxXSAtIHIgLyAyLjUsIDAsIG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVswXSArIHIgLyAyLjUsIG9ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVsxXSAtIHIgLyAyLjUsIHIsIHByb3BbJ2NoYXJ0LmNvbG9ycy5idWJibGUuZ3JhZHVhdGVkJ10gPyAnd2hpdGUnIDogY29sb3IsIGNvbG9yKTtjby5hcmMob2JqX3NjYXR0ZXIuY29vcmRzWzBdW2ldWzBdLCBvYmpfc2NhdHRlci5jb29yZHNbMF1baV1bMV0sIHIsIDAsIFJHLlRXT1BJLCBmYWxzZSk7Y28uZmlsbCgpO29ial9idWJibGUuY29vcmRzW2ldID0gW29ial9zY2F0dGVyLmNvb3Jkc1swXVtpXVswXSwgb2JqX3NjYXR0ZXIuY29vcmRzWzBdW2ldWzFdLCByLCBjby5maWxsU3R5bGVdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5zY2F0dGVyLkRyYXcoKTtyZXR1cm4gdGhpcztcbiAgICB9O1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXSA9IFJHLmFycmF5X2Nsb25lKHRoaXMuZGF0YSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQudmJhcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmxpbmUuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5saW5lLmNvbG9ycyddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuZGVmYXVsdGNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5heGlzLmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5heGlzLmNvbG9yJ10pO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtpZiAoZGF0YSkge1xuICAgICAgZm9yICh2YXIgZGF0YXNldCA9IDA7IGRhdGFzZXQgPCBkYXRhLmxlbmd0aDsgKytkYXRhc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhW2RhdGFzZXRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtkYXRhc2V0XVtpXSAmJiBfdHlwZW9mKHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXSkgPT0gJ29iamVjdCcgJiYgdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXVs1XSA9PSAnc3RyaW5nJykgdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzVdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzVdKTtpZiAodHlwZW9mIHRoaXMuZGF0YVtkYXRhc2V0XVtpXVsxXVs2XSA9PSAnc3RyaW5nJykgdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzZdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2RhdGFzZXRdW2ldWzFdWzZdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFSRy5pc051bGwodGhpcy5kYXRhW2RhdGFzZXRdW2ldKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2RhdGFzZXRdW2ldWzJdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQodGhpcy5kYXRhW2RhdGFzZXRdW2ldWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhiYXJzID0gcHJvcFsnY2hhcnQuYmFja2dyb3VuZC5oYmFycyddO2lmIChoYmFycykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGhiYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhiYXJzW2ldWzJdID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoaGJhcnNbaV1bMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmJhcnMgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLnZiYXJzJ107aWYgKHZiYXJzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmJhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmJhcnNbaV1bMl0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudCh2YmFyc1tpXVsyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5saW5lLmNvbG9ycyddO2lmIChjb2xvcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29sb3JzW2ldID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuZGVmYXVsdGNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5kZWZhdWx0Y29sb3InXSk7cHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuY3Jvc3NoYWlycy5jb2xvciddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IyJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7cHJvcFsnY2hhcnQuYXhpcy5jb2xvciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYXhpcy5jb2xvciddKTtcbiAgfTt0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge307dGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IHR5cGVvZiBjb2xvciAhPSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSwgMCwgcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gIH07dGhpcy5pbnRlcmFjdGl2ZUtleUhpZ2hsaWdodCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmICh0aGlzLmNvb3JkcyAmJiB0aGlzLmNvb3Jkc1tpbmRleF0gJiYgdGhpcy5jb29yZHNbaW5kZXhdLmxlbmd0aCkge1xuICAgICAgdGhpcy5jb29yZHNbaW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpZHgsIGFycikge1xuICAgICAgICBjby5iZWdpblBhdGgoKTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnXTtjby5hcmModmFsdWVbMF0sIHZhbHVlWzFdLCBwcm9wWydjaGFydC50aWNrc2l6ZSddICsgMywgMCwgUkcuVFdPUEksIGZhbHNlKTtjby5maWxsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpc1t0eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1t0eXBlXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O3RoaXMuZmlyc3REcmF3RnVuYyA9IGZ1bmN0aW9uICgpIHt9O3RoaXMudHJhY2UgPSB0aGlzLnRyYWNlMiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMl0sXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICBvYmouU2V0KCdhbmltYXRpb25UcmFjZScsIHRydWUpO29iai5TZXQoJ2FuaW1hdGlvblRyYWNlQ2xpcCcsIDApO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgUkcuY2xlYXIob2JqLmNhbnZhcyk7UkcucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO2lmIChmcmFtZSsrIDwgZnJhbWVzKSB7XG4gICAgICAgIG9iai5zZXQoJ2FuaW1hdGlvblRyYWNlQ2xpcCcsIGZyYW1lIC8gZnJhbWVzKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O3RoaXMucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm9yaWdpbmFsX2NvbG9yc1snZGF0YSddLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV0ubGVuZ3RoOyBqIDwgbGVuMjsgKytqKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpXVtqXVsyXSA9IFJHLmFycmF5X2Nsb25lKHRoaXMub3JpZ2luYWxfY29sb3JzWydkYXRhJ11baV1bal1bMl0pO2lmIChfdHlwZW9mKHRoaXMuZGF0YVtpXVtqXVsxXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW2ldW2pdWzFdWzVdID0gUkcuYXJyYXlfY2xvbmUodGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVtqXVsxXVs1XSk7dGhpcy5kYXRhW2ldW2pdWzFdWzZdID0gUkcuYXJyYXlfY2xvbmUodGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2RhdGEnXVtpXVtqXVsxXVs2XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07UkcucmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnNjYXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///202\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SemiCircularProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'semicircularprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.createUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.background.color': 'rgba(0,0,0,0)', 'chart.colors': ['#0c0'], 'chart.linewidth': 2, 'chart.strokestyle': '#666', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 35, 'chart.radius': null, 'chart.centerx': null, 'chart.centery': null, 'chart.width': null, 'chart.angles.start': Math.PI, 'chart.angles.end': 2 * Math.PI, 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.formatter': null, 'chart.scale.round': false, 'chart.shadow': false, 'chart.shadow.color': 'rgba(220,220,220,1)', 'chart.shadow.blur': 2, 'chart.shadow.offsetx': 2, 'chart.shadow.offsety': 2, 'chart.labels.center': true, 'chart.labels.center.font': null, 'chart.labels.center.bold': false, 'chart.labels.center.italic': false, 'chart.labels.center.fade': false, 'chart.labels.center.size': 40, 'chart.labels.center.color': 'black', 'chart.labels.center.valign': 'bottom', 'chart.labels.min.color': null, 'chart.labels.min.font': null, 'chart.labels.min.bold': false, 'chart.labels.min.size': null, 'chart.labels.min.italic': false, 'chart.labels.min.offset.angle': 0, 'chart.labels.min.offsetx': 0, 'chart.labels.min.offsety': 0, 'chart.labels.max.color': null, 'chart.labels.max.font': null, 'chart.labels.max.bold': false, 'chart.labels.max.size': null, 'chart.labels.max.italic': false, 'chart.labels.max.offset.angle': 0, 'chart.labels.max.offsetx': 0, 'chart.labels.max.offsety': 0, 'chart.title': '', 'chart.title.bold': true, 'chart.title.italic': false, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.tooltips.coords.page': true, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.adjustable': false, 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[SEMICIRCULARPROGRESS] No canvas support');return;\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.radius = ma.min((ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2, ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']);this.centerx = (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft;this.centery = ca.height - this.gutterBottom;this.width = this.radius / 3;if (typeof prop['chart.radius'] === 'number') this.radius = prop['chart.radius'];if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];if (typeof prop['chart.width'] === 'number') this.width = prop['chart.width'];this.coords = [];this.coordsText = [];this.drawMeter();this.drawLabels();if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    this.allowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawMeter = this.DrawMeter = function () {\n    var start = prop['chart.angles.start'],\n        end = prop['chart.angles.end'];this.scale2 = RG.getScale2(this, { 'max': this.max, 'strict': true, 'min': this.min, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': 5, 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.background.color'] !== 'rgba(0,0,0,0)') {\n      pa2(co, 'fs % fr % % % %', prop['chart.background.color'], 0, 0, ca.width, ca.height);\n    }\n    pa2(co, 'lw % b a % % % % % false a % % % % % true c s % f % sx % sy % sc % sb % f % sx 0 sy 0 sb 0 sc rgba(0,0,0,0) lw 1', prop['chart.linewidth'], this.centerx, this.centery, this.radius, start, end, this.centerx, this.centery, this.radius - this.width, end, start, prop['chart.strokestyle'], typeof prop['chart.colors'][1] !== 'undefined' ? prop['chart.colors'][1] : prop['chart.colors'][0], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow'] ? prop['chart.shadow.color'] : 'rgba(0,0,0,0)', prop['chart.shadow.blur'], typeof prop['chart.colors'][1] !== 'undefined' ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0.85)');var angle = start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min));pa2(co, 'b a % % % % % false a % % % % % true c f %', this.centerx, this.centery, this.radius, start, angle, this.centerx, this.centery, this.radius - this.width, start + (end - start) * ((this.value - this.scale2.min) / (this.max - this.scale2.min)), start, prop['chart.colors'][0]);this.coords = [[this.centerx, this.centery, this.radius, start, end, this.width, angle]];\n  };this.drawLabels = this.DrawLabels = function () {\n    var min = RG.numberFormat(this, this.scale2.min, prop['chart.units.pre'], prop['chart.units.post']);\n    var max = RG.numberFormat(this, this.scale2.max, prop['chart.units.pre'], prop['chart.units.post']);\n    if (prop['chart.angles.start'] === RGraph.PI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.start'] <= RGraph.PI) {\n      var halign = 'left';var valign = 'center';\n    } else if (prop['chart.angles.start'] >= RGraph.PI) {\n      var halign = 'right';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.start'] + prop['chart.labels.min.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.min.font'] || prop['chart.text.font'], bold: prop['chart.labels.min.bold'] || prop['chart.text.bold'], size: prop['chart.labels.min.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.min.offsetx'], y: xy[1] + prop['chart.labels.min.offsety'], valign: valign, halign: halign, text: min, color: prop['chart.labels.min.color'] || prop['chart.text.color'], italic: prop['chart.labels.min.italic'] });if (prop['chart.angles.end'] === RGraph.TWOPI) {\n      var halign = 'center';var valign = 'top';\n    } else if (prop['chart.angles.end'] >= RGraph.TWOPI) {\n      var halign = 'right';var valign = 'center';\n    } else if (prop['chart.angles.end'] <= RGraph.TWOPI) {\n      var halign = 'left';var valign = 'center';\n    }\n    var xy = RG.getRadiusEndPoint(this.centerx, this.centery, prop['chart.angles.end'] + prop['chart.labels.max.offset.angle'], this.radius - this.width / 2);RG.text2(this, { font: prop['chart.labels.max.font'] || prop['chart.text.font'], bold: prop['chart.labels.max.bold'] || prop['chart.text.bold'], size: prop['chart.labels.max.size'] || prop['chart.text.size'], x: xy[0] + prop['chart.labels.max.offsetx'], y: xy[1] + prop['chart.labels.max.offsety'], valign: valign, halign: halign, text: max, color: prop['chart.labels.max.color'] || prop['chart.text.color'], italic: prop['chart.labels.max.italic'] });if (prop['chart.labels.center']) {\n      var ret = RG.text2(this, { font: prop['chart.labels.center.font'] || prop['chart.text.font'], size: prop['chart.labels.center.size'] || 50, bold: prop['chart.labels.center.bold'], italic: prop['chart.labels.center.italic'], x: this.centerx, y: this.centery, valign: prop['chart.labels.center.valign'], halign: 'center', text: RG.numberFormat(this, this.value.toFixed(prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']), color: prop['chart.labels.center.color'] || prop['chart.text.color'] });if (prop['chart.labels.center.fade'] && ret.node) {\n        ret.node.style.opacity = 0;var delay = 25,\n            incr = 0.1;for (var i = 0; i < 10; ++i) {\n          (function (index) {\n            setTimeout(function () {\n              ret.node.style.opacity = incr * index;\n            }, delay * (index + 1));\n          })(i);\n        }\n      }\n    }\n    RG.drawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size']);\n  };this.getShape = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], this.coords[0][3], this.coords[0][6], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], this.coords[0][6], this.coords[0][3]);if (co.isPointInPath(mouseX, mouseY)) {\n      return { object: this, 0: this, x: this.coords[0][0], 1: this.coords[0][0], y: this.coords[0][1], 2: this.coords[0][1], radius: this.coords[0][2], 3: this.coords[0][2], width: this.coords[0][5], 4: this.coords[0][5], start: this.coords[0][3], 5: this.coords[0][3], end: this.coords[0][6], 6: this.coords[0][6], index: 0, tooltip: !RG.isNull(prop['chart.tooltips']) ? prop['chart.tooltips'][0] : null };\n    }\n  };this.getValue = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1],\n        angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);if (angle && mouseX >= this.centerx && mouseY > this.centery) {\n      angle += RGraph.TWOPI;\n    }\n    if (angle < prop['chart.angles.start'] && mouseX > this.centerx) {\n      angle = prop['chart.angles.end'];\n    }\n    if (angle < prop['chart.angles.start']) {\n      angle = prop['chart.angles.start'];\n    }\n    var value = (angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start']) * (this.max - this.min) + this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      pa2(co, 'lw 5 b a % % % % % false a % % % % % true c s % f % lw 1', shape.x, shape.y, shape.radius, shape.start, shape.end, shape.x, shape.y, shape.radius - shape.width, shape.end, shape.start, prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);pa2(co, 'b a % % % % % false', this.centerx, this.centery, this.radius, prop['chart.angles.start'], prop['chart.angles.end']);pa2(co, 'a % % % % % true', this.centerx, this.centery, this.radius - this.width, prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseXY[0], mouseXY[1]) ? this : null;\n  };this.allowAdjusting = this.AllowAdjusting = function () {};this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var value = this.getValue(e);if (typeof value === 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(this.canvas);\n      }\n    }\n  };this.getAngle = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var angle = value / this.max * (prop['chart.angles.end'] - prop['chart.angles.start']);\n    angle += prop['chart.angles.start'];return angle;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    pa2(co, 'b a % % % % % false a % % % % % true', this.coords[0][0], this.coords[0][1], this.coords[0][2], prop['chart.angles.start'], prop['chart.angles.end'], this.coords[0][0], this.coords[0][1], this.coords[0][2] - this.coords[0][5], prop['chart.angles.end'], prop['chart.angles.start']);return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    prop['chart.colors'][0] = this.parseSingleColorForGradient(prop['chart.colors'][0]);prop['chart.colors'][1] = this.parseSingleColorForGradient(prop['chart.colors'][1]);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.exec = function (func) {\n    func(this);return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        initial_value = this.currentValue,\n        opt = arguments[0] || {},\n        numFrames = opt.frames || 30,\n        frame = 0,\n        callback = arguments[1] || function () {},\n        diff = this.value - Number(this.currentValue),\n        increment = diff / numFrames;\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        obj.value = initial_value + increment * frame;RG.clear(ca);RG.redrawCanvas(ca);RG.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zZW1pY2lyY3VsYXJwcm9ncmVzcy5qcz85ZWNiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlNlbWlDaXJjdWxhclByb2dyZXNzID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZi5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcGFyc2VDb25mT2JqZWN0Rm9yT3B0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbmYgPSB7IGlkOiBhcmd1bWVudHNbMF0sIG1pbjogYXJndW1lbnRzWzFdLCBtYXg6IGFyZ3VtZW50c1syXSwgdmFsdWU6IGFyZ3VtZW50c1szXSB9O1xuICB9XG4gIHRoaXMuaWQgPSBjb25mLmlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLm1pbiA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKGNvbmYubWluKTt0aGlzLm1heCA9IFJHcmFwaC5zdHJpbmdzVG9OdW1iZXJzKGNvbmYubWF4KTt0aGlzLnZhbHVlID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi52YWx1ZSk7dGhpcy50eXBlID0gJ3NlbWljaXJjdWxhcnByb2dyZXNzJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMuY3VycmVudFZhbHVlID0gbnVsbDt0aGlzLnVpZCA9IFJHcmFwaC5jcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuY29sb3JzJzogWycjMGMwJ10sICdjaGFydC5saW5ld2lkdGgnOiAyLCAnY2hhcnQuc3Ryb2tlc3R5bGUnOiAnIzY2NicsICdjaGFydC5ndXR0ZXIubGVmdCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMjUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMzUsICdjaGFydC5yYWRpdXMnOiBudWxsLCAnY2hhcnQuY2VudGVyeCc6IG51bGwsICdjaGFydC5jZW50ZXJ5JzogbnVsbCwgJ2NoYXJ0LndpZHRoJzogbnVsbCwgJ2NoYXJ0LmFuZ2xlcy5zdGFydCc6IE1hdGguUEksICdjaGFydC5hbmdsZXMuZW5kJzogMiAqIE1hdGguUEksICdjaGFydC5zY2FsZS5kZWNpbWFscyc6IDAsICdjaGFydC5zY2FsZS5wb2ludCc6ICcuJywgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQuc2NhbGUuZm9ybWF0dGVyJzogbnVsbCwgJ2NoYXJ0LnNjYWxlLnJvdW5kJzogZmFsc2UsICdjaGFydC5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICdyZ2JhKDIyMCwyMjAsMjIwLDEpJywgJ2NoYXJ0LnNoYWRvdy5ibHVyJzogMiwgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4JzogMiwgJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmxhYmVscy5jZW50ZXInOiB0cnVlLCAnY2hhcnQubGFiZWxzLmNlbnRlci5mb250JzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5jZW50ZXIuYm9sZCc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5jZW50ZXIuZmFkZSc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLmNlbnRlci5zaXplJzogNDAsICdjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LmxhYmVscy5jZW50ZXIudmFsaWduJzogJ2JvdHRvbScsICdjaGFydC5sYWJlbHMubWluLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5taW4uZm9udCc6IG51bGwsICdjaGFydC5sYWJlbHMubWluLmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5taW4uc2l6ZSc6IG51bGwsICdjaGFydC5sYWJlbHMubWluLml0YWxpYyc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLm1pbi5vZmZzZXQuYW5nbGUnOiAwLCAnY2hhcnQubGFiZWxzLm1pbi5vZmZzZXR4JzogMCwgJ2NoYXJ0LmxhYmVscy5taW4ub2Zmc2V0eSc6IDAsICdjaGFydC5sYWJlbHMubWF4LmNvbG9yJzogbnVsbCwgJ2NoYXJ0LmxhYmVscy5tYXguZm9udCc6IG51bGwsICdjaGFydC5sYWJlbHMubWF4LmJvbGQnOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5tYXguc2l6ZSc6IG51bGwsICdjaGFydC5sYWJlbHMubWF4Lml0YWxpYyc6IGZhbHNlLCAnY2hhcnQubGFiZWxzLm1heC5vZmZzZXQuYW5nbGUnOiAwLCAnY2hhcnQubGFiZWxzLm1heC5vZmZzZXR4JzogMCwgJ2NoYXJ0LmxhYmVscy5tYXgub2Zmc2V0eSc6IDAsICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS5pdGFsaWMnOiBmYWxzZSwgJ2NoYXJ0LnRpdGxlLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQuY29udGV4dG1lbnUnOiBudWxsLCAnY2hhcnQudW5pdHMucHJlJzogJycsICdjaGFydC51bml0cy5wb3N0JzogJycsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuaGlnaGxpZ2h0JzogdHJ1ZSwgJ2NoYXJ0LnRvb2x0aXBzLmV2ZW50JzogJ29uY2xpY2snLCAnY2hhcnQudG9vbHRpcHMuY29vcmRzLnBhZ2UnOiB0cnVlLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5hbm5vdGF0YWJsZSc6IGZhbHNlLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQuem9vbS5hY3Rpb24nOiAnem9vbScsICdjaGFydC5yZXNpemFibGUnOiBmYWxzZSwgJ2NoYXJ0LnJlc2l6ZS5oYW5kbGUuYWRqdXN0JzogWzAsIDBdLCAnY2hhcnQucmVzaXplLmhhbmRsZS5iYWNrZ3JvdW5kJzogbnVsbCwgJ2NoYXJ0LmFkanVzdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LmV2ZW50cy5jbGljayc6IG51bGwsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJzogbnVsbCwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbU0VNSUNJUkNVTEFSUFJPR1JFU1NdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGlmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5yYWRpdXMgPSBtYS5taW4oKGNhLndpZHRoIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddKSAvIDIsIGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSk7dGhpcy5jZW50ZXJ4ID0gKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tO3RoaXMud2lkdGggPSB0aGlzLnJhZGl1cyAvIDM7aWYgKHR5cGVvZiBwcm9wWydjaGFydC5yYWRpdXMnXSA9PT0gJ251bWJlcicpIHRoaXMucmFkaXVzID0gcHJvcFsnY2hhcnQucmFkaXVzJ107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ4J10gPT09ICdudW1iZXInKSB0aGlzLmNlbnRlcnggPSBwcm9wWydjaGFydC5jZW50ZXJ4J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC5jZW50ZXJ5J10gPT09ICdudW1iZXInKSB0aGlzLmNlbnRlcnkgPSBwcm9wWydjaGFydC5jZW50ZXJ5J107aWYgKHR5cGVvZiBwcm9wWydjaGFydC53aWR0aCddID09PSAnbnVtYmVyJykgdGhpcy53aWR0aCA9IHByb3BbJ2NoYXJ0LndpZHRoJ107dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLmRyYXdNZXRlcigpO3RoaXMuZHJhd0xhYmVscygpO2lmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5zaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgUkcuaW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmIChwcm9wWydjaGFydC5yZXNpemFibGUnXSkge1xuICAgICAgUkcuYWxsb3dSZXNpemluZyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hbGxvd0FkanVzdGluZygpO2lmICh0aGlzLmZpcnN0RHJhdykge1xuICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmZpcnN0ZHJhdycpO3RoaXMuZmlyc3REcmF3ID0gZmFsc2U7dGhpcy5maXJzdERyYXdGdW5jKCk7XG4gICAgfVxuICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3TWV0ZXIgPSB0aGlzLkRyYXdNZXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSxcbiAgICAgICAgZW5kID0gcHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddO3RoaXMuc2NhbGUyID0gUkcuZ2V0U2NhbGUyKHRoaXMsIHsgJ21heCc6IHRoaXMubWF4LCAnc3RyaWN0JzogdHJ1ZSwgJ21pbic6IHRoaXMubWluLCAnc2NhbGUudGhvdXNhbmQnOiBwcm9wWydjaGFydC5zY2FsZS50aG91c2FuZCddLCAnc2NhbGUucG9pbnQnOiBwcm9wWydjaGFydC5zY2FsZS5wb2ludCddLCAnc2NhbGUuZGVjaW1hbHMnOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddLCAneWxhYmVscy5jb3VudCc6IDUsICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7aWYgKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSAhPT0gJ3JnYmEoMCwwLDAsMCknKSB7XG4gICAgICBwYTIoY28sICdmcyAlIGZyICUgJSAlICUnLCBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ10sIDAsIDAsIGNhLndpZHRoLCBjYS5oZWlnaHQpO1xuICAgIH1cbiAgICBwYTIoY28sICdsdyAlIGIgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZSBjIHMgJSBmICUgc3ggJSBzeSAlIHNjICUgc2IgJSBmICUgc3ggMCBzeSAwIHNiIDAgc2MgcmdiYSgwLDAsMCwwKSBsdyAxJywgcHJvcFsnY2hhcnQubGluZXdpZHRoJ10sIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgc3RhcnQsIGVuZCwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gdGhpcy53aWR0aCwgZW5kLCBzdGFydCwgcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSwgdHlwZW9mIHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdICE9PSAndW5kZWZpbmVkJyA/IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdIDogcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdyddID8gcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10gOiAncmdiYSgwLDAsMCwwKScsIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10sIHR5cGVvZiBwcm9wWydjaGFydC5jb2xvcnMnXVsxXSAhPT0gJ3VuZGVmaW5lZCcgPyAncmdiYSgwLDAsMCwwKScgOiAncmdiYSgyNTUsMjU1LDI1NSwwLjg1KScpO3ZhciBhbmdsZSA9IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqICgodGhpcy52YWx1ZSAtIHRoaXMuc2NhbGUyLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLnNjYWxlMi5taW4pKTtwYTIoY28sICdiIGEgJSAlICUgJSAlIGZhbHNlIGEgJSAlICUgJSAlIHRydWUgYyBmICUnLCB0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHN0YXJ0LCBhbmdsZSwgdGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIHRoaXMucmFkaXVzIC0gdGhpcy53aWR0aCwgc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogKCh0aGlzLnZhbHVlIC0gdGhpcy5zY2FsZTIubWluKSAvICh0aGlzLm1heCAtIHRoaXMuc2NhbGUyLm1pbikpLCBzdGFydCwgcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0pO3RoaXMuY29vcmRzID0gW1t0aGlzLmNlbnRlcngsIHRoaXMuY2VudGVyeSwgdGhpcy5yYWRpdXMsIHN0YXJ0LCBlbmQsIHRoaXMud2lkdGgsIGFuZ2xlXV07XG4gIH07dGhpcy5kcmF3TGFiZWxzID0gdGhpcy5EcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW4gPSBSRy5udW1iZXJGb3JtYXQodGhpcywgdGhpcy5zY2FsZTIubWluLCBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKTtcbiAgICB2YXIgbWF4ID0gUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMuc2NhbGUyLm1heCwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSk7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddID09PSBSR3JhcGguUEkpIHtcbiAgICAgIHZhciBoYWxpZ24gPSAnY2VudGVyJzt2YXIgdmFsaWduID0gJ3RvcCc7XG4gICAgfSBlbHNlIGlmIChwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSA8PSBSR3JhcGguUEkpIHtcbiAgICAgIHZhciBoYWxpZ24gPSAnbGVmdCc7dmFyIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gPj0gUkdyYXBoLlBJKSB7XG4gICAgICB2YXIgaGFsaWduID0gJ3JpZ2h0Jzt2YXIgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuICAgIHZhciB4eSA9IFJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSArIHByb3BbJ2NoYXJ0LmxhYmVscy5taW4ub2Zmc2V0LmFuZ2xlJ10sIHRoaXMucmFkaXVzIC0gdGhpcy53aWR0aCAvIDIpO1JHLnRleHQyKHRoaXMsIHsgZm9udDogcHJvcFsnY2hhcnQubGFiZWxzLm1pbi5mb250J10gfHwgcHJvcFsnY2hhcnQudGV4dC5mb250J10sIGJvbGQ6IHByb3BbJ2NoYXJ0LmxhYmVscy5taW4uYm9sZCddIHx8IHByb3BbJ2NoYXJ0LnRleHQuYm9sZCddLCBzaXplOiBwcm9wWydjaGFydC5sYWJlbHMubWluLnNpemUnXSB8fCBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgeDogeHlbMF0gKyBwcm9wWydjaGFydC5sYWJlbHMubWluLm9mZnNldHgnXSwgeTogeHlbMV0gKyBwcm9wWydjaGFydC5sYWJlbHMubWluLm9mZnNldHknXSwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogaGFsaWduLCB0ZXh0OiBtaW4sIGNvbG9yOiBwcm9wWydjaGFydC5sYWJlbHMubWluLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddLCBpdGFsaWM6IHByb3BbJ2NoYXJ0LmxhYmVscy5taW4uaXRhbGljJ10gfSk7aWYgKHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSA9PT0gUkdyYXBoLlRXT1BJKSB7XG4gICAgICB2YXIgaGFsaWduID0gJ2NlbnRlcic7dmFyIHZhbGlnbiA9ICd0b3AnO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddID49IFJHcmFwaC5UV09QSSkge1xuICAgICAgdmFyIGhhbGlnbiA9ICdyaWdodCc7dmFyIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSBpZiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIDw9IFJHcmFwaC5UV09QSSkge1xuICAgICAgdmFyIGhhbGlnbiA9ICdsZWZ0Jzt2YXIgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuICAgIHZhciB4eSA9IFJHLmdldFJhZGl1c0VuZFBvaW50KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gKyBwcm9wWydjaGFydC5sYWJlbHMubWF4Lm9mZnNldC5hbmdsZSddLCB0aGlzLnJhZGl1cyAtIHRoaXMud2lkdGggLyAyKTtSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LmxhYmVscy5tYXguZm9udCddIHx8IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBib2xkOiBwcm9wWydjaGFydC5sYWJlbHMubWF4LmJvbGQnXSB8fCBwcm9wWydjaGFydC50ZXh0LmJvbGQnXSwgc2l6ZTogcHJvcFsnY2hhcnQubGFiZWxzLm1heC5zaXplJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sIHg6IHh5WzBdICsgcHJvcFsnY2hhcnQubGFiZWxzLm1heC5vZmZzZXR4J10sIHk6IHh5WzFdICsgcHJvcFsnY2hhcnQubGFiZWxzLm1heC5vZmZzZXR5J10sIHZhbGlnbjogdmFsaWduLCBoYWxpZ246IGhhbGlnbiwgdGV4dDogbWF4LCBjb2xvcjogcHJvcFsnY2hhcnQubGFiZWxzLm1heC5jb2xvciddIHx8IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSwgaXRhbGljOiBwcm9wWydjaGFydC5sYWJlbHMubWF4Lml0YWxpYyddIH0pO2lmIChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyJ10pIHtcbiAgICAgIHZhciByZXQgPSBSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LmxhYmVscy5jZW50ZXIuZm9udCddIHx8IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBzaXplOiBwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLnNpemUnXSB8fCA1MCwgYm9sZDogcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5ib2xkJ10sIGl0YWxpYzogcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci5pdGFsaWMnXSwgeDogdGhpcy5jZW50ZXJ4LCB5OiB0aGlzLmNlbnRlcnksIHZhbGlnbjogcHJvcFsnY2hhcnQubGFiZWxzLmNlbnRlci52YWxpZ24nXSwgaGFsaWduOiAnY2VudGVyJywgdGV4dDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMudmFsdWUudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSksIGNvbG9yOiBwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmNvbG9yJ10gfHwgcHJvcFsnY2hhcnQudGV4dC5jb2xvciddIH0pO2lmIChwcm9wWydjaGFydC5sYWJlbHMuY2VudGVyLmZhZGUnXSAmJiByZXQubm9kZSkge1xuICAgICAgICByZXQubm9kZS5zdHlsZS5vcGFjaXR5ID0gMDt2YXIgZGVsYXkgPSAyNSxcbiAgICAgICAgICAgIGluY3IgPSAwLjE7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldC5ub2RlLnN0eWxlLm9wYWNpdHkgPSBpbmNyICogaW5kZXg7XG4gICAgICAgICAgICB9LCBkZWxheSAqIChpbmRleCArIDEpKTtcbiAgICAgICAgICB9KShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBSRy5kcmF3VGl0bGUodGhpcywgcHJvcFsnY2hhcnQudGl0bGUnXSwgdGhpcy5ndXR0ZXJUb3AsIG51bGwsIHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSk7XG4gIH07dGhpcy5nZXRTaGFwZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO1xuICAgIHBhMihjbywgJ2IgYSAlICUgJSAlICUgZmFsc2UgYSAlICUgJSAlICUgdHJ1ZScsIHRoaXMuY29vcmRzWzBdWzBdLCB0aGlzLmNvb3Jkc1swXVsxXSwgdGhpcy5jb29yZHNbMF1bMl0sIHRoaXMuY29vcmRzWzBdWzNdLCB0aGlzLmNvb3Jkc1swXVs2XSwgdGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzWzBdWzFdLCB0aGlzLmNvb3Jkc1swXVsyXSAtIHRoaXMuY29vcmRzWzBdWzVdLCB0aGlzLmNvb3Jkc1swXVs2XSwgdGhpcy5jb29yZHNbMF1bM10pO2lmIChjby5pc1BvaW50SW5QYXRoKG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgcmV0dXJuIHsgb2JqZWN0OiB0aGlzLCAwOiB0aGlzLCB4OiB0aGlzLmNvb3Jkc1swXVswXSwgMTogdGhpcy5jb29yZHNbMF1bMF0sIHk6IHRoaXMuY29vcmRzWzBdWzFdLCAyOiB0aGlzLmNvb3Jkc1swXVsxXSwgcmFkaXVzOiB0aGlzLmNvb3Jkc1swXVsyXSwgMzogdGhpcy5jb29yZHNbMF1bMl0sIHdpZHRoOiB0aGlzLmNvb3Jkc1swXVs1XSwgNDogdGhpcy5jb29yZHNbMF1bNV0sIHN0YXJ0OiB0aGlzLmNvb3Jkc1swXVszXSwgNTogdGhpcy5jb29yZHNbMF1bM10sIGVuZDogdGhpcy5jb29yZHNbMF1bNl0sIDY6IHRoaXMuY29vcmRzWzBdWzZdLCBpbmRleDogMCwgdG9vbHRpcDogIVJHLmlzTnVsbChwcm9wWydjaGFydC50b29sdGlwcyddKSA/IHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ11bMF0gOiBudWxsIH07XG4gICAgfVxuICB9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXSxcbiAgICAgICAgYW5nbGUgPSBSRy5nZXRBbmdsZUJ5WFkodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIG1vdXNlWCwgbW91c2VZKTtpZiAoYW5nbGUgJiYgbW91c2VYID49IHRoaXMuY2VudGVyeCAmJiBtb3VzZVkgPiB0aGlzLmNlbnRlcnkpIHtcbiAgICAgIGFuZ2xlICs9IFJHcmFwaC5UV09QSTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlIDwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10gJiYgbW91c2VYID4gdGhpcy5jZW50ZXJ4KSB7XG4gICAgICBhbmdsZSA9IHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlIDwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pIHtcbiAgICAgIGFuZ2xlID0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J107XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChhbmdsZSAtIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKSAvIChwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10gLSBwcm9wWydjaGFydC5hbmdsZXMuc3RhcnQnXSkgKiAodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbjt2YWx1ZSA9IG1hLm1heCh2YWx1ZSwgdGhpcy5taW4pO3ZhbHVlID0gbWEubWluKHZhbHVlLCB0aGlzLm1heCk7cmV0dXJuIHZhbHVlO1xuICB9O3RoaXMuaGlnaGxpZ2h0ID0gdGhpcy5IaWdobGlnaHQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXShzaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhMihjbywgJ2x3IDUgYiBhICUgJSAlICUgJSBmYWxzZSBhICUgJSAlICUgJSB0cnVlIGMgcyAlIGYgJSBsdyAxJywgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLCBzaGFwZS5zdGFydCwgc2hhcGUuZW5kLCBzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMgLSBzaGFwZS53aWR0aCwgc2hhcGUuZW5kLCBzaGFwZS5zdGFydCwgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddLCBwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7cGEyKGNvLCAnYiBhICUgJSAlICUgJSBmYWxzZScsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cywgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSk7cGEyKGNvLCAnYSAlICUgJSAlICUgdHJ1ZScsIHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCB0aGlzLnJhZGl1cyAtIHRoaXMud2lkdGgsIHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pO3JldHVybiBjby5pc1BvaW50SW5QYXRoKG1vdXNlWFlbMF0sIG1vdXNlWFlbMV0pID8gdGhpcyA6IG51bGw7XG4gIH07dGhpcy5hbGxvd0FkanVzdGluZyA9IHRoaXMuQWxsb3dBZGp1c3RpbmcgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmFkanVzdGluZ19tb3VzZW1vdmUgPSB0aGlzLkFkanVzdGluZ19tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wWydjaGFydC5hZGp1c3RhYmxlJ10gJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKSAmJiBSRy5SZWdpc3RyeS5HZXQoJ2NoYXJ0LmFkanVzdGluZycpLnVpZCA9PSB0aGlzLnVpZCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZShlKTtpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYWRqdXN0Jyk7dGhpcy52YWx1ZSA9IE51bWJlcih2YWx1ZS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKTtSRy5yZWRyYXdDYW52YXModGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmdldEFuZ2xlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID4gdGhpcy5tYXggfHwgdmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhbmdsZSA9IHZhbHVlIC8gdGhpcy5tYXggKiAocHJvcFsnY2hhcnQuYW5nbGVzLmVuZCddIC0gcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10pO1xuICAgIGFuZ2xlICs9IHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddO3JldHVybiBhbmdsZTtcbiAgfTt0aGlzLm92ZXJDaGFydEFyZWEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkdyYXBoLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07XG4gICAgcGEyKGNvLCAnYiBhICUgJSAlICUgJSBmYWxzZSBhICUgJSAlICUgJSB0cnVlJywgdGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzWzBdWzFdLCB0aGlzLmNvb3Jkc1swXVsyXSwgcHJvcFsnY2hhcnQuYW5nbGVzLnN0YXJ0J10sIHByb3BbJ2NoYXJ0LmFuZ2xlcy5lbmQnXSwgdGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzWzBdWzFdLCB0aGlzLmNvb3Jkc1swXVsyXSAtIHRoaXMuY29vcmRzWzBdWzVdLCBwcm9wWydjaGFydC5hbmdsZXMuZW5kJ10sIHByb3BbJ2NoYXJ0LmFuZ2xlcy5zdGFydCddKTtyZXR1cm4gY28uaXNQb2ludEluUGF0aChtb3VzZVgsIG1vdXNlWSk7XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ10gPSBSRy5hcnJheUNsb25lKHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVswXSk7cHJvcFsnY2hhcnQuY29sb3JzJ11bMV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jb2xvcnMnXVsxXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLCAwLCBjYS53aWR0aCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddLCAwKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWQgPyBncmFkIDogY29sb3I7XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBpbml0aWFsX3ZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWUsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgbnVtRnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXSB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGlmZiA9IHRoaXMudmFsdWUgLSBOdW1iZXIodGhpcy5jdXJyZW50VmFsdWUpLFxuICAgICAgICBpbmNyZW1lbnQgPSBkaWZmIC8gbnVtRnJhbWVzO1xuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZnJhbWUrKztpZiAoZnJhbWUgPD0gbnVtRnJhbWVzKSB7XG4gICAgICAgIG9iai52YWx1ZSA9IGluaXRpYWxfdmFsdWUgKyBpbmNyZW1lbnQgKiBmcmFtZTtSRy5jbGVhcihjYSk7UkcucmVkcmF3Q2FudmFzKGNhKTtSRy5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zZW1pY2lyY3VsYXJwcm9ncmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///203\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Bar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'bar';this.coords = [];this.stackedBackfaces = [];this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, variant: null, variant3dOffsetx: 10, variant3dOffsety: 5, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', hmargin: 3, hmarginGrouped: 2, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, keyTextFont: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');if (prop.variant !== '3d') {\n        prop.variant3dOffsetx = 0;prop.variant3dOffsety = 0;\n      } else {\n        this.svg.all.setAttribute('transform', 'skewY(5)');\n      }\n      RG.SVG.createDefs(this);this.coords = [];this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);if (prop.variant === '3d') {\n        RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, prop.gutterTop, prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, this.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft, this.height - prop.gutterBottom, prop.gutterLeft, prop.gutterTop), fill: '#ddd', stroke: '#ccc' } });this.threed_xaxis_group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph_3d_bar_xaxis_negative' } });RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(prop.gutterLeft, this.getYCoord(0), prop.gutterLeft + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight + prop.variant3dOffsetx, this.getYCoord(0) - prop.variant3dOffsety, this.width - prop.gutterRight, this.getYCoord(0), prop.gutterLeft, this.getYCoord(0)), fill: '#ddd', stroke: '#ccc' } });\n      }\n      this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      var y = this.getYCoord(0);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = this.graphWidth / this.data.length,\n              height = (ma.abs(this.data[i]) - ma.abs(this.scale.min)) / (ma.abs(this.scale.max) - ma.abs(this.scale.min)) * this.graphHeight,\n              width = this.graphWidth / this.data.length - prop.hmargin - prop.hmargin,\n              x = prop.gutterLeft + prop.hmargin + outerSegment * i;if (this.scale.min >= 0 && this.scale.max > 0) {\n            y = this.getYCoord(this.scale.min) - height;\n          } else if (this.scale.min < 0 && this.scale.max > 0) {\n            height = ma.abs(this.data[i]) / (this.scale.max - this.scale.min) * this.graphHeight;y = this.getYCoord(0) - height;if (this.data[i] < 0) {\n              y = this.getYCoord(0);\n            }\n          } else if (this.scale.min < 0 && this.scale.max < 0) {\n            height = (ma.abs(this.data[i]) - ma.abs(this.scale.max)) / (ma.abs(this.scale.min) - ma.abs(this.scale.max)) * this.graphHeight;y = prop.gutterTop;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: prop.variant === '3d' && this.data[i] < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width < 0 ? 0 : width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n            this.drawTop3dFace({ rect: rect, value: this.data[i] });this.drawSide3dFace({ rect: rect, value: this.data[i] });\n          }\n          if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = this.graphWidth / this.data.length,\n              innerSegment = outerSegment - 2 * prop.hmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = (innerSegment - (this.data[i].length - 1) * prop.hmarginGrouped) / this.data[i].length,\n                x = outerSegment * i + prop.hmargin + prop.gutterLeft + j * width + (j - 1) * prop.hmarginGrouped;x = prop.gutterLeft + outerSegment * i + width * j + prop.hmargin + j * prop.hmarginGrouped;if (this.scale.min === 0 && this.scale.max > this.scale.min) {\n              var height = (this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(0) - height;\n            } else if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n              var height = (this.data[i][j] - this.scale.max) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.max);height = ma.abs(height);\n            } else if (this.scale.max > 0 && this.scale.min < 0) {\n              var height = ma.abs(this.data[i][j]) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.data[i][j] < 0 ? this.getYCoord(0) : this.getYCoord(this.data[i][j]);\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var height = ma.abs(this.data[i][j] - this.scale.min) / (this.scale.max - this.scale.min) * this.graphHeight,\n                  y = this.getYCoord(this.scale.min) - height;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: prop.variant === '3d' && this.data[i][j] < 0 ? this.threed_xaxis_group : this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = this.graphWidth / this.data.length;var y = this.getYCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var height = ma.round(this.data[i][j] / (this.max - this.min) * this.graphHeight),\n                width = section - 2 * prop.hmargin,\n                x = prop.gutterLeft + i * section + prop.hmargin,\n                y = y - height;if (j === 0 && prop.shadow) {\n              var fullHeight = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphHeight);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { fill: 'white', x: x, y: this.height - prop.gutterBottom - fullHeight, width: width, height: fullHeight, 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-x': x, 'data-original-y': y, 'data-original-width': width, 'data-original-height': height, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (prop.variant === '3d') {\n              this.drawTop3dFace({ rect: rect, value: this.data[i][j] });this.drawSide3dFace({ rect: rect, value: this.data[i][j] });\n            }\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getYCoord = function (value) {\n      if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {}\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0,\n            stacked_total = 0;;for (var i = 0; i < this.coords.length; ++i, seq++) {\n          var num = typeof this.data[i] === 'number' ? this.data[i] : data_seq[seq];if (prop.grouping === 'stacked') {\n            var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);var group = indexes[0];var datapiece = indexes[1];if (datapiece !== this.data[group].length - 1) {\n              continue;\n            } else {\n              num = RG.SVG.arraySum(this.data[group]);\n            }\n          }\n          var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n            str = prop.labelsAboveSpecific[seq];\n          } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n            continue;\n          }\n          var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (data_seq[i] >= 0) {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n          } else {\n            var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n          }\n          RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.drawTop3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(255,255,255,0.7)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_top_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(255,255,255,0.7)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x, y, x + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w, y) } });rect.rgraph_3d_top_face[i] = face;\n      }\n    };this.drawSide3dFace = function (opt) {\n      var rect = opt.rect,\n          arr = [parseInt(rect.getAttribute('fill')), 'rgba(0,0,0,0.3)'],\n          x = parseInt(rect.getAttribute('x')),\n          y = parseInt(rect.getAttribute('y')),\n          w = parseInt(rect.getAttribute('width')),\n          h = parseInt(rect.getAttribute('height'));rect.rgraph_3d_side_face = [];for (var i = 0; i < 2; ++i) {\n        var color = i === 0 ? rect.getAttribute('fill') : 'rgba(0,0,0,0.3)';var face = RG.SVG.create({ svg: this.svg, type: 'path', parent: prop.variant === '3d' && opt.value < 0 ? this.threed_xaxis_group : this.svg.all, attr: { stroke: prop.strokestyle, fill: color, 'stroke-width': prop.linewidth, d: 'M {1} {2} L {3} {4} L {5} {6} L {7} {8}'.format(x + w, y, x + w + prop.variant3dOffsetx, y - prop.variant3dOffsety, x + w + prop.variant3dOffsetx, y + h - prop.variant3dOffsety, x + w, y + h) } });rect.rgraph_3d_side_face[i] = face;\n      }\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            height = ma.abs(obj.getYCoord(data[i]) - obj.getYCoord(0));obj.data[i] = data[i] * multiplier;height = multiplier * height;obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i] < 0 ? obj.getYCoord(0) : obj.getYCoord(0) - height);if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped') {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n              if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeHeight = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              height = ma.abs(obj.getYCoord(data[i][j]) - obj.getYCoord(0));height = multiplier * height;obj.data[i][j] = data[i][j] * multiplier;height = ma.round(height);obj.coords[seq].object.setAttribute('height', height);obj.coords[seq].object.setAttribute('y', data[i][j] < 0 ? obj.getYCoord(0) + accumulativeHeight : obj.getYCoord(0) - height - accumulativeHeight);if (prop.variant === '3d') {\n                if (obj.coords[seq].object.rgraph_3d_side_face[0].parentNode) obj.coords[seq].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[0]);if (obj.coords[seq].object.rgraph_3d_side_face[1].parentNode) obj.coords[seq].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_side_face[1]);if (obj.coords[seq].object.rgraph_3d_top_face[0].parentNode) obj.coords[seq].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[0]);if (obj.coords[seq].object.rgraph_3d_top_face[1].parentNode) obj.coords[seq].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[seq].object.rgraph_3d_top_face[1]);obj.drawSide3dFace({ rect: obj.coords[seq].object });obj.drawTop3dFace({ rect: obj.coords[seq].object });if (obj.coords[seq].object.parentNode) {\n                  var parent = obj.coords[seq].object.parentNode;var node = parent.removeChild(obj.coords[seq].object);parent.appendChild(node);\n                }\n              }\n              accumulativeHeight += prop.grouping === 'stacked' ? height : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('height', accumulativeHeight);obj.stackedBackfaces[i].setAttribute('y', obj.height - prop.gutterBottom - accumulativeHeight);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {};for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('height', 0);if (this.coords[i].object.rgraph_3d_side_face) {\n          this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_side_face[1]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[0]);this.svg.all.removeChild(this.coords[i].object.rgraph_3d_top_face[1]);\n        }\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalHeight = obj.coords[i].object.getAttribute('data-original-height'),\n                height,\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));var height = ma.min((frame - opt.startFrames[i]) / framesperbar * originalHeight, originalHeight);obj.coords[i].object.setAttribute('height', height < 0 ? 0 : height);obj.coords[i].object.setAttribute('y', value >= 0 ? obj.getYCoord(0) - height : obj.getYCoord(0));if (prop.variant === '3d') {\n              if (obj.coords[i].object.rgraph_3d_side_face[0].parentNode) obj.coords[i].object.rgraph_3d_side_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[0]);if (obj.coords[i].object.rgraph_3d_side_face[1].parentNode) obj.coords[i].object.rgraph_3d_side_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_side_face[1]);if (obj.coords[i].object.rgraph_3d_top_face[0].parentNode) obj.coords[i].object.rgraph_3d_top_face[0].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[0]);if (obj.coords[i].object.rgraph_3d_top_face[1].parentNode) obj.coords[i].object.rgraph_3d_top_face[1].parentNode.removeChild(obj.coords[i].object.rgraph_3d_top_face[1]);if (obj.coords[i].object.parentNode) {\n                var parent = obj.coords[i].object.parentNode;var node = parent.removeChild(obj.coords[i].object);parent.appendChild(node);\n              }\n            }\n            if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('y', parseInt(obj.coords[i - 1].object.getAttribute('y')) - height);\n              }\n            }\n            if (prop.variant === '3d') {\n              obj.drawSide3dFace({ rect: obj.coords[i].object });if (prop.grouping === 'grouped' || prop.grouping === 'stacked' && indexes[1] + 1 === obj.data[indexes[0]].length) {\n                obj.drawTop3dFace({ rect: obj.coords[i].object });\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuYmFyLmpzPzljZjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQ7UkcuU1ZHLkJhciA9IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IGksIHZhbHVlOiBhcmd1bWVudHNbMF1baV0gfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHsgb2JqZWN0OiB0aGlzLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmlkID0gY29uZi5pZDt0aGlzLnVpZCA9IFJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnID0gUkcuU1ZHLmNyZWF0ZVNWRyh7IGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIgfSk7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy53aWR0aCA9IE51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0ID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO3RoaXMuZGF0YSA9IGNvbmYuZGF0YTt0aGlzLnR5cGUgPSAnYmFyJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuc3RhY2tlZEJhY2tmYWNlcyA9IFtdO3RoaXMub3JpZ2luYWxDb2xvcnMgPSB7fTt0aGlzLmdyYWRpZW50Q291bnRlciA9IDE7UkcuU1ZHLk9SLmFkZCh0aGlzKTt0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7dGhpcy5wcm9wZXJ0aWVzID0geyBndXR0ZXJMZWZ0OiAzNSwgZ3V0dGVyUmlnaHQ6IDM1LCBndXR0ZXJUb3A6IDM1LCBndXR0ZXJCb3R0b206IDM1LCB2YXJpYW50OiBudWxsLCB2YXJpYW50M2RPZmZzZXR4OiAxMCwgdmFyaWFudDNkT2Zmc2V0eTogNSwgYmFja2dyb3VuZENvbG9yOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2U6IG51bGwsIGJhY2tncm91bmRJbWFnZUFzcGVjdDogJ25vbmUnLCBiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoOiB0cnVlLCBiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5OiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VYOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VZOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VXOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VIOiBudWxsLCBiYWNrZ3JvdW5kR3JpZDogdHJ1ZSwgYmFja2dyb3VuZEdyaWRDb2xvcjogJyNkZGQnLCBiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDogMSwgYmFja2dyb3VuZEdyaWRIbGluZXM6IHRydWUsIGJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6IG51bGwsIGJhY2tncm91bmRHcmlkVmxpbmVzOiB0cnVlLCBiYWNrZ3JvdW5kR3JpZFZsaW5lc0NvdW50OiBudWxsLCBiYWNrZ3JvdW5kR3JpZEJvcmRlcjogdHJ1ZSwgY29sb3JzOiBbJ3JlZCcsICcjMGYwJywgJyMwMGYnLCAnI2ZmMCcsICcjMGZmJywgJyMwZjAnLCAncGluaycsICdvcmFuZ2UnLCAnZ3JheScsICdibGFjaycsICdyZWQnLCAnIzBmMCcsICcjMDBmJywgJyNmZjAnLCAnIzBmZicsICcjMGYwJywgJ3BpbmsnLCAnb3JhbmdlJywgJ2dyYXknLCAnYmxhY2snXSwgY29sb3JzU2VxdWVudGlhbDogZmFsc2UsIHN0cm9rZXN0eWxlOiAncmdiYSgwLDAsMCwwKScsIGhtYXJnaW46IDMsIGhtYXJnaW5Hcm91cGVkOiAyLCB5YXhpczogdHJ1ZSwgeWF4aXNUaWNrbWFya3M6IHRydWUsIHlheGlzVGlja21hcmtzTGVuZ3RoOiAzLCB5YXhpc0NvbG9yOiAnYmxhY2snLCB5YXhpc1NjYWxlOiB0cnVlLCB5YXhpc0xhYmVsczogbnVsbCwgeWF4aXNMYWJlbHNPZmZzZXR4OiAwLCB5YXhpc0xhYmVsc09mZnNldHk6IDAsIHlheGlzTGFiZWxzQ291bnQ6IDUsIHlheGlzVW5pdHNQcmU6ICcnLCB5YXhpc1VuaXRzUG9zdDogJycsIHlheGlzU3RyaWN0OiBmYWxzZSwgeWF4aXNEZWNpbWFsczogMCwgeWF4aXNQb2ludDogJy4nLCB5YXhpc1Rob3VzYW5kOiAnLCcsIHlheGlzUm91bmQ6IGZhbHNlLCB5YXhpc01heDogbnVsbCwgeWF4aXNNaW46IDAsIHlheGlzRm9ybWF0dGVyOiBudWxsLCB4YXhpczogdHJ1ZSwgeGF4aXNUaWNrbWFya3M6IHRydWUsIHhheGlzVGlja21hcmtzTGVuZ3RoOiA1LCB4YXhpc0xhYmVsczogbnVsbCwgeGF4aXNMYWJlbHNQb3NpdGlvbjogJ3NlY3Rpb24nLCB4YXhpc0xhYmVsc1Bvc2l0aW9uRWRnZVRpY2ttYXJrc0NvdW50OiBudWxsLCB4YXhpc0NvbG9yOiAnYmxhY2snLCB4YXhpc0xhYmVsc09mZnNldHg6IDAsIHhheGlzTGFiZWxzT2Zmc2V0eTogMCwgbGFiZWxzQWJvdmU6IGZhbHNlLCBsYWJlbHNBYm92ZUZvbnQ6IG51bGwsIGxhYmVsc0Fib3ZlU2l6ZTogbnVsbCwgbGFiZWxzQWJvdmVCb2xkOiBudWxsLCBsYWJlbHNBYm92ZUl0YWxpYzogbnVsbCwgbGFiZWxzQWJvdmVDb2xvcjogbnVsbCwgbGFiZWxzQWJvdmVCYWNrZ3JvdW5kOiBudWxsLCBsYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nOiAwLCBsYWJlbHNBYm92ZVVuaXRzUHJlOiBudWxsLCBsYWJlbHNBYm92ZVVuaXRzUG9zdDogbnVsbCwgbGFiZWxzQWJvdmVQb2ludDogbnVsbCwgbGFiZWxzQWJvdmVUaG91c2FuZDogbnVsbCwgbGFiZWxzQWJvdmVGb3JtYXR0ZXI6IG51bGwsIGxhYmVsc0Fib3ZlRGVjaW1hbHM6IG51bGwsIGxhYmVsc0Fib3ZlT2Zmc2V0eDogMCwgbGFiZWxzQWJvdmVPZmZzZXR5OiAwLCBsYWJlbHNBYm92ZUhhbGlnbjogJ2NlbnRlcicsIGxhYmVsc0Fib3ZlVmFsaWduOiAnYm90dG9tJywgbGFiZWxzQWJvdmVTcGVjaWZpYzogbnVsbCwgdGV4dENvbG9yOiAnYmxhY2snLCB0ZXh0Rm9udDogJ3NhbnMtc2VyaWYnLCB0ZXh0U2l6ZTogMTIsIHRleHRCb2xkOiBmYWxzZSwgdGV4dEl0YWxpYzogZmFsc2UsIGxpbmV3aWR0aDogMSwgZ3JvdXBpbmc6ICdncm91cGVkJywgdG9vbHRpcHM6IG51bGwsIHRvb2x0aXBzT3ZlcnJpZGU6IG51bGwsIHRvb2x0aXBzRWZmZWN0OiAnZmFkZScsIHRvb2x0aXBzQ3NzQ2xhc3M6ICdSR3JhcGhfdG9vbHRpcCcsIHRvb2x0aXBzRXZlbnQ6ICdjbGljaycsIGhpZ2hsaWdodFN0cm9rZTogJ3JnYmEoMCwwLDAsMCknLCBoaWdobGlnaHRGaWxsOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgaGlnaGxpZ2h0TGluZXdpZHRoOiAxLCB0aXRsZTogJycsIHRpdGxlU2l6ZTogMTYsIHRpdGxlWDogbnVsbCwgdGl0bGVZOiBudWxsLCB0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlVmFsaWduOiBudWxsLCB0aXRsZUNvbG9yOiAnYmxhY2snLCB0aXRsZUZvbnQ6IG51bGwsIHRpdGxlQm9sZDogZmFsc2UsIHRpdGxlSXRhbGljOiBmYWxzZSwgdGl0bGVTdWJ0aXRsZTogJycsIHRpdGxlU3VidGl0bGVTaXplOiAxMCwgdGl0bGVTdWJ0aXRsZVg6IG51bGwsIHRpdGxlU3VidGl0bGVZOiBudWxsLCB0aXRsZVN1YnRpdGxlSGFsaWduOiAnY2VudGVyJywgdGl0bGVTdWJ0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVTdWJ0aXRsZUNvbG9yOiAnI2FhYScsIHRpdGxlU3VidGl0bGVGb250OiBudWxsLCB0aXRsZVN1YnRpdGxlQm9sZDogZmFsc2UsIHRpdGxlU3VidGl0bGVJdGFsaWM6IGZhbHNlLCBzaGFkb3c6IGZhbHNlLCBzaGFkb3dPZmZzZXR4OiAyLCBzaGFkb3dPZmZzZXR5OiAyLCBzaGFkb3dCbHVyOiAyLCBzaGFkb3dPcGFjaXR5OiAwLjI1LCBrZXk6IG51bGwsIGtleUNvbG9yczogbnVsbCwga2V5T2Zmc2V0eDogMCwga2V5T2Zmc2V0eTogMCwga2V5VGV4dE9mZnNldHg6IDAsIGtleVRleHRPZmZzZXR5OiAtMSwga2V5VGV4dFNpemU6IG51bGwsIGtleVRleHRCb2xkOiBudWxsLCBrZXlUZXh0SXRhbGljOiBudWxsLCBrZXlUZXh0Rm9udDogbnVsbCwgYXR0cmlidXRpb246IHRydWUsIGF0dHJpYnV0aW9uWDogbnVsbCwgYXR0cmlidXRpb25ZOiBudWxsLCBhdHRyaWJ1dGlvbkhyZWY6IG51bGwsIGF0dHJpYnV0aW9uSGFsaWduOiAncmlnaHQnLCBhdHRyaWJ1dGlvblZhbGlnbjogJ2JvdHRvbScsIGF0dHJpYnV0aW9uU2l6ZTogNywgYXR0cmlidXRpb25Db2xvcjogJ2dyYXknLCBhdHRyaWJ1dGlvbkZvbnQ6ICdzYW5zLXNlcmlmJywgYXR0cmlidXRpb25JdGFsaWM6IGZhbHNlLCBhdHRyaWJ1dGlvbkJvbGQ6IGZhbHNlIH07aWYgKFJHLlNWRy5GWCAmJiB0eXBlb2YgUkcuU1ZHLkZYLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7XG4gICAgfVxuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3RoaXMuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO2lmIChwcm9wLnZhcmlhbnQgIT09ICczZCcpIHtcbiAgICAgICAgcHJvcC52YXJpYW50M2RPZmZzZXR4ID0gMDtwcm9wLnZhcmlhbnQzZE9mZnNldHkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdmcuYWxsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3NrZXdZKDUpJyk7XG4gICAgICB9XG4gICAgICBSRy5TVkcuY3JlYXRlRGVmcyh0aGlzKTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7IG9iamVjdDogdGhpcyB9KTt0aGlzLnBhcnNlQ29sb3JzKCk7dmFyIHZhbHVlcyA9IFtdO2ZvciAodmFyIGkgPSAwLCBtYXggPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZGF0YVtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlNYXgodGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtYXggPSBSRy5TVkcuYXJyYXlNYXgodmFsdWVzKTtpZiAodHlwZW9mIHByb3AueWF4aXNNYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heCA9IHByb3AueWF4aXNNYXg7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC55YXhpc01pbiA9PT0gJ21pcnJvcicgfHwgcHJvcC55YXhpc01pbiA9PT0gJ21pZGRsZScgfHwgcHJvcC55YXhpc01pbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIG1pcnJvclNjYWxlID0gdHJ1ZTtwcm9wLnlheGlzTWluID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NhbGUgPSBSRy5TVkcuZ2V0U2NhbGUoeyBvYmplY3Q6IHRoaXMsIG51bWxhYmVsczogcHJvcC55YXhpc0xhYmVsc0NvdW50LCB1bml0c1ByZTogcHJvcC55YXhpc1VuaXRzUHJlLCB1bml0c1Bvc3Q6IHByb3AueWF4aXNVbml0c1Bvc3QsIG1heDogbWF4LCBtaW46IHByb3AueWF4aXNNaW4sIHBvaW50OiBwcm9wLnlheGlzUG9pbnQsIHJvdW5kOiBwcm9wLnlheGlzUm91bmQsIHRob3VzYW5kOiBwcm9wLnlheGlzVGhvdXNhbmQsIGRlY2ltYWxzOiBwcm9wLnlheGlzRGVjaW1hbHMsIHN0cmljdDogdHlwZW9mIHByb3AueWF4aXNNYXggPT09ICdudW1iZXInLCBmb3JtYXR0ZXI6IHByb3AueWF4aXNGb3JtYXR0ZXIgfSk7aWYgKG1pcnJvclNjYWxlKSB7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBSRy5TVkcuZ2V0U2NhbGUoeyBvYmplY3Q6IHRoaXMsIG51bWxhYmVsczogcHJvcC55YXhpc0xhYmVsc0NvdW50LCB1bml0c1ByZTogcHJvcC55YXhpc1VuaXRzUHJlLCB1bml0c1Bvc3Q6IHByb3AueWF4aXNVbml0c1Bvc3QsIG1heDogdGhpcy5zY2FsZS5tYXgsIG1pbjogdGhpcy5zY2FsZS5tYXggKiAtMSwgcG9pbnQ6IHByb3AueWF4aXNQb2ludCwgcm91bmQ6IGZhbHNlLCB0aG91c2FuZDogcHJvcC55YXhpc1Rob3VzYW5kLCBkZWNpbWFsczogcHJvcC55YXhpc0RlY2ltYWxzLCBzdHJpY3Q6IHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJywgZm9ybWF0dGVyOiBwcm9wLnlheGlzRm9ybWF0dGVyIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXggPSB0aGlzLnNjYWxlLm1heDt0aGlzLm1pbiA9IHRoaXMuc2NhbGUubWluO3Byb3AueWF4aXNNYXggPSB0aGlzLnNjYWxlLm1heDtwcm9wLnlheGlzTWluID0gdGhpcy5zY2FsZS5taW47UkcuU1ZHLmRyYXdCYWNrZ3JvdW5kKHRoaXMpO2lmIChwcm9wLnZhcmlhbnQgPT09ICczZCcpIHtcbiAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ00gezF9IHsyfSBMIHszfSB7NH0gTCB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCwgcHJvcC5ndXR0ZXJUb3AsIHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLnZhcmlhbnQzZE9mZnNldHksIHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgcHJvcC5ndXR0ZXJMZWZ0LCB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tLCBwcm9wLmd1dHRlckxlZnQsIHByb3AuZ3V0dGVyVG9wKSwgZmlsbDogJyNkZGQnLCBzdHJva2U6ICcjY2NjJyB9IH0pO3RoaXMudGhyZWVkX3hheGlzX2dyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdnJywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgY2xhc3NOYW1lOiAncmdyYXBoXzNkX2Jhcl94YXhpc19uZWdhdGl2ZScgfSB9KTtSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiAnTSB7MX0gezJ9IEwgezN9IHs0fSBMIHs1fSB7Nn0gTCB7N30gezh9Jy5mb3JtYXQocHJvcC5ndXR0ZXJMZWZ0LCB0aGlzLmdldFlDb29yZCgwKSwgcHJvcC5ndXR0ZXJMZWZ0ICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCB0aGlzLmdldFlDb29yZCgwKSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyUmlnaHQgKyBwcm9wLnZhcmlhbnQzZE9mZnNldHgsIHRoaXMuZ2V0WUNvb3JkKDApIC0gcHJvcC52YXJpYW50M2RPZmZzZXR5LCB0aGlzLndpZHRoIC0gcHJvcC5ndXR0ZXJSaWdodCwgdGhpcy5nZXRZQ29vcmQoMCksIHByb3AuZ3V0dGVyTGVmdCwgdGhpcy5nZXRZQ29vcmQoMCkpLCBmaWxsOiAnI2RkZCcsIHN0cm9rZTogJyNjY2MnIH0gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdCYXJzKCk7UkcuU1ZHLmRyYXdYQXhpcyh0aGlzKTtSRy5TVkcuZHJhd1lBeGlzKHRoaXMpO3RoaXMuZHJhd0xhYmVsc0Fib3ZlKCk7aWYgKHR5cGVvZiBwcm9wLmtleSAhPT0gbnVsbCAmJiBSRy5TVkcuZHJhd0tleSkge1xuICAgICAgICBSRy5TVkcuZHJhd0tleSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSkge1xuICAgICAgICBhbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hdHRyaWJ1dGlvbih0aGlzKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuZHJhd0JhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgeSA9IHRoaXMuZ2V0WUNvb3JkKDApO2lmIChwcm9wLnNoYWRvdykge1xuICAgICAgICBSRy5TVkcuc2V0U2hhZG93KHsgb2JqZWN0OiB0aGlzLCBvZmZzZXR4OiBwcm9wLnNoYWRvd09mZnNldHgsIG9mZnNldHk6IHByb3Auc2hhZG93T2Zmc2V0eSwgYmx1cjogcHJvcC5zaGFkb3dCbHVyLCBvcGFjaXR5OiBwcm9wLnNoYWRvd09wYWNpdHksIGlkOiAnZHJvcFNoYWRvdycgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgc2VxdWVudGlhbEluZGV4ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSwgKytzZXF1ZW50aWFsSW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFyIG91dGVyU2VnbWVudCA9IHRoaXMuZ3JhcGhXaWR0aCAvIHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgIGhlaWdodCA9IChtYS5hYnModGhpcy5kYXRhW2ldKSAtIG1hLmFicyh0aGlzLnNjYWxlLm1pbikpIC8gKG1hLmFicyh0aGlzLnNjYWxlLm1heCkgLSBtYS5hYnModGhpcy5zY2FsZS5taW4pKSAqIHRoaXMuZ3JhcGhIZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5ncmFwaFdpZHRoIC8gdGhpcy5kYXRhLmxlbmd0aCAtIHByb3AuaG1hcmdpbiAtIHByb3AuaG1hcmdpbixcbiAgICAgICAgICAgICAgeCA9IHByb3AuZ3V0dGVyTGVmdCArIHByb3AuaG1hcmdpbiArIG91dGVyU2VnbWVudCAqIGk7aWYgKHRoaXMuc2NhbGUubWluID49IDAgJiYgdGhpcy5zY2FsZS5tYXggPiAwKSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZS5taW4pIC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY2FsZS5taW4gPCAwICYmIHRoaXMuc2NhbGUubWF4ID4gMCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gbWEuYWJzKHRoaXMuZGF0YVtpXSkgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0O3kgPSB0aGlzLmdldFlDb29yZCgwKSAtIGhlaWdodDtpZiAodGhpcy5kYXRhW2ldIDwgMCkge1xuICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjYWxlLm1pbiA8IDAgJiYgdGhpcy5zY2FsZS5tYXggPCAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSAobWEuYWJzKHRoaXMuZGF0YVtpXSkgLSBtYS5hYnModGhpcy5zY2FsZS5tYXgpKSAvIChtYS5hYnModGhpcy5zY2FsZS5taW4pIC0gbWEuYWJzKHRoaXMuc2NhbGUubWF4KSkgKiB0aGlzLmdyYXBoSGVpZ2h0O3kgPSBwcm9wLmd1dHRlclRvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlY3QgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ3JlY3QnLCBwYXJlbnQ6IHByb3AudmFyaWFudCA9PT0gJzNkJyAmJiB0aGlzLmRhdGFbaV0gPCAwID8gdGhpcy50aHJlZWRfeGF4aXNfZ3JvdXAgOiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLCBmaWxsOiBwcm9wLmNvbG9yc1NlcXVlbnRpYWwgPyBwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdID8gcHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XSA6IHByb3AuY29sb3JzW3Byb3AuY29sb3JzLmxlbmd0aCAtIDFdIDogcHJvcC5jb2xvcnNbMF0sIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCA8IDAgPyAwIDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsICdkYXRhLW9yaWdpbmFsLXgnOiB4LCAnZGF0YS1vcmlnaW5hbC15JzogeSwgJ2RhdGEtb3JpZ2luYWwtd2lkdGgnOiB3aWR0aCwgJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzogaGVpZ2h0LCAnZGF0YS10b29sdGlwJzogIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPyBwcm9wLnRvb2x0aXBzW2ldIDogJycsICdkYXRhLWluZGV4JzogaSwgJ2RhdGEtc2VxdWVudGlhbC1pbmRleCc6IHNlcXVlbnRpYWxJbmRleCwgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV0sIGZpbHRlcjogcHJvcC5zaGFkb3cgPyAndXJsKCNkcm9wU2hhZG93KScgOiAnJyB9IH0pO3RoaXMuY29vcmRzLnB1c2goeyBvYmplY3Q6IHJlY3QsIHg6IHgsIHk6IHkgLSAodGhpcy5kYXRhW2ldID4gMCA/IGhlaWdodCA6IDApLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO2lmIChwcm9wLnZhcmlhbnQgPT09ICczZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1RvcDNkRmFjZSh7IHJlY3Q6IHJlY3QsIHZhbHVlOiB0aGlzLmRhdGFbaV0gfSk7dGhpcy5kcmF3U2lkZTNkRmFjZSh7IHJlY3Q6IHJlY3QsIHZhbHVlOiB0aGlzLmRhdGFbaV0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzOyhmdW5jdGlvbiAoaWR4LCBzZXEpIHtcbiAgICAgICAgICAgICAgcmVjdC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudC5yZXBsYWNlKC9eb24vLCAnJyksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGluZGV4OiBpZHgsIGdyb3VwOiBudWxsLCBzZXF1ZW50aWFsSW5kZXg6IHNlcSwgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLCBldmVudDogZSB9KTtvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSwgZmFsc2UpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0pKGksIHNlcXVlbnRpYWxJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgcHJvcC5ncm91cGluZyA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgdmFyIG91dGVyU2VnbWVudCA9IHRoaXMuZ3JhcGhXaWR0aCAvIHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgIGlubmVyU2VnbWVudCA9IG91dGVyU2VnbWVudCAtIDIgKiBwcm9wLmhtYXJnaW47Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2osICsrc2VxdWVudGlhbEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAoaW5uZXJTZWdtZW50IC0gKHRoaXMuZGF0YVtpXS5sZW5ndGggLSAxKSAqIHByb3AuaG1hcmdpbkdyb3VwZWQpIC8gdGhpcy5kYXRhW2ldLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB4ID0gb3V0ZXJTZWdtZW50ICogaSArIHByb3AuaG1hcmdpbiArIHByb3AuZ3V0dGVyTGVmdCArIGogKiB3aWR0aCArIChqIC0gMSkgKiBwcm9wLmhtYXJnaW5Hcm91cGVkO3ggPSBwcm9wLmd1dHRlckxlZnQgKyBvdXRlclNlZ21lbnQgKiBpICsgd2lkdGggKiBqICsgcHJvcC5obWFyZ2luICsgaiAqIHByb3AuaG1hcmdpbkdyb3VwZWQ7aWYgKHRoaXMuc2NhbGUubWluID09PSAwICYmIHRoaXMuc2NhbGUubWF4ID4gdGhpcy5zY2FsZS5taW4pIHtcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLmRhdGFbaV1bal0gLSB0aGlzLnNjYWxlLm1pbikgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0WUNvb3JkKDApIC0gaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjYWxlLm1heCA8PSAwICYmIHRoaXMuc2NhbGUubWluIDwgdGhpcy5zY2FsZS5tYXgpIHtcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLmRhdGFbaV1bal0gLSB0aGlzLnNjYWxlLm1heCkgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0WUNvb3JkKHRoaXMuc2NhbGUubWF4KTtoZWlnaHQgPSBtYS5hYnMoaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY2FsZS5tYXggPiAwICYmIHRoaXMuc2NhbGUubWluIDwgMCkge1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbWEuYWJzKHRoaXMuZGF0YVtpXVtqXSkgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeSA9IHRoaXMuZGF0YVtpXVtqXSA8IDAgPyB0aGlzLmdldFlDb29yZCgwKSA6IHRoaXMuZ2V0WUNvb3JkKHRoaXMuZGF0YVtpXVtqXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NhbGUubWluID4gMCAmJiB0aGlzLnNjYWxlLm1heCA+IHRoaXMuc2NhbGUubWluKSB7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBtYS5hYnModGhpcy5kYXRhW2ldW2pdIC0gdGhpcy5zY2FsZS5taW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gdGhpcy5zY2FsZS5taW4pICogdGhpcy5ncmFwaEhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZCh0aGlzLnNjYWxlLm1pbikgLSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHByb3AudmFyaWFudCA9PT0gJzNkJyAmJiB0aGlzLmRhdGFbaV1bal0gPCAwID8gdGhpcy50aHJlZWRfeGF4aXNfZ3JvdXAgOiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdyZWN0JywgYXR0cjogeyBzdHJva2U6IHByb3BbJ3N0cm9rZXN0eWxlJ10sIGZpbGw6IHByb3AuY29sb3JzU2VxdWVudGlhbCAmJiBwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdID8gcHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XSA6IHByb3AuY29sb3JzW2pdLCB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsICdkYXRhLW9yaWdpbmFsLXgnOiB4LCAnZGF0YS1vcmlnaW5hbC15JzogeSwgJ2RhdGEtb3JpZ2luYWwtd2lkdGgnOiB3aWR0aCwgJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzogaGVpZ2h0LCAnZGF0YS1pbmRleCc6IGksICdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnOiBzZXF1ZW50aWFsSW5kZXgsICdkYXRhLXRvb2x0aXAnOiAhUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzLmxlbmd0aCA/IHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSA6ICcnLCAnZGF0YS12YWx1ZSc6IHRoaXMuZGF0YVtpXVtqXSwgZmlsdGVyOiBwcm9wLnNoYWRvdyA/ICd1cmwoI2Ryb3BTaGFkb3cpJyA6ICcnIH0gfSk7dGhpcy5jb29yZHMucHVzaCh7IG9iamVjdDogcmVjdCwgeDogeCwgeTogeSAtICh0aGlzLmRhdGFbaV1bal0gPiAwID8gaGVpZ2h0IDogMCksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7aWYgKHByb3AudmFyaWFudCA9PT0gJzNkJykge1xuICAgICAgICAgICAgICB0aGlzLmRyYXdUb3AzZEZhY2UoeyByZWN0OiByZWN0LCB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdIH0pO3RoaXMuZHJhd1NpZGUzZEZhY2UoeyByZWN0OiByZWN0LCB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSkge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpczsoZnVuY3Rpb24gKGlkeCwgc2VxKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO3ZhciBpbmRleGVzID0gUkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsIG9iai5kYXRhKTtyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sICcnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIFJHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGdyb3VwOiBpZHgsIGluZGV4OiBpbmRleGVzWzFdLCBzZXF1ZW50aWFsSW5kZXg6IHNlcSwgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLCBldmVudDogZSB9KTtvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSkoaSwgc2VxdWVudGlhbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLS1zZXF1ZW50aWFsSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuZ3JhcGhXaWR0aCAvIHRoaXMuZGF0YS5sZW5ndGg7dmFyIHkgPSB0aGlzLmdldFlDb29yZCgwKTtmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraiwgKytzZXF1ZW50aWFsSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBtYS5yb3VuZCh0aGlzLmRhdGFbaV1bal0gLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNlY3Rpb24gLSAyICogcHJvcC5obWFyZ2luLFxuICAgICAgICAgICAgICAgIHggPSBwcm9wLmd1dHRlckxlZnQgKyBpICogc2VjdGlvbiArIHByb3AuaG1hcmdpbixcbiAgICAgICAgICAgICAgICB5ID0geSAtIGhlaWdodDtpZiAoaiA9PT0gMCAmJiBwcm9wLnNoYWRvdykge1xuICAgICAgICAgICAgICB2YXIgZnVsbEhlaWdodCA9IG1hLmFicyhSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMuZ3JhcGhIZWlnaHQpO3ZhciByZWN0ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncmVjdCcsIGF0dHI6IHsgZmlsbDogJ3doaXRlJywgeDogeCwgeTogdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSAtIGZ1bGxIZWlnaHQsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBmdWxsSGVpZ2h0LCAnc3Ryb2tlLXdpZHRoJzogMCwgJ2RhdGEtaW5kZXgnOiBpLCBmaWx0ZXI6ICd1cmwoI2Ryb3BTaGFkb3cpJyB9IH0pO3RoaXMuc3RhY2tlZEJhY2tmYWNlc1tpXSA9IHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3JlY3QnLCBhdHRyOiB7IHN0cm9rZTogcHJvcFsnc3Ryb2tlc3R5bGUnXSwgZmlsbDogcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XSA/IHByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0gOiBwcm9wLmNvbG9yc1twcm9wLmNvbG9ycy5sZW5ndGggLSAxXSA6IHByb3AuY29sb3JzW2pdLCB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsICdkYXRhLW9yaWdpbmFsLXgnOiB4LCAnZGF0YS1vcmlnaW5hbC15JzogeSwgJ2RhdGEtb3JpZ2luYWwtd2lkdGgnOiB3aWR0aCwgJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzogaGVpZ2h0LCAnZGF0YS1pbmRleCc6IGksICdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnOiBzZXF1ZW50aWFsSW5kZXgsICdkYXRhLXRvb2x0aXAnOiAhUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzLmxlbmd0aCA/IHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSA6ICcnLCAnZGF0YS12YWx1ZSc6IHRoaXMuZGF0YVtpXVtqXSB9IH0pO3RoaXMuY29vcmRzLnB1c2goeyBvYmplY3Q6IHJlY3QsIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7aWYgKHByb3AudmFyaWFudCA9PT0gJzNkJykge1xuICAgICAgICAgICAgICB0aGlzLmRyYXdUb3AzZEZhY2UoeyByZWN0OiByZWN0LCB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdIH0pO3RoaXMuZHJhd1NpZGUzZEZhY2UoeyByZWN0OiByZWN0LCB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSkge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpczsoZnVuY3Rpb24gKGlkeCwgc2VxKSB7XG4gICAgICAgICAgICAgICAgcmVjdC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudC5yZXBsYWNlKC9eb24vLCAnJyksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7dmFyIGluZGV4ZXMgPSBSRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKHNlcSwgb2JqLmRhdGEpO1JHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGluZGV4OiBpbmRleGVzWzFdLCBncm91cDogaWR4LCBzZXF1ZW50aWFsSW5kZXg6IHNlcSwgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLCBldmVudDogZSB9KTtvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSkoaSwgc2VxdWVudGlhbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLS1zZXF1ZW50aWFsSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O3RoaXMuZ2V0WUNvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPiB0aGlzLnNjYWxlLm1heCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB5LFxuICAgICAgICAgIHhheGlzcG9zID0gcHJvcC54YXhpc3BvcztpZiAodmFsdWUgPCB0aGlzLnNjYWxlLm1pbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSAodmFsdWUgLSB0aGlzLnNjYWxlLm1pbikgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbik7eSAqPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207eSA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gLSB5O3JldHVybiB5O1xuICAgIH07dGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgdmFyIHggPSByZWN0LmdldEF0dHJpYnV0ZSgneCcpLFxuICAgICAgICAgIHkgPSByZWN0LmdldEF0dHJpYnV0ZSgneScpLFxuICAgICAgICAgIHdpZHRoID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO3ZhciBoaWdobGlnaHQgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdyZWN0JywgYXR0cjogeyBzdHJva2U6IHByb3AuaGlnaGxpZ2h0U3Ryb2tlLCBmaWxsOiBwcm9wLmhpZ2hsaWdodEZpbGwsIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsICdzdHJva2Utd2lkdGgnOiBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aCB9IH0pO2lmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdtb3VzZW1vdmUnKSB7fVxuICAgICAgUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIGhpZ2hsaWdodCk7XG4gICAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyA9IHsgY29sb3JzOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksIGJhY2tncm91bmRHcmlkQ29sb3I6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciksIGhpZ2hsaWdodEZpbGw6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksIGJhY2tncm91bmRDb2xvcjogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpIH07XG4gICAgICB9XG4gICAgICB2YXIgY29sb3JzID0gcHJvcC5jb2xvcnM7aWYgKGNvbG9ycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbG9yc1tpXSA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogY29sb3JzW2ldIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciB9KTtwcm9wLmhpZ2hsaWdodEZpbGwgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuaGlnaGxpZ2h0RmlsbCB9KTtwcm9wLmJhY2tncm91bmRDb2xvciA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogcHJvcC5iYWNrZ3JvdW5kQ29sb3IgfSk7XG4gICAgfTt0aGlzLmRyYXdMYWJlbHNBYm92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9wLmxhYmVsc0Fib3ZlKSB7XG4gICAgICAgIHZhciBkYXRhX3NlcSA9IFJHLlNWRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLFxuICAgICAgICAgICAgc2VxID0gMCxcbiAgICAgICAgICAgIHN0YWNrZWRfdG90YWwgPSAwOztmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29vcmRzLmxlbmd0aDsgKytpLCBzZXErKykge1xuICAgICAgICAgIHZhciBudW0gPSB0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnbnVtYmVyJyA/IHRoaXMuZGF0YVtpXSA6IGRhdGFfc2VxW3NlcV07aWYgKHByb3AuZ3JvdXBpbmcgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBSRy5TVkcuc2VxdWVudGlhbEluZGV4VG9Hcm91cGVkKGksIHRoaXMuZGF0YSk7dmFyIGdyb3VwID0gaW5kZXhlc1swXTt2YXIgZGF0YXBpZWNlID0gaW5kZXhlc1sxXTtpZiAoZGF0YXBpZWNlICE9PSB0aGlzLmRhdGFbZ3JvdXBdLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBudW0gPSBSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2dyb3VwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHIgPSBSRy5TVkcubnVtYmVyRm9ybWF0KHsgb2JqZWN0OiB0aGlzLCBudW06IG51bS50b0ZpeGVkKHByb3AubGFiZWxzQWJvdmVEZWNpbWFscyksIHByZXBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlVW5pdHNQcmUgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNBYm92ZVVuaXRzUHJlIDogbnVsbCwgYXBwZW5kOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0Fib3ZlVW5pdHNQb3N0IDogbnVsbCwgcG9pbnQ6IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlUG9pbnQgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNBYm92ZVBvaW50IDogbnVsbCwgdGhvdXNhbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlVGhvdXNhbmQgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNBYm92ZVRob3VzYW5kIDogbnVsbCwgZm9ybWF0dGVyOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3AubGFiZWxzQWJvdmVGb3JtYXR0ZXIgOiBudWxsIH0pO2lmIChwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMgJiYgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljLmxlbmd0aCAmJiAodHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV0gPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgc3RyID0gcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV07XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMgJiYgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljLmxlbmd0aCAmJiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneCcpKSArIHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDIpICsgcHJvcC5sYWJlbHNBYm92ZU9mZnNldHg7aWYgKGRhdGFfc2VxW2ldID49IDApIHtcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpIC0gNyArIHByb3AubGFiZWxzQWJvdmVPZmZzZXR5O3ZhciB2YWxpZ24gPSBwcm9wLmxhYmVsc0Fib3ZlVmFsaWduO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneScpKSArIHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpICsgNyAtIHByb3AubGFiZWxzQWJvdmVPZmZzZXR5O3ZhciB2YWxpZ24gPSBwcm9wLmxhYmVsc0Fib3ZlVmFsaWduID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogc3RyLCB4OiB4LCB5OiB5LCBoYWxpZ246IHByb3AubGFiZWxzQWJvdmVIYWxpZ24sIHZhbGlnbjogdmFsaWduLCBmb250OiBwcm9wLmxhYmVsc0Fib3ZlRm9udCB8fCBwcm9wLnRleHRGb250LCBzaXplOiBwcm9wLmxhYmVsc0Fib3ZlU2l6ZSB8fCBwcm9wLnRleHRTaXplLCBib2xkOiBwcm9wLmxhYmVsc0Fib3ZlQm9sZCB8fCBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHByb3AubGFiZWxzQWJvdmVJdGFsaWMgfHwgcHJvcC50ZXh0SXRhbGljLCBjb2xvcjogcHJvcC5sYWJlbHNBYm92ZUNvbG9yIHx8IHByb3AudGV4dENvbG9yLCBiYWNrZ3JvdW5kOiBwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZCB8fCBudWxsLCBwYWRkaW5nOiBwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZFBhZGRpbmcgfHwgMCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtpZiAoaGlnaGxpZ2h0ICYmIGhpZ2hsaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZ2hsaWdodCk7XG4gICAgICB9XG4gICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgfTt0aGlzLmRyYXdUb3AzZEZhY2UgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICB2YXIgcmVjdCA9IG9wdC5yZWN0LFxuICAgICAgICAgIGFyciA9IFtwYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpKSwgJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSddLFxuICAgICAgICAgIHggPSBwYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgneCcpKSxcbiAgICAgICAgICB5ID0gcGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ3knKSksXG4gICAgICAgICAgdyA9IHBhcnNlSW50KHJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSxcbiAgICAgICAgICBoID0gcGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtyZWN0LnJncmFwaF8zZF90b3BfZmFjZSA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGkgPT09IDAgPyByZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpIDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSc7dmFyIGZhY2UgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ3BhdGgnLCBwYXJlbnQ6IHByb3AudmFyaWFudCA9PT0gJzNkJyAmJiBvcHQudmFsdWUgPCAwID8gdGhpcy50aHJlZWRfeGF4aXNfZ3JvdXAgOiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLCBmaWxsOiBjb2xvciwgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLCBkOiAnTSB7MX0gezJ9IEwgezN9IHs0fSBMIHs1fSB7Nn0gTCB7N30gezh9Jy5mb3JtYXQoeCwgeSwgeCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgeSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgeCArIHcgKyBwcm9wLnZhcmlhbnQzZE9mZnNldHgsIHkgLSBwcm9wLnZhcmlhbnQzZE9mZnNldHksIHggKyB3LCB5KSB9IH0pO3JlY3QucmdyYXBoXzNkX3RvcF9mYWNlW2ldID0gZmFjZTtcbiAgICAgIH1cbiAgICB9O3RoaXMuZHJhd1NpZGUzZEZhY2UgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICB2YXIgcmVjdCA9IG9wdC5yZWN0LFxuICAgICAgICAgIGFyciA9IFtwYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgnZmlsbCcpKSwgJ3JnYmEoMCwwLDAsMC4zKSddLFxuICAgICAgICAgIHggPSBwYXJzZUludChyZWN0LmdldEF0dHJpYnV0ZSgneCcpKSxcbiAgICAgICAgICB5ID0gcGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ3knKSksXG4gICAgICAgICAgdyA9IHBhcnNlSW50KHJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSxcbiAgICAgICAgICBoID0gcGFyc2VJbnQocmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtyZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2UgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICB2YXIgY29sb3IgPSBpID09PSAwID8gcmVjdC5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKSA6ICdyZ2JhKDAsMCwwLDAuMyknO3ZhciBmYWNlID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdwYXRoJywgcGFyZW50OiBwcm9wLnZhcmlhbnQgPT09ICczZCcgJiYgb3B0LnZhbHVlIDwgMCA/IHRoaXMudGhyZWVkX3hheGlzX2dyb3VwIDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IHN0cm9rZTogcHJvcC5zdHJva2VzdHlsZSwgZmlsbDogY29sb3IsICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCwgZDogJ00gezF9IHsyfSBMIHszfSB7NH0gTCB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KHggKyB3LCB5LCB4ICsgdyArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgeSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgeCArIHcgKyBwcm9wLnZhcmlhbnQzZE9mZnNldHgsIHkgKyBoIC0gcHJvcC52YXJpYW50M2RPZmZzZXR5LCB4ICsgdywgeSArIGgpIH0gfSk7cmVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlW2ldID0gZmFjZTtcbiAgICAgIH1cbiAgICB9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCAzMCxcbiAgICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgICAgb2JqID0gdGhpcyxcbiAgICAgICAgICBkYXRhID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gbnVsbCxcbiAgICAgICAgICBzZXEgPSAwO2RhdGEgPSBSRy5TVkcuYXJyYXlDbG9uZSh0aGlzLmRhdGEpO3RoaXMuZHJhdygpO3ZhciBpdGVyYXRlID0gZnVuY3Rpb24gaXRlcmF0ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHNlcSA9IDAsIGxlbiA9IG9iai5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyArK2ksICsrc2VxKSB7XG4gICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBmcmFtZSAvIGZyYW1lcyAqIFJHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcywgZnJhbWUpICogUkcuU1ZHLkZYLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLCBmcmFtZSk7aWYgKHR5cGVvZiBkYXRhW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gbWEuYWJzKG9iai5nZXRZQ29vcmQoZGF0YVtpXSkgLSBvYmouZ2V0WUNvb3JkKDApKTtvYmouZGF0YVtpXSA9IGRhdGFbaV0gKiBtdWx0aXBsaWVyO2hlaWdodCA9IG11bHRpcGxpZXIgKiBoZWlnaHQ7b2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7b2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3knLCBkYXRhW2ldIDwgMCA/IG9iai5nZXRZQ29vcmQoMCkgOiBvYmouZ2V0WUNvb3JkKDApIC0gaGVpZ2h0KTtpZiAocHJvcC52YXJpYW50ID09PSAnM2QnKSB7XG4gICAgICAgICAgICAgIGlmIChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdLnBhcmVudE5vZGUpIG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdKTtpZiAob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlKSBvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXSk7aWYgKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVswXS5wYXJlbnROb2RlKSBvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0pO2lmIChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMV0ucGFyZW50Tm9kZSkgb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdKTtvYmouZHJhd1NpZGUzZEZhY2UoeyByZWN0OiBvYmouY29vcmRzW2ldLm9iamVjdCB9KTtpZiAocHJvcC5ncm91cGluZyA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICAgICAgb2JqLmRyYXdUb3AzZEZhY2UoeyByZWN0OiBvYmouY29vcmRzW2ldLm9iamVjdCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2JqLmNvb3Jkc1tpXS5vYmplY3QucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBvYmouY29vcmRzW2ldLm9iamVjdC5wYXJlbnROb2RlO3ZhciBub2RlID0gcGFyZW50LnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0KTtwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoZGF0YVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0aXZlSGVpZ2h0ID0gMDtmb3IgKHZhciBqID0gMCwgbGVuMiA9IGRhdGFbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgKytqLCArK3NlcSkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBtYS5hYnMob2JqLmdldFlDb29yZChkYXRhW2ldW2pdKSAtIG9iai5nZXRZQ29vcmQoMCkpO2hlaWdodCA9IG11bHRpcGxpZXIgKiBoZWlnaHQ7b2JqLmRhdGFbaV1bal0gPSBkYXRhW2ldW2pdICogbXVsdGlwbGllcjtoZWlnaHQgPSBtYS5yb3VuZChoZWlnaHQpO29iai5jb29yZHNbc2VxXS5vYmplY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO29iai5jb29yZHNbc2VxXS5vYmplY3Quc2V0QXR0cmlidXRlKCd5JywgZGF0YVtpXVtqXSA8IDAgPyBvYmouZ2V0WUNvb3JkKDApICsgYWNjdW11bGF0aXZlSGVpZ2h0IDogb2JqLmdldFlDb29yZCgwKSAtIGhlaWdodCAtIGFjY3VtdWxhdGl2ZUhlaWdodCk7aWYgKHByb3AudmFyaWFudCA9PT0gJzNkJykge1xuICAgICAgICAgICAgICAgIGlmIChvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0ucGFyZW50Tm9kZSkgb2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdKTtpZiAob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzFdLnBhcmVudE5vZGUpIG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXSk7aWYgKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdLnBhcmVudE5vZGUpIG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0pO2lmIChvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXS5wYXJlbnROb2RlKSBvYmouY29vcmRzW3NlcV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdKTtvYmouZHJhd1NpZGUzZEZhY2UoeyByZWN0OiBvYmouY29vcmRzW3NlcV0ub2JqZWN0IH0pO29iai5kcmF3VG9wM2RGYWNlKHsgcmVjdDogb2JqLmNvb3Jkc1tzZXFdLm9iamVjdCB9KTtpZiAob2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5wYXJlbnROb2RlO3ZhciBub2RlID0gcGFyZW50LnJlbW92ZUNoaWxkKG9iai5jb29yZHNbc2VxXS5vYmplY3QpO3BhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWNjdW11bGF0aXZlSGVpZ2h0ICs9IHByb3AuZ3JvdXBpbmcgPT09ICdzdGFja2VkJyA/IGhlaWdodCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnN0YWNrZWRCYWNrZmFjZXNbaV0pIHtcbiAgICAgICAgICAgICAgb2JqLnN0YWNrZWRCYWNrZmFjZXNbaV0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBhY2N1bXVsYXRpdmVIZWlnaHQpO29iai5zdGFja2VkQmFja2ZhY2VzW2ldLnNldEF0dHJpYnV0ZSgneScsIG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSAtIGFjY3VtdWxhdGl2ZUhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLXNlcTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgICBSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC5jYWxsYmFjaykge1xuICAgICAgICAgIG9wdC5jYWxsYmFjayhvYmopO1xuICAgICAgICB9XG4gICAgICB9O2l0ZXJhdGUoKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMud2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZHJhdygpO3ZhciBvYmogPSB0aGlzLFxuICAgICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTtvcHQuZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MDtvcHQuc3RhcnRGcmFtZXMgPSBbXTtvcHQuY291bnRlcnMgPSBbXTt2YXIgZnJhbWVzcGVyYmFyID0gb3B0LmZyYW1lcyAvIDMsXG4gICAgICAgICAgZnJhbWUgPSAtMSxcbiAgICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgb3B0LnN0YXJ0RnJhbWVzW2ldID0gb3B0LmZyYW1lcyAvIDIgLyAob2JqLmNvb3Jkcy5sZW5ndGggLSAxKSAqIGk7b3B0LmNvdW50ZXJzW2ldID0gMDt0aGlzLmNvb3Jkc1tpXS5vYmplY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAwKTtpZiAodGhpcy5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2UpIHtcbiAgICAgICAgICB0aGlzLnN2Zy5hbGwucmVtb3ZlQ2hpbGQodGhpcy5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMF0pO3RoaXMuc3ZnLmFsbC5yZW1vdmVDaGlsZCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXSk7dGhpcy5zdmcuYWxsLnJlbW92ZUNoaWxkKHRoaXMuY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0pO3RoaXMuc3ZnLmFsbC5yZW1vdmVDaGlsZCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICsrZnJhbWU7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5jb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoZnJhbWUgPiBvcHQuc3RhcnRGcmFtZXNbaV0pIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IG9iai5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1oZWlnaHQnKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KG9iai5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpKTt2YXIgaGVpZ2h0ID0gbWEubWluKChmcmFtZSAtIG9wdC5zdGFydEZyYW1lc1tpXSkgLyBmcmFtZXNwZXJiYXIgKiBvcmlnaW5hbEhlaWdodCwgb3JpZ2luYWxIZWlnaHQpO29iai5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0IDwgMCA/IDAgOiBoZWlnaHQpO29iai5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgneScsIHZhbHVlID49IDAgPyBvYmouZ2V0WUNvb3JkKDApIC0gaGVpZ2h0IDogb2JqLmdldFlDb29yZCgwKSk7aWYgKHByb3AudmFyaWFudCA9PT0gJzNkJykge1xuICAgICAgICAgICAgICBpZiAob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVswXS5wYXJlbnROb2RlKSBvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2Rfc2lkZV9mYWNlWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVswXSk7aWYgKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMV0ucGFyZW50Tm9kZSkgb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3NpZGVfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF9zaWRlX2ZhY2VbMV0pO2lmIChvYmouY29vcmRzW2ldLm9iamVjdC5yZ3JhcGhfM2RfdG9wX2ZhY2VbMF0ucGFyZW50Tm9kZSkgb2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzBdKTtpZiAob2JqLmNvb3Jkc1tpXS5vYmplY3QucmdyYXBoXzNkX3RvcF9mYWNlWzFdLnBhcmVudE5vZGUpIG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iai5jb29yZHNbaV0ub2JqZWN0LnJncmFwaF8zZF90b3BfZmFjZVsxXSk7aWYgKG9iai5jb29yZHNbaV0ub2JqZWN0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmNvb3Jkc1tpXS5vYmplY3QucGFyZW50Tm9kZTt2YXIgbm9kZSA9IHBhcmVudC5yZW1vdmVDaGlsZChvYmouY29vcmRzW2ldLm9iamVjdCk7cGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcC5ncm91cGluZyA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICAgICAgICAgIHZhciBzZXEgPSBvYmouY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VxdWVudGlhbC1pbmRleCcpO3ZhciBpbmRleGVzID0gUkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsIG9iai5kYXRhKTtpZiAoaW5kZXhlc1sxXSA+IDApIHtcbiAgICAgICAgICAgICAgICBvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3knLCBwYXJzZUludChvYmouY29vcmRzW2kgLSAxXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpIC0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJzNkJykge1xuICAgICAgICAgICAgICBvYmouZHJhd1NpZGUzZEZhY2UoeyByZWN0OiBvYmouY29vcmRzW2ldLm9iamVjdCB9KTtpZiAocHJvcC5ncm91cGluZyA9PT0gJ2dyb3VwZWQnIHx8IHByb3AuZ3JvdXBpbmcgPT09ICdzdGFja2VkJyAmJiBpbmRleGVzWzFdICsgMSA9PT0gb2JqLmRhdGFbaW5kZXhlc1swXV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqLmRyYXdUb3AzZEZhY2UoeyByZWN0OiBvYmouY29vcmRzW2ldLm9iamVjdCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWUgPj0gb3B0LmZyYW1lcykge1xuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gICAgfTtmb3IgKGkgaW4gY29uZi5vcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3JldHVybiB0aGlzO1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5iYXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///204\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.AJAX = RGraph.SVG.AJAX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.AJAX = function (url, callback) {\n    if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('GET', url, true);httpRequest.send();\n  };RG.SVG.AJAX.POST = function (url, data, callback) {\n    var crumbs = [];if (window.XMLHttpRequest) {\n      var httpRequest = new XMLHttpRequest();\n    } else if (window.ActiveXObject) {\n      var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    httpRequest.onreadystatechange = function () {\n      if (this.readyState == 4 && this.status == 200) {\n        this.__user_callback__ = callback;this.__user_callback__(this.responseText);\n      }\n    };\n    httpRequest.open('POST', url, true);httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");for (i in data) {\n      if (typeof i == 'string') {\n        crumbs.push(i + '=' + encodeURIComponent(data[i]));\n      }\n    }\n    httpRequest.send(crumbs.join('&'));\n  };RG.SVG.AJAX.getNumber = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var num = parseFloat(this.responseText);callback(num);\n    });\n  };RG.SVG.AJAX.getString = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var str = String(this.responseText);callback(str);\n    });\n  };RG.SVG.AJAX.getJSON = function (url, callback) {\n    RG.SVG.AJAX(url, function () {\n      var json = eval('(' + this.responseText + ')');callback(json);\n    });\n  };RG.SVG.AJAX.getCSV = function (url, callback) {\n    var seperator = typeof arguments[2] === 'string' ? arguments[2] : ',',\n        lineSep = typeof arguments[3] === 'string' ? arguments[3] : \"\\r?\\n\";RG.SVG.AJAX(url, function () {\n      var text = this.responseText,\n          regexp = new RegExp(seperator),\n          lines = this.responseText.split(lineSep),\n          rows = [];for (var i = 0; i < lines.length; ++i) {\n        var row = lines[i].split(seperator);for (var j = 0, len = row.length; j < len; ++j) {\n          if (row[j].match(/^[0-9.]+$/)) {\n            row[j] = parseFloat(row[j]);\n          }\n        }\n        rows.push(row);\n      }\n      callback(rows);\n    });\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmFqYXguanM/MmZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSwgaXNSR3JhcGhTVkc6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTtSR3JhcGguU1ZHLkFKQVggPSBSR3JhcGguU1ZHLkFKQVggfHwge307KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy5TVkcuQUpBWCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICB9XG4gICAgaHR0cFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICB0aGlzLl9fdXNlcl9jYWxsYmFja19fID0gY2FsbGJhY2s7dGhpcy5fX3VzZXJfY2FsbGJhY2tfXyh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBodHRwUmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO2h0dHBSZXF1ZXN0LnNlbmQoKTtcbiAgfTtSRy5TVkcuQUpBWC5QT1NUID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY3J1bWJzID0gW107aWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgdmFyIGh0dHBSZXF1ZXN0ID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICB9XG4gICAgaHR0cFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICB0aGlzLl9fdXNlcl9jYWxsYmFja19fID0gY2FsbGJhY2s7dGhpcy5fX3VzZXJfY2FsbGJhY2tfXyh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBodHRwUmVxdWVzdC5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtodHRwUmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO2ZvciAoaSBpbiBkYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIGkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY3J1bWJzLnB1c2goaSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGh0dHBSZXF1ZXN0LnNlbmQoY3J1bWJzLmpvaW4oJyYnKSk7XG4gIH07UkcuU1ZHLkFKQVguZ2V0TnVtYmVyID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgICBSRy5TVkcuQUpBWCh1cmwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhudW0pO1xuICAgIH0pO1xuICB9O1JHLlNWRy5BSkFYLmdldFN0cmluZyA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgUkcuU1ZHLkFKQVgodXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyID0gU3RyaW5nKHRoaXMucmVzcG9uc2VUZXh0KTtjYWxsYmFjayhzdHIpO1xuICAgIH0pO1xuICB9O1JHLlNWRy5BSkFYLmdldEpTT04gPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIFJHLlNWRy5BSkFYKHVybCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGpzb24gPSBldmFsKCcoJyArIHRoaXMucmVzcG9uc2VUZXh0ICsgJyknKTtjYWxsYmFjayhqc29uKTtcbiAgICB9KTtcbiAgfTtSRy5TVkcuQUpBWC5nZXRDU1YgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBzZXBlcmF0b3IgPSB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnc3RyaW5nJyA/IGFyZ3VtZW50c1syXSA6ICcsJyxcbiAgICAgICAgbGluZVNlcCA9IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdzdHJpbmcnID8gYXJndW1lbnRzWzNdIDogXCJcXHI/XFxuXCI7UkcuU1ZHLkFKQVgodXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMucmVzcG9uc2VUZXh0LFxuICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoc2VwZXJhdG9yKSxcbiAgICAgICAgICBsaW5lcyA9IHRoaXMucmVzcG9uc2VUZXh0LnNwbGl0KGxpbmVTZXApLFxuICAgICAgICAgIHJvd3MgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByb3cgPSBsaW5lc1tpXS5zcGxpdChzZXBlcmF0b3IpO2ZvciAodmFyIGogPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICBpZiAocm93W2pdLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgcm93W2pdID0gcGFyc2VGbG9hdChyb3dbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHJvd3MpO1xuICAgIH0pO1xuICB9O1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24uYWpheC5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///205\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.REG = { store: [] };RG.SVG.OR = { objects: [] };RG.SVG.TRIG = {};RG.SVG.TRIG.HALFPI = ma.PI * .4999;RG.SVG.TRIG.PI = RG.SVG.TRIG.HALFPI * 2;RG.SVG.TRIG.TWOPI = RG.SVG.TRIG.PI * 2;RG.SVG.ISIE = ua.indexOf('rident') > 0;RG.SVG.ISFF = ua.indexOf('irefox') > 0;RG.SVG.events = [];RG.SVG.ISFF = ua.indexOf('Firefox') != -1;RG.SVG.ISOPERA = ua.indexOf('Opera') != -1;RG.SVG.ISCHROME = ua.indexOf('Chrome') != -1;RG.SVG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;RG.SVG.ISWEBKIT = ua.indexOf('WebKit') != -1;RG.SVG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;RG.SVG.ISIE6 = ua.indexOf('MSIE 6') > 0;RG.SVG.ISIE7 = ua.indexOf('MSIE 7') > 0;RG.SVG.ISIE8 = ua.indexOf('MSIE 8') > 0;RG.SVG.ISIE9 = ua.indexOf('MSIE 9') > 0;RG.SVG.ISIE10 = ua.indexOf('MSIE 10') > 0;RG.SVG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;RG.SVG.ISIE10UP = RG.SVG.ISIE10 || RG.SVG.ISIE11UP;RG.SVG.ISIE9UP = RG.SVG.ISIE9 || RG.SVG.ISIE10UP;RG.SVG.createSVG = function (opt) {\n    var container = opt.container;if (container.__svg__) {\n      return container.__svg__;\n    }\n    var svg = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");svg.setAttribute('style', 'top: 0; left: 0; position: absolute');svg.setAttribute('width', container.offsetWidth);svg.setAttribute('height', container.offsetHeight);svg.setAttribute('version', '1.1');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", 'xmlns', 'http://www.w3.org/2000/svg');svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");container.appendChild(svg);container.__svg__ = svg;container.style.position = 'relative';var group = RG.SVG.create({ svg: svg, type: 'g', attr: { className: 'all-elements' } });container.__svg__.all = group;return svg;\n  };RG.SVG.createDefs = function (obj) {\n    if (!obj.svg.defs) {\n      var defs = RG.SVG.create({ svg: obj.svg, type: 'defs' });obj.svg.defs = defs;\n    }\n    return defs;\n  };RG.SVG.create = function (opt) {\n    var ns = \"http://www.w3.org/2000/svg\",\n        tag = doc.createElementNS(ns, opt.type);for (var o in opt.attr) {\n      if (typeof o === 'string') {\n        var name = o;if (o === 'className') {\n          name = 'class';\n        }\n        if ((opt.type === 'a' || opt.type === 'image') && o === 'xlink:href') {\n          tag.setAttributeNS('http://www.w3.org/1999/xlink', o, String(opt.attr[o]));\n        } else {\n          tag.setAttribute(name, String(opt.attr[o]));\n        }\n      }\n    }\n    for (var o in opt.style) {\n      if (typeof o === 'string') {\n        tag.style[o] = String(opt.style[o]);\n      }\n    }\n    if (opt.parent) {\n      opt.parent.appendChild(tag);\n    } else {\n      opt.svg.appendChild(tag);\n    }\n    return tag;\n  };RG.SVG.drawXAxis = function (obj) {\n    var prop = obj.properties;if (prop.xaxis) {\n      var y = obj.type === 'hbar' ? obj.height - prop.gutterBottom : obj.getYCoord(obj.scale.min < 0 && obj.scale.max < 0 ? obj.scale.max : obj.scale.min > 0 && obj.scale.max > 0 ? obj.scale.min : 0);var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft, y + 0.01, obj.width - prop.gutterRight, y), fill: prop.xaxisColor, stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': 'crispEdges', 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.height - prop.gutterBottom,\n            endY = obj.height - prop.gutterBottom + prop.xaxisTickmarksLength;\n      } else {\n        var width = obj.graphWidth / obj.data.length,\n            x = prop.gutterLeft,\n            startY = obj.getYCoord(0) - (prop.yaxisMin < 0 ? prop.xaxisTickmarksLength : 0),\n            endY = obj.getYCoord(0) + prop.xaxisTickmarksLength;if (obj.scale.min < 0 && obj.scale.max <= 0) {\n          startY = prop.gutterTop;endY = prop.gutterTop - prop.xaxisTickmarksLength;\n        }\n        if (obj.scale.min > 0 && obj.scale.max > 0) {\n          startY = obj.getYCoord(obj.scale.min);endY = obj.getYCoord(obj.scale.min) + prop.xaxisTickmarksLength;\n        }\n      }\n      if (prop.xaxisTickmarks) {\n        if (prop.xaxisScale) {\n          for (var i = 0; i < obj.scale.numlabels + (prop.yaxis && prop.xaxisMin === 0 ? 0 : 1); ++i) {\n            if (obj.type === 'hbar') {\n              var dataPoints = obj.data.length;\n            }\n            x = prop.gutterLeft + (i + (prop.yaxis && prop.xaxisMin === 0 ? 1 : 0)) * (obj.graphWidth / obj.scale.numlabels);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        } else {\n          if (prop.xaxisLabelsPosition === 'section') {\n            if (obj.type === 'bar' || obj.type === 'waterfall') {\n              var dataPoints = obj.data.length;\n            } else if (obj.type === 'line') {\n              var dataPoints = obj.data[0].length;\n            } else if (obj.type === 'scatter') {\n              var dataPoints = prop.xaxisLabels ? prop.xaxisLabels.length : 10;\n            }\n            for (var i = 0; i < dataPoints; ++i) {\n              x = prop.gutterLeft + (i + 1) * (obj.graphWidth / dataPoints);RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          } else if (prop.xaxisLabelsPosition === 'edge') {\n            if (typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number') {\n              var len = prop.xaxisLabelsPositionEdgeTickmarksCount;\n            } else {\n              var len = obj.data && obj.data[0] && obj.data[0].length ? obj.data[0].length : 0;\n            }\n            for (var i = 0; i < len; ++i) {\n              var gap = obj.graphWidth / (len - 1),\n                  x = prop.gutterLeft + (i + 1) * gap;RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x + 0.001, startY, x, endY), stroke: prop.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n            }\n          }\n        }\n        if (prop.yaxis === false) {\n          RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft + 0.001, startY, prop.gutterLeft, endY), stroke: obj.properties.xaxisColor, 'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", parent: obj.svg.all } });\n        }\n      }\n    }\n    if (prop.xaxisScale) {\n      var segment = obj.graphWidth / prop.xaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var x = prop.gutterLeft + segment * i + segment + prop.xaxisLabelsOffsetx;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: x, y: obj.height - prop.gutterBottom + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n      if (prop.xaxisLabelsCount > 0) {\n        var y = obj.height - prop.gutterBottom + prop.xaxisLabelsOffsety + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10),\n            str = RG.SVG.numberFormat({ object: obj, num: prop.xaxisMin.toFixed(prop.xaxisDecimals), prepend: prop.xaxisUnitsPre, append: prop.xaxisUnitsPost, point: prop.xaxisPoint, thousand: prop.xaxisThousand, formatter: prop.xaxisFormatter });var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.xaxisFormatter === 'function' ? prop.xaxisFormatter(this, prop.xaxisMin) : str, x: prop.gutterLeft + prop.xaxisLabelsOffsetx, y: y, halign: 'center', valign: 'top', font: prop.xaxisTextFont || prop.textFont, size: prop.xaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.xaxisTextBold || prop.textBold, italic: prop.xaxisTextItalic || prop.textItalic, color: prop.xaxisTextColor || prop.textColor });\n      }\n    } else {\n      if (_typeof(prop.xaxisLabels) === 'object' && !RG.SVG.isNull(prop.xaxisLabels)) {\n        if (prop.xaxisLabelsPosition === 'section') {\n          var segment = (obj.width - prop.gutterLeft - prop.gutterRight) / prop.xaxisLabels.length;for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + segment / 2 + i * segment;if (obj.scale.max <= 0 && obj.scale.min < obj.scale.max) {\n              var y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'bottom';\n            } else {\n              var y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;var valign = 'top';\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        } else if (prop.xaxisLabelsPosition === 'edge') {\n          if (obj.type === 'line') {\n            var hmargin = prop.hmargin;\n          } else {\n            var hmargin = 0;\n          }\n          var segment = (obj.graphWidth - hmargin - hmargin) / (prop.xaxisLabels.length - 1);for (var i = 0; i < prop.xaxisLabels.length; ++i) {\n            var x = prop.gutterLeft + i * segment + hmargin;if (obj.scale.max <= 0 && obj.scale.min < 0) {\n              valign = 'bottom';y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisTickmarksLength - 5) - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            } else {\n              valign = 'top';y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisTickmarksLength - 5) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;\n            }\n            RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.xaxisLabels[i], x: x + prop.xaxisLabelsOffsetx, y: y, valign: valign, halign: 'center', size: prop.xaxisTextSize || prop.textSize, italic: prop.xaxisTextItalic || prop.textItalic, font: prop.xaxisTextFont || prop.textFont, bold: prop.xaxisTextBold || prop.textBold, color: prop.xaxisTextColor || prop.textColor });\n          }\n        }\n      }\n    }\n  };RG.SVG.drawYAxis = function (obj) {\n    var prop = obj.properties;if (prop.yaxis) {\n      if (obj.type === 'hbar') {\n        var x = obj.getXCoord(prop.xaxisMin > 0 ? prop.xaxisMin : 0);if (prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          x = obj.getXCoord(prop.xaxisMax);\n        }\n      } else {\n        var x = prop.gutterLeft;\n      }\n      var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(x, prop.gutterTop, x + 0.001, obj.height - prop.gutterBottom), stroke: prop.yaxisColor, fill: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\", 'stroke-linecap': 'square' } });if (obj.type === 'hbar') {\n        var height = (obj.graphHeight - prop.vmarginTop - prop.vmarginBottom) / prop.yaxisLabels.length,\n            y = prop.gutterTop + prop.vmarginTop,\n            len = prop.yaxisLabels.length,\n            startX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0),\n            endX = obj.getXCoord(0) - prop.yaxisTickmarksLength;if (obj.type === 'hbar' && prop.xaxisMin < 0 && prop.xaxisMax <= 0) {\n          startX = obj.getXCoord(prop.xaxisMax);endX = obj.getXCoord(prop.xaxisMax) + 5;\n        }\n        if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if (prop.xaxis === false) {\n            if (obj.type === 'hbar' && prop.xaxisMin <= 0 && prop.xaxisMax < 0) {\n              var startX = obj.getXCoord(prop.xaxisMax);var endX = obj.getXCoord(prop.xaxisMax) + prop.yaxisTickmarksLength;\n            } else {\n              var startX = obj.getXCoord(0) - prop.yaxisTickmarksLength;var endX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0);\n            }\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom), endX, obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom) - 0.001), stroke: obj.properties.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      } else {\n        var height = obj.graphHeight / prop.yaxisLabelsCount,\n            y = prop.gutterTop,\n            len = prop.yaxisLabelsCount,\n            startX = prop.gutterLeft,\n            endX = prop.gutterLeft - prop.yaxisTickmarksLength;if (prop.yaxisTickmarks) {\n          for (var i = 0; i < len; ++i) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(startX, y, endX, y + 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });y += height;\n          }\n          if ((prop.yaxisMin !== 0 || prop.xaxis === false) && !(obj.scale.min > 0 && obj.scale.max > 0)) {\n            var axis = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: 'M{1} {2} L{3} {4}'.format(prop.gutterLeft - prop.yaxisTickmarksLength, obj.height - prop.gutterBottom, prop.gutterLeft, obj.height - prop.gutterBottom - 0.001), stroke: prop.yaxisColor, 'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1, 'shape-rendering': \"crispEdges\" } });\n          }\n        }\n      }\n    }\n    if (prop.yaxisScale) {\n      var segment = (obj.height - prop.gutterTop - prop.gutterBottom) / prop.yaxisLabelsCount;for (var i = 0; i < obj.scale.labels.length; ++i) {\n        var y = obj.height - prop.gutterBottom - segment * i - segment;RG.SVG.text({ object: obj, parent: obj.svg.all, text: obj.scale.labels[i], x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n      var y = obj.height - prop.gutterBottom,\n          str = prop.yaxisUnitsPre + prop.yaxisMin.toFixed(prop.yaxisDecimals).replace(/\\./, prop.yaxisPoint) + prop.yaxisUnitsPost;var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: typeof prop.yaxisFormatter === 'function' ? prop.yaxisFormatter(this, prop.yaxisMin) : str, x: prop.gutterLeft - 7 - (prop.yaxis ? prop.yaxisTickmarksLength - 3 : 0) + prop.yaxisLabelsOffsetx, y: y + prop.yaxisLabelsOffsety, halign: 'right', valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n    } else if (prop.yaxisLabels && prop.yaxisLabels.length) {\n      for (var i = 0; i < prop.yaxisLabels.length; ++i) {\n        var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length,\n            y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsety,\n            x = prop.gutterLeft - 7 - (prop.yaxisLinewidth || 1) + prop.yaxisLabelsOffsetx,\n            halign = 'right';if (obj.type === 'hbar' && obj.scale.min < obj.scale.max && obj.scale.max <= 0) {\n          halign = 'left';x = obj.width - prop.gutterRight + 7 + prop.yaxisLabelsOffsetx;\n        } else if (obj.type === 'hbar' && !prop.yaxisLabelsSpecific) {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / prop.yaxisLabels.length;y = prop.gutterTop + (prop.vmarginTop || 0) + segment * i + segment / 2 + prop.yaxisLabelsOffsetx;\n        } else {\n          var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0)) / (prop.yaxisLabels.length - 1);y = obj.height - prop.gutterBottom - segment * i + prop.yaxisLabelsOffsetx;\n        }\n        var text = RG.SVG.text({ object: obj, parent: obj.svg.all, text: prop.yaxisLabels[i] ? prop.yaxisLabels[i] : '', x: x, y: y, halign: halign, valign: 'center', font: prop.yaxisTextFont || prop.textFont, size: prop.yaxisTextSize || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize), bold: prop.yaxisTextBold || prop.textBold, italic: prop.yaxisTextItalic || prop.textItalic, color: prop.yaxisTextColor || prop.textColor });\n      }\n    }\n  };RG.SVG.drawBackground = function (obj) {\n    var prop = obj.properties;if (typeof prop.variant3dOffsetx !== 'number') prop.variant3dOffsetx = 0;if (typeof prop.variant3dOffsety !== 'number') prop.variant3dOffsety = 0;if (prop.backgroundColor) {\n      RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'rect', attr: { x: -1 + prop.variant3dOffsetx, y: -1 - prop.variant3dOffsety, width: parseFloat(obj.svg.getAttribute('width')) + 2, height: parseFloat(obj.svg.getAttribute('height')) + 2, fill: prop.backgroundColor } });\n    }\n    if (prop.backgroundImage) {\n      var attr = { 'xlink:href': prop.backgroundImage, preserveAspectRatio: prop.backgroundImageAspect || 'none', x: prop.gutterLeft, y: prop.gutterTop };if (prop.backgroundImageStretch) {\n        attr.x = prop.gutterLeft + prop.variant3dOffsetx;attr.y = prop.gutterTop + prop.variant3dOffsety;attr.width = obj.width - prop.gutterLeft - prop.gutterRight;attr.height = obj.height - prop.gutterTop - prop.gutterBottom;\n      } else {\n        if (typeof prop.backgroundImageX === 'number') {\n          attr.x = prop.backgroundImageX + prop.variant3dOffsetx;\n        }\n        if (typeof prop.backgroundImageY === 'number') {\n          attr.y = prop.backgroundImageY + prop.variant3dOffsety;\n        }\n        if (typeof prop.backgroundImageW === 'number') {\n          attr.width = prop.backgroundImageW;\n        }\n        if (typeof prop.backgroundImageH === 'number') {\n          attr.height = prop.backgroundImageH;\n        }\n      }\n      if (prop.variant === '3d') {\n        attr.x += prop.variant3dOffsetx;attr.y -= prop.variant3dOffsety;\n      }\n      var img = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'image', attr: attr, style: { opacity: typeof prop.backgroundImageOpacity === 'number' ? prop.backgroundImageOpacity : 1 } });\n    }\n    if (prop.backgroundGrid) {\n      var parts = [];if (prop.backgroundGridHlines) {\n        var count = typeof prop.backgroundGridHlinesCount === 'number' ? prop.backgroundGridHlinesCount : obj.type === 'hbar' ? prop.yaxisLabels.length || obj.data.length || 5 : prop.yaxisLabelsCount;for (var i = 0; i < count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop + obj.graphHeight / count * i - prop.variant3dOffsety));\n        }\n        parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      if (prop.backgroundGridVlines) {\n        if (obj.type === 'line' && RG.SVG.isArray(obj.data[0])) {\n          var len = obj.data[0].length;\n        } else if (obj.type === 'hbar') {\n          var len = prop.xaxisLabelsCount || 10;\n        } else if (obj.type === 'scatter') {\n          var len = prop.xaxisLabels && prop.xaxisLabels.length || 10;\n        } else {\n          var len = obj.data.length;\n        }\n        var count = typeof prop.backgroundGridVlinesCount === 'number' ? prop.backgroundGridVlinesCount : len;if (prop.xaxisLabelsPosition === 'edge') {\n          count--;\n        }\n        for (var i = 0; i <= count; ++i) {\n          parts.push('M{1} {2} L{3} {4}'.format(prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, prop.gutterLeft + obj.graphWidth / count * i + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n        }\n      }\n      if (prop.backgroundGridBorder) {\n        parts.push('M{1} {2} L{3} {4} L{5} {6} L{7} {8} z'.format(prop.gutterLeft + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, prop.gutterTop - prop.variant3dOffsety, obj.width - prop.gutterRight + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety, prop.gutterLeft + prop.variant3dOffsetx, obj.height - prop.gutterBottom - prop.variant3dOffsety));\n      }\n      var grid = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'path', attr: { d: parts.join(' '), stroke: prop.backgroundGridColor, fill: 'rgba(0,0,0,0)', 'stroke-width': prop.backgroundGridLinewidth, 'shape-rendering': \"crispEdges\" } });\n    }\n    RG.SVG.drawTitle(obj);\n  };RG.SVG.isNull = function (arg) {\n    if (arg == null || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !arg) {\n      return true;\n    }\n    return false;\n  };RG.SVG.getScale = function (opt) {\n    var obj = opt.object,\n        prop = obj.properties,\n        numlabels = opt.numlabels,\n        unitsPre = opt.unitsPre,\n        unitsPost = opt.unitsPost,\n        max = Number(opt.max),\n        min = Number(opt.min),\n        strict = opt.strict,\n        decimals = Number(opt.decimals),\n        point = opt.point,\n        thousand = opt.thousand,\n        originalMax = max,\n        round = opt.round,\n        scale = { max: 1, labels: [], values: [] },\n        formatter = opt.formatter;if (max === 0 && min === 0) {\n      var max = 1;for (var i = 0; i < numlabels; ++i) {\n        var label = ((max - min) / numlabels * (i + 1) + min).toFixed(decimals);scale.labels.push(unitsPre + label + unitsPost);scale.values.push(parseFloat(label));\n      }\n    } else if (max <= 1 && !strict) {\n      var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],\n          vals = [];for (var i = 0; i < arr.length; ++i) {\n        if (max > arr[i]) {\n          i--;break;\n        }\n      }\n      scale.max = arr[i];\n      scale.labels = [];scale.values = [];for (var j = 0; j < numlabels; ++j) {\n        var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);scale.values.push(value);scale.labels.push(RG.SVG.numberFormat({ object: obj, num: value, prepend: unitsPre, append: unitsPost, point: prop.yaxisPoint, thousand: prop.yaxisThousand, formatter: formatter }));\n      }\n    } else if (!strict) {\n      max = ma.ceil(max);var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));var topValue = interval;while (topValue < max) {\n        topValue += interval / 2;\n      }\n      if (Number(originalMax) > Number(topValue)) {\n        topValue += interval / 2;\n      }\n      if (max <= 10) {\n        topValue = Number(originalMax) <= 5 ? 5 : 10;\n      }\n      if (obj && typeof round == 'boolean' && round) {\n        topValue = 10 * interval;\n      }\n      scale.max = topValue;for (var i = 0; i < numlabels; ++i) {\n        var label = RG.SVG.numberFormat({ object: obj, num: ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand, formatter: formatter });scale.labels.push(label);scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));\n      }\n    } else if (typeof max === 'number' && strict) {\n      for (var i = 0; i < numlabels; ++i) {\n        scale.labels.push(RG.SVG.numberFormat({ object: obj, formatter: formatter, num: ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), prepend: unitsPre, append: unitsPost, point: point, thousand: thousand }));scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));\n      }\n      scale.max = max;\n    }\n    scale.unitsPre = unitsPre;scale.unitsPost = unitsPost;scale.point = point;scale.decimals = decimals;scale.thousand = thousand;scale.numlabels = numlabels;scale.round = Boolean(round);scale.min = min;for (var i = 0; i < scale.values.length; ++i) {\n      scale.values[i] = parseFloat(scale.values[i]);\n    }\n    return scale;\n  };RG.SVG.arrayFill = RG.SVG.arrayPad = function (opt) {\n    var arr = opt.array,\n        len = opt.length,\n        value = opt.value ? opt.value : null;if (arr.length < len) {\n      for (var i = arr.length; i < len; i += 1) {\n        arr[i] = value;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayMax = function (arr) {\n    var max = null;\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof max === 'number') {\n          max = ma.max(max, val);\n        } else {\n          max = val;\n        }\n      }\n    }\n    return max;\n  };RG.SVG.arrayMin = function (arr) {\n    var max = null,\n        min = null,\n        ma = Math;if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      if (typeof arr[i] === 'number') {\n        var val = arguments[1] ? ma.abs(arr[i]) : arr[i];if (typeof min === 'number') {\n          min = ma.min(min, val);\n        } else {\n          min = val;\n        }\n      }\n    }\n    return min;\n  };RG.SVG.arrayPad = function (arr, len) {\n    if (arr.length < len) {\n      var val = arguments[2] ? arguments[2] : null;for (var i = arr.length; i < len; i += 1) {\n        arr[i] = val;\n      }\n    }\n    return arr;\n  };RG.SVG.arraySum = function (arr) {\n    if (typeof arr === 'number') {\n      return arr;\n    }\n    if (RG.SVG.isNull(arr)) {\n      return 0;\n    }\n    var i,\n        sum,\n        len = arr.length;for (i = 0, sum = 0; i < len; sum += arr[i++]) {}return sum;\n  };RG.SVG.arrayLinearize = function () {\n    var arr = [],\n        args = arguments;\n    for (var i = 0, len = args.length; i < len; ++i) {\n      if (_typeof(args[i]) === 'object' && args[i]) {\n        for (var j = 0, len2 = args[i].length; j < len2; ++j) {\n          var sub = RG.SVG.arrayLinearize(args[i][j]);for (var k = 0, len3 = sub.length; k < len3; ++k) {\n            arr.push(sub[k]);\n          }\n        }\n      } else {\n        arr.push(args[i]);\n      }\n    }\n    return arr;\n  };RG.SVG.arrayShift = function (arr) {\n    var ret = [];for (var i = 1, len = arr.length; i < len; ++i) {\n      ret.push(arr[i]);\n    }\n    return ret;\n  };RG.SVG.arrayReverse = function (arr) {\n    if (!arr) {\n      return;\n    }\n    var newarr = [];for (var i = arr.length - 1; i >= 0; i -= 1) {\n      newarr.push(arr[i]);\n    }\n    return newarr;\n  };RG.SVG.arrayClone = function (obj) {\n    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n      return obj;\n    }\n    if (RG.SVG.isArray(obj)) {\n      var temp = [];for (var i = 0, len = obj.length; i < len; ++i) {\n        if (typeof obj[i] === 'number') {\n          temp[i] = function (arg) {\n            return Number(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'string') {\n          temp[i] = function (arg) {\n            return String(arg);\n          }(obj[i]);\n        } else if (typeof obj[i] === 'function') {\n          temp[i] = obj[i];\n        } else {\n          temp[i] = RG.SVG.arrayClone(obj[i]);\n        }\n      }\n    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {\n      var temp = {};for (var i in obj) {\n        if (typeof i === 'string') {\n          temp[i] = obj[i];\n        }\n      }\n    }\n    return temp;\n  };RG.SVG.arrayInvert = function (arr) {\n    for (var i = 0, len = arr.length; i < len; ++i) {\n      arr[i] = !arr[i];\n    }\n    return arr;\n  };RG.SVG.arrayTrim = function (arr) {\n    var out = [],\n        content = false;for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        content = true;\n      }\n      if (content) {\n        out.push(arr[i]);\n      }\n    }\n    out = RG.SVG.arrayReverse(out);var out2 = [],\n        content = false;for (var i = 0; i < out.length; i++) {\n      if (out[i]) {\n        content = true;\n      }\n      if (content) {\n        out2.push(out[i]);\n      }\n    }\n    out2 = RG.SVG.arrayReverse(out2);return out2;\n  };RG.SVG.isArray = function (obj) {\n    if (obj && obj.constructor) {\n      var pos = obj.constructor.toString().indexOf('Array');\n    } else {\n      return false;\n    }\n    return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;\n  };RG.SVG.abs = function (value) {\n    if (typeof value === 'string') {\n      value = parseFloat(value) || 0;\n    }\n    if (typeof value === 'number') {\n      return ma.abs(value);\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      for (i in value) {\n        if (typeof i === 'string' || typeof i === 'number' || (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object') {\n          value[i] = RG.SVG.abs(value[i]);\n        }\n      }\n      return value;\n    }\n    return 0;\n  };RG.SVG.numberFormat = function (opt) {\n    var obj = opt.object,\n        prepend = opt.prepend ? String(opt.prepend) : '',\n        append = opt.append ? String(opt.append) : '',\n        output = '',\n        decimal_seperator = typeof opt.point === 'string' ? opt.point : '.',\n        thousand_seperator = typeof opt.thousand === 'string' ? opt.thousand : ',',\n        num = opt.num;RegExp.$1 = '';if (typeof opt.formatter === 'function') {\n      return opt.formatter(obj, num);\n    }\n    if (String(num).indexOf('e') > 0) {\n      return String(prepend + String(num) + append);\n    }\n    num = String(num);if (num.indexOf('.') > 0) {\n      var tmp = num;num = num.replace(/\\.(.*)/, '');decimal = tmp.replace(/(.*)\\.(.*)/, '$2');\n    } else {\n      decimal = '';\n    }\n    var seperator = thousand_seperator;var foundPoint;for (i = num.length - 1, j = 0; i >= 0; j++, i--) {\n      var character = num.charAt(i);if (j % 3 == 0 && j != 0) {\n        output += seperator;\n      }\n      output += character;\n    }\n    var rev = output;output = '';for (i = rev.length - 1; i >= 0; i--) {\n      output += rev.charAt(i);\n    }\n    if (output.indexOf('-' + thousand_seperator) == 0) {\n      output = '-' + output.substr(('-' + thousand_seperator).length);\n    }\n    if (decimal.length) {\n      output = output + decimal_seperator + decimal;decimal = '';RegExp.$1 = '';\n    }\n    if (output.charAt(0) == '-') {\n      output = output.replace(/-/, '');prepend = '-' + prepend;\n    }\n    return prepend + output + append;\n  };RG.SVG.text = function (opt) {\n    var obj = opt.object,\n        parent = opt.parent || opt.object.svg.all,\n        size = opt.size,\n        bold = opt.bold,\n        font = opt.font,\n        italic = opt.italic,\n        halign = opt.halign,\n        valign = opt.valign,\n        str = opt.text,\n        x = opt.x,\n        y = opt.y,\n        color = opt.color ? opt.color : 'black',\n        background = opt.background || null,\n        padding = opt.padding || 0;if (halign === 'right') {\n      halign = 'end';\n    } else if (halign === 'center' || halign === 'middle') {\n      halign = 'middle';\n    } else {\n      halign = 'start';\n    }\n    if (valign === 'top') {\n      valign = 'hanging';\n    } else if (valign === 'center' || valign === 'middle') {\n      valign = 'central';valign = 'middle';\n    } else {\n      valign = 'bottom';\n    }\n    var text = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'text', attr: { fill: color, x: x, y: y, 'font-size': typeof size === 'number' ? size + 'pt' : size, 'font-weight': bold ? 900 : 100, 'font-family': font ? font : 'sans-serif', 'font-style': italic ? 'italic' : 'normal', 'text-anchor': halign, 'dominant-baseline': valign } });var textNode = document.createTextNode(str);text.appendChild(textNode);if (typeof background === 'string') {\n      var bbox = text.getBBox(),\n          rect = RG.SVG.create({ svg: obj.svg, parent: opt.parent, type: 'rect', attr: { x: bbox.x - padding, y: bbox.y - padding, width: bbox.width + padding * 2, height: bbox.height + padding * 2, fill: background } });parent.insertBefore(rect, text);\n    }\n    if (RG.SVG.ISIE && valign === 'hanging') {\n      text.setAttribute('y', y + text.scrollHeight / 2);\n    } else if (RG.SVG.ISIE && valign === 'middle') {\n      text.setAttribute('y', y + text.scrollHeight / 3);\n    }\n    if (RG.SVG.ISFF) {\n      Y = y + text.scrollHeight / 3;\n    }\n    return text;\n  };RG.SVG.createUID = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = ma.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);\n    });\n  };RG.SVG.isFixed = function (svg) {\n    var obj = svg.parentNode,\n        i = 0;while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n      if (obj.style.position === 'fixed') {\n        return obj;\n      }\n      obj = obj.offsetParent;\n    }\n    return false;\n  };RG.SVG.REG.set = function (name, value) {\n    RG.SVG.REG.store[name] = value;return value;\n  };RG.SVG.REG.get = function (name) {\n    return RG.SVG.REG.store[name];\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return str.replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return str.replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.hideTooltip = function () {\n    var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.parentNode) {\n      tooltip.parentNode.removeChild(tooltip);tooltip.style.display = 'none';tooltip.style.visibility = 'hidden';RG.SVG.REG.set('tooltip', null);\n    }\n    if (tooltip && tooltip.__object__) {\n      RG.SVG.removeHighlight(tooltip.__object__);\n    }\n  };RG.SVG.setShadow = function (options) {\n    var obj = options.object,\n        offsetx = options.offsetx || 0,\n        offsety = options.offsety || 0,\n        blur = options.blur || 0,\n        opacity = options.opacity || 0,\n        id = options.id;var filter = RG.SVG.create({ svg: obj.svg, parent: obj.svg.defs, type: 'filter', attr: { id: id, width: \"130%\", height: \"130%\" } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feOffset', attr: { result: 'offOut', 'in': 'SourceGraphic', dx: offsetx, dy: offsety } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feColorMatrix', attr: { result: 'matrixOut', 'in': 'offOut', type: 'matrix', values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 {1} 0'.format(opacity) } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feGaussianBlur', attr: { result: 'blurOut', 'in': 'matrixOut', stdDeviation: blur } });RG.SVG.create({ svg: obj.svg, parent: filter, type: 'feBlend', attr: { 'in': 'SourceGraphic', 'in2': 'blurOut', mode: 'normal' } });\n  };RG.SVG.sequentialIndexToGrouped = function (index, data) {\n    var group = 0,\n        grouped_index = 0;while (--index >= 0) {\n      if (RG.SVG.isNull(data[group])) {\n        group++;grouped_index = 0;continue;\n      }\n      if (typeof data[group] == 'number') {\n        group++;\n        grouped_index = 0;continue;\n      }\n      grouped_index++;if (grouped_index >= data[group].length) {\n        group++;grouped_index = 0;\n      }\n    }\n    return [group, grouped_index];\n  };RG.SVG.TRIG.toCartesian = function (options) {\n    return { x: options.cx + options.r * ma.cos(options.angle), y: options.cy + options.r * ma.sin(options.angle) };\n  };RG.SVG.TRIG.getArcPath = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = options.end - options.start;var largeArc = '0';var sweep = '0';if (options.anticlockwise && diff > 3.14) {\n      largeArc = '0';sweep = '0';\n    } else if (options.anticlockwise && diff <= 3.14) {\n      largeArc = '1';sweep = '0';\n    } else if (!options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    } else if (!options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '1';\n    }\n    if (options.start > options.end && options.anticlockwise && diff <= 3.14) {\n      largeArc = '0';sweep = '0';\n    }\n    if (options.start > options.end && options.anticlockwise && diff > 3.14) {\n      largeArc = '1';sweep = '1';\n    }\n    if (typeof options.moveto === 'boolean' && options.moveto === false) {\n      var d = [\"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath2 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"M\", options.cx, options.cy, \"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getArcPath3 = function (options) {\n    options.start -= 1.57;options.end -= 1.57;var start = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.start });var end = RG.SVG.TRIG.toCartesian({ cx: options.cx, cy: options.cy, r: options.r, angle: options.end });var diff = ma.abs(options.end - options.start);var largeArc = '0';var sweep = '0';if (!options.anticlockwise) {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '1';\n      } else {\n        largeArc = '0';sweep = '1';\n      }\n    } else {\n      if (diff > RG.SVG.TRIG.PI) {\n        largeArc = '1';sweep = '0';\n      } else {\n        largeArc = '0';sweep = '0';\n      }\n    }\n    if (typeof options.lineto === 'boolean' && options.lineto === false) {\n      var d = [\"M\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    } else {\n      var d = [\"L\", start.x, start.y, \"A\", options.r, options.r, 0, largeArc, sweep, end.x, end.y];\n    }\n    if (options.array === true) {\n      return d;\n    } else {\n      return d.join(\" \");\n    }\n  };RG.SVG.TRIG.getRadiusEndPoint = function (opt) {\n    if (arguments.length === 1) {\n      var angle = opt.angle,\n          r = opt.r;\n    } else if (arguments.length === 4) {\n      var angle = arguments[0],\n          r = arguments[1];\n    }\n    var x = ma.cos(angle) * r,\n        y = ma.sin(angle) * r;return [x, y];\n  };RG.SVG.drawTitle = function (obj) {\n    var prop = obj.properties;var valign = 'bottom';if (obj.type === 'pie') {\n      if (RG.SVG.isNull(prop.titleX)) {\n        prop.titleX = obj.centerx;prop.titleSubtitleX = obj.centerx;\n      }\n      if (RG.SVG.isNull(prop.titleY)) {\n        prop.titleY = obj.centery - obj.radius - 10;\n      }\n    }\n    if (obj.scale && obj.scale.max <= 0 && obj.scale.min < 0 && typeof prop.titleY !== 'number' && obj.type !== 'hbar') {\n      prop.titleY = obj.height - prop.gutterBottom + 10;var positionBottom = true;valign = 'top';\n    } else if (typeof prop.titleY !== 'number') {\n      var positionBottom = false;prop.titleY = prop.gutterTop - 10;valign = 'bottom';if (!RG.SVG.isNull(prop.key)) {\n        prop.titleY -= 2 * (prop.keyTextSize || prop.textSize);\n      }\n    }\n    if (prop.titleSubtitle && typeof prop.titleSubtitleY !== 'number' && !positionBottom) {\n      prop.titleY = prop.titleY - prop.titleSubtitleSize * 1.5;\n    }\n    prop.titleSubTitleSize = prop.titleSubTitleSize || prop.textSize;prop.titleSubtitleY = prop.titleSubtitleY || prop.titleY + 18;if (positionBottom && typeof prop.titleSubtitleY !== 'number') {\n      prop.titleSubtitleY = prop.titleY + 26;\n    }\n    if (prop.title) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.title.toString(), size: prop.titleSize || prop.textSize + 4 || 16, x: typeof prop.titleX === 'number' ? prop.titleX + (prop.variant3dOffsetx || 0) : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleY + (prop.variant3dOffsety || 0), halign: prop.titleHalign || 'center', valign: prop.titleValign || valign, color: prop.titleColor || prop.textColor || 'black', bold: prop.titleBold || false, italic: prop.titleItalic || false, font: prop.titleFont || prop.textFont || 'Arial' });\n    }\n    if (prop.titleSubtitle) {\n      RG.SVG.text({ object: obj, svg: obj.svg, parent: obj.svg.all, text: prop.titleSubtitle, size: prop.titleSubtitleSize, x: typeof prop.titleSubtitleX === 'number' ? prop.titleSubtitleX : prop.gutterLeft + obj.graphWidth / 2 + (prop.variant3dOffsetx || 0), y: prop.titleSubtitleY + (prop.variant3dOffsety || 0), halign: prop.titleSubtitleHalign || 'center', valign: prop.titleSubtitleValign || valign, color: prop.titleSubtitleColor || prop.textColor || '#aaa', bold: prop.titleSubtitleBold || false, italic: prop.titleSubtitleItalic || false, font: prop.titleSubtitleFont || prop.textFont || 'Arial' });\n    }\n  };RG.SVG.trim = function (str) {\n    return RG.SVG.ltrim(RG.SVG.rtrim(str));\n  };RG.SVG.ltrim = function (str) {\n    return String(str).replace(/^(\\s|\\0)+/, '');\n  };RG.SVG.rtrim = function (str) {\n    return String(str).replace(/(\\s|\\0)+$/, '');\n  };RG.SVG.parseColorLinear = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);if (opt && opt.direction && opt.direction === 'horizontal') {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: opt.start || 0, x2: opt.end || '100%', y1: 0, y2: 0, gradientUnits: \"userSpaceOnUse\" } });\n      } else {\n        var grad = RG.SVG.create({ type: 'linearGradient', parent: obj.svg.defs, attr: { id: 'RGraph-linear-gradient' + obj.gradientCounter, x1: 0, x2: 0, y1: opt.start || 0, y2: opt.end || '100%', gradientUnits: \"userSpaceOnUse\" } });\n      }\n      var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-linear-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.parseColorRadial = function (opt) {\n    var obj = opt.object,\n        color = opt.color;if (!color || typeof color !== 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':'),\n          diff = 1 / (parts.length - 1);var grad = RG.SVG.create({ type: 'radialGradient', parent: obj.svg.defs, attr: { id: 'RGraph-radial-gradient' + obj.gradientCounter, gradientUnits: opt.gradientUnits || 'userSpaceOnUse', cx: opt.cx || obj.centerx, cy: opt.cy || obj.centery, fx: opt.fx || obj.centerx, fy: opt.fy || obj.centery, r: opt.r || obj.radius } });var stop = RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: '0%', 'stop-color': RG.SVG.trim(parts[0]) } });for (var j = 1, len = parts.length; j < len; ++j) {\n        RG.SVG.create({ type: 'stop', parent: grad, attr: { offset: j * diff * 100 + '%', 'stop-color': RG.SVG.trim(parts[j]) } });\n      }\n    }\n    color = grad ? 'url(#RGraph-radial-gradient' + obj.gradientCounter++ + ')' : color;return color;\n  };RG.SVG.resetColorsToOriginalValues = function (opt) {\n    var obj = opt.object;if (obj.originalColors) {\n      for (var j in obj.originalColors) {\n        if (typeof j === 'string') {\n          obj.properties[j] = RG.SVG.arrayClone(obj.originalColors[j]);\n        }\n      }\n    }\n    if (typeof obj.resetColorsToOriginalValues === 'function') {\n      obj.resetColorsToOriginalValues();\n    }\n    obj.originalColors = {};obj.colorsParsed = false;obj.gradientCounter = 1;\n  };RG.SVG.clear = function (svg) {\n    while (svg.all.lastChild) {\n      svg.all.removeChild(svg.all.lastChild);\n    }\n  };RG.SVG.addCustomEventListener = function (obj, name, func) {\n    if (typeof RG.SVG.events[obj.uid] === 'undefined') {\n      RG.SVG.events[obj.uid] = [];\n    }\n    if (name.substr(0, 2) !== 'on') {\n      name = 'on' + name;\n    }\n    RG.SVG.events[obj.uid].push({ object: obj, event: name, func: func });return RG.SVG.events[obj.uid].length - 1;\n  };RG.SVG.fireCustomEvent = function (obj, name) {\n    if (obj && obj.isRGraph) {\n      var uid = obj.uid;if (typeof uid === 'string' && _typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[uid]) === 'object' && RG.SVG.events[uid].length > 0) {\n        for (var j = 0, len = RG.SVG.events[uid].length; j < len; ++j) {\n          if (RG.SVG.events[uid][j] && RG.SVG.events[uid][j].event === name) {\n            RG.SVG.events[uid][j].func(obj);\n          }\n        }\n      }\n    }\n  };RG.SVG.removeAllCustomEventListeners = function () {\n    var uid = arguments[0];if (uid && RG.SVG.events[uid]) {\n      RG.SVG.events[uid] = {};\n    } else {\n      RG.SVG.events = [];\n    }\n  };RG.SVG.removeCustomEventListener = function (obj, i) {\n    if (_typeof(RG.SVG.events) === 'object' && _typeof(RG.SVG.events[obj.uid]) === 'object' && _typeof(RG.SVG.events[obj.uid][i]) === 'object') {\n      RG.SVG.events[obj.uid][i] = null;\n    }\n  };RG.SVG.removeHighlight = function (obj) {\n    var highlight = RG.SVG.REG.get('highlight');if (highlight && RG.SVG.isArray(highlight) && highlight.length) {\n      for (var i = 0, len = highlight.length; i < len; ++i) {\n        if (highlight[i].parentNode) {\n          highlight[i].parentNode.removeChild(highlight[i]);\n        }\n      }\n    } else if (highlight && highlight.parentNode) {\n      if (obj.type === 'scatter') {\n        highlight.setAttribute('fill', 'transparent');\n      } else {\n        highlight.parentNode.removeChild(highlight);\n      }\n    }\n  };RG.SVG.redraw = function () {\n    if (arguments.length === 1) {\n      var svg = arguments[0];RG.SVG.clear(svg);var objects = RG.SVG.OR.get('id:' + svg.parentNode.id);for (var i = 0, len = objects.length; i < len; ++i) {\n        RG.SVG.resetColorsToOriginalValues({ object: objects[i] });objects[i].draw();\n      }\n    } else {\n      var tags = RG.SVG.OR.tags();for (var i in tags) {\n        RG.SVG.redraw(tags[i]);\n      }\n    }\n  };RG.SVG.parseDate = function (str) {\n    var d = new Date();var defaults = { seconds: '00', minutes: '00', hours: '00', date: d.getDate(), month: d.getMonth() + 1, year: d.getFullYear() };var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'],\n        months_regex = months.join('|');for (var i = 0; i < months.length; ++i) {\n      months[months[i]] = i;months[months[i].substring(0, 3)] = i;months_regex = months_regex + '|' + months[i].substring(0, 3);\n    }\n    var sep = '[-./_=+~#:;,]+';var tokens = str.split(/ +/);for (var i = 0, len = tokens.length; i < len; ++i) {\n      if (tokens[i]) {\n        if (tokens[i].match(/^\\d\\d\\d\\d$/)) {\n          defaults.year = tokens[i];\n        }\n        var res = isMonth(tokens[i]);if (typeof res === 'number') {\n          defaults.month = res + 1;\n        }\n        if (tokens[i].match(/^\\d?\\d(?:st|nd|rd|th)?$/)) {\n          defaults.date = parseInt(tokens[i]);\n        }\n        if (tokens[i].match(/^(\\d\\d):(\\d\\d)(?:(\\d\\d))?$/)) {\n          defaults.hours = parseInt(RegExp.$1);defaults.minutes = parseInt(RegExp.$2);if (RegExp.$3) {\n            defaults.seconds = parseInt(RegExp.$3);\n          }\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$3);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$1);\n        }\n        if (tokens[i].match(new RegExp('^(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d\\\\d\\\\d)$', 'i'))) {\n          defaults.date = parseInt(RegExp.$1);defaults.month = parseInt(RegExp.$2);defaults.year = parseInt(RegExp.$3);\n        }\n      }\n    }\n    str = '{1}/{2}/{3} {4}:{5}:{6}'.format(defaults.year, String(defaults.month).length === 1 ? '0' + defaults.month : defaults.month, String(defaults.date).length === 1 ? '0' + defaults.date : defaults.date, String(defaults.hours).length === 1 ? '0' + defaults.hours : defaults.hours, String(defaults.minutes).length === 1 ? '0' + defaults.minutes : defaults.minutes, String(defaults.seconds).length === 1 ? '0' + defaults.seconds : defaults.seconds);return Date.parse(str);function isMonth(str) {\n      var res = str.toLowerCase().match(months_regex);return res ? months[res[0]] : false;\n    }\n  };RG.SVG.OR.add = function (obj) {\n    RG.SVG.OR.objects.push(obj);return obj;\n  };RG.SVG.OR.get = function () {\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'id:') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].id === arguments[0].substr(3)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 4).toLowerCase() === 'type') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].type === arguments[0].substr(5)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'uid') {\n      var ret = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n        if (RG.SVG.OR.objects[i].uid === arguments[0].substr(4)) {\n          ret.push(RG.SVG.OR.objects[i]);\n        }\n      }\n      return ret;\n    }\n    return RG.SVG.OR.objects;\n  };RG.SVG.OR.tags = function () {\n    var tags = [];for (var i = 0; i < RG.SVG.OR.objects.length; ++i) {\n      if (!tags[RG.SVG.OR.objects[i].svg.parentNode.id]) {\n        tags[RG.SVG.OR.objects[i].svg.parentNode.id] = RG.SVG.OR.objects[i].svg;\n      }\n    }\n    return tags;\n  };RG.SVG.getSVGXY = function (svg) {\n    var x = 0,\n        y = 0,\n        el = svg.parentNode;do {\n      x += el.offsetLeft;y += el.offsetTop;if (el.tagName.toLowerCase() == 'table' && (RG.SVG.ISCHROME || RG.SVG.ISSAFARI)) {\n        x += parseInt(el.border) || 0;y += parseInt(el.border) || 0;\n      }\n      el = el.offsetParent;\n    } while (el && el.tagName && el.tagName.toLowerCase() != 'body');var paddingLeft = svg.style.paddingLeft ? parseInt(svg.style.paddingLeft) : 0,\n        paddingTop = svg.style.paddingTop ? parseInt(svg.style.paddingTop) : 0,\n        borderLeft = svg.style.borderLeftWidth ? parseInt(svg.style.borderLeftWidth) : 0,\n        borderTop = svg.style.borderTopWidth ? parseInt(svg.style.borderTopWidth) : 0;if (navigator.userAgent.indexOf('Firefox') > 0) {\n      x += parseInt(document.body.style.borderLeftWidth) || 0;y += parseInt(document.body.style.borderTopWidth) || 0;\n    }\n    return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n  };RG.SVG.FX.update = function (func) {\n    win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {\n      setTimeout(func, 16.666);\n    };win.requestAnimationFrame(func);\n  };RG.SVG.FX.getEasingMultiplier = function (frames, frame) {\n    var multiplier = ma.pow(ma.sin(frame / frames * RG.SVG.TRIG.HALFPI), 3);return multiplier;\n  };RG.SVG.measureText = function (opt) {\n    var text = opt.text || '',\n        bold = opt.bold || false,\n        font = opt.font || 'Arial',\n        size = opt.size || 10,\n        str = text + ':' + bold + ':' + font + ':' + size;if (typeof RG.SVG.measuretext_cache === 'undefined') {\n      RG.SVG.measuretext_cache = [];\n    }\n    if (_typeof(RG.SVG.measuretext_cache) == 'object' && RG.SVG.measuretext_cache[str]) {\n      return RG.SVG.measuretext_cache[str];\n    }\n    if (!RG.SVG.measuretext_cache['text-span']) {\n      var span = document.createElement('SPAN');span.style.position = 'absolute';span.style.padding = 0;span.style.display = 'inline';span.style.top = '-200px';span.style.left = '-200px';span.style.lineHeight = '1em';document.body.appendChild(span);RG.SVG.measuretext_cache['text-span'] = span;\n    } else if (RG.SVG.measuretext_cache['text-span']) {\n      var span = RG.SVG.measuretext_cache['text-span'];\n    }\n    span.innerHTML = text.replace(/\\r\\n/g, '<br />');span.style.fontFamily = font;span.style.fontWeight = bold ? 'bold' : 'normal';span.style.fontSize = size + 'pt';var sizes = [span.offsetWidth, span.offsetHeight];RG.SVG.measuretext_cache[str] = sizes;return sizes;\n  };RG.SVG.stringsToNumbers = function (str) {\n    var sep = arguments[1] || ',';if (typeof str === 'number') {\n      return str;\n    }\n    if (typeof str === 'string') {\n      if (str.indexOf(sep) != -1) {\n        str = str.split(sep);\n      } else {\n        str = parseFloat(str);\n      }\n    }\n    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'object') {\n      for (var i = 0, len = str.length; i < len; i += 1) {\n        str[i] = parseFloat(str[i]);\n      }\n    }\n    return str;\n  };RG.SVG.getAdjustedNumber = function (opt) {\n    var value = opt.value,\n        prop = opt.prop;if (typeof prop === 'string' && match(/^(\\+|-)([0-9.]+)/)) {\n      if (RegExp.$1 === '+') {\n        value += parseFloat(RegExp.$2);\n      } else if (RegExp.$1 === '-') {\n        value -= parseFloat(RegExp.$2);\n      }\n    }\n    return value;\n  };RG.SVG.attribution = function (obj) {\n    return;\n  };RG.SVG.parseGradient = function (str) {};RG.SVG.random = function (opt) {\n    var min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0,\n        r = ma.random();return Number(((max - min) * r + min).toFixed(dp));\n  };RG.SVG.arrayRand = RG.SVG.arrayRandom = RG.SVG.random.array = function (opt) {\n    var num = opt.num,\n        min = opt.min,\n        max = opt.max,\n        dp = opt.dp || opt.decimals || 0;for (var i = 0, arr = []; i < num; i += 1) {\n      arr.push(RG.SVG.random({ min: min, max: max, dp: dp }));\n    }\n    return arr;\n  };RG.SVG.commonSetter = function (opt) {\n    var obj = opt.object,\n        name = opt.name,\n        value = opt.value;if (name === 'tooltipsEvent' && value !== 'click' && value !== 'mousemove') {\n      value = 'click';\n    }\n    return { name: name, value: value };\n  };RG.SVG.log = function (opt) {\n    var num = opt.num,\n        base = opt.base;return ma.log(num) / (base ? ma.log(base) : 1);\n  };RG.SVG.donut = function (opt) {\n    var arcPath1 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.outerRadius, start: 0, end: RG.SVG.TRIG.TWOPI, anticlockwise: false, lineto: false });var arcPath2 = RG.SVG.TRIG.getArcPath3({ cx: opt.cx, cy: opt.cy, r: opt.innerRadius, start: RG.SVG.TRIG.TWOPI, end: 0, anticlockwise: true, lineto: false });var path = RG.SVG.create({ svg: opt.svg, type: 'path', attr: { d: arcPath1 + arcPath2, stroke: opt.stroke, fill: opt.fill } });return path;\n  };if (typeof RG.SVG.tooltip !== 'function') {\n    RG.SVG.tooltip = function () {\n      $a('The tooltip library has not been included!');\n    };\n  }\n})(window, document);window.$p = function (obj) {\n  var indent = arguments[2] ? arguments[2] : '    ';var str = '';var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;if (counter >= 5) {\n    return '';\n  }\n  switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {case 'string':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + obj.length + ')';break;case 'number':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'boolean':\n      str += obj + ' (' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ')';break;case 'function':\n      str += 'function () {}';break;case 'undefined':\n      str += 'undefined';break;case 'null':\n      str += 'null';break;case 'object':\n      if (RGraph.SVG.isNull(obj)) {\n        str += indent + 'null\\n';\n      } else {\n        str += indent + 'Object {' + '\\n';\n        for (j in obj) {\n          str += indent + '    ' + j + ' => ' + window.$p(obj[j], true, indent + '    ', counter + 1) + '\\n';\n        }\n        str += indent + '}';\n      }\n      break;default:\n      str += 'Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + '';break;}\n  if (!arguments[1]) {\n    alert(str);\n  }\n  return str;\n};window.$a = function (v) {\n  alert(v);\n};window.$cl = function (v) {\n  return console.log(v);\n};if (!String.prototype.format) {\n  String.prototype.format = function () {\n    var args = arguments;return this.replace(/{(\\d+)}/g, function (str, idx) {\n      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmNvcmUuanM/Y2IwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSwgaXNSR3JhcGhTVkc6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTtSR3JhcGguU1ZHLkZYID0gUkdyYXBoLlNWRy5GWCB8fCB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoO1JHLlNWRy5SRUcgPSB7IHN0b3JlOiBbXSB9O1JHLlNWRy5PUiA9IHsgb2JqZWN0czogW10gfTtSRy5TVkcuVFJJRyA9IHt9O1JHLlNWRy5UUklHLkhBTEZQSSA9IG1hLlBJICogLjQ5OTk7UkcuU1ZHLlRSSUcuUEkgPSBSRy5TVkcuVFJJRy5IQUxGUEkgKiAyO1JHLlNWRy5UUklHLlRXT1BJID0gUkcuU1ZHLlRSSUcuUEkgKiAyO1JHLlNWRy5JU0lFID0gdWEuaW5kZXhPZigncmlkZW50JykgPiAwO1JHLlNWRy5JU0ZGID0gdWEuaW5kZXhPZignaXJlZm94JykgPiAwO1JHLlNWRy5ldmVudHMgPSBbXTtSRy5TVkcuSVNGRiA9IHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSAhPSAtMTtSRy5TVkcuSVNPUEVSQSA9IHVhLmluZGV4T2YoJ09wZXJhJykgIT0gLTE7UkcuU1ZHLklTQ0hST01FID0gdWEuaW5kZXhPZignQ2hyb21lJykgIT0gLTE7UkcuU1ZHLklTU0FGQVJJID0gdWEuaW5kZXhPZignU2FmYXJpJykgIT0gLTEgJiYgIVJHLklTQ0hST01FO1JHLlNWRy5JU1dFQktJVCA9IHVhLmluZGV4T2YoJ1dlYktpdCcpICE9IC0xO1JHLlNWRy5JU0lFID0gdWEuaW5kZXhPZignVHJpZGVudCcpID4gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA+IDA7UkcuU1ZHLklTSUU2ID0gdWEuaW5kZXhPZignTVNJRSA2JykgPiAwO1JHLlNWRy5JU0lFNyA9IHVhLmluZGV4T2YoJ01TSUUgNycpID4gMDtSRy5TVkcuSVNJRTggPSB1YS5pbmRleE9mKCdNU0lFIDgnKSA+IDA7UkcuU1ZHLklTSUU5ID0gdWEuaW5kZXhPZignTVNJRSA5JykgPiAwO1JHLlNWRy5JU0lFMTAgPSB1YS5pbmRleE9mKCdNU0lFIDEwJykgPiAwO1JHLlNWRy5JU0lFMTFVUCA9IHVhLmluZGV4T2YoJ01TSUUnKSA9PSAtMSAmJiB1YS5pbmRleE9mKCdUcmlkZW50JykgPiAwO1JHLlNWRy5JU0lFMTBVUCA9IFJHLlNWRy5JU0lFMTAgfHwgUkcuU1ZHLklTSUUxMVVQO1JHLlNWRy5JU0lFOVVQID0gUkcuU1ZHLklTSUU5IHx8IFJHLlNWRy5JU0lFMTBVUDtSRy5TVkcuY3JlYXRlU1ZHID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBjb250YWluZXIgPSBvcHQuY29udGFpbmVyO2lmIChjb250YWluZXIuX19zdmdfXykge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5fX3N2Z19fO1xuICAgIH1cbiAgICB2YXIgc3ZnID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO3N2Zy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3RvcDogMDsgbGVmdDogMDsgcG9zaXRpb246IGFic29sdXRlJyk7c3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjb250YWluZXIub2Zmc2V0V2lkdGgpO3N2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQpO3N2Zy5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7c3ZnLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7c3ZnLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7Y29udGFpbmVyLmFwcGVuZENoaWxkKHN2Zyk7Y29udGFpbmVyLl9fc3ZnX18gPSBzdmc7Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJzt2YXIgZ3JvdXAgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBzdmcsIHR5cGU6ICdnJywgYXR0cjogeyBjbGFzc05hbWU6ICdhbGwtZWxlbWVudHMnIH0gfSk7Y29udGFpbmVyLl9fc3ZnX18uYWxsID0gZ3JvdXA7cmV0dXJuIHN2ZztcbiAgfTtSRy5TVkcuY3JlYXRlRGVmcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5zdmcuZGVmcykge1xuICAgICAgdmFyIGRlZnMgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCB0eXBlOiAnZGVmcycgfSk7b2JqLnN2Zy5kZWZzID0gZGVmcztcbiAgICB9XG4gICAgcmV0dXJuIGRlZnM7XG4gIH07UkcuU1ZHLmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHRhZyA9IGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIG9wdC50eXBlKTtmb3IgKHZhciBvIGluIG9wdC5hdHRyKSB7XG4gICAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBuYW1lID0gbztpZiAobyA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgICBuYW1lID0gJ2NsYXNzJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9wdC50eXBlID09PSAnYScgfHwgb3B0LnR5cGUgPT09ICdpbWFnZScpICYmIG8gPT09ICd4bGluazpocmVmJykge1xuICAgICAgICAgIHRhZy5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG8sIFN0cmluZyhvcHQuYXR0cltvXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZy5zZXRBdHRyaWJ1dGUobmFtZSwgU3RyaW5nKG9wdC5hdHRyW29dKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgbyBpbiBvcHQuc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGFnLnN0eWxlW29dID0gU3RyaW5nKG9wdC5zdHlsZVtvXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHQucGFyZW50KSB7XG4gICAgICBvcHQucGFyZW50LmFwcGVuZENoaWxkKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5zdmcuYXBwZW5kQ2hpbGQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbiAgfTtSRy5TVkcuZHJhd1hBeGlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7aWYgKHByb3AueGF4aXMpIHtcbiAgICAgIHZhciB5ID0gb2JqLnR5cGUgPT09ICdoYmFyJyA/IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSA6IG9iai5nZXRZQ29vcmQob2JqLnNjYWxlLm1pbiA8IDAgJiYgb2JqLnNjYWxlLm1heCA8IDAgPyBvYmouc2NhbGUubWF4IDogb2JqLnNjYWxlLm1pbiA+IDAgJiYgb2JqLnNjYWxlLm1heCA+IDAgPyBvYmouc2NhbGUubWluIDogMCk7dmFyIGF4aXMgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQocHJvcC5ndXR0ZXJMZWZ0LCB5ICsgMC4wMSwgb2JqLndpZHRoIC0gcHJvcC5ndXR0ZXJSaWdodCwgeSksIGZpbGw6IHByb3AueGF4aXNDb2xvciwgc3Ryb2tlOiBwcm9wLnhheGlzQ29sb3IsICdzdHJva2Utd2lkdGgnOiB0eXBlb2YgcHJvcC54YXhpc0xpbmV3aWR0aCA9PT0gJ251bWJlcicgPyBwcm9wLnhheGlzTGluZXdpZHRoIDogMSwgJ3NoYXBlLXJlbmRlcmluZyc6ICdjcmlzcEVkZ2VzJywgJ3N0cm9rZS1saW5lY2FwJzogJ3NxdWFyZScgfSB9KTtpZiAob2JqLnR5cGUgPT09ICdoYmFyJykge1xuICAgICAgICB2YXIgd2lkdGggPSBvYmouZ3JhcGhXaWR0aCAvIG9iai5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHggPSBwcm9wLmd1dHRlckxlZnQsXG4gICAgICAgICAgICBzdGFydFkgPSBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20sXG4gICAgICAgICAgICBlbmRZID0gb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tICsgcHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3aWR0aCA9IG9iai5ncmFwaFdpZHRoIC8gb2JqLmRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgeCA9IHByb3AuZ3V0dGVyTGVmdCxcbiAgICAgICAgICAgIHN0YXJ0WSA9IG9iai5nZXRZQ29vcmQoMCkgLSAocHJvcC55YXhpc01pbiA8IDAgPyBwcm9wLnhheGlzVGlja21hcmtzTGVuZ3RoIDogMCksXG4gICAgICAgICAgICBlbmRZID0gb2JqLmdldFlDb29yZCgwKSArIHByb3AueGF4aXNUaWNrbWFya3NMZW5ndGg7aWYgKG9iai5zY2FsZS5taW4gPCAwICYmIG9iai5zY2FsZS5tYXggPD0gMCkge1xuICAgICAgICAgIHN0YXJ0WSA9IHByb3AuZ3V0dGVyVG9wO2VuZFkgPSBwcm9wLmd1dHRlclRvcCAtIHByb3AueGF4aXNUaWNrbWFya3NMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5zY2FsZS5taW4gPiAwICYmIG9iai5zY2FsZS5tYXggPiAwKSB7XG4gICAgICAgICAgc3RhcnRZID0gb2JqLmdldFlDb29yZChvYmouc2NhbGUubWluKTtlbmRZID0gb2JqLmdldFlDb29yZChvYmouc2NhbGUubWluKSArIHByb3AueGF4aXNUaWNrbWFya3NMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLnhheGlzVGlja21hcmtzKSB7XG4gICAgICAgIGlmIChwcm9wLnhheGlzU2NhbGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5zY2FsZS5udW1sYWJlbHMgKyAocHJvcC55YXhpcyAmJiBwcm9wLnhheGlzTWluID09PSAwID8gMCA6IDEpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2hiYXInKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhUG9pbnRzID0gb2JqLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IHByb3AuZ3V0dGVyTGVmdCArIChpICsgKHByb3AueWF4aXMgJiYgcHJvcC54YXhpc01pbiA9PT0gMCA/IDEgOiAwKSkgKiAob2JqLmdyYXBoV2lkdGggLyBvYmouc2NhbGUubnVtbGFiZWxzKTtSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoeCArIDAuMDAxLCBzdGFydFksIHgsIGVuZFkpLCBzdHJva2U6IHByb3AueGF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueGF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbiA9PT0gJ3NlY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdiYXInIHx8IG9iai50eXBlID09PSAnd2F0ZXJmYWxsJykge1xuICAgICAgICAgICAgICB2YXIgZGF0YVBvaW50cyA9IG9iai5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICB2YXIgZGF0YVBvaW50cyA9IG9iai5kYXRhWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdzY2F0dGVyJykge1xuICAgICAgICAgICAgICB2YXIgZGF0YVBvaW50cyA9IHByb3AueGF4aXNMYWJlbHMgPyBwcm9wLnhheGlzTGFiZWxzLmxlbmd0aCA6IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhUG9pbnRzOyArK2kpIHtcbiAgICAgICAgICAgICAgeCA9IHByb3AuZ3V0dGVyTGVmdCArIChpICsgMSkgKiAob2JqLmdyYXBoV2lkdGggLyBkYXRhUG9pbnRzKTtSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoeCArIDAuMDAxLCBzdGFydFksIHgsIGVuZFkpLCBzdHJva2U6IHByb3AueGF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueGF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbiA9PT0gJ2VkZ2UnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbkVkZ2VUaWNrbWFya3NDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbkVkZ2VUaWNrbWFya3NDb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBvYmouZGF0YSAmJiBvYmouZGF0YVswXSAmJiBvYmouZGF0YVswXS5sZW5ndGggPyBvYmouZGF0YVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZ2FwID0gb2JqLmdyYXBoV2lkdGggLyAobGVuIC0gMSksXG4gICAgICAgICAgICAgICAgICB4ID0gcHJvcC5ndXR0ZXJMZWZ0ICsgKGkgKyAxKSAqIGdhcDtSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoeCArIDAuMDAxLCBzdGFydFksIHgsIGVuZFkpLCBzdHJva2U6IHByb3AueGF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueGF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AueWF4aXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBvYmouc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6ICdNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCArIDAuMDAxLCBzdGFydFksIHByb3AuZ3V0dGVyTGVmdCwgZW5kWSksIHN0cm9rZTogb2JqLnByb3BlcnRpZXMueGF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnhheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueGF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIsIHBhcmVudDogb2JqLnN2Zy5hbGwgfSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcC54YXhpc1NjYWxlKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IG9iai5ncmFwaFdpZHRoIC8gcHJvcC54YXhpc0xhYmVsc0NvdW50O2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLnNjYWxlLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgeCA9IHByb3AuZ3V0dGVyTGVmdCArIHNlZ21lbnQgKiBpICsgc2VnbWVudCArIHByb3AueGF4aXNMYWJlbHNPZmZzZXR4O1JHLlNWRy50ZXh0KHsgb2JqZWN0OiBvYmosIHBhcmVudDogb2JqLnN2Zy5hbGwsIHRleHQ6IG9iai5zY2FsZS5sYWJlbHNbaV0sIHg6IHgsIHk6IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIChwcm9wLnhheGlzID8gcHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aCArIDYgOiAxMCkgKyAocHJvcC54YXhpc0xpbmV3aWR0aCB8fCAxKSArIHByb3AueGF4aXNMYWJlbHNPZmZzZXR5LCBoYWxpZ246ICdjZW50ZXInLCB2YWxpZ246ICd0b3AnLCBmb250OiBwcm9wLnhheGlzVGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC54YXhpc1RleHRTaXplIHx8ICh0eXBlb2YgcHJvcC50ZXh0U2l6ZSA9PT0gJ251bWJlcicgPyBwcm9wLnRleHRTaXplICsgJ3B0JyA6IHByb3AudGV4dFNpemUpLCBib2xkOiBwcm9wLnhheGlzVGV4dEJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgaXRhbGljOiBwcm9wLnhheGlzVGV4dEl0YWxpYyB8fCBwcm9wLnRleHRJdGFsaWMsIGNvbG9yOiBwcm9wLnhheGlzVGV4dENvbG9yIHx8IHByb3AudGV4dENvbG9yIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AueGF4aXNMYWJlbHNDb3VudCA+IDApIHtcbiAgICAgICAgdmFyIHkgPSBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gKyBwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eSArIChwcm9wLnhheGlzID8gcHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aCArIDYgOiAxMCksXG4gICAgICAgICAgICBzdHIgPSBSRy5TVkcubnVtYmVyRm9ybWF0KHsgb2JqZWN0OiBvYmosIG51bTogcHJvcC54YXhpc01pbi50b0ZpeGVkKHByb3AueGF4aXNEZWNpbWFscyksIHByZXBlbmQ6IHByb3AueGF4aXNVbml0c1ByZSwgYXBwZW5kOiBwcm9wLnhheGlzVW5pdHNQb3N0LCBwb2ludDogcHJvcC54YXhpc1BvaW50LCB0aG91c2FuZDogcHJvcC54YXhpc1Rob3VzYW5kLCBmb3JtYXR0ZXI6IHByb3AueGF4aXNGb3JtYXR0ZXIgfSk7dmFyIHRleHQgPSBSRy5TVkcudGV4dCh7IG9iamVjdDogb2JqLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0ZXh0OiB0eXBlb2YgcHJvcC54YXhpc0Zvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3AueGF4aXNGb3JtYXR0ZXIodGhpcywgcHJvcC54YXhpc01pbikgOiBzdHIsIHg6IHByb3AuZ3V0dGVyTGVmdCArIHByb3AueGF4aXNMYWJlbHNPZmZzZXR4LCB5OiB5LCBoYWxpZ246ICdjZW50ZXInLCB2YWxpZ246ICd0b3AnLCBmb250OiBwcm9wLnhheGlzVGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC54YXhpc1RleHRTaXplIHx8ICh0eXBlb2YgcHJvcC50ZXh0U2l6ZSA9PT0gJ251bWJlcicgPyBwcm9wLnRleHRTaXplICsgJ3B0JyA6IHByb3AudGV4dFNpemUpLCBib2xkOiBwcm9wLnhheGlzVGV4dEJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgaXRhbGljOiBwcm9wLnhheGlzVGV4dEl0YWxpYyB8fCBwcm9wLnRleHRJdGFsaWMsIGNvbG9yOiBwcm9wLnhheGlzVGV4dENvbG9yIHx8IHByb3AudGV4dENvbG9yIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX3R5cGVvZihwcm9wLnhheGlzTGFiZWxzKSA9PT0gJ29iamVjdCcgJiYgIVJHLlNWRy5pc051bGwocHJvcC54YXhpc0xhYmVscykpIHtcbiAgICAgICAgaWYgKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbiA9PT0gJ3NlY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSAob2JqLndpZHRoIC0gcHJvcC5ndXR0ZXJMZWZ0IC0gcHJvcC5ndXR0ZXJSaWdodCkgLyBwcm9wLnhheGlzTGFiZWxzLmxlbmd0aDtmb3IgKHZhciBpID0gMDsgaSA8IHByb3AueGF4aXNMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcHJvcC5ndXR0ZXJMZWZ0ICsgc2VnbWVudCAvIDIgKyBpICogc2VnbWVudDtpZiAob2JqLnNjYWxlLm1heCA8PSAwICYmIG9iai5zY2FsZS5taW4gPCBvYmouc2NhbGUubWF4KSB7XG4gICAgICAgICAgICAgIHZhciB5ID0gcHJvcC5ndXR0ZXJUb3AgLSAoUkcuU1ZHLklTRkYgPyA1IDogMTApIC0gKHByb3AueGF4aXNMaW5ld2lkdGggfHwgMSkgKyBwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eTt2YXIgdmFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgeSA9IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIChSRy5TVkcuSVNGRiA/IDUgOiAxMCkgKyAocHJvcC54YXhpc0xpbmV3aWR0aCB8fCAxKSArIHByb3AueGF4aXNMYWJlbHNPZmZzZXR5O3ZhciB2YWxpZ24gPSAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiBvYmosIHBhcmVudDogb2JqLnN2Zy5hbGwsIHRleHQ6IHByb3AueGF4aXNMYWJlbHNbaV0sIHg6IHggKyBwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eCwgeTogeSwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogJ2NlbnRlcicsIHNpemU6IHByb3AueGF4aXNUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplLCBpdGFsaWM6IHByb3AueGF4aXNUZXh0SXRhbGljIHx8IHByb3AudGV4dEl0YWxpYywgZm9udDogcHJvcC54YXhpc1RleHRGb250IHx8IHByb3AudGV4dEZvbnQsIGJvbGQ6IHByb3AueGF4aXNUZXh0Qm9sZCB8fCBwcm9wLnRleHRCb2xkLCBjb2xvcjogcHJvcC54YXhpc1RleHRDb2xvciB8fCBwcm9wLnRleHRDb2xvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcC54YXhpc0xhYmVsc1Bvc2l0aW9uID09PSAnZWRnZScpIHtcbiAgICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgdmFyIGhtYXJnaW4gPSBwcm9wLmhtYXJnaW47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobWFyZ2luID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSAob2JqLmdyYXBoV2lkdGggLSBobWFyZ2luIC0gaG1hcmdpbikgLyAocHJvcC54YXhpc0xhYmVscy5sZW5ndGggLSAxKTtmb3IgKHZhciBpID0gMDsgaSA8IHByb3AueGF4aXNMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcHJvcC5ndXR0ZXJMZWZ0ICsgaSAqIHNlZ21lbnQgKyBobWFyZ2luO2lmIChvYmouc2NhbGUubWF4IDw9IDAgJiYgb2JqLnNjYWxlLm1pbiA8IDApIHtcbiAgICAgICAgICAgICAgdmFsaWduID0gJ2JvdHRvbSc7eSA9IHByb3AuZ3V0dGVyVG9wIC0gKFJHLlNWRy5JU0ZGID8gNSA6IDEwKSAtIChwcm9wLnhheGlzVGlja21hcmtzTGVuZ3RoIC0gNSkgLSAocHJvcC54YXhpc0xpbmV3aWR0aCB8fCAxKSArIHByb3AueGF4aXNMYWJlbHNPZmZzZXR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsaWduID0gJ3RvcCc7eSA9IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIChSRy5TVkcuSVNGRiA/IDUgOiAxMCkgKyAocHJvcC54YXhpc1RpY2ttYXJrc0xlbmd0aCAtIDUpICsgKHByb3AueGF4aXNMaW5ld2lkdGggfHwgMSkgKyBwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiBvYmosIHBhcmVudDogb2JqLnN2Zy5hbGwsIHRleHQ6IHByb3AueGF4aXNMYWJlbHNbaV0sIHg6IHggKyBwcm9wLnhheGlzTGFiZWxzT2Zmc2V0eCwgeTogeSwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogJ2NlbnRlcicsIHNpemU6IHByb3AueGF4aXNUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplLCBpdGFsaWM6IHByb3AueGF4aXNUZXh0SXRhbGljIHx8IHByb3AudGV4dEl0YWxpYywgZm9udDogcHJvcC54YXhpc1RleHRGb250IHx8IHByb3AudGV4dEZvbnQsIGJvbGQ6IHByb3AueGF4aXNUZXh0Qm9sZCB8fCBwcm9wLnRleHRCb2xkLCBjb2xvcjogcHJvcC54YXhpc1RleHRDb2xvciB8fCBwcm9wLnRleHRDb2xvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07UkcuU1ZHLmRyYXdZQXhpcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO2lmIChwcm9wLnlheGlzKSB7XG4gICAgICBpZiAob2JqLnR5cGUgPT09ICdoYmFyJykge1xuICAgICAgICB2YXIgeCA9IG9iai5nZXRYQ29vcmQocHJvcC54YXhpc01pbiA+IDAgPyBwcm9wLnhheGlzTWluIDogMCk7aWYgKHByb3AueGF4aXNNaW4gPCAwICYmIHByb3AueGF4aXNNYXggPD0gMCkge1xuICAgICAgICAgIHggPSBvYmouZ2V0WENvb3JkKHByb3AueGF4aXNNYXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9IHByb3AuZ3V0dGVyTGVmdDtcbiAgICAgIH1cbiAgICAgIHZhciBheGlzID0gUkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBvYmouc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6ICdNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHgsIHByb3AuZ3V0dGVyVG9wLCB4ICsgMC4wMDEsIG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSksIHN0cm9rZTogcHJvcC55YXhpc0NvbG9yLCBmaWxsOiBwcm9wLnlheGlzQ29sb3IsICdzdHJva2Utd2lkdGgnOiB0eXBlb2YgcHJvcC55YXhpc0xpbmV3aWR0aCA9PT0gJ251bWJlcicgPyBwcm9wLnlheGlzTGluZXdpZHRoIDogMSwgJ3NoYXBlLXJlbmRlcmluZyc6IFwiY3Jpc3BFZGdlc1wiLCAnc3Ryb2tlLWxpbmVjYXAnOiAnc3F1YXJlJyB9IH0pO2lmIChvYmoudHlwZSA9PT0gJ2hiYXInKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAob2JqLmdyYXBoSGVpZ2h0IC0gcHJvcC52bWFyZ2luVG9wIC0gcHJvcC52bWFyZ2luQm90dG9tKSAvIHByb3AueWF4aXNMYWJlbHMubGVuZ3RoLFxuICAgICAgICAgICAgeSA9IHByb3AuZ3V0dGVyVG9wICsgcHJvcC52bWFyZ2luVG9wLFxuICAgICAgICAgICAgbGVuID0gcHJvcC55YXhpc0xhYmVscy5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydFggPSBvYmouZ2V0WENvb3JkKDApICsgKHByb3AueGF4aXNNaW4gPCAwID8gcHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aCA6IDApLFxuICAgICAgICAgICAgZW5kWCA9IG9iai5nZXRYQ29vcmQoMCkgLSBwcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoO2lmIChvYmoudHlwZSA9PT0gJ2hiYXInICYmIHByb3AueGF4aXNNaW4gPCAwICYmIHByb3AueGF4aXNNYXggPD0gMCkge1xuICAgICAgICAgIHN0YXJ0WCA9IG9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCk7ZW5kWCA9IG9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCkgKyA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wLnlheGlzVGlja21hcmtzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQoc3RhcnRYLCB5LCBlbmRYLCB5ICsgMC4wMDEpLCBzdHJva2U6IHByb3AueWF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnlheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueWF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTt5ICs9IGhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3AueGF4aXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdoYmFyJyAmJiBwcm9wLnhheGlzTWluIDw9IDAgJiYgcHJvcC54YXhpc01heCA8IDApIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IG9iai5nZXRYQ29vcmQocHJvcC54YXhpc01heCk7dmFyIGVuZFggPSBvYmouZ2V0WENvb3JkKHByb3AueGF4aXNNYXgpICsgcHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydFggPSBvYmouZ2V0WENvb3JkKDApIC0gcHJvcC55YXhpc1RpY2ttYXJrc0xlbmd0aDt2YXIgZW5kWCA9IG9iai5nZXRYQ29vcmQoMCkgKyAocHJvcC54YXhpc01pbiA8IDAgPyBwcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXhpcyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiAnTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChzdGFydFgsIG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSAtIHBhcnNlRmxvYXQocHJvcC52bWFyZ2luQm90dG9tKSwgZW5kWCwgb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0gcGFyc2VGbG9hdChwcm9wLnZtYXJnaW5Cb3R0b20pIC0gMC4wMDEpLCBzdHJva2U6IG9iai5wcm9wZXJ0aWVzLnlheGlzQ29sb3IsICdzdHJva2Utd2lkdGgnOiB0eXBlb2YgcHJvcC55YXhpc0xpbmV3aWR0aCA9PT0gJ251bWJlcicgPyBwcm9wLnlheGlzTGluZXdpZHRoIDogMSwgJ3NoYXBlLXJlbmRlcmluZyc6IFwiY3Jpc3BFZGdlc1wiIH0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb2JqLmdyYXBoSGVpZ2h0IC8gcHJvcC55YXhpc0xhYmVsc0NvdW50LFxuICAgICAgICAgICAgeSA9IHByb3AuZ3V0dGVyVG9wLFxuICAgICAgICAgICAgbGVuID0gcHJvcC55YXhpc0xhYmVsc0NvdW50LFxuICAgICAgICAgICAgc3RhcnRYID0gcHJvcC5ndXR0ZXJMZWZ0LFxuICAgICAgICAgICAgZW5kWCA9IHByb3AuZ3V0dGVyTGVmdCAtIHByb3AueWF4aXNUaWNrbWFya3NMZW5ndGg7aWYgKHByb3AueWF4aXNUaWNrbWFya3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiAnTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChzdGFydFgsIHksIGVuZFgsIHkgKyAwLjAwMSksIHN0cm9rZTogcHJvcC55YXhpc0NvbG9yLCAnc3Ryb2tlLXdpZHRoJzogdHlwZW9mIHByb3AueWF4aXNMaW5ld2lkdGggPT09ICdudW1iZXInID8gcHJvcC55YXhpc0xpbmV3aWR0aCA6IDEsICdzaGFwZS1yZW5kZXJpbmcnOiBcImNyaXNwRWRnZXNcIiB9IH0pO3kgKz0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHByb3AueWF4aXNNaW4gIT09IDAgfHwgcHJvcC54YXhpcyA9PT0gZmFsc2UpICYmICEob2JqLnNjYWxlLm1pbiA+IDAgJiYgb2JqLnNjYWxlLm1heCA+IDApKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiAnTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQgLSBwcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoLCBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20sIHByb3AuZ3V0dGVyTGVmdCwgb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0gMC4wMDEpLCBzdHJva2U6IHByb3AueWF4aXNDb2xvciwgJ3N0cm9rZS13aWR0aCc6IHR5cGVvZiBwcm9wLnlheGlzTGluZXdpZHRoID09PSAnbnVtYmVyJyA/IHByb3AueWF4aXNMaW5ld2lkdGggOiAxLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3AueWF4aXNTY2FsZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSAob2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b20pIC8gcHJvcC55YXhpc0xhYmVsc0NvdW50O2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLnNjYWxlLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgeSA9IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSAtIHNlZ21lbnQgKiBpIC0gc2VnbWVudDtSRy5TVkcudGV4dCh7IG9iamVjdDogb2JqLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0ZXh0OiBvYmouc2NhbGUubGFiZWxzW2ldLCB4OiBwcm9wLmd1dHRlckxlZnQgLSA3IC0gKHByb3AueWF4aXMgPyBwcm9wLnlheGlzVGlja21hcmtzTGVuZ3RoIC0gMyA6IDApICsgcHJvcC55YXhpc0xhYmVsc09mZnNldHgsIHk6IHkgKyBwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eSwgaGFsaWduOiAncmlnaHQnLCB2YWxpZ246ICdjZW50ZXInLCBmb250OiBwcm9wLnlheGlzVGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC55YXhpc1RleHRTaXplIHx8ICh0eXBlb2YgcHJvcC50ZXh0U2l6ZSA9PT0gJ251bWJlcicgPyBwcm9wLnRleHRTaXplICsgJ3B0JyA6IHByb3AudGV4dFNpemUpLCBib2xkOiBwcm9wLnlheGlzVGV4dEJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgaXRhbGljOiBwcm9wLnlheGlzVGV4dEl0YWxpYyB8fCBwcm9wLnRleHRJdGFsaWMsIGNvbG9yOiBwcm9wLnlheGlzVGV4dENvbG9yIHx8IHByb3AudGV4dENvbG9yIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20sXG4gICAgICAgICAgc3RyID0gcHJvcC55YXhpc1VuaXRzUHJlICsgcHJvcC55YXhpc01pbi50b0ZpeGVkKHByb3AueWF4aXNEZWNpbWFscykucmVwbGFjZSgvXFwuLywgcHJvcC55YXhpc1BvaW50KSArIHByb3AueWF4aXNVbml0c1Bvc3Q7dmFyIHRleHQgPSBSRy5TVkcudGV4dCh7IG9iamVjdDogb2JqLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0ZXh0OiB0eXBlb2YgcHJvcC55YXhpc0Zvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3AueWF4aXNGb3JtYXR0ZXIodGhpcywgcHJvcC55YXhpc01pbikgOiBzdHIsIHg6IHByb3AuZ3V0dGVyTGVmdCAtIDcgLSAocHJvcC55YXhpcyA/IHByb3AueWF4aXNUaWNrbWFya3NMZW5ndGggLSAzIDogMCkgKyBwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eCwgeTogeSArIHByb3AueWF4aXNMYWJlbHNPZmZzZXR5LCBoYWxpZ246ICdyaWdodCcsIHZhbGlnbjogJ2NlbnRlcicsIGZvbnQ6IHByb3AueWF4aXNUZXh0Rm9udCB8fCBwcm9wLnRleHRGb250LCBzaXplOiBwcm9wLnlheGlzVGV4dFNpemUgfHwgKHR5cGVvZiBwcm9wLnRleHRTaXplID09PSAnbnVtYmVyJyA/IHByb3AudGV4dFNpemUgKyAncHQnIDogcHJvcC50ZXh0U2l6ZSksIGJvbGQ6IHByb3AueWF4aXNUZXh0Qm9sZCB8fCBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHByb3AueWF4aXNUZXh0SXRhbGljIHx8IHByb3AudGV4dEl0YWxpYywgY29sb3I6IHByb3AueWF4aXNUZXh0Q29sb3IgfHwgcHJvcC50ZXh0Q29sb3IgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9wLnlheGlzTGFiZWxzICYmIHByb3AueWF4aXNMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3AueWF4aXNMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSAob2JqLmdyYXBoSGVpZ2h0IC0gKHByb3Audm1hcmdpblRvcCB8fCAwKSAtIChwcm9wLnZtYXJnaW5Cb3R0b20gfHwgMCkpIC8gcHJvcC55YXhpc0xhYmVscy5sZW5ndGgsXG4gICAgICAgICAgICB5ID0gcHJvcC5ndXR0ZXJUb3AgKyAocHJvcC52bWFyZ2luVG9wIHx8IDApICsgc2VnbWVudCAqIGkgKyBzZWdtZW50IC8gMiArIHByb3AueWF4aXNMYWJlbHNPZmZzZXR5LFxuICAgICAgICAgICAgeCA9IHByb3AuZ3V0dGVyTGVmdCAtIDcgLSAocHJvcC55YXhpc0xpbmV3aWR0aCB8fCAxKSArIHByb3AueWF4aXNMYWJlbHNPZmZzZXR4LFxuICAgICAgICAgICAgaGFsaWduID0gJ3JpZ2h0JztpZiAob2JqLnR5cGUgPT09ICdoYmFyJyAmJiBvYmouc2NhbGUubWluIDwgb2JqLnNjYWxlLm1heCAmJiBvYmouc2NhbGUubWF4IDw9IDApIHtcbiAgICAgICAgICBoYWxpZ24gPSAnbGVmdCc7eCA9IG9iai53aWR0aCAtIHByb3AuZ3V0dGVyUmlnaHQgKyA3ICsgcHJvcC55YXhpc0xhYmVsc09mZnNldHg7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdoYmFyJyAmJiAhcHJvcC55YXhpc0xhYmVsc1NwZWNpZmljKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSAob2JqLmdyYXBoSGVpZ2h0IC0gKHByb3Audm1hcmdpblRvcCB8fCAwKSAtIChwcm9wLnZtYXJnaW5Cb3R0b20gfHwgMCkpIC8gcHJvcC55YXhpc0xhYmVscy5sZW5ndGg7eSA9IHByb3AuZ3V0dGVyVG9wICsgKHByb3Audm1hcmdpblRvcCB8fCAwKSArIHNlZ21lbnQgKiBpICsgc2VnbWVudCAvIDIgKyBwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IChvYmouZ3JhcGhIZWlnaHQgLSAocHJvcC52bWFyZ2luVG9wIHx8IDApIC0gKHByb3Audm1hcmdpbkJvdHRvbSB8fCAwKSkgLyAocHJvcC55YXhpc0xhYmVscy5sZW5ndGggLSAxKTt5ID0gb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0gc2VnbWVudCAqIGkgKyBwcm9wLnlheGlzTGFiZWxzT2Zmc2V0eDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IFJHLlNWRy50ZXh0KHsgb2JqZWN0OiBvYmosIHBhcmVudDogb2JqLnN2Zy5hbGwsIHRleHQ6IHByb3AueWF4aXNMYWJlbHNbaV0gPyBwcm9wLnlheGlzTGFiZWxzW2ldIDogJycsIHg6IHgsIHk6IHksIGhhbGlnbjogaGFsaWduLCB2YWxpZ246ICdjZW50ZXInLCBmb250OiBwcm9wLnlheGlzVGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC55YXhpc1RleHRTaXplIHx8ICh0eXBlb2YgcHJvcC50ZXh0U2l6ZSA9PT0gJ251bWJlcicgPyBwcm9wLnRleHRTaXplICsgJ3B0JyA6IHByb3AudGV4dFNpemUpLCBib2xkOiBwcm9wLnlheGlzVGV4dEJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgaXRhbGljOiBwcm9wLnlheGlzVGV4dEl0YWxpYyB8fCBwcm9wLnRleHRJdGFsaWMsIGNvbG9yOiBwcm9wLnlheGlzVGV4dENvbG9yIHx8IHByb3AudGV4dENvbG9yIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5TVkcuZHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHByb3AgPSBvYmoucHJvcGVydGllcztpZiAodHlwZW9mIHByb3AudmFyaWFudDNkT2Zmc2V0eCAhPT0gJ251bWJlcicpIHByb3AudmFyaWFudDNkT2Zmc2V0eCA9IDA7aWYgKHR5cGVvZiBwcm9wLnZhcmlhbnQzZE9mZnNldHkgIT09ICdudW1iZXInKSBwcm9wLnZhcmlhbnQzZE9mZnNldHkgPSAwO2lmIChwcm9wLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBvYmouc3ZnLmFsbCwgdHlwZTogJ3JlY3QnLCBhdHRyOiB7IHg6IC0xICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCB5OiAtMSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgd2lkdGg6IHBhcnNlRmxvYXQob2JqLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpICsgMiwgaGVpZ2h0OiBwYXJzZUZsb2F0KG9iai5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkgKyAyLCBmaWxsOiBwcm9wLmJhY2tncm91bmRDb2xvciB9IH0pO1xuICAgIH1cbiAgICBpZiAocHJvcC5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgIHZhciBhdHRyID0geyAneGxpbms6aHJlZic6IHByb3AuYmFja2dyb3VuZEltYWdlLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBwcm9wLmJhY2tncm91bmRJbWFnZUFzcGVjdCB8fCAnbm9uZScsIHg6IHByb3AuZ3V0dGVyTGVmdCwgeTogcHJvcC5ndXR0ZXJUb3AgfTtpZiAocHJvcC5iYWNrZ3JvdW5kSW1hZ2VTdHJldGNoKSB7XG4gICAgICAgIGF0dHIueCA9IHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eDthdHRyLnkgPSBwcm9wLmd1dHRlclRvcCArIHByb3AudmFyaWFudDNkT2Zmc2V0eTthdHRyLndpZHRoID0gb2JqLndpZHRoIC0gcHJvcC5ndXR0ZXJMZWZ0IC0gcHJvcC5ndXR0ZXJSaWdodDthdHRyLmhlaWdodCA9IG9iai5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wLmJhY2tncm91bmRJbWFnZVggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYXR0ci54ID0gcHJvcC5iYWNrZ3JvdW5kSW1hZ2VYICsgcHJvcC52YXJpYW50M2RPZmZzZXR4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcC5iYWNrZ3JvdW5kSW1hZ2VZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGF0dHIueSA9IHByb3AuYmFja2dyb3VuZEltYWdlWSArIHByb3AudmFyaWFudDNkT2Zmc2V0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3AuYmFja2dyb3VuZEltYWdlVyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhdHRyLndpZHRoID0gcHJvcC5iYWNrZ3JvdW5kSW1hZ2VXO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcC5iYWNrZ3JvdW5kSW1hZ2VIID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGF0dHIuaGVpZ2h0ID0gcHJvcC5iYWNrZ3JvdW5kSW1hZ2VIO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcC52YXJpYW50ID09PSAnM2QnKSB7XG4gICAgICAgIGF0dHIueCArPSBwcm9wLnZhcmlhbnQzZE9mZnNldHg7YXR0ci55IC09IHByb3AudmFyaWFudDNkT2Zmc2V0eTtcbiAgICAgIH1cbiAgICAgIHZhciBpbWcgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAnaW1hZ2UnLCBhdHRyOiBhdHRyLCBzdHlsZTogeyBvcGFjaXR5OiB0eXBlb2YgcHJvcC5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5ID09PSAnbnVtYmVyJyA/IHByb3AuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA6IDEgfSB9KTtcbiAgICB9XG4gICAgaWYgKHByb3AuYmFja2dyb3VuZEdyaWQpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdO2lmIChwcm9wLmJhY2tncm91bmRHcmlkSGxpbmVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHR5cGVvZiBwcm9wLmJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQgPT09ICdudW1iZXInID8gcHJvcC5iYWNrZ3JvdW5kR3JpZEhsaW5lc0NvdW50IDogb2JqLnR5cGUgPT09ICdoYmFyJyA/IHByb3AueWF4aXNMYWJlbHMubGVuZ3RoIHx8IG9iai5kYXRhLmxlbmd0aCB8fCA1IDogcHJvcC55YXhpc0xhYmVsc0NvdW50O2ZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goJ017MX0gezJ9IEx7M30gezR9Jy5mb3JtYXQocHJvcC5ndXR0ZXJMZWZ0ICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCBwcm9wLmd1dHRlclRvcCArIG9iai5ncmFwaEhlaWdodCAvIGNvdW50ICogaSAtIHByb3AudmFyaWFudDNkT2Zmc2V0eSwgb2JqLndpZHRoIC0gcHJvcC5ndXR0ZXJSaWdodCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgcHJvcC5ndXR0ZXJUb3AgKyBvYmouZ3JhcGhIZWlnaHQgLyBjb3VudCAqIGkgLSBwcm9wLnZhcmlhbnQzZE9mZnNldHkpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKCdNezF9IHsyfSBMezN9IHs0fScuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0gcHJvcC52YXJpYW50M2RPZmZzZXR5LCBvYmoud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0ICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gLSBwcm9wLnZhcmlhbnQzZE9mZnNldHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLmJhY2tncm91bmRHcmlkVmxpbmVzKSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2xpbmUnICYmIFJHLlNWRy5pc0FycmF5KG9iai5kYXRhWzBdKSkge1xuICAgICAgICAgIHZhciBsZW4gPSBvYmouZGF0YVswXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdoYmFyJykge1xuICAgICAgICAgIHZhciBsZW4gPSBwcm9wLnhheGlzTGFiZWxzQ291bnQgfHwgMTA7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdzY2F0dGVyJykge1xuICAgICAgICAgIHZhciBsZW4gPSBwcm9wLnhheGlzTGFiZWxzICYmIHByb3AueGF4aXNMYWJlbHMubGVuZ3RoIHx8IDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsZW4gPSBvYmouZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdHlwZW9mIHByb3AuYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudCA9PT0gJ251bWJlcicgPyBwcm9wLmJhY2tncm91bmRHcmlkVmxpbmVzQ291bnQgOiBsZW47aWYgKHByb3AueGF4aXNMYWJlbHNQb3NpdGlvbiA9PT0gJ2VkZ2UnKSB7XG4gICAgICAgICAgY291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgKytpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCgnTXsxfSB7Mn0gTHszfSB7NH0nLmZvcm1hdChwcm9wLmd1dHRlckxlZnQgKyBvYmouZ3JhcGhXaWR0aCAvIGNvdW50ICogaSArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLnZhcmlhbnQzZE9mZnNldHksIHByb3AuZ3V0dGVyTGVmdCArIG9iai5ncmFwaFdpZHRoIC8gY291bnQgKiBpICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gLSBwcm9wLnZhcmlhbnQzZE9mZnNldHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3AuYmFja2dyb3VuZEdyaWRCb3JkZXIpIHtcbiAgICAgICAgcGFydHMucHVzaCgnTXsxfSB7Mn0gTHszfSB7NH0gTHs1fSB7Nn0gTHs3fSB7OH0geicuZm9ybWF0KHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLnZhcmlhbnQzZE9mZnNldHksIG9iai53aWR0aCAtIHByb3AuZ3V0dGVyUmlnaHQgKyBwcm9wLnZhcmlhbnQzZE9mZnNldHgsIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC52YXJpYW50M2RPZmZzZXR5LCBvYmoud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0ICsgcHJvcC52YXJpYW50M2RPZmZzZXR4LCBvYmouaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gLSBwcm9wLnZhcmlhbnQzZE9mZnNldHksIHByb3AuZ3V0dGVyTGVmdCArIHByb3AudmFyaWFudDNkT2Zmc2V0eCwgb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0gcHJvcC52YXJpYW50M2RPZmZzZXR5KSk7XG4gICAgICB9XG4gICAgICB2YXIgZ3JpZCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiBwYXJ0cy5qb2luKCcgJyksIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLCBmaWxsOiAncmdiYSgwLDAsMCwwKScsICdzdHJva2Utd2lkdGgnOiBwcm9wLmJhY2tncm91bmRHcmlkTGluZXdpZHRoLCAnc2hhcGUtcmVuZGVyaW5nJzogXCJjcmlzcEVkZ2VzXCIgfSB9KTtcbiAgICB9XG4gICAgUkcuU1ZHLmRyYXdUaXRsZShvYmopO1xuICB9O1JHLlNWRy5pc051bGwgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGFyZyA9PSBudWxsIHx8ICh0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhcmcpKSA9PT0gJ29iamVjdCcgJiYgIWFyZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtSRy5TVkcuZ2V0U2NhbGUgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG9iaiA9IG9wdC5vYmplY3QsXG4gICAgICAgIHByb3AgPSBvYmoucHJvcGVydGllcyxcbiAgICAgICAgbnVtbGFiZWxzID0gb3B0Lm51bWxhYmVscyxcbiAgICAgICAgdW5pdHNQcmUgPSBvcHQudW5pdHNQcmUsXG4gICAgICAgIHVuaXRzUG9zdCA9IG9wdC51bml0c1Bvc3QsXG4gICAgICAgIG1heCA9IE51bWJlcihvcHQubWF4KSxcbiAgICAgICAgbWluID0gTnVtYmVyKG9wdC5taW4pLFxuICAgICAgICBzdHJpY3QgPSBvcHQuc3RyaWN0LFxuICAgICAgICBkZWNpbWFscyA9IE51bWJlcihvcHQuZGVjaW1hbHMpLFxuICAgICAgICBwb2ludCA9IG9wdC5wb2ludCxcbiAgICAgICAgdGhvdXNhbmQgPSBvcHQudGhvdXNhbmQsXG4gICAgICAgIG9yaWdpbmFsTWF4ID0gbWF4LFxuICAgICAgICByb3VuZCA9IG9wdC5yb3VuZCxcbiAgICAgICAgc2NhbGUgPSB7IG1heDogMSwgbGFiZWxzOiBbXSwgdmFsdWVzOiBbXSB9LFxuICAgICAgICBmb3JtYXR0ZXIgPSBvcHQuZm9ybWF0dGVyO2lmIChtYXggPT09IDAgJiYgbWluID09PSAwKSB7XG4gICAgICB2YXIgbWF4ID0gMTtmb3IgKHZhciBpID0gMDsgaSA8IG51bWxhYmVsczsgKytpKSB7XG4gICAgICAgIHZhciBsYWJlbCA9ICgobWF4IC0gbWluKSAvIG51bWxhYmVscyAqIChpICsgMSkgKyBtaW4pLnRvRml4ZWQoZGVjaW1hbHMpO3NjYWxlLmxhYmVscy5wdXNoKHVuaXRzUHJlICsgbGFiZWwgKyB1bml0c1Bvc3QpO3NjYWxlLnZhbHVlcy5wdXNoKHBhcnNlRmxvYXQobGFiZWwpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heCA8PSAxICYmICFzdHJpY3QpIHtcbiAgICAgIHZhciBhcnIgPSBbMSwgMC41LCAwLjEwLCAwLjA1LCAwLjAxMCwgMC4wMDUsIDAuMDAxMCwgMC4wMDA1LCAwLjAwMDEwLCAwLjAwMDA1LCAwLjAwMDAxMCwgMC4wMDAwMDUsIDAuMDAwMDAxMCwgMC4wMDAwMDA1LCAwLjAwMDAwMDEwLCAwLjAwMDAwMDA1LCAwLjAwMDAwMDAxMCwgMC4wMDAwMDAwMDUsIDAuMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDA1LCAwLjAwMDAwMDAwMDEwLCAwLjAwMDAwMDAwMDA1LCAwLjAwMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDAwMDUsIDAuMDAwMDAwMDAwMDAxMCwgMC4wMDAwMDAwMDAwMDA1XSxcbiAgICAgICAgICB2YWxzID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1heCA+IGFycltpXSkge1xuICAgICAgICAgIGktLTticmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2NhbGUubWF4ID0gYXJyW2ldO1xuICAgICAgc2NhbGUubGFiZWxzID0gW107c2NhbGUudmFsdWVzID0gW107Zm9yICh2YXIgaiA9IDA7IGogPCBudW1sYWJlbHM7ICsraikge1xuICAgICAgICB2YXIgdmFsdWUgPSAoKGFycltpXSAtIG1pbikgLyBudW1sYWJlbHMgKiAoaiArIDEpICsgbWluKS50b0ZpeGVkKGRlY2ltYWxzKTtzY2FsZS52YWx1ZXMucHVzaCh2YWx1ZSk7c2NhbGUubGFiZWxzLnB1c2goUkcuU1ZHLm51bWJlckZvcm1hdCh7IG9iamVjdDogb2JqLCBudW06IHZhbHVlLCBwcmVwZW5kOiB1bml0c1ByZSwgYXBwZW5kOiB1bml0c1Bvc3QsIHBvaW50OiBwcm9wLnlheGlzUG9pbnQsIHRob3VzYW5kOiBwcm9wLnlheGlzVGhvdXNhbmQsIGZvcm1hdHRlcjogZm9ybWF0dGVyIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgIG1heCA9IG1hLmNlaWwobWF4KTt2YXIgaW50ZXJ2YWwgPSBtYS5wb3coMTAsIG1hLm1heCgxLCBOdW1iZXIoU3RyaW5nKE51bWJlcihtYXgpIC0gTnVtYmVyKG1pbikpLmxlbmd0aCAtIDEpKSk7dmFyIHRvcFZhbHVlID0gaW50ZXJ2YWw7d2hpbGUgKHRvcFZhbHVlIDwgbWF4KSB7XG4gICAgICAgIHRvcFZhbHVlICs9IGludGVydmFsIC8gMjtcbiAgICAgIH1cbiAgICAgIGlmIChOdW1iZXIob3JpZ2luYWxNYXgpID4gTnVtYmVyKHRvcFZhbHVlKSkge1xuICAgICAgICB0b3BWYWx1ZSArPSBpbnRlcnZhbCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAobWF4IDw9IDEwKSB7XG4gICAgICAgIHRvcFZhbHVlID0gTnVtYmVyKG9yaWdpbmFsTWF4KSA8PSA1ID8gNSA6IDEwO1xuICAgICAgfVxuICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygcm91bmQgPT0gJ2Jvb2xlYW4nICYmIHJvdW5kKSB7XG4gICAgICAgIHRvcFZhbHVlID0gMTAgKiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHNjYWxlLm1heCA9IHRvcFZhbHVlO2ZvciAodmFyIGkgPSAwOyBpIDwgbnVtbGFiZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7IG9iamVjdDogb2JqLCBudW06ICgoaSArIDEpIC8gbnVtbGFiZWxzICogKHRvcFZhbHVlIC0gbWluKSArIG1pbikudG9GaXhlZChkZWNpbWFscyksIHByZXBlbmQ6IHVuaXRzUHJlLCBhcHBlbmQ6IHVuaXRzUG9zdCwgcG9pbnQ6IHBvaW50LCB0aG91c2FuZDogdGhvdXNhbmQsIGZvcm1hdHRlcjogZm9ybWF0dGVyIH0pO3NjYWxlLmxhYmVscy5wdXNoKGxhYmVsKTtzY2FsZS52YWx1ZXMucHVzaCgoKGkgKyAxKSAvIG51bWxhYmVscyAqICh0b3BWYWx1ZSAtIG1pbikgKyBtaW4pLnRvRml4ZWQoZGVjaW1hbHMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXggPT09ICdudW1iZXInICYmIHN0cmljdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1sYWJlbHM7ICsraSkge1xuICAgICAgICBzY2FsZS5sYWJlbHMucHVzaChSRy5TVkcubnVtYmVyRm9ybWF0KHsgb2JqZWN0OiBvYmosIGZvcm1hdHRlcjogZm9ybWF0dGVyLCBudW06ICgoaSArIDEpIC8gbnVtbGFiZWxzICogKG1heCAtIG1pbikgKyBtaW4pLnRvRml4ZWQoZGVjaW1hbHMpLCBwcmVwZW5kOiB1bml0c1ByZSwgYXBwZW5kOiB1bml0c1Bvc3QsIHBvaW50OiBwb2ludCwgdGhvdXNhbmQ6IHRob3VzYW5kIH0pKTtzY2FsZS52YWx1ZXMucHVzaCgoKGkgKyAxKSAvIG51bWxhYmVscyAqIChtYXggLSBtaW4pICsgbWluKS50b0ZpeGVkKGRlY2ltYWxzKSk7XG4gICAgICB9XG4gICAgICBzY2FsZS5tYXggPSBtYXg7XG4gICAgfVxuICAgIHNjYWxlLnVuaXRzUHJlID0gdW5pdHNQcmU7c2NhbGUudW5pdHNQb3N0ID0gdW5pdHNQb3N0O3NjYWxlLnBvaW50ID0gcG9pbnQ7c2NhbGUuZGVjaW1hbHMgPSBkZWNpbWFscztzY2FsZS50aG91c2FuZCA9IHRob3VzYW5kO3NjYWxlLm51bWxhYmVscyA9IG51bWxhYmVscztzY2FsZS5yb3VuZCA9IEJvb2xlYW4ocm91bmQpO3NjYWxlLm1pbiA9IG1pbjtmb3IgKHZhciBpID0gMDsgaSA8IHNjYWxlLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgc2NhbGUudmFsdWVzW2ldID0gcGFyc2VGbG9hdChzY2FsZS52YWx1ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07UkcuU1ZHLmFycmF5RmlsbCA9IFJHLlNWRy5hcnJheVBhZCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgYXJyID0gb3B0LmFycmF5LFxuICAgICAgICBsZW4gPSBvcHQubGVuZ3RoLFxuICAgICAgICB2YWx1ZSA9IG9wdC52YWx1ZSA/IG9wdC52YWx1ZSA6IG51bGw7aWYgKGFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07UkcuU1ZHLmFycmF5U3VtID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgaWYgKFJHLlNWRy5pc051bGwoYXJyKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBpLFxuICAgICAgICBzdW0sXG4gICAgICAgIGxlbiA9IGFyci5sZW5ndGg7Zm9yIChpID0gMCwgc3VtID0gMDsgaSA8IGxlbjsgc3VtICs9IGFycltpKytdKSB7fXJldHVybiBzdW07XG4gIH07UkcuU1ZHLmFycmF5TWF4ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBtYXggPSBudWxsO1xuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgaWYgKFJHLlNWRy5pc051bGwoYXJyKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdmFsID0gYXJndW1lbnRzWzFdID8gbWEuYWJzKGFycltpXSkgOiBhcnJbaV07aWYgKHR5cGVvZiBtYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbWF4ID0gbWEubWF4KG1heCwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfTtSRy5TVkcuYXJyYXlNaW4gPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG1heCA9IG51bGwsXG4gICAgICAgIG1pbiA9IG51bGwsXG4gICAgICAgIG1hID0gTWF0aDtpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGlmIChSRy5TVkcuaXNOdWxsKGFycikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAodHlwZW9mIGFycltpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1sxXSA/IG1hLmFicyhhcnJbaV0pIDogYXJyW2ldO2lmICh0eXBlb2YgbWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG1pbiA9IG1hLm1pbihtaW4sIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW47XG4gIH07UkcuU1ZHLmFycmF5UGFkID0gZnVuY3Rpb24gKGFyciwgbGVuKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHZhciB2YWwgPSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiBudWxsO2ZvciAodmFyIGkgPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1JHLlNWRy5hcnJheVN1bSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICBpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGlmIChSRy5TVkcuaXNOdWxsKGFycikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgaSxcbiAgICAgICAgc3VtLFxuICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO2ZvciAoaSA9IDAsIHN1bSA9IDA7IGkgPCBsZW47IHN1bSArPSBhcnJbaSsrXSkge31yZXR1cm4gc3VtO1xuICB9O1JHLlNWRy5hcnJheUxpbmVhcml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gW10sXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChfdHlwZW9mKGFyZ3NbaV0pID09PSAnb2JqZWN0JyAmJiBhcmdzW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gYXJnc1tpXS5sZW5ndGg7IGogPCBsZW4yOyArK2opIHtcbiAgICAgICAgICB2YXIgc3ViID0gUkcuU1ZHLmFycmF5TGluZWFyaXplKGFyZ3NbaV1bal0pO2ZvciAodmFyIGsgPSAwLCBsZW4zID0gc3ViLmxlbmd0aDsgayA8IGxlbjM7ICsraykge1xuICAgICAgICAgICAgYXJyLnB1c2goc3ViW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1JHLlNWRy5hcnJheVNoaWZ0ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciByZXQgPSBbXTtmb3IgKHZhciBpID0gMSwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByZXQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1JHLlNWRy5hcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgaWYgKCFhcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld2FyciA9IFtdO2ZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIG5ld2Fyci5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdhcnI7XG4gIH07UkcuU1ZHLmFycmF5Q2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoUkcuU1ZHLmlzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIHRlbXAgPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRlbXBbaV0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgICAgICAgfShvYmpbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGVtcFtpXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICAgICAgICB9KG9ialtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRlbXBbaV0gPSBvYmpbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFtpXSA9IFJHLlNWRy5hcnJheUNsb25lKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciB0ZW1wID0ge307Zm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRlbXBbaV0gPSBvYmpbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG4gIH07UkcuU1ZHLmFycmF5SW52ZXJ0ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycltpXSA9ICFhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07UkcuU1ZHLmFycmF5VHJpbSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNvbnRlbnQgPSBmYWxzZTtmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICBjb250ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIG91dC5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCA9IFJHLlNWRy5hcnJheVJldmVyc2Uob3V0KTt2YXIgb3V0MiA9IFtdLFxuICAgICAgICBjb250ZW50ID0gZmFsc2U7Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRbaV0pIHtcbiAgICAgICAgY29udGVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBvdXQyLnB1c2gob3V0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0MiA9IFJHLlNWRy5hcnJheVJldmVyc2Uob3V0Mik7cmV0dXJuIG91dDI7XG4gIH07UkcuU1ZHLmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IpIHtcbiAgICAgIHZhciBwb3MgPSBvYmouY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKCdBcnJheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyAmJiBwb3MgPiAwICYmIHBvcyA8IDIwO1xuICB9O1JHLlNWRy5hYnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG1hLmFicyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChpIGluIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGkgPT09ICdudW1iZXInIHx8ICh0eXBlb2YgaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhbHVlW2ldID0gUkcuU1ZHLmFicyh2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07UkcuU1ZHLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgb2JqID0gb3B0Lm9iamVjdCxcbiAgICAgICAgcHJlcGVuZCA9IG9wdC5wcmVwZW5kID8gU3RyaW5nKG9wdC5wcmVwZW5kKSA6ICcnLFxuICAgICAgICBhcHBlbmQgPSBvcHQuYXBwZW5kID8gU3RyaW5nKG9wdC5hcHBlbmQpIDogJycsXG4gICAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgICBkZWNpbWFsX3NlcGVyYXRvciA9IHR5cGVvZiBvcHQucG9pbnQgPT09ICdzdHJpbmcnID8gb3B0LnBvaW50IDogJy4nLFxuICAgICAgICB0aG91c2FuZF9zZXBlcmF0b3IgPSB0eXBlb2Ygb3B0LnRob3VzYW5kID09PSAnc3RyaW5nJyA/IG9wdC50aG91c2FuZCA6ICcsJyxcbiAgICAgICAgbnVtID0gb3B0Lm51bTtSZWdFeHAuJDEgPSAnJztpZiAodHlwZW9mIG9wdC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcHQuZm9ybWF0dGVyKG9iaiwgbnVtKTtcbiAgICB9XG4gICAgaWYgKFN0cmluZyhudW0pLmluZGV4T2YoJ2UnKSA+IDApIHtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlcGVuZCArIFN0cmluZyhudW0pICsgYXBwZW5kKTtcbiAgICB9XG4gICAgbnVtID0gU3RyaW5nKG51bSk7aWYgKG51bS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICB2YXIgdG1wID0gbnVtO251bSA9IG51bS5yZXBsYWNlKC9cXC4oLiopLywgJycpO2RlY2ltYWwgPSB0bXAucmVwbGFjZSgvKC4qKVxcLiguKikvLCAnJDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjaW1hbCA9ICcnO1xuICAgIH1cbiAgICB2YXIgc2VwZXJhdG9yID0gdGhvdXNhbmRfc2VwZXJhdG9yO3ZhciBmb3VuZFBvaW50O2ZvciAoaSA9IG51bS5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBqKyssIGktLSkge1xuICAgICAgdmFyIGNoYXJhY3RlciA9IG51bS5jaGFyQXQoaSk7aWYgKGogJSAzID09IDAgJiYgaiAhPSAwKSB7XG4gICAgICAgIG91dHB1dCArPSBzZXBlcmF0b3I7XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gY2hhcmFjdGVyO1xuICAgIH1cbiAgICB2YXIgcmV2ID0gb3V0cHV0O291dHB1dCA9ICcnO2ZvciAoaSA9IHJldi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgb3V0cHV0ICs9IHJldi5jaGFyQXQoaSk7XG4gICAgfVxuICAgIGlmIChvdXRwdXQuaW5kZXhPZignLScgKyB0aG91c2FuZF9zZXBlcmF0b3IpID09IDApIHtcbiAgICAgIG91dHB1dCA9ICctJyArIG91dHB1dC5zdWJzdHIoKCctJyArIHRob3VzYW5kX3NlcGVyYXRvcikubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGRlY2ltYWwubGVuZ3RoKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQgKyBkZWNpbWFsX3NlcGVyYXRvciArIGRlY2ltYWw7ZGVjaW1hbCA9ICcnO1JlZ0V4cC4kMSA9ICcnO1xuICAgIH1cbiAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSA9PSAnLScpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8tLywgJycpO3ByZXBlbmQgPSAnLScgKyBwcmVwZW5kO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGVuZCArIG91dHB1dCArIGFwcGVuZDtcbiAgfTtSRy5TVkcudGV4dCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgb2JqID0gb3B0Lm9iamVjdCxcbiAgICAgICAgcGFyZW50ID0gb3B0LnBhcmVudCB8fCBvcHQub2JqZWN0LnN2Zy5hbGwsXG4gICAgICAgIHNpemUgPSBvcHQuc2l6ZSxcbiAgICAgICAgYm9sZCA9IG9wdC5ib2xkLFxuICAgICAgICBmb250ID0gb3B0LmZvbnQsXG4gICAgICAgIGl0YWxpYyA9IG9wdC5pdGFsaWMsXG4gICAgICAgIGhhbGlnbiA9IG9wdC5oYWxpZ24sXG4gICAgICAgIHZhbGlnbiA9IG9wdC52YWxpZ24sXG4gICAgICAgIHN0ciA9IG9wdC50ZXh0LFxuICAgICAgICB4ID0gb3B0LngsXG4gICAgICAgIHkgPSBvcHQueSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgPyBvcHQuY29sb3IgOiAnYmxhY2snLFxuICAgICAgICBiYWNrZ3JvdW5kID0gb3B0LmJhY2tncm91bmQgfHwgbnVsbCxcbiAgICAgICAgcGFkZGluZyA9IG9wdC5wYWRkaW5nIHx8IDA7aWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaGFsaWduID0gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdjZW50ZXInIHx8IGhhbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgIGhhbGlnbiA9ICdtaWRkbGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYWxpZ24gPSAnc3RhcnQnO1xuICAgIH1cbiAgICBpZiAodmFsaWduID09PSAndG9wJykge1xuICAgICAgdmFsaWduID0gJ2hhbmdpbmcnO1xuICAgIH0gZWxzZSBpZiAodmFsaWduID09PSAnY2VudGVyJyB8fCB2YWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICB2YWxpZ24gPSAnY2VudHJhbCc7dmFsaWduID0gJ21pZGRsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlnbiA9ICdib3R0b20nO1xuICAgIH1cbiAgICB2YXIgdGV4dCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb3B0LnBhcmVudCwgdHlwZTogJ3RleHQnLCBhdHRyOiB7IGZpbGw6IGNvbG9yLCB4OiB4LCB5OiB5LCAnZm9udC1zaXplJzogdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSArICdwdCcgOiBzaXplLCAnZm9udC13ZWlnaHQnOiBib2xkID8gOTAwIDogMTAwLCAnZm9udC1mYW1pbHknOiBmb250ID8gZm9udCA6ICdzYW5zLXNlcmlmJywgJ2ZvbnQtc3R5bGUnOiBpdGFsaWMgPyAnaXRhbGljJyA6ICdub3JtYWwnLCAndGV4dC1hbmNob3InOiBoYWxpZ24sICdkb21pbmFudC1iYXNlbGluZSc6IHZhbGlnbiB9IH0pO3ZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cik7dGV4dC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7aWYgKHR5cGVvZiBiYWNrZ3JvdW5kID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGJib3ggPSB0ZXh0LmdldEJCb3goKSxcbiAgICAgICAgICByZWN0ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBvcHQucGFyZW50LCB0eXBlOiAncmVjdCcsIGF0dHI6IHsgeDogYmJveC54IC0gcGFkZGluZywgeTogYmJveC55IC0gcGFkZGluZywgd2lkdGg6IGJib3gud2lkdGggKyBwYWRkaW5nICogMiwgaGVpZ2h0OiBiYm94LmhlaWdodCArIHBhZGRpbmcgKiAyLCBmaWxsOiBiYWNrZ3JvdW5kIH0gfSk7cGFyZW50Lmluc2VydEJlZm9yZShyZWN0LCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKFJHLlNWRy5JU0lFICYmIHZhbGlnbiA9PT0gJ2hhbmdpbmcnKSB7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneScsIHkgKyB0ZXh0LnNjcm9sbEhlaWdodCAvIDIpO1xuICAgIH0gZWxzZSBpZiAoUkcuU1ZHLklTSUUgJiYgdmFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3knLCB5ICsgdGV4dC5zY3JvbGxIZWlnaHQgLyAzKTtcbiAgICB9XG4gICAgaWYgKFJHLlNWRy5JU0ZGKSB7XG4gICAgICBZID0geSArIHRleHQuc2Nyb2xsSGVpZ2h0IC8gMztcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07UkcuU1ZHLmNyZWF0ZVVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHIgPSBtYS5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgICB2ID0gYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtyZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG4gIH07UkcuU1ZHLmlzRml4ZWQgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIG9iaiA9IHN2Zy5wYXJlbnROb2RlLFxuICAgICAgICBpID0gMDt3aGlsZSAob2JqICYmIG9iai50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2JvZHknICYmIGkgPCA5OSkge1xuICAgICAgaWYgKG9iai5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1JHLlNWRy5SRUcuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgUkcuU1ZHLlJFRy5zdG9yZVtuYW1lXSA9IHZhbHVlO3JldHVybiB2YWx1ZTtcbiAgfTtSRy5TVkcuUkVHLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIFJHLlNWRy5SRUcuc3RvcmVbbmFtZV07XG4gIH07UkcuU1ZHLnRyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIFJHLlNWRy5sdHJpbShSRy5TVkcucnRyaW0oc3RyKSk7XG4gIH07UkcuU1ZHLmx0cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXihcXHN8XFwwKSsvLCAnJyk7XG4gIH07UkcuU1ZHLnJ0cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcc3xcXDApKyQvLCAnJyk7XG4gIH07UkcuU1ZHLmhpZGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b29sdGlwID0gUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAnKTtpZiAodG9vbHRpcCAmJiB0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIHRvb2x0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b29sdGlwKTt0b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7dG9vbHRpcC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7UkcuU1ZHLlJFRy5zZXQoJ3Rvb2x0aXAnLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fX29iamVjdF9fKSB7XG4gICAgICBSRy5TVkcucmVtb3ZlSGlnaGxpZ2h0KHRvb2x0aXAuX19vYmplY3RfXyk7XG4gICAgfVxuICB9O1JHLlNWRy5zZXRTaGFkb3cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zLm9iamVjdCxcbiAgICAgICAgb2Zmc2V0eCA9IG9wdGlvbnMub2Zmc2V0eCB8fCAwLFxuICAgICAgICBvZmZzZXR5ID0gb3B0aW9ucy5vZmZzZXR5IHx8IDAsXG4gICAgICAgIGJsdXIgPSBvcHRpb25zLmJsdXIgfHwgMCxcbiAgICAgICAgb3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eSB8fCAwLFxuICAgICAgICBpZCA9IG9wdGlvbnMuaWQ7dmFyIGZpbHRlciA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5kZWZzLCB0eXBlOiAnZmlsdGVyJywgYXR0cjogeyBpZDogaWQsIHdpZHRoOiBcIjEzMCVcIiwgaGVpZ2h0OiBcIjEzMCVcIiB9IH0pO1JHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogZmlsdGVyLCB0eXBlOiAnZmVPZmZzZXQnLCBhdHRyOiB7IHJlc3VsdDogJ29mZk91dCcsICdpbic6ICdTb3VyY2VHcmFwaGljJywgZHg6IG9mZnNldHgsIGR5OiBvZmZzZXR5IH0gfSk7UkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBmaWx0ZXIsIHR5cGU6ICdmZUNvbG9yTWF0cml4JywgYXR0cjogeyByZXN1bHQ6ICdtYXRyaXhPdXQnLCAnaW4nOiAnb2ZmT3V0JywgdHlwZTogJ21hdHJpeCcsIHZhbHVlczogJzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIHsxfSAwJy5mb3JtYXQob3BhY2l0eSkgfSB9KTtSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IGZpbHRlciwgdHlwZTogJ2ZlR2F1c3NpYW5CbHVyJywgYXR0cjogeyByZXN1bHQ6ICdibHVyT3V0JywgJ2luJzogJ21hdHJpeE91dCcsIHN0ZERldmlhdGlvbjogYmx1ciB9IH0pO1JHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogZmlsdGVyLCB0eXBlOiAnZmVCbGVuZCcsIGF0dHI6IHsgJ2luJzogJ1NvdXJjZUdyYXBoaWMnLCAnaW4yJzogJ2JsdXJPdXQnLCBtb2RlOiAnbm9ybWFsJyB9IH0pO1xuICB9O1JHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEpIHtcbiAgICB2YXIgZ3JvdXAgPSAwLFxuICAgICAgICBncm91cGVkX2luZGV4ID0gMDt3aGlsZSAoLS1pbmRleCA+PSAwKSB7XG4gICAgICBpZiAoUkcuU1ZHLmlzTnVsbChkYXRhW2dyb3VwXSkpIHtcbiAgICAgICAgZ3JvdXArKztncm91cGVkX2luZGV4ID0gMDtjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtncm91cF0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgZ3JvdXArKztcbiAgICAgICAgZ3JvdXBlZF9pbmRleCA9IDA7Y29udGludWU7XG4gICAgICB9XG4gICAgICBncm91cGVkX2luZGV4Kys7aWYgKGdyb3VwZWRfaW5kZXggPj0gZGF0YVtncm91cF0ubGVuZ3RoKSB7XG4gICAgICAgIGdyb3VwKys7Z3JvdXBlZF9pbmRleCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbZ3JvdXAsIGdyb3VwZWRfaW5kZXhdO1xuICB9O1JHLlNWRy5UUklHLnRvQ2FydGVzaWFuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyB4OiBvcHRpb25zLmN4ICsgb3B0aW9ucy5yICogbWEuY29zKG9wdGlvbnMuYW5nbGUpLCB5OiBvcHRpb25zLmN5ICsgb3B0aW9ucy5yICogbWEuc2luKG9wdGlvbnMuYW5nbGUpIH07XG4gIH07UkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zdGFydCAtPSAxLjU3O29wdGlvbnMuZW5kIC09IDEuNTc7dmFyIHN0YXJ0ID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oeyBjeDogb3B0aW9ucy5jeCwgY3k6IG9wdGlvbnMuY3ksIHI6IG9wdGlvbnMuciwgYW5nbGU6IG9wdGlvbnMuc3RhcnQgfSk7dmFyIGVuZCA9IFJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHsgY3g6IG9wdGlvbnMuY3gsIGN5OiBvcHRpb25zLmN5LCByOiBvcHRpb25zLnIsIGFuZ2xlOiBvcHRpb25zLmVuZCB9KTt2YXIgZGlmZiA9IG9wdGlvbnMuZW5kIC0gb3B0aW9ucy5zdGFydDt2YXIgbGFyZ2VBcmMgPSAnMCc7dmFyIHN3ZWVwID0gJzAnO2lmIChvcHRpb25zLmFudGljbG9ja3dpc2UgJiYgZGlmZiA+IDMuMTQpIHtcbiAgICAgIGxhcmdlQXJjID0gJzAnO3N3ZWVwID0gJzAnO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hbnRpY2xvY2t3aXNlICYmIGRpZmYgPD0gMy4xNCkge1xuICAgICAgbGFyZ2VBcmMgPSAnMSc7c3dlZXAgPSAnMCc7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5hbnRpY2xvY2t3aXNlICYmIGRpZmYgPiAzLjE0KSB7XG4gICAgICBsYXJnZUFyYyA9ICcxJztzd2VlcCA9ICcxJztcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmFudGljbG9ja3dpc2UgJiYgZGlmZiA8PSAzLjE0KSB7XG4gICAgICBsYXJnZUFyYyA9ICcwJztzd2VlcCA9ICcxJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhcnQgPiBvcHRpb25zLmVuZCAmJiBvcHRpb25zLmFudGljbG9ja3dpc2UgJiYgZGlmZiA8PSAzLjE0KSB7XG4gICAgICBsYXJnZUFyYyA9ICcwJztzd2VlcCA9ICcwJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhcnQgPiBvcHRpb25zLmVuZCAmJiBvcHRpb25zLmFudGljbG9ja3dpc2UgJiYgZGlmZiA+IDMuMTQpIHtcbiAgICAgIGxhcmdlQXJjID0gJzEnO3N3ZWVwID0gJzEnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubW92ZXRvID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5tb3ZldG8gPT09IGZhbHNlKSB7XG4gICAgICB2YXIgZCA9IFtcIkFcIiwgb3B0aW9ucy5yLCBvcHRpb25zLnIsIDAsIGxhcmdlQXJjLCBzd2VlcCwgZW5kLngsIGVuZC55XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGQgPSBbXCJNXCIsIHN0YXJ0LngsIHN0YXJ0LnksIFwiQVwiLCBvcHRpb25zLnIsIG9wdGlvbnMuciwgMCwgbGFyZ2VBcmMsIHN3ZWVwLCBlbmQueCwgZW5kLnldO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hcnJheSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfTtSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zdGFydCAtPSAxLjU3O29wdGlvbnMuZW5kIC09IDEuNTc7dmFyIHN0YXJ0ID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oeyBjeDogb3B0aW9ucy5jeCwgY3k6IG9wdGlvbnMuY3ksIHI6IG9wdGlvbnMuciwgYW5nbGU6IG9wdGlvbnMuc3RhcnQgfSk7dmFyIGVuZCA9IFJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHsgY3g6IG9wdGlvbnMuY3gsIGN5OiBvcHRpb25zLmN5LCByOiBvcHRpb25zLnIsIGFuZ2xlOiBvcHRpb25zLmVuZCB9KTt2YXIgZGlmZiA9IG1hLmFicyhvcHRpb25zLmVuZCAtIG9wdGlvbnMuc3RhcnQpO3ZhciBsYXJnZUFyYyA9ICcwJzt2YXIgc3dlZXAgPSAnMCc7aWYgKCFvcHRpb25zLmFudGljbG9ja3dpc2UpIHtcbiAgICAgIGlmIChkaWZmID4gUkcuU1ZHLlRSSUcuUEkpIHtcbiAgICAgICAgbGFyZ2VBcmMgPSAnMSc7c3dlZXAgPSAnMSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXJnZUFyYyA9ICcwJztzd2VlcCA9ICcxJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpZmYgPiBSRy5TVkcuVFJJRy5QSSkge1xuICAgICAgICBsYXJnZUFyYyA9ICcxJztzd2VlcCA9ICcwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhcmdlQXJjID0gJzAnO3N3ZWVwID0gJzAnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXRvID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5saW5ldG8gPT09IGZhbHNlKSB7XG4gICAgICB2YXIgZCA9IFtcIk1cIiwgc3RhcnQueCwgc3RhcnQueSwgXCJBXCIsIG9wdGlvbnMuciwgb3B0aW9ucy5yLCAwLCBsYXJnZUFyYywgc3dlZXAsIGVuZC54LCBlbmQueV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkID0gW1wiTVwiLCBvcHRpb25zLmN4LCBvcHRpb25zLmN5LCBcIkxcIiwgc3RhcnQueCwgc3RhcnQueSwgXCJBXCIsIG9wdGlvbnMuciwgb3B0aW9ucy5yLCAwLCBsYXJnZUFyYywgc3dlZXAsIGVuZC54LCBlbmQueV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFycmF5ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGQuam9pbihcIiBcIik7XG4gICAgfVxuICB9O1JHLlNWRy5UUklHLmdldEFyY1BhdGgzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnN0YXJ0IC09IDEuNTc7b3B0aW9ucy5lbmQgLT0gMS41Nzt2YXIgc3RhcnQgPSBSRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7IGN4OiBvcHRpb25zLmN4LCBjeTogb3B0aW9ucy5jeSwgcjogb3B0aW9ucy5yLCBhbmdsZTogb3B0aW9ucy5zdGFydCB9KTt2YXIgZW5kID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oeyBjeDogb3B0aW9ucy5jeCwgY3k6IG9wdGlvbnMuY3ksIHI6IG9wdGlvbnMuciwgYW5nbGU6IG9wdGlvbnMuZW5kIH0pO3ZhciBkaWZmID0gbWEuYWJzKG9wdGlvbnMuZW5kIC0gb3B0aW9ucy5zdGFydCk7dmFyIGxhcmdlQXJjID0gJzAnO3ZhciBzd2VlcCA9ICcwJztpZiAoIW9wdGlvbnMuYW50aWNsb2Nrd2lzZSkge1xuICAgICAgaWYgKGRpZmYgPiBSRy5TVkcuVFJJRy5QSSkge1xuICAgICAgICBsYXJnZUFyYyA9ICcxJztzd2VlcCA9ICcxJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhcmdlQXJjID0gJzAnO3N3ZWVwID0gJzEnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlmZiA+IFJHLlNWRy5UUklHLlBJKSB7XG4gICAgICAgIGxhcmdlQXJjID0gJzEnO3N3ZWVwID0gJzAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFyZ2VBcmMgPSAnMCc7c3dlZXAgPSAnMCc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5ldG8gPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmxpbmV0byA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBkID0gW1wiTVwiLCBzdGFydC54LCBzdGFydC55LCBcIkFcIiwgb3B0aW9ucy5yLCBvcHRpb25zLnIsIDAsIGxhcmdlQXJjLCBzd2VlcCwgZW5kLngsIGVuZC55XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGQgPSBbXCJMXCIsIHN0YXJ0LngsIHN0YXJ0LnksIFwiQVwiLCBvcHRpb25zLnIsIG9wdGlvbnMuciwgMCwgbGFyZ2VBcmMsIHN3ZWVwLCBlbmQueCwgZW5kLnldO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hcnJheSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfTtSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGFuZ2xlID0gb3B0LmFuZ2xlLFxuICAgICAgICAgIHIgPSBvcHQucjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBhbmdsZSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICByID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICB2YXIgeCA9IG1hLmNvcyhhbmdsZSkgKiByLFxuICAgICAgICB5ID0gbWEuc2luKGFuZ2xlKSAqIHI7cmV0dXJuIFt4LCB5XTtcbiAgfTtSRy5TVkcuZHJhd1RpdGxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm9wID0gb2JqLnByb3BlcnRpZXM7dmFyIHZhbGlnbiA9ICdib3R0b20nO2lmIChvYmoudHlwZSA9PT0gJ3BpZScpIHtcbiAgICAgIGlmIChSRy5TVkcuaXNOdWxsKHByb3AudGl0bGVYKSkge1xuICAgICAgICBwcm9wLnRpdGxlWCA9IG9iai5jZW50ZXJ4O3Byb3AudGl0bGVTdWJ0aXRsZVggPSBvYmouY2VudGVyeDtcbiAgICAgIH1cbiAgICAgIGlmIChSRy5TVkcuaXNOdWxsKHByb3AudGl0bGVZKSkge1xuICAgICAgICBwcm9wLnRpdGxlWSA9IG9iai5jZW50ZXJ5IC0gb2JqLnJhZGl1cyAtIDEwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLnNjYWxlICYmIG9iai5zY2FsZS5tYXggPD0gMCAmJiBvYmouc2NhbGUubWluIDwgMCAmJiB0eXBlb2YgcHJvcC50aXRsZVkgIT09ICdudW1iZXInICYmIG9iai50eXBlICE9PSAnaGJhcicpIHtcbiAgICAgIHByb3AudGl0bGVZID0gb2JqLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tICsgMTA7dmFyIHBvc2l0aW9uQm90dG9tID0gdHJ1ZTt2YWxpZ24gPSAndG9wJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wLnRpdGxlWSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBwb3NpdGlvbkJvdHRvbSA9IGZhbHNlO3Byb3AudGl0bGVZID0gcHJvcC5ndXR0ZXJUb3AgLSAxMDt2YWxpZ24gPSAnYm90dG9tJztpZiAoIVJHLlNWRy5pc051bGwocHJvcC5rZXkpKSB7XG4gICAgICAgIHByb3AudGl0bGVZIC09IDIgKiAocHJvcC5rZXlUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3AudGl0bGVTdWJ0aXRsZSAmJiB0eXBlb2YgcHJvcC50aXRsZVN1YnRpdGxlWSAhPT0gJ251bWJlcicgJiYgIXBvc2l0aW9uQm90dG9tKSB7XG4gICAgICBwcm9wLnRpdGxlWSA9IHByb3AudGl0bGVZIC0gcHJvcC50aXRsZVN1YnRpdGxlU2l6ZSAqIDEuNTtcbiAgICB9XG4gICAgcHJvcC50aXRsZVN1YlRpdGxlU2l6ZSA9IHByb3AudGl0bGVTdWJUaXRsZVNpemUgfHwgcHJvcC50ZXh0U2l6ZTtwcm9wLnRpdGxlU3VidGl0bGVZID0gcHJvcC50aXRsZVN1YnRpdGxlWSB8fCBwcm9wLnRpdGxlWSArIDE4O2lmIChwb3NpdGlvbkJvdHRvbSAmJiB0eXBlb2YgcHJvcC50aXRsZVN1YnRpdGxlWSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHByb3AudGl0bGVTdWJ0aXRsZVkgPSBwcm9wLnRpdGxlWSArIDI2O1xuICAgIH1cbiAgICBpZiAocHJvcC50aXRsZSkge1xuICAgICAgUkcuU1ZHLnRleHQoeyBvYmplY3Q6IG9iaiwgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0ZXh0OiBwcm9wLnRpdGxlLnRvU3RyaW5nKCksIHNpemU6IHByb3AudGl0bGVTaXplIHx8IHByb3AudGV4dFNpemUgKyA0IHx8IDE2LCB4OiB0eXBlb2YgcHJvcC50aXRsZVggPT09ICdudW1iZXInID8gcHJvcC50aXRsZVggKyAocHJvcC52YXJpYW50M2RPZmZzZXR4IHx8IDApIDogcHJvcC5ndXR0ZXJMZWZ0ICsgb2JqLmdyYXBoV2lkdGggLyAyICsgKHByb3AudmFyaWFudDNkT2Zmc2V0eCB8fCAwKSwgeTogcHJvcC50aXRsZVkgKyAocHJvcC52YXJpYW50M2RPZmZzZXR5IHx8IDApLCBoYWxpZ246IHByb3AudGl0bGVIYWxpZ24gfHwgJ2NlbnRlcicsIHZhbGlnbjogcHJvcC50aXRsZVZhbGlnbiB8fCB2YWxpZ24sIGNvbG9yOiBwcm9wLnRpdGxlQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3IgfHwgJ2JsYWNrJywgYm9sZDogcHJvcC50aXRsZUJvbGQgfHwgZmFsc2UsIGl0YWxpYzogcHJvcC50aXRsZUl0YWxpYyB8fCBmYWxzZSwgZm9udDogcHJvcC50aXRsZUZvbnQgfHwgcHJvcC50ZXh0Rm9udCB8fCAnQXJpYWwnIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcC50aXRsZVN1YnRpdGxlKSB7XG4gICAgICBSRy5TVkcudGV4dCh7IG9iamVjdDogb2JqLCBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHRleHQ6IHByb3AudGl0bGVTdWJ0aXRsZSwgc2l6ZTogcHJvcC50aXRsZVN1YnRpdGxlU2l6ZSwgeDogdHlwZW9mIHByb3AudGl0bGVTdWJ0aXRsZVggPT09ICdudW1iZXInID8gcHJvcC50aXRsZVN1YnRpdGxlWCA6IHByb3AuZ3V0dGVyTGVmdCArIG9iai5ncmFwaFdpZHRoIC8gMiArIChwcm9wLnZhcmlhbnQzZE9mZnNldHggfHwgMCksIHk6IHByb3AudGl0bGVTdWJ0aXRsZVkgKyAocHJvcC52YXJpYW50M2RPZmZzZXR5IHx8IDApLCBoYWxpZ246IHByb3AudGl0bGVTdWJ0aXRsZUhhbGlnbiB8fCAnY2VudGVyJywgdmFsaWduOiBwcm9wLnRpdGxlU3VidGl0bGVWYWxpZ24gfHwgdmFsaWduLCBjb2xvcjogcHJvcC50aXRsZVN1YnRpdGxlQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3IgfHwgJyNhYWEnLCBib2xkOiBwcm9wLnRpdGxlU3VidGl0bGVCb2xkIHx8IGZhbHNlLCBpdGFsaWM6IHByb3AudGl0bGVTdWJ0aXRsZUl0YWxpYyB8fCBmYWxzZSwgZm9udDogcHJvcC50aXRsZVN1YnRpdGxlRm9udCB8fCBwcm9wLnRleHRGb250IHx8ICdBcmlhbCcgfSk7XG4gICAgfVxuICB9O1JHLlNWRy50cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBSRy5TVkcubHRyaW0oUkcuU1ZHLnJ0cmltKHN0cikpO1xuICB9O1JHLlNWRy5sdHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvXihcXHN8XFwwKSsvLCAnJyk7XG4gIH07UkcuU1ZHLnJ0cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oXFxzfFxcMCkrJC8sICcnKTtcbiAgfTtSRy5TVkcucGFyc2VDb2xvckxpbmVhciA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgb2JqID0gb3B0Lm9iamVjdCxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3I7aWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGlmIChjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpLFxuICAgICAgICAgIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2lmIChvcHQgJiYgb3B0LmRpcmVjdGlvbiAmJiBvcHQuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBSRy5TVkcuY3JlYXRlKHsgdHlwZTogJ2xpbmVhckdyYWRpZW50JywgcGFyZW50OiBvYmouc3ZnLmRlZnMsIGF0dHI6IHsgaWQ6ICdSR3JhcGgtbGluZWFyLWdyYWRpZW50JyArIG9iai5ncmFkaWVudENvdW50ZXIsIHgxOiBvcHQuc3RhcnQgfHwgMCwgeDI6IG9wdC5lbmQgfHwgJzEwMCUnLCB5MTogMCwgeTI6IDAsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiB9IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGdyYWQgPSBSRy5TVkcuY3JlYXRlKHsgdHlwZTogJ2xpbmVhckdyYWRpZW50JywgcGFyZW50OiBvYmouc3ZnLmRlZnMsIGF0dHI6IHsgaWQ6ICdSR3JhcGgtbGluZWFyLWdyYWRpZW50JyArIG9iai5ncmFkaWVudENvdW50ZXIsIHgxOiAwLCB4MjogMCwgeTE6IG9wdC5zdGFydCB8fCAwLCB5Mjogb3B0LmVuZCB8fCAnMTAwJScsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiB9IH0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0b3AgPSBSRy5TVkcuY3JlYXRlKHsgdHlwZTogJ3N0b3AnLCBwYXJlbnQ6IGdyYWQsIGF0dHI6IHsgb2Zmc2V0OiAnMCUnLCAnc3RvcC1jb2xvcic6IFJHLlNWRy50cmltKHBhcnRzWzBdKSB9IH0pO2ZvciAodmFyIGogPSAxLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICBSRy5TVkcuY3JlYXRlKHsgdHlwZTogJ3N0b3AnLCBwYXJlbnQ6IGdyYWQsIGF0dHI6IHsgb2Zmc2V0OiBqICogZGlmZiAqIDEwMCArICclJywgJ3N0b3AtY29sb3InOiBSRy5TVkcudHJpbShwYXJ0c1tqXSkgfSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sb3IgPSBncmFkID8gJ3VybCgjUkdyYXBoLWxpbmVhci1ncmFkaWVudCcgKyBvYmouZ3JhZGllbnRDb3VudGVyKysgKyAnKScgOiBjb2xvcjtyZXR1cm4gY29sb3I7XG4gIH07UkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG9iaiA9IG9wdC5vYmplY3QsXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yO2lmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAoY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKSxcbiAgICAgICAgICBkaWZmID0gMSAvIChwYXJ0cy5sZW5ndGggLSAxKTt2YXIgZ3JhZCA9IFJHLlNWRy5jcmVhdGUoeyB0eXBlOiAncmFkaWFsR3JhZGllbnQnLCBwYXJlbnQ6IG9iai5zdmcuZGVmcywgYXR0cjogeyBpZDogJ1JHcmFwaC1yYWRpYWwtZ3JhZGllbnQnICsgb2JqLmdyYWRpZW50Q291bnRlciwgZ3JhZGllbnRVbml0czogb3B0LmdyYWRpZW50VW5pdHMgfHwgJ3VzZXJTcGFjZU9uVXNlJywgY3g6IG9wdC5jeCB8fCBvYmouY2VudGVyeCwgY3k6IG9wdC5jeSB8fCBvYmouY2VudGVyeSwgZng6IG9wdC5meCB8fCBvYmouY2VudGVyeCwgZnk6IG9wdC5meSB8fCBvYmouY2VudGVyeSwgcjogb3B0LnIgfHwgb2JqLnJhZGl1cyB9IH0pO3ZhciBzdG9wID0gUkcuU1ZHLmNyZWF0ZSh7IHR5cGU6ICdzdG9wJywgcGFyZW50OiBncmFkLCBhdHRyOiB7IG9mZnNldDogJzAlJywgJ3N0b3AtY29sb3InOiBSRy5TVkcudHJpbShwYXJ0c1swXSkgfSB9KTtmb3IgKHZhciBqID0gMSwgbGVuID0gcGFydHMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHR5cGU6ICdzdG9wJywgcGFyZW50OiBncmFkLCBhdHRyOiB7IG9mZnNldDogaiAqIGRpZmYgKiAxMDAgKyAnJScsICdzdG9wLWNvbG9yJzogUkcuU1ZHLnRyaW0ocGFydHNbal0pIH0gfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbG9yID0gZ3JhZCA/ICd1cmwoI1JHcmFwaC1yYWRpYWwtZ3JhZGllbnQnICsgb2JqLmdyYWRpZW50Q291bnRlcisrICsgJyknIDogY29sb3I7cmV0dXJuIGNvbG9yO1xuICB9O1JHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG9iaiA9IG9wdC5vYmplY3Q7aWYgKG9iai5vcmlnaW5hbENvbG9ycykge1xuICAgICAgZm9yICh2YXIgaiBpbiBvYmoub3JpZ2luYWxDb2xvcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG9iai5wcm9wZXJ0aWVzW2pdID0gUkcuU1ZHLmFycmF5Q2xvbmUob2JqLm9yaWdpbmFsQ29sb3JzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9iai5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoKTtcbiAgICB9XG4gICAgb2JqLm9yaWdpbmFsQ29sb3JzID0ge307b2JqLmNvbG9yc1BhcnNlZCA9IGZhbHNlO29iai5ncmFkaWVudENvdW50ZXIgPSAxO1xuICB9O1JHLlNWRy5jbGVhciA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICB3aGlsZSAoc3ZnLmFsbC5sYXN0Q2hpbGQpIHtcbiAgICAgIHN2Zy5hbGwucmVtb3ZlQ2hpbGQoc3ZnLmFsbC5sYXN0Q2hpbGQpO1xuICAgIH1cbiAgfTtSRy5TVkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZW9mIFJHLlNWRy5ldmVudHNbb2JqLnVpZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBSRy5TVkcuZXZlbnRzW29iai51aWRdID0gW107XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgbmFtZSA9ICdvbicgKyBuYW1lO1xuICAgIH1cbiAgICBSRy5TVkcuZXZlbnRzW29iai51aWRdLnB1c2goeyBvYmplY3Q6IG9iaiwgZXZlbnQ6IG5hbWUsIGZ1bmM6IGZ1bmMgfSk7cmV0dXJuIFJHLlNWRy5ldmVudHNbb2JqLnVpZF0ubGVuZ3RoIC0gMTtcbiAgfTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuICAgIGlmIChvYmogJiYgb2JqLmlzUkdyYXBoKSB7XG4gICAgICB2YXIgdWlkID0gb2JqLnVpZDtpZiAodHlwZW9mIHVpZCA9PT0gJ3N0cmluZycgJiYgX3R5cGVvZihSRy5TVkcuZXZlbnRzKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihSRy5TVkcuZXZlbnRzW3VpZF0pID09PSAnb2JqZWN0JyAmJiBSRy5TVkcuZXZlbnRzW3VpZF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gUkcuU1ZHLmV2ZW50c1t1aWRdLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgaWYgKFJHLlNWRy5ldmVudHNbdWlkXVtqXSAmJiBSRy5TVkcuZXZlbnRzW3VpZF1bal0uZXZlbnQgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIFJHLlNWRy5ldmVudHNbdWlkXVtqXS5mdW5jKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1JHLlNWRy5yZW1vdmVBbGxDdXN0b21FdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdWlkID0gYXJndW1lbnRzWzBdO2lmICh1aWQgJiYgUkcuU1ZHLmV2ZW50c1t1aWRdKSB7XG4gICAgICBSRy5TVkcuZXZlbnRzW3VpZF0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuU1ZHLmV2ZW50cyA9IFtdO1xuICAgIH1cbiAgfTtSRy5TVkcucmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChvYmosIGkpIHtcbiAgICBpZiAoX3R5cGVvZihSRy5TVkcuZXZlbnRzKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihSRy5TVkcuZXZlbnRzW29iai51aWRdKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihSRy5TVkcuZXZlbnRzW29iai51aWRdW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLlNWRy5ldmVudHNbb2JqLnVpZF1baV0gPSBudWxsO1xuICAgIH1cbiAgfTtSRy5TVkcucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYgKGhpZ2hsaWdodCAmJiBSRy5TVkcuaXNBcnJheShoaWdobGlnaHQpICYmIGhpZ2hsaWdodC5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoaWdobGlnaHQubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodFtpXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaGlnaGxpZ2h0W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGlnaGxpZ2h0ICYmIGhpZ2hsaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAob2JqLnR5cGUgPT09ICdzY2F0dGVyJykge1xuICAgICAgICBoaWdobGlnaHQuc2V0QXR0cmlidXRlKCdmaWxsJywgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtSRy5TVkcucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc3ZnID0gYXJndW1lbnRzWzBdO1JHLlNWRy5jbGVhcihzdmcpO3ZhciBvYmplY3RzID0gUkcuU1ZHLk9SLmdldCgnaWQ6JyArIHN2Zy5wYXJlbnROb2RlLmlkKTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHsgb2JqZWN0OiBvYmplY3RzW2ldIH0pO29iamVjdHNbaV0uZHJhdygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFncyA9IFJHLlNWRy5PUi50YWdzKCk7Zm9yICh2YXIgaSBpbiB0YWdzKSB7XG4gICAgICAgIFJHLlNWRy5yZWRyYXcodGFnc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1JHLlNWRy5wYXJzZURhdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGQgPSBuZXcgRGF0ZSgpO3ZhciBkZWZhdWx0cyA9IHsgc2Vjb25kczogJzAwJywgbWludXRlczogJzAwJywgaG91cnM6ICcwMCcsIGRhdGU6IGQuZ2V0RGF0ZSgpLCBtb250aDogZC5nZXRNb250aCgpICsgMSwgeWVhcjogZC5nZXRGdWxsWWVhcigpIH07dmFyIG1vbnRocyA9IFsnamFudWFyeScsICdmZWJydWFyeScsICdtYXJjaCcsICdhcHJpbCcsICdtYXknLCAnanVuZScsICdqdWx5JywgJ2F1Z3VzdCcsICdzZXB0ZW1iZXInLCAnb2N0b2JlcicsICdub3ZlbWJlcicsICdkZWNlbWJlciddLFxuICAgICAgICBtb250aHNfcmVnZXggPSBtb250aHMuam9pbignfCcpO2ZvciAodmFyIGkgPSAwOyBpIDwgbW9udGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICBtb250aHNbbW9udGhzW2ldXSA9IGk7bW9udGhzW21vbnRoc1tpXS5zdWJzdHJpbmcoMCwgMyldID0gaTttb250aHNfcmVnZXggPSBtb250aHNfcmVnZXggKyAnfCcgKyBtb250aHNbaV0uc3Vic3RyaW5nKDAsIDMpO1xuICAgIH1cbiAgICB2YXIgc2VwID0gJ1stLi9fPSt+Izo7LF0rJzt2YXIgdG9rZW5zID0gc3RyLnNwbGl0KC8gKy8pO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICh0b2tlbnNbaV0pIHtcbiAgICAgICAgaWYgKHRva2Vuc1tpXS5tYXRjaCgvXlxcZFxcZFxcZFxcZCQvKSkge1xuICAgICAgICAgIGRlZmF1bHRzLnllYXIgPSB0b2tlbnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGlzTW9udGgodG9rZW5zW2ldKTtpZiAodHlwZW9mIHJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBkZWZhdWx0cy5tb250aCA9IHJlcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1tpXS5tYXRjaCgvXlxcZD9cXGQoPzpzdHxuZHxyZHx0aCk/JC8pKSB7XG4gICAgICAgICAgZGVmYXVsdHMuZGF0ZSA9IHBhcnNlSW50KHRva2Vuc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1tpXS5tYXRjaCgvXihcXGRcXGQpOihcXGRcXGQpKD86KFxcZFxcZCkpPyQvKSkge1xuICAgICAgICAgIGRlZmF1bHRzLmhvdXJzID0gcGFyc2VJbnQoUmVnRXhwLiQxKTtkZWZhdWx0cy5taW51dGVzID0gcGFyc2VJbnQoUmVnRXhwLiQyKTtpZiAoUmVnRXhwLiQzKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5zZWNvbmRzID0gcGFyc2VJbnQoUmVnRXhwLiQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1tpXS5tYXRjaChuZXcgUmVnRXhwKCdeKFxcXFxkXFxcXGRcXFxcZFxcXFxkKScgKyBzZXAgKyAnKFxcXFxkXFxcXGQpJyArIHNlcCArICcoXFxcXGRcXFxcZCkkJywgJ2knKSkpIHtcbiAgICAgICAgICBkZWZhdWx0cy5kYXRlID0gcGFyc2VJbnQoUmVnRXhwLiQzKTtkZWZhdWx0cy5tb250aCA9IHBhcnNlSW50KFJlZ0V4cC4kMik7ZGVmYXVsdHMueWVhciA9IHBhcnNlSW50KFJlZ0V4cC4kMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1tpXS5tYXRjaChuZXcgUmVnRXhwKCdeKFxcXFxkXFxcXGQpJyArIHNlcCArICcoXFxcXGRcXFxcZCknICsgc2VwICsgJyhcXFxcZFxcXFxkXFxcXGRcXFxcZCkkJywgJ2knKSkpIHtcbiAgICAgICAgICBkZWZhdWx0cy5kYXRlID0gcGFyc2VJbnQoUmVnRXhwLiQxKTtkZWZhdWx0cy5tb250aCA9IHBhcnNlSW50KFJlZ0V4cC4kMik7ZGVmYXVsdHMueWVhciA9IHBhcnNlSW50KFJlZ0V4cC4kMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gJ3sxfS97Mn0vezN9IHs0fTp7NX06ezZ9Jy5mb3JtYXQoZGVmYXVsdHMueWVhciwgU3RyaW5nKGRlZmF1bHRzLm1vbnRoKS5sZW5ndGggPT09IDEgPyAnMCcgKyBkZWZhdWx0cy5tb250aCA6IGRlZmF1bHRzLm1vbnRoLCBTdHJpbmcoZGVmYXVsdHMuZGF0ZSkubGVuZ3RoID09PSAxID8gJzAnICsgZGVmYXVsdHMuZGF0ZSA6IGRlZmF1bHRzLmRhdGUsIFN0cmluZyhkZWZhdWx0cy5ob3VycykubGVuZ3RoID09PSAxID8gJzAnICsgZGVmYXVsdHMuaG91cnMgOiBkZWZhdWx0cy5ob3VycywgU3RyaW5nKGRlZmF1bHRzLm1pbnV0ZXMpLmxlbmd0aCA9PT0gMSA/ICcwJyArIGRlZmF1bHRzLm1pbnV0ZXMgOiBkZWZhdWx0cy5taW51dGVzLCBTdHJpbmcoZGVmYXVsdHMuc2Vjb25kcykubGVuZ3RoID09PSAxID8gJzAnICsgZGVmYXVsdHMuc2Vjb25kcyA6IGRlZmF1bHRzLnNlY29uZHMpO3JldHVybiBEYXRlLnBhcnNlKHN0cik7ZnVuY3Rpb24gaXNNb250aChzdHIpIHtcbiAgICAgIHZhciByZXMgPSBzdHIudG9Mb3dlckNhc2UoKS5tYXRjaChtb250aHNfcmVnZXgpO3JldHVybiByZXMgPyBtb250aHNbcmVzWzBdXSA6IGZhbHNlO1xuICAgIH1cbiAgfTtSRy5TVkcuT1IuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuICAgIFJHLlNWRy5PUi5vYmplY3RzLnB1c2gob2JqKTtyZXR1cm4gb2JqO1xuICB9O1JHLlNWRy5PUi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIGFyZ3VtZW50c1swXS5zdWJzdHIoMCwgMykudG9Mb3dlckNhc2UoKSA9PT0gJ2lkOicpIHtcbiAgICAgIHZhciByZXQgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IFJHLlNWRy5PUi5vYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChSRy5TVkcuT1Iub2JqZWN0c1tpXS5pZCA9PT0gYXJndW1lbnRzWzBdLnN1YnN0cigzKSkge1xuICAgICAgICAgIHJldC5wdXNoKFJHLlNWRy5PUi5vYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIGFyZ3VtZW50c1swXS5zdWJzdHIoMCwgNCkudG9Mb3dlckNhc2UoKSA9PT0gJ3R5cGUnKSB7XG4gICAgICB2YXIgcmV0ID0gW107Zm9yICh2YXIgaSA9IDA7IGkgPCBSRy5TVkcuT1Iub2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoUkcuU1ZHLk9SLm9iamVjdHNbaV0udHlwZSA9PT0gYXJndW1lbnRzWzBdLnN1YnN0cig1KSkge1xuICAgICAgICAgIHJldC5wdXNoKFJHLlNWRy5PUi5vYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIGFyZ3VtZW50c1swXS5zdWJzdHIoMCwgMykudG9Mb3dlckNhc2UoKSA9PT0gJ3VpZCcpIHtcbiAgICAgIHZhciByZXQgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IFJHLlNWRy5PUi5vYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChSRy5TVkcuT1Iub2JqZWN0c1tpXS51aWQgPT09IGFyZ3VtZW50c1swXS5zdWJzdHIoNCkpIHtcbiAgICAgICAgICByZXQucHVzaChSRy5TVkcuT1Iub2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBSRy5TVkcuT1Iub2JqZWN0cztcbiAgfTtSRy5TVkcuT1IudGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGFncyA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgUkcuU1ZHLk9SLm9iamVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghdGFnc1tSRy5TVkcuT1Iub2JqZWN0c1tpXS5zdmcucGFyZW50Tm9kZS5pZF0pIHtcbiAgICAgICAgdGFnc1tSRy5TVkcuT1Iub2JqZWN0c1tpXS5zdmcucGFyZW50Tm9kZS5pZF0gPSBSRy5TVkcuT1Iub2JqZWN0c1tpXS5zdmc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xuICB9O1JHLlNWRy5nZXRTVkdYWSA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBlbCA9IHN2Zy5wYXJlbnROb2RlO2RvIHtcbiAgICAgIHggKz0gZWwub2Zmc2V0TGVmdDt5ICs9IGVsLm9mZnNldFRvcDtpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICd0YWJsZScgJiYgKFJHLlNWRy5JU0NIUk9NRSB8fCBSRy5TVkcuSVNTQUZBUkkpKSB7XG4gICAgICAgIHggKz0gcGFyc2VJbnQoZWwuYm9yZGVyKSB8fCAwO3kgKz0gcGFyc2VJbnQoZWwuYm9yZGVyKSB8fCAwO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgfSB3aGlsZSAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2JvZHknKTt2YXIgcGFkZGluZ0xlZnQgPSBzdmcuc3R5bGUucGFkZGluZ0xlZnQgPyBwYXJzZUludChzdmcuc3R5bGUucGFkZGluZ0xlZnQpIDogMCxcbiAgICAgICAgcGFkZGluZ1RvcCA9IHN2Zy5zdHlsZS5wYWRkaW5nVG9wID8gcGFyc2VJbnQoc3ZnLnN0eWxlLnBhZGRpbmdUb3ApIDogMCxcbiAgICAgICAgYm9yZGVyTGVmdCA9IHN2Zy5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPyBwYXJzZUludChzdmcuc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSA6IDAsXG4gICAgICAgIGJvcmRlclRvcCA9IHN2Zy5zdHlsZS5ib3JkZXJUb3BXaWR0aCA/IHBhcnNlSW50KHN2Zy5zdHlsZS5ib3JkZXJUb3BXaWR0aCkgOiAwO2lmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IDApIHtcbiAgICAgIHggKz0gcGFyc2VJbnQoZG9jdW1lbnQuYm9keS5zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7eSArPSBwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gW3ggKyBwYWRkaW5nTGVmdCArIGJvcmRlckxlZnQsIHkgKyBwYWRkaW5nVG9wICsgYm9yZGVyVG9wXTtcbiAgfTtSRy5TVkcuRlgudXBkYXRlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW4ud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbi5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW4ubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2LjY2Nik7XG4gICAgfTt3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmMpO1xuICB9O1JHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyID0gZnVuY3Rpb24gKGZyYW1lcywgZnJhbWUpIHtcbiAgICB2YXIgbXVsdGlwbGllciA9IG1hLnBvdyhtYS5zaW4oZnJhbWUgLyBmcmFtZXMgKiBSRy5TVkcuVFJJRy5IQUxGUEkpLCAzKTtyZXR1cm4gbXVsdGlwbGllcjtcbiAgfTtSRy5TVkcubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIHRleHQgPSBvcHQudGV4dCB8fCAnJyxcbiAgICAgICAgYm9sZCA9IG9wdC5ib2xkIHx8IGZhbHNlLFxuICAgICAgICBmb250ID0gb3B0LmZvbnQgfHwgJ0FyaWFsJyxcbiAgICAgICAgc2l6ZSA9IG9wdC5zaXplIHx8IDEwLFxuICAgICAgICBzdHIgPSB0ZXh0ICsgJzonICsgYm9sZCArICc6JyArIGZvbnQgKyAnOicgKyBzaXplO2lmICh0eXBlb2YgUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlID0gW107XG4gICAgfVxuICAgIGlmIChfdHlwZW9mKFJHLlNWRy5tZWFzdXJldGV4dF9jYWNoZSkgPT0gJ29iamVjdCcgJiYgUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlW3N0cl0pIHtcbiAgICAgIHJldHVybiBSRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbc3RyXTtcbiAgICB9XG4gICAgaWYgKCFSRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtc3BhbiddKSB7XG4gICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NQQU4nKTtzcGFuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztzcGFuLnN0eWxlLnBhZGRpbmcgPSAwO3NwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO3NwYW4uc3R5bGUudG9wID0gJy0yMDBweCc7c3Bhbi5zdHlsZS5sZWZ0ID0gJy0yMDBweCc7c3Bhbi5zdHlsZS5saW5lSGVpZ2h0ID0gJzFlbSc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcGFuKTtSRy5TVkcubWVhc3VyZXRleHRfY2FjaGVbJ3RleHQtc3BhbiddID0gc3BhbjtcbiAgICB9IGVsc2UgaWYgKFJHLlNWRy5tZWFzdXJldGV4dF9jYWNoZVsndGV4dC1zcGFuJ10pIHtcbiAgICAgIHZhciBzcGFuID0gUkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlWyd0ZXh0LXNwYW4nXTtcbiAgICB9XG4gICAgc3Bhbi5pbm5lckhUTUwgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnPGJyIC8+Jyk7c3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gZm9udDtzcGFuLnN0eWxlLmZvbnRXZWlnaHQgPSBib2xkID8gJ2JvbGQnIDogJ25vcm1hbCc7c3Bhbi5zdHlsZS5mb250U2l6ZSA9IHNpemUgKyAncHQnO3ZhciBzaXplcyA9IFtzcGFuLm9mZnNldFdpZHRoLCBzcGFuLm9mZnNldEhlaWdodF07UkcuU1ZHLm1lYXN1cmV0ZXh0X2NhY2hlW3N0cl0gPSBzaXplcztyZXR1cm4gc2l6ZXM7XG4gIH07UkcuU1ZHLnN0cmluZ3NUb051bWJlcnMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50c1sxXSB8fCAnLCc7aWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZihzZXApICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zcGxpdChzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0cikpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzdHJbaV0gPSBwYXJzZUZsb2F0KHN0cltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07UkcuU1ZHLmdldEFkanVzdGVkTnVtYmVyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciB2YWx1ZSA9IG9wdC52YWx1ZSxcbiAgICAgICAgcHJvcCA9IG9wdC5wcm9wO2lmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbWF0Y2goL14oXFwrfC0pKFswLTkuXSspLykpIHtcbiAgICAgIGlmIChSZWdFeHAuJDEgPT09ICcrJykge1xuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KFJlZ0V4cC4kMik7XG4gICAgICB9IGVsc2UgaWYgKFJlZ0V4cC4kMSA9PT0gJy0nKSB7XG4gICAgICAgIHZhbHVlIC09IHBhcnNlRmxvYXQoUmVnRXhwLiQyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1JHLlNWRy5hdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm47XG4gIH07UkcuU1ZHLnBhcnNlR3JhZGllbnQgPSBmdW5jdGlvbiAoc3RyKSB7fTtSRy5TVkcucmFuZG9tID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBtaW4gPSBvcHQubWluLFxuICAgICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgICBkcCA9IG9wdC5kcCB8fCBvcHQuZGVjaW1hbHMgfHwgMCxcbiAgICAgICAgciA9IG1hLnJhbmRvbSgpO3JldHVybiBOdW1iZXIoKChtYXggLSBtaW4pICogciArIG1pbikudG9GaXhlZChkcCkpO1xuICB9O1JHLlNWRy5hcnJheVJhbmQgPSBSRy5TVkcuYXJyYXlSYW5kb20gPSBSRy5TVkcucmFuZG9tLmFycmF5ID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBudW0gPSBvcHQubnVtLFxuICAgICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgICBkcCA9IG9wdC5kcCB8fCBvcHQuZGVjaW1hbHMgfHwgMDtmb3IgKHZhciBpID0gMCwgYXJyID0gW107IGkgPCBudW07IGkgKz0gMSkge1xuICAgICAgYXJyLnB1c2goUkcuU1ZHLnJhbmRvbSh7IG1pbjogbWluLCBtYXg6IG1heCwgZHA6IGRwIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtSRy5TVkcuY29tbW9uU2V0dGVyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBvYmogPSBvcHQub2JqZWN0LFxuICAgICAgICBuYW1lID0gb3B0Lm5hbWUsXG4gICAgICAgIHZhbHVlID0gb3B0LnZhbHVlO2lmIChuYW1lID09PSAndG9vbHRpcHNFdmVudCcgJiYgdmFsdWUgIT09ICdjbGljaycgJiYgdmFsdWUgIT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICB2YWx1ZSA9ICdjbGljayc7XG4gICAgfVxuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xuICB9O1JHLlNWRy5sb2cgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG51bSA9IG9wdC5udW0sXG4gICAgICAgIGJhc2UgPSBvcHQuYmFzZTtyZXR1cm4gbWEubG9nKG51bSkgLyAoYmFzZSA/IG1hLmxvZyhiYXNlKSA6IDEpO1xuICB9O1JHLlNWRy5kb251dCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgYXJjUGF0aDEgPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMyh7IGN4OiBvcHQuY3gsIGN5OiBvcHQuY3ksIHI6IG9wdC5vdXRlclJhZGl1cywgc3RhcnQ6IDAsIGVuZDogUkcuU1ZHLlRSSUcuVFdPUEksIGFudGljbG9ja3dpc2U6IGZhbHNlLCBsaW5ldG86IGZhbHNlIH0pO3ZhciBhcmNQYXRoMiA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgzKHsgY3g6IG9wdC5jeCwgY3k6IG9wdC5jeSwgcjogb3B0LmlubmVyUmFkaXVzLCBzdGFydDogUkcuU1ZHLlRSSUcuVFdPUEksIGVuZDogMCwgYW50aWNsb2Nrd2lzZTogdHJ1ZSwgbGluZXRvOiBmYWxzZSB9KTt2YXIgcGF0aCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9wdC5zdmcsIHR5cGU6ICdwYXRoJywgYXR0cjogeyBkOiBhcmNQYXRoMSArIGFyY1BhdGgyLCBzdHJva2U6IG9wdC5zdHJva2UsIGZpbGw6IG9wdC5maWxsIH0gfSk7cmV0dXJuIHBhdGg7XG4gIH07aWYgKHR5cGVvZiBSRy5TVkcudG9vbHRpcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLlNWRy50b29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgJGEoJ1RoZSB0b29sdGlwIGxpYnJhcnkgaGFzIG5vdCBiZWVuIGluY2x1ZGVkIScpO1xuICAgIH07XG4gIH1cbn0pKHdpbmRvdywgZG9jdW1lbnQpO3dpbmRvdy4kcCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGluZGVudCA9IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6ICcgICAgJzt2YXIgc3RyID0gJyc7dmFyIGNvdW50ZXIgPSB0eXBlb2YgYXJndW1lbnRzWzNdID09ICdudW1iZXInID8gYXJndW1lbnRzWzNdIDogMDtpZiAoY291bnRlciA+PSA1KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkge2Nhc2UgJ3N0cmluZyc6XG4gICAgICBzdHIgKz0gb2JqICsgJyAoJyArICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSArICcsICcgKyBvYmoubGVuZ3RoICsgJyknO2JyZWFrO2Nhc2UgJ251bWJlcic6XG4gICAgICBzdHIgKz0gb2JqICsgJyAoJyArICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSArICcpJzticmVhaztjYXNlICdib29sZWFuJzpcbiAgICAgIHN0ciArPSBvYmogKyAnICgnICsgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpICsgJyknO2JyZWFrO2Nhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHN0ciArPSAnZnVuY3Rpb24gKCkge30nO2JyZWFrO2Nhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBzdHIgKz0gJ3VuZGVmaW5lZCc7YnJlYWs7Y2FzZSAnbnVsbCc6XG4gICAgICBzdHIgKz0gJ251bGwnO2JyZWFrO2Nhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoUkdyYXBoLlNWRy5pc051bGwob2JqKSkge1xuICAgICAgICBzdHIgKz0gaW5kZW50ICsgJ251bGxcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGluZGVudCArICdPYmplY3QgeycgKyAnXFxuJztcbiAgICAgICAgZm9yIChqIGluIG9iaikge1xuICAgICAgICAgIHN0ciArPSBpbmRlbnQgKyAnICAgICcgKyBqICsgJyA9PiAnICsgd2luZG93LiRwKG9ialtqXSwgdHJ1ZSwgaW5kZW50ICsgJyAgICAnLCBjb3VudGVyICsgMSkgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gaW5kZW50ICsgJ30nO1xuICAgICAgfVxuICAgICAgYnJlYWs7ZGVmYXVsdDpcbiAgICAgIHN0ciArPSAnVW5rbm93biB0eXBlOiAnICsgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpICsgJyc7YnJlYWs7fVxuICBpZiAoIWFyZ3VtZW50c1sxXSkge1xuICAgIGFsZXJ0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07d2luZG93LiRhID0gZnVuY3Rpb24gKHYpIHtcbiAgYWxlcnQodik7XG59O3dpbmRvdy4kY2wgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gY29uc29sZS5sb2codik7XG59O2lmICghU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7cmV0dXJuIHRoaXMucmVwbGFjZSgveyhcXGQrKX0vZywgZnVuY3Rpb24gKHN0ciwgaWR4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZ3NbaWR4IC0gMV0gIT09ICd1bmRlZmluZWQnID8gYXJnc1tpZHggLSAxXSA6IHN0cjtcbiAgICB9KTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///206\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.CSV = function (url, func) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;this.url = url;this.ready = func;this.data = null;this.numrows = null;this.numcols = null;this.seperator = arguments[2] || ',';this.endofline = arguments[3] || /\\r?\\n/;this.splitCSV = function (str, split) {\n    var arr = [];var field = '';var inDoubleQuotes = false;var inSingleQuotes = false;var preserve = (typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object' && split.preserve ? true : false;if ((typeof split === 'undefined' ? 'undefined' : _typeof(split)) === 'object') {\n      if (typeof split.char === 'string') {\n        split = split.char;\n      } else {\n        split = ',';\n      }\n    }\n    for (var i = 0, len = str.length; i < len; i += 1) {\n      char = str.charAt(i);if (char === '\"' && !inDoubleQuotes) {\n        inDoubleQuotes = true;continue;\n      } else if (char === '\"' && inDoubleQuotes) {\n        inDoubleQuotes = false;continue;\n      }\n      if (char === \"'\" && !inSingleQuotes) {\n        inSingleQuotes = true;continue;\n      } else if (char === \"'\" && inSingleQuotes) {\n        inSingleQuotes = false;continue;\n      } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {\n        arr.push(field);field = '';continue;\n      } else {\n        field = field + char;\n      }\n    }\n    arr.push(field);if (!preserve) {\n      for (i = 0, len = arr.length; i < len; i += 1) {\n        arr[i] = arr[i].trim();\n      }\n    }\n    return arr;\n  };this.fetch = function () {\n    var sep = this.seperator,\n        eol = this.endofline,\n        obj = this;if (this.url.substring(0, 3) === 'id:' || this.url.substring(0, 4) === 'str:') {\n      if (this.url.substring(0, 3) === 'id:') {\n        var data = document.getElementById(this.url.substring(3)).innerHTML.trim();\n      } else if (this.url.substring(0, 4) === 'str:') {\n        var data = this.url.substring(4).trim();\n      }\n      obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n        var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n          obj.numcols = row.length;\n        }\n        for (var j = 0; j < row.length; j += 1) {\n          if (/^\\-?[0-9.]+$/.test(row[j])) {\n            row[j] = parseFloat(row[j]);\n          }\n          obj.data[i] = row;\n        }\n      }\n      obj.ready(obj);\n    } else {\n      RGraph.SVG.AJAX.getString(this.url, function (data) {\n        data = data.replace(/(\\r?\\n)+$/, '');obj.data = data.split(eol);obj.numrows = obj.data.length;for (var i = 0, len = obj.data.length; i < len; i += 1) {\n          var row = obj.splitCSV(obj.data[i], { preserve: false, char: sep });if (!obj.numcols) {\n            obj.numcols = row.length;\n          }\n          for (var j = 0; j < row.length; j += 1) {\n            if (/^\\-?[0-9.]+$/.test(row[j])) {\n              row[j] = parseFloat(row[j]);\n            }\n            obj.data[i] = row;\n          }\n        }\n        obj.ready(obj);\n      });\n    }\n  };this.getRow = function (index) {\n    var row = [];var start = arguments[1] || 0;for (var i = start; i < this.numcols; i += 1) {\n      row.push(this.data[index][i]);\n    }\n    return row;\n  };this.getCol = this.getColumn = function (index) {\n    var col = [];var start = arguments[1] || 0;for (var i = start; i < this.numrows; i += 1) {\n      col.push(this.data[i][index]);\n    }\n    return col;\n  };this.fetch();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmNzdi5qcz8xZjcwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLkNTViA9IGZ1bmN0aW9uICh1cmwsIGZ1bmMpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoO3RoaXMudXJsID0gdXJsO3RoaXMucmVhZHkgPSBmdW5jO3RoaXMuZGF0YSA9IG51bGw7dGhpcy5udW1yb3dzID0gbnVsbDt0aGlzLm51bWNvbHMgPSBudWxsO3RoaXMuc2VwZXJhdG9yID0gYXJndW1lbnRzWzJdIHx8ICcsJzt0aGlzLmVuZG9mbGluZSA9IGFyZ3VtZW50c1szXSB8fCAvXFxyP1xcbi87dGhpcy5zcGxpdENTViA9IGZ1bmN0aW9uIChzdHIsIHNwbGl0KSB7XG4gICAgdmFyIGFyciA9IFtdO3ZhciBmaWVsZCA9ICcnO3ZhciBpbkRvdWJsZVF1b3RlcyA9IGZhbHNlO3ZhciBpblNpbmdsZVF1b3RlcyA9IGZhbHNlO3ZhciBwcmVzZXJ2ZSA9ICh0eXBlb2Ygc3BsaXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHNwbGl0KSkgPT09ICdvYmplY3QnICYmIHNwbGl0LnByZXNlcnZlID8gdHJ1ZSA6IGZhbHNlO2lmICgodHlwZW9mIHNwbGl0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzcGxpdCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBzcGxpdC5jaGFyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzcGxpdCA9IHNwbGl0LmNoYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpdCA9ICcsJztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY2hhciA9IHN0ci5jaGFyQXQoaSk7aWYgKGNoYXIgPT09ICdcIicgJiYgIWluRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIGluRG91YmxlUXVvdGVzID0gdHJ1ZTtjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1wiJyAmJiBpbkRvdWJsZVF1b3Rlcykge1xuICAgICAgICBpbkRvdWJsZVF1b3RlcyA9IGZhbHNlO2NvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09IFwiJ1wiICYmICFpblNpbmdsZVF1b3Rlcykge1xuICAgICAgICBpblNpbmdsZVF1b3RlcyA9IHRydWU7Y29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJ1wiICYmIGluU2luZ2xlUXVvdGVzKSB7XG4gICAgICAgIGluU2luZ2xlUXVvdGVzID0gZmFsc2U7Y29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IHNwbGl0ICYmICFpbkRvdWJsZVF1b3RlcyAmJiAhaW5TaW5nbGVRdW90ZXMpIHtcbiAgICAgICAgYXJyLnB1c2goZmllbGQpO2ZpZWxkID0gJyc7Y29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZCA9IGZpZWxkICsgY2hhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJyLnB1c2goZmllbGQpO2lmICghcHJlc2VydmUpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaV0udHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O3RoaXMuZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlcCA9IHRoaXMuc2VwZXJhdG9yLFxuICAgICAgICBlb2wgPSB0aGlzLmVuZG9mbGluZSxcbiAgICAgICAgb2JqID0gdGhpcztpZiAodGhpcy51cmwuc3Vic3RyaW5nKDAsIDMpID09PSAnaWQ6JyB8fCB0aGlzLnVybC5zdWJzdHJpbmcoMCwgNCkgPT09ICdzdHI6Jykge1xuICAgICAgaWYgKHRoaXMudXJsLnN1YnN0cmluZygwLCAzKSA9PT0gJ2lkOicpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnVybC5zdWJzdHJpbmcoMykpLmlubmVySFRNTC50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudXJsLnN1YnN0cmluZygwLCA0KSA9PT0gJ3N0cjonKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy51cmwuc3Vic3RyaW5nKDQpLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIG9iai5kYXRhID0gZGF0YS5zcGxpdChlb2wpO29iai5udW1yb3dzID0gb2JqLmRhdGEubGVuZ3RoO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmouZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgcm93ID0gb2JqLnNwbGl0Q1NWKG9iai5kYXRhW2ldLCB7IHByZXNlcnZlOiBmYWxzZSwgY2hhcjogc2VwIH0pO2lmICghb2JqLm51bWNvbHMpIHtcbiAgICAgICAgICBvYmoubnVtY29scyA9IHJvdy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAoL15cXC0/WzAtOS5dKyQvLnRlc3Qocm93W2pdKSkge1xuICAgICAgICAgICAgcm93W2pdID0gcGFyc2VGbG9hdChyb3dbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouZGF0YVtpXSA9IHJvdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqLnJlYWR5KG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJHcmFwaC5TVkcuQUpBWC5nZXRTdHJpbmcodGhpcy51cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO29iai5kYXRhID0gZGF0YS5zcGxpdChlb2wpO29iai5udW1yb3dzID0gb2JqLmRhdGEubGVuZ3RoO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmouZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHZhciByb3cgPSBvYmouc3BsaXRDU1Yob2JqLmRhdGFbaV0sIHsgcHJlc2VydmU6IGZhbHNlLCBjaGFyOiBzZXAgfSk7aWYgKCFvYmoubnVtY29scykge1xuICAgICAgICAgICAgb2JqLm51bWNvbHMgPSByb3cubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgaWYgKC9eXFwtP1swLTkuXSskLy50ZXN0KHJvd1tqXSkpIHtcbiAgICAgICAgICAgICAgcm93W2pdID0gcGFyc2VGbG9hdChyb3dbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmRhdGFbaV0gPSByb3c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iai5yZWFkeShvYmopO1xuICAgICAgfSk7XG4gICAgfVxuICB9O3RoaXMuZ2V0Um93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHJvdyA9IFtdO3ZhciBzdGFydCA9IGFyZ3VtZW50c1sxXSB8fCAwO2ZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRoaXMubnVtY29sczsgaSArPSAxKSB7XG4gICAgICByb3cucHVzaCh0aGlzLmRhdGFbaW5kZXhdW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbiAgfTt0aGlzLmdldENvbCA9IHRoaXMuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGNvbCA9IFtdO3ZhciBzdGFydCA9IGFyZ3VtZW50c1sxXSB8fCAwO2ZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRoaXMubnVtcm93czsgaSArPSAxKSB7XG4gICAgICBjb2wucHVzaCh0aGlzLmRhdGFbaV1baW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbDtcbiAgfTt0aGlzLmZldGNoKCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmNzdi5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///207\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};RGraph.SVG.FX = RGraph.SVG.FX || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.FX.decorate = function (obj) {\n    for (i in RG.SVG.FX) {\n      if (typeof RG.SVG.FX[i] === 'function') {\n        obj[i] = RG.SVG.FX[i];\n      }\n    }\n  };RG.SVG.FX.fadein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};obj.svg.style.opacity = 0;RG.SVG.redraw(this.svg);for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {};for (var i = 1; i <= frames; ++i) {\n      (function (index) {\n        setTimeout(function () {\n          obj.svg.style.opacity = 1 - index / frames;if (index >= frames) {\n            callback(obj);\n          }\n        }, index / frames * duration);\n      })(i);\n    }\n    return this;\n  };RG.SVG.FX.fadeslidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(this.container));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadeslideout = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        pc = -20,\n        step = (120 - pc) / frames,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (pc < 120) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)' });pc += step;RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularinoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 1,\n        radius = 0,\n        svgXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadecircularinoutwards_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, ' + color + ' ' + radius + '%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + frame++ / frames * 100 + '%, ' + color + ' ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutoutwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        width = this.container.offsetWidth,\n        height = this.container.offsetHeight,\n        canvasXY = RG.SVG.getSVGXY(obj.svg),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, transparent 0%)', width: width + 'px', height: height + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + frame++ / frames * 100 + '%, rgba(255,255,255,0) ' + frame++ / frames * 150 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularininwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(obj.container.offsetWidth, obj.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};RG.SVG.redraw(this.svg);$('<div id=\"rgraph_fadeslide_cover_' + obj.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(' + color + ' ' + (frames - frame++) / frames * 100 + '%, rgba(255,255,255,0) ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        $('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.fadecircularoutinwards = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        frame = 0,\n        radius = ma.max(this.container.offsetWidth, this.container.offsetHeight),\n        color = opt.color || 'white',\n        callback = opt.callback || function () {};$('<div id=\"rgraph_fadeslide_cover_' + this.id + '\"></div>').css({ background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)', width: this.container.offsetWidth + 'px', height: this.container.offsetHeight + 'px', top: 0, left: 0, position: 'absolute' }).appendTo($(obj.svg.parentNode));function iterator() {\n      if (frame < frames) {\n        $('div#rgraph_fadeslide_cover_' + obj.id).css({ background: 'radial-gradient(rgba(255,255,255,0) ' + (frames - frame++) / frames * 100 + '%, ' + color + ' ' + (frames - frame++) / frames * 120 + '%)' });RG.SVG.FX.update(iterator);\n      } else {\n        RG.SVG.clear(obj.svg);$('div#rgraph_fadeslide_cover_' + obj.id).remove();callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.SVG.FX.reveal = function () {\n    var obj = this,\n        opt = arguments[0] || {};\n    color = opt.color || 'white', frames = opt.frames || 90, duration = frames / 60 * 1000, callback = opt.callback || function () {};\n    var divs = [['rgraph_reveal_left_' + this.id, 0, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_right_' + this.id, this.container.offsetWidth / 2, 0, this.container.offsetWidth / 2, this.container.offsetHeight], ['rgraph_reveal_top_' + this.id, 0, 0, this.container.offsetWidth, this.container.offsetHeight / 2], ['rgraph_reveal_bottom_' + this.id, 0, this.container.offsetHeight / 2, this.container.offsetWidth, this.container.offsetHeight / 2]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    RG.SVG.redraw(obj.svg);jQuery('#rgraph_reveal_left_' + obj.id).animate({ width: 0 }, duration);jQuery('#rgraph_reveal_right_' + obj.id).animate({ left: '+=' + this.container.offsetWidth / 2, width: 0 }, duration);jQuery('#rgraph_reveal_top_' + obj.id).animate({ height: 0 }, duration);jQuery('#rgraph_reveal_bottom_' + obj.id).animate({ top: '+=' + this.container.offsetHeight / 2, height: 0 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_reveal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_reveal_right_\" + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.conceal = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        duration = frames / 60 * 1000,\n        frame = 0;var divs = [['rgraph_conceal_left_' + obj.id, 0, 0, 0, this.container.offsetHeight], ['rgraph_conceal_right_' + obj.id, this.container.offsetWidth, 0, 0, this.container.offsetHeight], ['rgraph_conceal_top_' + obj.id, 0, 0, this.container.offsetWidth, 0], ['rgraph_conceal_bottom_' + obj.id, 0, this.container.offsetHeight, this.container.offsetWidth, 0]];for (var i = 0, len = divs.length; i < len; ++i) {\n      var div = doc.createElement('DIV');div.id = divs[i][0];div.style.left = divs[i][1] + 'px';div.style.top = divs[i][2] + 'px';div.style.width = divs[i][3] + 'px';div.style.height = divs[i][4] + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n    }\n    jQuery('#rgraph_conceal_left_' + obj.id).animate({ width: '+=' + this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_right_' + obj.id).animate({ left: '-=' + this.container.offsetWidth / 2, width: this.container.offsetWidth / 2 }, duration);jQuery('#rgraph_conceal_top_' + obj.id).animate({ height: '+=' + this.container.offsetHeight / 2 }, duration);jQuery('#rgraph_conceal_bottom_' + obj.id).animate({ top: '-=' + this.container.offsetHeight / 2, height: this.container.offsetHeight / 2 }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById(\"rgraph_conceal_top_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_bottom_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_left_\" + obj.id));obj.container.removeChild(doc.getElementById(\"rgraph_conceal_right_\" + obj.id));RG.SVG.clear(obj.svg);callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration);setTimeout(function () {\n      callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color = 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hblinds_' + i + '_' + obj.id;div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.width = this.container.offsetWidth + 'px';div.style.height = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({ height: height + 'px' }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);\n  };RG.SVG.FX.vblindsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(obj.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;obj.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: 0 }, duration);\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.vblindsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_vblinds_' + i + '_' + obj.id;div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.width = 0;div.style.height = this.container.offsetHeight + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({ width: width }, duration);\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));\n    }, duration + 100);setTimeout(function () {\n      callback(obj);\n    }, duration + 100);return this;\n  };RG.SVG.FX.slidein = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10,\n        from = opt.from || 'left';this.container.style.overflow = 'hidden';RG.SVG.redraw(this.svg);this.svg.style.position = 'relative';if (from == 'left') {\n      this.svg.style.left = 0 - this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    } else if (from == 'top') {\n      this.svg.style.left = 0;this.svg.style.top = 0 - this.container.offsetHeight + 'px';\n    } else if (from == 'bottom') {\n      this.svg.style.left = 0;this.svg.style.top = this.container.offsetHeight + 'px';\n    } else {\n      this.svg.style.left = this.container.offsetWidth + 'px';this.svg.style.top = 0;\n    }\n    jQuery(this.svg).animate({ left: 0, top: 0 }, duration, function () {\n      callback(obj);\n    });return this;\n  };RG.SVG.FX.slideout = function () {\n    var opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        width = this.container.offetsWidth / 10;this.container.style.overflow = 'hidden';this.svg.style.position = 'relative';this.svg.style.left = 0;this.svg.style.top = 0;if (to == 'left') {\n      jQuery(this.svg).animate({ left: 0 - this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'top') {\n      jQuery(this.svg).animate({ left: 0, top: 0 - this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else if (to == 'bottom') {\n      jQuery(this.svg).animate({ top: 0 + this.container.offsetHeight + 'px' }, duration, function () {\n        callback(this);\n      });\n    } else {\n      jQuery(this.svg).animate({ left: 0 + this.container.offsetWidth + 'px' }, duration, function () {\n        callback(this);\n      });\n    }\n    return this;\n  };RG.SVG.FX.hscissorsopen = function () {\n    var opt = arguments[0] || {},\n        obj = this,\n        frames = opt.frames || 90,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        to = opt.to || 'left',\n        frame = 0,\n        duration = frames / 60 * 1000,\n        width = this.container.offsetWidth / 10,\n        height = this.container.offsetHeight / 5;RG.SVG.redraw(this.svg);for (var i = 0; i < 5; ++i) {\n      var div = doc.getElementById(\"rgraph_hscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = this.container.offsetWidth + 'px';div.style.height = this.container.offsetHeight / 5 + 'px';div.style.left = 0;div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: this.container.offsetWidth + 'px', width: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.hscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 60,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        height = this.container.offsetHeight / 5;for (var i = 0; i < 5; ++i) {\n      var div = doc.createElement('DIV');div.id = 'rgraph_hscissors_' + i + '_' + this.id;div.style.width = 0;div.style.height = height + 'px';div.style.left = (i % 2 == 0 ? this.container.offsetWidth : 0) + 'px';div.style.top = this.container.offsetHeight * (i / 5) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ left: 0, width: this.container.offsetWidth + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({ width: this.container.offsetWidth + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsopen = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;RG.SVG.redraw(this.svg);for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = this.container.offsetHeight + 'px';div.style.left = this.container.offsetWidth * (i / 10) + 'px';div.style.top = 0;div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: this.container.offsetHeight + 'px', height: 0 }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: 0 }, duration);\n      }\n    }\n    setTimeout(function () {\n      obj.container.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));obj.container.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));callback(obj);\n    }, duration);return this;\n  };RG.SVG.FX.vscissorsclose = function () {\n    var obj = this,\n        opt = arguments[0] || {},\n        frames = opt.frames || 90,\n        duration = frames / 60 * 1000,\n        frame = 0,\n        callback = opt.callback || function () {},\n        color = opt.color || 'white',\n        width = this.container.offsetWidth / 10;for (var i = 0; i < 10; ++i) {\n      var div = doc.getElementById(\"rgraph_vscissors_\" + i + '_' + this.id);\n      if (!div) {\n        var div = doc.createElement('DIV');div.id = 'rgraph_vscissors_' + i + '_' + this.id;div.style.width = width + 'px';div.style.height = 0;div.style.left = width * i + 'px';div.style.top = (i % 2 == 0 ? this.container.offsetHeight : 0) + 'px';div.style.position = 'absolute';div.style.backgroundColor = color;this.container.appendChild(div);\n      }\n      if (i % 2 == 0) {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ top: 0, height: this.container.offsetHeight + 'px' }, duration);\n      } else {\n        jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({ height: this.container.offsetHeight + 'px' }, duration);\n      }\n    }\n    setTimeout(function () {\n      RG.SVG.clear(obj.svg);for (var i = 0; i < 10; i++) {\n        jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();\n      }\n      callback(obj);\n    }, duration);return this;\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmZ4LmpzPzE2MjciXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTtSR3JhcGguU1ZHLkZYID0gUkdyYXBoLlNWRy5GWCB8fCB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoO1JHLlNWRy5GWC5kZWNvcmF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKGkgaW4gUkcuU1ZHLkZYKSB7XG4gICAgICBpZiAodHlwZW9mIFJHLlNWRy5GWFtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbaV0gPSBSRy5TVkcuRlhbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1JHLlNWRy5GWC5mYWRlaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307b2JqLnN2Zy5zdHlsZS5vcGFjaXR5ID0gMDtSRy5TVkcucmVkcmF3KHRoaXMuc3ZnKTtmb3IgKHZhciBpID0gMTsgaSA8PSBmcmFtZXM7ICsraSkge1xuICAgICAgKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYmouc3ZnLnN0eWxlLm9wYWNpdHkgPSBpbmRleCAvIGZyYW1lcztpZiAoaW5kZXggPj0gZnJhbWVzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaW5kZXggLyBmcmFtZXMgKiBkdXJhdGlvbik7XG4gICAgICB9KShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07UkcuU1ZHLkZYLmZhZGVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307Zm9yICh2YXIgaSA9IDE7IGkgPD0gZnJhbWVzOyArK2kpIHtcbiAgICAgIChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JqLnN2Zy5zdHlsZS5vcGFjaXR5ID0gMSAtIGluZGV4IC8gZnJhbWVzO2lmIChpbmRleCA+PSBmcmFtZXMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpbmRleCAvIGZyYW1lcyAqIGR1cmF0aW9uKTtcbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlguZmFkZXNsaWRlaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBwYyA9IC0yMCxcbiAgICAgICAgc3RlcCA9ICgxMjAgLSBwYykgLyBmcmFtZXMsXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZScsXG4gICAgICAgIHdpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7JCgnPGRpdiBpZD1cInJncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCArICdcIj48L2Rpdj4nKS5jc3MoeyBiYWNrZ3JvdW5kOiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgcmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgcGMgKyAnJSwgJyArIGNvbG9yICsgJyAnICsgKHBjICsgMjApICsgJyUpJywgd2lkdGg6IHdpZHRoICsgJ3B4JywgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLCB0b3A6IDAsIGxlZnQ6IDAsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQodGhpcy5jb250YWluZXIpKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGlmIChwYyA8IDEyMCkge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5jc3MoeyBiYWNrZ3JvdW5kOiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgcmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgcGMgKyAnJSwgJyArIGNvbG9yICsgJyAnICsgKHBjICsgMjApICsgJyUpJyB9KTtwYyArPSBzdGVwO1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkucmVtb3ZlKCk7Y2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlguZmFkZXNsaWRlb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgcGMgPSAtMjAsXG4gICAgICAgIHN0ZXAgPSAoMTIwIC0gcGMpIC8gZnJhbWVzLFxuICAgICAgICBjYW52YXNYWSA9IFJHLlNWRy5nZXRTVkdYWShvYmouc3ZnKSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkICsgJ1wiPjwvZGl2PicpLmNzcyh7IGJhY2tncm91bmQ6ICdsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAnICsgY29sb3IgKyAnICcgKyBwYyArICclLCByZ2JhKDI1NSwyNTUsMjU1LDApICcgKyAocGMgKyAyMCkgKyAnJSknLCB3aWR0aDogd2lkdGggKyAncHgnLCBoZWlnaHQ6IGhlaWdodCArICdweCcsIHRvcDogMCwgbGVmdDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScgfSkuYXBwZW5kVG8oJChvYmouc3ZnLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGlmIChwYyA8IDEyMCkge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5jc3MoeyBiYWNrZ3JvdW5kOiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgJyArIGNvbG9yICsgJyAnICsgcGMgKyAnJSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAnICsgKHBjICsgMjApICsgJyUpJyB9KTtwYyArPSBzdGVwO1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcuU1ZHLmNsZWFyKG9iai5zdmcpOyQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuU1ZHLkZYLmZhZGVjaXJjdWxhcmlub3V0d2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZnJhbWUgPSAxLFxuICAgICAgICByYWRpdXMgPSAwLFxuICAgICAgICBzdmdYWSA9IFJHLlNWRy5nZXRTVkdYWShvYmouc3ZnKSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7JCgnPGRpdiBpZD1cInJncmFwaF9mYWRlY2lyY3VsYXJpbm91dHdhcmRzX2NvdmVyXycgKyBvYmouaWQgKyAnXCI+PC9kaXY+JykuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCAnICsgY29sb3IgKyAnICcgKyByYWRpdXMgKyAnJSknLCB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKyAncHgnLCBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCcsIHRvcDogMCwgbGVmdDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScgfSkuYXBwZW5kVG8oJChvYmouc3ZnLnBhcmVudE5vZGUpKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGlmIChmcmFtZSA8IGZyYW1lcykge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVjaXJjdWxhcmlub3V0d2FyZHNfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApICcgKyBmcmFtZSsrIC8gZnJhbWVzICogMTAwICsgJyUsICcgKyBjb2xvciArICcgJyArIGZyYW1lKysgLyBmcmFtZXMgKiAxNTAgKyAnJSknIH0pO1JHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlY2lyY3VsYXJpbm91dHdhcmRzX2NvdmVyXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcuU1ZHLkZYLmZhZGVjaXJjdWxhcm91dG91dHdhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBjYW52YXNYWSA9IFJHLlNWRy5nZXRTVkdYWShvYmouc3ZnKSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307JCgnPGRpdiBpZD1cInJncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCArICdcIj48L2Rpdj4nKS5jc3MoeyBiYWNrZ3JvdW5kOiAncmFkaWFsLWdyYWRpZW50KHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUsIHRyYW5zcGFyZW50IDAlKScsIHdpZHRoOiB3aWR0aCArICdweCcsIGhlaWdodDogaGVpZ2h0ICsgJ3B4JywgdG9wOiAwLCBsZWZ0OiAwLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9KS5hcHBlbmRUbygkKG9iai5zdmcucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgaWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgICQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLmNzcyh7IGJhY2tncm91bmQ6ICdyYWRpYWwtZ3JhZGllbnQoJyArIGNvbG9yICsgJyAnICsgZnJhbWUrKyAvIGZyYW1lcyAqIDEwMCArICclLCByZ2JhKDI1NSwyNTUsMjU1LDApICcgKyBmcmFtZSsrIC8gZnJhbWVzICogMTUwICsgJyUpJyB9KTtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLlNWRy5jbGVhcihvYmouc3ZnKTskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC5mYWRlY2lyY3VsYXJpbmlud2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICByYWRpdXMgPSBtYS5tYXgob2JqLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwgb2JqLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQpLFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtSRy5TVkcucmVkcmF3KHRoaXMuc3ZnKTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkICsgJ1wiPjwvZGl2PicpLmNzcyh7IGJhY2tncm91bmQ6ICdyYWRpYWwtZ3JhZGllbnQocmdiYSgyNTUsMjU1LDI1NSwwKSAxMDAlLCByZ2JhKDI1NSwyNTUsMjU1LDApIDAlKScsIHdpZHRoOiB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCArICdweCcsIGhlaWdodDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JywgdG9wOiAwLCBsZWZ0OiAwLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9KS5hcHBlbmRUbygkKG9iai5zdmcucGFyZW50Tm9kZSkpO2Z1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgaWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgICQoJ2RpdiNyZ3JhcGhfZmFkZXNsaWRlX2NvdmVyXycgKyBvYmouaWQpLmNzcyh7IGJhY2tncm91bmQ6ICdyYWRpYWwtZ3JhZGllbnQoJyArIGNvbG9yICsgJyAnICsgKGZyYW1lcyAtIGZyYW1lKyspIC8gZnJhbWVzICogMTAwICsgJyUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgJyArIChmcmFtZXMgLSBmcmFtZSsrKSAvIGZyYW1lcyAqIDEyMCArICclKScgfSk7UkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC5mYWRlY2lyY3VsYXJvdXRpbndhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgcmFkaXVzID0gbWEubWF4KHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQpLFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTskKCc8ZGl2IGlkPVwicmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgdGhpcy5pZCArICdcIj48L2Rpdj4nKS5jc3MoeyBiYWNrZ3JvdW5kOiAncmFkaWFsLWdyYWRpZW50KHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUsIHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUpJywgd2lkdGg6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4JywgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyAncHgnLCB0b3A6IDAsIGxlZnQ6IDAsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pLmFwcGVuZFRvKCQob2JqLnN2Zy5wYXJlbnROb2RlKSk7ZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAoZnJhbWUgPCBmcmFtZXMpIHtcbiAgICAgICAgJCgnZGl2I3JncmFwaF9mYWRlc2xpZGVfY292ZXJfJyArIG9iai5pZCkuY3NzKHsgYmFja2dyb3VuZDogJ3JhZGlhbC1ncmFkaWVudChyZ2JhKDI1NSwyNTUsMjU1LDApICcgKyAoZnJhbWVzIC0gZnJhbWUrKykgLyBmcmFtZXMgKiAxMDAgKyAnJSwgJyArIGNvbG9yICsgJyAnICsgKGZyYW1lcyAtIGZyYW1lKyspIC8gZnJhbWVzICogMTIwICsgJyUpJyB9KTtSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJHLlNWRy5jbGVhcihvYmouc3ZnKTskKCdkaXYjcmdyYXBoX2ZhZGVzbGlkZV9jb3Zlcl8nICsgb2JqLmlkKS5yZW1vdmUoKTtjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC5yZXZlYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLCBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDkwLCBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMCwgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgdmFyIGRpdnMgPSBbWydyZ3JhcGhfcmV2ZWFsX2xlZnRfJyArIHRoaXMuaWQsIDAsIDAsIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMiwgdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XSwgWydyZ3JhcGhfcmV2ZWFsX3JpZ2h0XycgKyB0aGlzLmlkLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDIsIDAsIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMiwgdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XSwgWydyZ3JhcGhfcmV2ZWFsX3RvcF8nICsgdGhpcy5pZCwgMCwgMCwgdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCAvIDJdLCBbJ3JncmFwaF9yZXZlYWxfYm90dG9tXycgKyB0aGlzLmlkLCAwLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyAyLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0IC8gMl1dO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXZzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9IGRpdnNbaV1bMF07ZGl2LnN0eWxlLmxlZnQgPSBkaXZzW2ldWzFdICsgJ3B4JztkaXYuc3R5bGUudG9wID0gZGl2c1tpXVsyXSArICdweCc7ZGl2LnN0eWxlLndpZHRoID0gZGl2c1tpXVszXSArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IGRpdnNbaV1bNF0gKyAncHgnO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XG4gICAgfVxuICAgIFJHLlNWRy5yZWRyYXcob2JqLnN2Zyk7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9sZWZ0XycgKyBvYmouaWQpLmFuaW1hdGUoeyB3aWR0aDogMCB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX3JldmVhbF9yaWdodF8nICsgb2JqLmlkKS5hbmltYXRlKHsgbGVmdDogJys9JyArIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMiwgd2lkdGg6IDAgfSwgZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9yZXZlYWxfdG9wXycgKyBvYmouaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IDAgfSwgZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9yZXZlYWxfYm90dG9tXycgKyBvYmouaWQpLmFuaW1hdGUoeyB0b3A6ICcrPScgKyB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyAyLCBoZWlnaHQ6IDAgfSwgZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfcmV2ZWFsX3RvcF9cIiArIG9iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3JldmVhbF9ib3R0b21fXCIgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9yZXZlYWxfbGVmdF9cIiArIG9iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3JldmVhbF9yaWdodF9cIiArIG9iai5pZCkpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC5jb25jZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMCxcbiAgICAgICAgZnJhbWUgPSAwO3ZhciBkaXZzID0gW1sncmdyYXBoX2NvbmNlYWxfbGVmdF8nICsgb2JqLmlkLCAwLCAwLCAwLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRdLCBbJ3JncmFwaF9jb25jZWFsX3JpZ2h0XycgKyBvYmouaWQsIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLCAwLCAwLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRdLCBbJ3JncmFwaF9jb25jZWFsX3RvcF8nICsgb2JqLmlkLCAwLCAwLCB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCwgMF0sIFsncmdyYXBoX2NvbmNlYWxfYm90dG9tXycgKyBvYmouaWQsIDAsIHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCwgdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsIDBdXTtmb3IgKHZhciBpID0gMCwgbGVuID0gZGl2cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQgPSBkaXZzW2ldWzBdO2Rpdi5zdHlsZS5sZWZ0ID0gZGl2c1tpXVsxXSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IGRpdnNbaV1bMl0gKyAncHgnO2Rpdi5zdHlsZS53aWR0aCA9IGRpdnNbaV1bM10gKyAncHgnO2Rpdi5zdHlsZS5oZWlnaHQgPSBkaXZzW2ldWzRdICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH1cbiAgICBqUXVlcnkoJyNyZ3JhcGhfY29uY2VhbF9sZWZ0XycgKyBvYmouaWQpLmFuaW1hdGUoeyB3aWR0aDogJys9JyArIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMiB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfcmlnaHRfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGxlZnQ6ICctPScgKyB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDIsIHdpZHRoOiB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDIgfSwgZHVyYXRpb24pO2pRdWVyeSgnI3JncmFwaF9jb25jZWFsX3RvcF8nICsgb2JqLmlkKS5hbmltYXRlKHsgaGVpZ2h0OiAnKz0nICsgdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0IC8gMiB9LCBkdXJhdGlvbik7alF1ZXJ5KCcjcmdyYXBoX2NvbmNlYWxfYm90dG9tXycgKyBvYmouaWQpLmFuaW1hdGUoeyB0b3A6ICctPScgKyB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyAyLCBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCAvIDIgfSwgZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfY29uY2VhbF90b3BfXCIgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZChcInJncmFwaF9jb25jZWFsX2JvdHRvbV9cIiArIG9iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2NvbmNlYWxfbGVmdF9cIiArIG9iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2NvbmNlYWxfcmlnaHRfXCIgKyBvYmouaWQpKTtSRy5TVkcuY2xlYXIob2JqLnN2Zyk7Y2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbik7cmV0dXJuIHRoaXM7XG4gIH07UkcuU1ZHLkZYLmhibGluZHNvcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyA1O1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpO2ZvciAodmFyIGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfaGJsaW5kc18nICsgaSArICdfJyArIG9iai5pZDtkaXYuc3R5bGUubGVmdCA9IDA7ZGl2LnN0eWxlLnRvcCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCAqIChpIC8gNSkgKyAncHgnO2Rpdi5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0IC8gNSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtqUXVlcnkoJyNyZ3JhcGhfaGJsaW5kc18nICsgaSArICdfJyArIG9iai5pZCkuYW5pbWF0ZSh7IGhlaWdodDogMCB9LCBkdXJhdGlvbik7XG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzBfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMl8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24pO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzNfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbik7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhvYmopO1xuICAgIH0sIGR1cmF0aW9uKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlguaGJsaW5kc2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciA9ICd3aGl0ZScsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCAvIDU7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oYmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS5sZWZ0ID0gMDtkaXYuc3R5bGUudG9wID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0ICogKGkgLyA1KSArICdweCc7ZGl2LnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKyAncHgnO2Rpdi5zdHlsZS5oZWlnaHQgPSAwO2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX2hibGluZHNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IGhlaWdodCArICdweCcgfSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLlNWRy5jbGVhcihvYmouc3ZnKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfMF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzFfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfaGJsaW5kc18yXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hibGluZHNfM18nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF9oYmxpbmRzXzRfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO1xuICB9O1JHLlNWRy5GWC52YmxpbmRzb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpcyxcbiAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDkwLFxuICAgICAgICBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDEwO1JHLlNWRy5yZWRyYXcob2JqLnN2Zyk7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfdmJsaW5kc18nICsgaSArICdfJyArIG9iai5pZDtkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAqIChpIC8gMTApICsgJ3B4JztkaXYuc3R5bGUudG9wID0gMDtkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtvYmouY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7alF1ZXJ5KCcjcmdyYXBoX3ZibGluZHNfJyArIGkgKyAnXycgKyBvYmouaWQpLmFuaW1hdGUoeyB3aWR0aDogMCB9LCBkdXJhdGlvbik7XG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzBfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMl8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzNfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNV8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzZfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzlfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC52YmxpbmRzY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZScsXG4gICAgICAgIHdpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggLyAxMDtmb3IgKHZhciBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF92YmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkO2Rpdi5zdHlsZS5sZWZ0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKiAoaSAvIDEwKSArICdweCc7ZGl2LnN0eWxlLnRvcCA9IDA7ZGl2LnN0eWxlLndpZHRoID0gMDtkaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO2pRdWVyeSgnI3JncmFwaF92YmxpbmRzXycgKyBpICsgJ18nICsgb2JqLmlkKS5hbmltYXRlKHsgd2lkdGg6IHdpZHRoIH0sIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5TVkcuY2xlYXIob2JqLnN2Zyk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzBfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc18xXycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfMl8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzNfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc180XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfNV8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzZfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdmJsaW5kc183XycgKyBvYmouaWQpKTtcbiAgICB9LCBkdXJhdGlvbiArIDEwMCk7c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZibGluZHNfOF8nICsgb2JqLmlkKSk7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92YmxpbmRzXzlfJyArIG9iai5pZCkpO1xuICAgIH0sIGR1cmF0aW9uICsgMTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24gKyAxMDApO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC5zbGlkZWluID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICB3aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMTAsXG4gICAgICAgIGZyb20gPSBvcHQuZnJvbSB8fCAnbGVmdCc7dGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztSRy5TVkcucmVkcmF3KHRoaXMuc3ZnKTt0aGlzLnN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7aWYgKGZyb20gPT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gMCAtIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4Jzt0aGlzLnN2Zy5zdHlsZS50b3AgPSAwO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA9PSAndG9wJykge1xuICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9IDA7dGhpcy5zdmcuc3R5bGUudG9wID0gMCAtIHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgfSBlbHNlIGlmIChmcm9tID09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gMDt0aGlzLnN2Zy5zdHlsZS50b3AgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKyAncHgnO3RoaXMuc3ZnLnN0eWxlLnRvcCA9IDA7XG4gICAgfVxuICAgIGpRdWVyeSh0aGlzLnN2ZykuYW5pbWF0ZSh7IGxlZnQ6IDAsIHRvcDogMCB9LCBkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9KTtyZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlguc2xpZGVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgY29sb3IgPSBvcHQuY29sb3IgfHwgJ3doaXRlJyxcbiAgICAgICAgdG8gPSBvcHQudG8gfHwgJ2xlZnQnLFxuICAgICAgICBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMCxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBjYWxsYmFjayA9IG9wdC5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZldHNXaWR0aCAvIDEwO3RoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7dGhpcy5zdmcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO3RoaXMuc3ZnLnN0eWxlLmxlZnQgPSAwO3RoaXMuc3ZnLnN0eWxlLnRvcCA9IDA7aWYgKHRvID09ICdsZWZ0Jykge1xuICAgICAgalF1ZXJ5KHRoaXMuc3ZnKS5hbmltYXRlKHsgbGVmdDogMCAtIHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4JyB9LCBkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodG8gPT0gJ3RvcCcpIHtcbiAgICAgIGpRdWVyeSh0aGlzLnN2ZykuYW5pbWF0ZSh7IGxlZnQ6IDAsIHRvcDogMCAtIHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCcgfSwgZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRvID09ICdib3R0b20nKSB7XG4gICAgICBqUXVlcnkodGhpcy5zdmcpLmFuaW1hdGUoeyB0b3A6IDAgKyB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyAncHgnIH0sIGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpRdWVyeSh0aGlzLnN2ZykuYW5pbWF0ZSh7IGxlZnQ6IDAgKyB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCArICdweCcgfSwgZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07UkcuU1ZHLkZYLmhzY2lzc29yc29wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgb2JqID0gdGhpcyxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZScsXG4gICAgICAgIHRvID0gb3B0LnRvIHx8ICdsZWZ0JyxcbiAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICBkdXJhdGlvbiA9IGZyYW1lcyAvIDYwICogMTAwMCxcbiAgICAgICAgd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDEwLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLyA1O1JHLlNWRy5yZWRyYXcodGhpcy5zdmcpO2ZvciAodmFyIGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX2hzY2lzc29yc19cIiArIGkgKyAnXycgKyB0aGlzLmlkKTtcbiAgICAgIGlmICghZGl2KSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oc2Npc3NvcnNfJyArIGkgKyAnXycgKyB0aGlzLmlkO2Rpdi5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4JztkaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0IC8gNSArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSAwO2Rpdi5zdHlsZS50b3AgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiAoaSAvIDUpICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgfVxuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgalF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyBpICsgJ18nICsgdGhpcy5pZCkuYW5pbWF0ZSh7IGxlZnQ6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoICsgJ3B4Jywgd2lkdGg6IDAgfSwgZHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgalF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyBpICsgJ18nICsgdGhpcy5pZCkuYW5pbWF0ZSh7IHdpZHRoOiAwIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18wXycgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18xXycgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18yXycgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc18zXycgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2hzY2lzc29yc180XycgKyBvYmouaWQpKTtjYWxsYmFjayhvYmopO1xuICAgIH0sIGR1cmF0aW9uKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlguaHNjaXNzb3JzY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA2MCxcbiAgICAgICAgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZScsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCAvIDU7Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnRElWJyk7ZGl2LmlkID0gJ3JncmFwaF9oc2Npc3NvcnNfJyArIGkgKyAnXycgKyB0aGlzLmlkO2Rpdi5zdHlsZS53aWR0aCA9IDA7ZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSAoaSAlIDIgPT0gMCA/IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIDogMCkgKyAncHgnO2Rpdi5zdHlsZS50b3AgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiAoaSAvIDUpICsgJ3B4JztkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO2lmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgaSArICdfJyArIHRoaXMuaWQpLmFuaW1hdGUoeyBsZWZ0OiAwLCB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKyAncHgnIH0sIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgaSArICdfJyArIHRoaXMuaWQpLmFuaW1hdGUoeyB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggKyAncHgnIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5TVkcuY2xlYXIob2JqLnN2Zyk7alF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyAwICsgJ18nICsgb2JqLmlkKS5yZW1vdmUoKTtqUXVlcnkoJyMnICsgJ3JncmFwaF9oc2Npc3NvcnNfJyArIDEgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO2pRdWVyeSgnIycgKyAncmdyYXBoX2hzY2lzc29yc18nICsgMiArICdfJyArIG9iai5pZCkucmVtb3ZlKCk7alF1ZXJ5KCcjJyArICdyZ3JhcGhfaHNjaXNzb3JzXycgKyAzICsgJ18nICsgb2JqLmlkKS5yZW1vdmUoKTtqUXVlcnkoJyMnICsgJ3JncmFwaF9oc2Npc3NvcnNfJyArIDQgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO2NhbGxiYWNrKG9iaik7XG4gICAgfSwgZHVyYXRpb24pO3JldHVybiB0aGlzO1xuICB9O1JHLlNWRy5GWC52c2Npc3NvcnNvcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB0aGlzLFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgOTAsXG4gICAgICAgIGR1cmF0aW9uID0gZnJhbWVzIC8gNjAgKiAxMDAwLFxuICAgICAgICBmcmFtZSA9IDAsXG4gICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb2xvciA9IG9wdC5jb2xvciB8fCAnd2hpdGUnLFxuICAgICAgICB3aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC8gMTA7UkcuU1ZHLnJlZHJhdyh0aGlzLnN2Zyk7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmdldEVsZW1lbnRCeUlkKFwicmdyYXBoX3ZzY2lzc29yc19cIiArIGkgKyAnXycgKyB0aGlzLmlkKTtpZiAoIWRpdikge1xuICAgICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ0RJVicpO2Rpdi5pZCA9ICdyZ3JhcGhfdnNjaXNzb3JzXycgKyBpICsgJ18nICsgdGhpcy5pZDtkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7ZGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCArICdweCc7ZGl2LnN0eWxlLmxlZnQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAqIChpIC8gMTApICsgJ3B4JztkaXYuc3R5bGUudG9wID0gMDtkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO2Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgfVxuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgalF1ZXJ5KCcjJyArICdyZ3JhcGhfdnNjaXNzb3JzXycgKyBpICsgJ18nICsgdGhpcy5pZCkuYW5pbWF0ZSh7IHRvcDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JywgaGVpZ2h0OiAwIH0sIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIHRoaXMuaWQpLmFuaW1hdGUoeyBoZWlnaHQ6IDAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzAnICsgJ18nICsgb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92c2Npc3NvcnNfMScgKyAnXycgKyBvYmouaWQpKTtvYmouY29udGFpbmVyLnJlbW92ZUNoaWxkKGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX3ZzY2lzc29yc18yJyArICdfJyArIG9iai5pZCkpO29iai5jb250YWluZXIucmVtb3ZlQ2hpbGQoZG9jLmdldEVsZW1lbnRCeUlkKCdyZ3JhcGhfdnNjaXNzb3JzXzMnICsgJ18nICsgb2JqLmlkKSk7b2JqLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JncmFwaF92c2Npc3NvcnNfNCcgKyAnXycgKyBvYmouaWQpKTtjYWxsYmFjayhvYmopO1xuICAgIH0sIGR1cmF0aW9uKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5TVkcuRlgudnNjaXNzb3JzY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgZnJhbWVzID0gb3B0LmZyYW1lcyB8fCA5MCxcbiAgICAgICAgZHVyYXRpb24gPSBmcmFtZXMgLyA2MCAqIDEwMDAsXG4gICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGNvbG9yID0gb3B0LmNvbG9yIHx8ICd3aGl0ZScsXG4gICAgICAgIHdpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggLyAxMDtmb3IgKHZhciBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgIHZhciBkaXYgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoXCJyZ3JhcGhfdnNjaXNzb3JzX1wiICsgaSArICdfJyArIHRoaXMuaWQpO1xuICAgICAgaWYgKCFkaXYpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtkaXYuaWQgPSAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIHRoaXMuaWQ7ZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO2Rpdi5zdHlsZS5oZWlnaHQgPSAwO2Rpdi5zdHlsZS5sZWZ0ID0gd2lkdGggKiBpICsgJ3B4JztkaXYuc3R5bGUudG9wID0gKGkgJSAyID09IDAgPyB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgOiAwKSArICdweCc7ZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIH1cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIGpRdWVyeSgnIycgKyAncmdyYXBoX3ZzY2lzc29yc18nICsgaSArICdfJyArIHRoaXMuaWQpLmFuaW1hdGUoeyB0b3A6IDAsIGhlaWdodDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JyB9LCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqUXVlcnkoJyMnICsgJ3JncmFwaF92c2Npc3NvcnNfJyArIGkgKyAnXycgKyB0aGlzLmlkKS5hbmltYXRlKHsgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyAncHgnIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5TVkcuY2xlYXIob2JqLnN2Zyk7Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGpRdWVyeSgnI3JncmFwaF92c2Npc3NvcnNfJyArIGkgKyAnXycgKyBvYmouaWQpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9LCBkdXJhdGlvbik7cmV0dXJuIHRoaXM7XG4gIH07XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmNvbW1vbi5meC5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///208\n")},function(module,exports){eval("// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\nRGraph.SVG.HTML = RGraph.SVG.HTML || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math;\n\n    /**\n    * Draws the graph key (used by various graphs)\n    * \n    * @param object obj The graph object\n    * @param array  key An array of the texts to be listed in the key\n    * @param colors An array of the colors to be used\n    */\n    RG.SVG.drawKey = function (obj) {\n        var prop = obj.properties,\n            key = prop.key,\n            colors = prop.keyColors || prop.colors,\n            defaultFont = 'Arial',\n            blobSize = 0,\n            width = 0;\n\n        // Work out the center point of the SVG tag\n        var centerx = obj.svg.getAttribute('width') / 2;\n\n        // First measure the length so that the key can be centered\n        for (var i = 0, length = 0; i < key.length; i++) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            blobSize = ma.max(blobSize, textDimensions[1]);\n\n            width = width + 10 + blobSize + 5 + textDimensions[0];\n        }\n\n        // Center the key\n        x = centerx - width / 2;\n\n        // Loop thru the key and draw them\n        for (var i = 0, y = prop.gutterTop - 5; i < key.length; ++i) {\n\n            // First measure the text\n            var textDimensions = RG.SVG.measureText({\n                text: key[i],\n                bold: prop.keyTextBold || false,\n                font: prop.keyTextFont || prop.textFont || defaultFont,\n                size: prop.keyTextSize || prop.textSize\n            });\n\n            RG.SVG.create({\n                svg: obj.svg,\n                type: 'rect',\n                parent: obj.svg.all,\n                attr: {\n                    x: x + prop.keyOffsetx,\n                    y: y - blobSize + prop.keyOffsety,\n                    width: blobSize,\n                    height: blobSize,\n                    fill: colors[i]\n                }\n            });\n\n            RGraph.SVG.text({\n                object: obj,\n                parent: obj.svg.all,\n                size: prop.keyTextSize || prop.textSize,\n                bold: prop.keyTextBold || false,\n                font: 'Arial',\n                italic: prop.keyTextItalic || false,\n                halign: 'left',\n                valign: 'bottom',\n                text: key[i],\n                x: x + blobSize + 5 + prop.keyTextOffsetx + prop.keyOffsetx,\n                y: y + prop.keyTextOffsety + prop.keyOffsety,\n                color: 'black',\n                background: 'white',\n                padding: 0\n            });\n\n            x += 10 + blobSize + 5 + textDimensions[0];\n        }\n    };\n\n    /**\n    * Create a TABLE based HTML key. There's lots of options so it's\n    * suggested that you consult the documentation page\n    * \n    * @param mixed id   This should be a string consisting of the ID of the container\n    * @param object prop An object map of the various properties that you can use to\n    *                    configure the key. See the documentation page for a list.\n    */\n    RG.SVG.HTML.key = function (id, prop) {\n        var div = doc.getElementById(id);\n\n        /**\n        * Create the table that becomes the key\n        */\n        var str = '<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" id=\"rgraph_key\" style=\"display: inline;' + function () {\n            var style = '';\n            for (i in prop.tableCss) {\n                if (typeof i === 'string') {\n                    style = style + i + ': ' + prop.tableCss[i] + ';';\n                }\n            }\n            return style;\n        }() + '\" ' + (prop.tableClass ? 'class=\"' + prop.tableClass + '\"' : '') + '>';\n\n        /**\n        * Add the individual key elements\n        */\n        for (var i = 0; i < prop.labels.length; i += 1) {\n            str += '<tr><td><div style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.blobCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.blobCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '\"' + (prop.blobClass ? 'class=\"' + prop.blobClass + '\"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href=\"' + prop.links[i] + '\">' : '') + '<span ' + (prop.labelClass ? 'class=\"' + prop.labelClass + '\"' : '') + '\" style=\"' + function () {\n                var style = '';\n\n                for (var j in prop.labelCss) {\n                    if (typeof j === 'string') {\n                        style = style + j + ': ' + prop.labelCss[j] + ';';\n                    }\n                }\n\n                return style;\n            }() + '\" ' + function () {\n                var style = '';\n\n                if (prop['labelCss_' + i]) {\n                    for (var j in prop['labelCss_' + i]) {\n                        style = style + j + ': ' + prop['labelCss_' + i][j] + ';';\n                    }\n                }\n\n                return style ? 'style=\"' + style + '\"' : '';\n            }() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';\n        }\n\n        div.innerHTML += str + '</table>';\n\n        // Return the TABLE object that is the HTML key\n        return doc.getElementById('rgraph_key');\n    };\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmtleS5qcz81ZjhkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZlcnNpb246IDIwMTctMDUtMDhcbi8qKlxuKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4qIHwgVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIFJHcmFwaCBwYWNrYWdlIC0geW91IGNhbiBsZWFybiBtb3JlIGF0OiAgICAgICAgICAgICAgIHxcbiogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnJncmFwaC5uZXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfCBSR3JhcGggaXMgbGljZW5zZWQgdW5kZXIgdGhlIE9wZW4gU291cmNlIE1JVCBsaWNlbnNlLiBUaGF0IG1lYW5zIHRoYXQgaXQncyAgICAgfFxuKiB8IHRvdGFsbHkgZnJlZSB0byB1c2UhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIG8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLW9cbiovXG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1xuUkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307XG5SR3JhcGguU1ZHLkhUTUwgPSBSR3JhcGguU1ZHLkhUTUwgfHwge307XG5cbi8vIE1vZHVsZSBwYXR0ZXJuXG4oZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgbWEgPSBNYXRoO1xuXG4gICAgLyoqXG4gICAgKiBEcmF3cyB0aGUgZ3JhcGgga2V5ICh1c2VkIGJ5IHZhcmlvdXMgZ3JhcGhzKVxuICAgICogXG4gICAgKiBAcGFyYW0gb2JqZWN0IG9iaiBUaGUgZ3JhcGggb2JqZWN0XG4gICAgKiBAcGFyYW0gYXJyYXkgIGtleSBBbiBhcnJheSBvZiB0aGUgdGV4dHMgdG8gYmUgbGlzdGVkIGluIHRoZSBrZXlcbiAgICAqIEBwYXJhbSBjb2xvcnMgQW4gYXJyYXkgb2YgdGhlIGNvbG9ycyB0byBiZSB1c2VkXG4gICAgKi9cbiAgICBSRy5TVkcuZHJhd0tleSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmoucHJvcGVydGllcyxcbiAgICAgICAgICAgIGtleSA9IHByb3Aua2V5LFxuICAgICAgICAgICAgY29sb3JzID0gcHJvcC5rZXlDb2xvcnMgfHwgcHJvcC5jb2xvcnMsXG4gICAgICAgICAgICBkZWZhdWx0Rm9udCA9ICdBcmlhbCcsXG4gICAgICAgICAgICBibG9iU2l6ZSA9IDAsXG4gICAgICAgICAgICB3aWR0aCA9IDA7XG5cbiAgICAgICAgLy8gV29yayBvdXQgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgU1ZHIHRhZ1xuICAgICAgICB2YXIgY2VudGVyeCA9IG9iai5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIC8gMjtcblxuICAgICAgICAvLyBGaXJzdCBtZWFzdXJlIHRoZSBsZW5ndGggc28gdGhhdCB0aGUga2V5IGNhbiBiZSBjZW50ZXJlZFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBGaXJzdCBtZWFzdXJlIHRoZSB0ZXh0XG4gICAgICAgICAgICB2YXIgdGV4dERpbWVuc2lvbnMgPSBSRy5TVkcubWVhc3VyZVRleHQoe1xuICAgICAgICAgICAgICAgIHRleHQ6IGtleVtpXSxcbiAgICAgICAgICAgICAgICBib2xkOiBwcm9wLmtleVRleHRCb2xkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvbnQ6IHByb3Aua2V5VGV4dEZvbnQgfHwgcHJvcC50ZXh0Rm9udCB8fCBkZWZhdWx0Rm9udCxcbiAgICAgICAgICAgICAgICBzaXplOiBwcm9wLmtleVRleHRTaXplIHx8IHByb3AudGV4dFNpemVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBibG9iU2l6ZSA9IG1hLm1heChibG9iU2l6ZSwgdGV4dERpbWVuc2lvbnNbMV0pO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoICsgMTAgKyBibG9iU2l6ZSArIDUgKyB0ZXh0RGltZW5zaW9uc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENlbnRlciB0aGUga2V5XG4gICAgICAgIHggPSBjZW50ZXJ4IC0gd2lkdGggLyAyO1xuXG4gICAgICAgIC8vIExvb3AgdGhydSB0aGUga2V5IGFuZCBkcmF3IHRoZW1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHkgPSBwcm9wLmd1dHRlclRvcCAtIDU7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgLy8gRmlyc3QgbWVhc3VyZSB0aGUgdGV4dFxuICAgICAgICAgICAgdmFyIHRleHREaW1lbnNpb25zID0gUkcuU1ZHLm1lYXN1cmVUZXh0KHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBrZXlbaV0sXG4gICAgICAgICAgICAgICAgYm9sZDogcHJvcC5rZXlUZXh0Qm9sZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb250OiBwcm9wLmtleVRleHRGb250IHx8IHByb3AudGV4dEZvbnQgfHwgZGVmYXVsdEZvbnQsXG4gICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5rZXlUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiBvYmouc3ZnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IG9iai5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCArIHByb3Aua2V5T2Zmc2V0eCxcbiAgICAgICAgICAgICAgICAgICAgeTogeSAtIGJsb2JTaXplICsgcHJvcC5rZXlPZmZzZXR5LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmxvYlNpemUsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYmxvYlNpemUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBSR3JhcGguU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgIHBhcmVudDogb2JqLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5rZXlUZXh0U2l6ZSB8fCBwcm9wLnRleHRTaXplLFxuICAgICAgICAgICAgICAgIGJvbGQ6IHByb3Aua2V5VGV4dEJvbGQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9udDogJ0FyaWFsJyxcbiAgICAgICAgICAgICAgICBpdGFsaWM6IHByb3Aua2V5VGV4dEl0YWxpYyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBoYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICB2YWxpZ246ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIHRleHQ6IGtleVtpXSxcbiAgICAgICAgICAgICAgICB4OiB4ICsgYmxvYlNpemUgKyA1ICsgcHJvcC5rZXlUZXh0T2Zmc2V0eCArIHByb3Aua2V5T2Zmc2V0eCxcbiAgICAgICAgICAgICAgICB5OiB5ICsgcHJvcC5rZXlUZXh0T2Zmc2V0eSArIHByb3Aua2V5T2Zmc2V0eSxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4ICs9IDEwICsgYmxvYlNpemUgKyA1ICsgdGV4dERpbWVuc2lvbnNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBUQUJMRSBiYXNlZCBIVE1MIGtleS4gVGhlcmUncyBsb3RzIG9mIG9wdGlvbnMgc28gaXQnc1xuICAgICogc3VnZ2VzdGVkIHRoYXQgeW91IGNvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gcGFnZVxuICAgICogXG4gICAgKiBAcGFyYW0gbWl4ZWQgaWQgICBUaGlzIHNob3VsZCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIHRoZSBJRCBvZiB0aGUgY29udGFpbmVyXG4gICAgKiBAcGFyYW0gb2JqZWN0IHByb3AgQW4gb2JqZWN0IG1hcCBvZiB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgeW91IGNhbiB1c2UgdG9cbiAgICAqICAgICAgICAgICAgICAgICAgICBjb25maWd1cmUgdGhlIGtleS4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIHBhZ2UgZm9yIGEgbGlzdC5cbiAgICAqL1xuICAgIFJHLlNWRy5IVE1MLmtleSA9IGZ1bmN0aW9uIChpZCwgcHJvcCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBDcmVhdGUgdGhlIHRhYmxlIHRoYXQgYmVjb21lcyB0aGUga2V5XG4gICAgICAgICovXG4gICAgICAgIHZhciBzdHIgPSAnPHRhYmxlIGJvcmRlcj1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBjZWxscGFkZGluZz1cIjBcIiBpZD1cInJncmFwaF9rZXlcIiBzdHlsZT1cImRpc3BsYXk6IGlubGluZTsnICsgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGkgaW4gcHJvcC50YWJsZUNzcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSArIGkgKyAnOiAnICsgcHJvcC50YWJsZUNzc1tpXSArICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0oKSArICdcIiAnICsgKHByb3AudGFibGVDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLnRhYmxlQ2xhc3MgKyAnXCInIDogJycpICsgJz4nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEFkZCB0aGUgaW5kaXZpZHVhbCBrZXkgZWxlbWVudHNcbiAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wLmxhYmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3RyICs9ICc8dHI+PHRkPjxkaXYgc3R5bGU9XCInICsgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwcm9wLmJsb2JDc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSArIGogKyAnOiAnICsgcHJvcC5ibG9iQ3NzW2pdICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgfSgpICsgJ2Rpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLXJpZ2h0OiA1cHg7IG1hcmdpbi10b3A6IDRweDsgd2lkdGg6IDE1cHg7IGhlaWdodDogMTVweDsgYmFja2dyb3VuZC1jb2xvcjogJyArIHByb3AuY29sb3JzW2ldICsgJ1wiJyArIChwcm9wLmJsb2JDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmJsb2JDbGFzcyArICdcIicgOiAnJykgKyAnPiZuYnNwOzwvZGl2Pjx0ZD4nICsgKHByb3AubGlua3MgJiYgcHJvcC5saW5rc1tpXSA/ICc8YSBocmVmPVwiJyArIHByb3AubGlua3NbaV0gKyAnXCI+JyA6ICcnKSArICc8c3BhbiAnICsgKHByb3AubGFiZWxDbGFzcyA/ICdjbGFzcz1cIicgKyBwcm9wLmxhYmVsQ2xhc3MgKyAnXCInIDogJycpICsgJ1wiIHN0eWxlPVwiJyArIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSAnJztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gcHJvcC5sYWJlbENzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlICsgaiArICc6ICcgKyBwcm9wLmxhYmVsQ3NzW2pdICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgfSgpICsgJ1wiICcgKyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcFsnbGFiZWxDc3NfJyArIGldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gcHJvcFsnbGFiZWxDc3NfJyArIGldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlICsgaiArICc6ICcgKyBwcm9wWydsYWJlbENzc18nICsgaV1bal0gKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGUgPyAnc3R5bGU9XCInICsgc3R5bGUgKyAnXCInIDogJyc7XG4gICAgICAgICAgICB9KCkgKyAnPicgKyBwcm9wLmxhYmVsc1tpXSArICc8L3NwYW4+JyArIChwcm9wLmxpbmtzICYmIHByb3AubGlua3NbaV0gPyAnPC9hPicgOiAnJykgKyAnPC90ZD48L3RyPic7XG4gICAgICAgIH1cblxuICAgICAgICBkaXYuaW5uZXJIVE1MICs9IHN0ciArICc8L3RhYmxlPic7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBUQUJMRSBvYmplY3QgdGhhdCBpcyB0aGUgSFRNTCBrZXlcbiAgICAgICAgcmV0dXJuIGRvYy5nZXRFbGVtZW50QnlJZCgncmdyYXBoX2tleScpO1xuICAgIH07XG5cbiAgICAvLyBFbmQgbW9kdWxlIHBhdHRlcm5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLmtleS5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///209\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };(function (win, doc, undefined) {\n  RGraph.Sheets = function (key) {\n    var worksheet,\n        callback,\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';if (arguments.length === 3) {\n      worksheet = Number(arguments[1]);callback = arguments[2];\n    } else {\n      worksheet = 1;callback = arguments[1];\n    }\n    var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\\[KEY\\]/, key).replace(/\\[WORKSHEET\\]/, worksheet);this.load = function (url, userCallback) {\n      var obj = this;__rgraph_JSONPCallback = function __rgraph_JSONPCallback(json) {\n        obj.json = json;var grid = [],\n            row = 0,\n            col = 0;for (var i = 0; i < json.feed.entry.length; ++i) {\n          row = json.feed.entry[i].gs$cell.row - 1;col = json.feed.entry[i].gs$cell.col - 1;if (!grid[row]) {\n            grid[row] = [];\n          }\n          grid[row][col] = json.feed.entry[i].content.$t;\n        }\n        var maxcols = 0;for (var i = 0; i < grid.length; ++i) {\n          maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;\n        }\n        for (var i = 0; i < grid.length; ++i) {\n          if (typeof grid[i] === 'undefined') {\n            grid[i] = new Array(maxcols);\n          }\n          for (var j = 0; j < maxcols; j++) {\n            if (typeof grid[i][j] === 'undefined') {\n              grid[i][j] = '';\n            }\n            if (grid[i][j].match(/^[0-9]+$/)) {\n              grid[i][j] = parseInt(grid[i][j]);\n            } else if (grid[i][j].match(/^[0-9.]+$/)) {\n              grid[i][j] = parseFloat(grid[i][j]);\n            }\n          }\n        }\n        obj.data = grid;userCallback(obj);\n      };var scriptNode = document.createElement('SCRIPT');scriptNode.src = url;document.body.appendChild(scriptNode);\n    };this.row = function (index, start) {\n      var opt = {},\n          row;start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      row = this.data[index - 1].slice(start - 1);if (opt.trim) {\n        row = RGraph.SVG.arrayTrim(row);\n      }\n      return row;\n    };this.col = function (index, start) {\n      var opt = {},\n          col = [];start = start || 1;if (arguments && _typeof(arguments[2]) === 'object' && typeof arguments[2].trim === 'boolean') {\n        opt.trim = arguments[2].trim;\n      } else {\n        opt.trim = true;\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        col.push(this.data[i][index - 1]);\n      }\n      if (opt.trim) {\n        col = RGraph.SVG.arrayTrim(col);\n      }\n      col = col.slice(start - 1);return col;\n    };this.getIndexOfLetters = function (l) {\n      var parts = l.split('');if (parts.length === 1) {\n        return letters.indexOf(l) + 1;\n      } else if (parts.length === 2) {\n        var idx = (letters.indexOf(parts[0]) + 1) * 26 + (letters.indexOf(parts[1]) + 1);return idx;\n      }\n    };\n    this.get = function (str) {\n      str = str.toUpperCase();if (str.match(/^[a-z]+$/i)) {\n        if (str.length === 1) {\n          var index = letters.indexOf(str) + 1;return this.col(index, 1, arguments[1]);\n        } else if (str.length === 2) {\n          var index = (letters.indexOf(str[0]) + 1) * 26 + letters.indexOf(str[1]) + 1;return this.col(index, 1, arguments[1]);\n        }\n      }\n      if (str.match(/^[0-9]+$/i)) {\n        return this.row(str, null, arguments[1]);\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {\n        var letter = RegExp.$1,\n            number = RegExp.$2,\n            col = this.get(letter, { trim: false });return col[number - 1];\n      }\n      if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {\n        var letter1 = RegExp.$1,\n            number1 = RegExp.$2,\n            letter2 = RegExp.$3,\n            number2 = RegExp.$4;\n        if (letter1 === letter2) {\n          var cells = [],\n              index = this.getIndexOfLetters(letter1),\n              col = this.col(index, null, { trim: false });for (var i = number1 - 1; i <= number2 - 1; ++i) {\n            cells.push(col[i]);\n          }\n        } else if (number1 === number2) {\n          var cells = [],\n              row = this.row(number1, null, { trim: false }),\n              index1 = this.getIndexOfLetters(letter1),\n              index2 = this.getIndexOfLetters(letter2);\n          for (var i = index1 - 1; i <= index2 - 1; ++i) {\n            cells.push(row[i]);\n          }\n        }\n        if (arguments[1] && arguments[1].trim === false) {} else {\n          cells = RGraph.SVG.arrayTrim(cells);\n        }\n        return cells;\n      }\n    };this.load(url, callback);\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLnNoZWV0cy5qcz9iZTkxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIFJHcmFwaC5TaGVldHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHdvcmtzaGVldCxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIGxldHRlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB3b3Jrc2hlZXQgPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtjYWxsYmFjayA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya3NoZWV0ID0gMTtjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgdmFyIHVybCA9ICdodHRwczovL3NwcmVhZHNoZWV0cy5nb29nbGUuY29tL2ZlZWRzL2NlbGxzL1tLRVldL1tXT1JLU0hFRVRdL3B1YmxpYy9mdWxsP2FsdD1qc29uLWluLXNjcmlwdCZjYWxsYmFjaz1fX3JncmFwaF9KU09OUENhbGxiYWNrJy5yZXBsYWNlKC9cXFtLRVlcXF0vLCBrZXkpLnJlcGxhY2UoL1xcW1dPUktTSEVFVFxcXS8sIHdvcmtzaGVldCk7dGhpcy5sb2FkID0gZnVuY3Rpb24gKHVybCwgdXNlckNhbGxiYWNrKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztfX3JncmFwaF9KU09OUENhbGxiYWNrID0gZnVuY3Rpb24gX19yZ3JhcGhfSlNPTlBDYWxsYmFjayhqc29uKSB7XG4gICAgICAgIG9iai5qc29uID0ganNvbjt2YXIgZ3JpZCA9IFtdLFxuICAgICAgICAgICAgcm93ID0gMCxcbiAgICAgICAgICAgIGNvbCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmZlZWQuZW50cnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByb3cgPSBqc29uLmZlZWQuZW50cnlbaV0uZ3MkY2VsbC5yb3cgLSAxO2NvbCA9IGpzb24uZmVlZC5lbnRyeVtpXS5ncyRjZWxsLmNvbCAtIDE7aWYgKCFncmlkW3Jvd10pIHtcbiAgICAgICAgICAgIGdyaWRbcm93XSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmlkW3Jvd11bY29sXSA9IGpzb24uZmVlZC5lbnRyeVtpXS5jb250ZW50LiR0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhjb2xzID0gMDtmb3IgKHZhciBpID0gMDsgaSA8IGdyaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBtYXhjb2xzID0gZ3JpZFtpXSA/IE1hdGgubWF4KG1heGNvbHMsIGdyaWRbaV0ubGVuZ3RoKSA6IG1heGNvbHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBncmlkW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZ3JpZFtpXSA9IG5ldyBBcnJheShtYXhjb2xzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXhjb2xzOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JpZFtpXVtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZ3JpZFtpXVtqXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWRbaV1bal0ubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgZ3JpZFtpXVtqXSA9IHBhcnNlSW50KGdyaWRbaV1bal0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChncmlkW2ldW2pdLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgICBncmlkW2ldW2pdID0gcGFyc2VGbG9hdChncmlkW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLmRhdGEgPSBncmlkO3VzZXJDYWxsYmFjayhvYmopO1xuICAgICAgfTt2YXIgc2NyaXB0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO3NjcmlwdE5vZGUuc3JjID0gdXJsO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0Tm9kZSk7XG4gICAgfTt0aGlzLnJvdyA9IGZ1bmN0aW9uIChpbmRleCwgc3RhcnQpIHtcbiAgICAgIHZhciBvcHQgPSB7fSxcbiAgICAgICAgICByb3c7c3RhcnQgPSBzdGFydCB8fCAxO2lmIChhcmd1bWVudHMgJiYgX3R5cGVvZihhcmd1bWVudHNbMl0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzJdLnRyaW0gPT09ICdib29sZWFuJykge1xuICAgICAgICBvcHQudHJpbSA9IGFyZ3VtZW50c1syXS50cmltO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LnRyaW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcm93ID0gdGhpcy5kYXRhW2luZGV4IC0gMV0uc2xpY2Uoc3RhcnQgLSAxKTtpZiAob3B0LnRyaW0pIHtcbiAgICAgICAgcm93ID0gUkdyYXBoLlNWRy5hcnJheVRyaW0ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfTt0aGlzLmNvbCA9IGZ1bmN0aW9uIChpbmRleCwgc3RhcnQpIHtcbiAgICAgIHZhciBvcHQgPSB7fSxcbiAgICAgICAgICBjb2wgPSBbXTtzdGFydCA9IHN0YXJ0IHx8IDE7aWYgKGFyZ3VtZW50cyAmJiBfdHlwZW9mKGFyZ3VtZW50c1syXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmd1bWVudHNbMl0udHJpbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdC50cmltID0gYXJndW1lbnRzWzJdLnRyaW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQudHJpbSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb2wucHVzaCh0aGlzLmRhdGFbaV1baW5kZXggLSAxXSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0LnRyaW0pIHtcbiAgICAgICAgY29sID0gUkdyYXBoLlNWRy5hcnJheVRyaW0oY29sKTtcbiAgICAgIH1cbiAgICAgIGNvbCA9IGNvbC5zbGljZShzdGFydCAtIDEpO3JldHVybiBjb2w7XG4gICAgfTt0aGlzLmdldEluZGV4T2ZMZXR0ZXJzID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGwuc3BsaXQoJycpO2lmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlcnMuaW5kZXhPZihsKSArIDE7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgaWR4ID0gKGxldHRlcnMuaW5kZXhPZihwYXJ0c1swXSkgKyAxKSAqIDI2ICsgKGxldHRlcnMuaW5kZXhPZihwYXJ0c1sxXSkgKyAxKTtyZXR1cm4gaWR4O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtpZiAoc3RyLm1hdGNoKC9eW2Etel0rJC9pKSkge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxldHRlcnMuaW5kZXhPZihzdHIpICsgMTtyZXR1cm4gdGhpcy5jb2woaW5kZXgsIDEsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHZhciBpbmRleCA9IChsZXR0ZXJzLmluZGV4T2Yoc3RyWzBdKSArIDEpICogMjYgKyBsZXR0ZXJzLmluZGV4T2Yoc3RyWzFdKSArIDE7cmV0dXJuIHRoaXMuY29sKGluZGV4LCAxLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyLm1hdGNoKC9eWzAtOV0rJC9pKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3coc3RyLCBudWxsLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5tYXRjaCgvXihbYS16XXsxLDJ9KShbMC05XSspJC9pKSkge1xuICAgICAgICB2YXIgbGV0dGVyID0gUmVnRXhwLiQxLFxuICAgICAgICAgICAgbnVtYmVyID0gUmVnRXhwLiQyLFxuICAgICAgICAgICAgY29sID0gdGhpcy5nZXQobGV0dGVyLCB7IHRyaW06IGZhbHNlIH0pO3JldHVybiBjb2xbbnVtYmVyIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoc3RyLm1hdGNoKC9eKFthLXpdezEsMn0pKFswLTldKyk6KFthLXpdezEsMn0pKFswLTldKykkL2kpKSB7XG4gICAgICAgIHZhciBsZXR0ZXIxID0gUmVnRXhwLiQxLFxuICAgICAgICAgICAgbnVtYmVyMSA9IFJlZ0V4cC4kMixcbiAgICAgICAgICAgIGxldHRlcjIgPSBSZWdFeHAuJDMsXG4gICAgICAgICAgICBudW1iZXIyID0gUmVnRXhwLiQ0O1xuICAgICAgICBpZiAobGV0dGVyMSA9PT0gbGV0dGVyMikge1xuICAgICAgICAgIHZhciBjZWxscyA9IFtdLFxuICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPZkxldHRlcnMobGV0dGVyMSksXG4gICAgICAgICAgICAgIGNvbCA9IHRoaXMuY29sKGluZGV4LCBudWxsLCB7IHRyaW06IGZhbHNlIH0pO2ZvciAodmFyIGkgPSBudW1iZXIxIC0gMTsgaSA8PSBudW1iZXIyIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNvbFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG51bWJlcjEgPT09IG51bWJlcjIpIHtcbiAgICAgICAgICB2YXIgY2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgcm93ID0gdGhpcy5yb3cobnVtYmVyMSwgbnVsbCwgeyB0cmltOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgaW5kZXgxID0gdGhpcy5nZXRJbmRleE9mTGV0dGVycyhsZXR0ZXIxKSxcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5nZXRJbmRleE9mTGV0dGVycyhsZXR0ZXIyKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXgxIC0gMTsgaSA8PSBpbmRleDIgLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2gocm93W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0udHJpbSA9PT0gZmFsc2UpIHt9IGVsc2Uge1xuICAgICAgICAgIGNlbGxzID0gUkdyYXBoLlNWRy5hcnJheVRyaW0oY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZWxscztcbiAgICAgIH1cbiAgICB9O3RoaXMubG9hZCh1cmwsIGNhbGxiYWNrKTtcbiAgfTtcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLnNoZWV0cy5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///210\n")},function(module,exports){eval("\nRGraph = window.RGraph || { isRGraph: true, isRGraphSVG: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math;RG.SVG.tooltips = {};RG.SVG.tooltips.style = { display: 'inline-block', position: 'absolute', padding: '6px', fontFamily: 'Arial', fontSize: '12pt', fontWeight: 'normal', textAlign: 'center', left: 0, top: 0, backgroundColor: 'rgb(255,255,239)', color: 'black', visibility: 'visible', zIndex: 3, borderRadius: '5px', boxShadow: 'rgba(96,96,96,0.5) 0 0 5px', transition: 'left ease-out .25s, top ease-out .25s' };RG.SVG.tooltip = function (opt) {\n    var obj = opt.object;RG.SVG.fireCustomEvent(obj, 'onbeforetooltip');if (!opt.text || typeof opt.text === 'undefined' || RG.SVG.trim(opt.text).length === 0) {\n      return;\n    }\n    var prop = obj.properties;if (typeof prop.tooltipsOverride === 'function') {\n      return prop.tooltipsOverride(obj, opt);\n    }\n    if (!RG.SVG.REG.get('tooltip')) {\n      var tooltipObj = document.createElement('DIV');tooltipObj.className = prop.tooltipsCssClass;for (var i in RG.SVG.tooltips.style) {\n        if (typeof i === 'string') {\n          tooltipObj.style[i] = RG.SVG.tooltips.style[i];\n        }\n      }\n    } else {\n      var tooltipObj = RG.SVG.REG.get('tooltip');tooltipObj.__object__.removeHighlight();tooltipObj.style.width = '';\n    }\n    if (RG.SVG.REG.get('tooltip-lasty')) {\n      tooltipObj.style.left = RG.SVG.REG.get('tooltip-lastx') + 'px';tooltipObj.style.top = RG.SVG.REG.get('tooltip-lasty') + 'px';\n    }\n    tooltipObj.innerHTML = opt.text;tooltipObj.__text__ = opt.text;tooltipObj.id = '__rgraph_tooltip_' + obj.id + '_' + obj.uid + '_' + opt.index;tooltipObj.__event__ = prop.tooltipsEvent || 'click';tooltipObj.__object__ = obj;if (typeof opt.index === 'number') {\n      tooltipObj.__index__ = opt.index;\n    }\n    if (typeof opt.dataset === 'number') {\n      tooltipObj.__dataset__ = opt.dataset;\n    }\n    if (typeof opt.group === 'number' || RG.SVG.isNull(opt.group)) {\n      tooltipObj.__group__ = opt.group;\n    }\n    if (typeof opt.sequentialIndex === 'number') {\n      tooltipObj.__sequentialIndex__ = opt.sequentialIndex;\n    }\n    document.body.appendChild(tooltipObj);var width = tooltipObj.offsetWidth,\n        height = tooltipObj.offsetHeight;tooltipObj.style.left = opt.event.pageX - width / 2 + 'px';tooltipObj.style.top = opt.event.pageY - height - 15 + 'px';tooltipObj.style.width = width + 'px';if (!RG.SVG.REG.get('tooltip-lastx')) {\n      for (var i = 0; i <= 30; ++i) {\n        (function (idx) {\n          setTimeout(function () {\n            tooltipObj.style.opacity = idx / 30 * 1;\n          }, idx / 30 * 200);\n        })(i);\n      }\n    }\n    if (parseFloat(tooltipObj.style.left) <= 5) {\n      tooltipObj.style.left = '5px';\n    }\n    if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {\n      tooltipObj.style.left = '';\n      tooltipObj.style.right = '5px';\n    }\n    if (RG.SVG.isFixed(obj.svg)) {\n      var scrollTop = window.scrollY || document.documentElement.scrollTop;tooltipObj.style.position = 'fixed';tooltipObj.style.top = opt.event.pageY - scrollTop - height - 10 + 'px';\n    }\n    tooltipObj.onmousedown = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onmouseup = function (e) {\n      e.stopPropagation();\n    };tooltipObj.onclick = function (e) {\n      if (e.button == 0) {\n        e.stopPropagation();\n      }\n    };document.body.addEventListener('mouseup', function (e) {\n      RG.SVG.hideTooltip();\n    }, false);RG.SVG.REG.set('tooltip', tooltipObj);RG.SVG.REG.set('tooltip-lastx', parseFloat(tooltipObj.style.left));RG.SVG.REG.set('tooltip-lasty', parseFloat(tooltipObj.style.top));RG.SVG.fireCustomEvent(obj, 'ontooltip');\n  };\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuY29tbW9uLnRvb2x0aXBzLmpzPzczODgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUsIGlzUkdyYXBoU1ZHOiB0cnVlIH07UkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aDtSRy5TVkcudG9vbHRpcHMgPSB7fTtSRy5TVkcudG9vbHRpcHMuc3R5bGUgPSB7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgcGFkZGluZzogJzZweCcsIGZvbnRGYW1pbHk6ICdBcmlhbCcsIGZvbnRTaXplOiAnMTJwdCcsIGZvbnRXZWlnaHQ6ICdub3JtYWwnLCB0ZXh0QWxpZ246ICdjZW50ZXInLCBsZWZ0OiAwLCB0b3A6IDAsIGJhY2tncm91bmRDb2xvcjogJ3JnYigyNTUsMjU1LDIzOSknLCBjb2xvcjogJ2JsYWNrJywgdmlzaWJpbGl0eTogJ3Zpc2libGUnLCB6SW5kZXg6IDMsIGJvcmRlclJhZGl1czogJzVweCcsIGJveFNoYWRvdzogJ3JnYmEoOTYsOTYsOTYsMC41KSAwIDAgNXB4JywgdHJhbnNpdGlvbjogJ2xlZnQgZWFzZS1vdXQgLjI1cywgdG9wIGVhc2Utb3V0IC4yNXMnIH07UkcuU1ZHLnRvb2x0aXAgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIG9iaiA9IG9wdC5vYmplY3Q7UkcuU1ZHLmZpcmVDdXN0b21FdmVudChvYmosICdvbmJlZm9yZXRvb2x0aXAnKTtpZiAoIW9wdC50ZXh0IHx8IHR5cGVvZiBvcHQudGV4dCA9PT0gJ3VuZGVmaW5lZCcgfHwgUkcuU1ZHLnRyaW0ob3B0LnRleHQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IG9iai5wcm9wZXJ0aWVzO2lmICh0eXBlb2YgcHJvcC50b29sdGlwc092ZXJyaWRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvcC50b29sdGlwc092ZXJyaWRlKG9iaiwgb3B0KTtcbiAgICB9XG4gICAgaWYgKCFSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpKSB7XG4gICAgICB2YXIgdG9vbHRpcE9iaiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO3Rvb2x0aXBPYmouY2xhc3NOYW1lID0gcHJvcC50b29sdGlwc0Nzc0NsYXNzO2ZvciAodmFyIGkgaW4gUkcuU1ZHLnRvb2x0aXBzLnN0eWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0b29sdGlwT2JqLnN0eWxlW2ldID0gUkcuU1ZHLnRvb2x0aXBzLnN0eWxlW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0b29sdGlwT2JqID0gUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAnKTt0b29sdGlwT2JqLl9fb2JqZWN0X18ucmVtb3ZlSGlnaGxpZ2h0KCk7dG9vbHRpcE9iai5zdHlsZS53aWR0aCA9ICcnO1xuICAgIH1cbiAgICBpZiAoUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAtbGFzdHknKSkge1xuICAgICAgdG9vbHRpcE9iai5zdHlsZS5sZWZ0ID0gUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAtbGFzdHgnKSArICdweCc7dG9vbHRpcE9iai5zdHlsZS50b3AgPSBSRy5TVkcuUkVHLmdldCgndG9vbHRpcC1sYXN0eScpICsgJ3B4JztcbiAgICB9XG4gICAgdG9vbHRpcE9iai5pbm5lckhUTUwgPSBvcHQudGV4dDt0b29sdGlwT2JqLl9fdGV4dF9fID0gb3B0LnRleHQ7dG9vbHRpcE9iai5pZCA9ICdfX3JncmFwaF90b29sdGlwXycgKyBvYmouaWQgKyAnXycgKyBvYmoudWlkICsgJ18nICsgb3B0LmluZGV4O3Rvb2x0aXBPYmouX19ldmVudF9fID0gcHJvcC50b29sdGlwc0V2ZW50IHx8ICdjbGljayc7dG9vbHRpcE9iai5fX29iamVjdF9fID0gb2JqO2lmICh0eXBlb2Ygb3B0LmluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgdG9vbHRpcE9iai5fX2luZGV4X18gPSBvcHQuaW5kZXg7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0LmRhdGFzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0b29sdGlwT2JqLl9fZGF0YXNldF9fID0gb3B0LmRhdGFzZXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0Lmdyb3VwID09PSAnbnVtYmVyJyB8fCBSRy5TVkcuaXNOdWxsKG9wdC5ncm91cCkpIHtcbiAgICAgIHRvb2x0aXBPYmouX19ncm91cF9fID0gb3B0Lmdyb3VwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdC5zZXF1ZW50aWFsSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICB0b29sdGlwT2JqLl9fc2VxdWVudGlhbEluZGV4X18gPSBvcHQuc2VxdWVudGlhbEluZGV4O1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXBPYmopO3ZhciB3aWR0aCA9IHRvb2x0aXBPYmoub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRvb2x0aXBPYmoub2Zmc2V0SGVpZ2h0O3Rvb2x0aXBPYmouc3R5bGUubGVmdCA9IG9wdC5ldmVudC5wYWdlWCAtIHdpZHRoIC8gMiArICdweCc7dG9vbHRpcE9iai5zdHlsZS50b3AgPSBvcHQuZXZlbnQucGFnZVkgLSBoZWlnaHQgLSAxNSArICdweCc7dG9vbHRpcE9iai5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztpZiAoIVJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwLWxhc3R4JykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDMwOyArK2kpIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRvb2x0aXBPYmouc3R5bGUub3BhY2l0eSA9IGlkeCAvIDMwICogMTtcbiAgICAgICAgICB9LCBpZHggLyAzMCAqIDIwMCk7XG4gICAgICAgIH0pKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLmxlZnQpIDw9IDUpIHtcbiAgICAgIHRvb2x0aXBPYmouc3R5bGUubGVmdCA9ICc1cHgnO1xuICAgIH1cbiAgICBpZiAocGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLmxlZnQpICsgcGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLndpZHRoKSA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICB0b29sdGlwT2JqLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgIHRvb2x0aXBPYmouc3R5bGUucmlnaHQgPSAnNXB4JztcbiAgICB9XG4gICAgaWYgKFJHLlNWRy5pc0ZpeGVkKG9iai5zdmcpKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDt0b29sdGlwT2JqLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJzt0b29sdGlwT2JqLnN0eWxlLnRvcCA9IG9wdC5ldmVudC5wYWdlWSAtIHNjcm9sbFRvcCAtIGhlaWdodCAtIDEwICsgJ3B4JztcbiAgICB9XG4gICAgdG9vbHRpcE9iai5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07dG9vbHRpcE9iai5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O3Rvb2x0aXBPYmoub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5idXR0b24gPT0gMCkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH07ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIFJHLlNWRy5oaWRlVG9vbHRpcCgpO1xuICAgIH0sIGZhbHNlKTtSRy5TVkcuUkVHLnNldCgndG9vbHRpcCcsIHRvb2x0aXBPYmopO1JHLlNWRy5SRUcuc2V0KCd0b29sdGlwLWxhc3R4JywgcGFyc2VGbG9hdCh0b29sdGlwT2JqLnN0eWxlLmxlZnQpKTtSRy5TVkcuUkVHLnNldCgndG9vbHRpcC1sYXN0eScsIHBhcnNlRmxvYXQodG9vbHRpcE9iai5zdHlsZS50b3ApKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KG9iaiwgJ29udG9vbHRpcCcpO1xuICB9O1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5jb21tb24udG9vbHRpcHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///211\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.HBar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'hbar';this.coords = [];this.stackedBackfaces = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 100, gutterRight: 35, gutterTop: 35, gutterBottom: 35, gutterLeftAutosize: true, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black', 'red', '#0f0', '#00f', '#ff0', '#0ff', '#0f0', 'pink', 'orange', 'gray', 'black'], colorsSequential: false, strokestyle: 'rgba(0,0,0,0)', vmargin: 3, vmarginGrouped: 2, vmarginTop: 0, vmarginBottom: 0, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisColor: 'black', xaxisLabels: [], xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsCount: 5, xaxisScale: true, xaxisUnitsPre: '', xaxisUnitsPost: '', xaxisStrict: false, xaxisDecimals: 0, xaxisPoint: '.', xaxisThousand: ',', xaxisRound: false, xaxisMax: null, xaxisMin: 0, xaxisFormatter: null, xaxisLabelsPositionEdgeTickmarksCount: null, xaxisTextColor: null, xaxisTextBold: null, xaxisTextItalic: null, xaxisTextFont: null, xaxisTextSize: null, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisLabels: [], yaxisLabelsPosition: 'section', yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisScale: false, yaxisLabelsPositionEdgeTickmarksCount: null, yaxisColor: 'black', yaxisTextFont: null, yaxisTextSize: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: null, labelsAboveBackgroundPadding: 0, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'left', labelsAboveValign: 'center', labelsAboveSpecific: null, linewidth: 1, grouping: 'grouped', tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleSize: 10, titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);if (prop.gutterLeftAutosize) {\n        for (var i = 0, len = prop.yaxisLabels.length, maxLength = 0; i < len; ++i) {\n          var sizes = RG.SVG.measureText({ text: prop.yaxisLabels[i], bold: prop.yaxisTextBold || prop.textBold, size: prop.yaxisTextSize || prop.textSize, font: prop.yaxisTextFont || prop.textFont });maxLength = ma.max(maxLength, sizes[0]);\n        }\n        prop.gutterLeft = maxLength + 15;\n      }\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          values.push(RG.SVG.arraySum(this.data[i]));\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.xaxisMax === 'number') {\n        max = prop.xaxisMax;\n      }\n      if (prop.xaxisMin === 'mirror' || prop.xaxisMin === 'middle' || prop.xaxisMin === 'center') {\n        var mirrorScale = true;prop.xaxisMin = prop.xaxisMax * -1;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: max, min: prop.xaxisMin, point: prop.xaxisPoint, round: prop.xaxisRound, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.xaxisLabelsCount, unitsPre: prop.xaxisUnitsPre, unitsPost: prop.xaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.xaxisPoint, round: false, thousand: prop.xaxisThousand, decimals: prop.xaxisDecimals, strict: typeof prop.xaxisMax === 'number', formatter: prop.xaxisFormatter });\n      }\n      this.max = this.scale.max;prop.xaxisMax = this.scale.max;this.min = this.scale.min;prop.xaxisMin = this.scale.min;RG.SVG.drawBackground(this);this.drawBars();RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0, sequentialIndex = 0; i < this.data.length; ++i, ++sequentialIndex) {\n        if (typeof this.data[i] === 'number') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              width = this.getWidth(this.data[i]),\n              height = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length - prop.vmargin - prop.vmargin,\n              x = this.getXCoord(this.scale.min < 0 && this.scale.max < 0 || this.scale.min > 0 && this.scale.max > 0 ? this.scale.min : 0) - (this.data[i] < 0 ? width : 0),\n              y = prop.gutterTop + prop.vmarginTop + prop.vmargin + outerSegment * i;if (this.scale.min < 0 && this.scale.max < 0) {\n            x = this.width - prop.gutterRight - width;\n          }\n          var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { stroke: prop.strokestyle, fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[0], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-original-width': width, 'data-original-height': height, 'data-sequential-index': sequentialIndex, 'data-value': this.data[i], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n            var obj = this;(function (idx, seq) {\n              rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, group: null, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n              }, false);rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            })(i, sequentialIndex);\n          }\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'grouped') {\n          var outerSegment = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n              innerSegment = outerSegment - 2 * prop.vmargin;for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = (innerSegment - (this.data[i].length - 1) * prop.vmarginGrouped) / this.data[i].length,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerSegment * i + j * height + j * prop.vmarginGrouped,\n                x = this.getXCoord(0) - (this.data[i][j] < 0 ? width : 0);if (this.scale.max < 0 && this.scale.min < this.scale.max) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.max);x = x1;width = x2 - x1;\n            } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n              var x1 = this.getXCoord(this.data[i][j]);var x2 = this.getXCoord(this.scale.min);x = this.getXCoord(this.scale.min);width = x1 - x2;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential && prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-width': width, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j], filter: prop.shadow ? 'url(#dropShadow)' : '' } });this.coords.push({ object: rect, x: x, y: y - (this.data[i][j] > 0 ? height : 0), width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();RG.SVG.tooltip({ object: obj, group: idx, index: indexes[1], sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n          }\n          --sequentialIndex;\n        } else if (RG.SVG.isArray(this.data[i]) && prop.grouping === 'stacked') {\n          var section = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length;var x = this.getXCoord(0);for (var j = 0; j < this.data[i].length; ++j, ++sequentialIndex) {\n            var outerHeight = (this.graphHeight - prop.vmarginTop - prop.vmarginBottom) / this.data.length,\n                width = ma.abs(this.data[i][j] / (this.max - this.min) * this.graphWidth),\n                height = outerHeight - 2 * prop.vmargin,\n                y = prop.gutterTop + prop.vmargin + prop.vmarginTop + outerHeight * i;if (j === 0 && prop.shadow) {\n              var fullWidth = ma.abs(RG.SVG.arraySum(this.data[i]) / (this.max - this.min) * this.graphWidth);var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: x, y: y, width: fullWidth, height: height, fill: 'white', 'stroke-width': 0, 'data-index': i, filter: 'url(#dropShadow)' } });this.stackedBackfaces[i] = rect;\n            }\n            var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop['strokestyle'], fill: prop.colorsSequential ? prop.colors[sequentialIndex] ? prop.colors[sequentialIndex] : prop.colors[prop.colors.length - 1] : prop.colors[j] ? prop.colors[j] : prop.colors[prop.colors.length - 1], x: x, y: y, width: width, height: height, 'stroke-width': prop.linewidth, 'data-original-width': width, 'data-original-height': height, 'data-original-x': x, 'data-original-y': y, 'data-index': i, 'data-sequential-index': sequentialIndex, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[sequentialIndex] : '', 'data-value': this.data[i][j] } });this.coords.push({ object: rect, x: x, y: y, width: width, height: height });if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[sequentialIndex]) {\n              var obj = this;(function (idx, seq) {\n                rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n                  obj.removeHighlight();var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);RG.SVG.tooltip({ object: obj, index: indexes[1], group: idx, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(e.target);\n                }, false);rect.addEventListener('mousemove', function (e) {\n                  e.target.style.cursor = 'pointer';\n                }, false);\n              })(i, sequentialIndex);\n            }\n            x += width;\n          }\n          --sequentialIndex;\n        }\n      }\n    };this.getXCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var x;if (value < this.scale.min) {\n        return null;\n      }\n      x = (value - this.scale.min) / (this.scale.max - this.scale.min);x *= this.graphWidth;x += prop.gutterLeft;return x;\n    };this.getWidth = function (value) {\n      if (this.scale.max <= 0 && this.scale.min < this.scale.max) {\n        var x1 = this.getXCoord(this.scale.max);var x2 = this.getXCoord(value);\n      } else if (this.scale.min > 0 && this.scale.max > this.scale.min) {\n        var x1 = this.getXCoord(this.scale.min);var x2 = this.getXCoord(value);\n      } else {\n        var x1 = this.getXCoord(0);var x2 = this.getXCoord(value);\n      }\n      return ma.abs(x1 - x2);\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i], direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill, direction: 'horizontal', start: prop.gutterLeft, end: this.width - prop.gutterRight });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data = RG.SVG.arrayLinearize(this.data);for (var i = 0; i < this.coords.length; ++i) {\n          var value = data[i].toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);var indexes = RG.SVG.sequentialIndexToGrouped(i, this.data);if (RG.SVG.isArray(this.data[indexes[0]]) && prop.grouping === 'stacked') {\n            if (indexes[1] + 1 === this.data[indexes[0]].length) {\n              value = RG.SVG.arraySum(this.data[indexes[0]]);value = value.toFixed(typeof prop.labelsAboveDecimals === 'number' ? prop.labelsAboveDecimals : prop.xaxisDecimals);\n            } else {\n              continue;\n            }\n          }\n          var str = prop.labelsAboveSpecific ? prop.labelsAboveSpecific[i].toString() : RG.SVG.numberFormat({ object: this, num: value, prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });var bold = typeof prop.labelsAboveBold === 'boolean' ? prop.labelsAboveBold : prop.textBold,\n              italic = typeof prop.labelsAboveItalic === 'boolean' ? prop.labelsAboveItalic : prop.textItalic,\n              size = prop.labelsAboveSize || prop.textSize,\n              font = prop.labelsAboveFont || prop.textFont,\n              halign = prop.labelsAboveHalign,\n              valign = prop.labelsAboveValign;var dimensions = RG.SVG.measureText({ text: str, bold: bold, font: font, size: size });var x = value >= 0 ? parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width')) + 7 + prop.labelsAboveOffsetx : parseFloat(this.coords[i].object.getAttribute('x') - 7 - prop.labelsAboveOffsetx),\n              y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height') / 2) + prop.labelsAboveOffsety,\n              width = dimensions[0],\n              height = dimensions[1],\n              halign = value >= 0 ? 'left' : 'right';if (x + width > this.width && value > 0) {\n            halign = 'right';x = this.width - 5;prop.labelsAboveBackground = prop.labelsAboveBackground || 'rgba(255,255,255,0.95)';\n          }\n          var text = RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: halign, valign: valign, font: font, size: size, bold: bold, italic: italic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;data = RG.SVG.arrayClone(this.data);this.draw();var iterate = function iterate() {\n        for (var i = 0, seq = 0, len = obj.coords.length; i < len; ++i, ++seq) {\n          var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);if (typeof data[i] === 'number') {\n            width = ma.abs(obj.getXCoord(data[i]) - obj.getXCoord(0));obj.data[i] = data[i] * multiplier;width = multiplier * width;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i] > 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);\n          } else if (_typeof(data[i]) === 'object') {\n            var accumulativeWidth = 0;for (var j = 0, len2 = data[i].length; j < len2; ++j, ++seq) {\n              width = ma.abs(obj.getXCoord(data[i][j]) - obj.getXCoord(0));width = multiplier * width;obj.data[i][j] = data[i][j] * multiplier;obj.coords[seq].object.setAttribute('width', width);obj.coords[seq].object.setAttribute('x', data[i][j] > 0 ? obj.getXCoord(0) + accumulativeWidth : obj.getXCoord(0) - width - accumulativeWidth);accumulativeWidth += prop.grouping === 'stacked' ? width : 0;\n            }\n            if (obj.stackedBackfaces[i]) {\n              obj.stackedBackfaces[i].setAttribute('width', accumulativeWidth);obj.stackedBackfaces[i].setAttribute('x', prop.gutterLeft);\n            }\n            --seq;\n          }\n        }\n        if (frame++ < frames) {\n          RG.SVG.FX.update(iterate);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterate();return this;\n    };this.wave = function () {\n      this.draw();var obj = this,\n          opt = arguments[0] || {};opt.frames = opt.frames || 60;opt.startFrames = [];opt.counters = [];var framesperbar = opt.frames / 3,\n          frame = -1,\n          callback = opt.callback || function () {},\n          width;for (var i = 0, len = this.coords.length; i < len; i += 1) {\n        opt.startFrames[i] = opt.frames / 2 / (obj.coords.length - 1) * i;opt.counters[i] = 0;this.coords[i].object.setAttribute('width', 0);\n      }\n      function iterator() {\n        ++frame;for (var i = 0, len = obj.coords.length; i < len; i += 1) {\n          if (frame > opt.startFrames[i]) {\n            var originalWidth = obj.coords[i].object.getAttribute('data-original-width'),\n                value = parseFloat(obj.coords[i].object.getAttribute('data-value'));obj.coords[i].object.setAttribute('width', width = ma.min((frame - opt.startFrames[i]) / framesperbar * originalWidth, originalWidth));obj.coords[i].object.setAttribute('x', value >= 0 ? obj.getXCoord(0) : obj.getXCoord(0) - width);if (prop.grouping === 'stacked') {\n              var seq = obj.coords[i].object.getAttribute('data-sequential-index');var indexes = RG.SVG.sequentialIndexToGrouped(seq, obj.data);if (indexes[1] > 0) {\n                obj.coords[i].object.setAttribute('x', parseInt(obj.coords[i - 1].object.getAttribute('x')) + parseInt(obj.coords[i - 1].object.getAttribute('width')));\n              }\n            }\n          }\n        }\n        if (frame >= opt.frames) {\n          callback(obj);\n        } else {\n          RG.SVG.FX.update(iterator);\n        }\n      }\n      iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuaGJhci5qcz9hNWQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aCxcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50O1JHLlNWRy5IQmFyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoaSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7IG9iamVjdDogdGhpcywgbmFtZTogaSwgdmFsdWU6IGFyZ3VtZW50c1swXVtpXSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuaWQgPSBjb25mLmlkO3RoaXMudWlkID0gUkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5zdmcgPSBSRy5TVkcuY3JlYXRlU1ZHKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7dGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7dGhpcy5kYXRhID0gY29uZi5kYXRhO3RoaXMudHlwZSA9ICdoYmFyJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuc3RhY2tlZEJhY2tmYWNlcyA9IFtdO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O3RoaXMuZ3JhZGllbnRDb3VudGVyID0gMTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXMgPSB7IGd1dHRlckxlZnQ6IDEwMCwgZ3V0dGVyUmlnaHQ6IDM1LCBndXR0ZXJUb3A6IDM1LCBndXR0ZXJCb3R0b206IDM1LCBndXR0ZXJMZWZ0QXV0b3NpemU6IHRydWUsIGJhY2tncm91bmRDb2xvcjogbnVsbCwgYmFja2dyb3VuZEltYWdlOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VBc3BlY3Q6ICdub25lJywgYmFja2dyb3VuZEltYWdlU3RyZXRjaDogdHJ1ZSwgYmFja2dyb3VuZEltYWdlT3BhY2l0eTogbnVsbCwgYmFja2dyb3VuZEltYWdlWDogbnVsbCwgYmFja2dyb3VuZEltYWdlWTogbnVsbCwgYmFja2dyb3VuZEltYWdlVzogbnVsbCwgYmFja2dyb3VuZEltYWdlSDogbnVsbCwgYmFja2dyb3VuZEdyaWQ6IHRydWUsIGJhY2tncm91bmRHcmlkQ29sb3I6ICcjZGRkJywgYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6IDEsIGJhY2tncm91bmRHcmlkSGxpbmVzOiB0cnVlLCBiYWNrZ3JvdW5kR3JpZEhsaW5lc0NvdW50OiBudWxsLCBiYWNrZ3JvdW5kR3JpZFZsaW5lczogdHJ1ZSwgYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudDogbnVsbCwgYmFja2dyb3VuZEdyaWRCb3JkZXI6IHRydWUsIGNvbG9yczogWydyZWQnLCAnIzBmMCcsICcjMDBmJywgJyNmZjAnLCAnIzBmZicsICcjMGYwJywgJ3BpbmsnLCAnb3JhbmdlJywgJ2dyYXknLCAnYmxhY2snLCAncmVkJywgJyMwZjAnLCAnIzAwZicsICcjZmYwJywgJyMwZmYnLCAnIzBmMCcsICdwaW5rJywgJ29yYW5nZScsICdncmF5JywgJ2JsYWNrJ10sIGNvbG9yc1NlcXVlbnRpYWw6IGZhbHNlLCBzdHJva2VzdHlsZTogJ3JnYmEoMCwwLDAsMCknLCB2bWFyZ2luOiAzLCB2bWFyZ2luR3JvdXBlZDogMiwgdm1hcmdpblRvcDogMCwgdm1hcmdpbkJvdHRvbTogMCwgeGF4aXM6IHRydWUsIHhheGlzVGlja21hcmtzOiB0cnVlLCB4YXhpc1RpY2ttYXJrc0xlbmd0aDogNSwgeGF4aXNDb2xvcjogJ2JsYWNrJywgeGF4aXNMYWJlbHM6IFtdLCB4YXhpc0xhYmVsc09mZnNldHg6IDAsIHhheGlzTGFiZWxzT2Zmc2V0eTogMCwgeGF4aXNMYWJlbHNDb3VudDogNSwgeGF4aXNTY2FsZTogdHJ1ZSwgeGF4aXNVbml0c1ByZTogJycsIHhheGlzVW5pdHNQb3N0OiAnJywgeGF4aXNTdHJpY3Q6IGZhbHNlLCB4YXhpc0RlY2ltYWxzOiAwLCB4YXhpc1BvaW50OiAnLicsIHhheGlzVGhvdXNhbmQ6ICcsJywgeGF4aXNSb3VuZDogZmFsc2UsIHhheGlzTWF4OiBudWxsLCB4YXhpc01pbjogMCwgeGF4aXNGb3JtYXR0ZXI6IG51bGwsIHhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ6IG51bGwsIHhheGlzVGV4dENvbG9yOiBudWxsLCB4YXhpc1RleHRCb2xkOiBudWxsLCB4YXhpc1RleHRJdGFsaWM6IG51bGwsIHhheGlzVGV4dEZvbnQ6IG51bGwsIHhheGlzVGV4dFNpemU6IG51bGwsIHlheGlzOiB0cnVlLCB5YXhpc1RpY2ttYXJrczogdHJ1ZSwgeWF4aXNUaWNrbWFya3NMZW5ndGg6IDMsIHlheGlzTGFiZWxzOiBbXSwgeWF4aXNMYWJlbHNQb3NpdGlvbjogJ3NlY3Rpb24nLCB5YXhpc0xhYmVsc09mZnNldHg6IDAsIHlheGlzTGFiZWxzT2Zmc2V0eTogMCwgeWF4aXNTY2FsZTogZmFsc2UsIHlheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ6IG51bGwsIHlheGlzQ29sb3I6ICdibGFjaycsIHlheGlzVGV4dEZvbnQ6IG51bGwsIHlheGlzVGV4dFNpemU6IG51bGwsIHlheGlzVGV4dENvbG9yOiBudWxsLCB5YXhpc1RleHRCb2xkOiBudWxsLCB5YXhpc1RleHRJdGFsaWM6IG51bGwsIHRleHRDb2xvcjogJ2JsYWNrJywgdGV4dEZvbnQ6ICdzYW5zLXNlcmlmJywgdGV4dFNpemU6IDEyLCB0ZXh0Qm9sZDogZmFsc2UsIHRleHRJdGFsaWM6IGZhbHNlLCBsYWJlbHNBYm92ZTogZmFsc2UsIGxhYmVsc0Fib3ZlRm9udDogbnVsbCwgbGFiZWxzQWJvdmVTaXplOiBudWxsLCBsYWJlbHNBYm92ZUJvbGQ6IG51bGwsIGxhYmVsc0Fib3ZlSXRhbGljOiBudWxsLCBsYWJlbHNBYm92ZUNvbG9yOiBudWxsLCBsYWJlbHNBYm92ZUJhY2tncm91bmQ6IG51bGwsIGxhYmVsc0Fib3ZlQmFja2dyb3VuZFBhZGRpbmc6IDAsIGxhYmVsc0Fib3ZlVW5pdHNQcmU6IG51bGwsIGxhYmVsc0Fib3ZlVW5pdHNQb3N0OiBudWxsLCBsYWJlbHNBYm92ZVBvaW50OiBudWxsLCBsYWJlbHNBYm92ZVRob3VzYW5kOiBudWxsLCBsYWJlbHNBYm92ZUZvcm1hdHRlcjogbnVsbCwgbGFiZWxzQWJvdmVEZWNpbWFsczogbnVsbCwgbGFiZWxzQWJvdmVPZmZzZXR4OiAwLCBsYWJlbHNBYm92ZU9mZnNldHk6IDAsIGxhYmVsc0Fib3ZlSGFsaWduOiAnbGVmdCcsIGxhYmVsc0Fib3ZlVmFsaWduOiAnY2VudGVyJywgbGFiZWxzQWJvdmVTcGVjaWZpYzogbnVsbCwgbGluZXdpZHRoOiAxLCBncm91cGluZzogJ2dyb3VwZWQnLCB0b29sdGlwczogbnVsbCwgdG9vbHRpcHNPdmVycmlkZTogbnVsbCwgdG9vbHRpcHNFZmZlY3Q6ICdmYWRlJywgdG9vbHRpcHNDc3NDbGFzczogJ1JHcmFwaF90b29sdGlwJywgdG9vbHRpcHNFdmVudDogJ2NsaWNrJywgaGlnaGxpZ2h0U3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCBoaWdobGlnaHRMaW5ld2lkdGg6IDEsIHRpdGxlOiAnJywgdGl0bGVTaXplOiAxNiwgdGl0bGVYOiBudWxsLCB0aXRsZVk6IG51bGwsIHRpdGxlSGFsaWduOiAnY2VudGVyJywgdGl0bGVWYWxpZ246IG51bGwsIHRpdGxlQ29sb3I6ICdibGFjaycsIHRpdGxlRm9udDogbnVsbCwgdGl0bGVCb2xkOiBmYWxzZSwgdGl0bGVJdGFsaWM6IGZhbHNlLCB0aXRsZVN1YnRpdGxlOiAnJywgdGl0bGVTdWJ0aXRsZVg6IG51bGwsIHRpdGxlU3VidGl0bGVZOiBudWxsLCB0aXRsZVN1YnRpdGxlSGFsaWduOiAnY2VudGVyJywgdGl0bGVTdWJ0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVTdWJ0aXRsZUNvbG9yOiAnI2FhYScsIHRpdGxlU3VidGl0bGVTaXplOiAxMCwgdGl0bGVTdWJ0aXRsZUZvbnQ6IG51bGwsIHRpdGxlU3VidGl0bGVCb2xkOiBmYWxzZSwgdGl0bGVTdWJ0aXRsZUl0YWxpYzogZmFsc2UsIHNoYWRvdzogZmFsc2UsIHNoYWRvd09mZnNldHg6IDIsIHNoYWRvd09mZnNldHk6IDIsIHNoYWRvd0JsdXI6IDIsIHNoYWRvd09wYWNpdHk6IDAuMjUsIGtleTogbnVsbCwga2V5Q29sb3JzOiBudWxsLCBrZXlPZmZzZXR4OiAwLCBrZXlPZmZzZXR5OiAwLCBrZXlUZXh0T2Zmc2V0eDogMCwga2V5VGV4dE9mZnNldHk6IC0xLCBrZXlUZXh0U2l6ZTogbnVsbCwga2V5VGV4dEJvbGQ6IG51bGwsIGtleVRleHRJdGFsaWM6IG51bGwsIGF0dHJpYnV0aW9uOiB0cnVlLCBhdHRyaWJ1dGlvblg6IG51bGwsIGF0dHJpYnV0aW9uWTogbnVsbCwgYXR0cmlidXRpb25IcmVmOiBudWxsLCBhdHRyaWJ1dGlvbkhhbGlnbjogJ3JpZ2h0JywgYXR0cmlidXRpb25WYWxpZ246ICdib3R0b20nLCBhdHRyaWJ1dGlvblNpemU6IDcsIGF0dHJpYnV0aW9uQ29sb3I6ICdncmF5JywgYXR0cmlidXRpb25Gb250OiAnc2Fucy1zZXJpZicsIGF0dHJpYnV0aW9uSXRhbGljOiBmYWxzZSwgYXR0cmlidXRpb25Cb2xkOiBmYWxzZSB9O2lmIChSRy5TVkcuRlggJiYgdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUkcuU1ZHLkZYLmRlY29yYXRlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllczt0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtSRy5TVkcuY3JlYXRlRGVmcyh0aGlzKTtpZiAocHJvcC5ndXR0ZXJMZWZ0QXV0b3NpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3AueWF4aXNMYWJlbHMubGVuZ3RoLCBtYXhMZW5ndGggPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2l6ZXMgPSBSRy5TVkcubWVhc3VyZVRleHQoeyB0ZXh0OiBwcm9wLnlheGlzTGFiZWxzW2ldLCBib2xkOiBwcm9wLnlheGlzVGV4dEJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgc2l6ZTogcHJvcC55YXhpc1RleHRTaXplIHx8IHByb3AudGV4dFNpemUsIGZvbnQ6IHByb3AueWF4aXNUZXh0Rm9udCB8fCBwcm9wLnRleHRGb250IH0pO21heExlbmd0aCA9IG1hLm1heChtYXhMZW5ndGgsIHNpemVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wLmd1dHRlckxlZnQgPSBtYXhMZW5ndGggKyAxNTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7IG9iamVjdDogdGhpcyB9KTt0aGlzLnBhcnNlQ29sb3JzKCk7dmFyIHZhbHVlcyA9IFtdO2ZvciAodmFyIGkgPSAwLCBtYXggPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZGF0YVtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlNYXgodGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtYXggPSBSRy5TVkcuYXJyYXlNYXgodmFsdWVzKTtpZiAodHlwZW9mIHByb3AueGF4aXNNYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heCA9IHByb3AueGF4aXNNYXg7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC54YXhpc01pbiA9PT0gJ21pcnJvcicgfHwgcHJvcC54YXhpc01pbiA9PT0gJ21pZGRsZScgfHwgcHJvcC54YXhpc01pbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIG1pcnJvclNjYWxlID0gdHJ1ZTtwcm9wLnhheGlzTWluID0gcHJvcC54YXhpc01heCAqIC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2FsZSA9IFJHLlNWRy5nZXRTY2FsZSh7IG9iamVjdDogdGhpcywgbnVtbGFiZWxzOiBwcm9wLnhheGlzTGFiZWxzQ291bnQsIHVuaXRzUHJlOiBwcm9wLnhheGlzVW5pdHNQcmUsIHVuaXRzUG9zdDogcHJvcC54YXhpc1VuaXRzUG9zdCwgbWF4OiBtYXgsIG1pbjogcHJvcC54YXhpc01pbiwgcG9pbnQ6IHByb3AueGF4aXNQb2ludCwgcm91bmQ6IHByb3AueGF4aXNSb3VuZCwgdGhvdXNhbmQ6IHByb3AueGF4aXNUaG91c2FuZCwgZGVjaW1hbHM6IHByb3AueGF4aXNEZWNpbWFscywgc3RyaWN0OiB0eXBlb2YgcHJvcC54YXhpc01heCA9PT0gJ251bWJlcicsIGZvcm1hdHRlcjogcHJvcC54YXhpc0Zvcm1hdHRlciB9KTtpZiAobWlycm9yU2NhbGUpIHtcbiAgICAgICAgdGhpcy5zY2FsZSA9IFJHLlNWRy5nZXRTY2FsZSh7IG9iamVjdDogdGhpcywgbnVtbGFiZWxzOiBwcm9wLnhheGlzTGFiZWxzQ291bnQsIHVuaXRzUHJlOiBwcm9wLnhheGlzVW5pdHNQcmUsIHVuaXRzUG9zdDogcHJvcC54YXhpc1VuaXRzUG9zdCwgbWF4OiB0aGlzLnNjYWxlLm1heCwgbWluOiB0aGlzLnNjYWxlLm1heCAqIC0xLCBwb2ludDogcHJvcC54YXhpc1BvaW50LCByb3VuZDogZmFsc2UsIHRob3VzYW5kOiBwcm9wLnhheGlzVGhvdXNhbmQsIGRlY2ltYWxzOiBwcm9wLnhheGlzRGVjaW1hbHMsIHN0cmljdDogdHlwZW9mIHByb3AueGF4aXNNYXggPT09ICdudW1iZXInLCBmb3JtYXR0ZXI6IHByb3AueGF4aXNGb3JtYXR0ZXIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1heCA9IHRoaXMuc2NhbGUubWF4O3Byb3AueGF4aXNNYXggPSB0aGlzLnNjYWxlLm1heDt0aGlzLm1pbiA9IHRoaXMuc2NhbGUubWluO3Byb3AueGF4aXNNaW4gPSB0aGlzLnNjYWxlLm1pbjtSRy5TVkcuZHJhd0JhY2tncm91bmQodGhpcyk7dGhpcy5kcmF3QmFycygpO1JHLlNWRy5kcmF3WEF4aXModGhpcyk7UkcuU1ZHLmRyYXdZQXhpcyh0aGlzKTt0aGlzLmRyYXdMYWJlbHNBYm92ZSgpO2lmICh0eXBlb2YgcHJvcC5rZXkgIT09IG51bGwgJiYgUkcuU1ZHLmRyYXdLZXkpIHtcbiAgICAgICAgUkcuU1ZHLmRyYXdLZXkodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFSR3JhcGguU1ZHLmlzTnVsbChwcm9wLmtleSkpIHtcbiAgICAgICAgYWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7XG4gICAgICB9XG4gICAgICBSRy5TVkcuYXR0cmlidXRpb24odGhpcyk7dmFyIG9iaiA9IHRoaXM7ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBSRy5TVkcucmVtb3ZlSGlnaGxpZ2h0KG9iaik7XG4gICAgICB9LCBmYWxzZSk7UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmRyYXdCYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb3Auc2hhZG93KSB7XG4gICAgICAgIFJHLlNWRy5zZXRTaGFkb3coeyBvYmplY3Q6IHRoaXMsIG9mZnNldHg6IHByb3Auc2hhZG93T2Zmc2V0eCwgb2Zmc2V0eTogcHJvcC5zaGFkb3dPZmZzZXR5LCBibHVyOiBwcm9wLnNoYWRvd0JsdXIsIG9wYWNpdHk6IHByb3Auc2hhZG93T3BhY2l0eSwgaWQ6ICdkcm9wU2hhZG93JyB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBzZXF1ZW50aWFsSW5kZXggPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpLCArK3NlcXVlbnRpYWxJbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgb3V0ZXJTZWdtZW50ID0gKHRoaXMuZ3JhcGhIZWlnaHQgLSBwcm9wLnZtYXJnaW5Ub3AgLSBwcm9wLnZtYXJnaW5Cb3R0b20pIC8gdGhpcy5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldFdpZHRoKHRoaXMuZGF0YVtpXSksXG4gICAgICAgICAgICAgIGhlaWdodCA9ICh0aGlzLmdyYXBoSGVpZ2h0IC0gcHJvcC52bWFyZ2luVG9wIC0gcHJvcC52bWFyZ2luQm90dG9tKSAvIHRoaXMuZGF0YS5sZW5ndGggLSBwcm9wLnZtYXJnaW4gLSBwcm9wLnZtYXJnaW4sXG4gICAgICAgICAgICAgIHggPSB0aGlzLmdldFhDb29yZCh0aGlzLnNjYWxlLm1pbiA8IDAgJiYgdGhpcy5zY2FsZS5tYXggPCAwIHx8IHRoaXMuc2NhbGUubWluID4gMCAmJiB0aGlzLnNjYWxlLm1heCA+IDAgPyB0aGlzLnNjYWxlLm1pbiA6IDApIC0gKHRoaXMuZGF0YVtpXSA8IDAgPyB3aWR0aCA6IDApLFxuICAgICAgICAgICAgICB5ID0gcHJvcC5ndXR0ZXJUb3AgKyBwcm9wLnZtYXJnaW5Ub3AgKyBwcm9wLnZtYXJnaW4gKyBvdXRlclNlZ21lbnQgKiBpO2lmICh0aGlzLnNjYWxlLm1pbiA8IDAgJiYgdGhpcy5zY2FsZS5tYXggPCAwKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyUmlnaHQgLSB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlY3QgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdyZWN0JywgYXR0cjogeyBzdHJva2U6IHByb3Auc3Ryb2tlc3R5bGUsIGZpbGw6IHByb3AuY29sb3JzU2VxdWVudGlhbCA/IHByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0gPyBwcm9wLmNvbG9yc1tzZXF1ZW50aWFsSW5kZXhdIDogcHJvcC5jb2xvcnNbcHJvcC5jb2xvcnMubGVuZ3RoIC0gMV0gOiBwcm9wLmNvbG9yc1swXSwgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLCAnZGF0YS10b29sdGlwJzogIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPyBwcm9wLnRvb2x0aXBzW2ldIDogJycsICdkYXRhLWluZGV4JzogaSwgJ2RhdGEtb3JpZ2luYWwtd2lkdGgnOiB3aWR0aCwgJ2RhdGEtb3JpZ2luYWwtaGVpZ2h0JzogaGVpZ2h0LCAnZGF0YS1zZXF1ZW50aWFsLWluZGV4Jzogc2VxdWVudGlhbEluZGV4LCAnZGF0YS12YWx1ZSc6IHRoaXMuZGF0YVtpXSwgZmlsdGVyOiBwcm9wLnNoYWRvdyA/ICd1cmwoI2Ryb3BTaGFkb3cpJyA6ICcnIH0gfSk7dGhpcy5jb29yZHMucHVzaCh7IG9iamVjdDogcmVjdCwgeDogeCwgeTogeSAtICh0aGlzLmRhdGFbaV0gPiAwID8gaGVpZ2h0IDogMCksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7aWYgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXM7KGZ1bmN0aW9uIChpZHgsIHNlcSkge1xuICAgICAgICAgICAgICByZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sICcnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7UkcuU1ZHLnRvb2x0aXAoeyBvYmplY3Q6IG9iaiwgaW5kZXg6IGlkeCwgZ3JvdXA6IG51bGwsIHNlcXVlbnRpYWxJbmRleDogc2VxLCB0ZXh0OiBwcm9wLnRvb2x0aXBzW3NlcV0sIGV2ZW50OiBlIH0pO29iai5oaWdobGlnaHQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICB9LCBmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSkoaSwgc2VxdWVudGlhbEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2ldKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICB2YXIgb3V0ZXJTZWdtZW50ID0gKHRoaXMuZ3JhcGhIZWlnaHQgLSBwcm9wLnZtYXJnaW5Ub3AgLSBwcm9wLnZtYXJnaW5Cb3R0b20pIC8gdGhpcy5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgaW5uZXJTZWdtZW50ID0gb3V0ZXJTZWdtZW50IC0gMiAqIHByb3Audm1hcmdpbjtmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraiwgKytzZXF1ZW50aWFsSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IG1hLmFicyh0aGlzLmRhdGFbaV1bal0gLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiB0aGlzLmdyYXBoV2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IChpbm5lclNlZ21lbnQgLSAodGhpcy5kYXRhW2ldLmxlbmd0aCAtIDEpICogcHJvcC52bWFyZ2luR3JvdXBlZCkgLyB0aGlzLmRhdGFbaV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHkgPSBwcm9wLmd1dHRlclRvcCArIHByb3Audm1hcmdpbiArIHByb3Audm1hcmdpblRvcCArIG91dGVyU2VnbWVudCAqIGkgKyBqICogaGVpZ2h0ICsgaiAqIHByb3Audm1hcmdpbkdyb3VwZWQsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0WENvb3JkKDApIC0gKHRoaXMuZGF0YVtpXVtqXSA8IDAgPyB3aWR0aCA6IDApO2lmICh0aGlzLnNjYWxlLm1heCA8IDAgJiYgdGhpcy5zY2FsZS5taW4gPCB0aGlzLnNjYWxlLm1heCkge1xuICAgICAgICAgICAgICB2YXIgeDEgPSB0aGlzLmdldFhDb29yZCh0aGlzLmRhdGFbaV1bal0pO3ZhciB4MiA9IHRoaXMuZ2V0WENvb3JkKHRoaXMuc2NhbGUubWF4KTt4ID0geDE7d2lkdGggPSB4MiAtIHgxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjYWxlLm1pbiA+IDAgJiYgdGhpcy5zY2FsZS5tYXggPiB0aGlzLnNjYWxlLm1pbikge1xuICAgICAgICAgICAgICB2YXIgeDEgPSB0aGlzLmdldFhDb29yZCh0aGlzLmRhdGFbaV1bal0pO3ZhciB4MiA9IHRoaXMuZ2V0WENvb3JkKHRoaXMuc2NhbGUubWluKTt4ID0gdGhpcy5nZXRYQ29vcmQodGhpcy5zY2FsZS5taW4pO3dpZHRoID0geDEgLSB4MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWN0ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdyZWN0JywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgc3Ryb2tlOiBwcm9wWydzdHJva2VzdHlsZSddLCBmaWxsOiBwcm9wLmNvbG9yc1NlcXVlbnRpYWwgJiYgcHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XSA/IHByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0gOiBwcm9wLmNvbG9yc1tqXSA/IHByb3AuY29sb3JzW2pdIDogcHJvcC5jb2xvcnNbcHJvcC5jb2xvcnMubGVuZ3RoIC0gMV0sIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCwgJ2RhdGEtaW5kZXgnOiBpLCAnZGF0YS1vcmlnaW5hbC13aWR0aCc6IHdpZHRoLCAnZGF0YS1zZXF1ZW50aWFsLWluZGV4Jzogc2VxdWVudGlhbEluZGV4LCAnZGF0YS10b29sdGlwJzogIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPyBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0gOiAnJywgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV1bal0sIGZpbHRlcjogcHJvcC5zaGFkb3cgPyAndXJsKCNkcm9wU2hhZG93KScgOiAnJyB9IH0pO3RoaXMuY29vcmRzLnB1c2goeyBvYmplY3Q6IHJlY3QsIHg6IHgsIHk6IHkgLSAodGhpcy5kYXRhW2ldW2pdID4gMCA/IGhlaWdodCA6IDApLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO2lmICghUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pIHtcbiAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXM7KGZ1bmN0aW9uIChpZHgsIHNlcSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gUkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsIG9iai5kYXRhKTtyZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sICcnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVIaWdobGlnaHQoKTtSRy5TVkcudG9vbHRpcCh7IG9iamVjdDogb2JqLCBncm91cDogaWR4LCBpbmRleDogaW5kZXhlc1sxXSwgc2VxdWVudGlhbEluZGV4OiBzZXEsIHRleHQ6IHByb3AudG9vbHRpcHNbc2VxXSwgZXZlbnQ6IGUgfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0pKGksIHNlcXVlbnRpYWxJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC0tc2VxdWVudGlhbEluZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgcHJvcC5ncm91cGluZyA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICAgICAgdmFyIHNlY3Rpb24gPSAodGhpcy5ncmFwaEhlaWdodCAtIHByb3Audm1hcmdpblRvcCAtIHByb3Audm1hcmdpbkJvdHRvbSkgLyB0aGlzLmRhdGEubGVuZ3RoO3ZhciB4ID0gdGhpcy5nZXRYQ29vcmQoMCk7Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2osICsrc2VxdWVudGlhbEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJIZWlnaHQgPSAodGhpcy5ncmFwaEhlaWdodCAtIHByb3Audm1hcmdpblRvcCAtIHByb3Audm1hcmdpbkJvdHRvbSkgLyB0aGlzLmRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gbWEuYWJzKHRoaXMuZGF0YVtpXVtqXSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIHRoaXMuZ3JhcGhXaWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gb3V0ZXJIZWlnaHQgLSAyICogcHJvcC52bWFyZ2luLFxuICAgICAgICAgICAgICAgIHkgPSBwcm9wLmd1dHRlclRvcCArIHByb3Audm1hcmdpbiArIHByb3Audm1hcmdpblRvcCArIG91dGVySGVpZ2h0ICogaTtpZiAoaiA9PT0gMCAmJiBwcm9wLnNoYWRvdykge1xuICAgICAgICAgICAgICB2YXIgZnVsbFdpZHRoID0gbWEuYWJzKFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGFbaV0pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogdGhpcy5ncmFwaFdpZHRoKTt2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3JlY3QnLCBhdHRyOiB7IHg6IHgsIHk6IHksIHdpZHRoOiBmdWxsV2lkdGgsIGhlaWdodDogaGVpZ2h0LCBmaWxsOiAnd2hpdGUnLCAnc3Ryb2tlLXdpZHRoJzogMCwgJ2RhdGEtaW5kZXgnOiBpLCBmaWx0ZXI6ICd1cmwoI2Ryb3BTaGFkb3cpJyB9IH0pO3RoaXMuc3RhY2tlZEJhY2tmYWNlc1tpXSA9IHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncmVjdCcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IHN0cm9rZTogcHJvcFsnc3Ryb2tlc3R5bGUnXSwgZmlsbDogcHJvcC5jb2xvcnNTZXF1ZW50aWFsID8gcHJvcC5jb2xvcnNbc2VxdWVudGlhbEluZGV4XSA/IHByb3AuY29sb3JzW3NlcXVlbnRpYWxJbmRleF0gOiBwcm9wLmNvbG9yc1twcm9wLmNvbG9ycy5sZW5ndGggLSAxXSA6IHByb3AuY29sb3JzW2pdID8gcHJvcC5jb2xvcnNbal0gOiBwcm9wLmNvbG9yc1twcm9wLmNvbG9ycy5sZW5ndGggLSAxXSwgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLCAnZGF0YS1vcmlnaW5hbC13aWR0aCc6IHdpZHRoLCAnZGF0YS1vcmlnaW5hbC1oZWlnaHQnOiBoZWlnaHQsICdkYXRhLW9yaWdpbmFsLXgnOiB4LCAnZGF0YS1vcmlnaW5hbC15JzogeSwgJ2RhdGEtaW5kZXgnOiBpLCAnZGF0YS1zZXF1ZW50aWFsLWluZGV4Jzogc2VxdWVudGlhbEluZGV4LCAnZGF0YS10b29sdGlwJzogIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPyBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0gOiAnJywgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV1bal0gfSB9KTt0aGlzLmNvb3Jkcy5wdXNoKHsgb2JqZWN0OiByZWN0LCB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO2lmICghUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF0pIHtcbiAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXM7KGZ1bmN0aW9uIChpZHgsIHNlcSkge1xuICAgICAgICAgICAgICAgIHJlY3QuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQucmVwbGFjZSgvXm9uLywgJycpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO3ZhciBpbmRleGVzID0gUkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsIG9iai5kYXRhKTtSRy5TVkcudG9vbHRpcCh7IG9iamVjdDogb2JqLCBpbmRleDogaW5kZXhlc1sxXSwgZ3JvdXA6IGlkeCwgc2VxdWVudGlhbEluZGV4OiBzZXEsIHRleHQ6IHByb3AudG9vbHRpcHNbc2VxXSwgZXZlbnQ6IGUgfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO3JlY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0pKGksIHNlcXVlbnRpYWxJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICs9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAtLXNlcXVlbnRpYWxJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5nZXRYQ29vcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO2lmICh2YWx1ZSA+IHRoaXMuc2NhbGUubWF4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHg7aWYgKHZhbHVlIDwgdGhpcy5zY2FsZS5taW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB4ID0gKHZhbHVlIC0gdGhpcy5zY2FsZS5taW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gdGhpcy5zY2FsZS5taW4pO3ggKj0gdGhpcy5ncmFwaFdpZHRoO3ggKz0gcHJvcC5ndXR0ZXJMZWZ0O3JldHVybiB4O1xuICAgIH07dGhpcy5nZXRXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuc2NhbGUubWF4IDw9IDAgJiYgdGhpcy5zY2FsZS5taW4gPCB0aGlzLnNjYWxlLm1heCkge1xuICAgICAgICB2YXIgeDEgPSB0aGlzLmdldFhDb29yZCh0aGlzLnNjYWxlLm1heCk7dmFyIHgyID0gdGhpcy5nZXRYQ29vcmQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNjYWxlLm1pbiA+IDAgJiYgdGhpcy5zY2FsZS5tYXggPiB0aGlzLnNjYWxlLm1pbikge1xuICAgICAgICB2YXIgeDEgPSB0aGlzLmdldFhDb29yZCh0aGlzLnNjYWxlLm1pbik7dmFyIHgyID0gdGhpcy5nZXRYQ29vcmQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHgxID0gdGhpcy5nZXRYQ29vcmQoMCk7dmFyIHgyID0gdGhpcy5nZXRYQ29vcmQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hLmFicyh4MSAtIHgyKTtcbiAgICB9O3RoaXMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHZhciB4ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgICAgICB5ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3knKSxcbiAgICAgICAgICB3aWR0aCA9IHJlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodCA9IHJlY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTt2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdyZWN0JywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgc3Ryb2tlOiBwcm9wLmhpZ2hsaWdodFN0cm9rZSwgZmlsbDogcHJvcC5oaWdobGlnaHRGaWxsLCB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5oaWdobGlnaHRMaW5ld2lkdGggfSB9KTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0KTtcbiAgICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ29sb3JzID0geyBjb2xvcnM6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuY29sb3JzKSwgYmFja2dyb3VuZEdyaWRDb2xvcjogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yKSwgaGlnaGxpZ2h0RmlsbDogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKSwgYmFja2dyb3VuZENvbG9yOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmJhY2tncm91bmRDb2xvcikgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvcnMgPSBwcm9wLmNvbG9ycztpZiAoY29sb3JzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29sb3JzW2ldID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBjb2xvcnNbaV0sIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLCBzdGFydDogcHJvcC5ndXR0ZXJMZWZ0LCBlbmQ6IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciwgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsIHN0YXJ0OiBwcm9wLmd1dHRlckxlZnQsIGVuZDogdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyUmlnaHQgfSk7cHJvcC5oaWdobGlnaHRGaWxsID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGwsIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLCBzdGFydDogcHJvcC5ndXR0ZXJMZWZ0LCBlbmQ6IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0IH0pO3Byb3AuYmFja2dyb3VuZENvbG9yID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmJhY2tncm91bmRDb2xvciB9KTtcbiAgICB9O3RoaXMuZHJhd0xhYmVsc0Fib3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb3AubGFiZWxzQWJvdmUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBSRy5TVkcuYXJyYXlMaW5lYXJpemUodGhpcy5kYXRhKTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29vcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtpXS50b0ZpeGVkKHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHMgPT09ICdudW1iZXInID8gcHJvcC5sYWJlbHNBYm92ZURlY2ltYWxzIDogcHJvcC54YXhpc0RlY2ltYWxzKTt2YXIgaW5kZXhlcyA9IFJHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQoaSwgdGhpcy5kYXRhKTtpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhW2luZGV4ZXNbMF1dKSAmJiBwcm9wLmdyb3VwaW5nID09PSAnc3RhY2tlZCcpIHtcbiAgICAgICAgICAgIGlmIChpbmRleGVzWzFdICsgMSA9PT0gdGhpcy5kYXRhW2luZGV4ZXNbMF1dLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGFbaW5kZXhlc1swXV0pO3ZhbHVlID0gdmFsdWUudG9GaXhlZCh0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZURlY2ltYWxzID09PSAnbnVtYmVyJyA/IHByb3AubGFiZWxzQWJvdmVEZWNpbWFscyA6IHByb3AueGF4aXNEZWNpbWFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ciA9IHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyA/IHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tpXS50b1N0cmluZygpIDogUkcuU1ZHLm51bWJlckZvcm1hdCh7IG9iamVjdDogdGhpcywgbnVtOiB2YWx1ZSwgcHJlcGVuZDogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1ByZSA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0Fib3ZlVW5pdHNQcmUgOiBudWxsLCBhcHBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlVW5pdHNQb3N0ID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVVbml0c1Bvc3QgOiBudWxsLCBwb2ludDogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVQb2ludCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0Fib3ZlUG9pbnQgOiBudWxsLCB0aG91c2FuZDogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVUaG91c2FuZCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0Fib3ZlVGhvdXNhbmQgOiBudWxsLCBmb3JtYXR0ZXI6IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nID8gcHJvcC5sYWJlbHNBYm92ZUZvcm1hdHRlciA6IG51bGwgfSk7dmFyIGJvbGQgPSB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZUJvbGQgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzQWJvdmVCb2xkIDogcHJvcC50ZXh0Qm9sZCxcbiAgICAgICAgICAgICAgaXRhbGljID0gdHlwZW9mIHByb3AubGFiZWxzQWJvdmVJdGFsaWMgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzQWJvdmVJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsXG4gICAgICAgICAgICAgIHNpemUgPSBwcm9wLmxhYmVsc0Fib3ZlU2l6ZSB8fCBwcm9wLnRleHRTaXplLFxuICAgICAgICAgICAgICBmb250ID0gcHJvcC5sYWJlbHNBYm92ZUZvbnQgfHwgcHJvcC50ZXh0Rm9udCxcbiAgICAgICAgICAgICAgaGFsaWduID0gcHJvcC5sYWJlbHNBYm92ZUhhbGlnbixcbiAgICAgICAgICAgICAgdmFsaWduID0gcHJvcC5sYWJlbHNBYm92ZVZhbGlnbjt2YXIgZGltZW5zaW9ucyA9IFJHLlNWRy5tZWFzdXJlVGV4dCh7IHRleHQ6IHN0ciwgYm9sZDogYm9sZCwgZm9udDogZm9udCwgc2l6ZTogc2l6ZSB9KTt2YXIgeCA9IHZhbHVlID49IDAgPyBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSkgKyBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpICsgNyArIHByb3AubGFiZWxzQWJvdmVPZmZzZXR4IDogcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd4JykgLSA3IC0gcHJvcC5sYWJlbHNBYm92ZU9mZnNldHgpLFxuICAgICAgICAgICAgICB5ID0gcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpICsgcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAvIDIpICsgcHJvcC5sYWJlbHNBYm92ZU9mZnNldHksXG4gICAgICAgICAgICAgIHdpZHRoID0gZGltZW5zaW9uc1swXSxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9uc1sxXSxcbiAgICAgICAgICAgICAgaGFsaWduID0gdmFsdWUgPj0gMCA/ICdsZWZ0JyA6ICdyaWdodCc7aWYgKHggKyB3aWR0aCA+IHRoaXMud2lkdGggJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBoYWxpZ24gPSAncmlnaHQnO3ggPSB0aGlzLndpZHRoIC0gNTtwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZCA9IHByb3AubGFiZWxzQWJvdmVCYWNrZ3JvdW5kIHx8ICdyZ2JhKDI1NSwyNTUsMjU1LDAuOTUpJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRleHQgPSBSRy5TVkcudGV4dCh7IG9iamVjdDogdGhpcywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHRleHQ6IHN0ciwgeDogeCwgeTogeSwgaGFsaWduOiBoYWxpZ24sIHZhbGlnbjogdmFsaWduLCBmb250OiBmb250LCBzaXplOiBzaXplLCBib2xkOiBib2xkLCBpdGFsaWM6IGl0YWxpYywgY29sb3I6IHByb3AubGFiZWxzQWJvdmVDb2xvciB8fCBwcm9wLnRleHRDb2xvciwgYmFja2dyb3VuZDogcHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmQgfHwgbnVsbCwgcGFkZGluZzogcHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nIHx8IDAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYgKGhpZ2hsaWdodCAmJiBoaWdobGlnaHQucGFyZW50Tm9kZSkge1xuICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIG51bGwpO1xuICAgIH07dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgICBvYmogPSB0aGlzLFxuICAgICAgICAgIGRhdGEgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSBudWxsLFxuICAgICAgICAgIHNlcSA9IDA7ZGF0YSA9IFJHLlNWRy5hcnJheUNsb25lKHRoaXMuZGF0YSk7dGhpcy5kcmF3KCk7dmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiBpdGVyYXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgc2VxID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47ICsraSwgKytzZXEpIHtcbiAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGZyYW1lIC8gZnJhbWVzICogUkcuU1ZHLkZYLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLCBmcmFtZSkgKiBSRy5TVkcuRlguZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKTtpZiAodHlwZW9mIGRhdGFbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG1hLmFicyhvYmouZ2V0WENvb3JkKGRhdGFbaV0pIC0gb2JqLmdldFhDb29yZCgwKSk7b2JqLmRhdGFbaV0gPSBkYXRhW2ldICogbXVsdGlwbGllcjt3aWR0aCA9IG11bHRpcGxpZXIgKiB3aWR0aDtvYmouY29vcmRzW3NlcV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7b2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCBkYXRhW2ldID4gMCA/IG9iai5nZXRYQ29vcmQoMCkgOiBvYmouZ2V0WENvb3JkKDApIC0gd2lkdGgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkYXRhW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRpdmVXaWR0aCA9IDA7Zm9yICh2YXIgaiA9IDAsIGxlbjIgPSBkYXRhW2ldLmxlbmd0aDsgaiA8IGxlbjI7ICsraiwgKytzZXEpIHtcbiAgICAgICAgICAgICAgd2lkdGggPSBtYS5hYnMob2JqLmdldFhDb29yZChkYXRhW2ldW2pdKSAtIG9iai5nZXRYQ29vcmQoMCkpO3dpZHRoID0gbXVsdGlwbGllciAqIHdpZHRoO29iai5kYXRhW2ldW2pdID0gZGF0YVtpXVtqXSAqIG11bHRpcGxpZXI7b2JqLmNvb3Jkc1tzZXFdLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO29iai5jb29yZHNbc2VxXS5vYmplY3Quc2V0QXR0cmlidXRlKCd4JywgZGF0YVtpXVtqXSA+IDAgPyBvYmouZ2V0WENvb3JkKDApICsgYWNjdW11bGF0aXZlV2lkdGggOiBvYmouZ2V0WENvb3JkKDApIC0gd2lkdGggLSBhY2N1bXVsYXRpdmVXaWR0aCk7YWNjdW11bGF0aXZlV2lkdGggKz0gcHJvcC5ncm91cGluZyA9PT0gJ3N0YWNrZWQnID8gd2lkdGggOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5zdGFja2VkQmFja2ZhY2VzW2ldKSB7XG4gICAgICAgICAgICAgIG9iai5zdGFja2VkQmFja2ZhY2VzW2ldLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhY2N1bXVsYXRpdmVXaWR0aCk7b2JqLnN0YWNrZWRCYWNrZmFjZXNbaV0uc2V0QXR0cmlidXRlKCd4JywgcHJvcC5ndXR0ZXJMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC0tc2VxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWUrKyA8IGZyYW1lcykge1xuICAgICAgICAgIFJHLlNWRy5GWC51cGRhdGUoaXRlcmF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LmNhbGxiYWNrKSB7XG4gICAgICAgICAgb3B0LmNhbGxiYWNrKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH07aXRlcmF0ZSgpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy53YXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kcmF3KCk7dmFyIG9iaiA9IHRoaXMsXG4gICAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O29wdC5mcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDYwO29wdC5zdGFydEZyYW1lcyA9IFtdO29wdC5jb3VudGVycyA9IFtdO3ZhciBmcmFtZXNwZXJiYXIgPSBvcHQuZnJhbWVzIC8gMyxcbiAgICAgICAgICBmcmFtZSA9IC0xLFxuICAgICAgICAgIGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgIHdpZHRoO2ZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBvcHQuc3RhcnRGcmFtZXNbaV0gPSBvcHQuZnJhbWVzIC8gMiAvIChvYmouY29vcmRzLmxlbmd0aCAtIDEpICogaTtvcHQuY291bnRlcnNbaV0gPSAwO3RoaXMuY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgKytmcmFtZTtmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChmcmFtZSA+IG9wdC5zdGFydEZyYW1lc1tpXSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSBvYmouY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtd2lkdGgnKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQob2JqLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykpO29iai5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCA9IG1hLm1pbigoZnJhbWUgLSBvcHQuc3RhcnRGcmFtZXNbaV0pIC8gZnJhbWVzcGVyYmFyICogb3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxXaWR0aCkpO29iai5jb29yZHNbaV0ub2JqZWN0LnNldEF0dHJpYnV0ZSgneCcsIHZhbHVlID49IDAgPyBvYmouZ2V0WENvb3JkKDApIDogb2JqLmdldFhDb29yZCgwKSAtIHdpZHRoKTtpZiAocHJvcC5ncm91cGluZyA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICAgICAgICAgIHZhciBzZXEgPSBvYmouY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VxdWVudGlhbC1pbmRleCcpO3ZhciBpbmRleGVzID0gUkcuU1ZHLnNlcXVlbnRpYWxJbmRleFRvR3JvdXBlZChzZXEsIG9iai5kYXRhKTtpZiAoaW5kZXhlc1sxXSA+IDApIHtcbiAgICAgICAgICAgICAgICBvYmouY29vcmRzW2ldLm9iamVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCBwYXJzZUludChvYmouY29vcmRzW2kgLSAxXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd4JykpICsgcGFyc2VJbnQob2JqLmNvb3Jkc1tpIC0gMV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFtZSA+PSBvcHQuZnJhbWVzKSB7XG4gICAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSRy5TVkcuRlgudXBkYXRlKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgICB9O2ZvciAoaSBpbiBjb25mLm9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgY29uZi5vcHRpb25zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07cmV0dXJuIHRoaXM7XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLmhiYXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///212\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Line = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));if (RG.SVG.isArray(conf.data) && RG.SVG.isArray(conf.data[0])) {\n      this.data = RG.SVG.arrayClone(conf.data);\n    } else if (RG.SVG.isArray(conf.data)) {\n      this.data = [RG.SVG.arrayClone(conf.data)];\n    } else {\n      this.data = [[]];\n    }\n    this.type = 'line';this.coords = [];this.coords2 = [];this.coordsSpline = [];this.hasMultipleDatasets = _typeof(this.data[0]) === 'object' && _typeof(this.data[1]) === 'object' ? true : false;this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.originalData = RG.SVG.arrayClone(this.data);RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageStretch: true, backgroundImageAspect: 'none', backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['red', '#0f0', 'blue', '#ff0', '#0ff', 'green'], filled: false, filledColors: [], filledClick: null, filledOpacity: 1, filledAccumulative: false, hmargin: 0, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisLabelsPosition: 'edge', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarksStyle: 'none', tickmarksSize: 5, tickmarksFill: 'white', tickmarksLinewidth: 1, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.7)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: -10, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, spline: false, title: '', titleSize: null, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: null, titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.coords = [];this.coords2 = [];this.coordsSpline = [];this.data = RG.SVG.arrayClone(this.originalData);this.tooltipsSequentialIndex = 0;var values = [];for (var i = 0, max = 0; i < this.data.length; ++i) {\n        if (typeof this.data[i] === 'number') {\n          values.push(this.data[i]);\n        } else if (RG.SVG.isArray(this.data[i]) && (!prop.filled || !prop.filledAccumulative)) {\n          values.push(RG.SVG.arrayMax(this.data[i]));\n        } else if (RG.SVG.isArray(this.data[i]) && prop.filled && prop.filledAccumulative) {\n          for (var j = 0; j < this.data[i].length; ++j) {\n            values[j] = values[j] || 0;values[j] = values[j] + this.data[i][j];this.data[i][j] = values[j];\n          }\n        }\n      }\n      var max = RG.SVG.arrayMax(values);if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);for (var i = 0; i < this.data.length; ++i) {\n        this.drawLine(this.data[i], i);\n      }\n      this.redrawLines();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      this.drawLabelsAbove();RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawLine = function (data, index) {\n      var coords = [],\n          path = [];for (var i = 0, len = data.length; i < len; ++i) {\n        var val = data[i],\n            x = (this.graphWidth - prop.hmargin - prop.hmargin) / (len - 1) * i + prop.gutterLeft + prop.hmargin,\n            y = this.getYCoord(val);coords.push([x, y]);\n      }\n      for (var i = 0; i < coords.length; ++i) {\n        if (i === 0 || RG.SVG.isNull(data[i]) || RG.SVG.isNull(data[i - 1])) {\n          var action = 'M';\n        } else {\n          var action = 'L';\n        }\n        path.push(action + '{1} {2}'.format(coords[i][0], coords[i][1]));\n      }\n      this.coords[index] = RG.SVG.arrayClone(coords);this.coords2[index] = RG.SVG.arrayClone(coords);if (prop.spline) {\n        this.coordsSpline[index] = this.drawSpline(coords);\n      }\n      if (prop.filled === true || _typeof(prop.filled) === 'object' && prop.filled[index]) {\n        if (prop.spline) {\n          var fillPath = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n            fillPath.push('L{1} {2}'.format(this.coordsSpline[index][i][0] + (i === this.coordsSpline[index].length - 1 ? 1 : 0), this.coordsSpline[index][i][1]));\n          }\n        } else {\n          var fillPath = RG.SVG.arrayClone(path);\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][this.coords[index].length - 1][0] + 1, index > 0 && prop.filledAccumulative ? prop.spline ? this.coordsSpline[index - 1][this.coordsSpline[index - 1].length - 1][1] : this.coords[index - 1][this.coords[index - 1].length - 1][1] : this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));if (index > 0 && prop.filledAccumulative) {\n          var path2 = RG.SVG.arrayClone(path);if (index > 0 && prop.filledAccumulative) {\n            if (prop.spline) {\n              for (var i = this.coordsSpline[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]));\n              }\n            } else {\n              for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n                fillPath.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n              }\n            }\n          }\n        } else {\n          fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.getYCoord(prop.yaxisMin > 0 ? prop.yaxisMin : 0) + (prop.xaxis ? 0 : 1)));\n        }\n        fillPath.push('L{1} {2}'.format(this.coords[index][0][0] + (prop.yaxis ? 1 : 0), this.coords[index][0][1]));for (var i = 0; i < this.data[index].length; ++i) {\n          if (!RG.SVG.isNull(this.data[index][i])) {\n            fillPath.push('L{1} {2}'.format(this.coords[index][i][0], this.getYCoord(0)));break;\n          }\n        }\n        var fillPathObject = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: fillPath.join(' '), stroke: 'rgba(0,0,0,0)', 'fill': prop.filledColors && prop.filledColors[index] ? prop.filledColors[index] : prop.colors[index], 'fill-opacity': prop.filledOpacity, 'stroke-width': 1, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });if (prop.filledClick) {\n          var obj = this;fillPathObject.addEventListener('click', function (e) {\n            prop.filledClick(e, obj, index);\n          }, false);fillPathObject.addEventListener('mousemove', function (e) {\n            e.target.style.cursor = 'pointer';\n          }, false);\n        }\n      }\n      if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      if (prop.spline) {\n        var str = ['M{1} {2}'.format(this.coordsSpline[index][0][0], this.coordsSpline[index][0][1])];for (var i = 1; i < this.coordsSpline[index].length; ++i) {\n          str.push('L{1} {2}'.format(this.coordsSpline[index][i][0], this.coordsSpline[index][i][1]));\n        }\n        str = str.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: str, stroke: prop['colors'][index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      } else {\n        var path2 = RG.SVG.arrayClone(path);if (prop.filled && prop.filledAccumulative && index > 0) {\n          for (var i = this.coords[index - 1].length - 1; i >= 0; --i) {\n            path2.push('L{1} {2}'.format(this.coords[index - 1][i][0], this.coords[index - 1][i][1]));\n          }\n        }\n        path2 = path2.join(' ');var line = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path2, stroke: prop.colors[index], 'fill': 'none', 'stroke-width': this.hasMultipleDatasets && prop.filled && prop.filledAccumulative ? 0.1 : RG.SVG.isArray(prop.linewidth) ? prop.linewidth[index] : prop.linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n      }\n      if (prop.tooltips && prop.tooltips.length) {\n        var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { 'fill': 'transparent', className: \"rgraph_hotspots\" }, style: { cursor: 'pointer' } });for (var i = 0; i < this.coords[index].length && this.tooltipsSequentialIndex < prop.tooltips.length; ++i, ++this.tooltipsSequentialIndex) {\n          if (prop.tooltips[this.tooltipsSequentialIndex] && this.coords[index][i][0] && this.coords[index][i][1]) {\n            var hotspot = RG.SVG.create({ svg: this.svg, parent: group, type: 'circle', attr: { cx: this.coords[index][i][0], cy: this.coords[index][i][1], r: 5, 'data-dataset': index, 'data-index': i } });var obj = this;(function (sequentialIndex) {\n              hotspot.addEventListener(prop.tooltipsEvent, function (e) {\n                var indexes = RG.SVG.sequentialIndexToGrouped(sequentialIndex, obj.data),\n                    index = indexes[1],\n                    dataset = indexes[0];if (RG.SVG.REG.get('tooltip') && RG.SVG.REG.get('tooltip').__index__ === index && RG.SVG.REG.get('tooltip').__dataset__ === dataset) {\n                  return;\n                }\n                RG.SVG.hideTooltip();if (prop.tooltips[sequentialIndex]) {\n                  var text = prop.tooltips[sequentialIndex];\n                }\n                RG.SVG.tooltip({ object: obj, index: index, dataset: dataset, sequentialIndex: sequentialIndex, text: text, event: e });var outer_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 13, fill: obj.properties.colors[dataset], 'fill-opacity': 0.5 }, style: { cursor: 'pointer' } });var outer_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 14, fill: 'white', 'fill-opacity': 0.75 }, style: { cursor: 'pointer' } });var inner_highlight1 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 6, fill: 'white' }, style: { cursor: 'pointer' } });var inner_highlight2 = RG.SVG.create({ svg: obj.svg, parent: obj.svg.all, type: 'circle', attr: { cx: obj.coords[dataset][index][0], cy: obj.coords[dataset][index][1], r: 5, fill: obj.properties.colors[dataset] }, style: { cursor: 'pointer' } });RG.SVG.REG.set('highlight', [outer_highlight1, outer_highlight2, inner_highlight1, inner_highlight2]);\n              }, false);\n            })(this.tooltipsSequentialIndex);\n          }\n        }\n      }\n    };this.drawTickmarks = function (index, data, coords) {\n      for (var i = 0; i < data.length; ++i) {\n        if (typeof data[i] === 'number') {\n          switch (prop.tickmarksStyle) {case 'filledcircle':case 'filledendcircle':\n              if (prop.tickmarksStyle === 'filledcircle' || i === 0 || i === data.length - 1) {\n                var circle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'circle':case 'endcircle':\n              if (prop.tickmarksStyle === 'circle' || prop.tickmarksStyle === 'endcircle' && (i === 0 || i === data.length - 1)) {\n                var outerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': prop.colors[index], filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });var innerCircle = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'circle', attr: { cx: coords[index][i][0], cy: coords[index][i][1], r: prop.tickmarksSize, 'fill': prop.tickmarksFill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });break;\n              }\n              break;case 'endrect':case 'rect':\n              if (prop.tickmarksStyle === 'rect' || prop.tickmarksStyle === 'endrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && typeof prop.tickmarksFill[index] === 'string' ? prop.tickmarksFill[index] : prop.tickmarksFill;var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'stroke-width': prop.tickmarksLinewidth, 'stroke': prop.colors[index], 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }\n              break;case 'filledendrect':case 'filledrect':\n              if (prop.tickmarksStyle === 'filledrect' || prop.tickmarksStyle === 'filledendrect' && (i === 0 || i === data.length - 1)) {\n                var half = (prop.tickmarksSize + prop.tickmarksLinewidth) / 2;var fill = prop.colors[index];var rect = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'rect', attr: { x: coords[index][i][0] - half, y: coords[index][i][1] - half, width: prop.tickmarksSize + prop.tickmarksLinewidth, height: prop.tickmarksSize + prop.tickmarksLinewidth, 'fill': fill, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n              }}\n        }\n      }\n    };this.redrawLines = function () {\n      if (prop.spline) {\n        for (var i = 0; i < this.coordsSpline.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coordsSpline[i].length; ++j) {\n            if (j === 0) {\n              path += 'M{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coordsSpline[i][j][0], this.coordsSpline[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropShadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      } else {\n        for (var i = 0; i < this.coords.length; ++i) {\n          var linewidth = RG.SVG.isArray(prop.linewidth) ? prop.linewidth[i] : prop.linewidth,\n              color = prop['colors'][i],\n              path = '';for (var j = 0; j < this.coords[i].length; ++j) {\n            if (j === 0 || RG.SVG.isNull(this.data[i][j]) || RG.SVG.isNull(this.data[i][j - 1])) {\n              path += 'M{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            } else {\n              path += 'L{1} {2} '.format(this.coords[i][j][0], this.coords[i][j][1]);\n            }\n          }\n          RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, stroke: color, 'fill': 'none', 'stroke-width': linewidth + 0.01, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', filter: prop.shadow ? 'url(#dropshadow)' : '', 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });\n        }\n        for (var dataset = 0; dataset < this.coords.length; ++dataset) {\n          this.drawTickmarks(dataset, this.data[dataset], this.coords);\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties,\n          y;if (value > this.scale.max) {\n        return null;\n      }\n      if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y');\n    };this.drawSpline = function (coords) {\n      var xCoords = [];gutterLeft = prop.gutterLeft, gutterRight = prop.gutterRight, hmargin = prop.hmargin, interval = (this.graphWidth - 2 * hmargin) / (coords.length - 1), coordsSpline = [];for (var i = 0, len = coords.length; i < len; i += 1) {\n        if (_typeof(coords[i]) == 'object' && coords[i] && coords[i].length == 2) {\n          coords[i] = Number(coords[i][1]);\n        }\n      }\n      var P = [coords[0]];for (var i = 0; i < coords.length; ++i) {\n        P.push(coords[i]);\n      }\n      P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));for (var j = 1; j < P.length - 2; ++j) {\n        for (var t = 0; t < 10; ++t) {\n          var yCoord = spline(t / 10, P[j - 1], P[j], P[j + 1], P[j + 2]);xCoords.push((j - 1) * interval + t * (interval / 10) + gutterLeft + hmargin);coordsSpline.push([xCoords[xCoords.length - 1], yCoord]);if (typeof index === 'number') {\n            coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\n          }\n        }\n      }\n      coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);if (typeof index === 'number') {\n        coordsSpline.push([(j - 1) * interval + gutterLeft + hmargin, P[j]]);\n      }\n      function spline(t, P0, P1, P2, P3) {\n        return 0.5 * (2 * P1 + (0 - P0 + P2) * t + ((2 * P0 - 5 * P1 + 4 * P2 - P3) * (t * t) + (0 - P0 + 3 * P1 - 3 * P2 + P3) * (t * t * t)));\n      }\n      return coordsSpline;\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), filledColors: RG.SVG.arrayClone(prop.filledColors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      var filledColors = prop.filledColors;if (filledColors) {\n        for (var i = 0; i < filledColors.length; ++i) {\n          filledColors[i] = RG.SVG.parseColorLinear({ object: this, color: filledColors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var data_seq = RG.SVG.arrayLinearize(this.data),\n            seq = 0;for (var dataset = 0; dataset < this.coords.length; ++dataset, seq++) {\n          for (var i = 0; i < this.coords[dataset].length; ++i, seq++) {\n            var str = RG.SVG.numberFormat({ object: this, num: this.data[dataset][i].toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[seq] === 'string' || typeof prop.labelsAboveSpecific[seq] === 'number')) {\n              str = prop.labelsAboveSpecific[seq];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[seq] !== 'string' && typeof prop.labelsAboveSpecific[seq] !== 'number') {\n              continue;\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: parseFloat(this.coords[dataset][i][0]) + prop.labelsAboveOffsetx, y: parseFloat(this.coords[dataset][i][1]) + prop.labelsAboveOffsety, halign: prop.labelsAboveHalign, valign: prop.labelsAboveValign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n          seq--;\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 60,\n          obj = this;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });var clipPathRect = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'rect', attr: { x: 0, y: 0, width: 0, height: this.height } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;clipPathRect.setAttribute(\"width\", width);if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };\n  return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcubGluZS5qcz9mNDdhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aCxcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50O1JHLlNWRy5MaW5lID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoaSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7IG9iamVjdDogdGhpcywgbmFtZTogaSwgdmFsdWU6IGFyZ3VtZW50c1swXVtpXSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuaWQgPSBjb25mLmlkO3RoaXMudWlkID0gUkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5zdmcgPSBSRy5TVkcuY3JlYXRlU1ZHKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7dGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7aWYgKFJHLlNWRy5pc0FycmF5KGNvbmYuZGF0YSkgJiYgUkcuU1ZHLmlzQXJyYXkoY29uZi5kYXRhWzBdKSkge1xuICAgICAgdGhpcy5kYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKFJHLlNWRy5pc0FycmF5KGNvbmYuZGF0YSkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtSRy5TVkcuYXJyYXlDbG9uZShjb25mLmRhdGEpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gW1tdXTtcbiAgICB9XG4gICAgdGhpcy50eXBlID0gJ2xpbmUnO3RoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHMyID0gW107dGhpcy5jb29yZHNTcGxpbmUgPSBbXTt0aGlzLmhhc011bHRpcGxlRGF0YXNldHMgPSBfdHlwZW9mKHRoaXMuZGF0YVswXSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YodGhpcy5kYXRhWzFdKSA9PT0gJ29iamVjdCcgPyB0cnVlIDogZmFsc2U7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLm9yaWdpbmFsQ29sb3JzID0ge307dGhpcy5ncmFkaWVudENvdW50ZXIgPSAxO3RoaXMub3JpZ2luYWxEYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUodGhpcy5kYXRhKTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXMgPSB7IGd1dHRlckxlZnQ6IDM1LCBndXR0ZXJSaWdodDogMzUsIGd1dHRlclRvcDogMzUsIGd1dHRlckJvdHRvbTogMzUsIGJhY2tncm91bmRDb2xvcjogbnVsbCwgYmFja2dyb3VuZEltYWdlOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoOiB0cnVlLCBiYWNrZ3JvdW5kSW1hZ2VBc3BlY3Q6ICdub25lJywgYmFja2dyb3VuZEltYWdlT3BhY2l0eTogbnVsbCwgYmFja2dyb3VuZEltYWdlWDogbnVsbCwgYmFja2dyb3VuZEltYWdlWTogbnVsbCwgYmFja2dyb3VuZEltYWdlVzogbnVsbCwgYmFja2dyb3VuZEltYWdlSDogbnVsbCwgYmFja2dyb3VuZEdyaWQ6IHRydWUsIGJhY2tncm91bmRHcmlkQ29sb3I6ICcjZGRkJywgYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6IDEsIGJhY2tncm91bmRHcmlkSGxpbmVzOiB0cnVlLCBiYWNrZ3JvdW5kR3JpZEhsaW5lc0NvdW50OiBudWxsLCBiYWNrZ3JvdW5kR3JpZFZsaW5lczogdHJ1ZSwgYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudDogbnVsbCwgYmFja2dyb3VuZEdyaWRCb3JkZXI6IHRydWUsIGNvbG9yczogWydyZWQnLCAnIzBmMCcsICdibHVlJywgJyNmZjAnLCAnIzBmZicsICdncmVlbiddLCBmaWxsZWQ6IGZhbHNlLCBmaWxsZWRDb2xvcnM6IFtdLCBmaWxsZWRDbGljazogbnVsbCwgZmlsbGVkT3BhY2l0eTogMSwgZmlsbGVkQWNjdW11bGF0aXZlOiBmYWxzZSwgaG1hcmdpbjogMCwgeWF4aXM6IHRydWUsIHlheGlzVGlja21hcmtzOiB0cnVlLCB5YXhpc1RpY2ttYXJrc0xlbmd0aDogMywgeWF4aXNDb2xvcjogJ2JsYWNrJywgeWF4aXNTY2FsZTogdHJ1ZSwgeWF4aXNMYWJlbHM6IG51bGwsIHlheGlzTGFiZWxzT2Zmc2V0eDogMCwgeWF4aXNMYWJlbHNPZmZzZXR5OiAwLCB5YXhpc0xhYmVsc0NvdW50OiA1LCB5YXhpc1VuaXRzUHJlOiAnJywgeWF4aXNVbml0c1Bvc3Q6ICcnLCB5YXhpc1N0cmljdDogZmFsc2UsIHlheGlzRGVjaW1hbHM6IDAsIHlheGlzUG9pbnQ6ICcuJywgeWF4aXNUaG91c2FuZDogJywnLCB5YXhpc1JvdW5kOiBmYWxzZSwgeWF4aXNNYXg6IG51bGwsIHlheGlzTWluOiAwLCB5YXhpc0Zvcm1hdHRlcjogbnVsbCwgeGF4aXM6IHRydWUsIHhheGlzVGlja21hcmtzOiB0cnVlLCB4YXhpc1RpY2ttYXJrc0xlbmd0aDogNSwgeGF4aXNMYWJlbHM6IG51bGwsIHhheGlzTGFiZWxzT2Zmc2V0eDogMCwgeGF4aXNMYWJlbHNPZmZzZXR5OiAwLCB4YXhpc0xhYmVsc1Bvc2l0aW9uOiAnZWRnZScsIHhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ6IG51bGwsIHhheGlzQ29sb3I6ICdibGFjaycsIHRleHRDb2xvcjogJ2JsYWNrJywgdGV4dEZvbnQ6ICdzYW5zLXNlcmlmJywgdGV4dFNpemU6IDEyLCB0ZXh0Qm9sZDogZmFsc2UsIHRleHRJdGFsaWM6IGZhbHNlLCBsaW5ld2lkdGg6IDEsIHRvb2x0aXBzOiBudWxsLCB0b29sdGlwc092ZXJyaWRlOiBudWxsLCB0b29sdGlwc0VmZmVjdDogJ2ZhZGUnLCB0b29sdGlwc0Nzc0NsYXNzOiAnUkdyYXBoX3Rvb2x0aXAnLCB0b29sdGlwc0V2ZW50OiAnbW91c2Vtb3ZlJywgaGlnaGxpZ2h0U3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCBoaWdobGlnaHRMaW5ld2lkdGg6IDEsIHRpY2ttYXJrc1N0eWxlOiAnbm9uZScsIHRpY2ttYXJrc1NpemU6IDUsIHRpY2ttYXJrc0ZpbGw6ICd3aGl0ZScsIHRpY2ttYXJrc0xpbmV3aWR0aDogMSwgbGFiZWxzQWJvdmU6IGZhbHNlLCBsYWJlbHNBYm92ZUZvbnQ6IG51bGwsIGxhYmVsc0Fib3ZlU2l6ZTogbnVsbCwgbGFiZWxzQWJvdmVCb2xkOiBudWxsLCBsYWJlbHNBYm92ZUl0YWxpYzogbnVsbCwgbGFiZWxzQWJvdmVDb2xvcjogbnVsbCwgbGFiZWxzQWJvdmVCYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgbGFiZWxzQWJvdmVCYWNrZ3JvdW5kUGFkZGluZzogMiwgbGFiZWxzQWJvdmVVbml0c1ByZTogbnVsbCwgbGFiZWxzQWJvdmVVbml0c1Bvc3Q6IG51bGwsIGxhYmVsc0Fib3ZlUG9pbnQ6IG51bGwsIGxhYmVsc0Fib3ZlVGhvdXNhbmQ6IG51bGwsIGxhYmVsc0Fib3ZlRm9ybWF0dGVyOiBudWxsLCBsYWJlbHNBYm92ZURlY2ltYWxzOiBudWxsLCBsYWJlbHNBYm92ZU9mZnNldHg6IDAsIGxhYmVsc0Fib3ZlT2Zmc2V0eTogLTEwLCBsYWJlbHNBYm92ZUhhbGlnbjogJ2NlbnRlcicsIGxhYmVsc0Fib3ZlVmFsaWduOiAnYm90dG9tJywgbGFiZWxzQWJvdmVTcGVjaWZpYzogbnVsbCwgc2hhZG93OiBmYWxzZSwgc2hhZG93T2Zmc2V0eDogMiwgc2hhZG93T2Zmc2V0eTogMiwgc2hhZG93Qmx1cjogMiwgc2hhZG93T3BhY2l0eTogMC4yNSwgc3BsaW5lOiBmYWxzZSwgdGl0bGU6ICcnLCB0aXRsZVNpemU6IG51bGwsIHRpdGxlWDogbnVsbCwgdGl0bGVZOiBudWxsLCB0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlVmFsaWduOiBudWxsLCB0aXRsZUNvbG9yOiBudWxsLCB0aXRsZUZvbnQ6IG51bGwsIHRpdGxlQm9sZDogZmFsc2UsIHRpdGxlSXRhbGljOiBmYWxzZSwgdGl0bGVTdWJ0aXRsZTogJycsIHRpdGxlU3VidGl0bGVTaXplOiAxMCwgdGl0bGVTdWJ0aXRsZVg6IG51bGwsIHRpdGxlU3VidGl0bGVZOiBudWxsLCB0aXRsZVN1YnRpdGxlSGFsaWduOiAnY2VudGVyJywgdGl0bGVTdWJ0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVTdWJ0aXRsZUNvbG9yOiAnI2FhYScsIHRpdGxlU3VidGl0bGVGb250OiBudWxsLCB0aXRsZVN1YnRpdGxlQm9sZDogZmFsc2UsIHRpdGxlU3VidGl0bGVJdGFsaWM6IGZhbHNlLCBrZXk6IG51bGwsIGtleUNvbG9yczogbnVsbCwga2V5T2Zmc2V0eDogMCwga2V5T2Zmc2V0eTogMCwga2V5VGV4dE9mZnNldHg6IDAsIGtleVRleHRPZmZzZXR5OiAtMSwga2V5VGV4dFNpemU6IG51bGwsIGtleVRleHRCb2xkOiBudWxsLCBrZXlUZXh0SXRhbGljOiBudWxsLCBhdHRyaWJ1dGlvbjogdHJ1ZSwgYXR0cmlidXRpb25YOiBudWxsLCBhdHRyaWJ1dGlvblk6IG51bGwsIGF0dHJpYnV0aW9uSHJlZjogbnVsbCwgYXR0cmlidXRpb25IYWxpZ246ICdyaWdodCcsIGF0dHJpYnV0aW9uVmFsaWduOiAnYm90dG9tJywgYXR0cmlidXRpb25TaXplOiA3LCBhdHRyaWJ1dGlvbkNvbG9yOiAnZ3JheScsIGF0dHJpYnV0aW9uRm9udDogJ3NhbnMtc2VyaWYnLCBhdHRyaWJ1dGlvbkl0YWxpYzogZmFsc2UsIGF0dHJpYnV0aW9uQm9sZDogZmFsc2UgfTtpZiAoUkcuU1ZHLkZYICYmIHR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7dGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgUkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7UkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5ncmFwaFdpZHRoID0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyTGVmdCAtIHByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbTtSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHsgb2JqZWN0OiB0aGlzIH0pO3RoaXMucGFyc2VDb2xvcnMoKTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO3RoaXMuY29vcmRzU3BsaW5lID0gW107dGhpcy5kYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUodGhpcy5vcmlnaW5hbERhdGEpO3RoaXMudG9vbHRpcHNTZXF1ZW50aWFsSW5kZXggPSAwO3ZhciB2YWx1ZXMgPSBbXTtmb3IgKHZhciBpID0gMCwgbWF4ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmRhdGFbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgKCFwcm9wLmZpbGxlZCB8fCAhcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goUkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YVtpXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKFJHLlNWRy5pc0FycmF5KHRoaXMuZGF0YVtpXSkgJiYgcHJvcC5maWxsZWQgJiYgcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFsdWVzW2pdID0gdmFsdWVzW2pdIHx8IDA7dmFsdWVzW2pdID0gdmFsdWVzW2pdICsgdGhpcy5kYXRhW2ldW2pdO3RoaXMuZGF0YVtpXVtqXSA9IHZhbHVlc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtYXggPSBSRy5TVkcuYXJyYXlNYXgodmFsdWVzKTtpZiAodHlwZW9mIHByb3AueWF4aXNNYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heCA9IHByb3AueWF4aXNNYXg7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC55YXhpc01pbiA9PT0gJ21pcnJvcicpIHtcbiAgICAgICAgdmFyIG1pcnJvclNjYWxlID0gdHJ1ZTtwcm9wLnlheGlzTWluID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NhbGUgPSBSRy5TVkcuZ2V0U2NhbGUoeyBvYmplY3Q6IHRoaXMsIG51bWxhYmVsczogcHJvcC55YXhpc0xhYmVsc0NvdW50LCB1bml0c1ByZTogcHJvcC55YXhpc1VuaXRzUHJlLCB1bml0c1Bvc3Q6IHByb3AueWF4aXNVbml0c1Bvc3QsIG1heDogbWF4LCBtaW46IHByb3AueWF4aXNNaW4sIHBvaW50OiBwcm9wLnlheGlzUG9pbnQsIHJvdW5kOiBwcm9wLnlheGlzUm91bmQsIHRob3VzYW5kOiBwcm9wLnlheGlzVGhvdXNhbmQsIGRlY2ltYWxzOiBwcm9wLnlheGlzRGVjaW1hbHMsIHN0cmljdDogdHlwZW9mIHByb3AueWF4aXNNYXggPT09ICdudW1iZXInLCBmb3JtYXR0ZXI6IHByb3AueWF4aXNGb3JtYXR0ZXIgfSk7aWYgKG1pcnJvclNjYWxlKSB7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBSRy5TVkcuZ2V0U2NhbGUoeyBvYmplY3Q6IHRoaXMsIG51bWxhYmVsczogcHJvcC55YXhpc0xhYmVsc0NvdW50LCB1bml0c1ByZTogcHJvcC55YXhpc1VuaXRzUHJlLCB1bml0c1Bvc3Q6IHByb3AueWF4aXNVbml0c1Bvc3QsIG1heDogdGhpcy5zY2FsZS5tYXgsIG1pbjogdGhpcy5zY2FsZS5tYXggKiAtMSwgcG9pbnQ6IHByb3AueWF4aXNQb2ludCwgcm91bmQ6IGZhbHNlLCB0aG91c2FuZDogcHJvcC55YXhpc1Rob3VzYW5kLCBkZWNpbWFsczogcHJvcC55YXhpc0RlY2ltYWxzLCBzdHJpY3Q6IHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJywgZm9ybWF0dGVyOiBwcm9wLnlheGlzRm9ybWF0dGVyIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXggPSB0aGlzLnNjYWxlLm1heDt0aGlzLm1pbiA9IHRoaXMuc2NhbGUubWluO3Byb3AueWF4aXNNYXggPSB0aGlzLnNjYWxlLm1heDtwcm9wLnlheGlzTWluID0gdGhpcy5zY2FsZS5taW47UkcuU1ZHLmRyYXdCYWNrZ3JvdW5kKHRoaXMpO1JHLlNWRy5kcmF3WEF4aXModGhpcyk7UkcuU1ZHLmRyYXdZQXhpcyh0aGlzKTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRyYXdMaW5lKHRoaXMuZGF0YVtpXSwgaSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZHJhd0xpbmVzKCk7aWYgKHR5cGVvZiBwcm9wLmtleSAhPT0gbnVsbCAmJiBSRy5TVkcuZHJhd0tleSkge1xuICAgICAgICBSRy5TVkcuZHJhd0tleSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSkge1xuICAgICAgICBhbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0xhYmVsc0Fib3ZlKCk7UkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO3ZhciBvYmogPSB0aGlzO2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgUkcuU1ZHLnJlbW92ZUhpZ2hsaWdodChvYmopO1xuICAgICAgfSwgZmFsc2UpO1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy5kcmF3TGluZSA9IGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgICAgdmFyIGNvb3JkcyA9IFtdLFxuICAgICAgICAgIHBhdGggPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gZGF0YVtpXSxcbiAgICAgICAgICAgIHggPSAodGhpcy5ncmFwaFdpZHRoIC0gcHJvcC5obWFyZ2luIC0gcHJvcC5obWFyZ2luKSAvIChsZW4gLSAxKSAqIGkgKyBwcm9wLmd1dHRlckxlZnQgKyBwcm9wLmhtYXJnaW4sXG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQodmFsKTtjb29yZHMucHVzaChbeCwgeV0pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgUkcuU1ZHLmlzTnVsbChkYXRhW2ldKSB8fCBSRy5TVkcuaXNOdWxsKGRhdGFbaSAtIDFdKSkge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSAnTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9ICdMJztcbiAgICAgICAgfVxuICAgICAgICBwYXRoLnB1c2goYWN0aW9uICsgJ3sxfSB7Mn0nLmZvcm1hdChjb29yZHNbaV1bMF0sIGNvb3Jkc1tpXVsxXSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb29yZHNbaW5kZXhdID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29vcmRzKTt0aGlzLmNvb3JkczJbaW5kZXhdID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29vcmRzKTtpZiAocHJvcC5zcGxpbmUpIHtcbiAgICAgICAgdGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdID0gdGhpcy5kcmF3U3BsaW5lKGNvb3Jkcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC5maWxsZWQgPT09IHRydWUgfHwgX3R5cGVvZihwcm9wLmZpbGxlZCkgPT09ICdvYmplY3QnICYmIHByb3AuZmlsbGVkW2luZGV4XSkge1xuICAgICAgICBpZiAocHJvcC5zcGxpbmUpIHtcbiAgICAgICAgICB2YXIgZmlsbFBhdGggPSBbJ017MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdWzBdWzBdLCB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1bMF1bMV0pXTtmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1baV1bMF0gKyAoaSA9PT0gdGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLmxlbmd0aCAtIDEgPyAxIDogMCksIHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XVtpXVsxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlsbFBhdGggPSBSRy5TVkcuYXJyYXlDbG9uZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsUGF0aC5wdXNoKCdMezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzW2luZGV4XVt0aGlzLmNvb3Jkc1tpbmRleF0ubGVuZ3RoIC0gMV1bMF0gKyAxLCBpbmRleCA+IDAgJiYgcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUgPyBwcm9wLnNwbGluZSA/IHRoaXMuY29vcmRzU3BsaW5lW2luZGV4IC0gMV1bdGhpcy5jb29yZHNTcGxpbmVbaW5kZXggLSAxXS5sZW5ndGggLSAxXVsxXSA6IHRoaXMuY29vcmRzW2luZGV4IC0gMV1bdGhpcy5jb29yZHNbaW5kZXggLSAxXS5sZW5ndGggLSAxXVsxXSA6IHRoaXMuZ2V0WUNvb3JkKHByb3AueWF4aXNNaW4gPiAwID8gcHJvcC55YXhpc01pbiA6IDApICsgKHByb3AueGF4aXMgPyAwIDogMSkpKTtpZiAoaW5kZXggPiAwICYmIHByb3AuZmlsbGVkQWNjdW11bGF0aXZlKSB7XG4gICAgICAgICAgdmFyIHBhdGgyID0gUkcuU1ZHLmFycmF5Q2xvbmUocGF0aCk7aWYgKGluZGV4ID4gMCAmJiBwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHByb3Auc3BsaW5lKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleCAtIDFdLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpbmRleCAtIDFdW2ldWzBdLCB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleCAtIDFdW2ldWzFdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvb3Jkc1tpbmRleCAtIDFdLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleCAtIDFdW2ldWzBdLCB0aGlzLmNvb3Jkc1tpbmRleCAtIDFdW2ldWzFdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleF1bMF1bMF0gKyAocHJvcC55YXhpcyA/IDEgOiAwKSwgdGhpcy5nZXRZQ29vcmQocHJvcC55YXhpc01pbiA+IDAgPyBwcm9wLnlheGlzTWluIDogMCkgKyAocHJvcC54YXhpcyA/IDAgOiAxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxQYXRoLnB1c2goJ0x7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNbaW5kZXhdWzBdWzBdICsgKHByb3AueWF4aXMgPyAxIDogMCksIHRoaXMuY29vcmRzW2luZGV4XVswXVsxXSkpO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhW2luZGV4XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICghUkcuU1ZHLmlzTnVsbCh0aGlzLmRhdGFbaW5kZXhdW2ldKSkge1xuICAgICAgICAgICAgZmlsbFBhdGgucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleF1baV1bMF0sIHRoaXMuZ2V0WUNvb3JkKDApKSk7YnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmaWxsUGF0aE9iamVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6IGZpbGxQYXRoLmpvaW4oJyAnKSwgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsICdmaWxsJzogcHJvcC5maWxsZWRDb2xvcnMgJiYgcHJvcC5maWxsZWRDb2xvcnNbaW5kZXhdID8gcHJvcC5maWxsZWRDb2xvcnNbaW5kZXhdIDogcHJvcC5jb2xvcnNbaW5kZXhdLCAnZmlsbC1vcGFjaXR5JzogcHJvcC5maWxsZWRPcGFjaXR5LCAnc3Ryb2tlLXdpZHRoJzogMSwgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO2lmIChwcm9wLmZpbGxlZENsaWNrKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXM7ZmlsbFBhdGhPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcHJvcC5maWxsZWRDbGljayhlLCBvYmosIGluZGV4KTtcbiAgICAgICAgICB9LCBmYWxzZSk7ZmlsbFBhdGhPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLnNoYWRvdykge1xuICAgICAgICBSRy5TVkcuc2V0U2hhZG93KHsgb2JqZWN0OiB0aGlzLCBvZmZzZXR4OiBwcm9wLnNoYWRvd09mZnNldHgsIG9mZnNldHk6IHByb3Auc2hhZG93T2Zmc2V0eSwgYmx1cjogcHJvcC5zaGFkb3dCbHVyLCBvcGFjaXR5OiBwcm9wLnNoYWRvd09wYWNpdHksIGlkOiAnZHJvcFNoYWRvdycgfSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC5zcGxpbmUpIHtcbiAgICAgICAgdmFyIHN0ciA9IFsnTXsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1bMF1bMF0sIHRoaXMuY29vcmRzU3BsaW5lW2luZGV4XVswXVsxXSldO2ZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgc3RyLnB1c2goJ0x7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHNTcGxpbmVbaW5kZXhdW2ldWzBdLCB0aGlzLmNvb3Jkc1NwbGluZVtpbmRleF1baV1bMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuam9pbignICcpO3ZhciBsaW5lID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogc3RyLCBzdHJva2U6IHByb3BbJ2NvbG9ycyddW2luZGV4XSwgJ2ZpbGwnOiAnbm9uZScsICdzdHJva2Utd2lkdGgnOiB0aGlzLmhhc011bHRpcGxlRGF0YXNldHMgJiYgcHJvcC5maWxsZWQgJiYgcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUgPyAwLjEgOiBSRy5TVkcuaXNBcnJheShwcm9wLmxpbmV3aWR0aCkgPyBwcm9wLmxpbmV3aWR0aFtpbmRleF0gOiBwcm9wLmxpbmV3aWR0aCArIDAuMDEsICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLCBmaWx0ZXI6IHByb3Auc2hhZG93ID8gJ3VybCgjZHJvcFNoYWRvdyknIDogJycsICdjbGlwLXBhdGgnOiB0aGlzLmlzVHJhY2UgPyAndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknIDogJycgfSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXRoMiA9IFJHLlNWRy5hcnJheUNsb25lKHBhdGgpO2lmIChwcm9wLmZpbGxlZCAmJiBwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jb29yZHNbaW5kZXggLSAxXS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcGF0aDIucHVzaCgnTHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3Jkc1tpbmRleCAtIDFdW2ldWzBdLCB0aGlzLmNvb3Jkc1tpbmRleCAtIDFdW2ldWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGgyID0gcGF0aDIuam9pbignICcpO3ZhciBsaW5lID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogcGF0aDIsIHN0cm9rZTogcHJvcC5jb2xvcnNbaW5kZXhdLCAnZmlsbCc6ICdub25lJywgJ3N0cm9rZS13aWR0aCc6IHRoaXMuaGFzTXVsdGlwbGVEYXRhc2V0cyAmJiBwcm9wLmZpbGxlZCAmJiBwcm9wLmZpbGxlZEFjY3VtdWxhdGl2ZSA/IDAuMSA6IFJHLlNWRy5pc0FycmF5KHByb3AubGluZXdpZHRoKSA/IHByb3AubGluZXdpZHRoW2luZGV4XSA6IHByb3AubGluZXdpZHRoICsgMC4wMSwgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJywgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsIGZpbHRlcjogcHJvcC5zaGFkb3cgPyAndXJsKCNkcm9wU2hhZG93KScgOiAnJywgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAnZycsIGF0dHI6IHsgJ2ZpbGwnOiAndHJhbnNwYXJlbnQnLCBjbGFzc05hbWU6IFwicmdyYXBoX2hvdHNwb3RzXCIgfSwgc3R5bGU6IHsgY3Vyc29yOiAncG9pbnRlcicgfSB9KTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29vcmRzW2luZGV4XS5sZW5ndGggJiYgdGhpcy50b29sdGlwc1NlcXVlbnRpYWxJbmRleCA8IHByb3AudG9vbHRpcHMubGVuZ3RoOyArK2ksICsrdGhpcy50b29sdGlwc1NlcXVlbnRpYWxJbmRleCkge1xuICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzW3RoaXMudG9vbHRpcHNTZXF1ZW50aWFsSW5kZXhdICYmIHRoaXMuY29vcmRzW2luZGV4XVtpXVswXSAmJiB0aGlzLmNvb3Jkc1tpbmRleF1baV1bMV0pIHtcbiAgICAgICAgICAgIHZhciBob3RzcG90ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogZ3JvdXAsIHR5cGU6ICdjaXJjbGUnLCBhdHRyOiB7IGN4OiB0aGlzLmNvb3Jkc1tpbmRleF1baV1bMF0sIGN5OiB0aGlzLmNvb3Jkc1tpbmRleF1baV1bMV0sIHI6IDUsICdkYXRhLWRhdGFzZXQnOiBpbmRleCwgJ2RhdGEtaW5kZXgnOiBpIH0gfSk7dmFyIG9iaiA9IHRoaXM7KGZ1bmN0aW9uIChzZXF1ZW50aWFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgaG90c3BvdC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFJHLlNWRy5zZXF1ZW50aWFsSW5kZXhUb0dyb3VwZWQoc2VxdWVudGlhbEluZGV4LCBvYmouZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXhlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldCA9IGluZGV4ZXNbMF07aWYgKFJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwJykgJiYgUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAnKS5fX2luZGV4X18gPT09IGluZGV4ICYmIFJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwJykuX19kYXRhc2V0X18gPT09IGRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkcuU1ZHLmhpZGVUb29sdGlwKCk7aWYgKHByb3AudG9vbHRpcHNbc2VxdWVudGlhbEluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBwcm9wLnRvb2x0aXBzW3NlcXVlbnRpYWxJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGluZGV4OiBpbmRleCwgZGF0YXNldDogZGF0YXNldCwgc2VxdWVudGlhbEluZGV4OiBzZXF1ZW50aWFsSW5kZXgsIHRleHQ6IHRleHQsIGV2ZW50OiBlIH0pO3ZhciBvdXRlcl9oaWdobGlnaHQxID0gUkcuU1ZHLmNyZWF0ZSh7IHN2Zzogb2JqLnN2ZywgcGFyZW50OiBvYmouc3ZnLmFsbCwgdHlwZTogJ2NpcmNsZScsIGF0dHI6IHsgY3g6IG9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzBdLCBjeTogb2JqLmNvb3Jkc1tkYXRhc2V0XVtpbmRleF1bMV0sIHI6IDEzLCBmaWxsOiBvYmoucHJvcGVydGllcy5jb2xvcnNbZGF0YXNldF0sICdmaWxsLW9wYWNpdHknOiAwLjUgfSwgc3R5bGU6IHsgY3Vyc29yOiAncG9pbnRlcicgfSB9KTt2YXIgb3V0ZXJfaGlnaGxpZ2h0MiA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdjaXJjbGUnLCBhdHRyOiB7IGN4OiBvYmouY29vcmRzW2RhdGFzZXRdW2luZGV4XVswXSwgY3k6IG9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzFdLCByOiAxNCwgZmlsbDogJ3doaXRlJywgJ2ZpbGwtb3BhY2l0eSc6IDAuNzUgfSwgc3R5bGU6IHsgY3Vyc29yOiAncG9pbnRlcicgfSB9KTt2YXIgaW5uZXJfaGlnaGxpZ2h0MSA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IG9iai5zdmcsIHBhcmVudDogb2JqLnN2Zy5hbGwsIHR5cGU6ICdjaXJjbGUnLCBhdHRyOiB7IGN4OiBvYmouY29vcmRzW2RhdGFzZXRdW2luZGV4XVswXSwgY3k6IG9iai5jb29yZHNbZGF0YXNldF1baW5kZXhdWzFdLCByOiA2LCBmaWxsOiAnd2hpdGUnIH0sIHN0eWxlOiB7IGN1cnNvcjogJ3BvaW50ZXInIH0gfSk7dmFyIGlubmVyX2hpZ2hsaWdodDIgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiBvYmouc3ZnLCBwYXJlbnQ6IG9iai5zdmcuYWxsLCB0eXBlOiAnY2lyY2xlJywgYXR0cjogeyBjeDogb2JqLmNvb3Jkc1tkYXRhc2V0XVtpbmRleF1bMF0sIGN5OiBvYmouY29vcmRzW2RhdGFzZXRdW2luZGV4XVsxXSwgcjogNSwgZmlsbDogb2JqLnByb3BlcnRpZXMuY29sb3JzW2RhdGFzZXRdIH0sIHN0eWxlOiB7IGN1cnNvcjogJ3BvaW50ZXInIH0gfSk7UkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIFtvdXRlcl9oaWdobGlnaHQxLCBvdXRlcl9oaWdobGlnaHQyLCBpbm5lcl9oaWdobGlnaHQxLCBpbm5lcl9oaWdobGlnaHQyXSk7XG4gICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0pKHRoaXMudG9vbHRpcHNTZXF1ZW50aWFsSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5kcmF3VGlja21hcmtzID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBjb29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3dpdGNoIChwcm9wLnRpY2ttYXJrc1N0eWxlKSB7Y2FzZSAnZmlsbGVkY2lyY2xlJzpjYXNlICdmaWxsZWRlbmRjaXJjbGUnOlxuICAgICAgICAgICAgICBpZiAocHJvcC50aWNrbWFya3NTdHlsZSA9PT0gJ2ZpbGxlZGNpcmNsZScgfHwgaSA9PT0gMCB8fCBpID09PSBkYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAnY2lyY2xlJywgYXR0cjogeyBjeDogY29vcmRzW2luZGV4XVtpXVswXSwgY3k6IGNvb3Jkc1tpbmRleF1baV1bMV0sIHI6IHByb3AudGlja21hcmtzU2l6ZSwgJ2ZpbGwnOiBwcm9wLmNvbG9yc1tpbmRleF0sIGZpbHRlcjogcHJvcC5zaGFkb3cgPyAndXJsKCNkcm9wU2hhZG93KScgOiAnJywgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO2Nhc2UgJ2NpcmNsZSc6Y2FzZSAnZW5kY2lyY2xlJzpcbiAgICAgICAgICAgICAgaWYgKHByb3AudGlja21hcmtzU3R5bGUgPT09ICdjaXJjbGUnIHx8IHByb3AudGlja21hcmtzU3R5bGUgPT09ICdlbmRjaXJjbGUnICYmIChpID09PSAwIHx8IGkgPT09IGRhdGEubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXJDaXJjbGUgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdjaXJjbGUnLCBhdHRyOiB7IGN4OiBjb29yZHNbaW5kZXhdW2ldWzBdLCBjeTogY29vcmRzW2luZGV4XVtpXVsxXSwgcjogcHJvcC50aWNrbWFya3NTaXplICsgcHJvcC50aWNrbWFya3NMaW5ld2lkdGgsICdmaWxsJzogcHJvcC5jb2xvcnNbaW5kZXhdLCBmaWx0ZXI6IHByb3Auc2hhZG93ID8gJ3VybCgjZHJvcFNoYWRvdyknIDogJycsICdjbGlwLXBhdGgnOiB0aGlzLmlzVHJhY2UgPyAndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknIDogJycgfSB9KTt2YXIgaW5uZXJDaXJjbGUgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdjaXJjbGUnLCBhdHRyOiB7IGN4OiBjb29yZHNbaW5kZXhdW2ldWzBdLCBjeTogY29vcmRzW2luZGV4XVtpXVsxXSwgcjogcHJvcC50aWNrbWFya3NTaXplLCAnZmlsbCc6IHByb3AudGlja21hcmtzRmlsbCwgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO2JyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO2Nhc2UgJ2VuZHJlY3QnOmNhc2UgJ3JlY3QnOlxuICAgICAgICAgICAgICBpZiAocHJvcC50aWNrbWFya3NTdHlsZSA9PT0gJ3JlY3QnIHx8IHByb3AudGlja21hcmtzU3R5bGUgPT09ICdlbmRyZWN0JyAmJiAoaSA9PT0gMCB8fCBpID09PSBkYXRhLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSAocHJvcC50aWNrbWFya3NTaXplICsgcHJvcC50aWNrbWFya3NMaW5ld2lkdGgpIC8gMjt2YXIgZmlsbCA9IF90eXBlb2YocHJvcC50aWNrbWFya3NGaWxsKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3AudGlja21hcmtzRmlsbFtpbmRleF0gPT09ICdzdHJpbmcnID8gcHJvcC50aWNrbWFya3NGaWxsW2luZGV4XSA6IHByb3AudGlja21hcmtzRmlsbDt2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3JlY3QnLCBhdHRyOiB7IHg6IGNvb3Jkc1tpbmRleF1baV1bMF0gLSBoYWxmLCB5OiBjb29yZHNbaW5kZXhdW2ldWzFdIC0gaGFsZiwgd2lkdGg6IHByb3AudGlja21hcmtzU2l6ZSArIHByb3AudGlja21hcmtzTGluZXdpZHRoLCBoZWlnaHQ6IHByb3AudGlja21hcmtzU2l6ZSArIHByb3AudGlja21hcmtzTGluZXdpZHRoLCAnc3Ryb2tlLXdpZHRoJzogcHJvcC50aWNrbWFya3NMaW5ld2lkdGgsICdzdHJva2UnOiBwcm9wLmNvbG9yc1tpbmRleF0sICdmaWxsJzogZmlsbCwgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO2Nhc2UgJ2ZpbGxlZGVuZHJlY3QnOmNhc2UgJ2ZpbGxlZHJlY3QnOlxuICAgICAgICAgICAgICBpZiAocHJvcC50aWNrbWFya3NTdHlsZSA9PT0gJ2ZpbGxlZHJlY3QnIHx8IHByb3AudGlja21hcmtzU3R5bGUgPT09ICdmaWxsZWRlbmRyZWN0JyAmJiAoaSA9PT0gMCB8fCBpID09PSBkYXRhLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSAocHJvcC50aWNrbWFya3NTaXplICsgcHJvcC50aWNrbWFya3NMaW5ld2lkdGgpIC8gMjt2YXIgZmlsbCA9IHByb3AuY29sb3JzW2luZGV4XTt2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3JlY3QnLCBhdHRyOiB7IHg6IGNvb3Jkc1tpbmRleF1baV1bMF0gLSBoYWxmLCB5OiBjb29yZHNbaW5kZXhdW2ldWzFdIC0gaGFsZiwgd2lkdGg6IHByb3AudGlja21hcmtzU2l6ZSArIHByb3AudGlja21hcmtzTGluZXdpZHRoLCBoZWlnaHQ6IHByb3AudGlja21hcmtzU2l6ZSArIHByb3AudGlja21hcmtzTGluZXdpZHRoLCAnZmlsbCc6IGZpbGwsICdjbGlwLXBhdGgnOiB0aGlzLmlzVHJhY2UgPyAndXJsKCN0cmFjZS1lZmZlY3QtY2xpcCknIDogJycgfSB9KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5yZWRyYXdMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9wLnNwbGluZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29vcmRzU3BsaW5lLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGxpbmV3aWR0aCA9IFJHLlNWRy5pc0FycmF5KHByb3AubGluZXdpZHRoKSA/IHByb3AubGluZXdpZHRoW2ldIDogcHJvcC5saW5ld2lkdGgsXG4gICAgICAgICAgICAgIGNvbG9yID0gcHJvcFsnY29sb3JzJ11baV0sXG4gICAgICAgICAgICAgIHBhdGggPSAnJztmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29vcmRzU3BsaW5lW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICBwYXRoICs9ICdNezF9IHsyfSAnLmZvcm1hdCh0aGlzLmNvb3Jkc1NwbGluZVtpXVtqXVswXSwgdGhpcy5jb29yZHNTcGxpbmVbaV1bal1bMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF0aCArPSAnTHsxfSB7Mn0gJy5mb3JtYXQodGhpcy5jb29yZHNTcGxpbmVbaV1bal1bMF0sIHRoaXMuY29vcmRzU3BsaW5lW2ldW2pdWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogcGF0aCwgc3Ryb2tlOiBjb2xvciwgJ2ZpbGwnOiAnbm9uZScsICdzdHJva2Utd2lkdGgnOiBsaW5ld2lkdGggKyAwLjAxLCAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLCAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJywgZmlsdGVyOiBwcm9wLnNoYWRvdyA/ICd1cmwoI2Ryb3BTaGFkb3cpJyA6ICcnLCAnY2xpcC1wYXRoJzogdGhpcy5pc1RyYWNlID8gJ3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJyA6ICcnIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZGF0YXNldCA9IDA7IGRhdGFzZXQgPCB0aGlzLmNvb3Jkcy5sZW5ndGg7ICsrZGF0YXNldCkge1xuICAgICAgICAgIHRoaXMuZHJhd1RpY2ttYXJrcyhkYXRhc2V0LCB0aGlzLmRhdGFbZGF0YXNldF0sIHRoaXMuY29vcmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBsaW5ld2lkdGggPSBSRy5TVkcuaXNBcnJheShwcm9wLmxpbmV3aWR0aCkgPyBwcm9wLmxpbmV3aWR0aFtpXSA6IHByb3AubGluZXdpZHRoLFxuICAgICAgICAgICAgICBjb2xvciA9IHByb3BbJ2NvbG9ycyddW2ldLFxuICAgICAgICAgICAgICBwYXRoID0gJyc7Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvb3Jkc1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYgKGogPT09IDAgfHwgUkcuU1ZHLmlzTnVsbCh0aGlzLmRhdGFbaV1bal0pIHx8IFJHLlNWRy5pc051bGwodGhpcy5kYXRhW2ldW2ogLSAxXSkpIHtcbiAgICAgICAgICAgICAgcGF0aCArPSAnTXsxfSB7Mn0gJy5mb3JtYXQodGhpcy5jb29yZHNbaV1bal1bMF0sIHRoaXMuY29vcmRzW2ldW2pdWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhdGggKz0gJ0x7MX0gezJ9ICcuZm9ybWF0KHRoaXMuY29vcmRzW2ldW2pdWzBdLCB0aGlzLmNvb3Jkc1tpXVtqXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6IHBhdGgsIHN0cm9rZTogY29sb3IsICdmaWxsJzogJ25vbmUnLCAnc3Ryb2tlLXdpZHRoJzogbGluZXdpZHRoICsgMC4wMSwgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJywgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsIGZpbHRlcjogcHJvcC5zaGFkb3cgPyAndXJsKCNkcm9wc2hhZG93KScgOiAnJywgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGRhdGFzZXQgPSAwOyBkYXRhc2V0IDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2RhdGFzZXQpIHtcbiAgICAgICAgICB0aGlzLmRyYXdUaWNrbWFya3MoZGF0YXNldCwgdGhpcy5kYXRhW2RhdGFzZXRdLCB0aGlzLmNvb3Jkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O3RoaXMuZ2V0WUNvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICB5O2lmICh2YWx1ZSA+IHRoaXMuc2NhbGUubWF4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgdGhpcy5zY2FsZS5taW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5zY2FsZS5taW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gdGhpcy5zY2FsZS5taW4pO3kgKj0gdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tO3kgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0geTtyZXR1cm4geTtcbiAgICB9O3RoaXMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHZhciB4ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgICAgICB5ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICB9O3RoaXMuZHJhd1NwbGluZSA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgIHZhciB4Q29vcmRzID0gW107Z3V0dGVyTGVmdCA9IHByb3AuZ3V0dGVyTGVmdCwgZ3V0dGVyUmlnaHQgPSBwcm9wLmd1dHRlclJpZ2h0LCBobWFyZ2luID0gcHJvcC5obWFyZ2luLCBpbnRlcnZhbCA9ICh0aGlzLmdyYXBoV2lkdGggLSAyICogaG1hcmdpbikgLyAoY29vcmRzLmxlbmd0aCAtIDEpLCBjb29yZHNTcGxpbmUgPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKGNvb3Jkc1tpXSkgPT0gJ29iamVjdCcgJiYgY29vcmRzW2ldICYmIGNvb3Jkc1tpXS5sZW5ndGggPT0gMikge1xuICAgICAgICAgIGNvb3Jkc1tpXSA9IE51bWJlcihjb29yZHNbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgUCA9IFtjb29yZHNbMF1dO2ZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIFAucHVzaChjb29yZHNbaV0pO1xuICAgICAgfVxuICAgICAgUC5wdXNoKGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0gKyAoY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXSAtIGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMl0pKTtmb3IgKHZhciBqID0gMTsgaiA8IFAubGVuZ3RoIC0gMjsgKytqKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTA7ICsrdCkge1xuICAgICAgICAgIHZhciB5Q29vcmQgPSBzcGxpbmUodCAvIDEwLCBQW2ogLSAxXSwgUFtqXSwgUFtqICsgMV0sIFBbaiArIDJdKTt4Q29vcmRzLnB1c2goKGogLSAxKSAqIGludGVydmFsICsgdCAqIChpbnRlcnZhbCAvIDEwKSArIGd1dHRlckxlZnQgKyBobWFyZ2luKTtjb29yZHNTcGxpbmUucHVzaChbeENvb3Jkc1t4Q29vcmRzLmxlbmd0aCAtIDFdLCB5Q29vcmRdKTtpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29vcmRzU3BsaW5lW2luZGV4XS5wdXNoKFt4Q29vcmRzW3hDb29yZHMubGVuZ3RoIC0gMV0sIHlDb29yZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29vcmRzU3BsaW5lLnB1c2goWyhqIC0gMSkgKiBpbnRlcnZhbCArIGd1dHRlckxlZnQgKyBobWFyZ2luLCBQW2pdXSk7aWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29vcmRzU3BsaW5lLnB1c2goWyhqIC0gMSkgKiBpbnRlcnZhbCArIGd1dHRlckxlZnQgKyBobWFyZ2luLCBQW2pdXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzcGxpbmUodCwgUDAsIFAxLCBQMiwgUDMpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgyICogUDEgKyAoMCAtIFAwICsgUDIpICogdCArICgoMiAqIFAwIC0gNSAqIFAxICsgNCAqIFAyIC0gUDMpICogKHQgKiB0KSArICgwIC0gUDAgKyAzICogUDEgLSAzICogUDIgKyBQMykgKiAodCAqIHQgKiB0KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb3Jkc1NwbGluZTtcbiAgICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ29sb3JzID0geyBjb2xvcnM6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuY29sb3JzKSwgZmlsbGVkQ29sb3JzOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmZpbGxlZENvbG9ycyksIGJhY2tncm91bmRHcmlkQ29sb3I6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciksIGhpZ2hsaWdodEZpbGw6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksIGJhY2tncm91bmRDb2xvcjogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpIH07XG4gICAgICB9XG4gICAgICB2YXIgY29sb3JzID0gcHJvcC5jb2xvcnM7aWYgKGNvbG9ycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbG9yc1tpXSA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogY29sb3JzW2ldIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZmlsbGVkQ29sb3JzID0gcHJvcC5maWxsZWRDb2xvcnM7aWYgKGZpbGxlZENvbG9ycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGxlZENvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGZpbGxlZENvbG9yc1tpXSA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogZmlsbGVkQ29sb3JzW2ldIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciB9KTtwcm9wLmhpZ2hsaWdodEZpbGwgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuaGlnaGxpZ2h0RmlsbCB9KTtwcm9wLmJhY2tncm91bmRDb2xvciA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogcHJvcC5iYWNrZ3JvdW5kQ29sb3IgfSk7XG4gICAgfTt0aGlzLmRyYXdMYWJlbHNBYm92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9wLmxhYmVsc0Fib3ZlKSB7XG4gICAgICAgIHZhciBkYXRhX3NlcSA9IFJHLlNWRy5hcnJheUxpbmVhcml6ZSh0aGlzLmRhdGEpLFxuICAgICAgICAgICAgc2VxID0gMDtmb3IgKHZhciBkYXRhc2V0ID0gMDsgZGF0YXNldCA8IHRoaXMuY29vcmRzLmxlbmd0aDsgKytkYXRhc2V0LCBzZXErKykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHNbZGF0YXNldF0ubGVuZ3RoOyArK2ksIHNlcSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7IG9iamVjdDogdGhpcywgbnVtOiB0aGlzLmRhdGFbZGF0YXNldF1baV0udG9GaXhlZChwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHMpLCBwcmVwZW5kOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUHJlID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVVbml0c1ByZSA6IG51bGwsIGFwcGVuZDogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1Bvc3QgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdCA6IG51bGwsIHBvaW50OiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVBvaW50ID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVQb2ludCA6IG51bGwsIHRob3VzYW5kOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVRob3VzYW5kID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVUaG91c2FuZCA6IG51bGwsIGZvcm1hdHRlcjogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicgPyBwcm9wLmxhYmVsc0Fib3ZlRm9ybWF0dGVyIDogbnVsbCB9KTtpZiAocHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljICYmIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYy5sZW5ndGggJiYgKHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgc3RyID0gcHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljW3NlcV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyAmJiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMubGVuZ3RoICYmIHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbc2VxXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpY1tzZXFdICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogc3RyLCB4OiBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2RhdGFzZXRdW2ldWzBdKSArIHByb3AubGFiZWxzQWJvdmVPZmZzZXR4LCB5OiBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2RhdGFzZXRdW2ldWzFdKSArIHByb3AubGFiZWxzQWJvdmVPZmZzZXR5LCBoYWxpZ246IHByb3AubGFiZWxzQWJvdmVIYWxpZ24sIHZhbGlnbjogcHJvcC5sYWJlbHNBYm92ZVZhbGlnbiwgZm9udDogcHJvcC5sYWJlbHNBYm92ZUZvbnQgfHwgcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC5sYWJlbHNBYm92ZVNpemUgfHwgcHJvcC50ZXh0U2l6ZSwgYm9sZDogcHJvcC5sYWJlbHNBYm92ZUJvbGQgfHwgcHJvcC50ZXh0Qm9sZCwgaXRhbGljOiBwcm9wLmxhYmVsc0Fib3ZlSXRhbGljIHx8IHByb3AudGV4dEl0YWxpYywgY29sb3I6IHByb3AubGFiZWxzQWJvdmVDb2xvciB8fCBwcm9wLnRleHRDb2xvciwgYmFja2dyb3VuZDogcHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmQgfHwgbnVsbCwgcGFkZGluZzogcHJvcC5sYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nIHx8IDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICB9XG4gICAgICBSRy5TVkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy50cmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgZnJhbWUgPSAxLFxuICAgICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgNjAsXG4gICAgICAgICAgb2JqID0gdGhpczt0aGlzLmlzVHJhY2UgPSB0cnVlO3RoaXMuZHJhdygpO3ZhciBjbGlwUGF0aCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmRlZnMsIHR5cGU6ICdjbGlwUGF0aCcsIGF0dHI6IHsgaWQ6ICd0cmFjZS1lZmZlY3QtY2xpcCcgfSB9KTt2YXIgY2xpcFBhdGhSZWN0ID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogY2xpcFBhdGgsIHR5cGU6ICdyZWN0JywgYXR0cjogeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9IH0pO3ZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZSsrIC8gZnJhbWVzICogb2JqLndpZHRoO2NsaXBQYXRoUmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCk7aWYgKGZyYW1lIDw9IGZyYW1lcykge1xuICAgICAgICAgIFJHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC5jYWxsYmFjaykge1xuICAgICAgICAgIG9wdC5jYWxsYmFjayhvYmopO1xuICAgICAgICB9XG4gICAgICB9O2l0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gICAgfTtmb3IgKGkgaW4gY29uZi5vcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGhpcztcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcubGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///213\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Pie = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'pie';this.angles = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, colors: ['#f66', '#6f6', '#66f', '#ff6', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], strokestyle: 'rgba(0,0,0,0)', margin: 3, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], labelsSticks: true, labelsSticksHlength: 50, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, exploded: 0, roundRobinMultiplier: 1, donut: false, donutWidth: 75, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centery);RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.max = RG.SVG.arrayMax(this.data);this.total = RG.SVG.arraySum(this.data);if (typeof prop.exploded === 'number' && prop.exploded > 0) {\n        var val = prop.exploded;prop.exploded = [];for (var i = 0; i < this.data.length; ++i) {\n          prop.exploded[i] = val;\n        }\n      }\n      this.drawSegments({ shadow: true });RG.SVG.drawTitle(this);if (prop.labelsSticks) {\n        this.drawLabelsSticks();\n      } else {\n        this.drawLabels();\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);var obj = this;document.body.addEventListener('mousedown', function (e) {\n        RG.SVG.removeHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawSegments = function (opt) {\n      var start = 0,\n          end = 0,\n          angle = 0,\n          sum = RG.SVG.arraySum(this.data),\n          segment = 0;for (var i = 0, len = this.data.length; i < len; ++i) {\n        var value = this.data[i] * prop.roundRobinMultiplier;start = angle;segment = value / sum * RG.SVG.TRIG.TWOPI;end = start + segment;var explosion = RG.SVG.TRIG.getRadiusEndPoint({ angle: start + segment / 2, r: prop.exploded[i] });var explosionX = explosion[1],\n            explosionY = explosion[0];this.angles[i] = { start: start, end: end, angle: end - start, halfway: (end - start) / 2 + start, cx: this.centerx + (parseFloat(explosionX) || 0), cy: this.centery - (parseFloat(explosionY) || 0), radius: this.radius };angle += end - start;\n      }\n      if (opt.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      for (var i = 0; i < this.angles.length; ++i) {\n        var path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius, start: this.angles[i].start, end: this.angles[i].end });if (prop.donut) {\n          var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: this.angles[i].cx, cy: this.angles[i].cy, r: this.radius - donutWidth, start: this.angles[i].end, end: this.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: this.angles[i].end - RG.SVG.TRIG.HALFPI, r: this.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + this.angles[i].cx, xy[1] + this.angles[i].cy) + donut_path + \" Z\";\n        } else {\n          path = path + \" L {1} {2} \".format(this.angles[i].cx, this.angles[i].cy) + \" Z\";\n        }\n        var arc = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: path, fill: prop.colors[i], stroke: prop.strokestyle, 'stroke-width': prop.linewidth, 'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '', 'data-index': i, 'data-value': value, 'data-start-angle': this.angles[i].start, 'data-end-angle': this.angles[i].end, 'data-radius': this.radius, filter: prop.shadow && opt.shadow ? 'url(#dropShadow)' : '' } });if (prop.shadow && opt.shadow) {\n          this.shadowNodes[i] = arc;\n        } else {\n          this.nodes[i] = arc;\n        }\n        if (prop.tooltips && prop.tooltips[i] && (!opt.shadow || !prop.shadow)) {\n          if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          (function (index, obj) {\n            arc.addEventListener(prop.tooltipsEvent, function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: index, sequentialIndex: index, text: prop.tooltips[index], event: e });obj.highlight(e.target);var highlight = RG.SVG.REG.get('highlight');if (prop.tooltipsEvent === 'mousemove') {\n                highlight.style.cursor = 'pointer';\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              arc.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(i, this);\n        }\n      }\n      if (prop.shadow && opt.shadow) {\n        this.redrawSegments();\n      }\n    };this.redrawSegments = function () {\n      this.drawSegments({ shadow: false });\n    };this.drawLabels = function () {\n      var angles = this.angles,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0; i < angles.length; ++i) {\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: angles[i].halfway - RG.SVG.TRIG.HALFPI, r: angles[i].radius + 15 });var x = endpoint[0] + angles[i].cx,\n            y = endpoint[1] + angles[i].cy,\n            valign,\n            halign;if (angles[i].halfway > 0 && angles[i].halfway < RG.SVG.TRIG.HALFPI) {\n          halign = 'left';valign = 'bottom';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI && angles[i].halfway < RG.SVG.TRIG.PI) {\n          halign = 'left';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI) {\n          halign = 'right';valign = 'top';\n        } else if (angles[i].halfway > RG.SVG.TRIG.HALFPI + RG.SVG.TRIG.PI && angles[i].halfway < RG.SVG.TRIG.TWOPI) {\n          halign = 'right';valign = 'top';\n        }\n        RG.SVG.text({ object: this, parent: this.svg.all, text: typeof labels[i] === 'string' ? labels[i] : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: valign, halign: halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });\n      }\n    };this.drawLabelsSticks = function () {\n      var labels_right = [],\n          labels_left = [],\n          labels_coords = [];for (var i = 0; i < this.angles.length; ++i) {\n        var angle = this.angles[i].start + (this.angles[i].end - this.angles[i].start) / 2 - RGraph.SVG.TRIG.HALFPI,\n            endpoint_inner = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 5 }),\n            endpoint_outer = RG.SVG.TRIG.getRadiusEndPoint({ angle: angle, r: this.radius + 20 }),\n            explosion = [typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i], ma.cos(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i]), ma.sin(angle) * (typeof prop.exploded === 'number' ? prop.exploded : prop.exploded[i])];labels_coords[i] = [];var labels = {};if (angle > RG.SVG.TRIG.HALFPI) {\n          var index = labels_left.length;labels_left[index] = [];labels_left[index].text = prop.labels[i];labels_left[index].halign = 'right';labels = labels_left;labels_coords[i].halign = 'right';\n        } else {\n          var index = labels_right.length;labels_right[index] = [];labels_right[index].text = prop.labels[i];labels_right[index].halign = 'right';labels = labels_right;labels_coords[i].halign = 'left';\n        }\n        endpoint_inner[0] += explosion[1] || 0;endpoint_inner[1] += explosion[2] || 0;endpoint_outer[0] += explosion[1] || 0;endpoint_outer[1] += explosion[2] || 0;var x, y;if (labels[index].text) {\n          var stick = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: 'M {1} {2} L {3} {4}'.format(this.centerx + endpoint_inner[0], this.centery + endpoint_inner[1], this.centerx + endpoint_outer[0], this.centery + endpoint_outer[1]), stroke: '#999', fill: 'rgba(0,0,0,0)' } });\n        }\n        if (stick) {\n          labels[index].stick = stick;\n        }\n        x = this.centerx + endpoint_outer[0] + (angle > 1.57 ? -50 : 50);y = this.centery + endpoint_outer[1];labels_coords[i].x = x;labels_coords[i].y = y;labels_coords[i].text = prop.labels[i];\n      }\n      var vspace_right = (this.height - prop.gutterTop - prop.gutterBottom) / labels_right.length;var vspace_left = (this.height - prop.gutterTop - prop.gutterBottom) / labels_left.length;x = y = 0;for (var i = 0; i < labels_right.length; ++i) {\n        if (labels_right[i] && labels_right[i].text) {\n          x = this.centerx + this.radius + 100;y = prop.gutterTop + vspace_right * i + vspace_right / 2;RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_right[i].text === 'string' ? labels_right[i].text : '', font: prop.textFont, size: prop.textSize, x: x, y: y, valign: 'center', halign: labels_right[i].text, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_right[i].stick.setAttribute('d', labels_right[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx + this.radius + prop.labelsSticksHlength));\n        }\n      }\n      for (var i = 0; i < labels_left.length; ++i) {\n        if (labels_left[i] && labels_left[i].text) {\n          x = this.centerx - this.radius - 100;y = this.height - (prop.gutterTop + vspace_left * i + vspace_left / 2);RGraph.SVG.text({ object: this, parent: this.svg.all, text: typeof labels_left[i].text === 'string' ? labels_left[i].text : '', font: prop.textFont, size: prop.textSize, x: x - 7, y: y, valign: 'center', halign: labels_left[i].halign, bold: prop.textBold, italic: prop.textItalic, color: prop.textColor });labels_left[i].stick.setAttribute('d', labels_left[i].stick.getAttribute('d') + ' H {3} L {1} {2} '.format(x - 5, y, this.centerx - this.radius - prop.labelsSticksHlength));\n        }\n      }\n    };this.highlight = function (segment) {\n      var highlight = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'path', attr: { d: segment.getAttribute('d'), fill: prop.highlightFill, stroke: prop.highlightStroke, 'stroke-width': prop.highlightLinewidth } });if (prop.tooltipsEvent === 'mousemove') {\n        highlight.addEventListener('mouseout', function (e) {\n          highlight.parentNode.removeChild(highlight);RG.SVG.hideTooltip();RG.SVG.REG.set('highlight', null);\n        }, false);\n      }\n      RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.roundRobin = function () {\n      var obj = this,\n          opt = arguments[0] || {},\n          data = RG.SVG.arrayClone(this.data),\n          prop = this.properties,\n          frame = 1,\n          frames = opt.frames || 30,\n          callback = typeof opt.callback === 'function' ? opt.callback : function () {},\n          dataSum = RG.SVG.arraySum(this.data),\n          textColor = prop.textColor;this.properties.textColor = 'rgba(0,0,0,0)';obj.draw();angles = RG.SVG.arrayClone(obj.angles);function iterator() {\n        prop.roundRobinMultiplier = 1 / frames * frame++;for (var i = 0; i < obj.angles.length; ++i) {\n          var value = obj.data[i];obj.angles[i].start = angles[i].start * prop.roundRobinMultiplier;obj.angles[i].end = angles[i].end * prop.roundRobinMultiplier;var segment = (obj.angles[i].end - obj.angles[i].start) / 2;var explodedX = ma.cos(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var explodedY = ma.sin(obj.angles[i].start + segment - RG.SVG.TRIG.HALFPI) * (prop.exploded[i] || 0);var path = RG.SVG.TRIG.getArcPath({ cx: obj.centerx + explodedX, cy: obj.centery + explodedY, r: obj.radius, start: obj.angles[i].start, end: obj.angles[i].end });if (prop.donut) {\n            var donutWidth = prop.donutWidth;var donut_path = RG.SVG.TRIG.getArcPath({ cx: obj.angles[i].cx, cy: obj.angles[i].cy, r: obj.radius - donutWidth, start: obj.angles[i].end, end: obj.angles[i].start, moveto: false, anticlockwise: true });var xy = RG.SVG.TRIG.getRadiusEndPoint({ angle: obj.angles[i].end - RG.SVG.TRIG.HALFPI, r: obj.radius - donutWidth });path = path + \" L {1} {2} \".format(xy[0] + obj.angles[i].cx, xy[1] + obj.angles[i].cy) + donut_path + \" Z\";\n          } else {\n            path = path + \" L {1} {2} \".format(obj.angles[i].cx, obj.angles[i].cy) + \" Z\";\n          }\n          path = path + \" L {1} {2} Z\".format(obj.centerx + explodedX, obj.centery + explodedY);if (obj.shadowNodes && obj.shadowNodes[i]) {\n            obj.shadowNodes[i].setAttribute('d', path);\n          }\n          obj.nodes[i].setAttribute('d', path);\n        }\n        if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else {\n          prop.textColor = textColor;RG.SVG.redraw(obj.svg);callback(obj);\n        }\n      }\n      iterator();return this;\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcucGllLmpzP2M3MzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQ7UkcuU1ZHLlBpZSA9IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IGksIHZhbHVlOiBhcmd1bWVudHNbMF1baV0gfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHsgb2JqZWN0OiB0aGlzLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmlkID0gY29uZi5pZDt0aGlzLnVpZCA9IFJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnID0gUkcuU1ZHLmNyZWF0ZVNWRyh7IGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIgfSk7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy53aWR0aCA9IE51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0ID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO3RoaXMuZGF0YSA9IGNvbmYuZGF0YTt0aGlzLnR5cGUgPSAncGllJzt0aGlzLmFuZ2xlcyA9IFtdO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O3RoaXMuZ3JhZGllbnRDb3VudGVyID0gMTt0aGlzLm5vZGVzID0gW107dGhpcy5zaGFkb3dOb2RlcyA9IFtdO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO3RoaXMucHJvcGVydGllcyA9IHsgY2VudGVyeDogbnVsbCwgY2VudGVyeTogbnVsbCwgcmFkaXVzOiBudWxsLCBndXR0ZXJMZWZ0OiAzNSwgZ3V0dGVyUmlnaHQ6IDM1LCBndXR0ZXJUb3A6IDM1LCBndXR0ZXJCb3R0b206IDM1LCBjb2xvcnM6IFsnI2Y2NicsICcjNmY2JywgJyM2NmYnLCAnI2ZmNicsICcjNmZmJywgJyNjY2MnLCAncGluaycsICdvcmFuZ2UnLCAnY3lhbicsICdtYXJvb24nLCAnb2xpdmUnLCAndGVhbCddLCBzdHJva2VzdHlsZTogJ3JnYmEoMCwwLDAsMCknLCBtYXJnaW46IDMsIHRleHRDb2xvcjogJ2JsYWNrJywgdGV4dEZvbnQ6ICdzYW5zLXNlcmlmJywgdGV4dFNpemU6IDEyLCB0ZXh0Qm9sZDogZmFsc2UsIHRleHRJdGFsaWM6IGZhbHNlLCBsYWJlbHM6IFtdLCBsYWJlbHNTdGlja3M6IHRydWUsIGxhYmVsc1N0aWNrc0hsZW5ndGg6IDUwLCBsaW5ld2lkdGg6IDEsIHRvb2x0aXBzOiBudWxsLCB0b29sdGlwc092ZXJyaWRlOiBudWxsLCB0b29sdGlwc0VmZmVjdDogJ2ZhZGUnLCB0b29sdGlwc0Nzc0NsYXNzOiAnUkdyYXBoX3Rvb2x0aXAnLCB0b29sdGlwc0V2ZW50OiAnY2xpY2snLCBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJywgaGlnaGxpZ2h0RmlsbDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsIGhpZ2hsaWdodExpbmV3aWR0aDogMSwgdGl0bGU6ICcnLCB0aXRsZVNpemU6IDE2LCB0aXRsZVg6IG51bGwsIHRpdGxlWTogbnVsbCwgdGl0bGVIYWxpZ246ICdjZW50ZXInLCB0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVDb2xvcjogJ2JsYWNrJywgdGl0bGVGb250OiBudWxsLCB0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZUl0YWxpYzogZmFsc2UsIHRpdGxlU3VidGl0bGU6ICcnLCB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsIHRpdGxlU3VidGl0bGVYOiBudWxsLCB0aXRsZVN1YnRpdGxlWTogbnVsbCwgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlU3VidGl0bGVWYWxpZ246IG51bGwsIHRpdGxlU3VidGl0bGVDb2xvcjogJyNhYWEnLCB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCwgdGl0bGVTdWJ0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZVN1YnRpdGxlSXRhbGljOiBmYWxzZSwgc2hhZG93OiBmYWxzZSwgc2hhZG93T2Zmc2V0eDogMiwgc2hhZG93T2Zmc2V0eTogMiwgc2hhZG93Qmx1cjogMiwgc2hhZG93T3BhY2l0eTogMC4yNSwgZXhwbG9kZWQ6IDAsIHJvdW5kUm9iaW5NdWx0aXBsaWVyOiAxLCBkb251dDogZmFsc2UsIGRvbnV0V2lkdGg6IDc1LCBrZXk6IG51bGwsIGtleUNvbG9yczogbnVsbCwga2V5T2Zmc2V0eDogMCwga2V5T2Zmc2V0eTogMCwga2V5VGV4dE9mZnNldHg6IDAsIGtleVRleHRPZmZzZXR5OiAtMSwga2V5VGV4dFNpemU6IG51bGwsIGtleVRleHRCb2xkOiBudWxsLCBrZXlUZXh0SXRhbGljOiBudWxsLCBhdHRyaWJ1dGlvbjogdHJ1ZSwgYXR0cmlidXRpb25YOiBudWxsLCBhdHRyaWJ1dGlvblk6IG51bGwsIGF0dHJpYnV0aW9uSHJlZjogbnVsbCwgYXR0cmlidXRpb25IYWxpZ246ICdyaWdodCcsIGF0dHJpYnV0aW9uVmFsaWduOiAnYm90dG9tJywgYXR0cmlidXRpb25TaXplOiA3LCBhdHRyaWJ1dGlvbkNvbG9yOiAnZ3JheScsIGF0dHJpYnV0aW9uRm9udDogJ3NhbnMtc2VyaWYnLCBhdHRyaWJ1dGlvbkl0YWxpYzogZmFsc2UsIGF0dHJpYnV0aW9uQm9sZDogZmFsc2UgfTtpZiAoUkcuU1ZHLkZYICYmIHR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7dGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgUkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7UkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5ncmFwaFdpZHRoID0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyTGVmdCAtIHByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbTt0aGlzLmNlbnRlcnggPSB0aGlzLmdyYXBoV2lkdGggLyAyICsgcHJvcC5ndXR0ZXJMZWZ0O3RoaXMuY2VudGVyeSA9IHRoaXMuZ3JhcGhIZWlnaHQgLyAyICsgcHJvcC5ndXR0ZXJUb3A7dGhpcy5yYWRpdXMgPSBtYS5taW4odGhpcy5ncmFwaFdpZHRoLCB0aGlzLmdyYXBoSGVpZ2h0KSAvIDI7dGhpcy5jZW50ZXJ4ID0gdHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ251bWJlcicgPyBwcm9wLmNlbnRlcnggOiB0aGlzLmNlbnRlcng7dGhpcy5jZW50ZXJ5ID0gdHlwZW9mIHByb3AuY2VudGVyeSA9PT0gJ251bWJlcicgPyBwcm9wLmNlbnRlcnkgOiB0aGlzLmNlbnRlcnk7dGhpcy5yYWRpdXMgPSB0eXBlb2YgcHJvcC5yYWRpdXMgPT09ICdudW1iZXInID8gcHJvcC5yYWRpdXMgOiB0aGlzLnJhZGl1cztpZiAodHlwZW9mIHByb3AucmFkaXVzID09PSAnc3RyaW5nJyAmJiBwcm9wLnJhZGl1cy5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5yYWRpdXMgKz0gcGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7aWYgKHR5cGVvZiBwcm9wLmNlbnRlcnggPT09ICdzdHJpbmcnICYmIHByb3AuY2VudGVyeC5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5jZW50ZXJ4ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ4KTtpZiAodHlwZW9mIHByb3AuY2VudGVyeSA9PT0gJ3N0cmluZycgJiYgcHJvcC5jZW50ZXJ5Lm1hdGNoKC9eXFwrfC1cXGQrJC8pKSB0aGlzLmNlbnRlcnkgKz0gcGFyc2VGbG9hdChwcm9wLmNlbnRlcnkpO1JHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoeyBvYmplY3Q6IHRoaXMgfSk7dGhpcy5wYXJzZUNvbG9ycygpO3RoaXMubWF4ID0gUkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YSk7dGhpcy50b3RhbCA9IFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGEpO2lmICh0eXBlb2YgcHJvcC5leHBsb2RlZCA9PT0gJ251bWJlcicgJiYgcHJvcC5leHBsb2RlZCA+IDApIHtcbiAgICAgICAgdmFyIHZhbCA9IHByb3AuZXhwbG9kZWQ7cHJvcC5leHBsb2RlZCA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcHJvcC5leHBsb2RlZFtpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U2VnbWVudHMoeyBzaGFkb3c6IHRydWUgfSk7UkcuU1ZHLmRyYXdUaXRsZSh0aGlzKTtpZiAocHJvcC5sYWJlbHNTdGlja3MpIHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzU3RpY2tzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcC5rZXkgIT09IG51bGwgJiYgUkcuU1ZHLmRyYXdLZXkpIHtcbiAgICAgICAgUkcuU1ZHLmRyYXdLZXkodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFSR3JhcGguU1ZHLmlzTnVsbChwcm9wLmtleSkpIHtcbiAgICAgICAgYWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7XG4gICAgICB9XG4gICAgICBSRy5TVkcuYXR0cmlidXRpb24odGhpcyk7dmFyIG9iaiA9IHRoaXM7ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBSRy5TVkcucmVtb3ZlSGlnaGxpZ2h0KG9iaik7XG4gICAgICB9LCBmYWxzZSk7UkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25kcmF3Jyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmRyYXdTZWdtZW50cyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHZhciBzdGFydCA9IDAsXG4gICAgICAgICAgZW5kID0gMCxcbiAgICAgICAgICBhbmdsZSA9IDAsXG4gICAgICAgICAgc3VtID0gUkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YSksXG4gICAgICAgICAgc2VnbWVudCA9IDA7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbaV0gKiBwcm9wLnJvdW5kUm9iaW5NdWx0aXBsaWVyO3N0YXJ0ID0gYW5nbGU7c2VnbWVudCA9IHZhbHVlIC8gc3VtICogUkcuU1ZHLlRSSUcuVFdPUEk7ZW5kID0gc3RhcnQgKyBzZWdtZW50O3ZhciBleHBsb3Npb24gPSBSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCh7IGFuZ2xlOiBzdGFydCArIHNlZ21lbnQgLyAyLCByOiBwcm9wLmV4cGxvZGVkW2ldIH0pO3ZhciBleHBsb3Npb25YID0gZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgZXhwbG9zaW9uWSA9IGV4cGxvc2lvblswXTt0aGlzLmFuZ2xlc1tpXSA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgYW5nbGU6IGVuZCAtIHN0YXJ0LCBoYWxmd2F5OiAoZW5kIC0gc3RhcnQpIC8gMiArIHN0YXJ0LCBjeDogdGhpcy5jZW50ZXJ4ICsgKHBhcnNlRmxvYXQoZXhwbG9zaW9uWCkgfHwgMCksIGN5OiB0aGlzLmNlbnRlcnkgLSAocGFyc2VGbG9hdChleHBsb3Npb25ZKSB8fCAwKSwgcmFkaXVzOiB0aGlzLnJhZGl1cyB9O2FuZ2xlICs9IGVuZCAtIHN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5zaGFkb3cpIHtcbiAgICAgICAgUkcuU1ZHLnNldFNoYWRvdyh7IG9iamVjdDogdGhpcywgb2Zmc2V0eDogcHJvcC5zaGFkb3dPZmZzZXR4LCBvZmZzZXR5OiBwcm9wLnNoYWRvd09mZnNldHksIGJsdXI6IHByb3Auc2hhZG93Qmx1ciwgb3BhY2l0eTogcHJvcC5zaGFkb3dPcGFjaXR5LCBpZDogJ2Ryb3BTaGFkb3cnIH0pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuZ2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgoeyBjeDogdGhpcy5hbmdsZXNbaV0uY3gsIGN5OiB0aGlzLmFuZ2xlc1tpXS5jeSwgcjogdGhpcy5yYWRpdXMsIHN0YXJ0OiB0aGlzLmFuZ2xlc1tpXS5zdGFydCwgZW5kOiB0aGlzLmFuZ2xlc1tpXS5lbmQgfSk7aWYgKHByb3AuZG9udXQpIHtcbiAgICAgICAgICB2YXIgZG9udXRXaWR0aCA9IHByb3AuZG9udXRXaWR0aDt2YXIgZG9udXRfcGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgoeyBjeDogdGhpcy5hbmdsZXNbaV0uY3gsIGN5OiB0aGlzLmFuZ2xlc1tpXS5jeSwgcjogdGhpcy5yYWRpdXMgLSBkb251dFdpZHRoLCBzdGFydDogdGhpcy5hbmdsZXNbaV0uZW5kLCBlbmQ6IHRoaXMuYW5nbGVzW2ldLnN0YXJ0LCBtb3ZldG86IGZhbHNlLCBhbnRpY2xvY2t3aXNlOiB0cnVlIH0pO3ZhciB4eSA9IFJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHsgYW5nbGU6IHRoaXMuYW5nbGVzW2ldLmVuZCAtIFJHLlNWRy5UUklHLkhBTEZQSSwgcjogdGhpcy5yYWRpdXMgLSBkb251dFdpZHRoIH0pO3BhdGggPSBwYXRoICsgXCIgTCB7MX0gezJ9IFwiLmZvcm1hdCh4eVswXSArIHRoaXMuYW5nbGVzW2ldLmN4LCB4eVsxXSArIHRoaXMuYW5nbGVzW2ldLmN5KSArIGRvbnV0X3BhdGggKyBcIiBaXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGggKyBcIiBMIHsxfSB7Mn0gXCIuZm9ybWF0KHRoaXMuYW5nbGVzW2ldLmN4LCB0aGlzLmFuZ2xlc1tpXS5jeSkgKyBcIiBaXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyYyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6IHBhdGgsIGZpbGw6IHByb3AuY29sb3JzW2ldLCBzdHJva2U6IHByb3Auc3Ryb2tlc3R5bGUsICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCwgJ2RhdGEtdG9vbHRpcCc6ICFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHMubGVuZ3RoID8gcHJvcC50b29sdGlwc1tpXSA6ICcnLCAnZGF0YS1pbmRleCc6IGksICdkYXRhLXZhbHVlJzogdmFsdWUsICdkYXRhLXN0YXJ0LWFuZ2xlJzogdGhpcy5hbmdsZXNbaV0uc3RhcnQsICdkYXRhLWVuZC1hbmdsZSc6IHRoaXMuYW5nbGVzW2ldLmVuZCwgJ2RhdGEtcmFkaXVzJzogdGhpcy5yYWRpdXMsIGZpbHRlcjogcHJvcC5zaGFkb3cgJiYgb3B0LnNoYWRvdyA/ICd1cmwoI2Ryb3BTaGFkb3cpJyA6ICcnIH0gfSk7aWYgKHByb3Auc2hhZG93ICYmIG9wdC5zaGFkb3cpIHtcbiAgICAgICAgICB0aGlzLnNoYWRvd05vZGVzW2ldID0gYXJjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm9kZXNbaV0gPSBhcmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwc1tpXSAmJiAoIW9wdC5zaGFkb3cgfHwgIXByb3Auc2hhZG93KSkge1xuICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgIT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICBwcm9wLnRvb2x0aXBzRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoZnVuY3Rpb24gKGluZGV4LCBvYmopIHtcbiAgICAgICAgICAgIGFyYy5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGluZGV4OiBpbmRleCwgc2VxdWVudGlhbEluZGV4OiBpbmRleCwgdGV4dDogcHJvcC50b29sdGlwc1tpbmRleF0sIGV2ZW50OiBlIH0pO29iai5oaWdobGlnaHQoZS50YXJnZXQpO3ZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7aWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICBhcmMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KShpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3Auc2hhZG93ICYmIG9wdC5zaGFkb3cpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdTZWdtZW50cygpO1xuICAgICAgfVxuICAgIH07dGhpcy5yZWRyYXdTZWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZHJhd1NlZ21lbnRzKHsgc2hhZG93OiBmYWxzZSB9KTtcbiAgICB9O3RoaXMuZHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbmdsZXMgPSB0aGlzLmFuZ2xlcyxcbiAgICAgICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGxhYmVscyA9IHByb3AubGFiZWxzO2ZvciAodmFyIGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBlbmRwb2ludCA9IFJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHsgYW5nbGU6IGFuZ2xlc1tpXS5oYWxmd2F5IC0gUkcuU1ZHLlRSSUcuSEFMRlBJLCByOiBhbmdsZXNbaV0ucmFkaXVzICsgMTUgfSk7dmFyIHggPSBlbmRwb2ludFswXSArIGFuZ2xlc1tpXS5jeCxcbiAgICAgICAgICAgIHkgPSBlbmRwb2ludFsxXSArIGFuZ2xlc1tpXS5jeSxcbiAgICAgICAgICAgIHZhbGlnbixcbiAgICAgICAgICAgIGhhbGlnbjtpZiAoYW5nbGVzW2ldLmhhbGZ3YXkgPiAwICYmIGFuZ2xlc1tpXS5oYWxmd2F5IDwgUkcuU1ZHLlRSSUcuSEFMRlBJKSB7XG4gICAgICAgICAgaGFsaWduID0gJ2xlZnQnO3ZhbGlnbiA9ICdib3R0b20nO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ2xlc1tpXS5oYWxmd2F5ID4gUkcuU1ZHLlRSSUcuSEFMRlBJICYmIGFuZ2xlc1tpXS5oYWxmd2F5IDwgUkcuU1ZHLlRSSUcuUEkpIHtcbiAgICAgICAgICBoYWxpZ24gPSAnbGVmdCc7dmFsaWduID0gJ3RvcCc7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVzW2ldLmhhbGZ3YXkgPiBSRy5TVkcuVFJJRy5QSSAmJiBhbmdsZXNbaV0uaGFsZndheSA8IFJHLlNWRy5UUklHLkhBTEZQSSArIFJHLlNWRy5UUklHLlBJKSB7XG4gICAgICAgICAgaGFsaWduID0gJ3JpZ2h0Jzt2YWxpZ24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIGlmIChhbmdsZXNbaV0uaGFsZndheSA+IFJHLlNWRy5UUklHLkhBTEZQSSArIFJHLlNWRy5UUklHLlBJICYmIGFuZ2xlc1tpXS5oYWxmd2F5IDwgUkcuU1ZHLlRSSUcuVFdPUEkpIHtcbiAgICAgICAgICBoYWxpZ24gPSAncmlnaHQnO3ZhbGlnbiA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogdHlwZW9mIGxhYmVsc1tpXSA9PT0gJ3N0cmluZycgPyBsYWJlbHNbaV0gOiAnJywgZm9udDogcHJvcC50ZXh0Rm9udCwgc2l6ZTogcHJvcC50ZXh0U2l6ZSwgeDogeCwgeTogeSwgdmFsaWduOiB2YWxpZ24sIGhhbGlnbjogaGFsaWduLCBib2xkOiBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHByb3AudGV4dEl0YWxpYywgY29sb3I6IHByb3AudGV4dENvbG9yIH0pO1xuICAgICAgfVxuICAgIH07dGhpcy5kcmF3TGFiZWxzU3RpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhYmVsc19yaWdodCA9IFtdLFxuICAgICAgICAgIGxhYmVsc19sZWZ0ID0gW10sXG4gICAgICAgICAgbGFiZWxzX2Nvb3JkcyA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmdsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZXNbaV0uc3RhcnQgKyAodGhpcy5hbmdsZXNbaV0uZW5kIC0gdGhpcy5hbmdsZXNbaV0uc3RhcnQpIC8gMiAtIFJHcmFwaC5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICBlbmRwb2ludF9pbm5lciA9IFJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHsgYW5nbGU6IGFuZ2xlLCByOiB0aGlzLnJhZGl1cyArIDUgfSksXG4gICAgICAgICAgICBlbmRwb2ludF9vdXRlciA9IFJHLlNWRy5UUklHLmdldFJhZGl1c0VuZFBvaW50KHsgYW5nbGU6IGFuZ2xlLCByOiB0aGlzLnJhZGl1cyArIDIwIH0pLFxuICAgICAgICAgICAgZXhwbG9zaW9uID0gW3R5cGVvZiBwcm9wLmV4cGxvZGVkID09PSAnbnVtYmVyJyA/IHByb3AuZXhwbG9kZWQgOiBwcm9wLmV4cGxvZGVkW2ldLCBtYS5jb3MoYW5nbGUpICogKHR5cGVvZiBwcm9wLmV4cGxvZGVkID09PSAnbnVtYmVyJyA/IHByb3AuZXhwbG9kZWQgOiBwcm9wLmV4cGxvZGVkW2ldKSwgbWEuc2luKGFuZ2xlKSAqICh0eXBlb2YgcHJvcC5leHBsb2RlZCA9PT0gJ251bWJlcicgPyBwcm9wLmV4cGxvZGVkIDogcHJvcC5leHBsb2RlZFtpXSldO2xhYmVsc19jb29yZHNbaV0gPSBbXTt2YXIgbGFiZWxzID0ge307aWYgKGFuZ2xlID4gUkcuU1ZHLlRSSUcuSEFMRlBJKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbGFiZWxzX2xlZnQubGVuZ3RoO2xhYmVsc19sZWZ0W2luZGV4XSA9IFtdO2xhYmVsc19sZWZ0W2luZGV4XS50ZXh0ID0gcHJvcC5sYWJlbHNbaV07bGFiZWxzX2xlZnRbaW5kZXhdLmhhbGlnbiA9ICdyaWdodCc7bGFiZWxzID0gbGFiZWxzX2xlZnQ7bGFiZWxzX2Nvb3Jkc1tpXS5oYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxhYmVsc19yaWdodC5sZW5ndGg7bGFiZWxzX3JpZ2h0W2luZGV4XSA9IFtdO2xhYmVsc19yaWdodFtpbmRleF0udGV4dCA9IHByb3AubGFiZWxzW2ldO2xhYmVsc19yaWdodFtpbmRleF0uaGFsaWduID0gJ3JpZ2h0JztsYWJlbHMgPSBsYWJlbHNfcmlnaHQ7bGFiZWxzX2Nvb3Jkc1tpXS5oYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZW5kcG9pbnRfaW5uZXJbMF0gKz0gZXhwbG9zaW9uWzFdIHx8IDA7ZW5kcG9pbnRfaW5uZXJbMV0gKz0gZXhwbG9zaW9uWzJdIHx8IDA7ZW5kcG9pbnRfb3V0ZXJbMF0gKz0gZXhwbG9zaW9uWzFdIHx8IDA7ZW5kcG9pbnRfb3V0ZXJbMV0gKz0gZXhwbG9zaW9uWzJdIHx8IDA7dmFyIHgsIHk7aWYgKGxhYmVsc1tpbmRleF0udGV4dCkge1xuICAgICAgICAgIHZhciBzdGljayA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6ICdNIHsxfSB7Mn0gTCB7M30gezR9Jy5mb3JtYXQodGhpcy5jZW50ZXJ4ICsgZW5kcG9pbnRfaW5uZXJbMF0sIHRoaXMuY2VudGVyeSArIGVuZHBvaW50X2lubmVyWzFdLCB0aGlzLmNlbnRlcnggKyBlbmRwb2ludF9vdXRlclswXSwgdGhpcy5jZW50ZXJ5ICsgZW5kcG9pbnRfb3V0ZXJbMV0pLCBzdHJva2U6ICcjOTk5JywgZmlsbDogJ3JnYmEoMCwwLDAsMCknIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0aWNrKSB7XG4gICAgICAgICAgbGFiZWxzW2luZGV4XS5zdGljayA9IHN0aWNrO1xuICAgICAgICB9XG4gICAgICAgIHggPSB0aGlzLmNlbnRlcnggKyBlbmRwb2ludF9vdXRlclswXSArIChhbmdsZSA+IDEuNTcgPyAtNTAgOiA1MCk7eSA9IHRoaXMuY2VudGVyeSArIGVuZHBvaW50X291dGVyWzFdO2xhYmVsc19jb29yZHNbaV0ueCA9IHg7bGFiZWxzX2Nvb3Jkc1tpXS55ID0geTtsYWJlbHNfY29vcmRzW2ldLnRleHQgPSBwcm9wLmxhYmVsc1tpXTtcbiAgICAgIH1cbiAgICAgIHZhciB2c3BhY2VfcmlnaHQgPSAodGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tKSAvIGxhYmVsc19yaWdodC5sZW5ndGg7dmFyIHZzcGFjZV9sZWZ0ID0gKHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbSkgLyBsYWJlbHNfbGVmdC5sZW5ndGg7eCA9IHkgPSAwO2ZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzX3JpZ2h0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsYWJlbHNfcmlnaHRbaV0gJiYgbGFiZWxzX3JpZ2h0W2ldLnRleHQpIHtcbiAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgKyAxMDA7eSA9IHByb3AuZ3V0dGVyVG9wICsgdnNwYWNlX3JpZ2h0ICogaSArIHZzcGFjZV9yaWdodCAvIDI7UkdyYXBoLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogdHlwZW9mIGxhYmVsc19yaWdodFtpXS50ZXh0ID09PSAnc3RyaW5nJyA/IGxhYmVsc19yaWdodFtpXS50ZXh0IDogJycsIGZvbnQ6IHByb3AudGV4dEZvbnQsIHNpemU6IHByb3AudGV4dFNpemUsIHg6IHgsIHk6IHksIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogbGFiZWxzX3JpZ2h0W2ldLnRleHQsIGJvbGQ6IHByb3AudGV4dEJvbGQsIGl0YWxpYzogcHJvcC50ZXh0SXRhbGljLCBjb2xvcjogcHJvcC50ZXh0Q29sb3IgfSk7bGFiZWxzX3JpZ2h0W2ldLnN0aWNrLnNldEF0dHJpYnV0ZSgnZCcsIGxhYmVsc19yaWdodFtpXS5zdGljay5nZXRBdHRyaWJ1dGUoJ2QnKSArICcgSCB7M30gTCB7MX0gezJ9ICcuZm9ybWF0KHggLSA1LCB5LCB0aGlzLmNlbnRlcnggKyB0aGlzLnJhZGl1cyArIHByb3AubGFiZWxzU3RpY2tzSGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsc19sZWZ0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsYWJlbHNfbGVmdFtpXSAmJiBsYWJlbHNfbGVmdFtpXS50ZXh0KSB7XG4gICAgICAgICAgeCA9IHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzIC0gMTAwO3kgPSB0aGlzLmhlaWdodCAtIChwcm9wLmd1dHRlclRvcCArIHZzcGFjZV9sZWZ0ICogaSArIHZzcGFjZV9sZWZ0IC8gMik7UkdyYXBoLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogdHlwZW9mIGxhYmVsc19sZWZ0W2ldLnRleHQgPT09ICdzdHJpbmcnID8gbGFiZWxzX2xlZnRbaV0udGV4dCA6ICcnLCBmb250OiBwcm9wLnRleHRGb250LCBzaXplOiBwcm9wLnRleHRTaXplLCB4OiB4IC0gNywgeTogeSwgdmFsaWduOiAnY2VudGVyJywgaGFsaWduOiBsYWJlbHNfbGVmdFtpXS5oYWxpZ24sIGJvbGQ6IHByb3AudGV4dEJvbGQsIGl0YWxpYzogcHJvcC50ZXh0SXRhbGljLCBjb2xvcjogcHJvcC50ZXh0Q29sb3IgfSk7bGFiZWxzX2xlZnRbaV0uc3RpY2suc2V0QXR0cmlidXRlKCdkJywgbGFiZWxzX2xlZnRbaV0uc3RpY2suZ2V0QXR0cmlidXRlKCdkJykgKyAnIEggezN9IEwgezF9IHsyfSAnLmZvcm1hdCh4IC0gNSwgeSwgdGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMgLSBwcm9wLmxhYmVsc1N0aWNrc0hsZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ3BhdGgnLCBhdHRyOiB7IGQ6IHNlZ21lbnQuZ2V0QXR0cmlidXRlKCdkJyksIGZpbGw6IHByb3AuaGlnaGxpZ2h0RmlsbCwgc3Ryb2tlOiBwcm9wLmhpZ2hsaWdodFN0cm9rZSwgJ3N0cm9rZS13aWR0aCc6IHByb3AuaGlnaGxpZ2h0TGluZXdpZHRoIH0gfSk7aWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgaGlnaGxpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1JHLlNWRy5oaWRlVG9vbHRpcCgpO1JHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLCBudWxsKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIGhpZ2hsaWdodCk7XG4gICAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyA9IHsgY29sb3JzOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksIGhpZ2hsaWdodEZpbGw6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCkgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvcnMgPSBwcm9wLmNvbG9ycztpZiAoY29sb3JzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29sb3JzW2ldID0gUkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBjb2xvcnNbaV0gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AuaGlnaGxpZ2h0RmlsbCA9IFJHLlNWRy5wYXJzZUNvbG9yUmFkaWFsKHsgb2JqZWN0OiB0aGlzLCBjb2xvcjogcHJvcC5oaWdobGlnaHRGaWxsIH0pO1xuICAgIH07dGhpcy5yb3VuZFJvYmluID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgIGRhdGEgPSBSRy5TVkcuYXJyYXlDbG9uZSh0aGlzLmRhdGEpLFxuICAgICAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgICAgZnJhbWUgPSAxLFxuICAgICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzAsXG4gICAgICAgICAgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0LmNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gb3B0LmNhbGxiYWNrIDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgZGF0YVN1bSA9IFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGEpLFxuICAgICAgICAgIHRleHRDb2xvciA9IHByb3AudGV4dENvbG9yO3RoaXMucHJvcGVydGllcy50ZXh0Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7b2JqLmRyYXcoKTthbmdsZXMgPSBSRy5TVkcuYXJyYXlDbG9uZShvYmouYW5nbGVzKTtmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgcHJvcC5yb3VuZFJvYmluTXVsdGlwbGllciA9IDEgLyBmcmFtZXMgKiBmcmFtZSsrO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmFuZ2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iai5kYXRhW2ldO29iai5hbmdsZXNbaV0uc3RhcnQgPSBhbmdsZXNbaV0uc3RhcnQgKiBwcm9wLnJvdW5kUm9iaW5NdWx0aXBsaWVyO29iai5hbmdsZXNbaV0uZW5kID0gYW5nbGVzW2ldLmVuZCAqIHByb3Aucm91bmRSb2Jpbk11bHRpcGxpZXI7dmFyIHNlZ21lbnQgPSAob2JqLmFuZ2xlc1tpXS5lbmQgLSBvYmouYW5nbGVzW2ldLnN0YXJ0KSAvIDI7dmFyIGV4cGxvZGVkWCA9IG1hLmNvcyhvYmouYW5nbGVzW2ldLnN0YXJ0ICsgc2VnbWVudCAtIFJHLlNWRy5UUklHLkhBTEZQSSkgKiAocHJvcC5leHBsb2RlZFtpXSB8fCAwKTt2YXIgZXhwbG9kZWRZID0gbWEuc2luKG9iai5hbmdsZXNbaV0uc3RhcnQgKyBzZWdtZW50IC0gUkcuU1ZHLlRSSUcuSEFMRlBJKSAqIChwcm9wLmV4cGxvZGVkW2ldIHx8IDApO3ZhciBwYXRoID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aCh7IGN4OiBvYmouY2VudGVyeCArIGV4cGxvZGVkWCwgY3k6IG9iai5jZW50ZXJ5ICsgZXhwbG9kZWRZLCByOiBvYmoucmFkaXVzLCBzdGFydDogb2JqLmFuZ2xlc1tpXS5zdGFydCwgZW5kOiBvYmouYW5nbGVzW2ldLmVuZCB9KTtpZiAocHJvcC5kb251dCkge1xuICAgICAgICAgICAgdmFyIGRvbnV0V2lkdGggPSBwcm9wLmRvbnV0V2lkdGg7dmFyIGRvbnV0X3BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHsgY3g6IG9iai5hbmdsZXNbaV0uY3gsIGN5OiBvYmouYW5nbGVzW2ldLmN5LCByOiBvYmoucmFkaXVzIC0gZG9udXRXaWR0aCwgc3RhcnQ6IG9iai5hbmdsZXNbaV0uZW5kLCBlbmQ6IG9iai5hbmdsZXNbaV0uc3RhcnQsIG1vdmV0bzogZmFsc2UsIGFudGljbG9ja3dpc2U6IHRydWUgfSk7dmFyIHh5ID0gUkcuU1ZHLlRSSUcuZ2V0UmFkaXVzRW5kUG9pbnQoeyBhbmdsZTogb2JqLmFuZ2xlc1tpXS5lbmQgLSBSRy5TVkcuVFJJRy5IQUxGUEksIHI6IG9iai5yYWRpdXMgLSBkb251dFdpZHRoIH0pO3BhdGggPSBwYXRoICsgXCIgTCB7MX0gezJ9IFwiLmZvcm1hdCh4eVswXSArIG9iai5hbmdsZXNbaV0uY3gsIHh5WzFdICsgb2JqLmFuZ2xlc1tpXS5jeSkgKyBkb251dF9wYXRoICsgXCIgWlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aCArIFwiIEwgezF9IHsyfSBcIi5mb3JtYXQob2JqLmFuZ2xlc1tpXS5jeCwgb2JqLmFuZ2xlc1tpXS5jeSkgKyBcIiBaXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBwYXRoICsgXCIgTCB7MX0gezJ9IFpcIi5mb3JtYXQob2JqLmNlbnRlcnggKyBleHBsb2RlZFgsIG9iai5jZW50ZXJ5ICsgZXhwbG9kZWRZKTtpZiAob2JqLnNoYWRvd05vZGVzICYmIG9iai5zaGFkb3dOb2Rlc1tpXSkge1xuICAgICAgICAgICAgb2JqLnNoYWRvd05vZGVzW2ldLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoubm9kZXNbaV0uc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lIDw9IGZyYW1lcykge1xuICAgICAgICAgIFJHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AudGV4dENvbG9yID0gdGV4dENvbG9yO1JHLlNWRy5yZWRyYXcob2JqLnN2Zyk7Y2FsbGJhY2sob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYgKGhpZ2hsaWdodCAmJiBoaWdobGlnaHQucGFyZW50Tm9kZSkge1xuICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIG51bGwpO1xuICAgIH07Zm9yIChpIGluIGNvbmYub3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnNldChpLCBjb25mLm9wdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtyZXR1cm4gdGhpcztcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcucGllLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///214\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Radar = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = RG.SVG.arrayClone(conf.data);this.originalData = RG.SVG.arrayClone(conf.data);this.type = 'radar';this.coords = [];this.coords2 = [];this.angles = [];this.angles2 = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.nodes = [];this.shadowNodes = [];this.max = 0;this.redraw = false;this.highlight_node = null;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { centerx: null, centery: null, radius: null, gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridRadialsCount: null, backgroundGridConcentricsCount: 5, backgroundGridLinewidth: 1, backgroundGridPoly: true, colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'], filled: false, filledOpacity: 0.25, filledAccumulative: true, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, labels: [], scaleVisible: true, scaleUnitsPre: '', scaleUnitsPost: '', scaleMax: null, scaleMin: 0, scalePoint: '.', scaleThousand: ',', scaleRound: false, scaleDecimals: 0, scaleFormatter: null, scaleBold: null, scaleItalic: null, scaleColor: null, scaleSize: null, scaleFont: null, scaleLabelsCount: 5, linewidth: 1, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, tickmarks: 'circle', tickmarksLinewidth: 1, tickmarksSize: 6, tickmarksFill: 'white', title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, grouping: 'normal', shadow: false, shadowOffsetx: 2, shadowOffsety: 2, shadowBlur: 2, shadowOpacity: 0.25, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');this.data = RG.SVG.arrayClone(this.originalData);if (this.data.length > 1) {\n        var len = this.data[0].length;for (var i = 1; i < this.data.length; ++i) {\n          if (this.data[i].length !== len) {\n            alert('[ERROR] The Radar chart datasets must have the same number of elements!');\n          }\n        }\n      }\n      this.angles = [];this.coords = [];this.coords2 = [];RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;this.centerx = this.graphWidth / 2 + prop.gutterLeft;this.centery = this.graphHeight / 2 + prop.gutterTop;this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n        this.data = [this.data];\n      }\n      for (var i = 0; i < this.data.length; ++i) {\n        for (var j = 0; j < this.data[i].length; ++j) {\n          if (typeof this.data[i][j] === 'string') {\n            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n          }\n        }\n      }\n      if (prop.filled && prop.filledAccumulative) {\n        for (var dataset = 1; dataset < this.data.length; ++dataset) {\n          for (var i = 0; i < this.data[dataset].length; ++i) {\n            this.data[dataset][i] += this.data[dataset - 1][i];\n          }\n        }\n      }\n      this.getMaxValue();RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();this.scale = RG.SVG.getScale({ object: this, numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount, unitsPre: prop.scaleUnitsPre, unitsPost: prop.scaleUnitsPost, max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max, min: prop.scaleMin, point: prop.scalePoint, round: prop.scaleRound, thousand: prop.scaleThousand, decimals: prop.scaleDecimals, strict: typeof prop.scaleMax === 'number', formatter: prop.scaleFormatter });this.max = this.scale.max;this.drawBackground();this.drawRadar();this.drawTickmarks();this.drawLabels();RG.SVG.drawTitle(this);this.addTooltipHotspots();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);if (prop.shadow) {\n        RG.SVG.setShadow({ object: this, offsetx: prop.shadowOffsetx, offsety: prop.shadowOffsety, blur: prop.shadowBlur, opacity: prop.shadowOpacity, id: 'dropShadow' });\n      }\n      var obj = this;doc.body.addEventListener('mousedown', function (e) {\n        obj.hideHighlight(obj);\n      }, false);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBackground = function () {\n      if (prop.backgroundGrid) {\n        var grid = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_grid', fill: 'rgba(0,0,0,0)', stroke: prop.backgroundGridColor } });var origin = 0 - RG.SVG.TRIG.PI / 2,\n            radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data[0].length,\n            concentrics = prop.backgroundGridConcentricsCount,\n            step = RG.SVG.TRIG.TWOPI / radials;if (radials > 0) {\n          for (var i = 0, len = radials; i < len; ++i) {\n            var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius, angle: origin + i * step });var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: str, stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n          }\n        }\n        if (concentrics > 0) {\n          if (prop.backgroundGridPoly) {\n            for (var j = 1; j <= concentrics; j++) {\n              for (var i = 0, len = radials, path = []; i < len; ++i) {\n                var coords = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), angle: origin + i * step });path.push('{1} {2} {3}'.format(i === 0 ? 'M' : 'L', coords.x, coords.y));\n              }\n              RG.SVG.create({ svg: this.svg, type: 'path', parent: grid, attr: { d: path.join(' ') + ' z', fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          } else {\n            for (var j = 1; j <= concentrics; j++) {\n              RG.SVG.create({ svg: this.svg, type: 'circle', parent: grid, attr: { cx: this.centerx, cy: this.centery, r: this.radius * (j / concentrics), fill: 'transparent', stroke: prop.backgroundGridColor, 'stroke-width': prop.backgroundGridLinewidth } });\n            }\n          }\n        }\n      }\n    };this.drawRadar = function (opt) {\n      for (var dataset = 0, len = this.data.length; dataset < len; ++dataset) {\n        this.coords2[dataset] = [];this.angles2[dataset] = [];var path = [];for (var i = 0, len2 = this.data[dataset].length; i < len2; ++i) {\n          var value = this.data[dataset][i];var xy = RG.SVG.TRIG.toCartesian({ cx: this.centerx, cy: this.centery, r: this.getRadius(this.data[dataset][i]), angle: RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI });xy.r = (value - prop.scaleMin) / (this.max - prop.scaleMin) * this.radius;xy.angle = RG.SVG.TRIG.TWOPI / len2 * i - RG.SVG.TRIG.HALFPI;path.push('{1}{2} {3}'.format(i === 0 ? 'M' : 'L', xy.x, xy.y));this.angles.push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.angles2[dataset].push({ cx: this.centerx, cy: this.centery, r: xy.r, angle: xy.angle });this.coords.push([xy.x, xy.y]);this.coords2[dataset].push([xy.x, xy.y]);\n        }\n        if (dataset > 0 && prop.filled && prop.filledAccumulative) {\n          path.push('L {1} {2}'.format(this.coords2[dataset][0][0], this.coords2[dataset][0][1]));path.push('M {1} {2}'.format(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]));for (var i = this.coords2[dataset - 1].length - 1; i >= 0; --i) {\n            path.push('L {1} {2}'.format(this.coords2[dataset - 1][i][0], this.coords2[dataset - 1][i][1]));\n          }\n          this.redraw = true;\n        } else {\n          path.push('z');\n        }\n        var path = RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: prop.filled ? prop.colors[dataset] : 'transparent', 'fill-opacity': prop.filledOpacity, 'stroke-width': prop.linewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '', filter: prop.shadow ? 'url(#dropShadow)' : '' } });path.setAttribute('data-dataset', dataset);\n      }\n      this.redrawRadar();\n    };this.redrawRadar = function () {\n      if (this.redraw) {\n        this.redraw = false;for (var dataset = 0; dataset < this.coords2.length; ++dataset) {\n          var path = [];for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            if (i === 0) {\n              path.push('M {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            } else {\n              path.push('L {1} {2}'.format(this.coords2[dataset][i][0], this.coords2[dataset][i][1]));\n            }\n          }\n          path.push('z');\n          RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path.join(\" \"), stroke: prop.colors[dataset], fill: 'transparent', 'stroke-width': prop.linewidth } });\n        }\n      }\n    };this.drawTickmarks = function () {\n      var group = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph_radar_tickmarks' } });for (var i = 0; i < this.coords2.length; ++i) {\n        for (var j = 0; j < this.coords2[i].length; ++j) {\n          if (prop.tickmarks === 'circle' || prop.tickmarks === 'filledcircle') {\n            var c = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[i][j][0], cy: this.coords2[i][j][1], r: prop.tickmarksSize, fill: prop.tickmarks === 'filledcircle' ? prop.colors[i] : prop.tickmarksFill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth, 'clip-path': this.isTrace ? 'url(#trace-effect-clip)' : '' } });c.setAttribute('data-dataset', i);c.setAttribute('data-index', j);\n          } else if (prop.tickmarks === 'rect' || prop.tickmarks === 'filledrect') {\n            var halfTickmarkSize = prop.tickmarksSize / 2;var fill = _typeof(prop.tickmarksFill) === 'object' && prop.tickmarksFill[i] ? prop.tickmarksFill[i] : prop.tickmarksFill;var s = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: this.coords2[i][j][0] - halfTickmarkSize, y: this.coords2[i][j][1] - halfTickmarkSize, width: prop.tickmarksSize, height: prop.tickmarksSize, fill: prop.tickmarks === 'filledrect' ? prop.colors[i] : fill, stroke: prop.colors[i], 'stroke-width': prop.tickmarksLinewidth } });s.setAttribute('data-dataset', i);s.setAttribute('data-index', j);\n          }\n        }\n      }\n    };this.drawLabels = function () {\n      var angles = this.angles2,\n          prop = this.properties,\n          labels = prop.labels;for (var i = 0, len = labels.length; i < len; ++i) {\n        if (!labels[i]) {\n          continue;\n        }\n        var endpoint = RG.SVG.TRIG.getRadiusEndPoint({ angle: RG.SVG.TRIG.TWOPI / labels.length * i - RG.SVG.TRIG.HALFPI, r: this.radius + 15 });var x = endpoint[0] + this.centerx,\n            y = endpoint[1] + this.centery;if (i / len < 0.5) {\n          halign = 'left';\n        } else {\n          halign = 'right';\n        }\n        if (i / len < 0.25 || i / len > 0.75) {\n          valign = 'bottom';\n        } else {\n          valign = 'top';\n        }\n        if (i / len === 0) {\n          halign = 'center';\n        }\n        if (i / len === 0.25) {\n          valign = 'center';\n        }\n        if (i / len === 0.5) {\n          halign = 'center';\n        }\n        if (i / len === 0.75) {\n          valign = 'center';\n        }\n        RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: labels[i], size: typeof prop.labelsSize === 'number' ? prop.labelsSize : prop.textSize, x: x, y: y, halign: halign, valign: 'center', color: prop.labelsColor || prop.textColor, bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold, italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic, font: prop.labelsFont || prop.textFont });\n      }\n      if (prop.scaleVisible) {\n        for (var i = 0; i < this.scale.labels.length; ++i) {\n          var x = this.centerx;var y = this.centery - this.radius / this.scale.labels.length * (i + 1);RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: this.scale.labels[i], size: prop.scaleSize || prop.textSize - 2, x: x, y: y, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n        }\n        var str = RG.SVG.numberFormat({ object: this, num: this.scale.min.toFixed(prop.scaleDecimals), prepend: prop.scaleUnitsPre, append: prop.scaleUnitsPost, point: prop.scalePoint, thousand: prop.scaleThousand, formatter: prop.scaleFormatter });RG.SVG.text({ object: this, svg: this.svg, parent: this.svg.all, text: str, size: prop.scaleSize || prop.textSize - 2, x: this.centerx, y: this.centery, halign: 'center', valign: 'center', background: 'rgba(255,255,255,0.7)', padding: 2, color: prop.scaleColor || prop.textColor, bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold, italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic, font: prop.scaleFont || prop.textFont });\n      }\n    };this.highlight = function (circle) {\n      circle.setAttribute('fill', prop.highlightFill);circle.setAttribute('stroke', prop.highlightStroke);circle.setAttribute('stroke-width', prop.highlightLinewidth);this.highlight_node = circle;RG.SVG.REG.set('highlight', circle);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), highlightFill: RG.SVG.arrayClone(prop.highlightFill) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorRadial({ object: this, color: colors[i] });\n        }\n      }\n      prop.highlightFill = RG.SVG.parseColorRadial({ object: this, color: prop.highlightFill });\n    };this.getMaxValue = function () {\n      var max = 0;if (prop.filled && prop.filledAccumulative) {\n        this.max = RG.SVG.arrayMax(this.data[this.data.length - 1]);\n      } else {\n        for (var dataset = 0, max = 0; dataset < this.data.length; ++dataset) {\n          this.max = ma.max(this.max, RG.SVG.arrayMax(this.data[dataset]));\n        }\n      }\n    };this.getRadius = function (value) {\n      return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n    };this.addTooltipHotspots = function () {\n      if (prop.tooltips && prop.tooltips.length > 0) {\n        if (prop.tooltipsEvent !== 'mousemove') {\n          prop.tooltipsEvent = 'click';\n        }\n        var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'rgraph-radar-tooltip-hotspots' } });for (var dataset = 0, seq = 0; dataset < this.coords2.length; ++dataset) {\n          for (var i = 0; i < this.coords2[dataset].length; ++i) {\n            var circle = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: this.coords2[dataset][i][0], cy: this.coords2[dataset][i][1], r: prop.tickmarksSize, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0, 'data-sequential-index': seq }, style: { cursor: prop['tooltips'][seq] ? 'pointer' : 'default' } });(function (dataset, index, seq, obj) {\n              if (prop.tooltips[seq]) {\n                circle.addEventListener(prop.tooltipsEvent, function (e) {\n                  var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__sequentialIndex__ === seq) {\n                    return;\n                  }\n                  RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: prop.tooltips[seq], event: e });obj.highlight(this);\n                }, false);if (prop.tooltipsEvent === 'click') {\n                  circle.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                  }, false);\n                }\n              }\n            })(dataset, i, seq++, this);\n          }\n        }\n      }\n    };this.roundRobin = function () {};this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = this.hideHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && this.highlight_node) {\n        this.highlight_node.setAttribute('fill', 'transparent');this.highlight_node.setAttribute('stroke', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };this.trace = function () {\n      var opt = arguments[0] || {},\n          frame = 1,\n          frames = opt.frames || 120,\n          obj = this;\n      step = 360 / frames;this.isTrace = true;this.draw();var clipPath = RG.SVG.create({ svg: this.svg, parent: this.svg.defs, type: 'clipPath', attr: { id: 'trace-effect-clip' } });clipPathArcPath = RG.SVG.TRIG.getArcPath2({ cx: this.angles[0].cx, cy: this.angles[0].cy, r: this.angles[0].r * 2, start: 0, end: 0 });var clipPathArc = RG.SVG.create({ svg: this.svg, parent: clipPath, type: 'path', attr: { d: clipPathArcPath } });var iterator = function iterator() {\n        var width = frame++ / frames * obj.width;var deg = 360 / frames * frame++,\n            rad = RG.SVG.TRIG.TWOPI / 360 * deg;\n        clipPathArc.setAttribute('d', RG.SVG.TRIG.getArcPath2({ cx: obj.angles[0].cx, cy: obj.angles[0].cy, r: obj.angles[0].r * 2, start: 0, end: rad }));if (frame <= frames) {\n          RG.SVG.FX.update(iterator);\n        } else if (opt.callback) {\n          opt.callback(obj);\n        }\n      };iterator();return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcucmFkYXIuanM/NWFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5TVkcgPSBSR3JhcGguU1ZHIHx8IHt9OyhmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBtYSA9IE1hdGgsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBkb2MgPSBkb2N1bWVudDtSRy5TVkcuUmFkYXIgPSBmdW5jdGlvbiAoY29uZikge1xuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChpIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHsgb2JqZWN0OiB0aGlzLCBuYW1lOiBpLCB2YWx1ZTogYXJndW1lbnRzWzBdW2ldIH0pO25hbWUgPSByZXQubmFtZTt2YWx1ZSA9IHJldC52YWx1ZTt0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7IG9iamVjdDogdGhpcywgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO25hbWUgPSByZXQubmFtZTt2YWx1ZSA9IHJldC52YWx1ZTt0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07dGhpcy5pZCA9IGNvbmYuaWQ7dGhpcy51aWQgPSBSRy5TVkcuY3JlYXRlVUlEKCk7dGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLnN2ZyA9IFJHLlNWRy5jcmVhdGVTVkcoeyBjb250YWluZXI6IHRoaXMuY29udGFpbmVyIH0pO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMud2lkdGggPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTt0aGlzLmhlaWdodCA9IE51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTt0aGlzLmRhdGEgPSBSRy5TVkcuYXJyYXlDbG9uZShjb25mLmRhdGEpO3RoaXMub3JpZ2luYWxEYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29uZi5kYXRhKTt0aGlzLnR5cGUgPSAncmFkYXInO3RoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHMyID0gW107dGhpcy5hbmdsZXMgPSBbXTt0aGlzLmFuZ2xlczIgPSBbXTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMub3JpZ2luYWxDb2xvcnMgPSB7fTt0aGlzLmdyYWRpZW50Q291bnRlciA9IDE7dGhpcy5ub2RlcyA9IFtdO3RoaXMuc2hhZG93Tm9kZXMgPSBbXTt0aGlzLm1heCA9IDA7dGhpcy5yZWRyYXcgPSBmYWxzZTt0aGlzLmhpZ2hsaWdodF9ub2RlID0gbnVsbDtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXMgPSB7IGNlbnRlcng6IG51bGwsIGNlbnRlcnk6IG51bGwsIHJhZGl1czogbnVsbCwgZ3V0dGVyTGVmdDogMzUsIGd1dHRlclJpZ2h0OiAzNSwgZ3V0dGVyVG9wOiAzNSwgZ3V0dGVyQm90dG9tOiAzNSwgYmFja2dyb3VuZEdyaWQ6IHRydWUsIGJhY2tncm91bmRHcmlkQ29sb3I6ICcjZGRkJywgYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQ6IG51bGwsIGJhY2tncm91bmRHcmlkQ29uY2VudHJpY3NDb3VudDogNSwgYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6IDEsIGJhY2tncm91bmRHcmlkUG9seTogdHJ1ZSwgY29sb3JzOiBbJ3JlZCcsICdibGFjaycsICdvcmFuZ2UnLCAnZ3JlZW4nLCAnIzZmZicsICcjY2NjJywgJ3BpbmsnLCAnb3JhbmdlJywgJ2N5YW4nLCAnbWFyb29uJywgJ29saXZlJywgJ3RlYWwnXSwgZmlsbGVkOiBmYWxzZSwgZmlsbGVkT3BhY2l0eTogMC4yNSwgZmlsbGVkQWNjdW11bGF0aXZlOiB0cnVlLCB0ZXh0Q29sb3I6ICdibGFjaycsIHRleHRGb250OiAnc2Fucy1zZXJpZicsIHRleHRTaXplOiAxMiwgdGV4dEJvbGQ6IGZhbHNlLCB0ZXh0SXRhbGljOiBmYWxzZSwgbGFiZWxzOiBbXSwgc2NhbGVWaXNpYmxlOiB0cnVlLCBzY2FsZVVuaXRzUHJlOiAnJywgc2NhbGVVbml0c1Bvc3Q6ICcnLCBzY2FsZU1heDogbnVsbCwgc2NhbGVNaW46IDAsIHNjYWxlUG9pbnQ6ICcuJywgc2NhbGVUaG91c2FuZDogJywnLCBzY2FsZVJvdW5kOiBmYWxzZSwgc2NhbGVEZWNpbWFsczogMCwgc2NhbGVGb3JtYXR0ZXI6IG51bGwsIHNjYWxlQm9sZDogbnVsbCwgc2NhbGVJdGFsaWM6IG51bGwsIHNjYWxlQ29sb3I6IG51bGwsIHNjYWxlU2l6ZTogbnVsbCwgc2NhbGVGb250OiBudWxsLCBzY2FsZUxhYmVsc0NvdW50OiA1LCBsaW5ld2lkdGg6IDEsIHRvb2x0aXBzOiBudWxsLCB0b29sdGlwc092ZXJyaWRlOiBudWxsLCB0b29sdGlwc0VmZmVjdDogJ2ZhZGUnLCB0b29sdGlwc0Nzc0NsYXNzOiAnUkdyYXBoX3Rvb2x0aXAnLCB0b29sdGlwc0V2ZW50OiAnbW91c2Vtb3ZlJywgaGlnaGxpZ2h0U3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLCBoaWdobGlnaHRMaW5ld2lkdGg6IDEsIHRpY2ttYXJrczogJ2NpcmNsZScsIHRpY2ttYXJrc0xpbmV3aWR0aDogMSwgdGlja21hcmtzU2l6ZTogNiwgdGlja21hcmtzRmlsbDogJ3doaXRlJywgdGl0bGU6ICcnLCB0aXRsZVNpemU6IDE2LCB0aXRsZVg6IG51bGwsIHRpdGxlWTogbnVsbCwgdGl0bGVIYWxpZ246ICdjZW50ZXInLCB0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVDb2xvcjogJ2JsYWNrJywgdGl0bGVGb250OiBudWxsLCB0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZUl0YWxpYzogZmFsc2UsIHRpdGxlU3VidGl0bGU6ICcnLCB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsIHRpdGxlU3VidGl0bGVYOiBudWxsLCB0aXRsZVN1YnRpdGxlWTogbnVsbCwgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlU3VidGl0bGVWYWxpZ246IG51bGwsIHRpdGxlU3VidGl0bGVDb2xvcjogJyNhYWEnLCB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCwgdGl0bGVTdWJ0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZVN1YnRpdGxlSXRhbGljOiBmYWxzZSwgZ3JvdXBpbmc6ICdub3JtYWwnLCBzaGFkb3c6IGZhbHNlLCBzaGFkb3dPZmZzZXR4OiAyLCBzaGFkb3dPZmZzZXR5OiAyLCBzaGFkb3dCbHVyOiAyLCBzaGFkb3dPcGFjaXR5OiAwLjI1LCBrZXk6IG51bGwsIGtleUNvbG9yczogbnVsbCwga2V5T2Zmc2V0eDogMCwga2V5T2Zmc2V0eTogMCwga2V5VGV4dE9mZnNldHg6IDAsIGtleVRleHRPZmZzZXR5OiAtMSwga2V5VGV4dFNpemU6IG51bGwsIGtleVRleHRCb2xkOiBudWxsLCBrZXlUZXh0SXRhbGljOiBudWxsLCBhdHRyaWJ1dGlvbjogdHJ1ZSwgYXR0cmlidXRpb25YOiBudWxsLCBhdHRyaWJ1dGlvblk6IG51bGwsIGF0dHJpYnV0aW9uSHJlZjogbnVsbCwgYXR0cmlidXRpb25IYWxpZ246ICdyaWdodCcsIGF0dHJpYnV0aW9uVmFsaWduOiAnYm90dG9tJywgYXR0cmlidXRpb25TaXplOiA3LCBhdHRyaWJ1dGlvbkNvbG9yOiAnZ3JheScsIGF0dHJpYnV0aW9uRm9udDogJ3NhbnMtc2VyaWYnLCBhdHRyaWJ1dGlvbkl0YWxpYzogZmFsc2UsIGF0dHJpYnV0aW9uQm9sZDogZmFsc2UgfTtpZiAoUkcuU1ZHLkZYICYmIHR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7dGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgUkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7dGhpcy5kYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUodGhpcy5vcmlnaW5hbERhdGEpO2lmICh0aGlzLmRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5kYXRhWzBdLmxlbmd0aDtmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0ubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgICAgIGFsZXJ0KCdbRVJST1JdIFRoZSBSYWRhciBjaGFydCBkYXRhc2V0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbmdsZXMgPSBbXTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29vcmRzMiA9IFtdO1JHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO3RoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207dGhpcy5jZW50ZXJ4ID0gdGhpcy5ncmFwaFdpZHRoIC8gMiArIHByb3AuZ3V0dGVyTGVmdDt0aGlzLmNlbnRlcnkgPSB0aGlzLmdyYXBoSGVpZ2h0IC8gMiArIHByb3AuZ3V0dGVyVG9wO3RoaXMucmFkaXVzID0gbWEubWluKHRoaXMuZ3JhcGhXaWR0aCwgdGhpcy5ncmFwaEhlaWdodCkgLyAyO3RoaXMuY2VudGVyeCA9IHR5cGVvZiBwcm9wLmNlbnRlcnggPT09ICdudW1iZXInID8gcHJvcC5jZW50ZXJ4IDogdGhpcy5jZW50ZXJ4O3RoaXMuY2VudGVyeSA9IHR5cGVvZiBwcm9wLmNlbnRlcnkgPT09ICdudW1iZXInID8gcHJvcC5jZW50ZXJ5IDogdGhpcy5jZW50ZXJ5O3RoaXMucmFkaXVzID0gdHlwZW9mIHByb3AucmFkaXVzID09PSAnbnVtYmVyJyA/IHByb3AucmFkaXVzIDogdGhpcy5yYWRpdXM7aWYgKHR5cGVvZiBwcm9wLnJhZGl1cyA9PT0gJ3N0cmluZycgJiYgcHJvcC5yYWRpdXMubWF0Y2goL15cXCt8LVxcZCskLykpIHRoaXMucmFkaXVzICs9IHBhcnNlRmxvYXQocHJvcC5yYWRpdXMpO2lmICh0eXBlb2YgcHJvcC5jZW50ZXJ4ID09PSAnc3RyaW5nJyAmJiBwcm9wLmNlbnRlcngubWF0Y2goL15cXCt8LVxcZCskLykpIHRoaXMuY2VudGVyeSArPSBwYXJzZUZsb2F0KHByb3AuY2VudGVyeCk7aWYgKHR5cGVvZiBwcm9wLmNlbnRlcnkgPT09ICdzdHJpbmcnICYmIHByb3AuY2VudGVyeS5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5jZW50ZXJ4ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ5KTtpZiAoUkcuU1ZHLmlzQXJyYXkodGhpcy5kYXRhKSAmJiAodHlwZW9mIHRoaXMuZGF0YVswXSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMuZGF0YVswXSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFt0aGlzLmRhdGFdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXSA9IFJHLlNWRy5zdHJpbmdzVG9OdW1iZXJzKHRoaXMuZGF0YVtpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcC5maWxsZWQgJiYgcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpIHtcbiAgICAgICAgZm9yICh2YXIgZGF0YXNldCA9IDE7IGRhdGFzZXQgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2RhdGFzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2RhdGFzZXRdW2ldICs9IHRoaXMuZGF0YVtkYXRhc2V0IC0gMV1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmdldE1heFZhbHVlKCk7UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7IG9iamVjdDogdGhpcyB9KTt0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5zY2FsZSA9IFJHLlNWRy5nZXRTY2FsZSh7IG9iamVjdDogdGhpcywgbnVtbGFiZWxzOiB0eXBlb2YgcHJvcC5zY2FsZUxhYmVsc0NvdW50ID09PSAnbnVtYmVyJyA/IHByb3Auc2NhbGVMYWJlbHNDb3VudCA6IHByb3AuYmFja2dyb3VuZEdyaWRDb25jZW50cmljQ291bnQsIHVuaXRzUHJlOiBwcm9wLnNjYWxlVW5pdHNQcmUsIHVuaXRzUG9zdDogcHJvcC5zY2FsZVVuaXRzUG9zdCwgbWF4OiB0eXBlb2YgcHJvcC5zY2FsZU1heCA9PT0gJ251bWJlcicgPyBwcm9wLnNjYWxlTWF4IDogdGhpcy5tYXgsIG1pbjogcHJvcC5zY2FsZU1pbiwgcG9pbnQ6IHByb3Auc2NhbGVQb2ludCwgcm91bmQ6IHByb3Auc2NhbGVSb3VuZCwgdGhvdXNhbmQ6IHByb3Auc2NhbGVUaG91c2FuZCwgZGVjaW1hbHM6IHByb3Auc2NhbGVEZWNpbWFscywgc3RyaWN0OiB0eXBlb2YgcHJvcC5zY2FsZU1heCA9PT0gJ251bWJlcicsIGZvcm1hdHRlcjogcHJvcC5zY2FsZUZvcm1hdHRlciB9KTt0aGlzLm1heCA9IHRoaXMuc2NhbGUubWF4O3RoaXMuZHJhd0JhY2tncm91bmQoKTt0aGlzLmRyYXdSYWRhcigpO3RoaXMuZHJhd1RpY2ttYXJrcygpO3RoaXMuZHJhd0xhYmVscygpO1JHLlNWRy5kcmF3VGl0bGUodGhpcyk7dGhpcy5hZGRUb29sdGlwSG90c3BvdHMoKTtpZiAodHlwZW9mIHByb3Aua2V5ICE9PSBudWxsICYmIFJHLlNWRy5kcmF3S2V5KSB7XG4gICAgICAgIFJHLlNWRy5kcmF3S2V5KHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghUkdyYXBoLlNWRy5pc051bGwocHJvcC5rZXkpKSB7XG4gICAgICAgIGFsZXJ0KCdUaGUgZHJhd0tleSgpIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0IC0gaGF2ZSB5b3UgZm9yZ290dGVuIHRvIGluY2x1ZGUgdGhlIGtleSBsaWJyYXJ5PycpO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLmF0dHJpYnV0aW9uKHRoaXMpO2lmIChwcm9wLnNoYWRvdykge1xuICAgICAgICBSRy5TVkcuc2V0U2hhZG93KHsgb2JqZWN0OiB0aGlzLCBvZmZzZXR4OiBwcm9wLnNoYWRvd09mZnNldHgsIG9mZnNldHk6IHByb3Auc2hhZG93T2Zmc2V0eSwgYmx1cjogcHJvcC5zaGFkb3dCbHVyLCBvcGFjaXR5OiBwcm9wLnNoYWRvd09wYWNpdHksIGlkOiAnZHJvcFNoYWRvdycgfSk7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcztkb2MuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBvYmouaGlkZUhpZ2hsaWdodChvYmopO1xuICAgICAgfSwgZmFsc2UpO1JHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy5kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9wLmJhY2tncm91bmRHcmlkKSB7XG4gICAgICAgIHZhciBncmlkID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAnZycsIGF0dHI6IHsgY2xhc3NOYW1lOiAncmdyYXBoX3JhZGFyX2dyaWQnLCBmaWxsOiAncmdiYSgwLDAsMCwwKScsIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yIH0gfSk7dmFyIG9yaWdpbiA9IDAgLSBSRy5TVkcuVFJJRy5QSSAvIDIsXG4gICAgICAgICAgICByYWRpYWxzID0gdHlwZW9mIHByb3AuYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQgPT09ICdudW1iZXInID8gcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNDb3VudCA6IHRoaXMuZGF0YVswXS5sZW5ndGgsXG4gICAgICAgICAgICBjb25jZW50cmljcyA9IHByb3AuYmFja2dyb3VuZEdyaWRDb25jZW50cmljc0NvdW50LFxuICAgICAgICAgICAgc3RlcCA9IFJHLlNWRy5UUklHLlRXT1BJIC8gcmFkaWFscztpZiAocmFkaWFscyA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFkaWFsczsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oeyBjeDogdGhpcy5jZW50ZXJ4LCBjeTogdGhpcy5jZW50ZXJ5LCByOiB0aGlzLnJhZGl1cywgYW5nbGU6IG9yaWdpbiArIGkgKiBzdGVwIH0pO3ZhciBzdHIgPSAnTSB7MX0gezJ9IEwgezN9IHs0fScuZm9ybWF0KHRoaXMuY2VudGVyeCwgdGhpcy5jZW50ZXJ5LCBjb29yZHMueCwgY29vcmRzLnkpO1JHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncGF0aCcsIHBhcmVudDogZ3JpZCwgYXR0cjogeyBkOiBzdHIsIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5iYWNrZ3JvdW5kR3JpZExpbmV3aWR0aCB9IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uY2VudHJpY3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHByb3AuYmFja2dyb3VuZEdyaWRQb2x5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBjb25jZW50cmljczsgaisrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYWRpYWxzLCBwYXRoID0gW107IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBSRy5TVkcuVFJJRy50b0NhcnRlc2lhbih7IGN4OiB0aGlzLmNlbnRlcngsIGN5OiB0aGlzLmNlbnRlcnksIHI6IHRoaXMucmFkaXVzICogKGogLyBjb25jZW50cmljcyksIGFuZ2xlOiBvcmlnaW4gKyBpICogc3RlcCB9KTtwYXRoLnB1c2goJ3sxfSB7Mn0gezN9Jy5mb3JtYXQoaSA9PT0gMCA/ICdNJyA6ICdMJywgY29vcmRzLngsIGNvb3Jkcy55KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdwYXRoJywgcGFyZW50OiBncmlkLCBhdHRyOiB7IGQ6IHBhdGguam9pbignICcpICsgJyB6JywgZmlsbDogJ3RyYW5zcGFyZW50Jywgc3Ryb2tlOiBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IsICdzdHJva2Utd2lkdGgnOiBwcm9wLmJhY2tncm91bmRHcmlkTGluZXdpZHRoIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGNvbmNlbnRyaWNzOyBqKyspIHtcbiAgICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdjaXJjbGUnLCBwYXJlbnQ6IGdyaWQsIGF0dHI6IHsgY3g6IHRoaXMuY2VudGVyeCwgY3k6IHRoaXMuY2VudGVyeSwgcjogdGhpcy5yYWRpdXMgKiAoaiAvIGNvbmNlbnRyaWNzKSwgZmlsbDogJ3RyYW5zcGFyZW50Jywgc3Ryb2tlOiBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IsICdzdHJva2Utd2lkdGgnOiBwcm9wLmJhY2tncm91bmRHcmlkTGluZXdpZHRoIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTt0aGlzLmRyYXdSYWRhciA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIGZvciAodmFyIGRhdGFzZXQgPSAwLCBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoOyBkYXRhc2V0IDwgbGVuOyArK2RhdGFzZXQpIHtcbiAgICAgICAgdGhpcy5jb29yZHMyW2RhdGFzZXRdID0gW107dGhpcy5hbmdsZXMyW2RhdGFzZXRdID0gW107dmFyIHBhdGggPSBbXTtmb3IgKHZhciBpID0gMCwgbGVuMiA9IHRoaXMuZGF0YVtkYXRhc2V0XS5sZW5ndGg7IGkgPCBsZW4yOyArK2kpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbZGF0YXNldF1baV07dmFyIHh5ID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oeyBjeDogdGhpcy5jZW50ZXJ4LCBjeTogdGhpcy5jZW50ZXJ5LCByOiB0aGlzLmdldFJhZGl1cyh0aGlzLmRhdGFbZGF0YXNldF1baV0pLCBhbmdsZTogUkcuU1ZHLlRSSUcuVFdPUEkgLyBsZW4yICogaSAtIFJHLlNWRy5UUklHLkhBTEZQSSB9KTt4eS5yID0gKHZhbHVlIC0gcHJvcC5zY2FsZU1pbikgLyAodGhpcy5tYXggLSBwcm9wLnNjYWxlTWluKSAqIHRoaXMucmFkaXVzO3h5LmFuZ2xlID0gUkcuU1ZHLlRSSUcuVFdPUEkgLyBsZW4yICogaSAtIFJHLlNWRy5UUklHLkhBTEZQSTtwYXRoLnB1c2goJ3sxfXsyfSB7M30nLmZvcm1hdChpID09PSAwID8gJ00nIDogJ0wnLCB4eS54LCB4eS55KSk7dGhpcy5hbmdsZXMucHVzaCh7IGN4OiB0aGlzLmNlbnRlcngsIGN5OiB0aGlzLmNlbnRlcnksIHI6IHh5LnIsIGFuZ2xlOiB4eS5hbmdsZSB9KTt0aGlzLmFuZ2xlczJbZGF0YXNldF0ucHVzaCh7IGN4OiB0aGlzLmNlbnRlcngsIGN5OiB0aGlzLmNlbnRlcnksIHI6IHh5LnIsIGFuZ2xlOiB4eS5hbmdsZSB9KTt0aGlzLmNvb3Jkcy5wdXNoKFt4eS54LCB4eS55XSk7dGhpcy5jb29yZHMyW2RhdGFzZXRdLnB1c2goW3h5LngsIHh5LnldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldCA+IDAgJiYgcHJvcC5maWxsZWQgJiYgcHJvcC5maWxsZWRBY2N1bXVsYXRpdmUpIHtcbiAgICAgICAgICBwYXRoLnB1c2goJ0wgezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzMltkYXRhc2V0XVswXVswXSwgdGhpcy5jb29yZHMyW2RhdGFzZXRdWzBdWzFdKSk7cGF0aC5wdXNoKCdNIHsxfSB7Mn0nLmZvcm1hdCh0aGlzLmNvb3JkczJbZGF0YXNldCAtIDFdWzBdWzBdLCB0aGlzLmNvb3JkczJbZGF0YXNldCAtIDFdWzBdWzFdKSk7Zm9yICh2YXIgaSA9IHRoaXMuY29vcmRzMltkYXRhc2V0IC0gMV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaCgnTCB7MX0gezJ9Jy5mb3JtYXQodGhpcy5jb29yZHMyW2RhdGFzZXQgLSAxXVtpXVswXSwgdGhpcy5jb29yZHMyW2RhdGFzZXQgLSAxXVtpXVsxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKCd6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ3BhdGgnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgYXR0cjogeyBkOiBwYXRoLmpvaW4oXCIgXCIpLCBzdHJva2U6IHByb3AuY29sb3JzW2RhdGFzZXRdLCBmaWxsOiBwcm9wLmZpbGxlZCA/IHByb3AuY29sb3JzW2RhdGFzZXRdIDogJ3RyYW5zcGFyZW50JywgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuZmlsbGVkT3BhY2l0eSwgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLCAnY2xpcC1wYXRoJzogdGhpcy5pc1RyYWNlID8gJ3VybCgjdHJhY2UtZWZmZWN0LWNsaXApJyA6ICcnLCBmaWx0ZXI6IHByb3Auc2hhZG93ID8gJ3VybCgjZHJvcFNoYWRvdyknIDogJycgfSB9KTtwYXRoLnNldEF0dHJpYnV0ZSgnZGF0YS1kYXRhc2V0JywgZGF0YXNldCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZHJhd1JhZGFyKCk7XG4gICAgfTt0aGlzLnJlZHJhd1JhZGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucmVkcmF3KSB7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gZmFsc2U7Zm9yICh2YXIgZGF0YXNldCA9IDA7IGRhdGFzZXQgPCB0aGlzLmNvb3JkczIubGVuZ3RoOyArK2RhdGFzZXQpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMyW2RhdGFzZXRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBwYXRoLnB1c2goJ00gezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzMltkYXRhc2V0XVtpXVswXSwgdGhpcy5jb29yZHMyW2RhdGFzZXRdW2ldWzFdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXRoLnB1c2goJ0wgezF9IHsyfScuZm9ybWF0KHRoaXMuY29vcmRzMltkYXRhc2V0XVtpXVswXSwgdGhpcy5jb29yZHMyW2RhdGFzZXRdW2ldWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGgucHVzaCgneicpO1xuICAgICAgICAgIFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncGF0aCcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IGQ6IHBhdGguam9pbihcIiBcIiksIHN0cm9rZTogcHJvcC5jb2xvcnNbZGF0YXNldF0sIGZpbGw6ICd0cmFuc3BhcmVudCcsICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCB9IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTt0aGlzLmRyYXdUaWNrbWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHR5cGU6ICdnJywgYXR0cjogeyBjbGFzc05hbWU6ICdyZ3JhcGhfcmFkYXJfdGlja21hcmtzJyB9IH0pO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb29yZHMyW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKHByb3AudGlja21hcmtzID09PSAnY2lyY2xlJyB8fCBwcm9wLnRpY2ttYXJrcyA9PT0gJ2ZpbGxlZGNpcmNsZScpIHtcbiAgICAgICAgICAgIHZhciBjID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdjaXJjbGUnLCBwYXJlbnQ6IGdyb3VwLCBhdHRyOiB7IGN4OiB0aGlzLmNvb3JkczJbaV1bal1bMF0sIGN5OiB0aGlzLmNvb3JkczJbaV1bal1bMV0sIHI6IHByb3AudGlja21hcmtzU2l6ZSwgZmlsbDogcHJvcC50aWNrbWFya3MgPT09ICdmaWxsZWRjaXJjbGUnID8gcHJvcC5jb2xvcnNbaV0gOiBwcm9wLnRpY2ttYXJrc0ZpbGwsIHN0cm9rZTogcHJvcC5jb2xvcnNbaV0sICdzdHJva2Utd2lkdGgnOiBwcm9wLnRpY2ttYXJrc0xpbmV3aWR0aCwgJ2NsaXAtcGF0aCc6IHRoaXMuaXNUcmFjZSA/ICd1cmwoI3RyYWNlLWVmZmVjdC1jbGlwKScgOiAnJyB9IH0pO2Muc2V0QXR0cmlidXRlKCdkYXRhLWRhdGFzZXQnLCBpKTtjLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGopO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC50aWNrbWFya3MgPT09ICdyZWN0JyB8fCBwcm9wLnRpY2ttYXJrcyA9PT0gJ2ZpbGxlZHJlY3QnKSB7XG4gICAgICAgICAgICB2YXIgaGFsZlRpY2ttYXJrU2l6ZSA9IHByb3AudGlja21hcmtzU2l6ZSAvIDI7dmFyIGZpbGwgPSBfdHlwZW9mKHByb3AudGlja21hcmtzRmlsbCkgPT09ICdvYmplY3QnICYmIHByb3AudGlja21hcmtzRmlsbFtpXSA/IHByb3AudGlja21hcmtzRmlsbFtpXSA6IHByb3AudGlja21hcmtzRmlsbDt2YXIgcyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncmVjdCcsIHBhcmVudDogZ3JvdXAsIGF0dHI6IHsgeDogdGhpcy5jb29yZHMyW2ldW2pdWzBdIC0gaGFsZlRpY2ttYXJrU2l6ZSwgeTogdGhpcy5jb29yZHMyW2ldW2pdWzFdIC0gaGFsZlRpY2ttYXJrU2l6ZSwgd2lkdGg6IHByb3AudGlja21hcmtzU2l6ZSwgaGVpZ2h0OiBwcm9wLnRpY2ttYXJrc1NpemUsIGZpbGw6IHByb3AudGlja21hcmtzID09PSAnZmlsbGVkcmVjdCcgPyBwcm9wLmNvbG9yc1tpXSA6IGZpbGwsIHN0cm9rZTogcHJvcC5jb2xvcnNbaV0sICdzdHJva2Utd2lkdGgnOiBwcm9wLnRpY2ttYXJrc0xpbmV3aWR0aCB9IH0pO3Muc2V0QXR0cmlidXRlKCdkYXRhLWRhdGFzZXQnLCBpKTtzLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5kcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFuZ2xlcyA9IHRoaXMuYW5nbGVzMixcbiAgICAgICAgICBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGxhYmVscyA9IHByb3AubGFiZWxzO2ZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKCFsYWJlbHNbaV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCh7IGFuZ2xlOiBSRy5TVkcuVFJJRy5UV09QSSAvIGxhYmVscy5sZW5ndGggKiBpIC0gUkcuU1ZHLlRSSUcuSEFMRlBJLCByOiB0aGlzLnJhZGl1cyArIDE1IH0pO3ZhciB4ID0gZW5kcG9pbnRbMF0gKyB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICB5ID0gZW5kcG9pbnRbMV0gKyB0aGlzLmNlbnRlcnk7aWYgKGkgLyBsZW4gPCAwLjUpIHtcbiAgICAgICAgICBoYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAvIGxlbiA8IDAuMjUgfHwgaSAvIGxlbiA+IDAuNzUpIHtcbiAgICAgICAgICB2YWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZ24gPSAndG9wJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAvIGxlbiA9PT0gMCkge1xuICAgICAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIC8gbGVuID09PSAwLjI1KSB7XG4gICAgICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgLyBsZW4gPT09IDAuNSkge1xuICAgICAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIC8gbGVuID09PSAwLjc1KSB7XG4gICAgICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgUkcuU1ZHLnRleHQoeyBvYmplY3Q6IHRoaXMsIHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0ZXh0OiBsYWJlbHNbaV0sIHNpemU6IHR5cGVvZiBwcm9wLmxhYmVsc1NpemUgPT09ICdudW1iZXInID8gcHJvcC5sYWJlbHNTaXplIDogcHJvcC50ZXh0U2l6ZSwgeDogeCwgeTogeSwgaGFsaWduOiBoYWxpZ24sIHZhbGlnbjogJ2NlbnRlcicsIGNvbG9yOiBwcm9wLmxhYmVsc0NvbG9yIHx8IHByb3AudGV4dENvbG9yLCBib2xkOiB0eXBlb2YgcHJvcC5sYWJlbHNCb2xkID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc0JvbGQgOiBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHR5cGVvZiBwcm9wLmxhYmVsc0l0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsIGZvbnQ6IHByb3AubGFiZWxzRm9udCB8fCBwcm9wLnRleHRGb250IH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByb3Auc2NhbGVWaXNpYmxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY2FsZS5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuY2VudGVyeDt2YXIgeSA9IHRoaXMuY2VudGVyeSAtIHRoaXMucmFkaXVzIC8gdGhpcy5zY2FsZS5sYWJlbHMubGVuZ3RoICogKGkgKyAxKTtSRy5TVkcudGV4dCh7IG9iamVjdDogdGhpcywgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHRleHQ6IHRoaXMuc2NhbGUubGFiZWxzW2ldLCBzaXplOiBwcm9wLnNjYWxlU2l6ZSB8fCBwcm9wLnRleHRTaXplIC0gMiwgeDogeCwgeTogeSwgaGFsaWduOiAnY2VudGVyJywgdmFsaWduOiAnY2VudGVyJywgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsIHBhZGRpbmc6IDIsIGNvbG9yOiBwcm9wLnNjYWxlQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3IsIGJvbGQ6IHR5cGVvZiBwcm9wLnNjYWxlQm9sZCA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5zY2FsZUJvbGQgOiBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHR5cGVvZiBwcm9wLnNjYWxlSXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLnNjYWxlSXRhbGljIDogcHJvcC50ZXh0SXRhbGljLCBmb250OiBwcm9wLnNjYWxlRm9udCB8fCBwcm9wLnRleHRGb250IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHIgPSBSRy5TVkcubnVtYmVyRm9ybWF0KHsgb2JqZWN0OiB0aGlzLCBudW06IHRoaXMuc2NhbGUubWluLnRvRml4ZWQocHJvcC5zY2FsZURlY2ltYWxzKSwgcHJlcGVuZDogcHJvcC5zY2FsZVVuaXRzUHJlLCBhcHBlbmQ6IHByb3Auc2NhbGVVbml0c1Bvc3QsIHBvaW50OiBwcm9wLnNjYWxlUG9pbnQsIHRob3VzYW5kOiBwcm9wLnNjYWxlVGhvdXNhbmQsIGZvcm1hdHRlcjogcHJvcC5zY2FsZUZvcm1hdHRlciB9KTtSRy5TVkcudGV4dCh7IG9iamVjdDogdGhpcywgc3ZnOiB0aGlzLnN2ZywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIHRleHQ6IHN0ciwgc2l6ZTogcHJvcC5zY2FsZVNpemUgfHwgcHJvcC50ZXh0U2l6ZSAtIDIsIHg6IHRoaXMuY2VudGVyeCwgeTogdGhpcy5jZW50ZXJ5LCBoYWxpZ246ICdjZW50ZXInLCB2YWxpZ246ICdjZW50ZXInLCBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgcGFkZGluZzogMiwgY29sb3I6IHByb3Auc2NhbGVDb2xvciB8fCBwcm9wLnRleHRDb2xvciwgYm9sZDogdHlwZW9mIHByb3Auc2NhbGVCb2xkID09PSAnYm9vbGVhbicgPyBwcm9wLnNjYWxlQm9sZCA6IHByb3AudGV4dEJvbGQsIGl0YWxpYzogdHlwZW9mIHByb3Auc2NhbGVJdGFsaWMgPT09ICdib29sZWFuJyA/IHByb3Auc2NhbGVJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsIGZvbnQ6IHByb3Auc2NhbGVGb250IHx8IHByb3AudGV4dEZvbnQgfSk7XG4gICAgICB9XG4gICAgfTt0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwcm9wLmhpZ2hsaWdodEZpbGwpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHByb3AuaGlnaGxpZ2h0U3Ryb2tlKTtjaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aCk7dGhpcy5oaWdobGlnaHRfbm9kZSA9IGNpcmNsZTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgY2lyY2xlKTtcbiAgICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ29sb3JzID0geyBjb2xvcnM6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuY29sb3JzKSwgaGlnaGxpZ2h0RmlsbDogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5oaWdobGlnaHRGaWxsKSB9O1xuICAgICAgfVxuICAgICAgdmFyIGNvbG9ycyA9IHByb3AuY29sb3JzO2lmIChjb2xvcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb2xvcnNbaV0gPSBSRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7IG9iamVjdDogdGhpcywgY29sb3I6IGNvbG9yc1tpXSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5oaWdobGlnaHRGaWxsID0gUkcuU1ZHLnBhcnNlQ29sb3JSYWRpYWwoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGwgfSk7XG4gICAgfTt0aGlzLmdldE1heFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1heCA9IDA7aWYgKHByb3AuZmlsbGVkICYmIHByb3AuZmlsbGVkQWNjdW11bGF0aXZlKSB7XG4gICAgICAgIHRoaXMubWF4ID0gUkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgZGF0YXNldCA9IDAsIG1heCA9IDA7IGRhdGFzZXQgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2RhdGFzZXQpIHtcbiAgICAgICAgICB0aGlzLm1heCA9IG1hLm1heCh0aGlzLm1heCwgUkcuU1ZHLmFycmF5TWF4KHRoaXMuZGF0YVtkYXRhc2V0XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTt0aGlzLmdldFJhZGl1cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSAtIHByb3Auc2NhbGVNaW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gcHJvcC5zY2FsZU1pbikgKiB0aGlzLnJhZGl1cztcbiAgICB9O3RoaXMuYWRkVG9vbHRpcEhvdHNwb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgIT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgcHJvcC50b29sdGlwc0V2ZW50ID0gJ2NsaWNrJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ2cnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgYXR0cjogeyBjbGFzc05hbWU6ICdyZ3JhcGgtcmFkYXItdG9vbHRpcC1ob3RzcG90cycgfSB9KTtmb3IgKHZhciBkYXRhc2V0ID0gMCwgc2VxID0gMDsgZGF0YXNldCA8IHRoaXMuY29vcmRzMi5sZW5ndGg7ICsrZGF0YXNldCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMyW2RhdGFzZXRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdjaXJjbGUnLCBwYXJlbnQ6IGdyb3VwLCBhdHRyOiB7IGN4OiB0aGlzLmNvb3JkczJbZGF0YXNldF1baV1bMF0sIGN5OiB0aGlzLmNvb3JkczJbZGF0YXNldF1baV1bMV0sIHI6IHByb3AudGlja21hcmtzU2l6ZSwgZmlsbDogJ3RyYW5zcGFyZW50Jywgc3Ryb2tlOiAndHJhbnNwYXJlbnQnLCAnc3Ryb2tlLXdpZHRoJzogMCwgJ2RhdGEtc2VxdWVudGlhbC1pbmRleCc6IHNlcSB9LCBzdHlsZTogeyBjdXJzb3I6IHByb3BbJ3Rvb2x0aXBzJ11bc2VxXSA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JyB9IH0pOyhmdW5jdGlvbiAoZGF0YXNldCwgaW5kZXgsIHNlcSwgb2JqKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzW3NlcV0pIHtcbiAgICAgICAgICAgICAgICBjaXJjbGUuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcCA9IFJHLlNWRy5SRUcuZ2V0KCd0b29sdGlwJyk7aWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fX3NlcXVlbnRpYWxJbmRleF9fID09PSBzZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoeyBvYmplY3Q6IG9iaiwgZGF0YXNldDogZGF0YXNldCwgaW5kZXg6IGluZGV4LCBzZXF1ZW50aWFsSW5kZXg6IHNlcSwgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLCBldmVudDogZSB9KTtvYmouaGlnaGxpZ2h0KHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtpZiAocHJvcC50b29sdGlwc0V2ZW50ID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICBjaXJjbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoZGF0YXNldCwgaSwgc2VxKyssIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5yb3VuZFJvYmluID0gZnVuY3Rpb24gKCkge307dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gdGhpcy5oaWRlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtpZiAoaGlnaGxpZ2h0ICYmIHRoaXMuaGlnaGxpZ2h0X25vZGUpIHtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKTt0aGlzLmhpZ2hsaWdodF9ub2RlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ3RyYW5zcGFyZW50Jyk7UkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIG51bGwpO1xuICAgICAgfVxuICAgIH07dGhpcy50cmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgZnJhbWUgPSAxLFxuICAgICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMTIwLFxuICAgICAgICAgIG9iaiA9IHRoaXM7XG4gICAgICBzdGVwID0gMzYwIC8gZnJhbWVzO3RoaXMuaXNUcmFjZSA9IHRydWU7dGhpcy5kcmF3KCk7dmFyIGNsaXBQYXRoID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuZGVmcywgdHlwZTogJ2NsaXBQYXRoJywgYXR0cjogeyBpZDogJ3RyYWNlLWVmZmVjdC1jbGlwJyB9IH0pO2NsaXBQYXRoQXJjUGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgyKHsgY3g6IHRoaXMuYW5nbGVzWzBdLmN4LCBjeTogdGhpcy5hbmdsZXNbMF0uY3ksIHI6IHRoaXMuYW5nbGVzWzBdLnIgKiAyLCBzdGFydDogMCwgZW5kOiAwIH0pO3ZhciBjbGlwUGF0aEFyYyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IGNsaXBQYXRoLCB0eXBlOiAncGF0aCcsIGF0dHI6IHsgZDogY2xpcFBhdGhBcmNQYXRoIH0gfSk7dmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lKysgLyBmcmFtZXMgKiBvYmoud2lkdGg7dmFyIGRlZyA9IDM2MCAvIGZyYW1lcyAqIGZyYW1lKyssXG4gICAgICAgICAgICByYWQgPSBSRy5TVkcuVFJJRy5UV09QSSAvIDM2MCAqIGRlZztcbiAgICAgICAgY2xpcFBhdGhBcmMuc2V0QXR0cmlidXRlKCdkJywgUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoeyBjeDogb2JqLmFuZ2xlc1swXS5jeCwgY3k6IG9iai5hbmdsZXNbMF0uY3ksIHI6IG9iai5hbmdsZXNbMF0uciAqIDIsIHN0YXJ0OiAwLCBlbmQ6IHJhZCB9KSk7aWYgKGZyYW1lIDw9IGZyYW1lcykge1xuICAgICAgICAgIFJHLlNWRy5GWC51cGRhdGUoaXRlcmF0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdC5jYWxsYmFjaykge1xuICAgICAgICAgIG9wdC5jYWxsYmFjayhvYmopO1xuICAgICAgICB9XG4gICAgICB9O2l0ZXJhdG9yKCk7cmV0dXJuIHRoaXM7XG4gICAgfTtmb3IgKGkgaW4gY29uZi5vcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O3JldHVybiB0aGlzO1xufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnN2Zy5yYWRhci5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///215\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.Rose = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = RG.SVG.arrayClone(conf.data);\n        this.originalData = RG.SVG.arrayClone(conf.data);\n        this.type = 'rose';\n        this.angles = [];\n        this.angles2 = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n        this.max = 0;\n        this.redraw = false;\n        this.highlight_node = null;\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundGrid: true,\n            backgroundGridColor: '#ddd',\n            backgroundGridRadialsCount: null,\n            backgroundGridRadialsAngleOffset: 0,\n            backgroundGridConcentricsCount: 5,\n            backgroundGridLinewidth: 1,\n\n            strokestyle: 'white',\n            colors: ['red', 'black', 'orange', 'green', '#6ff', '#ccc', 'pink', 'orange', 'cyan', 'maroon', 'olive', 'teal'],\n            colorsOpacity: 1,\n\n            textColor: 'black',\n            textFont: 'sans-serif',\n            textSize: 12,\n            textBold: false,\n            textItalic: false,\n\n            labels: [],\n            labelsFont: null,\n            labelsSize: null,\n            labelsColor: null,\n            labelsBold: null,\n            labelsItalic: null,\n            labelsRadialMargin: 10,\n            labelsAngleOffset: 0,\n\n            scaleVisible: true,\n            scaleUnitsPre: '',\n            scaleUnitsPost: '',\n            scaleMax: null,\n            scaleMin: 0,\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleRound: false,\n            scaleDecimals: 0,\n            scaleFormatter: null,\n            scaleBold: null,\n            scaleItalic: null,\n            scaleColor: null,\n            scaleSize: null,\n            scaleFont: null,\n            scaleLabelsCount: 5,\n\n            linewidth: 1,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            shadow: false,\n            shadowOffsetx: 2,\n            shadowOffsety: 2,\n            shadowBlur: 2,\n            shadowOpacity: 0.25,\n\n            margin: 0,\n            exploded: 0,\n\n            key: null,\n            keyColors: null,\n            keyOffsetx: 0,\n            keyOffsety: 0,\n            keyTextOffsetx: 0,\n            keyTextOffsety: -1,\n            keyTextSize: null,\n            keyTextBold: null,\n            keyTextItalic: null,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false,\n\n            segmentsAngleOffset: 0,\n            variant: 'normal'\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Reset the data back to the original values\n            this.data = RG.SVG.arrayClone(this.originalData);\n\n            // Reset the angles array to stop it growing\n            this.angles = [];\n\n            // Create the arrays in the angles2 array based on\n            // the data that we've been passed\n            for (var i = 0; i < this.data.length; ++i) {\n                this.angles2[i] = [];\n            }\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.graphHeight / 2 + prop.gutterTop;\n            this.radius = ma.min(this.graphWidth, this.graphHeight) / 2;\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            //\n            // Convert the nargin from strings to a number\n            //\n            if (typeof prop.margin === 'string' && prop.margin.match(/([0-9.]+)deg/)) {\n                prop.margin = RegExp.$1 / (180 / ma.PI);\n            }\n\n            /**\n            * Add the data to the .originalData array and work out the max value\n            * \n            * 2/5/14 Now also use this loop to ensure that the data pieces\n            *        are numbers\n            * \n            * **Is this necessary **\n            */\n            //if (RG.SVG.isArray(this.data) && (typeof this.data[0] === 'number' || typeof this.data[0] === 'string')) {\n            //    this.data = [this.data];\n            //}\n\n            // Convert strings to numbers\n            for (var i = 0; i < this.data.length; ++i) {\n                if (_typeof(this.data[i]) === 'object') {\n                    for (var j = 0; j < this.data[i].length; ++j) {\n                        if (typeof this.data[i][j] === 'string') {\n                            this.data[i][j] = RG.SVG.stringsToNumbers(this.data[i][j]);\n                        }\n                    }\n                } else if (typeof this.data[i] === 'string') {\n                    this.data[i] = RG.SVG.stringsToNumbers(this.data[i]);\n                }\n            }\n\n            // Get the max value. This sets the maximum value on the\n            // this.max variable\n            this.getMaxValue();\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            //\n            // Get the scale\n            //\n\n            this.scale = RG.SVG.getScale({\n                object: this,\n                numlabels: typeof prop.scaleLabelsCount === 'number' ? prop.scaleLabelsCount : prop.backgroundGridConcentricCount,\n                unitsPre: prop.scaleUnitsPre,\n                unitsPost: prop.scaleUnitsPost,\n                max: typeof prop.scaleMax === 'number' ? prop.scaleMax : this.max,\n                min: prop.scaleMin,\n                point: prop.scalePoint,\n                round: prop.scaleRound,\n                thousand: prop.scaleThousand,\n                decimals: prop.scaleDecimals,\n                strict: typeof prop.scaleMax === 'number',\n                formatter: prop.scaleFormatter\n            });\n\n            this.max = this.scale.max;\n\n            // Draw the background 'grid'\n            this.drawBackground();\n\n            // Draw the chart\n            this.drawRose();\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the key\n            if (typeof prop.key !== null && RG.SVG.drawKey) {\n                RG.SVG.drawKey(this);\n            } else if (!RGraph.SVG.isNull(prop.key)) {\n                alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n            }\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Create the shadow definition if needed\n            if (prop.shadow) {\n                RG.SVG.setShadow({\n                    object: this,\n                    offsetx: prop.shadowOffsetx,\n                    offsety: prop.shadowOffsety,\n                    blur: prop.shadowBlur,\n                    opacity: prop.shadowOpacity,\n                    id: 'dropShadow'\n                });\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.hideHighlight(obj);\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draw the background grid\n        //\n        this.drawBackground = function () {\n            if (prop.backgroundGrid) {\n\n                // Create the background grid group tag\n                var grid = RG.SVG.create({\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    type: 'g',\n                    attr: {\n                        className: 'rgraph_radar_grid',\n                        fill: 'rgba(0,0,0,0)',\n                        stroke: prop.backgroundGridColor\n                    }\n                });\n\n                // Draw the concentric \"rings\" grid lines that are\n                // arranged around the centerx/centery along with\n                // the radials that eminate from the center outwards\n\n                var origin = 0 - RG.SVG.TRIG.PI / 2,\n                    radials = typeof prop.backgroundGridRadialsCount === 'number' ? prop.backgroundGridRadialsCount : this.data.length,\n                    concentrics = prop.backgroundGridConcentricsCount,\n                    step = RG.SVG.TRIG.TWOPI / radials;\n\n                // First draw the radial lines that emanate from the\n                // center outwards\n                if (radials > 0) {\n                    // This draws the radials for the non-equi-angular ONLY\n                    if (prop.variant === 'non-equi-angular') {\n\n                        // Number of radials always matches the number of data pieces\n                        var radials = this.data.length;\n\n                        // Work out the total of the second part of each data bit\n                        for (var i = 0, total = 0; i < this.data.length; ++i) {\n                            total += this.data[i][1];\n                        }\n\n                        for (var i = 0, sum = 0; i < this.data.length; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + sum / total * RG.SVG.TRIG.TWOPI + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n\n                            sum += this.data[i][1];\n                        }\n\n                        // This draws the radials for normal and STACKED Rose charts\n                    } else {\n                        for (var i = 0, len = radials; i < len; ++i) {\n\n                            var coords = RG.SVG.TRIG.toCartesian({\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius,\n                                angle: origin + i * step + prop.backgroundGridRadialsAngleOffset\n                            });\n\n                            var str = 'M {1} {2} L {3} {4}'.format(this.centerx, this.centery, coords.x, coords.y);\n\n                            RG.SVG.create({\n                                svg: this.svg,\n                                type: 'path',\n                                parent: grid,\n                                attr: {\n                                    d: str,\n                                    stroke: prop.backgroundGridColor,\n                                    'stroke-width': prop.backgroundGridLinewidth\n                                }\n                            });\n                        }\n                    }\n                }\n\n                // Draw the concentrics\n                if (concentrics > 0) {\n\n                    for (var j = 1; j <= concentrics; j++) {\n\n                        // Add circle to the scene\n                        RG.SVG.create({\n                            svg: this.svg,\n                            type: 'circle',\n                            parent: grid,\n                            attr: {\n                                cx: this.centerx,\n                                cy: this.centery,\n                                r: this.radius * (j / concentrics),\n                                fill: 'transparent',\n                                stroke: prop.backgroundGridColor,\n                                'stroke-width': prop.backgroundGridLinewidth\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar\n        //\n        this.drawRose = function (opt) {\n            // Jump to another function if we're drawing a non-equi-angular chart\n            if (prop.variant === 'non-equi-angular') {\n                return this.drawRoseNonEquiAngular(opt);\n            }\n\n            var radians = RG.SVG.TRIG.TWOPI / this.data.length;\n\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radius = this.data[i] / this.scale.max * this.radius,\n                    start = i / this.data.length * RG.SVG.TRIG.TWOPI,\n                    end = i / this.data.length * RG.SVG.TRIG.TWOPI + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // Is the data piece an array or a number?\n                if (_typeof(this.data[i]) === 'object' && !RG.SVG.isNull(this.data[i])) {\n\n                    // Create a group for the parts of this segment\n                    var segment_group = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'g',\n                        parent: group,\n                        attr: {\n                            id: 'rose_' + this.id + '_segment_group_' + i\n                        }\n                    });\n\n                    for (var j = 0, sum = 0, accRadius = 0; j < this.data[i].length; ++j, ++seq) {\n\n                        sum += this.data[i][j];\n\n                        var radius = sum / this.scale.max * this.radius;\n\n                        // This (I think is the OUTER curve in the segment\n                        var arcPath = RG.SVG.TRIG.getArcPath2({\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            r: radius,\n                            start: start + prop.margin + prop.segmentsAngleOffset,\n                            end: end - prop.margin + prop.segmentsAngleOffset,\n                            anticlockwise: false\n                        });\n\n                        // The inner most segment\n                        if (j === 0) {\n                            arcPath = '{1} z'.format(arcPath);\n                        } else {\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                            arcPath = '{1} L {2} {3} {4}'.format(arcPath, this.centerx + explosion[0], this.centery + explosion[1], arcPath2);\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: segment_group,\n                            attr: {\n                                d: arcPath,\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[seq] : '',\n                                'data-index': i,\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-group': i,\n                                'data-subindex': j,\n                                'data-value': this.data[i][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': typeof prevRadius === 'number' ? prevRadius : 0,\n                                'data-sequential-index': seq\n                            }\n                        });\n\n                        // Install the tooltip listener\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        group: group,\n                                        index: index,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n\n                        // Add the segment to the angles and angles2 array\n                        this.angles.push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        var prevRadius = radius;\n                    }\n\n                    seq--;\n\n                    // A regular number\n                } else {\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-index': i,\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': prevRadius,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: index,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, this);\n                    }\n                }\n            }\n        };\n\n        //\n        // Draws the radar, but only the non-equi-angular variant\n        //\n        this.drawRoseNonEquiAngular = function (opt) {\n            var group = RG.SVG.create({\n                svg: this.svg,\n                type: 'g',\n                parent: this.svg.all,\n                attr: {\n                    id: 'rgraph_rose_segments_' + this.id\n                }\n            });\n\n            //Loop through the data summing the second data-pieces\n            for (var i = 0, total = 0; i < this.data.length; ++i) {\n                total += parseFloat(this.data[i][1]);\n            }\n\n            // The initial angles\n            var start = 0;\n\n            // Now loop thru the data\n            for (var i = 0, seq = 0; i < this.data.length; ++i, ++seq) {\n\n                var radians = this.data[i][1] / total * RG.SVG.TRIG.TWOPI,\n                    end = start + radians;\n\n                // Get the exploded distance\n                var explosion = this.getExploded({\n                    index: i,\n                    start: start - RG.SVG.TRIG.HALFPI,\n                    end: end - RG.SVG.TRIG.HALFPI\n                });\n\n                // A stacked non-equi-angular segment\n                if (_typeof(this.data[i][0]) === 'object' && !RG.SVG.isNull(this.data[i][0])) {\n\n                    // Loop thru the set of values for this segment\n                    for (var j = 0, sum = 0; j < this.data[i][0].length; ++j, ++seq) {\n\n                        sum += this.data[i][0][j];\n\n                        // First segment in the stack or not?\n                        if (j === 0) {\n\n                            var prevRadius = 0,\n                                radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = '';\n                        } else {\n\n                            var prevRadius = radius,\n                                // The previous iterations radius\n                            radius = sum / this.scale.max * this.radius;\n\n                            var arcPath = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: radius,\n                                start: start + prop.margin + prop.segmentsAngleOffset,\n                                end: end - prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: false\n                            });\n\n                            var arcPath2 = RG.SVG.TRIG.getArcPath2({\n                                cx: this.centerx + explosion[0],\n                                cy: this.centery + explosion[1],\n                                r: prevRadius,\n                                start: end - prop.margin + prop.segmentsAngleOffset,\n                                end: start + prop.margin + prop.segmentsAngleOffset,\n                                anticlockwise: true\n                            });\n                        }\n\n                        var path = RG.SVG.create({\n                            svg: this.svg,\n                            type: 'path',\n                            parent: group,\n                            attr: {\n                                d: '{1} {2} z'.format(arcPath, arcPath2),\n                                fill: prop.colorsSequential ? prop.colors[seq] : prop.colors[j],\n                                'fill-opacity': prop.colorsOpacity,\n                                stroke: prop.strokestyle,\n                                'stroke-width': prop.linewidth,\n                                'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                                'data-centerx': this.centerx + explosion[0],\n                                'data-centery': this.centery + explosion[1],\n                                'data-index': '[{1},{2}]'.format(i, j),\n                                'data-value': this.data[i][0][j],\n                                'data-start-angle': start,\n                                'data-end-angle': end,\n                                'data-radius': radius,\n                                'data-radius-inner': prevRadius,\n                                'data-sequential': seq\n                            }\n                        });\n\n                        // Add the segment to the angles array\n                        this.angles.push({\n                            object: path,\n                            index: i,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][0]\n                        });\n\n                        this.angles2[i].push({\n                            object: path,\n                            index: seq,\n                            cx: this.centerx + explosion[0],\n                            cy: this.centery + explosion[1],\n                            start: start,\n                            end: end,\n                            radius: radius,\n                            'radius-inner': prevRadius,\n                            value: this.data[i][j]\n                        });\n\n                        // Install tooltips listeners\n                        if (prop.tooltips && prop.tooltips[seq]) {\n\n                            // Make the tooltipsEvent default to click\n                            if (prop.tooltipsEvent !== 'mousemove') {\n                                prop.tooltipsEvent = 'click';\n                            }\n\n                            (function (index, group, seq, obj) {\n                                path.addEventListener(prop.tooltipsEvent, function (e) {\n                                    obj.removeHighlight();\n\n                                    // Show the tooltip\n                                    RG.SVG.tooltip({\n                                        object: obj,\n                                        index: index,\n                                        group: group,\n                                        sequentialIndex: seq,\n                                        text: prop.tooltips[seq],\n                                        event: e\n                                    });\n\n                                    // Highlight the rect that has been clicked on\n                                    obj.highlight(e.target);\n\n                                    var highlight = RG.SVG.REG.get('highlight');\n\n                                    if (prop.tooltipsEvent === 'mousemove') {\n                                        highlight.style.cursor = 'pointer';\n                                    }\n                                }, false);\n\n                                // Install the event listener that changes the\n                                // cursor if necessary\n                                if (prop.tooltipsEvent === 'click') {\n                                    path.addEventListener('mousemove', function (e) {\n                                        e.target.style.cursor = 'pointer';\n                                    }, false);\n                                }\n                            })(j, i, seq, this);\n                        }\n                        var prevRadius = radius;\n                    }\n                    seq--;\n\n                    // A regular non-equi-angular segment\n                } else {\n                    var radius = this.data[i][0] / this.scale.max * this.radius;\n\n                    var arcPath = RG.SVG.TRIG.getArcPath2({\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        r: radius,\n                        start: start + prop.margin + prop.segmentsAngleOffset,\n                        end: end - prop.margin + prop.segmentsAngleOffset,\n                        anticlockwise: false\n                    });\n\n                    var path = RG.SVG.create({\n                        svg: this.svg,\n                        type: 'path',\n                        parent: group,\n                        attr: {\n                            d: '{1} z'.format(arcPath),\n                            fill: prop.colorsSequential ? prop.colors[i] : prop.colors[0],\n                            'fill-opacity': prop.colorsOpacity,\n                            stroke: prop.strokestyle,\n                            'stroke-width': prop.linewidth,\n\n                            'data-tooltip': !RG.SVG.isNull(prop.tooltips) && prop.tooltips.length ? prop.tooltips[i] : '',\n                            'data-centerx': this.centerx + explosion[0],\n                            'data-centery': this.centery + explosion[1],\n                            'data-index': i,\n                            'data-value': this.data[i],\n                            'data-start-angle': start,\n                            'data-end-angle': end,\n                            'data-radius': radius,\n                            'data-sequential': seq\n                        }\n                    });\n\n                    // Add the segment to the angles array\n                    this.angles.push({\n                        object: path,\n                        index: i,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        value: this.data[i][0]\n                    });\n\n                    this.angles2[i].push({\n                        object: path,\n                        index: seq,\n                        cx: this.centerx + explosion[0],\n                        cy: this.centery + explosion[1],\n                        start: start,\n                        end: end,\n                        radius: radius,\n                        'radius-inner': 0,\n                        value: this.data[i][j]\n                    });\n\n                    if (prop.tooltips && prop.tooltips[i]) {\n\n                        // Make the tooltipsEvent default to click\n                        if (prop.tooltipsEvent !== 'mousemove') {\n                            prop.tooltipsEvent = 'click';\n                        }\n\n                        (function (index, group, seq, obj) {\n                            path.addEventListener(prop.tooltipsEvent, function (e) {\n                                obj.removeHighlight();\n\n                                // Show the tooltip\n                                RG.SVG.tooltip({\n                                    object: obj,\n                                    index: index,\n                                    group: index,\n                                    sequentialIndex: seq,\n                                    text: prop.tooltips[index],\n                                    event: e\n                                });\n\n                                // Highlight the rect that has been clicked on\n                                obj.highlight(e.target);\n\n                                var highlight = RG.SVG.REG.get('highlight');\n\n                                if (prop.tooltipsEvent === 'mousemove') {\n                                    highlight.style.cursor = 'pointer';\n                                }\n                            }, false);\n\n                            // Install the event listener that changes the\n                            // cursor if necessary\n                            if (prop.tooltipsEvent === 'click') {\n                                path.addEventListener('mousemove', function (e) {\n                                    e.target.style.cursor = 'pointer';\n                                }, false);\n                            }\n                        })(i, i, seq, this);\n                    }\n                }\n\n                // Increment the start angle for the next iteration of the loop\n                start += radians;\n            }\n        };\n\n        //\n        // Redraws the chart if required\n        //\n        this.redrawRose = function () {};\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the scale if required\n            if (prop.scaleVisible) {\n                for (var i = 0; i < this.scale.labels.length; ++i) {\n\n                    var x = this.centerx;\n                    var y = this.centery - this.radius / this.scale.labels.length * (i + 1);\n\n                    RG.SVG.text({\n                        object: this,\n                        svg: this.svg,\n                        parent: this.svg.all,\n                        text: this.scale.labels[i],\n                        size: prop.scaleSize || prop.textSize - 2,\n                        x: x,\n                        y: y,\n                        halign: 'center',\n                        valign: 'center',\n                        background: 'rgba(255,255,255,0.7)',\n                        padding: 2,\n                        color: prop.scaleColor || prop.textColor,\n                        bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                        italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                        font: prop.scaleFont || prop.textFont\n                    });\n                }\n\n                // Draw the zero label\n                var str = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.scale.min.toFixed(prop.scaleDecimals),\n                    prepend: prop.scaleUnitsPre,\n                    append: prop.scaleUnitsPost,\n                    point: prop.scalePoint,\n                    thousand: prop.scaleThousand,\n                    formatter: prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: str,\n                    size: prop.scaleSize || prop.textSize - 2,\n                    x: this.centerx,\n                    y: this.centery,\n                    halign: 'center',\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.scaleColor || prop.textColor,\n                    bold: typeof prop.scaleBold === 'boolean' ? prop.scaleBold : prop.textBold,\n                    italic: typeof prop.scaleItalic === 'boolean' ? prop.scaleItalic : prop.textItalic,\n                    font: prop.scaleFont || prop.textFont\n                });\n            }\n\n            // Used further down\n            var halign;\n\n            // Set a default size for the labels\n            if (typeof prop.labelsSize !== 'number') {\n                prop.labelsSize = prop.textSize + 4;\n            }\n\n            // Draw the circular labels if necessary\n            for (var i = 0; i < prop.labels.length; ++i) {\n\n                if (prop.variant === 'non-equi-angular') {\n                    var angle = (this.angles2[i][0].end - this.angles2[i][0].start) / 2 + this.angles2[i][0].start - RG.SVG.TRIG.HALFPI;\n                } else {\n                    var angle = RG.SVG.TRIG.TWOPI / prop.labels.length * i - RG.SVG.TRIG.HALFPI + prop.labelsAngleOffset + (this.angles2[i][0].end - this.angles2[i][0].start) / 2;\n                }\n\n                var endpoint = RG.SVG.TRIG.getRadiusEndPoint({\n                    r: this.radius + prop.labelsRadialMargin,\n                    angle: angle\n                });\n\n                // Accommodate the explosion for the label\n                var explosion = this.getExploded({\n                    index: i,\n                    start: this.angles2[i][0].start - RG.SVG.TRIG.HALFPI,\n                    end: this.angles2[i][0].end - RG.SVG.TRIG.HALFPI\n                });\n\n                endpoint[0] += this.centerx + explosion[0];\n                endpoint[1] += this.centery + explosion[1];\n\n                // Do the alignment based on which quadrant the label is in\n                if (ma.round(endpoint[0]) > this.centerx) {\n                    halign = 'left';\n                } else if (ma.round(endpoint[0]) === this.centerx) {\n                    halign = 'center';\n                } else {\n                    halign = 'right';\n                }\n\n                RG.SVG.text({\n                    object: this,\n                    svg: this.svg,\n                    parent: this.svg.all,\n                    text: typeof prop.labels[i] === 'string' ? prop.labels[i] : '',\n                    size: prop.labelsSize,\n                    x: endpoint[0],\n                    y: endpoint[1],\n                    halign: halign,\n                    valign: 'center',\n                    background: 'rgba(255,255,255,0.7)',\n                    padding: 2,\n                    color: prop.labelsColor || prop.textColor,\n                    bold: typeof prop.labelsBold === 'boolean' ? prop.labelsBold : prop.textBold,\n                    italic: typeof prop.labelsItalic === 'boolean' ? prop.labelsItalic : prop.textItalic,\n                    font: prop.labelsFont || prop.textFont\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        * \n        * @param object circle The circle to highlight\n        */\n        this.highlight = function (path) {\n            var path = path.getAttribute('d');\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                parent: this.svg.all,\n                type: 'path',\n                attr: {\n                    d: path,\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            if (prop.tooltipsEvent === 'mousemove') {\n                highlight.addEventListener('mouseout', function (e) {\n                    highlight.parentNode.removeChild(highlight);\n                    RG.SVG.hideTooltip();\n\n                    RG.SVG.REG.set('highlight', null);\n                }, false);\n            }\n\n            // Store the highlight rect in the registry so\n            // it can be cleared later\n            RG.SVG.REG.set('highlight', highlight);\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorRadial({\n                        object: this,\n                        color: colors[i]\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorRadial({\n                object: this,\n                color: prop.highlightFill\n            });\n        };\n\n        //\n        // Get the maximum value\n        //\n        this.getMaxValue = function () {\n            var max = 0;\n\n            if (prop.variant === 'non-equi-angular') {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i][0] === 'number') {\n                            max = ma.max(max, this.data[i][0]);\n                        } else if (_typeof(this.data[i][0]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i][0]));\n                        }\n                    }\n                }\n            } else {\n                for (var i = 0; i < this.data.length; ++i) {\n                    if (!RG.SVG.isNull(this.data[i])) {\n                        if (typeof this.data[i] === 'number') {\n                            max = ma.max(max, this.data[i]);\n                        } else if (_typeof(this.data[i]) === 'object') {\n                            max = ma.max(max, RG.SVG.arraySum(this.data[i]));\n                        }\n                    }\n                }\n            }\n\n            this.max = max;\n        };\n\n        //\n        // Gets the radius of a value\n        //\n        //@param number The value to get the radius for\n        //\n        this.getRadius = function (value) {\n            return (value - prop.scaleMin) / (this.scale.max - prop.scaleMin) * this.radius;\n        };\n\n        //\n        // A roundRobin effect for the Pie chart\n        //\n        // @param object    Options for the effect\n        // @param function  An optional callback function to call when\n        //                  the effect is complete\n        //\n        this.roundRobin = function () {};\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        * \n        * @param string   type The type of even to add\n        * @param function func \n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        // \n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Removes the tooltip highlight from the chart\n        //\n        this.removeHighlight = this.hideHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight && this.highlight_node) {\n                this.highlight_node.setAttribute('fill', 'transparent');\n                this.highlight_node.setAttribute('stroke', 'transparent');\n\n                RG.SVG.REG.set('highlight', null);\n            }\n        };\n\n        //\n        // Returns the exploded X/Y for a given explosion\n        //\n        //TODO Needs updating to current coding style, including converting\n        //     arguments to an object\n        //\n        this.getExploded = function (opt) {\n            var index = opt.index,\n                start = opt.start,\n                end = opt.end,\n                exploded = prop.exploded,\n                explodedX,\n                explodedY;\n\n            /**\n            * Retrieve any exploded - the exploded can be an array of numbers or a single number\n            * (which is applied to all segments)\n            */\n            if ((typeof exploded === 'undefined' ? 'undefined' : _typeof(exploded)) === 'object' && typeof exploded[index] === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded[index];\n                explodedY = ma.sin((end - start) / 2 + start) * exploded[index];\n            } else if (typeof exploded === 'number') {\n                explodedX = ma.cos((end - start) / 2 + start) * exploded;\n                explodedY = ma.sin((end - start) / 2 + start) * exploded;\n            } else {\n                explodedX = 0;\n                explodedY = 0;\n            }\n\n            return [explodedX, explodedY];\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcucm9zZS5qcz82YmNkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLy8gdmVyc2lvbjogMjAxNy0wNS0wOFxuLyoqXG4qIG8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLW9cbiogfCBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgUkdyYXBoIHBhY2thZ2UgLSB5b3UgY2FuIGxlYXJuIG1vcmUgYXQ6ICAgICAgICAgICAgICAgfFxuKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cucmdyYXBoLm5ldCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuKiB8IFJHcmFwaCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgT3BlbiBTb3VyY2UgTUlUIGxpY2Vuc2UuIFRoYXQgbWVhbnMgdGhhdCBpdCdzICAgICB8XG4qIHwgdG90YWxseSBmcmVlIHRvIHVzZSEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tb1xuKi9cblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07XG5SR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTtcblxuLy8gTW9kdWxlIHBhdHRlcm5cbihmdW5jdGlvbiAod2luLCBkb2MsIHVuZGVmaW5lZCkge1xuICAgIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBtYSA9IE1hdGgsXG4gICAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgICAgZG9jID0gZG9jdW1lbnQ7XG5cbiAgICBSRy5TVkcuUm9zZSA9IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgc2V0dGVyIHRoYXQgdGhlIGNvbnN0cnVjdG9yIHVzZXMgKGF0IHRoZSBlbmQpXG4gICAgICAgIC8vIHRvIHNldCBhbGwgb2YgdGhlIHByb3BlcnRpZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQHBhcmFtIHN0cmluZyBuYW1lICBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gICAgICAgIC8vIEBwYXJhbSBzdHJpbmcgdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZ3VtZW50c1swXVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSByZXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmV0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbmFtZSA9IHJldC5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmV0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaWQgPSBjb25mLmlkO1xuICAgICAgICB0aGlzLnVpZCA9IFJHLlNWRy5jcmVhdGVVSUQoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5zdmcgPSBSRy5TVkcuY3JlYXRlU1ZHKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTtcbiAgICAgICAgdGhpcy5pc1JHcmFwaCA9IHRydWU7XG4gICAgICAgIHRoaXMud2lkdGggPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IFJHLlNWRy5hcnJheUNsb25lKGNvbmYuZGF0YSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gUkcuU1ZHLmFycmF5Q2xvbmUoY29uZi5kYXRhKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Jvc2UnO1xuICAgICAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICAgICAgICB0aGlzLmFuZ2xlczIgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmdyYWRpZW50Q291bnRlciA9IDE7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaGFkb3dOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm1heCA9IDA7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0X25vZGUgPSBudWxsO1xuXG4gICAgICAgIC8vIEFkZCB0aGlzIG9iamVjdCB0byB0aGUgT2JqZWN0UmVnaXN0cnlcbiAgICAgICAgUkcuU1ZHLk9SLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgdGhlIERJViBjb250YWluZXIgdG8gYmUgaW5saW5lLWJsb2NrXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBjZW50ZXJ4OiBudWxsLFxuICAgICAgICAgICAgY2VudGVyeTogbnVsbCxcbiAgICAgICAgICAgIHJhZGl1czogbnVsbCxcblxuICAgICAgICAgICAgZ3V0dGVyTGVmdDogMzUsXG4gICAgICAgICAgICBndXR0ZXJSaWdodDogMzUsXG4gICAgICAgICAgICBndXR0ZXJUb3A6IDM1LFxuICAgICAgICAgICAgZ3V0dGVyQm90dG9tOiAzNSxcblxuICAgICAgICAgICAgYmFja2dyb3VuZEdyaWQ6IHRydWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kR3JpZENvbG9yOiAnI2RkZCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kR3JpZFJhZGlhbHNDb3VudDogbnVsbCxcbiAgICAgICAgICAgIGJhY2tncm91bmRHcmlkUmFkaWFsc0FuZ2xlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgYmFja2dyb3VuZEdyaWRDb25jZW50cmljc0NvdW50OiA1LFxuICAgICAgICAgICAgYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6IDEsXG5cbiAgICAgICAgICAgIHN0cm9rZXN0eWxlOiAnd2hpdGUnLFxuICAgICAgICAgICAgY29sb3JzOiBbJ3JlZCcsICdibGFjaycsICdvcmFuZ2UnLCAnZ3JlZW4nLCAnIzZmZicsICcjY2NjJywgJ3BpbmsnLCAnb3JhbmdlJywgJ2N5YW4nLCAnbWFyb29uJywgJ29saXZlJywgJ3RlYWwnXSxcbiAgICAgICAgICAgIGNvbG9yc09wYWNpdHk6IDEsXG5cbiAgICAgICAgICAgIHRleHRDb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgIHRleHRGb250OiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICB0ZXh0U2l6ZTogMTIsXG4gICAgICAgICAgICB0ZXh0Qm9sZDogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0SXRhbGljOiBmYWxzZSxcblxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICAgIGxhYmVsc0ZvbnQ6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNTaXplOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ29sb3I6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNCb2xkOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzSXRhbGljOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzUmFkaWFsTWFyZ2luOiAxMCxcbiAgICAgICAgICAgIGxhYmVsc0FuZ2xlT2Zmc2V0OiAwLFxuXG4gICAgICAgICAgICBzY2FsZVZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBzY2FsZVVuaXRzUHJlOiAnJyxcbiAgICAgICAgICAgIHNjYWxlVW5pdHNQb3N0OiAnJyxcbiAgICAgICAgICAgIHNjYWxlTWF4OiBudWxsLFxuICAgICAgICAgICAgc2NhbGVNaW46IDAsXG4gICAgICAgICAgICBzY2FsZVBvaW50OiAnLicsXG4gICAgICAgICAgICBzY2FsZVRob3VzYW5kOiAnLCcsXG4gICAgICAgICAgICBzY2FsZVJvdW5kOiBmYWxzZSxcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbHM6IDAsXG4gICAgICAgICAgICBzY2FsZUZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlQm9sZDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlSXRhbGljOiBudWxsLFxuICAgICAgICAgICAgc2NhbGVDb2xvcjogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlU2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlRm9udDogbnVsbCxcbiAgICAgICAgICAgIHNjYWxlTGFiZWxzQ291bnQ6IDUsXG5cbiAgICAgICAgICAgIGxpbmV3aWR0aDogMSxcblxuICAgICAgICAgICAgdG9vbHRpcHM6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwc092ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcHNFZmZlY3Q6ICdmYWRlJyxcbiAgICAgICAgICAgIHRvb2x0aXBzQ3NzQ2xhc3M6ICdSR3JhcGhfdG9vbHRpcCcsXG4gICAgICAgICAgICB0b29sdGlwc0V2ZW50OiAnY2xpY2snLFxuXG4gICAgICAgICAgICBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLFxuICAgICAgICAgICAgaGlnaGxpZ2h0TGluZXdpZHRoOiAxLFxuXG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICB0aXRsZVNpemU6IDE2LFxuICAgICAgICAgICAgdGl0bGVYOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVZOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVIYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgdGl0bGVWYWxpZ246IG51bGwsXG4gICAgICAgICAgICB0aXRsZUNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgdGl0bGVGb250OiBudWxsLFxuICAgICAgICAgICAgdGl0bGVCb2xkOiBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlSXRhbGljOiBmYWxzZSxcblxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZTogJycsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlWDogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVZOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlVmFsaWduOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZUNvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVCb2xkOiBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVJdGFsaWM6IGZhbHNlLFxuXG4gICAgICAgICAgICBzaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgc2hhZG93T2Zmc2V0eDogMixcbiAgICAgICAgICAgIHNoYWRvd09mZnNldHk6IDIsXG4gICAgICAgICAgICBzaGFkb3dCbHVyOiAyLFxuICAgICAgICAgICAgc2hhZG93T3BhY2l0eTogMC4yNSxcblxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgZXhwbG9kZWQ6IDAsXG5cbiAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgIGtleUNvbG9yczogbnVsbCxcbiAgICAgICAgICAgIGtleU9mZnNldHg6IDAsXG4gICAgICAgICAgICBrZXlPZmZzZXR5OiAwLFxuICAgICAgICAgICAga2V5VGV4dE9mZnNldHg6IDAsXG4gICAgICAgICAgICBrZXlUZXh0T2Zmc2V0eTogLTEsXG4gICAgICAgICAgICBrZXlUZXh0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGtleVRleHRCb2xkOiBudWxsLFxuICAgICAgICAgICAga2V5VGV4dEl0YWxpYzogbnVsbCxcblxuICAgICAgICAgICAgYXR0cmlidXRpb246IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblg6IG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblk6IG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkhyZWY6IG51bGwsIC8vIERlZmF1bHQgaXMgc2V0IGluIFJHcmFwaC5zdmcuY29tbW9uLmNvcmUuanNcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uSGFsaWduOiAncmlnaHQnLFxuICAgICAgICAgICAgYXR0cmlidXRpb25WYWxpZ246ICdib3R0b20nLFxuICAgICAgICAgICAgYXR0cmlidXRpb25TaXplOiA3LFxuICAgICAgICAgICAgYXR0cmlidXRpb25Db2xvcjogJ2dyYXknLFxuICAgICAgICAgICAgYXR0cmlidXRpb25Gb250OiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkl0YWxpYzogZmFsc2UsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkJvbGQ6IGZhbHNlLFxuXG4gICAgICAgICAgICBzZWdtZW50c0FuZ2xlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgdmFyaWFudDogJ25vcm1hbCdcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBcIkRlY29yYXRlXCIgdGhlIG9iamVjdCB3aXRoIHRoZSBnZW5lcmljIGVmZmVjdHMgaWYgdGhlIGVmZmVjdHMgbGlicmFyeSBoYXMgYmVlbiBpbmNsdWRlZFxuICAgICAgICAqL1xuICAgICAgICBpZiAoUkcuU1ZHLkZYICYmIHR5cGVvZiBSRy5TVkcuRlguZGVjb3JhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFJHLlNWRy5GWC5kZWNvcmF0ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkcmF3IG1ldGhvZCBkcmF3cyB0aGUgQmFyIGNoYXJ0XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGJlZm9yZWRyYXcgZXZlbnRcbiAgICAgICAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZGF0YSBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFJHLlNWRy5hcnJheUNsb25lKHRoaXMub3JpZ2luYWxEYXRhKTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGFuZ2xlcyBhcnJheSB0byBzdG9wIGl0IGdyb3dpbmdcbiAgICAgICAgICAgIHRoaXMuYW5nbGVzID0gW107XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYXJyYXlzIGluIHRoZSBhbmdsZXMyIGFycmF5IGJhc2VkIG9uXG4gICAgICAgICAgICAvLyB0aGUgZGF0YSB0aGF0IHdlJ3ZlIGJlZW4gcGFzc2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzMltpXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGRlZnMgdGFnIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ncmFwaEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbTtcblxuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGNlbnRlciBwb2ludFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJ4ID0gdGhpcy5ncmFwaFdpZHRoIC8gMiArIHByb3AuZ3V0dGVyTGVmdDtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyeSA9IHRoaXMuZ3JhcGhIZWlnaHQgLyAyICsgcHJvcC5ndXR0ZXJUb3A7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG1hLm1pbih0aGlzLmdyYXBoV2lkdGgsIHRoaXMuZ3JhcGhIZWlnaHQpIC8gMjtcblxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGNhbGN1bGF0ZWQgY2VudGVyeC95L3JhZGl1c1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJ4ID0gdHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ251bWJlcicgPyBwcm9wLmNlbnRlcnggOiB0aGlzLmNlbnRlcng7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcnkgPSB0eXBlb2YgcHJvcC5jZW50ZXJ5ID09PSAnbnVtYmVyJyA/IHByb3AuY2VudGVyeSA6IHRoaXMuY2VudGVyeTtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gdHlwZW9mIHByb3AucmFkaXVzID09PSAnbnVtYmVyJyA/IHByb3AucmFkaXVzIDogdGhpcy5yYWRpdXM7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgY2VudGVyeC9jZW50ZXJ5L3JhZGl1cyB0byBiZSBhIHBsdXMvbWludXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AucmFkaXVzID09PSAnc3RyaW5nJyAmJiBwcm9wLnJhZGl1cy5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5yYWRpdXMgKz0gcGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ3N0cmluZycgJiYgcHJvcC5jZW50ZXJ4Lm1hdGNoKC9eXFwrfC1cXGQrJC8pKSB0aGlzLmNlbnRlcnkgKz0gcGFyc2VGbG9hdChwcm9wLmNlbnRlcngpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wLmNlbnRlcnkgPT09ICdzdHJpbmcnICYmIHByb3AuY2VudGVyeS5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5jZW50ZXJ4ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ5KTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG5hcmdpbiBmcm9tIHN0cmluZ3MgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AubWFyZ2luID09PSAnc3RyaW5nJyAmJiBwcm9wLm1hcmdpbi5tYXRjaCgvKFswLTkuXSspZGVnLykpIHtcbiAgICAgICAgICAgICAgICBwcm9wLm1hcmdpbiA9IFJlZ0V4cC4kMSAvICgxODAgLyBtYS5QSSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBBZGQgdGhlIGRhdGEgdG8gdGhlIC5vcmlnaW5hbERhdGEgYXJyYXkgYW5kIHdvcmsgb3V0IHRoZSBtYXggdmFsdWVcbiAgICAgICAgICAgICogXG4gICAgICAgICAgICAqIDIvNS8xNCBOb3cgYWxzbyB1c2UgdGhpcyBsb29wIHRvIGVuc3VyZSB0aGF0IHRoZSBkYXRhIHBpZWNlc1xuICAgICAgICAgICAgKiAgICAgICAgYXJlIG51bWJlcnNcbiAgICAgICAgICAgICogXG4gICAgICAgICAgICAqICoqSXMgdGhpcyBuZWNlc3NhcnkgKipcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvL2lmIChSRy5TVkcuaXNBcnJheSh0aGlzLmRhdGEpICYmICh0eXBlb2YgdGhpcy5kYXRhWzBdID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGhpcy5kYXRhWzBdID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIC8vICAgIHRoaXMuZGF0YSA9IFt0aGlzLmRhdGFdO1xuICAgICAgICAgICAgLy99XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5ncyB0byBudW1iZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV1bal0gPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyh0aGlzLmRhdGFbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyh0aGlzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBtYXggdmFsdWUuIFRoaXMgc2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvbiB0aGVcbiAgICAgICAgICAgIC8vIHRoaXMubWF4IHZhcmlhYmxlXG4gICAgICAgICAgICB0aGlzLmdldE1heFZhbHVlKCk7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb2xvcnMgZm9yIGdyYWRpZW50c1xuICAgICAgICAgICAgUkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7IG9iamVjdDogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb2xvcnMoKTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEdldCB0aGUgc2NhbGVcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBSRy5TVkcuZ2V0U2NhbGUoe1xuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICBudW1sYWJlbHM6IHR5cGVvZiBwcm9wLnNjYWxlTGFiZWxzQ291bnQgPT09ICdudW1iZXInID8gcHJvcC5zY2FsZUxhYmVsc0NvdW50IDogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNDb3VudCxcbiAgICAgICAgICAgICAgICB1bml0c1ByZTogcHJvcC5zY2FsZVVuaXRzUHJlLFxuICAgICAgICAgICAgICAgIHVuaXRzUG9zdDogcHJvcC5zY2FsZVVuaXRzUG9zdCxcbiAgICAgICAgICAgICAgICBtYXg6IHR5cGVvZiBwcm9wLnNjYWxlTWF4ID09PSAnbnVtYmVyJyA/IHByb3Auc2NhbGVNYXggOiB0aGlzLm1heCxcbiAgICAgICAgICAgICAgICBtaW46IHByb3Auc2NhbGVNaW4sXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICByb3VuZDogcHJvcC5zY2FsZVJvdW5kLFxuICAgICAgICAgICAgICAgIHRob3VzYW5kOiBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHByb3Auc2NhbGVEZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHR5cGVvZiBwcm9wLnNjYWxlTWF4ID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHByb3Auc2NhbGVGb3JtYXR0ZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMuc2NhbGUubWF4O1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBiYWNrZ3JvdW5kICdncmlkJ1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBjaGFydFxuICAgICAgICAgICAgdGhpcy5kcmF3Um9zZSgpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBsYWJlbHNcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscygpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSB0aXRsZSBhbmQgc3VidGl0bGVcbiAgICAgICAgICAgIFJHLlNWRy5kcmF3VGl0bGUodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGtleVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wLmtleSAhPT0gbnVsbCAmJiBSRy5TVkcuZHJhd0tleSkge1xuICAgICAgICAgICAgICAgIFJHLlNWRy5kcmF3S2V5KHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghUkdyYXBoLlNWRy5pc051bGwocHJvcC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ1RoZSBkcmF3S2V5KCkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBoYXZlIHlvdSBmb3Jnb3R0ZW4gdG8gaW5jbHVkZSB0aGUga2V5IGxpYnJhcnk/Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRpb24gbGluay4gSWYgeW91J3JlIGFkZGluZyB0aGlzIGVsc2V3aGVyZSBvbiB5b3VyIHBhZ2Uvc2l0ZVxuICAgICAgICAgICAgLy8gYW5kIHlvdSBkb24ndCB3YW50IGl0IGRpc3BsYXllZCB0aGVuIHRoZXJlIGFyZSBvcHRpb25zIGF2YWlsYWJsZSB0byBub3RcbiAgICAgICAgICAgIC8vIHNob3cgaXQuXG4gICAgICAgICAgICBSRy5TVkcuYXR0cmlidXRpb24odGhpcyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2hhZG93IGRlZmluaXRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAocHJvcC5zaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBSRy5TVkcuc2V0U2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXR4OiBwcm9wLnNoYWRvd09mZnNldHgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldHk6IHByb3Auc2hhZG93T2Zmc2V0eSxcbiAgICAgICAgICAgICAgICAgICAgYmx1cjogcHJvcC5zaGFkb3dCbHVyLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBwcm9wLnNoYWRvd09wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnZHJvcFNoYWRvdydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNsZWFycyB0aGUgaGlnaGxpZ2h0IGlmXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhbnkuIE11c3QgYmUgTU9VU0VET1dOIChpZSBiZWZvcmUgdGhlIGNsaWNrIGV2ZW50KVxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXM7XG4gICAgICAgICAgICBkb2MuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIG9iai5oaWRlSGlnaGxpZ2h0KG9iaik7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGRyYXcgZXZlbnRcbiAgICAgICAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3IHRoZSBiYWNrZ3JvdW5kIGdyaWRcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLmJhY2tncm91bmRHcmlkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJhY2tncm91bmQgZ3JpZCBncm91cCB0YWdcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2cnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdyZ3JhcGhfcmFkYXJfZ3JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHByb3AuYmFja2dyb3VuZEdyaWRDb2xvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBjb25jZW50cmljIFwicmluZ3NcIiBncmlkIGxpbmVzIHRoYXQgYXJlXG4gICAgICAgICAgICAgICAgLy8gYXJyYW5nZWQgYXJvdW5kIHRoZSBjZW50ZXJ4L2NlbnRlcnkgYWxvbmcgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSByYWRpYWxzIHRoYXQgZW1pbmF0ZSBmcm9tIHRoZSBjZW50ZXIgb3V0d2FyZHNcblxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSAwIC0gUkcuU1ZHLlRSSUcuUEkgLyAyLFxuICAgICAgICAgICAgICAgICAgICByYWRpYWxzID0gdHlwZW9mIHByb3AuYmFja2dyb3VuZEdyaWRSYWRpYWxzQ291bnQgPT09ICdudW1iZXInID8gcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNDb3VudCA6IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNlbnRyaWNzID0gcHJvcC5iYWNrZ3JvdW5kR3JpZENvbmNlbnRyaWNzQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBSRy5TVkcuVFJJRy5UV09QSSAvIHJhZGlhbHM7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBkcmF3IHRoZSByYWRpYWwgbGluZXMgdGhhdCBlbWFuYXRlIGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2VudGVyIG91dHdhcmRzXG4gICAgICAgICAgICAgICAgaWYgKHJhZGlhbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZHJhd3MgdGhlIHJhZGlhbHMgZm9yIHRoZSBub24tZXF1aS1hbmd1bGFyIE9OTFlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiByYWRpYWxzIGFsd2F5cyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgZGF0YSBwaWVjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYWRpYWxzID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIHRvdGFsIG9mIHRoZSBzZWNvbmQgcGFydCBvZiBlYWNoIGRhdGEgYml0XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdG90YWwgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5kYXRhW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgc3VtID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFJHLlNWRy5UUklHLnRvQ2FydGVzaWFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBvcmlnaW4gKyBzdW0gLyB0b3RhbCAqIFJHLlNWRy5UUklHLlRXT1BJICsgcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNBbmdsZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICdNIHsxfSB7Mn0gTCB7M30gezR9Jy5mb3JtYXQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIGNvb3Jkcy54LCBjb29yZHMueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHRoaXMuZGF0YVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkcmF3cyB0aGUgcmFkaWFscyBmb3Igbm9ybWFsIGFuZCBTVEFDS0VEIFJvc2UgY2hhcnRzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFkaWFsczsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gUkcuU1ZHLlRSSUcudG9DYXJ0ZXNpYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IG9yaWdpbiArIGkgKiBzdGVwICsgcHJvcC5iYWNrZ3JvdW5kR3JpZFJhZGlhbHNBbmdsZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICdNIHsxfSB7Mn0gTCB7M30gezR9Jy5mb3JtYXQodGhpcy5jZW50ZXJ4LCB0aGlzLmNlbnRlcnksIGNvb3Jkcy54LCBjb29yZHMueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgY29uY2VudHJpY3NcbiAgICAgICAgICAgICAgICBpZiAoY29uY2VudHJpY3MgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gY29uY2VudHJpY3M7IGorKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2lyY2xlIHRvIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiB0aGlzLnJhZGl1cyAqIChqIC8gY29uY2VudHJpY3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHByb3AuYmFja2dyb3VuZEdyaWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AuYmFja2dyb3VuZEdyaWRMaW5ld2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3cyB0aGUgcmFkYXJcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5kcmF3Um9zZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIC8vIEp1bXAgdG8gYW5vdGhlciBmdW5jdGlvbiBpZiB3ZSdyZSBkcmF3aW5nIGEgbm9uLWVxdWktYW5ndWxhciBjaGFydFxuICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1Jvc2VOb25FcXVpQW5ndWxhcihvcHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IFJHLlNWRy5UUklHLlRXT1BJIC8gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZycsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3JncmFwaF9yb3NlX3NlZ21lbnRzXycgKyB0aGlzLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vdyBsb29wIHRocnUgdGhlIGRhdGFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzZXEgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpLCArK3NlcSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZGF0YVtpXSAvIHRoaXMuc2NhbGUubWF4ICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSAvIHRoaXMuZGF0YS5sZW5ndGggKiBSRy5TVkcuVFJJRy5UV09QSSxcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gaSAvIHRoaXMuZGF0YS5sZW5ndGggKiBSRy5TVkcuVFJJRy5UV09QSSArIHJhZGlhbnM7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGV4cGxvZGVkIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGV4cGxvc2lvbiA9IHRoaXMuZ2V0RXhwbG9kZWQoe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0IC0gUkcuU1ZHLlRSSUcuSEFMRlBJLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIFJHLlNWRy5UUklHLkhBTEZQSVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIGRhdGEgcGllY2UgYW4gYXJyYXkgb3IgYSBudW1iZXI/XG4gICAgICAgICAgICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldKSA9PT0gJ29iamVjdCcgJiYgIVJHLlNWRy5pc051bGwodGhpcy5kYXRhW2ldKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgcGFydHMgb2YgdGhpcyBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50X2dyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3Jvc2VfJyArIHRoaXMuaWQgKyAnX3NlZ21lbnRfZ3JvdXBfJyArIGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIHN1bSA9IDAsIGFjY1JhZGl1cyA9IDA7IGogPCB0aGlzLmRhdGFbaV0ubGVuZ3RoOyArK2osICsrc2VxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLmRhdGFbaV1bal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBzdW0gLyB0aGlzLnNjYWxlLm1heCAqIHRoaXMucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIChJIHRoaW5rIGlzIHRoZSBPVVRFUiBjdXJ2ZSBpbiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIG1vc3Qgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNQYXRoID0gJ3sxfSB6Jy5mb3JtYXQoYXJjUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGgyID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZW5kIC0gcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1BhdGggPSAnezF9IEwgezJ9IHszfSB7NH0nLmZvcm1hdChhcmNQYXRoLCB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sIHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSwgYXJjUGF0aDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogc2VnbWVudF9ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IGFyY1BhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHByb3AuY29sb3JzU2VxdWVudGlhbCA/IHByb3AuY29sb3JzW3NlcV0gOiBwcm9wLmNvbG9yc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuY29sb3JzT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdG9vbHRpcCc6ICFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHMubGVuZ3RoID8gcHJvcC50b29sdGlwc1tzZXFdIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWluZGV4JzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeCc6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeSc6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZ3JvdXAnOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1zdWJpbmRleCc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXZhbHVlJzogdGhpcy5kYXRhW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1zdGFydC1hbmdsZSc6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1lbmQtYW5nbGUnOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXJhZGl1cyc6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmFkaXVzLWlubmVyJzogdHlwZW9mIHByZXZSYWRpdXMgPT09ICdudW1iZXInID8gcHJldlJhZGl1cyA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwtaW5kZXgnOiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCB0aGUgdG9vbHRpcCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwc1tzZXFdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSB0b29sdGlwc0V2ZW50IGRlZmF1bHQgdG8gY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ICE9PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnRvb2x0aXBzRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoaW5kZXgsIGdyb3VwLCBzZXEsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcudG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsSW5kZXg6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcm9wLnRvb2x0aXBzW3NlcV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHJlY3QgdGhhdCBoYXMgYmVlbiBjbGlja2VkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouaGlnaGxpZ2h0KGUudGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCB0aGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjaGFuZ2VzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KShqLCBpLCBzZXEsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHNlZ21lbnQgdG8gdGhlIGFuZ2xlcyBhbmQgYW5nbGVzMiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmFkaXVzLWlubmVyJzogcHJldlJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMyW2ldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cy1pbm5lcic6IHByZXZSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGF0YVtpXVtqXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VxLS07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZWd1bGFyIG51bWJlclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCArIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQgLSBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAnezF9IHonLmZvcm1hdChhcmNQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wLmNvbG9yc1NlcXVlbnRpYWwgPyBwcm9wLmNvbG9yc1tpXSA6IHByb3AuY29sb3JzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBwcm9wLmNvbG9yc09wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvb2x0aXAnOiAhUkcuU1ZHLmlzTnVsbChwcm9wLnRvb2x0aXBzKSAmJiBwcm9wLnRvb2x0aXBzLmxlbmd0aCA/IHByb3AudG9vbHRpcHNbaV0gOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeCc6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jZW50ZXJ5JzogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXZhbHVlJzogdGhpcy5kYXRhW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXN0YXJ0LWFuZ2xlJzogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZW5kLWFuZ2xlJzogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXJhZGl1cyc6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1zZXF1ZW50aWFsJzogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCB0byB0aGUgYW5nbGVzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzMltpXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmFkaXVzLWlubmVyJzogcHJldlJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bal1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHMgJiYgcHJvcC50b29sdGlwc1tpXSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSB0b29sdGlwc0V2ZW50IGRlZmF1bHQgdG8gY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgIT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC50b29sdGlwc0V2ZW50ID0gJ2NsaWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpbmRleCwgb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHJlY3QgdGhhdCBoYXMgYmVlbiBjbGlja2VkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5oaWdobGlnaHQoZS50YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YWxsIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNoYW5nZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Vyc29yIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoaSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRHJhd3MgdGhlIHJhZGFyLCBidXQgb25seSB0aGUgbm9uLWVxdWktYW5ndWxhciB2YXJpYW50XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhd1Jvc2VOb25FcXVpQW5ndWxhciA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2cnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZ3JhcGhfcm9zZV9zZWdtZW50c18nICsgdGhpcy5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL0xvb3AgdGhyb3VnaCB0aGUgZGF0YSBzdW1taW5nIHRoZSBzZWNvbmQgZGF0YS1waWVjZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0b3RhbCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBwYXJzZUZsb2F0KHRoaXMuZGF0YVtpXVsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBpbml0aWFsIGFuZ2xlc1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgICAgICAgICAgLy8gTm93IGxvb3AgdGhydSB0aGUgZGF0YVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHNlcSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2ksICsrc2VxKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFkaWFucyA9IHRoaXMuZGF0YVtpXVsxXSAvIHRvdGFsICogUkcuU1ZHLlRSSUcuVFdPUEksXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgcmFkaWFucztcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZXhwbG9kZWQgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZXhwbG9zaW9uID0gdGhpcy5nZXRFeHBsb2RlZCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQgLSBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kIC0gUkcuU1ZHLlRSSUcuSEFMRlBJXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBIHN0YWNrZWQgbm9uLWVxdWktYW5ndWxhciBzZWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldWzBdKSA9PT0gJ29iamVjdCcgJiYgIVJHLlNWRy5pc051bGwodGhpcy5kYXRhW2ldWzBdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhydSB0aGUgc2V0IG9mIHZhbHVlcyBmb3IgdGhpcyBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBzdW0gPSAwOyBqIDwgdGhpcy5kYXRhW2ldWzBdLmxlbmd0aDsgKytqLCArK3NlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5kYXRhW2ldWzBdW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBzZWdtZW50IGluIHRoZSBzdGFjayBvciBub3Q/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZSYWRpdXMgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSBzdW0gLyB0aGlzLnNjYWxlLm1heCAqIHRoaXMucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoMih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICsgcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kIC0gcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJjUGF0aDIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlJhZGl1cyA9IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIGl0ZXJhdGlvbnMgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gc3VtIC8gdGhpcy5zY2FsZS5tYXggKiB0aGlzLnJhZGl1cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmNQYXRoID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCArIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyY1BhdGgyID0gUkcuU1ZHLlRSSUcuZ2V0QXJjUGF0aDIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZW5kIC0gcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnQgKyBwcm9wLm1hcmdpbiArIHByb3Auc2VnbWVudHNBbmdsZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAnezF9IHsyfSB6Jy5mb3JtYXQoYXJjUGF0aCwgYXJjUGF0aDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wLmNvbG9yc1NlcXVlbnRpYWwgPyBwcm9wLmNvbG9yc1tzZXFdIDogcHJvcC5jb2xvcnNbal0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBwcm9wLmNvbG9yc09wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5zdHJva2VzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10b29sdGlwJzogIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwcy5sZW5ndGggPyBwcm9wLnRvb2x0aXBzW2ldIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcngnOiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcnknOiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWluZGV4JzogJ1t7MX0sezJ9XScuZm9ybWF0KGksIGopLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS12YWx1ZSc6IHRoaXMuZGF0YVtpXVswXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3RhcnQtYW5nbGUnOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZW5kLWFuZ2xlJzogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1yYWRpdXMnOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXJhZGl1cy1pbm5lcic6IHByZXZSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwnOiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50IHRvIHRoZSBhbmdsZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4ICsgZXhwbG9zaW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnkgKyBleHBsb3Npb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyYWRpdXMtaW5uZXInOiBwcmV2UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlczJbaV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyeCArIGV4cGxvc2lvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmFkaXVzLWlubmVyJzogcHJldlJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhW2ldW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCB0b29sdGlwcyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzICYmIHByb3AudG9vbHRpcHNbc2VxXSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgdG9vbHRpcHNFdmVudCBkZWZhdWx0IHRvIGNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCAhPT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC50b29sdGlwc0V2ZW50ID0gJ2NsaWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGluZGV4LCBncm91cCwgc2VxLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVIaWdobGlnaHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tzZXFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSByZWN0IHRoYXQgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgdGhlIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2hhbmdlcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Vyc29yIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoaiwgaSwgc2VxLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UmFkaXVzID0gcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlcS0tO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmVndWxhciBub24tZXF1aS1hbmd1bGFyIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5kYXRhW2ldWzBdIC8gdGhpcy5zY2FsZS5tYXggKiB0aGlzLnJhZGl1cztcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJjUGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcjogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICsgcHJvcC5tYXJnaW4gKyBwcm9wLnNlZ21lbnRzQW5nbGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCAtIHByb3AubWFyZ2luICsgcHJvcC5zZWdtZW50c0FuZ2xlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBSRy5TVkcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6ICd7MX0geicuZm9ybWF0KGFyY1BhdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHByb3AuY29sb3JzU2VxdWVudGlhbCA/IHByb3AuY29sb3JzW2ldIDogcHJvcC5jb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHByb3AuY29sb3JzT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHByb3Auc3Ryb2tlc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHByb3AubGluZXdpZHRoLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdG9vbHRpcCc6ICFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHMubGVuZ3RoID8gcHJvcC50b29sdGlwc1tpXSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNlbnRlcngnOiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY2VudGVyeSc6IHRoaXMuY2VudGVyeSArIGV4cGxvc2lvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdmFsdWUnOiB0aGlzLmRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtc3RhcnQtYW5nbGUnOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1lbmQtYW5nbGUnOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmFkaXVzJzogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXNlcXVlbnRpYWwnOiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50IHRvIHRoZSBhbmdsZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRhdGFbaV1bMF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMyW2ldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyYWRpdXMtaW5uZXInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGF0YVtpXVtqXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC50b29sdGlwcyAmJiBwcm9wLnRvb2x0aXBzW2ldKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHRvb2x0aXBzRXZlbnQgZGVmYXVsdCB0byBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCAhPT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnRvb2x0aXBzRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGluZGV4LCBncm91cCwgc2VxLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRy5TVkcudG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG9iaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbnRpYWxJbmRleDogc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHJlY3QgdGhhdCBoYXMgYmVlbiBjbGlja2VkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5oaWdobGlnaHQoZS50YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudG9vbHRpcHNFdmVudCA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YWxsIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNoYW5nZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Vyc29yIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoaSwgaSwgc2VxLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aGUgc3RhcnQgYW5nbGUgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHJhZGlhbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVkcmF3cyB0aGUgY2hhcnQgaWYgcmVxdWlyZWRcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yZWRyYXdSb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRHJhdyB0aGUgbGFiZWxzXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHNjYWxlIGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpZiAocHJvcC5zY2FsZVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NhbGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNlbnRlcng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5jZW50ZXJ5IC0gdGhpcy5yYWRpdXMgLyB0aGlzLnNjYWxlLmxhYmVscy5sZW5ndGggKiAoaSArIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIFJHLlNWRy50ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc2NhbGUubGFiZWxzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5zY2FsZVNpemUgfHwgcHJvcC50ZXh0U2l6ZSAtIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHByb3Auc2NhbGVDb2xvciB8fCBwcm9wLnRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHR5cGVvZiBwcm9wLnNjYWxlQm9sZCA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5zY2FsZUJvbGQgOiBwcm9wLnRleHRCb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRhbGljOiB0eXBlb2YgcHJvcC5zY2FsZUl0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5zY2FsZUl0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IHByb3Auc2NhbGVGb250IHx8IHByb3AudGV4dEZvbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgemVybyBsYWJlbFxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBSRy5TVkcubnVtYmVyRm9ybWF0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBudW06IHRoaXMuc2NhbGUubWluLnRvRml4ZWQocHJvcC5zY2FsZURlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZDogcHJvcC5zY2FsZVVuaXRzUHJlLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmQ6IHByb3Auc2NhbGVVbml0c1Bvc3QsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwcm9wLnNjYWxlUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHRob3VzYW5kOiBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogcHJvcC5zY2FsZUZvcm1hdHRlclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdHIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHByb3Auc2NhbGVTaXplIHx8IHByb3AudGV4dFNpemUgLSAyLFxuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDIsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBwcm9wLnNjYWxlQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IHR5cGVvZiBwcm9wLnNjYWxlQm9sZCA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5zY2FsZUJvbGQgOiBwcm9wLnRleHRCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWM6IHR5cGVvZiBwcm9wLnNjYWxlSXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLnNjYWxlSXRhbGljIDogcHJvcC50ZXh0SXRhbGljLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBwcm9wLnNjYWxlRm9udCB8fCBwcm9wLnRleHRGb250XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZWQgZnVydGhlciBkb3duXG4gICAgICAgICAgICB2YXIgaGFsaWduO1xuXG4gICAgICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHNpemUgZm9yIHRoZSBsYWJlbHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcC5sYWJlbHNTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHByb3AubGFiZWxzU2l6ZSA9IHByb3AudGV4dFNpemUgKyA0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBjaXJjdWxhciBsYWJlbHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3AubGFiZWxzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcC52YXJpYW50ID09PSAnbm9uLWVxdWktYW5ndWxhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gKHRoaXMuYW5nbGVzMltpXVswXS5lbmQgLSB0aGlzLmFuZ2xlczJbaV1bMF0uc3RhcnQpIC8gMiArIHRoaXMuYW5nbGVzMltpXVswXS5zdGFydCAtIFJHLlNWRy5UUklHLkhBTEZQSTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBSRy5TVkcuVFJJRy5UV09QSSAvIHByb3AubGFiZWxzLmxlbmd0aCAqIGkgLSBSRy5TVkcuVFJJRy5IQUxGUEkgKyBwcm9wLmxhYmVsc0FuZ2xlT2Zmc2V0ICsgKHRoaXMuYW5nbGVzMltpXVswXS5lbmQgLSB0aGlzLmFuZ2xlczJbaV1bMF0uc3RhcnQpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSBSRy5TVkcuVFJJRy5nZXRSYWRpdXNFbmRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHI6IHRoaXMucmFkaXVzICsgcHJvcC5sYWJlbHNSYWRpYWxNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjb21tb2RhdGUgdGhlIGV4cGxvc2lvbiBmb3IgdGhlIGxhYmVsXG4gICAgICAgICAgICAgICAgdmFyIGV4cGxvc2lvbiA9IHRoaXMuZ2V0RXhwbG9kZWQoe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuYW5nbGVzMltpXVswXS5zdGFydCAtIFJHLlNWRy5UUklHLkhBTEZQSSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB0aGlzLmFuZ2xlczJbaV1bMF0uZW5kIC0gUkcuU1ZHLlRSSUcuSEFMRlBJXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlbmRwb2ludFswXSArPSB0aGlzLmNlbnRlcnggKyBleHBsb3Npb25bMF07XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRbMV0gKz0gdGhpcy5jZW50ZXJ5ICsgZXhwbG9zaW9uWzFdO1xuXG4gICAgICAgICAgICAgICAgLy8gRG8gdGhlIGFsaWdubWVudCBiYXNlZCBvbiB3aGljaCBxdWFkcmFudCB0aGUgbGFiZWwgaXMgaW5cbiAgICAgICAgICAgICAgICBpZiAobWEucm91bmQoZW5kcG9pbnRbMF0pID4gdGhpcy5jZW50ZXJ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hLnJvdW5kKGVuZHBvaW50WzBdKSA9PT0gdGhpcy5jZW50ZXJ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2YgcHJvcC5sYWJlbHNbaV0gPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNbaV0gOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5sYWJlbHNTaXplLFxuICAgICAgICAgICAgICAgICAgICB4OiBlbmRwb2ludFswXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZW5kcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbjogaGFsaWduLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMixcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHByb3AubGFiZWxzQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IHR5cGVvZiBwcm9wLmxhYmVsc0JvbGQgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzQm9sZCA6IHByb3AudGV4dEJvbGQsXG4gICAgICAgICAgICAgICAgICAgIGl0YWxpYzogdHlwZW9mIHByb3AubGFiZWxzSXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc0l0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogcHJvcC5sYWJlbHNGb250IHx8IHByb3AudGV4dEZvbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGhpZ2hsaWdodCBhIHNlZ21lbnQgb24gdGhlIGNoYXJ0XG4gICAgICAgICogXG4gICAgICAgICogQHBhcmFtIG9iamVjdCBjaXJjbGUgVGhlIGNpcmNsZSB0byBoaWdobGlnaHRcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoLmdldEF0dHJpYnV0ZSgnZCcpO1xuXG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wLmhpZ2hsaWdodEZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5oaWdobGlnaHRTdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocHJvcC50b29sdGlwc0V2ZW50ID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIFJHLlNWRy5oaWRlVG9vbHRpcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIFJHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBoaWdobGlnaHQgcmVjdCBpbiB0aGUgcmVnaXN0cnkgc29cbiAgICAgICAgICAgIC8vIGl0IGNhbiBiZSBjbGVhcmVkIGxhdGVyXG4gICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGFsbG93cyBmb3IgZWFzeSBzcGVjaWZpY2F0aW9uIG9mIGdyYWRpZW50c1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgY29sb3JzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdG9yZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlc2V0XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLFxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRGaWxsOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmhpZ2hsaWdodEZpbGwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29sb3JzXG4gICAgICAgICAgICB2YXIgY29sb3JzID0gcHJvcC5jb2xvcnM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBSRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGZpbGxcbiAgICAgICAgICAgIHByb3AuaGlnaGxpZ2h0RmlsbCA9IFJHLlNWRy5wYXJzZUNvbG9yUmFkaWFsKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgY29sb3I6IHByb3AuaGlnaGxpZ2h0RmlsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZ2V0TWF4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgICAgICAgaWYgKHByb3AudmFyaWFudCA9PT0gJ25vbi1lcXVpLWFuZ3VsYXInKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFSRy5TVkcuaXNOdWxsKHRoaXMuZGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1hLm1heChtYXgsIHRoaXMuZGF0YVtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YodGhpcy5kYXRhW2ldWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBtYS5tYXgobWF4LCBSRy5TVkcuYXJyYXlTdW0odGhpcy5kYXRhW2ldWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUkcuU1ZHLmlzTnVsbCh0aGlzLmRhdGFbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBtYS5tYXgobWF4LCB0aGlzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMuZGF0YVtpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWEubWF4KG1heCwgUkcuU1ZHLmFycmF5U3VtKHRoaXMuZGF0YVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBHZXRzIHRoZSByYWRpdXMgb2YgYSB2YWx1ZVxuICAgICAgICAvL1xuICAgICAgICAvL0BwYXJhbSBudW1iZXIgVGhlIHZhbHVlIHRvIGdldCB0aGUgcmFkaXVzIGZvclxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmdldFJhZGl1cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHByb3Auc2NhbGVNaW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gcHJvcC5zY2FsZU1pbikgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBBIHJvdW5kUm9iaW4gZWZmZWN0IGZvciB0aGUgUGllIGNoYXJ0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEBwYXJhbSBvYmplY3QgICAgT3B0aW9ucyBmb3IgdGhlIGVmZmVjdFxuICAgICAgICAvLyBAcGFyYW0gZnVuY3Rpb24gIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlblxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHRoZSBlZmZlY3QgaXMgY29tcGxldGVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yb3VuZFJvYmluID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogVXNpbmcgYSBmdW5jdGlvbiB0byBhZGQgZXZlbnRzIG1ha2VzIGl0IGVhc2llciB0byBmYWNpbGl0YXRlIG1ldGhvZFxuICAgICAgICAqIGNoYWluaW5nXG4gICAgICAgICogXG4gICAgICAgICogQHBhcmFtIHN0cmluZyAgIHR5cGUgVGhlIHR5cGUgb2YgZXZlbiB0byBhZGRcbiAgICAgICAgKiBAcGFyYW0gZnVuY3Rpb24gZnVuYyBcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBVc2VkIGluIGNoYWluaW5nLiBSdW5zIGEgZnVuY3Rpb24gdGhlcmUgYW5kIHRoZW4gLSBub3Qgd2FpdGluZyBmb3JcbiAgICAgICAgLy8gdGhlIGV2ZW50cyB0byBmaXJlIChlZyB0aGUgb25iZWZvcmVkcmF3IGV2ZW50KVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gQHBhcmFtIGZ1bmN0aW9uIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIGZ1bmModGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgaGlnaGxpZ2h0IGZyb20gdGhlIGNoYXJ0XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gdGhpcy5oaWRlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtcblxuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodCAmJiB0aGlzLmhpZ2hsaWdodF9ub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodF9ub2RlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ3RyYW5zcGFyZW50Jyk7XG5cbiAgICAgICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgZXhwbG9kZWQgWC9ZIGZvciBhIGdpdmVuIGV4cGxvc2lvblxuICAgICAgICAvL1xuICAgICAgICAvL1RPRE8gTmVlZHMgdXBkYXRpbmcgdG8gY3VycmVudCBjb2Rpbmcgc3R5bGUsIGluY2x1ZGluZyBjb252ZXJ0aW5nXG4gICAgICAgIC8vICAgICBhcmd1bWVudHMgdG8gYW4gb2JqZWN0XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZ2V0RXhwbG9kZWQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBvcHQuaW5kZXgsXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBvcHQuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kID0gb3B0LmVuZCxcbiAgICAgICAgICAgICAgICBleHBsb2RlZCA9IHByb3AuZXhwbG9kZWQsXG4gICAgICAgICAgICAgICAgZXhwbG9kZWRYLFxuICAgICAgICAgICAgICAgIGV4cGxvZGVkWTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIFJldHJpZXZlIGFueSBleHBsb2RlZCAtIHRoZSBleHBsb2RlZCBjYW4gYmUgYW4gYXJyYXkgb2YgbnVtYmVycyBvciBhIHNpbmdsZSBudW1iZXJcbiAgICAgICAgICAgICogKHdoaWNoIGlzIGFwcGxpZWQgdG8gYWxsIHNlZ21lbnRzKVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICgodHlwZW9mIGV4cGxvZGVkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleHBsb2RlZCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwbG9kZWRbaW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGV4cGxvZGVkWCA9IG1hLmNvcygoZW5kIC0gc3RhcnQpIC8gMiArIHN0YXJ0KSAqIGV4cGxvZGVkW2luZGV4XTtcbiAgICAgICAgICAgICAgICBleHBsb2RlZFkgPSBtYS5zaW4oKGVuZCAtIHN0YXJ0KSAvIDIgKyBzdGFydCkgKiBleHBsb2RlZFtpbmRleF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBsb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBleHBsb2RlZFggPSBtYS5jb3MoKGVuZCAtIHN0YXJ0KSAvIDIgKyBzdGFydCkgKiBleHBsb2RlZDtcbiAgICAgICAgICAgICAgICBleHBsb2RlZFkgPSBtYS5zaW4oKGVuZCAtIHN0YXJ0KSAvIDIgKyBzdGFydCkgKiBleHBsb2RlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwbG9kZWRYID0gMDtcbiAgICAgICAgICAgICAgICBleHBsb2RlZFkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2V4cGxvZGVkWCwgZXhwbG9kZWRZXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBTZXQgdGhlIG9wdGlvbnMgdGhhdCB0aGUgdXNlciBoYXMgcHJvdmlkZWRcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpIGluIGNvbmYub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBFbmQgbW9kdWxlIHBhdHRlcm5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcucm9zZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///216\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Scatter = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'scatter';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;this.sequential = 0;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, xmax: 0, tickmarksStyle: 'cross', tickmarksSize: 7, colors: ['black'], line: false, lineColors: 1, lineLinewidth: 'black', yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 3, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, xaxisMin: 0, xaxisMax: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'mousemove', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n    if (this.data[0] && !RG.SVG.isArray(this.data[0])) {\n      this.data = [];this.data[0] = conf.data;\n    }\n    if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;if (typeof prop.xaxisMin === 'string') {\n      prop.xaxisMin = RG.SVG.parseDate(prop.xaxisMin);\n    }\n    if (typeof prop.xaxisMax === 'string') {\n      prop.xaxisMax = RG.SVG.parseDate(prop.xaxisMax);\n    }\n    for (var i = 0; i < this.data.length; ++i) {\n      for (var j = 0; j < this.data[i].length; ++j) {\n        if (typeof this.data[i][j].x === 'string') {\n          this.data[i][j].x = RG.SVG.parseDate(this.data[i][j].x);\n        }\n      }\n    }\n    this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();for (var ds = 0, max = 0; ds < this.data.length; ++ds) {\n        for (var dp = 0; dp < this.data[ds].length; ++dp) {\n          max = ma.max(max, this.data[ds][dp].y);\n        }\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);var dataset_group = RGraph.SVG.create({ svg: this.svg, type: 'g', parent: this.svg.all, attr: { className: 'scatter_datasets_' + this.uid } });for (var i = 0; i < this.data.length; ++i) {\n        this.drawPoints({ index: i, data: this.data[i], group: dataset_group });if (prop.line == true || _typeof(prop.line) === 'object' && prop.line[i] == true) {\n          this.drawLine({ index: i, coords: this.coords[i] });\n        }\n      }\n      if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawPoints = function (opt) {\n      var index = opt.index,\n          data = opt.data,\n          group = opt.group;this.coords[index] = [];var group = RG.SVG.create({ svg: this.svg, type: 'g', parent: group, attr: { className: 'scatter_dataset_' + index + '_' + this.uid } });for (var i = 0; i < data.length; ++i) {\n        var point = data[i];if (typeof point.x === 'number' && typeof point.y === 'number') {\n          var ret = this.drawSinglePoint({ dataset: data, datasetIdx: index, point: point, index: i, group: group, sequential: this.sequential++ });this.coords[index][i] = [ret.x, ret.y];\n        }\n        if (typeof data[i].tooltip === 'string' && data[i].tooltip || typeof data[i].tooltip === 'number') {\n          var _RG$SVG$create;\n\n          data[i].tooltip = String(data[i].tooltip);if (prop.tooltipsEvent !== 'mousemove') {\n            prop.tooltipsEvent = 'click';\n          }\n          if (!group_tooltip_hotspots) {\n            var group_tooltip_hotspots = RG.SVG.create({ svg: this.svg, parent: this.svg.all, type: 'g', attr: { className: 'rgraph-scatter-tooltip-hotspots' } });\n          }\n          var rect = RG.SVG.create((_RG$SVG$create = { svg: this.svg, parent: this.svg.all, type: 'rect' }, _defineProperty(_RG$SVG$create, 'parent', group_tooltip_hotspots), _defineProperty(_RG$SVG$create, 'attr', { x: ret.x - ret.size / 2, y: ret.y - ret.size / 2, width: ret.size, height: ret.size, fill: 'transparent', stroke: 'transparent', 'stroke-width': 0 }), _defineProperty(_RG$SVG$create, 'style', { cursor: 'pointer' }), _RG$SVG$create));ret.mark.hotspot = rect;(function (dataset, index, seq, obj) {\n            rect.addEventListener(prop.tooltipsEvent, function (e) {\n              var tooltip = RG.SVG.REG.get('tooltip');if (tooltip && tooltip.__dataset__ === dataset && tooltip.__index__ === index) {\n                return;\n              }\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, dataset: dataset, index: index, sequentialIndex: seq, text: obj.data[dataset][index].tooltip, event: e });if (RG.SVG.REG.get('tooltip')) {\n                obj.highlight(this);\n              }\n            }, false);if (prop.tooltipsEvent === 'click') {\n              rect.addEventListener('mousemove', function (e) {\n                e.target.style.cursor = 'pointer';\n              }, false);\n            }\n          })(index, i, this.sequential - 1, this);\n        }\n      }\n    };this.drawSinglePoint = function (opt) {\n      var dataset = opt.dataset,\n          datasetIdx = opt.datasetIdx,\n          seq = opt.sequential,\n          point = opt.point,\n          index = opt.index,\n          valueX = opt.point.x,\n          valueY = opt.point.y,\n          conf = opt.point || {},\n          group = opt.group,\n          coordX = opt.coordx = this.getXCoord(valueX),\n          coordY = opt.coordy = this.getYCoord(valueY);if (typeof conf.type === 'undefined' && typeof conf.shape !== 'undefined') {\n        conf.type = conf.shape;\n      }\n      if (typeof conf.type === 'string') {} else if (typeof prop.tickmarksStyle === 'string') {\n        conf.type = prop.tickmarksStyle;\n      } else if (_typeof(prop.tickmarksStyle) === 'object' && typeof prop.tickmarksStyle[datasetIdx] === 'string') {\n        conf.type = prop.tickmarksStyle[datasetIdx];\n      }\n      if (typeof conf.size !== 'number' && typeof prop.tickmarksSize === 'number') {\n        conf.size = prop.tickmarksSize;\n      } else if (typeof conf.size !== 'number' && _typeof(prop.tickmarksSize) === 'object' && typeof prop.tickmarksSize[datasetIdx] === 'number') {\n        conf.size = prop.tickmarksSize[datasetIdx];\n      }\n      if (typeof conf.color === 'string') {} else if (typeof prop.colors[datasetIdx] === 'string') {\n        conf.color = prop.colors[datasetIdx];\n      } else {\n        conf.color = 'black';\n      }\n      if (typeof conf.opacity === 'undefined') {\n        conf.opacity = 1;\n      } else if (typeof conf.opacity === 'number') {}\n      if (prop.bubble) {\n        return this.drawBubble(opt, conf);\n      }\n      switch (conf.type) {case 'image:' + conf.type.substr(6):\n          var src = conf.type.substr(6);var img = new Image();img.src = src;var mark = RG.SVG.create({ svg: this.svg, type: 'image', parent: group, attr: { preserveAspectRatio: 'xMidYMid meet', 'xlink:href': src } });img.onload = function () {\n            var x = coordX - img.width / 2,\n                y = coordY - img.height / 2,\n                w = img.width,\n                h = img.height;mark.setAttribute('x', x);mark.setAttribute('y', y);mark.setAttribute('width', w);mark.setAttribute('height', h);if (mark && mark.hotspot) {\n              mark.hotspot.setAttribute('x', x);mark.hotspot.setAttribute('y', y);mark.hotspot.setAttribute('width', w);mark.hotspot.setAttribute('height', h);\n            }\n          };break;case 'triangle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} L {5} {6}'.format(coordX - conf.size / 2, coordY + conf.size / 2, coordX, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2), fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'plus':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY, coordX + conf.size / 2, coordY, coordX, coordY - conf.size / 2, coordX, coordY + conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;case 'square':case 'rect':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'rect', parent: group, attr: { x: coordX - conf.size / 2, y: coordY - conf.size / 2, width: conf.size, height: conf.size, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'dot':case 'circle':\n          var mark = RG.SVG.create({ svg: this.svg, type: 'circle', parent: group, attr: { cx: coordX, cy: coordY, r: conf.size / 2, fill: conf.color, 'fill-opacity': conf.opacity } });break;case 'cross':default:\n          var mark = RG.SVG.create({ svg: this.svg, type: 'path', parent: group, attr: { d: 'M {1} {2} L {3} {4} M {5} {6} L {7} {8}'.format(coordX - conf.size / 2, coordY - conf.size / 2, coordX + conf.size / 2, coordY + conf.size / 2, coordX - conf.size / 2, coordY + conf.size / 2, coordX + conf.size / 2, coordY - conf.size / 2), stroke: conf.color, 'stroke-opacity': conf.opacity } });break;}\n      mark.setAttribute('data-index', index);mark.setAttribute('data-dataset', datasetIdx);mark.setAttribute('data-original-opacity', conf.opacity);mark.setAttribute('data-original-color', conf.color);mark.setAttribute('data-original-coordx', coordX);mark.setAttribute('data-original-coordy', coordY);mark.setAttribute('data-size', conf.size);mark.setAttribute('data-sequential', seq);mark.setAttribute('data-type', conf.type);return { x: coordX, y: coordY, size: conf.type.substr(0, 6) === 'image:' ? img.width : conf.size, mark: mark, type: conf.type };\n    };this.drawBubble = function (opt, conf) {\n      var size = conf.z / prop.bubbleMaxValue * prop.bubbleMaxRadius;var color = RG.SVG.parseColorRadial({ object: this, color: prop.bubbleColorsSolid ? conf.color : 'Gradient(white:' + conf.color + ')', cx: opt.coordx + size / 4, cy: opt.coordy - size / 4, fx: opt.coordx + size / 4, fy: opt.coordy - size / 4, r: size * 1.5 });var circle = RG.SVG.create({ svg: this.svg, type: 'circle', attr: { cx: opt.coordx, cy: opt.coordy, r: size, fill: color, 'fill-opacity': conf.opacity } });circle.setAttribute('data-index', opt.index);circle.setAttribute('data-dataset', opt.datasetIdx);circle.setAttribute('data-original-opacity', conf.opacity);circle.setAttribute('data-original-color', conf.color);circle.setAttribute('data-original-coordx', opt.coordx);circle.setAttribute('data-original-coordy', opt.coordy);circle.setAttribute('data-size', size);circle.setAttribute('data-sequential', opt.sequential);circle.setAttribute('data-type', 'bubble');return { x: opt.coordx, y: opt.coordy, z: opt.coordz };\n    };this.drawLine = function (opt) {\n      var linewidth = 1,\n          color = 'black';if (_typeof(prop.lineLinewidth) === 'object' && typeof prop.lineLinewidth[opt.index] === 'number') {\n        linewidth = prop.lineLinewidth[opt.index];\n      } else if (typeof prop.lineLinewidth === 'number') {\n        linewidth = prop.lineLinewidth;\n      } else {\n        linewidth = 1;\n      }\n      if (_typeof(prop.lineColors) === 'object' && prop.lineColors[opt.index]) {\n        color = prop.lineColors[opt.index];\n      } else if (prop.colors[opt.index] === 'string') {\n        color = prop.colors[opt.index];\n      } else {\n        color = 'black';\n      }\n      for (var i = 0, path = ''; i < this.coords[opt.index].length; ++i) {\n        path += '{1} {2} {3} '.format(i === 0 ? 'M' : 'L', this.coords[opt.index][i][0], this.coords[opt.index][i][1]);\n      }\n      RG.SVG.create({ svg: this.svg, type: 'path', parent: this.svg.all, attr: { d: path, fill: 'transparent', stroke: color, 'stroke-width': linewidth, 'stroke-linecap': 'round', 'stroke-linejoin': 'round' } });\n    };this.getXCoord = function (value) {\n      var x;if (value > prop.xaxisMax) {\n        return null;\n      }\n      if (value < prop.xaxisMin) {\n        return null;\n      }\n      x = (value - prop.xaxisMin) / (prop.xaxisMax - prop.xaxisMin);x *= this.width - prop.gutterLeft - prop.gutterRight;x = prop.gutterLeft + x;return x;\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      rect.setAttribute('fill', prop.highlightFill);RG.SVG.REG.set('highlight', rect);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors && !prop.bubble) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight) {\n        highlight.setAttribute('fill', 'transparent');RG.SVG.REG.set('highlight', null);\n      }\n    };\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuc2NhdHRlci5qcz9lMzYwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307KGZ1bmN0aW9uICh3aW4sIGRvYywgdW5kZWZpbmVkKSB7XG4gIHZhciBSRyA9IFJHcmFwaCxcbiAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIG1hID0gTWF0aCxcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50O1JHLlNWRy5TY2F0dGVyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoaSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7IG9iamVjdDogdGhpcywgbmFtZTogaSwgdmFsdWU6IGFyZ3VtZW50c1swXVtpXSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtuYW1lID0gcmV0Lm5hbWU7dmFsdWUgPSByZXQudmFsdWU7dGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuaWQgPSBjb25mLmlkO3RoaXMudWlkID0gUkcuU1ZHLmNyZWF0ZVVJRCgpO3RoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5zdmcgPSBSRy5TVkcuY3JlYXRlU1ZHKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7dGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7dGhpcy5kYXRhID0gY29uZi5kYXRhO3RoaXMudHlwZSA9ICdzY2F0dGVyJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O3RoaXMuZ3JhZGllbnRDb3VudGVyID0gMTt0aGlzLnNlcXVlbnRpYWwgPSAwO1JHLlNWRy5PUi5hZGQodGhpcyk7dGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO3RoaXMucHJvcGVydGllcyA9IHsgZ3V0dGVyTGVmdDogMzUsIGd1dHRlclJpZ2h0OiAzNSwgZ3V0dGVyVG9wOiAzNSwgZ3V0dGVyQm90dG9tOiAzNSwgYmFja2dyb3VuZENvbG9yOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2U6IG51bGwsIGJhY2tncm91bmRJbWFnZUFzcGVjdDogJ25vbmUnLCBiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoOiB0cnVlLCBiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5OiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VYOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VZOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VXOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VIOiBudWxsLCBiYWNrZ3JvdW5kR3JpZDogdHJ1ZSwgYmFja2dyb3VuZEdyaWRDb2xvcjogJyNkZGQnLCBiYWNrZ3JvdW5kR3JpZExpbmV3aWR0aDogMSwgYmFja2dyb3VuZEdyaWRIbGluZXM6IHRydWUsIGJhY2tncm91bmRHcmlkSGxpbmVzQ291bnQ6IG51bGwsIGJhY2tncm91bmRHcmlkVmxpbmVzOiB0cnVlLCBiYWNrZ3JvdW5kR3JpZFZsaW5lc0NvdW50OiBudWxsLCBiYWNrZ3JvdW5kR3JpZEJvcmRlcjogdHJ1ZSwgeG1heDogMCwgdGlja21hcmtzU3R5bGU6ICdjcm9zcycsIHRpY2ttYXJrc1NpemU6IDcsIGNvbG9yczogWydibGFjayddLCBsaW5lOiBmYWxzZSwgbGluZUNvbG9yczogMSwgbGluZUxpbmV3aWR0aDogJ2JsYWNrJywgeWF4aXM6IHRydWUsIHlheGlzVGlja21hcmtzOiB0cnVlLCB5YXhpc1RpY2ttYXJrc0xlbmd0aDogMywgeWF4aXNDb2xvcjogJ2JsYWNrJywgeWF4aXNTY2FsZTogdHJ1ZSwgeWF4aXNMYWJlbHM6IG51bGwsIHlheGlzTGFiZWxzT2Zmc2V0eDogMCwgeWF4aXNMYWJlbHNPZmZzZXR5OiAwLCB5YXhpc0xhYmVsc0NvdW50OiA1LCB5YXhpc1VuaXRzUHJlOiAnJywgeWF4aXNVbml0c1Bvc3Q6ICcnLCB5YXhpc1N0cmljdDogZmFsc2UsIHlheGlzRGVjaW1hbHM6IDAsIHlheGlzUG9pbnQ6ICcuJywgeWF4aXNUaG91c2FuZDogJywnLCB5YXhpc1JvdW5kOiBmYWxzZSwgeWF4aXNNYXg6IG51bGwsIHlheGlzTWluOiAwLCB5YXhpc0Zvcm1hdHRlcjogbnVsbCwgeGF4aXM6IHRydWUsIHhheGlzVGlja21hcmtzOiB0cnVlLCB4YXhpc1RpY2ttYXJrc0xlbmd0aDogNSwgeGF4aXNMYWJlbHM6IG51bGwsIHhheGlzTGFiZWxzUG9zaXRpb246ICdzZWN0aW9uJywgeGF4aXNMYWJlbHNQb3NpdGlvbkVkZ2VUaWNrbWFya3NDb3VudDogbnVsbCwgeGF4aXNDb2xvcjogJ2JsYWNrJywgeGF4aXNMYWJlbHNPZmZzZXR4OiAwLCB4YXhpc0xhYmVsc09mZnNldHk6IDAsIHhheGlzTWluOiAwLCB4YXhpc01heDogbnVsbCwgdGV4dENvbG9yOiAnYmxhY2snLCB0ZXh0Rm9udDogJ3NhbnMtc2VyaWYnLCB0ZXh0U2l6ZTogMTIsIHRleHRCb2xkOiBmYWxzZSwgdGV4dEl0YWxpYzogZmFsc2UsIHRvb2x0aXBzT3ZlcnJpZGU6IG51bGwsIHRvb2x0aXBzRWZmZWN0OiAnZmFkZScsIHRvb2x0aXBzQ3NzQ2xhc3M6ICdSR3JhcGhfdG9vbHRpcCcsIHRvb2x0aXBzRXZlbnQ6ICdtb3VzZW1vdmUnLCBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJywgaGlnaGxpZ2h0RmlsbDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsIGhpZ2hsaWdodExpbmV3aWR0aDogMSwgdGl0bGU6ICcnLCB0aXRsZVNpemU6IDE2LCB0aXRsZVg6IG51bGwsIHRpdGxlWTogbnVsbCwgdGl0bGVIYWxpZ246ICdjZW50ZXInLCB0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVDb2xvcjogJ2JsYWNrJywgdGl0bGVGb250OiBudWxsLCB0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZUl0YWxpYzogZmFsc2UsIHRpdGxlU3VidGl0bGU6ICcnLCB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsIHRpdGxlU3VidGl0bGVYOiBudWxsLCB0aXRsZVN1YnRpdGxlWTogbnVsbCwgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlU3VidGl0bGVWYWxpZ246IG51bGwsIHRpdGxlU3VidGl0bGVDb2xvcjogJyNhYWEnLCB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCwgdGl0bGVTdWJ0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZVN1YnRpdGxlSXRhbGljOiBmYWxzZSwga2V5OiBudWxsLCBrZXlDb2xvcnM6IG51bGwsIGtleU9mZnNldHg6IDAsIGtleU9mZnNldHk6IDAsIGtleVRleHRPZmZzZXR4OiAwLCBrZXlUZXh0T2Zmc2V0eTogLTEsIGtleVRleHRTaXplOiBudWxsLCBrZXlUZXh0Qm9sZDogbnVsbCwga2V5VGV4dEl0YWxpYzogbnVsbCwgYXR0cmlidXRpb246IHRydWUsIGF0dHJpYnV0aW9uWDogbnVsbCwgYXR0cmlidXRpb25ZOiBudWxsLCBhdHRyaWJ1dGlvbkhyZWY6IG51bGwsIGF0dHJpYnV0aW9uSGFsaWduOiAncmlnaHQnLCBhdHRyaWJ1dGlvblZhbGlnbjogJ2JvdHRvbScsIGF0dHJpYnV0aW9uU2l6ZTogNywgYXR0cmlidXRpb25Db2xvcjogJ2dyYXknLCBhdHRyaWJ1dGlvbkZvbnQ6ICdzYW5zLXNlcmlmJywgYXR0cmlidXRpb25JdGFsaWM6IGZhbHNlLCBhdHRyaWJ1dGlvbkJvbGQ6IGZhbHNlIH07Zm9yIChpIGluIGNvbmYub3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnNldChpLCBjb25mLm9wdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhWzBdICYmICFSRy5TVkcuaXNBcnJheSh0aGlzLmRhdGFbMF0pKSB7XG4gICAgICB0aGlzLmRhdGEgPSBbXTt0aGlzLmRhdGFbMF0gPSBjb25mLmRhdGE7XG4gICAgfVxuICAgIGlmIChSRy5TVkcuRlggJiYgdHlwZW9mIFJHLlNWRy5GWC5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUkcuU1ZHLkZYLmRlY29yYXRlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcztpZiAodHlwZW9mIHByb3AueGF4aXNNaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wLnhheGlzTWluID0gUkcuU1ZHLnBhcnNlRGF0ZShwcm9wLnhheGlzTWluKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wLnhheGlzTWF4ID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvcC54YXhpc01heCA9IFJHLlNWRy5wYXJzZURhdGUocHJvcC54YXhpc01heCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVtpXVtqXS54ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuZGF0YVtpXVtqXS54ID0gUkcuU1ZHLnBhcnNlRGF0ZSh0aGlzLmRhdGFbaV1bal0ueCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgUkcuU1ZHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7UkcuU1ZHLmNyZWF0ZURlZnModGhpcyk7dGhpcy5ncmFwaFdpZHRoID0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyTGVmdCAtIHByb3AuZ3V0dGVyUmlnaHQ7dGhpcy5ncmFwaEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbTtSRy5TVkcucmVzZXRDb2xvcnNUb09yaWdpbmFsVmFsdWVzKHsgb2JqZWN0OiB0aGlzIH0pO3RoaXMucGFyc2VDb2xvcnMoKTtmb3IgKHZhciBkcyA9IDAsIG1heCA9IDA7IGRzIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytkcykge1xuICAgICAgICBmb3IgKHZhciBkcCA9IDA7IGRwIDwgdGhpcy5kYXRhW2RzXS5sZW5ndGg7ICsrZHApIHtcbiAgICAgICAgICBtYXggPSBtYS5tYXgobWF4LCB0aGlzLmRhdGFbZHNdW2RwXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXggPSBwcm9wLnlheGlzTWF4O1xuICAgICAgfVxuICAgICAgaWYgKHByb3AueWF4aXNNaW4gPT09ICdtaXJyb3InIHx8IHByb3AueWF4aXNNaW4gPT09ICdtaWRkbGUnIHx8IHByb3AueWF4aXNNaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciBtaXJyb3JTY2FsZSA9IHRydWU7cHJvcC55YXhpc01pbiA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjYWxlID0gUkcuU1ZHLmdldFNjYWxlKHsgb2JqZWN0OiB0aGlzLCBudW1sYWJlbHM6IHByb3AueWF4aXNMYWJlbHNDb3VudCwgdW5pdHNQcmU6IHByb3AueWF4aXNVbml0c1ByZSwgdW5pdHNQb3N0OiBwcm9wLnlheGlzVW5pdHNQb3N0LCBtYXg6IG1heCwgbWluOiBwcm9wLnlheGlzTWluLCBwb2ludDogcHJvcC55YXhpc1BvaW50LCByb3VuZDogcHJvcC55YXhpc1JvdW5kLCB0aG91c2FuZDogcHJvcC55YXhpc1Rob3VzYW5kLCBkZWNpbWFsczogcHJvcC55YXhpc0RlY2ltYWxzLCBzdHJpY3Q6IHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJywgZm9ybWF0dGVyOiBwcm9wLnlheGlzRm9ybWF0dGVyIH0pO2lmIChtaXJyb3JTY2FsZSkge1xuICAgICAgICB0aGlzLnNjYWxlID0gUkcuU1ZHLmdldFNjYWxlKHsgb2JqZWN0OiB0aGlzLCBudW1sYWJlbHM6IHByb3AueWF4aXNMYWJlbHNDb3VudCwgdW5pdHNQcmU6IHByb3AueWF4aXNVbml0c1ByZSwgdW5pdHNQb3N0OiBwcm9wLnlheGlzVW5pdHNQb3N0LCBtYXg6IHRoaXMuc2NhbGUubWF4LCBtaW46IHRoaXMuc2NhbGUubWF4ICogLTEsIHBvaW50OiBwcm9wLnlheGlzUG9pbnQsIHJvdW5kOiBmYWxzZSwgdGhvdXNhbmQ6IHByb3AueWF4aXNUaG91c2FuZCwgZGVjaW1hbHM6IHByb3AueWF4aXNEZWNpbWFscywgc3RyaWN0OiB0eXBlb2YgcHJvcC55YXhpc01heCA9PT0gJ251bWJlcicsIGZvcm1hdHRlcjogcHJvcC55YXhpc0Zvcm1hdHRlciB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4ID0gdGhpcy5zY2FsZS5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlLm1pbjtwcm9wLnlheGlzTWF4ID0gdGhpcy5zY2FsZS5tYXg7cHJvcC55YXhpc01pbiA9IHRoaXMuc2NhbGUubWluO1JHLlNWRy5kcmF3QmFja2dyb3VuZCh0aGlzKTtSRy5TVkcuZHJhd1hBeGlzKHRoaXMpO1JHLlNWRy5kcmF3WUF4aXModGhpcyk7dmFyIGRhdGFzZXRfZ3JvdXAgPSBSR3JhcGguU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdnJywgcGFyZW50OiB0aGlzLnN2Zy5hbGwsIGF0dHI6IHsgY2xhc3NOYW1lOiAnc2NhdHRlcl9kYXRhc2V0c18nICsgdGhpcy51aWQgfSB9KTtmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRyYXdQb2ludHMoeyBpbmRleDogaSwgZGF0YTogdGhpcy5kYXRhW2ldLCBncm91cDogZGF0YXNldF9ncm91cCB9KTtpZiAocHJvcC5saW5lID09IHRydWUgfHwgX3R5cGVvZihwcm9wLmxpbmUpID09PSAnb2JqZWN0JyAmJiBwcm9wLmxpbmVbaV0gPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZHJhd0xpbmUoeyBpbmRleDogaSwgY29vcmRzOiB0aGlzLmNvb3Jkc1tpXSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wLmtleSAhPT0gbnVsbCAmJiBSRy5TVkcuZHJhd0tleSkge1xuICAgICAgICBSRy5TVkcuZHJhd0tleSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSkge1xuICAgICAgICBhbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hdHRyaWJ1dGlvbih0aGlzKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuZHJhd1BvaW50cyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHZhciBpbmRleCA9IG9wdC5pbmRleCxcbiAgICAgICAgICBkYXRhID0gb3B0LmRhdGEsXG4gICAgICAgICAgZ3JvdXAgPSBvcHQuZ3JvdXA7dGhpcy5jb29yZHNbaW5kZXhdID0gW107dmFyIGdyb3VwID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdnJywgcGFyZW50OiBncm91cCwgYXR0cjogeyBjbGFzc05hbWU6ICdzY2F0dGVyX2RhdGFzZXRfJyArIGluZGV4ICsgJ18nICsgdGhpcy51aWQgfSB9KTtmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZGF0YVtpXTtpZiAodHlwZW9mIHBvaW50LnggPT09ICdudW1iZXInICYmIHR5cGVvZiBwb2ludC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciByZXQgPSB0aGlzLmRyYXdTaW5nbGVQb2ludCh7IGRhdGFzZXQ6IGRhdGEsIGRhdGFzZXRJZHg6IGluZGV4LCBwb2ludDogcG9pbnQsIGluZGV4OiBpLCBncm91cDogZ3JvdXAsIHNlcXVlbnRpYWw6IHRoaXMuc2VxdWVudGlhbCsrIH0pO3RoaXMuY29vcmRzW2luZGV4XVtpXSA9IFtyZXQueCwgcmV0LnldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXS50b29sdGlwID09PSAnc3RyaW5nJyAmJiBkYXRhW2ldLnRvb2x0aXAgfHwgdHlwZW9mIGRhdGFbaV0udG9vbHRpcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgX1JHJFNWRyRjcmVhdGU7XG5cbiAgICAgICAgICBkYXRhW2ldLnRvb2x0aXAgPSBTdHJpbmcoZGF0YVtpXS50b29sdGlwKTtpZiAocHJvcC50b29sdGlwc0V2ZW50ICE9PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgcHJvcC50b29sdGlwc0V2ZW50ID0gJ2NsaWNrJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFncm91cF90b29sdGlwX2hvdHNwb3RzKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBfdG9vbHRpcF9ob3RzcG90cyA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdHlwZTogJ2cnLCBhdHRyOiB7IGNsYXNzTmFtZTogJ3JncmFwaC1zY2F0dGVyLXRvb2x0aXAtaG90c3BvdHMnIH0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWN0ID0gUkcuU1ZHLmNyZWF0ZSgoX1JHJFNWRyRjcmVhdGUgPSB7IHN2ZzogdGhpcy5zdmcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCB0eXBlOiAncmVjdCcgfSwgX2RlZmluZVByb3BlcnR5KF9SRyRTVkckY3JlYXRlLCAncGFyZW50JywgZ3JvdXBfdG9vbHRpcF9ob3RzcG90cyksIF9kZWZpbmVQcm9wZXJ0eShfUkckU1ZHJGNyZWF0ZSwgJ2F0dHInLCB7IHg6IHJldC54IC0gcmV0LnNpemUgLyAyLCB5OiByZXQueSAtIHJldC5zaXplIC8gMiwgd2lkdGg6IHJldC5zaXplLCBoZWlnaHQ6IHJldC5zaXplLCBmaWxsOiAndHJhbnNwYXJlbnQnLCBzdHJva2U6ICd0cmFuc3BhcmVudCcsICdzdHJva2Utd2lkdGgnOiAwIH0pLCBfZGVmaW5lUHJvcGVydHkoX1JHJFNWRyRjcmVhdGUsICdzdHlsZScsIHsgY3Vyc29yOiAncG9pbnRlcicgfSksIF9SRyRTVkckY3JlYXRlKSk7cmV0Lm1hcmsuaG90c3BvdCA9IHJlY3Q7KGZ1bmN0aW9uIChkYXRhc2V0LCBpbmRleCwgc2VxLCBvYmopIHtcbiAgICAgICAgICAgIHJlY3QuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLnRvb2x0aXBzRXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHZhciB0b29sdGlwID0gUkcuU1ZHLlJFRy5nZXQoJ3Rvb2x0aXAnKTtpZiAodG9vbHRpcCAmJiB0b29sdGlwLl9fZGF0YXNldF9fID09PSBkYXRhc2V0ICYmIHRvb2x0aXAuX19pbmRleF9fID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7UkcuU1ZHLnRvb2x0aXAoeyBvYmplY3Q6IG9iaiwgZGF0YXNldDogZGF0YXNldCwgaW5kZXg6IGluZGV4LCBzZXF1ZW50aWFsSW5kZXg6IHNlcSwgdGV4dDogb2JqLmRhdGFbZGF0YXNldF1baW5kZXhdLnRvb2x0aXAsIGV2ZW50OiBlIH0pO2lmIChSRy5TVkcuUkVHLmdldCgndG9vbHRpcCcpKSB7XG4gICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO2lmIChwcm9wLnRvb2x0aXBzRXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgcmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKGluZGV4LCBpLCB0aGlzLnNlcXVlbnRpYWwgLSAxLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07dGhpcy5kcmF3U2luZ2xlUG9pbnQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICB2YXIgZGF0YXNldCA9IG9wdC5kYXRhc2V0LFxuICAgICAgICAgIGRhdGFzZXRJZHggPSBvcHQuZGF0YXNldElkeCxcbiAgICAgICAgICBzZXEgPSBvcHQuc2VxdWVudGlhbCxcbiAgICAgICAgICBwb2ludCA9IG9wdC5wb2ludCxcbiAgICAgICAgICBpbmRleCA9IG9wdC5pbmRleCxcbiAgICAgICAgICB2YWx1ZVggPSBvcHQucG9pbnQueCxcbiAgICAgICAgICB2YWx1ZVkgPSBvcHQucG9pbnQueSxcbiAgICAgICAgICBjb25mID0gb3B0LnBvaW50IHx8IHt9LFxuICAgICAgICAgIGdyb3VwID0gb3B0Lmdyb3VwLFxuICAgICAgICAgIGNvb3JkWCA9IG9wdC5jb29yZHggPSB0aGlzLmdldFhDb29yZCh2YWx1ZVgpLFxuICAgICAgICAgIGNvb3JkWSA9IG9wdC5jb29yZHkgPSB0aGlzLmdldFlDb29yZCh2YWx1ZVkpO2lmICh0eXBlb2YgY29uZi50eXBlID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uZi5zaGFwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uZi50eXBlID0gY29uZi5zaGFwZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29uZi50eXBlID09PSAnc3RyaW5nJykge30gZWxzZSBpZiAodHlwZW9mIHByb3AudGlja21hcmtzU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmYudHlwZSA9IHByb3AudGlja21hcmtzU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YocHJvcC50aWNrbWFya3NTdHlsZSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9wLnRpY2ttYXJrc1N0eWxlW2RhdGFzZXRJZHhdID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25mLnR5cGUgPSBwcm9wLnRpY2ttYXJrc1N0eWxlW2RhdGFzZXRJZHhdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25mLnNpemUgIT09ICdudW1iZXInICYmIHR5cGVvZiBwcm9wLnRpY2ttYXJrc1NpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmYuc2l6ZSA9IHByb3AudGlja21hcmtzU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmYuc2l6ZSAhPT0gJ251bWJlcicgJiYgX3R5cGVvZihwcm9wLnRpY2ttYXJrc1NpemUpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvcC50aWNrbWFya3NTaXplW2RhdGFzZXRJZHhdID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25mLnNpemUgPSBwcm9wLnRpY2ttYXJrc1NpemVbZGF0YXNldElkeF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmYuY29sb3IgPT09ICdzdHJpbmcnKSB7fSBlbHNlIGlmICh0eXBlb2YgcHJvcC5jb2xvcnNbZGF0YXNldElkeF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmYuY29sb3IgPSBwcm9wLmNvbG9yc1tkYXRhc2V0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmYuY29sb3IgPSAnYmxhY2snO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25mLm9wYWNpdHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbmYub3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25mLm9wYWNpdHkgPT09ICdudW1iZXInKSB7fVxuICAgICAgaWYgKHByb3AuYnViYmxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdCdWJibGUob3B0LCBjb25mKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29uZi50eXBlKSB7Y2FzZSAnaW1hZ2U6JyArIGNvbmYudHlwZS5zdWJzdHIoNik6XG4gICAgICAgICAgdmFyIHNyYyA9IGNvbmYudHlwZS5zdWJzdHIoNik7dmFyIGltZyA9IG5ldyBJbWFnZSgpO2ltZy5zcmMgPSBzcmM7dmFyIG1hcmsgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ2ltYWdlJywgcGFyZW50OiBncm91cCwgYXR0cjogeyBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgbWVldCcsICd4bGluazpocmVmJzogc3JjIH0gfSk7aW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRYIC0gaW1nLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5ID0gY29vcmRZIC0gaW1nLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgdyA9IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICBoID0gaW1nLmhlaWdodDttYXJrLnNldEF0dHJpYnV0ZSgneCcsIHgpO21hcmsuc2V0QXR0cmlidXRlKCd5JywgeSk7bWFyay5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdyk7bWFyay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGgpO2lmIChtYXJrICYmIG1hcmsuaG90c3BvdCkge1xuICAgICAgICAgICAgICBtYXJrLmhvdHNwb3Quc2V0QXR0cmlidXRlKCd4JywgeCk7bWFyay5ob3RzcG90LnNldEF0dHJpYnV0ZSgneScsIHkpO21hcmsuaG90c3BvdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdyk7bWFyay5ob3RzcG90LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTticmVhaztjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgdmFyIG1hcmsgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ3BhdGgnLCBwYXJlbnQ6IGdyb3VwLCBhdHRyOiB7IGQ6ICdNIHsxfSB7Mn0gTCB7M30gezR9IEwgezV9IHs2fScuZm9ybWF0KGNvb3JkWCAtIGNvbmYuc2l6ZSAvIDIsIGNvb3JkWSArIGNvbmYuc2l6ZSAvIDIsIGNvb3JkWCwgY29vcmRZIC0gY29uZi5zaXplIC8gMiwgY29vcmRYICsgY29uZi5zaXplIC8gMiwgY29vcmRZICsgY29uZi5zaXplIC8gMiksIGZpbGw6IGNvbmYuY29sb3IsICdmaWxsLW9wYWNpdHknOiBjb25mLm9wYWNpdHkgfSB9KTticmVhaztjYXNlICdwbHVzJzpcbiAgICAgICAgICB2YXIgbWFyayA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncGF0aCcsIHBhcmVudDogZ3JvdXAsIGF0dHI6IHsgZDogJ00gezF9IHsyfSBMIHszfSB7NH0gTSB7NX0gezZ9IEwgezd9IHs4fScuZm9ybWF0KGNvb3JkWCAtIGNvbmYuc2l6ZSAvIDIsIGNvb3JkWSwgY29vcmRYICsgY29uZi5zaXplIC8gMiwgY29vcmRZLCBjb29yZFgsIGNvb3JkWSAtIGNvbmYuc2l6ZSAvIDIsIGNvb3JkWCwgY29vcmRZICsgY29uZi5zaXplIC8gMiksIHN0cm9rZTogY29uZi5jb2xvciwgJ3N0cm9rZS1vcGFjaXR5JzogY29uZi5vcGFjaXR5IH0gfSk7YnJlYWs7Y2FzZSAnc3F1YXJlJzpjYXNlICdyZWN0JzpcbiAgICAgICAgICB2YXIgbWFyayA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncmVjdCcsIHBhcmVudDogZ3JvdXAsIGF0dHI6IHsgeDogY29vcmRYIC0gY29uZi5zaXplIC8gMiwgeTogY29vcmRZIC0gY29uZi5zaXplIC8gMiwgd2lkdGg6IGNvbmYuc2l6ZSwgaGVpZ2h0OiBjb25mLnNpemUsIGZpbGw6IGNvbmYuY29sb3IsICdmaWxsLW9wYWNpdHknOiBjb25mLm9wYWNpdHkgfSB9KTticmVhaztjYXNlICdkb3QnOmNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgdmFyIG1hcmsgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ2NpcmNsZScsIHBhcmVudDogZ3JvdXAsIGF0dHI6IHsgY3g6IGNvb3JkWCwgY3k6IGNvb3JkWSwgcjogY29uZi5zaXplIC8gMiwgZmlsbDogY29uZi5jb2xvciwgJ2ZpbGwtb3BhY2l0eSc6IGNvbmYub3BhY2l0eSB9IH0pO2JyZWFrO2Nhc2UgJ2Nyb3NzJzpkZWZhdWx0OlxuICAgICAgICAgIHZhciBtYXJrID0gUkcuU1ZHLmNyZWF0ZSh7IHN2ZzogdGhpcy5zdmcsIHR5cGU6ICdwYXRoJywgcGFyZW50OiBncm91cCwgYXR0cjogeyBkOiAnTSB7MX0gezJ9IEwgezN9IHs0fSBNIHs1fSB7Nn0gTCB7N30gezh9Jy5mb3JtYXQoY29vcmRYIC0gY29uZi5zaXplIC8gMiwgY29vcmRZIC0gY29uZi5zaXplIC8gMiwgY29vcmRYICsgY29uZi5zaXplIC8gMiwgY29vcmRZICsgY29uZi5zaXplIC8gMiwgY29vcmRYIC0gY29uZi5zaXplIC8gMiwgY29vcmRZICsgY29uZi5zaXplIC8gMiwgY29vcmRYICsgY29uZi5zaXplIC8gMiwgY29vcmRZIC0gY29uZi5zaXplIC8gMiksIHN0cm9rZTogY29uZi5jb2xvciwgJ3N0cm9rZS1vcGFjaXR5JzogY29uZi5vcGFjaXR5IH0gfSk7YnJlYWs7fVxuICAgICAgbWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleCk7bWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0YXNldCcsIGRhdGFzZXRJZHgpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLW9wYWNpdHknLCBjb25mLm9wYWNpdHkpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvbG9yJywgY29uZi5jb2xvcik7bWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtY29vcmR4JywgY29vcmRYKTttYXJrLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1jb29yZHknLCBjb29yZFkpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLXNpemUnLCBjb25mLnNpemUpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLXNlcXVlbnRpYWwnLCBzZXEpO21hcmsuc2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnLCBjb25mLnR5cGUpO3JldHVybiB7IHg6IGNvb3JkWCwgeTogY29vcmRZLCBzaXplOiBjb25mLnR5cGUuc3Vic3RyKDAsIDYpID09PSAnaW1hZ2U6JyA/IGltZy53aWR0aCA6IGNvbmYuc2l6ZSwgbWFyazogbWFyaywgdHlwZTogY29uZi50eXBlIH07XG4gICAgfTt0aGlzLmRyYXdCdWJibGUgPSBmdW5jdGlvbiAob3B0LCBjb25mKSB7XG4gICAgICB2YXIgc2l6ZSA9IGNvbmYueiAvIHByb3AuYnViYmxlTWF4VmFsdWUgKiBwcm9wLmJ1YmJsZU1heFJhZGl1czt2YXIgY29sb3IgPSBSRy5TVkcucGFyc2VDb2xvclJhZGlhbCh7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYnViYmxlQ29sb3JzU29saWQgPyBjb25mLmNvbG9yIDogJ0dyYWRpZW50KHdoaXRlOicgKyBjb25mLmNvbG9yICsgJyknLCBjeDogb3B0LmNvb3JkeCArIHNpemUgLyA0LCBjeTogb3B0LmNvb3JkeSAtIHNpemUgLyA0LCBmeDogb3B0LmNvb3JkeCArIHNpemUgLyA0LCBmeTogb3B0LmNvb3JkeSAtIHNpemUgLyA0LCByOiBzaXplICogMS41IH0pO3ZhciBjaXJjbGUgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ2NpcmNsZScsIGF0dHI6IHsgY3g6IG9wdC5jb29yZHgsIGN5OiBvcHQuY29vcmR5LCByOiBzaXplLCBmaWxsOiBjb2xvciwgJ2ZpbGwtb3BhY2l0eSc6IGNvbmYub3BhY2l0eSB9IH0pO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBvcHQuaW5kZXgpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0YXNldCcsIG9wdC5kYXRhc2V0SWR4KTtjaXJjbGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLW9wYWNpdHknLCBjb25mLm9wYWNpdHkpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtY29sb3InLCBjb25mLmNvbG9yKTtjaXJjbGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWNvb3JkeCcsIG9wdC5jb29yZHgpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtY29vcmR5Jywgb3B0LmNvb3JkeSk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnZGF0YS1zaXplJywgc2l6ZSk7Y2lyY2xlLnNldEF0dHJpYnV0ZSgnZGF0YS1zZXF1ZW50aWFsJywgb3B0LnNlcXVlbnRpYWwpO2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScsICdidWJibGUnKTtyZXR1cm4geyB4OiBvcHQuY29vcmR4LCB5OiBvcHQuY29vcmR5LCB6OiBvcHQuY29vcmR6IH07XG4gICAgfTt0aGlzLmRyYXdMaW5lID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgdmFyIGxpbmV3aWR0aCA9IDEsXG4gICAgICAgICAgY29sb3IgPSAnYmxhY2snO2lmIChfdHlwZW9mKHByb3AubGluZUxpbmV3aWR0aCkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9wLmxpbmVMaW5ld2lkdGhbb3B0LmluZGV4XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbGluZXdpZHRoID0gcHJvcC5saW5lTGluZXdpZHRoW29wdC5pbmRleF07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wLmxpbmVMaW5ld2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxpbmV3aWR0aCA9IHByb3AubGluZUxpbmV3aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmV3aWR0aCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoX3R5cGVvZihwcm9wLmxpbmVDb2xvcnMpID09PSAnb2JqZWN0JyAmJiBwcm9wLmxpbmVDb2xvcnNbb3B0LmluZGV4XSkge1xuICAgICAgICBjb2xvciA9IHByb3AubGluZUNvbG9yc1tvcHQuaW5kZXhdO1xuICAgICAgfSBlbHNlIGlmIChwcm9wLmNvbG9yc1tvcHQuaW5kZXhdID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb2xvciA9IHByb3AuY29sb3JzW29wdC5pbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvciA9ICdibGFjayc7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgcGF0aCA9ICcnOyBpIDwgdGhpcy5jb29yZHNbb3B0LmluZGV4XS5sZW5ndGg7ICsraSkge1xuICAgICAgICBwYXRoICs9ICd7MX0gezJ9IHszfSAnLmZvcm1hdChpID09PSAwID8gJ00nIDogJ0wnLCB0aGlzLmNvb3Jkc1tvcHQuaW5kZXhdW2ldWzBdLCB0aGlzLmNvb3Jkc1tvcHQuaW5kZXhdW2ldWzFdKTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncGF0aCcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IGQ6IHBhdGgsIGZpbGw6ICd0cmFuc3BhcmVudCcsIHN0cm9rZTogY29sb3IsICdzdHJva2Utd2lkdGgnOiBsaW5ld2lkdGgsICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnIH0gfSk7XG4gICAgfTt0aGlzLmdldFhDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHg7aWYgKHZhbHVlID4gcHJvcC54YXhpc01heCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IHByb3AueGF4aXNNaW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB4ID0gKHZhbHVlIC0gcHJvcC54YXhpc01pbikgLyAocHJvcC54YXhpc01heCAtIHByb3AueGF4aXNNaW4pO3ggKj0gdGhpcy53aWR0aCAtIHByb3AuZ3V0dGVyTGVmdCAtIHByb3AuZ3V0dGVyUmlnaHQ7eCA9IHByb3AuZ3V0dGVyTGVmdCArIHg7cmV0dXJuIHg7XG4gICAgfTt0aGlzLmdldFlDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXM7aWYgKHZhbHVlID4gdGhpcy5zY2FsZS5tYXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgeSxcbiAgICAgICAgICB4YXhpc3BvcyA9IHByb3AueGF4aXNwb3M7aWYgKHZhbHVlIDwgdGhpcy5zY2FsZS5taW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB5ID0gKHZhbHVlIC0gdGhpcy5zY2FsZS5taW4pIC8gKHRoaXMuc2NhbGUubWF4IC0gdGhpcy5zY2FsZS5taW4pO3kgKj0gdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tO3kgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tIC0geTtyZXR1cm4geTtcbiAgICB9O3RoaXMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgcHJvcC5oaWdobGlnaHRGaWxsKTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgcmVjdCk7XG4gICAgfTt0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQ29sb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyA9IHsgY29sb3JzOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmNvbG9ycyksIGJhY2tncm91bmRHcmlkQ29sb3I6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZEdyaWRDb2xvciksIGhpZ2hsaWdodEZpbGw6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuaGlnaGxpZ2h0RmlsbCksIGJhY2tncm91bmRDb2xvcjogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5iYWNrZ3JvdW5kQ29sb3IpIH07XG4gICAgICB9XG4gICAgICB2YXIgY29sb3JzID0gcHJvcC5jb2xvcnM7aWYgKGNvbG9ycyAmJiAhcHJvcC5idWJibGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb2xvcnNbaV0gPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IGNvbG9yc1tpXSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IgfSk7cHJvcC5oaWdobGlnaHRGaWxsID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGwgfSk7cHJvcC5iYWNrZ3JvdW5kQ29sb3IgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYmFja2dyb3VuZENvbG9yIH0pO1xuICAgIH07dGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmV4ZWMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgZnVuYyh0aGlzKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIGhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKTtSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtyZXR1cm4gdGhpcztcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuc2NhdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///217\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// version: 2017-05-08\n/**\n* o--------------------------------------------------------------------------------o\n* | This file is part of the RGraph package - you can learn more at:               |\n* |                                                                                |\n* |                          http://www.rgraph.net                                 |\n* |                                                                                |\n* | RGraph is licensed under the Open Source MIT license. That means that it's     |\n* | totally free to use!                                                           |\n* o--------------------------------------------------------------------------------o\n*/\n\nRGraph = window.RGraph || { isRGraph: true };\nRGraph.SVG = RGraph.SVG || {};\n\n// Module pattern\n(function (win, doc, undefined) {\n    var RG = RGraph,\n        ua = navigator.userAgent,\n        ma = Math,\n        win = window,\n        doc = document;\n\n    RG.SVG.SemiCircularProgress = function (conf) {\n        //\n        // A setter that the constructor uses (at the end)\n        // to set all of the properties\n        //\n        // @param string name  The name of the property to set\n        // @param string value The value to set the property to\n        //\n        this.set = function (name, value) {\n            if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n\n                        var ret = RG.SVG.commonSetter({\n                            object: this,\n                            name: i,\n                            value: arguments[0][i]\n                        });\n\n                        name = ret.name;\n                        value = ret.value;\n\n                        this.set(name, value);\n                    }\n                }\n            } else {\n\n                var ret = RG.SVG.commonSetter({\n                    object: this,\n                    name: name,\n                    value: value\n                });\n\n                name = ret.name;\n                value = ret.value;\n\n                this.properties[name] = value;\n            }\n\n            return this;\n        };\n\n        this.min = RG.SVG.stringsToNumbers(conf.min);\n        this.max = RG.SVG.stringsToNumbers(conf.max);\n        this.value = RG.SVG.stringsToNumbers(conf.value);\n        this.id = conf.id;\n        this.uid = RG.SVG.createUID();\n        this.container = document.getElementById(this.id);\n        this.svg = RG.SVG.createSVG({ container: this.container });\n        this.isRGraph = true;\n        this.width = Number(this.svg.getAttribute('width'));\n        this.height = Number(this.svg.getAttribute('height'));\n        this.data = conf.data;\n        this.type = 'semicircularprogress';\n        this.angles = [];\n        this.colorsParsed = false;\n        this.originalColors = {};\n        this.gradientCounter = 1;\n        this.nodes = [];\n        this.shadowNodes = [];\n\n        // Add this object to the ObjectRegistry\n        RG.SVG.OR.add(this);\n\n        // Set the DIV container to be inline-block\n        this.container.style.display = 'inline-block';\n\n        this.properties = {\n            centerx: null,\n            centery: null,\n            radius: null,\n\n            width: 60,\n\n            gutterLeft: 35,\n            gutterRight: 35,\n            gutterTop: 35,\n            gutterBottom: 35,\n\n            backgroundStrokeLinewidth: 0.25,\n            backgroundStroke: 'gray',\n            backgroundFill: 'Gradient(white:#aaa)',\n            backgroundFillOpacity: 0.25,\n\n            colors: ['#0c0'],\n            strokestyle: '#666',\n\n            textColor: 'gray',\n            textFont: 'sans-serif',\n            textSize: 10,\n            textBold: false,\n            textItalic: false,\n            unitsPre: '',\n            unitsPost: '',\n            scalePoint: '.',\n            scaleThousand: ',',\n            scaleDecimals: 0,\n            scaleFormatter: null,\n\n            labelsMin: true,\n            labelsMinSpecific: null,\n            labelsMinPoint: null,\n            labelsMinThousand: null,\n            labelsMinFormatter: null,\n            labelsMinFont: null,\n            labelsMinSize: null,\n            labelsMinBold: null,\n            labelsMinItalic: null,\n            labelsMinColor: null,\n            labelsMinDecimals: null,\n            labelsMinUnitsPre: null,\n            labelsMinUnitsPost: null,\n\n            labelsMax: true,\n            labelsMaxSpecific: null,\n            labelsMaxPoint: null,\n            labelsMaxThousand: null,\n            labelsMaxFormatter: null,\n            labelsMaxFont: null,\n            labelsMaxSize: null,\n            labelsMaxBold: null,\n            labelsMaxItalic: null,\n            labelsMaxColor: null,\n            labelsMaxDecimals: null,\n            labelsMaxUnitsPre: null,\n            labelsMaxUnitsPost: null,\n\n            labelsCenter: true,\n            labelsCenterSpecific: null,\n            labelsCenterPoint: null,\n            labelsCenterThousand: null,\n            labelsCenterFormatter: null,\n            labelsCenterFont: null,\n            labelsCenterSize: 40,\n            labelsCenterBold: true,\n            labelsCenterItalic: null,\n            labelsCenterColor: '#666',\n            labelsCenterDecimals: null,\n            labelsCenterUnitsPre: null,\n            labelsCenterUnitsPost: null,\n\n            linewidth: 0,\n\n            tooltips: null,\n            tooltipsOverride: null,\n            tooltipsEffect: 'fade',\n            tooltipsCssClass: 'RGraph_tooltip',\n            tooltipsEvent: 'click',\n\n            highlightStroke: 'rgba(0,0,0,0)',\n            highlightFill: 'rgba(255,255,255,0.7)',\n            highlightLinewidth: 1,\n\n            title: '',\n            titleSize: 16,\n            titleX: null,\n            titleY: null,\n            titleHalign: 'center',\n            titleValign: null,\n            titleColor: 'black',\n            titleFont: null,\n            titleBold: false,\n            titleItalic: false,\n\n            titleSubtitle: '',\n            titleSubtitleSize: 10,\n            titleSubtitleX: null,\n            titleSubtitleY: null,\n            titleSubtitleHalign: 'center',\n            titleSubtitleValign: null,\n            titleSubtitleColor: '#aaa',\n            titleSubtitleFont: null,\n            titleSubtitleBold: false,\n            titleSubtitleItalic: false,\n\n            attribution: true,\n            attributionX: null,\n            attributionY: null,\n            attributionHref: null, // Default is set in RGraph.svg.common.core.js\n            attributionHalign: 'right',\n            attributionValign: 'bottom',\n            attributionSize: 7,\n            attributionColor: 'gray',\n            attributionFont: 'sans-serif',\n            attributionItalic: false,\n            attributionBold: false\n\n            //shadow: false,\n            //shadowOffsetx: 2,\n            //shadowOffsety: 2,\n            //shadowBlur: 2,\n            //shadowOpacity: 0.25\n        };\n\n        /**\n        * \"Decorate\" the object with the generic effects if the effects library has been included\n        */\n        if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n            RG.SVG.FX.decorate(this);\n        }\n\n        var prop = this.properties;\n\n        //\n        // The draw method draws the Bar chart\n        //\n        this.draw = function () {\n            // Fire the beforedraw event\n            RG.SVG.fireCustomEvent(this, 'onbeforedraw');\n\n            // Create the defs tag if necessary\n            RG.SVG.createDefs(this);\n\n            // Add these\n            this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;\n            this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;\n\n            // Work out the center point\n            this.centerx = this.graphWidth / 2 + prop.gutterLeft;\n            this.centery = this.height - prop.gutterBottom;\n            this.radius = ma.min(this.graphWidth / 2, this.graphHeight);\n\n            // Allow the user to override the calculated centerx/y/radius\n            this.centerx = typeof prop.centerx === 'number' ? prop.centerx : this.centerx;\n            this.centery = typeof prop.centery === 'number' ? prop.centery : this.centery;\n            this.radius = typeof prop.radius === 'number' ? prop.radius : this.radius;\n\n            //\n            // Allow the centerx/centery/radius to be a plus/minus\n            //\n            if (typeof prop.radius === 'string' && prop.radius.match(/^\\+|-\\d+$/)) this.radius += parseFloat(prop.radius);\n            if (typeof prop.centerx === 'string' && prop.centerx.match(/^\\+|-\\d+$/)) this.centery += parseFloat(prop.centerx);\n            if (typeof prop.centery === 'string' && prop.centery.match(/^\\+|-\\d+$/)) this.centerx += parseFloat(prop.centery);\n\n            // Set the width of the meter\n            this.progressWidth = prop.width || this.radius / 3;\n\n            // Parse the colors for gradients\n            RG.SVG.resetColorsToOriginalValues({ object: this });\n            this.parseColors();\n\n            // Draw the segments\n            this.path = this.drawMeter();\n\n            // Draw the title and subtitle\n            RG.SVG.drawTitle(this);\n\n            // Draw the labels\n            this.drawLabels();\n\n            // Add the attribution link. If you're adding this elsewhere on your page/site\n            // and you don't want it displayed then there are options available to not\n            // show it.\n            RG.SVG.attribution(this);\n\n            // Add the tooltip event listener\n            if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[0]) {\n\n                var obj = this;\n\n                //\n                // Add tooltip event listeners\n                //\n                this.path.addEventListener(prop.tooltipsEvent, function (e) {\n                    obj.removeHighlight();\n\n                    // Show the tooltip\n                    RG.SVG.tooltip({\n                        object: obj,\n                        index: 0,\n                        group: null,\n                        sequentialIndex: 0,\n                        text: prop.tooltips[0],\n                        event: e\n                    });\n\n                    // Highlight the rect that has been clicked on\n                    obj.highlight(e.target);\n                }, false);\n\n                this.path.addEventListener('mousemove', function (e) {\n                    e.target.style.cursor = 'pointer';\n                }, false);\n            }\n\n            // Add the event listener that clears the highlight if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n\n            // Fire the draw event\n            RG.SVG.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n        //\n        // Draws the meter\n        //\n        this.drawMeter = function () {\n            //\n            // Draw the background to the meter\n            //\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: RG.SVG.TRIG.HALFPI,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                start: RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L \" + (this.centerx + this.radius - this.progressWidth) + \" \" + this.centery + path2 + \" L \" + (this.centerx - this.radius) + \" \" + this.centery,\n                    fill: prop.backgroundFill || prop.colors[0],\n                    stroke: prop.backgroundStroke,\n                    'stroke-width': prop.backgroundStrokeLinewidth,\n                    'fill-opacity': prop.backgroundFillOpacity\n                }\n            });\n\n            //\n            // This draws the bar that indicates the value\n            //\n            var angle = (this.value - this.min) / (this.max - this.min) * RG.SVG.TRIG.PI; // Because the Meter is always a semi-circle\n\n            // Take off half a pi because our origin is the noth axis\n            angle -= RG.SVG.TRIG.HALFPI;\n\n            // Now get the path of the inner indicator bar\n            var path = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius,\n                start: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                end: angle,\n                anticlockwise: false\n            });\n\n            var path2 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: angle,\n                anticlockwise: false,\n                array: true\n            });\n\n            var path3 = RG.SVG.TRIG.getArcPath({\n                cx: this.centerx,\n                cy: this.centery,\n                r: this.radius - this.progressWidth,\n                start: angle,\n                end: RG.SVG.TRIG.PI + RG.SVG.TRIG.HALFPI,\n                anticlockwise: true,\n                moveto: false\n            });\n\n            // Now draw the path\n            var path = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: path + \" L{1} {2} \".format(path2[1], path2[2]) + path3 + ' z',\n                    fill: prop.colors[0],\n                    stroke: 'black',\n                    'stroke-width': prop.linewidth\n                }\n            });\n\n            return path;\n        };\n\n        //\n        // Draw the labels\n        //\n        this.drawLabels = function () {\n            // Draw the min label\n            if (prop.labelsMin) {\n\n                var min = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.min.toFixed(typeof prop.labelsMinDecimals === 'number' ? prop.labelsMinDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMinUnitsPre === 'string' ? prop.labelsMinUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMinUnitsPost === 'string' ? prop.labelsMinUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMinPoint === 'string' ? prop.labelsMinPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMinThousand === 'string' ? prop.labelsMinThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMinFormatter === 'function' ? prop.labelsMinFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMinSpecific === 'string' ? prop.labelsMinSpecific : min,\n                    x: this.centerx - this.radius + this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMinFont || prop.textFont,\n                    size: prop.labelsMinSize || prop.textSize,\n                    bold: typeof prop.labelsMinBold === 'boolean' ? prop.labelsMinBold : prop.textBold,\n                    italic: typeof prop.labelsMinItalic === 'boolean' ? prop.labelsMinItalic : prop.textItalic,\n                    color: prop.labelsMinColor || prop.textColor\n                });\n            }\n\n            // Draw the max label\n            if (prop.labelsMax) {\n\n                var max = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.max.toFixed(typeof prop.labelsMaxDecimals === 'number' ? prop.labelsMaxDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsMaxUnitsPre === 'string' ? prop.labelsMaxUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsMaxUnitsPost === 'string' ? prop.labelsMaxUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsMaxPoint === 'string' ? prop.labelsMaxPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsMaxThousand === 'string' ? prop.labelsMaxThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsMaxFormatter === 'function' ? prop.labelsMaxFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsMaxSpecific === 'string' ? prop.labelsMaxSpecific : max,\n                    x: this.centerx + this.radius - this.progressWidth / 2,\n                    y: this.height - prop.gutterBottom + 5,\n                    valign: 'top',\n                    halign: 'center',\n                    font: prop.labelsMaxFont || prop.textFont,\n                    size: prop.labelsMaxSize || prop.textSize,\n                    bold: typeof prop.labelsMaxBold === 'boolean' ? prop.labelsMaxBold : prop.textBold,\n                    italic: typeof prop.labelsMaxItalic === 'boolean' ? prop.labelsMaxItalic : prop.textItalic,\n                    color: prop.labelsMaxColor || prop.textColor\n                });\n            }\n\n            // Draw the center label\n            if (prop.labelsCenter) {\n\n                var center = RG.SVG.numberFormat({\n                    object: this,\n                    num: this.value.toFixed(typeof prop.labelsCenterDecimals === 'number' ? prop.labelsCenterDecimals : prop.scaleDecimals),\n                    prepend: typeof prop.labelsCenterUnitsPre === 'string' ? prop.labelsCenterUnitsPre : prop.unitsPre,\n                    append: typeof prop.labelsCenterUnitsPost === 'string' ? prop.labelsCenterUnitsPost : prop.unitsPost,\n                    point: typeof prop.labelsCenterPoint === 'string' ? prop.labelsCenterPoint : prop.scalePoint,\n                    thousand: typeof prop.labelsCenterThousand === 'string' ? prop.labelsCenterThousand : prop.scaleThousand,\n                    formatter: typeof prop.labelsCenterFormatter === 'function' ? prop.labelsCenterFormatter : prop.scaleFormatter\n                });\n\n                RG.SVG.text({\n                    object: this,\n                    parent: this.svg.all,\n                    text: typeof prop.labelsCenterSpecific === 'string' ? prop.labelsCenterSpecific : center,\n                    x: this.centerx,\n                    y: this.centery,\n                    valign: 'bottom',\n                    halign: 'center',\n                    font: prop.labelsCenterFont || prop.textFont,\n                    size: prop.labelsCenterSize || prop.textSize,\n                    bold: typeof prop.labelsCenterBold === 'boolean' ? prop.labelsCenterBold : prop.textBold,\n                    italic: typeof prop.labelsCenterItalic === 'boolean' ? prop.labelsCenterItalic : prop.textItalic,\n                    color: prop.labelsCenterColor || prop.textColor\n                });\n            }\n        };\n\n        /**\n        * This function can be used to highlight a segment on the chart\n        *\n        * @param object segment The segment to highlight\n        */\n        this.highlight = function (segment) {\n            // Remove any highlight that's already been\n            // installed\n            this.removeHighlight();\n\n            var highlight = RG.SVG.create({\n                svg: this.svg,\n                type: 'path',\n                parent: this.svg.all,\n                attr: {\n                    d: this.path.getAttribute('d'),\n                    fill: prop.highlightFill,\n                    stroke: prop.highlightStroke,\n                    'stroke-width': prop.highlightLinewidth\n                }\n            });\n\n            // Store the highlight node in the registry\n            RG.SVG.REG.set('highlight', highlight);\n\n            // Add the event listener that clears the highlight path if\n            // there is any. Must be MOUSEDOWN (ie before the click event)\n            var obj = this;\n            doc.body.addEventListener('mousedown', function (e) {\n                obj.removeHighlight();\n            }, false);\n        };\n\n        /**\n        * This function can be used to remove the highlight that is added\n        * by tooltips\n        */\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n\n            if (highlight) {\n                highlight.parentNode.removeChild(highlight);\n                highlight = null;\n            }\n        };\n\n        /**\n        * This allows for easy specification of gradients\n        */\n        this.parseColors = function () {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (!Object.keys(this.originalColors).length) {\n                this.originalColors = {\n                    colors: RG.SVG.arrayClone(prop.colors),\n                    highlightFill: RG.SVG.arrayClone(prop.highlightFill),\n                    backgroundColor: RG.SVG.arrayClone(prop.backgroundColor)\n                };\n            }\n\n            // colors\n            var colors = prop.colors;\n\n            if (colors) {\n                for (var i = 0; i < colors.length; ++i) {\n                    colors[i] = RG.SVG.parseColorLinear({\n                        object: this,\n                        color: colors[i],\n                        start: this.centerx - this.radius,\n                        end: this.centerx + this.radius,\n                        direction: 'horizontal'\n                    });\n                }\n            }\n\n            // Highlight fill\n            prop.highlightFill = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.highlightFill,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n\n            // Background color\n\n            // Background color\n            prop.backgroundColor = RG.SVG.parseColorLinear({\n                object: this,\n                color: prop.backgroundColor,\n                start: prop.gutterLeft,\n                end: this.width - prop.gutterRight,\n                direction: 'horizontal'\n            });\n        };\n\n        //\n        // The Bar chart grow effect\n        //\n        this.grow = function () {\n            var opt = arguments[0] || {},\n                frames = opt.frames || 30,\n                frame = 0,\n                obj = this,\n                value = opt.value;\n\n            //\n            // Copy the data\n            //\n            value = this.value;\n\n            this.draw();\n\n            var iterate = function iterate() {\n                var multiplier = frame / frames * RG.SVG.FX.getEasingMultiplier(frames, frame) * RG.SVG.FX.getEasingMultiplier(frames, frame);\n\n                obj.value = value * multiplier;\n\n                RG.SVG.redraw();\n\n                if (frame++ < frames) {\n                    RG.SVG.FX.update(iterate);\n                } else if (opt.callback) {\n                    obj.value = value;\n                    RG.SVG.redraw();\n                    opt.callback(obj);\n                }\n            };\n\n            iterate();\n\n            return this;\n        };\n\n        /**\n        * Using a function to add events makes it easier to facilitate method\n        * chaining\n        *\n        * @param string   type The type of even to add\n        * @param function func\n        */\n        this.on = function (type, func) {\n            if (type.substr(0, 2) !== 'on') {\n                type = 'on' + type;\n            }\n\n            RG.SVG.addCustomEventListener(this, type, func);\n\n            return this;\n        };\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        //\n        // @param function func The function to execute\n        //\n        this.exec = function (func) {\n            func(this);\n\n            return this;\n        };\n\n        //\n        // Remove highlight from the chart (tooltips)\n        //\n        this.removeHighlight = function () {\n            var highlight = RG.SVG.REG.get('highlight');\n            if (highlight && highlight.parentNode) {\n                highlight.parentNode.removeChild(highlight);\n            }\n\n            RG.SVG.REG.set('highlight', null);\n        };\n\n        //\n        // Set the options that the user has provided\n        //\n        for (i in conf.options) {\n            if (typeof i === 'string') {\n                this.set(i, conf.options[i]);\n            }\n        }\n    };\n\n    return this;\n\n    // End module pattern\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuc2VtaWNpcmN1bGFycHJvZ3Jlc3MuanM/OGI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8vIHZlcnNpb246IDIwMTctMDUtMDhcbi8qKlxuKiBvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vXG4qIHwgVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIFJHcmFwaCBwYWNrYWdlIC0geW91IGNhbiBsZWFybiBtb3JlIGF0OiAgICAgICAgICAgICAgIHxcbiogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnJncmFwaC5uZXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiogfCBSR3JhcGggaXMgbGljZW5zZWQgdW5kZXIgdGhlIE9wZW4gU291cmNlIE1JVCBsaWNlbnNlLiBUaGF0IG1lYW5zIHRoYXQgaXQncyAgICAgfFxuKiB8IHRvdGFsbHkgZnJlZSB0byB1c2UhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4qIG8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLW9cbiovXG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1xuUkdyYXBoLlNWRyA9IFJHcmFwaC5TVkcgfHwge307XG5cbi8vIE1vZHVsZSBwYXR0ZXJuXG4oZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgbWEgPSBNYXRoLFxuICAgICAgICB3aW4gPSB3aW5kb3csXG4gICAgICAgIGRvYyA9IGRvY3VtZW50O1xuXG4gICAgUkcuU1ZHLlNlbWlDaXJjdWxhclByb2dyZXNzID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSBzZXR0ZXIgdGhhdCB0aGUgY29uc3RydWN0b3IgdXNlcyAoYXQgdGhlIGVuZClcbiAgICAgICAgLy8gdG8gc2V0IGFsbCBvZiB0aGUgcHJvcGVydGllc1xuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gc3RyaW5nIG5hbWUgIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgLy8gQHBhcmFtIHN0cmluZyB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0b1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJndW1lbnRzWzBdW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJldC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gUkcuU1ZHLmNvbW1vblNldHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gcmV0Lm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5taW4gPSBSRy5TVkcuc3RyaW5nc1RvTnVtYmVycyhjb25mLm1pbik7XG4gICAgICAgIHRoaXMubWF4ID0gUkcuU1ZHLnN0cmluZ3NUb051bWJlcnMoY29uZi5tYXgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gUkcuU1ZHLnN0cmluZ3NUb051bWJlcnMoY29uZi52YWx1ZSk7XG4gICAgICAgIHRoaXMuaWQgPSBjb25mLmlkO1xuICAgICAgICB0aGlzLnVpZCA9IFJHLlNWRy5jcmVhdGVVSUQoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5zdmcgPSBSRy5TVkcuY3JlYXRlU1ZHKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTtcbiAgICAgICAgdGhpcy5pc1JHcmFwaCA9IHRydWU7XG4gICAgICAgIHRoaXMud2lkdGggPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNvbmYuZGF0YTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NlbWljaXJjdWxhcnByb2dyZXNzJztcbiAgICAgICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmdyYWRpZW50Q291bnRlciA9IDE7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaGFkb3dOb2RlcyA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCB0aGlzIG9iamVjdCB0byB0aGUgT2JqZWN0UmVnaXN0cnlcbiAgICAgICAgUkcuU1ZHLk9SLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgdGhlIERJViBjb250YWluZXIgdG8gYmUgaW5saW5lLWJsb2NrXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBjZW50ZXJ4OiBudWxsLFxuICAgICAgICAgICAgY2VudGVyeTogbnVsbCxcbiAgICAgICAgICAgIHJhZGl1czogbnVsbCxcblxuICAgICAgICAgICAgd2lkdGg6IDYwLFxuXG4gICAgICAgICAgICBndXR0ZXJMZWZ0OiAzNSxcbiAgICAgICAgICAgIGd1dHRlclJpZ2h0OiAzNSxcbiAgICAgICAgICAgIGd1dHRlclRvcDogMzUsXG4gICAgICAgICAgICBndXR0ZXJCb3R0b206IDM1LFxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlTGluZXdpZHRoOiAwLjI1LFxuICAgICAgICAgICAgYmFja2dyb3VuZFN0cm9rZTogJ2dyYXknLFxuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGw6ICdHcmFkaWVudCh3aGl0ZTojYWFhKScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbE9wYWNpdHk6IDAuMjUsXG5cbiAgICAgICAgICAgIGNvbG9yczogWycjMGMwJ10sXG4gICAgICAgICAgICBzdHJva2VzdHlsZTogJyM2NjYnLFxuXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICdncmF5JyxcbiAgICAgICAgICAgIHRleHRGb250OiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICB0ZXh0U2l6ZTogMTAsXG4gICAgICAgICAgICB0ZXh0Qm9sZDogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0SXRhbGljOiBmYWxzZSxcbiAgICAgICAgICAgIHVuaXRzUHJlOiAnJyxcbiAgICAgICAgICAgIHVuaXRzUG9zdDogJycsXG4gICAgICAgICAgICBzY2FsZVBvaW50OiAnLicsXG4gICAgICAgICAgICBzY2FsZVRob3VzYW5kOiAnLCcsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWxzOiAwLFxuICAgICAgICAgICAgc2NhbGVGb3JtYXR0ZXI6IG51bGwsXG5cbiAgICAgICAgICAgIGxhYmVsc01pbjogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsc01pblNwZWNpZmljOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluUG9pbnQ6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNaW5UaG91c2FuZDogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01pbkZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01pbkZvbnQ6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNaW5TaXplOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluQm9sZDogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01pbkl0YWxpYzogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01pbkNvbG9yOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWluRGVjaW1hbHM6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNaW5Vbml0c1ByZTogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01pblVuaXRzUG9zdDogbnVsbCxcblxuICAgICAgICAgICAgbGFiZWxzTWF4OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxzTWF4U3BlY2lmaWM6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhQb2ludDogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01heFRob3VzYW5kOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWF4Rm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWF4Rm9udDogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01heFNpemU6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhCb2xkOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWF4SXRhbGljOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWF4Q29sb3I6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNNYXhEZWNpbWFsczogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc01heFVuaXRzUHJlOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzTWF4VW5pdHNQb3N0OiBudWxsLFxuXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXI6IHRydWUsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJTcGVjaWZpYzogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlclBvaW50OiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ2VudGVyVGhvdXNhbmQ6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJGb250OiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ2VudGVyU2l6ZTogNDAsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJCb2xkOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxzQ2VudGVySXRhbGljOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ2VudGVyQ29sb3I6ICcjNjY2JyxcbiAgICAgICAgICAgIGxhYmVsc0NlbnRlckRlY2ltYWxzOiBudWxsLFxuICAgICAgICAgICAgbGFiZWxzQ2VudGVyVW5pdHNQcmU6IG51bGwsXG4gICAgICAgICAgICBsYWJlbHNDZW50ZXJVbml0c1Bvc3Q6IG51bGwsXG5cbiAgICAgICAgICAgIGxpbmV3aWR0aDogMCxcblxuICAgICAgICAgICAgdG9vbHRpcHM6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwc092ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcHNFZmZlY3Q6ICdmYWRlJyxcbiAgICAgICAgICAgIHRvb2x0aXBzQ3NzQ2xhc3M6ICdSR3JhcGhfdG9vbHRpcCcsXG4gICAgICAgICAgICB0b29sdGlwc0V2ZW50OiAnY2xpY2snLFxuXG4gICAgICAgICAgICBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEZpbGw6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLFxuICAgICAgICAgICAgaGlnaGxpZ2h0TGluZXdpZHRoOiAxLFxuXG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICB0aXRsZVNpemU6IDE2LFxuICAgICAgICAgICAgdGl0bGVYOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVZOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVIYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgdGl0bGVWYWxpZ246IG51bGwsXG4gICAgICAgICAgICB0aXRsZUNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgdGl0bGVGb250OiBudWxsLFxuICAgICAgICAgICAgdGl0bGVCb2xkOiBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlSXRhbGljOiBmYWxzZSxcblxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZTogJycsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlWDogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVZOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlVmFsaWduOiBudWxsLFxuICAgICAgICAgICAgdGl0bGVTdWJ0aXRsZUNvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVCb2xkOiBmYWxzZSxcbiAgICAgICAgICAgIHRpdGxlU3VidGl0bGVJdGFsaWM6IGZhbHNlLFxuXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uWDogbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uWTogbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uSHJlZjogbnVsbCwgLy8gRGVmYXVsdCBpcyBzZXQgaW4gUkdyYXBoLnN2Zy5jb21tb24uY29yZS5qc1xuICAgICAgICAgICAgYXR0cmlidXRpb25IYWxpZ246ICdyaWdodCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblZhbGlnbjogJ2JvdHRvbScsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvblNpemU6IDcsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkNvbG9yOiAnZ3JheScsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbkZvbnQ6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uSXRhbGljOiBmYWxzZSxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uQm9sZDogZmFsc2VcblxuICAgICAgICAgICAgLy9zaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgLy9zaGFkb3dPZmZzZXR4OiAyLFxuICAgICAgICAgICAgLy9zaGFkb3dPZmZzZXR5OiAyLFxuICAgICAgICAgICAgLy9zaGFkb3dCbHVyOiAyLFxuICAgICAgICAgICAgLy9zaGFkb3dPcGFjaXR5OiAwLjI1XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogXCJEZWNvcmF0ZVwiIHRoZSBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJpYyBlZmZlY3RzIGlmIHRoZSBlZmZlY3RzIGxpYnJhcnkgaGFzIGJlZW4gaW5jbHVkZWRcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKFJHLlNWRy5GWCAmJiB0eXBlb2YgUkcuU1ZHLkZYLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcztcblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZHJhdyBtZXRob2QgZHJhd3MgdGhlIEJhciBjaGFydFxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBGaXJlIHRoZSBiZWZvcmVkcmF3IGV2ZW50XG4gICAgICAgICAgICBSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBkZWZzIHRhZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIFJHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlc2VcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ncmFwaEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJUb3AgLSBwcm9wLmd1dHRlckJvdHRvbTtcblxuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGNlbnRlciBwb2ludFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJ4ID0gdGhpcy5ncmFwaFdpZHRoIC8gMiArIHByb3AuZ3V0dGVyTGVmdDtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyeSA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b207XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG1hLm1pbih0aGlzLmdyYXBoV2lkdGggLyAyLCB0aGlzLmdyYXBoSGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGNhbGN1bGF0ZWQgY2VudGVyeC95L3JhZGl1c1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJ4ID0gdHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ251bWJlcicgPyBwcm9wLmNlbnRlcnggOiB0aGlzLmNlbnRlcng7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcnkgPSB0eXBlb2YgcHJvcC5jZW50ZXJ5ID09PSAnbnVtYmVyJyA/IHByb3AuY2VudGVyeSA6IHRoaXMuY2VudGVyeTtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gdHlwZW9mIHByb3AucmFkaXVzID09PSAnbnVtYmVyJyA/IHByb3AucmFkaXVzIDogdGhpcy5yYWRpdXM7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgY2VudGVyeC9jZW50ZXJ5L3JhZGl1cyB0byBiZSBhIHBsdXMvbWludXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AucmFkaXVzID09PSAnc3RyaW5nJyAmJiBwcm9wLnJhZGl1cy5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5yYWRpdXMgKz0gcGFyc2VGbG9hdChwcm9wLnJhZGl1cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AuY2VudGVyeCA9PT0gJ3N0cmluZycgJiYgcHJvcC5jZW50ZXJ4Lm1hdGNoKC9eXFwrfC1cXGQrJC8pKSB0aGlzLmNlbnRlcnkgKz0gcGFyc2VGbG9hdChwcm9wLmNlbnRlcngpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wLmNlbnRlcnkgPT09ICdzdHJpbmcnICYmIHByb3AuY2VudGVyeS5tYXRjaCgvXlxcK3wtXFxkKyQvKSkgdGhpcy5jZW50ZXJ4ICs9IHBhcnNlRmxvYXQocHJvcC5jZW50ZXJ5KTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSB3aWR0aCBvZiB0aGUgbWV0ZXJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NXaWR0aCA9IHByb3Aud2lkdGggfHwgdGhpcy5yYWRpdXMgLyAzO1xuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgY29sb3JzIGZvciBncmFkaWVudHNcbiAgICAgICAgICAgIFJHLlNWRy5yZXNldENvbG9yc1RvT3JpZ2luYWxWYWx1ZXMoeyBvYmplY3Q6IHRoaXMgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHNlZ21lbnRzXG4gICAgICAgICAgICB0aGlzLnBhdGggPSB0aGlzLmRyYXdNZXRlcigpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSB0aXRsZSBhbmQgc3VidGl0bGVcbiAgICAgICAgICAgIFJHLlNWRy5kcmF3VGl0bGUodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGxhYmVsc1xuICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWxzKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRpb24gbGluay4gSWYgeW91J3JlIGFkZGluZyB0aGlzIGVsc2V3aGVyZSBvbiB5b3VyIHBhZ2Uvc2l0ZVxuICAgICAgICAgICAgLy8gYW5kIHlvdSBkb24ndCB3YW50IGl0IGRpc3BsYXllZCB0aGVuIHRoZXJlIGFyZSBvcHRpb25zIGF2YWlsYWJsZSB0byBub3RcbiAgICAgICAgICAgIC8vIHNob3cgaXQuXG4gICAgICAgICAgICBSRy5TVkcuYXR0cmlidXRpb24odGhpcyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdG9vbHRpcCBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgaWYgKCFSRy5TVkcuaXNOdWxsKHByb3AudG9vbHRpcHMpICYmIHByb3AudG9vbHRpcHNbMF0pIHtcblxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG9vbHRpcCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5hZGRFdmVudExpc3RlbmVyKHByb3AudG9vbHRpcHNFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVudGlhbEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcHJvcC50b29sdGlwc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgcmVjdCB0aGF0IGhhcyBiZWVuIGNsaWNrZWQgb25cbiAgICAgICAgICAgICAgICAgICAgb2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjbGVhcnMgdGhlIGhpZ2hsaWdodCBpZlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYW55LiBNdXN0IGJlIE1PVVNFRE9XTiAoaWUgYmVmb3JlIHRoZSBjbGljayBldmVudClcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzO1xuICAgICAgICAgICAgZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBvYmoucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGRyYXcgZXZlbnRcbiAgICAgICAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3cyB0aGUgbWV0ZXJcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5kcmF3TWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRHJhdyB0aGUgYmFja2dyb3VuZCB0byB0aGUgbWV0ZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgcGF0aCA9IFJHLlNWRy5UUklHLmdldEFyY1BhdGgoe1xuICAgICAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlcngsXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMuY2VudGVyeSxcbiAgICAgICAgICAgICAgICByOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICBzdGFydDogUkcuU1ZHLlRSSUcuUEkgKyBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgZW5kOiBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aDIgPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHtcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMgLSB0aGlzLnByb2dyZXNzV2lkdGgsXG4gICAgICAgICAgICAgICAgZW5kOiBSRy5TVkcuVFJJRy5QSSArIFJHLlNWRy5UUklHLkhBTEZQSSxcbiAgICAgICAgICAgICAgICBzdGFydDogUkcuU1ZHLlRSSUcuSEFMRlBJLFxuICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgbW92ZXRvOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgZDogcGF0aCArIFwiIEwgXCIgKyAodGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgLSB0aGlzLnByb2dyZXNzV2lkdGgpICsgXCIgXCIgKyB0aGlzLmNlbnRlcnkgKyBwYXRoMiArIFwiIEwgXCIgKyAodGhpcy5jZW50ZXJ4IC0gdGhpcy5yYWRpdXMpICsgXCIgXCIgKyB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHByb3AuYmFja2dyb3VuZEZpbGwgfHwgcHJvcC5jb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5iYWNrZ3JvdW5kU3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcC5iYWNrZ3JvdW5kU3Ryb2tlTGluZXdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogcHJvcC5iYWNrZ3JvdW5kRmlsbE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgZHJhd3MgdGhlIGJhciB0aGF0IGluZGljYXRlcyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy52YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIFJHLlNWRy5UUklHLlBJOyAvLyBCZWNhdXNlIHRoZSBNZXRlciBpcyBhbHdheXMgYSBzZW1pLWNpcmNsZVxuXG4gICAgICAgICAgICAvLyBUYWtlIG9mZiBoYWxmIGEgcGkgYmVjYXVzZSBvdXIgb3JpZ2luIGlzIHRoZSBub3RoIGF4aXNcbiAgICAgICAgICAgIGFuZ2xlIC09IFJHLlNWRy5UUklHLkhBTEZQSTtcblxuICAgICAgICAgICAgLy8gTm93IGdldCB0aGUgcGF0aCBvZiB0aGUgaW5uZXIgaW5kaWNhdG9yIGJhclxuICAgICAgICAgICAgdmFyIHBhdGggPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHtcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IFJHLlNWRy5UUklHLlBJICsgUkcuU1ZHLlRSSUcuSEFMRlBJLFxuICAgICAgICAgICAgICAgIGVuZDogYW5nbGUsXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aDIgPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHtcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMgLSB0aGlzLnByb2dyZXNzV2lkdGgsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuZ2xlLFxuICAgICAgICAgICAgICAgIGVuZDogYW5nbGUsXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aDMgPSBSRy5TVkcuVFJJRy5nZXRBcmNQYXRoKHtcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5jZW50ZXJ4LFxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlcnksXG4gICAgICAgICAgICAgICAgcjogdGhpcy5yYWRpdXMgLSB0aGlzLnByb2dyZXNzV2lkdGgsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuZ2xlLFxuICAgICAgICAgICAgICAgIGVuZDogUkcuU1ZHLlRSSUcuUEkgKyBSRy5TVkcuVFJJRy5IQUxGUEksXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb3ZldG86IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm93IGRyYXcgdGhlIHBhdGhcbiAgICAgICAgICAgIHZhciBwYXRoID0gUkcuU1ZHLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3ZnOiB0aGlzLnN2ZyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICBkOiBwYXRoICsgXCIgTHsxfSB7Mn0gXCIuZm9ybWF0KHBhdGgyWzFdLCBwYXRoMlsyXSkgKyBwYXRoMyArICcgeicsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHByb3AuY29sb3JzWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3IHRoZSBsYWJlbHNcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRHJhdyB0aGUgbWluIGxhYmVsXG4gICAgICAgICAgICBpZiAocHJvcC5sYWJlbHNNaW4pIHtcblxuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBSRy5TVkcubnVtYmVyRm9ybWF0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBudW06IHRoaXMubWluLnRvRml4ZWQodHlwZW9mIHByb3AubGFiZWxzTWluRGVjaW1hbHMgPT09ICdudW1iZXInID8gcHJvcC5sYWJlbHNNaW5EZWNpbWFscyA6IHByb3Auc2NhbGVEZWNpbWFscyksXG4gICAgICAgICAgICAgICAgICAgIHByZXBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc01pblVuaXRzUHJlID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzTWluVW5pdHNQcmUgOiBwcm9wLnVuaXRzUHJlLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc01pblVuaXRzUG9zdCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc01pblVuaXRzUG9zdCA6IHByb3AudW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogdHlwZW9mIHByb3AubGFiZWxzTWluUG9pbnQgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNNaW5Qb2ludCA6IHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdGhvdXNhbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc01pblRob3VzYW5kID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzTWluVGhvdXNhbmQgOiBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdHlwZW9mIHByb3AubGFiZWxzTWluRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nID8gcHJvcC5sYWJlbHNNaW5Gb3JtYXR0ZXIgOiBwcm9wLnNjYWxlRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBSRy5TVkcudGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHR5cGVvZiBwcm9wLmxhYmVsc01pblNwZWNpZmljID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzTWluU3BlY2lmaWMgOiBtaW4sXG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyeCAtIHRoaXMucmFkaXVzICsgdGhpcy5wcm9ncmVzc1dpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlckJvdHRvbSArIDUsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IHByb3AubGFiZWxzTWluRm9udCB8fCBwcm9wLnRleHRGb250LFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBwcm9wLmxhYmVsc01pblNpemUgfHwgcHJvcC50ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogdHlwZW9mIHByb3AubGFiZWxzTWluQm9sZCA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNNaW5Cb2xkIDogcHJvcC50ZXh0Qm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljOiB0eXBlb2YgcHJvcC5sYWJlbHNNaW5JdGFsaWMgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzTWluSXRhbGljIDogcHJvcC50ZXh0SXRhbGljLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogcHJvcC5sYWJlbHNNaW5Db2xvciB8fCBwcm9wLnRleHRDb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBtYXggbGFiZWxcbiAgICAgICAgICAgIGlmIChwcm9wLmxhYmVsc01heCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IFJHLlNWRy5udW1iZXJGb3JtYXQoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG51bTogdGhpcy5tYXgudG9GaXhlZCh0eXBlb2YgcHJvcC5sYWJlbHNNYXhEZWNpbWFscyA9PT0gJ251bWJlcicgPyBwcm9wLmxhYmVsc01heERlY2ltYWxzIDogcHJvcC5zY2FsZURlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGVuZDogdHlwZW9mIHByb3AubGFiZWxzTWF4VW5pdHNQcmUgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNNYXhVbml0c1ByZSA6IHByb3AudW5pdHNQcmUsXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZDogdHlwZW9mIHByb3AubGFiZWxzTWF4VW5pdHNQb3N0ID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzTWF4VW5pdHNQb3N0IDogcHJvcC51bml0c1Bvc3QsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB0eXBlb2YgcHJvcC5sYWJlbHNNYXhQb2ludCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc01heFBvaW50IDogcHJvcC5zY2FsZVBvaW50LFxuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogdHlwZW9mIHByb3AubGFiZWxzTWF4VGhvdXNhbmQgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNNYXhUaG91c2FuZCA6IHByb3Auc2NhbGVUaG91c2FuZCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiB0eXBlb2YgcHJvcC5sYWJlbHNNYXhGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicgPyBwcm9wLmxhYmVsc01heEZvcm1hdHRlciA6IHByb3Auc2NhbGVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFJHLlNWRy50ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdHlwZW9mIHByb3AubGFiZWxzTWF4U3BlY2lmaWMgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNNYXhTcGVjaWZpYyA6IG1heCxcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMgLSB0aGlzLnByb2dyZXNzV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyQm90dG9tICsgNSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWduOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogcHJvcC5sYWJlbHNNYXhGb250IHx8IHByb3AudGV4dEZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHByb3AubGFiZWxzTWF4U2l6ZSB8fCBwcm9wLnRleHRTaXplLFxuICAgICAgICAgICAgICAgICAgICBib2xkOiB0eXBlb2YgcHJvcC5sYWJlbHNNYXhCb2xkID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc01heEJvbGQgOiBwcm9wLnRleHRCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWM6IHR5cGVvZiBwcm9wLmxhYmVsc01heEl0YWxpYyA9PT0gJ2Jvb2xlYW4nID8gcHJvcC5sYWJlbHNNYXhJdGFsaWMgOiBwcm9wLnRleHRJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBwcm9wLmxhYmVsc01heENvbG9yIHx8IHByb3AudGV4dENvbG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGNlbnRlciBsYWJlbFxuICAgICAgICAgICAgaWYgKHByb3AubGFiZWxzQ2VudGVyKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbnVtOiB0aGlzLnZhbHVlLnRvRml4ZWQodHlwZW9mIHByb3AubGFiZWxzQ2VudGVyRGVjaW1hbHMgPT09ICdudW1iZXInID8gcHJvcC5sYWJlbHNDZW50ZXJEZWNpbWFscyA6IHByb3Auc2NhbGVEZWNpbWFscyksXG4gICAgICAgICAgICAgICAgICAgIHByZXBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclVuaXRzUHJlID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQ2VudGVyVW5pdHNQcmUgOiBwcm9wLnVuaXRzUHJlLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclVuaXRzUG9zdCA9PT0gJ3N0cmluZycgPyBwcm9wLmxhYmVsc0NlbnRlclVuaXRzUG9zdCA6IHByb3AudW5pdHNQb3N0LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogdHlwZW9mIHByb3AubGFiZWxzQ2VudGVyUG9pbnQgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNDZW50ZXJQb2ludCA6IHByb3Auc2NhbGVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdGhvdXNhbmQ6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclRob3VzYW5kID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQ2VudGVyVGhvdXNhbmQgOiBwcm9wLnNjYWxlVGhvdXNhbmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdHlwZW9mIHByb3AubGFiZWxzQ2VudGVyRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nID8gcHJvcC5sYWJlbHNDZW50ZXJGb3JtYXR0ZXIgOiBwcm9wLnNjYWxlRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBSRy5TVkcudGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLnN2Zy5hbGwsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlclNwZWNpZmljID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQ2VudGVyU3BlY2lmaWMgOiBjZW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyeCxcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5jZW50ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZ246ICdib3R0b20nLFxuICAgICAgICAgICAgICAgICAgICBoYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBwcm9wLmxhYmVsc0NlbnRlckZvbnQgfHwgcHJvcC50ZXh0Rm9udCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogcHJvcC5sYWJlbHNDZW50ZXJTaXplIHx8IHByb3AudGV4dFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IHR5cGVvZiBwcm9wLmxhYmVsc0NlbnRlckJvbGQgPT09ICdib29sZWFuJyA/IHByb3AubGFiZWxzQ2VudGVyQm9sZCA6IHByb3AudGV4dEJvbGQsXG4gICAgICAgICAgICAgICAgICAgIGl0YWxpYzogdHlwZW9mIHByb3AubGFiZWxzQ2VudGVySXRhbGljID09PSAnYm9vbGVhbicgPyBwcm9wLmxhYmVsc0NlbnRlckl0YWxpYyA6IHByb3AudGV4dEl0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHByb3AubGFiZWxzQ2VudGVyQ29sb3IgfHwgcHJvcC50ZXh0Q29sb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGhpZ2hsaWdodCBhIHNlZ21lbnQgb24gdGhlIGNoYXJ0XG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0gb2JqZWN0IHNlZ21lbnQgVGhlIHNlZ21lbnQgdG8gaGlnaGxpZ2h0XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgaGlnaGxpZ2h0IHRoYXQncyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgIC8vIGluc3RhbGxlZFxuICAgICAgICAgICAgdGhpcy5yZW1vdmVIaWdobGlnaHQoKTtcblxuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdmcuYWxsLFxuICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgZDogdGhpcy5wYXRoLmdldEF0dHJpYnV0ZSgnZCcpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wLmhpZ2hsaWdodEZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogcHJvcC5oaWdobGlnaHRTdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgaGlnaGxpZ2h0IG5vZGUgaW4gdGhlIHJlZ2lzdHJ5XG4gICAgICAgICAgICBSRy5TVkcuUkVHLnNldCgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0KTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNsZWFycyB0aGUgaGlnaGxpZ2h0IHBhdGggaWZcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFueS4gTXVzdCBiZSBNT1VTRURPV04gKGllIGJlZm9yZSB0aGUgY2xpY2sgZXZlbnQpXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgICAgICAgIGRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBoaWdobGlnaHQgdGhhdCBpcyBhZGRlZFxuICAgICAgICAqIGJ5IHRvb2x0aXBzXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IFJHLlNWRy5SRUcuZ2V0KCdoaWdobGlnaHQnKTtcblxuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGlzIGFsbG93cyBmb3IgZWFzeSBzcGVjaWZpY2F0aW9uIG9mIGdyYWRpZW50c1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnNlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgY29sb3JzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdG9yZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlc2V0XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxDb2xvcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLFxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRGaWxsOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmhpZ2hsaWdodEZpbGwpLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbG9yc1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IHByb3AuY29sb3JzO1xuXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzW2ldID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNlbnRlcnggLSB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdGhpcy5jZW50ZXJ4ICsgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBmaWxsXG4gICAgICAgICAgICBwcm9wLmhpZ2hsaWdodEZpbGwgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGwsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByb3AuZ3V0dGVyTGVmdCxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlclJpZ2h0LFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBjb2xvclxuXG4gICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICBwcm9wLmJhY2tncm91bmRDb2xvciA9IFJHLlNWRy5wYXJzZUNvbG9yTGluZWFyKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgY29sb3I6IHByb3AuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wLmd1dHRlckxlZnQsXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLndpZHRoIC0gcHJvcC5ndXR0ZXJSaWdodCxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIEJhciBjaGFydCBncm93IGVmZmVjdFxuICAgICAgICAvL1xuICAgICAgICB0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgfHwgMzAsXG4gICAgICAgICAgICAgICAgZnJhbWUgPSAwLFxuICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvcHQudmFsdWU7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBkYXRhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcblxuICAgICAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiBpdGVyYXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZnJhbWUgLyBmcmFtZXMgKiBSRy5TVkcuRlguZ2V0RWFzaW5nTXVsdGlwbGllcihmcmFtZXMsIGZyYW1lKSAqIFJHLlNWRy5GWC5nZXRFYXNpbmdNdWx0aXBsaWVyKGZyYW1lcywgZnJhbWUpO1xuXG4gICAgICAgICAgICAgICAgb2JqLnZhbHVlID0gdmFsdWUgKiBtdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICAgICAgUkcuU1ZHLnJlZHJhdygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lKysgPCBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLkZYLnVwZGF0ZShpdGVyYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBvYmoudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgUkcuU1ZHLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBvcHQuY2FsbGJhY2sob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpdGVyYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFVzaW5nIGEgZnVuY3Rpb24gdG8gYWRkIGV2ZW50cyBtYWtlcyBpdCBlYXNpZXIgdG8gZmFjaWxpdGF0ZSBtZXRob2RcbiAgICAgICAgKiBjaGFpbmluZ1xuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIHN0cmluZyAgIHR5cGUgVGhlIHR5cGUgb2YgZXZlbiB0byBhZGRcbiAgICAgICAgKiBAcGFyYW0gZnVuY3Rpb24gZnVuY1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUkcuU1ZHLmFkZEN1c3RvbUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgZnVuYyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFVzZWQgaW4gY2hhaW5pbmcuIFJ1bnMgYSBmdW5jdGlvbiB0aGVyZSBhbmQgdGhlbiAtIG5vdCB3YWl0aW5nIGZvclxuICAgICAgICAvLyB0aGUgZXZlbnRzIHRvIGZpcmUgKGVnIHRoZSBvbmJlZm9yZWRyYXcgZXZlbnQpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEBwYXJhbSBmdW5jdGlvbiBmdW5jIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuZXhlYyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICBmdW5jKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZW1vdmUgaGlnaGxpZ2h0IGZyb20gdGhlIGNoYXJ0ICh0b29sdGlwcylcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gUkcuU1ZHLlJFRy5nZXQoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodCAmJiBoaWdobGlnaHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZ2hsaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLCBudWxsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBTZXQgdGhlIG9wdGlvbnMgdGhhdCB0aGUgdXNlciBoYXMgcHJvdmlkZWRcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpIGluIGNvbmYub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbmYub3B0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBFbmQgbW9kdWxlIHBhdHRlcm5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcuc2VtaWNpcmN1bGFycHJvZ3Jlc3MuanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///218\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.SVG = RGraph.SVG || {};(function (win, doc, undefined) {\n  var RG = RGraph,\n      ua = navigator.userAgent,\n      ma = Math,\n      win = window,\n      doc = document;RG.SVG.Waterfall = function (conf) {\n    this.set = function (name, value) {\n      if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        for (i in arguments[0]) {\n          if (typeof i === 'string') {\n            var ret = RG.SVG.commonSetter({ object: this, name: i, value: arguments[0][i] });name = ret.name;value = ret.value;this.set(name, value);\n          }\n        }\n      } else {\n        var ret = RG.SVG.commonSetter({ object: this, name: name, value: value });name = ret.name;value = ret.value;this.properties[name] = value;\n      }\n      return this;\n    };this.id = conf.id;this.uid = RG.SVG.createUID();this.container = document.getElementById(this.id);this.svg = RG.SVG.createSVG({ container: this.container });this.isRGraph = true;this.width = Number(this.svg.getAttribute('width'));this.height = Number(this.svg.getAttribute('height'));this.data = conf.data;this.type = 'waterfall';this.coords = [];this.colorsParsed = false;this.originalColors = {};this.gradientCounter = 1;RG.SVG.OR.add(this);this.container.style.display = 'inline-block';this.properties = { gutterLeft: 35, gutterRight: 35, gutterTop: 35, gutterBottom: 35, backgroundColor: null, backgroundImage: null, backgroundImageAspect: 'none', backgroundImageStretch: true, backgroundImageOpacity: null, backgroundImageX: null, backgroundImageY: null, backgroundImageW: null, backgroundImageH: null, backgroundGrid: true, backgroundGridColor: '#ddd', backgroundGridLinewidth: 1, backgroundGridHlines: true, backgroundGridHlinesCount: null, backgroundGridVlines: true, backgroundGridVlinesCount: null, backgroundGridBorder: true, colors: ['black', 'red', 'blue'], colorsSequential: false, strokestyle: '#aaa', strokestyleConnector: null, total: true, hmargin: 5, linewidth: 1, yaxis: true, yaxisTickmarks: true, yaxisTickmarksLength: 5, yaxisColor: 'black', yaxisScale: true, yaxisLabels: null, yaxisLabelsOffsetx: 0, yaxisLabelsOffsety: 0, yaxisLabelsCount: 5, yaxisUnitsPre: '', yaxisUnitsPost: '', yaxisStrict: false, yaxisDecimals: 0, yaxisPoint: '.', yaxisThousand: ',', yaxisRound: false, yaxisMax: null, yaxisMin: 0, yaxisFormatter: null, yaxisTextColor: null, yaxisTextBold: null, yaxisTextItalic: null, yaxisTextFont: null, yaxisTextSize: null, xaxis: true, xaxisTickmarks: true, xaxisTickmarksLength: 5, xaxisLabels: null, xaxisLabelsPosition: 'section', xaxisLabelsPositionEdgeTickmarksCount: null, xaxisColor: 'black', xaxisLabelsOffsetx: 0, xaxisLabelsOffsety: 0, labelsAbove: false, labelsAboveFont: null, labelsAboveSize: null, labelsAboveBold: null, labelsAboveItalic: null, labelsAboveColor: null, labelsAboveBackground: 'rgba(255,255,255,0.5)', labelsAboveBackgroundPadding: 2, labelsAboveUnitsPre: null, labelsAboveUnitsPost: null, labelsAbovePoint: null, labelsAboveThousand: null, labelsAboveFormatter: null, labelsAboveDecimals: null, labelsAboveOffsetx: 0, labelsAboveOffsety: 0, labelsAboveHalign: 'center', labelsAboveValign: 'bottom', labelsAboveSpecific: null, textColor: 'black', textFont: 'sans-serif', textSize: 12, textBold: false, textItalic: false, tooltips: null, tooltipsOverride: null, tooltipsEffect: 'fade', tooltipsCssClass: 'RGraph_tooltip', tooltipsEvent: 'click', highlightStroke: 'rgba(0,0,0,0)', highlightFill: 'rgba(255,255,255,0.7)', highlightLinewidth: 1, title: '', titleSize: 16, titleX: null, titleY: null, titleHalign: 'center', titleValign: null, titleColor: 'black', titleFont: null, titleBold: false, titleItalic: false, titleSubtitle: '', titleSubtitleSize: 10, titleSubtitleX: null, titleSubtitleY: null, titleSubtitleHalign: 'center', titleSubtitleValign: null, titleSubtitleColor: '#aaa', titleSubtitleFont: null, titleSubtitleBold: false, titleSubtitleItalic: false, key: null, keyColors: null, keyOffsetx: 0, keyOffsety: 0, keyTextOffsetx: 0, keyTextOffsety: -1, keyTextSize: null, keyTextBold: null, keyTextItalic: null, attribution: true, attributionX: null, attributionY: null, attributionHref: null, attributionHalign: 'right', attributionValign: 'bottom', attributionSize: 7, attributionColor: 'gray', attributionFont: 'sans-serif', attributionItalic: false, attributionBold: false };if (RG.SVG.FX && typeof RG.SVG.FX.decorate === 'function') {\n      RG.SVG.FX.decorate(this);\n    }\n    var prop = this.properties;this.draw = function () {\n      RG.SVG.fireCustomEvent(this, 'onbeforedraw');RG.SVG.createDefs(this);this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;RG.SVG.resetColorsToOriginalValues({ object: this });this.parseColors();if (prop.total) {\n        var sum = RG.SVG.arraySum(this.data);this.data.push(sum);if (prop.xaxisLabels && prop.xaxisLabels.length === this.data.length - 1) {\n          prop.xaxisLabels.push('');\n        }\n      }\n      for (var i = 0, max = 0, runningTotal = 0; i < this.data.length - (prop.total ? 1 : 0); ++i) {\n        runningTotal += this.data[i];\n        max = ma.max(max, runningTotal);\n      }\n      if (typeof prop.yaxisMax === 'number') {\n        max = prop.yaxisMax;\n      }\n      if (prop.yaxisMin === 'mirror' || prop.yaxisMin === 'middle' || prop.yaxisMin === 'center') {\n        var mirrorScale = true;prop.yaxisMin = 0;\n      }\n      this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: max, min: prop.yaxisMin, point: prop.yaxisPoint, round: prop.yaxisRound, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });if (mirrorScale) {\n        this.scale = RG.SVG.getScale({ object: this, numlabels: prop.yaxisLabelsCount, unitsPre: prop.yaxisUnitsPre, unitsPost: prop.yaxisUnitsPost, max: this.scale.max, min: this.scale.max * -1, point: prop.yaxisPoint, round: false, thousand: prop.yaxisThousand, decimals: prop.yaxisDecimals, strict: typeof prop.yaxisMax === 'number', formatter: prop.yaxisFormatter });\n      }\n      this.max = this.scale.max;this.min = this.scale.min;prop.yaxisMax = this.scale.max;prop.yaxisMin = this.scale.min;RG.SVG.drawBackground(this);RG.SVG.drawXAxis(this);RG.SVG.drawYAxis(this);this.drawBars();this.drawLabelsAbove();if (typeof prop.key !== null && RG.SVG.drawKey) {\n        RG.SVG.drawKey(this);\n      } else if (!RGraph.SVG.isNull(prop.key)) {\n        alert('The drawKey() function does not exist - have you forgotten to include the key library?');\n      }\n      RG.SVG.attribution(this);RG.SVG.fireCustomEvent(this, 'ondraw');return this;\n    };this.drawBars = function () {\n      this.graphWidth = this.width - prop.gutterLeft - prop.gutterRight;this.graphHeight = this.height - prop.gutterTop - prop.gutterBottom;var innerWidth = this.graphWidth / this.data.length - 2 * prop.hmargin,\n          outerWidth = this.graphWidth / this.data.length;var y = this.getYCoord(0),\n          total = 0;for (var i = 0; i < this.data.length; ++i) {\n        var prevValue = this.data[i - 1],\n            nextValue = this.data[i + 1],\n            currentValue = this.data[i],\n            prevTotal = total;total += parseFloat(this.data[i]) || 0;var height = ma.abs(this.data[i] / (this.scale.max - this.scale.min) * this.graphHeight);if (prevValue === null) {\n          if (currentValue > 0) {\n            y = this.getYCoord(prevTotal) - height;\n          } else {\n            y = this.getYCoord(prevTotal);\n          }\n        } else {\n          if (i == 0 && this.data[i] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] > 0) {\n            y = y - height;\n          } else if (this.data[i] > 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight - height;\n          } else if (this.data[i] < 0 && this.data[i - 1] > 0) {} else if (this.data[i] < 0 && this.data[i - 1] < 0) {\n            y = y + prevHeight;\n          }\n        }\n        var fill = this.data[i] > 0 ? prop.colors[0] : prop.colors[1];if (prop.colorsSequential) {\n          fill = prop.colors[i];\n        }\n        if (i === this.data.length - 1 && this.data[this.data.length - 1] >= 0) {\n          y = this.getYCoord(0) - height;if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        } else if (i === this.data.length - 1 && this.data[this.data.length - 1] < 0) {\n          y = this.getYCoord(0);if (!prop.colorsSequential) {\n            fill = prop.colors[2];\n          }\n        }\n        var x = prop.gutterLeft + outerWidth * i + prop.hmargin;if (this.data[i] === null || typeof this.data[i] === 'undefined') {\n          var axisY = this.getYCoord(0);if (prevValue < 0) {\n            y = prevY + prevHeight;\n          } else {\n            y = prevY;\n          }\n          height = this.getYCoord(0) - this.getYCoord(total);if (!prop.colorsSequential) {\n            fill = prop.colors[3] || prop.colors[2];\n          }\n          if (height < 0) {\n            y += height;height *= -1;\n          }\n        }\n        var rect = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { x: x, y: y, width: innerWidth, height: height, stroke: prop.strokestyle, fill: fill, 'stroke-width': prop.linewidth, 'shape-rendering': 'crispEdges', 'data-index': i, 'data-original-x': x, 'data-original-y': y, 'data-original-width': innerWidth, 'data-original-height': height, 'data-original-stroke': prop.strokestyle, 'data-original-fill': fill, 'data-value': String(this.data[i]) } });this.coords[i] = { object: rect, x: x, y: y, width: innerWidth, height: height };if (!RG.SVG.isNull(prop.tooltips) && prop.tooltips[i]) {\n          var obj = this;(function (idx) {\n            rect.addEventListener(prop.tooltipsEvent.replace(/^on/, ''), function (e) {\n              obj.removeHighlight();RG.SVG.tooltip({ object: obj, index: idx, text: prop.tooltips[idx], event: e });obj.highlight(e.target);\n            }, false);rect.addEventListener('mousemove', function (e) {\n              e.target.style.cursor = 'pointer';\n            }, false);\n          })(i);\n        }\n        var prevX = x,\n            prevY = y,\n            prevWidth = innerWidth,\n            prevHeight = height,\n            prevValue = this.data[i];\n      }\n      for (var i = 0; i < this.coords.length; ++i) {\n        if (this.coords[i + 1] && this.coords[i + 1].object) {\n          var x1 = Number(this.coords[i].object.getAttribute('x')) + Number(this.coords[i].object.getAttribute('width')),\n              y1 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height'))),\n              x2 = x1 + 2 * prop.hmargin,\n              y2 = parseInt(this.coords[i].object.getAttribute('y')) + (this.data[i] > 0 ? 0 : parseInt(this.coords[i].object.getAttribute('height')));if (this.coords[i].object.getAttribute('data-value') === 'null') {\n            y1 = parseFloat(this.coords[i].object.getAttribute('y'));y2 = parseFloat(y1);\n          }\n          var line = RG.SVG.create({ svg: this.svg, type: 'line', parent: this.svg.all, attr: { x1: x1, y1: y1 + 0.5, x2: x2, y2: y2 + 0.5, stroke: prop.strokestyleConnector || prop.strokestyle, 'stroke-width': prop.linewidth, 'data-index': i, 'data-original-x1': x1, 'data-original-y1': y1 + 0.5, 'data-original-x2': x2, 'data-original-y2': y2 + 0.5 } });\n        }\n      }\n    };this.getYCoord = function (value) {\n      var prop = this.properties;if (value > this.scale.max) {\n        return null;\n      }\n      var y,\n          xaxispos = prop.xaxispos;if (value < this.scale.min) {\n        return null;\n      }\n      y = (value - this.scale.min) / (this.scale.max - this.scale.min);y *= this.height - prop.gutterTop - prop.gutterBottom;y = this.height - prop.gutterBottom - y;return y;\n    };this.highlight = function (rect) {\n      var x = rect.getAttribute('x'),\n          y = rect.getAttribute('y'),\n          width = rect.getAttribute('width'),\n          height = rect.getAttribute('height');var highlight = RG.SVG.create({ svg: this.svg, type: 'rect', parent: this.svg.all, attr: { stroke: prop.highlightStroke, fill: prop.highlightFill, x: x, y: y, width: width, height: height, 'stroke-width': prop.highlightLinewidth } });RG.SVG.REG.set('highlight', highlight);\n    };this.parseColors = function () {\n      if (!Object.keys(this.originalColors).length) {\n        this.originalColors = { colors: RG.SVG.arrayClone(prop.colors), backgroundGridColor: RG.SVG.arrayClone(prop.backgroundGridColor), highlightFill: RG.SVG.arrayClone(prop.highlightFill), backgroundColor: RG.SVG.arrayClone(prop.backgroundColor) };\n      }\n      var colors = prop.colors;if (colors) {\n        for (var i = 0; i < colors.length; ++i) {\n          colors[i] = RG.SVG.parseColorLinear({ object: this, color: colors[i] });\n        }\n      }\n      prop.backgroundGridColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundGridColor });prop.highlightFill = RG.SVG.parseColorLinear({ object: this, color: prop.highlightFill });prop.backgroundColor = RG.SVG.parseColorLinear({ object: this, color: prop.backgroundColor });\n    };this.drawLabelsAbove = function () {\n      if (prop.labelsAbove) {\n        var total = 0;for (var i = 0; i < this.coords.length; ++i) {\n          var num = this.data[i],\n              total = total + num;if (typeof num === 'number' || RG.SVG.isNull(num)) {\n            if (RG.SVG.isNull(num)) {\n              num = total;\n            }\n            var str = RG.SVG.numberFormat({ object: this, num: num.toFixed(prop.labelsAboveDecimals), prepend: typeof prop.labelsAboveUnitsPre === 'string' ? prop.labelsAboveUnitsPre : null, append: typeof prop.labelsAboveUnitsPost === 'string' ? prop.labelsAboveUnitsPost : null, point: typeof prop.labelsAbovePoint === 'string' ? prop.labelsAbovePoint : null, thousand: typeof prop.labelsAboveThousand === 'string' ? prop.labelsAboveThousand : null, formatter: typeof prop.labelsAboveFormatter === 'function' ? prop.labelsAboveFormatter : null });if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && (typeof prop.labelsAboveSpecific[i] === 'string' || typeof prop.labelsAboveSpecific[i] === 'number')) {\n              str = prop.labelsAboveSpecific[i];\n            } else if (prop.labelsAboveSpecific && prop.labelsAboveSpecific.length && typeof prop.labelsAboveSpecific[i] !== 'string' && typeof prop.labelsAboveSpecific[i] !== 'number') {\n              continue;\n            }\n            var x = parseFloat(this.coords[i].object.getAttribute('x')) + parseFloat(this.coords[i].object.getAttribute('width') / 2) + prop.labelsAboveOffsetx;if (this.data[i] >= 0) {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) - 7 + prop.labelsAboveOffsety;var valign = prop.labelsAboveValign;\n            } else {\n              var y = parseFloat(this.coords[i].object.getAttribute('y')) + parseFloat(this.coords[i].object.getAttribute('height')) + 7 - prop.labelsAboveOffsety;var valign = prop.labelsAboveValign === 'top' ? 'bottom' : 'top';\n            }\n            RG.SVG.text({ object: this, parent: this.svg.all, text: str, x: x, y: y, halign: prop.labelsAboveHalign, valign: valign, font: prop.labelsAboveFont || prop.textFont, size: prop.labelsAboveSize || prop.textSize, bold: prop.labelsAboveBold || prop.textBold, italic: prop.labelsAboveItalic || prop.textItalic, color: prop.labelsAboveColor || prop.textColor, background: prop.labelsAboveBackground || null, padding: prop.labelsAboveBackgroundPadding || 0 });\n          }\n        }\n      }\n    };this.on = function (type, func) {\n      if (type.substr(0, 2) !== 'on') {\n        type = 'on' + type;\n      }\n      RG.SVG.addCustomEventListener(this, type, func);return this;\n    };this.exec = function (func) {\n      func(this);return this;\n    };this.removeHighlight = function () {\n      var highlight = RG.SVG.REG.get('highlight');if (highlight && highlight.parentNode) {\n        highlight.parentNode.removeChild(highlight);\n      }\n      RG.SVG.REG.set('highlight', null);\n    };this.grow = function () {\n      var opt = arguments[0] || {},\n          frames = opt.frames || 30,\n          frame = 0,\n          obj = this,\n          data = [],\n          height = null,\n          seq = 0;return this;\n    };this.wave = function () {\n      return this;\n    };for (i in conf.options) {\n      if (typeof i === 'string') {\n        this.set(i, conf.options[i]);\n      }\n    }\n  };return this;\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC5zdmcud2F0ZXJmYWxsLmpzP2Y5NWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5SR3JhcGggPSB3aW5kb3cuUkdyYXBoIHx8IHsgaXNSR3JhcGg6IHRydWUgfTtSR3JhcGguU1ZHID0gUkdyYXBoLlNWRyB8fCB7fTsoZnVuY3Rpb24gKHdpbiwgZG9jLCB1bmRlZmluZWQpIHtcbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbWEgPSBNYXRoLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQ7UkcuU1ZHLldhdGVyZmFsbCA9IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHJldCA9IFJHLlNWRy5jb21tb25TZXR0ZXIoeyBvYmplY3Q6IHRoaXMsIG5hbWU6IGksIHZhbHVlOiBhcmd1bWVudHNbMF1baV0gfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXQgPSBSRy5TVkcuY29tbW9uU2V0dGVyKHsgb2JqZWN0OiB0aGlzLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7bmFtZSA9IHJldC5uYW1lO3ZhbHVlID0gcmV0LnZhbHVlO3RoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLmlkID0gY29uZi5pZDt0aGlzLnVpZCA9IFJHLlNWRy5jcmVhdGVVSUQoKTt0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuc3ZnID0gUkcuU1ZHLmNyZWF0ZVNWRyh7IGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIgfSk7dGhpcy5pc1JHcmFwaCA9IHRydWU7dGhpcy53aWR0aCA9IE51bWJlcih0aGlzLnN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO3RoaXMuaGVpZ2h0ID0gTnVtYmVyKHRoaXMuc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO3RoaXMuZGF0YSA9IGNvbmYuZGF0YTt0aGlzLnR5cGUgPSAnd2F0ZXJmYWxsJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuY29sb3JzUGFyc2VkID0gZmFsc2U7dGhpcy5vcmlnaW5hbENvbG9ycyA9IHt9O3RoaXMuZ3JhZGllbnRDb3VudGVyID0gMTtSRy5TVkcuT1IuYWRkKHRoaXMpO3RoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzt0aGlzLnByb3BlcnRpZXMgPSB7IGd1dHRlckxlZnQ6IDM1LCBndXR0ZXJSaWdodDogMzUsIGd1dHRlclRvcDogMzUsIGd1dHRlckJvdHRvbTogMzUsIGJhY2tncm91bmRDb2xvcjogbnVsbCwgYmFja2dyb3VuZEltYWdlOiBudWxsLCBiYWNrZ3JvdW5kSW1hZ2VBc3BlY3Q6ICdub25lJywgYmFja2dyb3VuZEltYWdlU3RyZXRjaDogdHJ1ZSwgYmFja2dyb3VuZEltYWdlT3BhY2l0eTogbnVsbCwgYmFja2dyb3VuZEltYWdlWDogbnVsbCwgYmFja2dyb3VuZEltYWdlWTogbnVsbCwgYmFja2dyb3VuZEltYWdlVzogbnVsbCwgYmFja2dyb3VuZEltYWdlSDogbnVsbCwgYmFja2dyb3VuZEdyaWQ6IHRydWUsIGJhY2tncm91bmRHcmlkQ29sb3I6ICcjZGRkJywgYmFja2dyb3VuZEdyaWRMaW5ld2lkdGg6IDEsIGJhY2tncm91bmRHcmlkSGxpbmVzOiB0cnVlLCBiYWNrZ3JvdW5kR3JpZEhsaW5lc0NvdW50OiBudWxsLCBiYWNrZ3JvdW5kR3JpZFZsaW5lczogdHJ1ZSwgYmFja2dyb3VuZEdyaWRWbGluZXNDb3VudDogbnVsbCwgYmFja2dyb3VuZEdyaWRCb3JkZXI6IHRydWUsIGNvbG9yczogWydibGFjaycsICdyZWQnLCAnYmx1ZSddLCBjb2xvcnNTZXF1ZW50aWFsOiBmYWxzZSwgc3Ryb2tlc3R5bGU6ICcjYWFhJywgc3Ryb2tlc3R5bGVDb25uZWN0b3I6IG51bGwsIHRvdGFsOiB0cnVlLCBobWFyZ2luOiA1LCBsaW5ld2lkdGg6IDEsIHlheGlzOiB0cnVlLCB5YXhpc1RpY2ttYXJrczogdHJ1ZSwgeWF4aXNUaWNrbWFya3NMZW5ndGg6IDUsIHlheGlzQ29sb3I6ICdibGFjaycsIHlheGlzU2NhbGU6IHRydWUsIHlheGlzTGFiZWxzOiBudWxsLCB5YXhpc0xhYmVsc09mZnNldHg6IDAsIHlheGlzTGFiZWxzT2Zmc2V0eTogMCwgeWF4aXNMYWJlbHNDb3VudDogNSwgeWF4aXNVbml0c1ByZTogJycsIHlheGlzVW5pdHNQb3N0OiAnJywgeWF4aXNTdHJpY3Q6IGZhbHNlLCB5YXhpc0RlY2ltYWxzOiAwLCB5YXhpc1BvaW50OiAnLicsIHlheGlzVGhvdXNhbmQ6ICcsJywgeWF4aXNSb3VuZDogZmFsc2UsIHlheGlzTWF4OiBudWxsLCB5YXhpc01pbjogMCwgeWF4aXNGb3JtYXR0ZXI6IG51bGwsIHlheGlzVGV4dENvbG9yOiBudWxsLCB5YXhpc1RleHRCb2xkOiBudWxsLCB5YXhpc1RleHRJdGFsaWM6IG51bGwsIHlheGlzVGV4dEZvbnQ6IG51bGwsIHlheGlzVGV4dFNpemU6IG51bGwsIHhheGlzOiB0cnVlLCB4YXhpc1RpY2ttYXJrczogdHJ1ZSwgeGF4aXNUaWNrbWFya3NMZW5ndGg6IDUsIHhheGlzTGFiZWxzOiBudWxsLCB4YXhpc0xhYmVsc1Bvc2l0aW9uOiAnc2VjdGlvbicsIHhheGlzTGFiZWxzUG9zaXRpb25FZGdlVGlja21hcmtzQ291bnQ6IG51bGwsIHhheGlzQ29sb3I6ICdibGFjaycsIHhheGlzTGFiZWxzT2Zmc2V0eDogMCwgeGF4aXNMYWJlbHNPZmZzZXR5OiAwLCBsYWJlbHNBYm92ZTogZmFsc2UsIGxhYmVsc0Fib3ZlRm9udDogbnVsbCwgbGFiZWxzQWJvdmVTaXplOiBudWxsLCBsYWJlbHNBYm92ZUJvbGQ6IG51bGwsIGxhYmVsc0Fib3ZlSXRhbGljOiBudWxsLCBsYWJlbHNBYm92ZUNvbG9yOiBudWxsLCBsYWJlbHNBYm92ZUJhY2tncm91bmQ6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknLCBsYWJlbHNBYm92ZUJhY2tncm91bmRQYWRkaW5nOiAyLCBsYWJlbHNBYm92ZVVuaXRzUHJlOiBudWxsLCBsYWJlbHNBYm92ZVVuaXRzUG9zdDogbnVsbCwgbGFiZWxzQWJvdmVQb2ludDogbnVsbCwgbGFiZWxzQWJvdmVUaG91c2FuZDogbnVsbCwgbGFiZWxzQWJvdmVGb3JtYXR0ZXI6IG51bGwsIGxhYmVsc0Fib3ZlRGVjaW1hbHM6IG51bGwsIGxhYmVsc0Fib3ZlT2Zmc2V0eDogMCwgbGFiZWxzQWJvdmVPZmZzZXR5OiAwLCBsYWJlbHNBYm92ZUhhbGlnbjogJ2NlbnRlcicsIGxhYmVsc0Fib3ZlVmFsaWduOiAnYm90dG9tJywgbGFiZWxzQWJvdmVTcGVjaWZpYzogbnVsbCwgdGV4dENvbG9yOiAnYmxhY2snLCB0ZXh0Rm9udDogJ3NhbnMtc2VyaWYnLCB0ZXh0U2l6ZTogMTIsIHRleHRCb2xkOiBmYWxzZSwgdGV4dEl0YWxpYzogZmFsc2UsIHRvb2x0aXBzOiBudWxsLCB0b29sdGlwc092ZXJyaWRlOiBudWxsLCB0b29sdGlwc0VmZmVjdDogJ2ZhZGUnLCB0b29sdGlwc0Nzc0NsYXNzOiAnUkdyYXBoX3Rvb2x0aXAnLCB0b29sdGlwc0V2ZW50OiAnY2xpY2snLCBoaWdobGlnaHRTdHJva2U6ICdyZ2JhKDAsMCwwLDApJywgaGlnaGxpZ2h0RmlsbDogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsIGhpZ2hsaWdodExpbmV3aWR0aDogMSwgdGl0bGU6ICcnLCB0aXRsZVNpemU6IDE2LCB0aXRsZVg6IG51bGwsIHRpdGxlWTogbnVsbCwgdGl0bGVIYWxpZ246ICdjZW50ZXInLCB0aXRsZVZhbGlnbjogbnVsbCwgdGl0bGVDb2xvcjogJ2JsYWNrJywgdGl0bGVGb250OiBudWxsLCB0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZUl0YWxpYzogZmFsc2UsIHRpdGxlU3VidGl0bGU6ICcnLCB0aXRsZVN1YnRpdGxlU2l6ZTogMTAsIHRpdGxlU3VidGl0bGVYOiBudWxsLCB0aXRsZVN1YnRpdGxlWTogbnVsbCwgdGl0bGVTdWJ0aXRsZUhhbGlnbjogJ2NlbnRlcicsIHRpdGxlU3VidGl0bGVWYWxpZ246IG51bGwsIHRpdGxlU3VidGl0bGVDb2xvcjogJyNhYWEnLCB0aXRsZVN1YnRpdGxlRm9udDogbnVsbCwgdGl0bGVTdWJ0aXRsZUJvbGQ6IGZhbHNlLCB0aXRsZVN1YnRpdGxlSXRhbGljOiBmYWxzZSwga2V5OiBudWxsLCBrZXlDb2xvcnM6IG51bGwsIGtleU9mZnNldHg6IDAsIGtleU9mZnNldHk6IDAsIGtleVRleHRPZmZzZXR4OiAwLCBrZXlUZXh0T2Zmc2V0eTogLTEsIGtleVRleHRTaXplOiBudWxsLCBrZXlUZXh0Qm9sZDogbnVsbCwga2V5VGV4dEl0YWxpYzogbnVsbCwgYXR0cmlidXRpb246IHRydWUsIGF0dHJpYnV0aW9uWDogbnVsbCwgYXR0cmlidXRpb25ZOiBudWxsLCBhdHRyaWJ1dGlvbkhyZWY6IG51bGwsIGF0dHJpYnV0aW9uSGFsaWduOiAncmlnaHQnLCBhdHRyaWJ1dGlvblZhbGlnbjogJ2JvdHRvbScsIGF0dHJpYnV0aW9uU2l6ZTogNywgYXR0cmlidXRpb25Db2xvcjogJ2dyYXknLCBhdHRyaWJ1dGlvbkZvbnQ6ICdzYW5zLXNlcmlmJywgYXR0cmlidXRpb25JdGFsaWM6IGZhbHNlLCBhdHRyaWJ1dGlvbkJvbGQ6IGZhbHNlIH07aWYgKFJHLlNWRy5GWCAmJiB0eXBlb2YgUkcuU1ZHLkZYLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSRy5TVkcuRlguZGVjb3JhdGUodGhpcyk7XG4gICAgfVxuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzO3RoaXMuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJHLlNWRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uYmVmb3JlZHJhdycpO1JHLlNWRy5jcmVhdGVEZWZzKHRoaXMpO3RoaXMuZ3JhcGhXaWR0aCA9IHRoaXMud2lkdGggLSBwcm9wLmd1dHRlckxlZnQgLSBwcm9wLmd1dHRlclJpZ2h0O3RoaXMuZ3JhcGhIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207UkcuU1ZHLnJlc2V0Q29sb3JzVG9PcmlnaW5hbFZhbHVlcyh7IG9iamVjdDogdGhpcyB9KTt0aGlzLnBhcnNlQ29sb3JzKCk7aWYgKHByb3AudG90YWwpIHtcbiAgICAgICAgdmFyIHN1bSA9IFJHLlNWRy5hcnJheVN1bSh0aGlzLmRhdGEpO3RoaXMuZGF0YS5wdXNoKHN1bSk7aWYgKHByb3AueGF4aXNMYWJlbHMgJiYgcHJvcC54YXhpc0xhYmVscy5sZW5ndGggPT09IHRoaXMuZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcHJvcC54YXhpc0xhYmVscy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IDAsIHJ1bm5pbmdUb3RhbCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoIC0gKHByb3AudG90YWwgPyAxIDogMCk7ICsraSkge1xuICAgICAgICBydW5uaW5nVG90YWwgKz0gdGhpcy5kYXRhW2ldO1xuICAgICAgICBtYXggPSBtYS5tYXgobWF4LCBydW5uaW5nVG90YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXggPSBwcm9wLnlheGlzTWF4O1xuICAgICAgfVxuICAgICAgaWYgKHByb3AueWF4aXNNaW4gPT09ICdtaXJyb3InIHx8IHByb3AueWF4aXNNaW4gPT09ICdtaWRkbGUnIHx8IHByb3AueWF4aXNNaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciBtaXJyb3JTY2FsZSA9IHRydWU7cHJvcC55YXhpc01pbiA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjYWxlID0gUkcuU1ZHLmdldFNjYWxlKHsgb2JqZWN0OiB0aGlzLCBudW1sYWJlbHM6IHByb3AueWF4aXNMYWJlbHNDb3VudCwgdW5pdHNQcmU6IHByb3AueWF4aXNVbml0c1ByZSwgdW5pdHNQb3N0OiBwcm9wLnlheGlzVW5pdHNQb3N0LCBtYXg6IG1heCwgbWluOiBwcm9wLnlheGlzTWluLCBwb2ludDogcHJvcC55YXhpc1BvaW50LCByb3VuZDogcHJvcC55YXhpc1JvdW5kLCB0aG91c2FuZDogcHJvcC55YXhpc1Rob3VzYW5kLCBkZWNpbWFsczogcHJvcC55YXhpc0RlY2ltYWxzLCBzdHJpY3Q6IHR5cGVvZiBwcm9wLnlheGlzTWF4ID09PSAnbnVtYmVyJywgZm9ybWF0dGVyOiBwcm9wLnlheGlzRm9ybWF0dGVyIH0pO2lmIChtaXJyb3JTY2FsZSkge1xuICAgICAgICB0aGlzLnNjYWxlID0gUkcuU1ZHLmdldFNjYWxlKHsgb2JqZWN0OiB0aGlzLCBudW1sYWJlbHM6IHByb3AueWF4aXNMYWJlbHNDb3VudCwgdW5pdHNQcmU6IHByb3AueWF4aXNVbml0c1ByZSwgdW5pdHNQb3N0OiBwcm9wLnlheGlzVW5pdHNQb3N0LCBtYXg6IHRoaXMuc2NhbGUubWF4LCBtaW46IHRoaXMuc2NhbGUubWF4ICogLTEsIHBvaW50OiBwcm9wLnlheGlzUG9pbnQsIHJvdW5kOiBmYWxzZSwgdGhvdXNhbmQ6IHByb3AueWF4aXNUaG91c2FuZCwgZGVjaW1hbHM6IHByb3AueWF4aXNEZWNpbWFscywgc3RyaWN0OiB0eXBlb2YgcHJvcC55YXhpc01heCA9PT0gJ251bWJlcicsIGZvcm1hdHRlcjogcHJvcC55YXhpc0Zvcm1hdHRlciB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4ID0gdGhpcy5zY2FsZS5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlLm1pbjtwcm9wLnlheGlzTWF4ID0gdGhpcy5zY2FsZS5tYXg7cHJvcC55YXhpc01pbiA9IHRoaXMuc2NhbGUubWluO1JHLlNWRy5kcmF3QmFja2dyb3VuZCh0aGlzKTtSRy5TVkcuZHJhd1hBeGlzKHRoaXMpO1JHLlNWRy5kcmF3WUF4aXModGhpcyk7dGhpcy5kcmF3QmFycygpO3RoaXMuZHJhd0xhYmVsc0Fib3ZlKCk7aWYgKHR5cGVvZiBwcm9wLmtleSAhPT0gbnVsbCAmJiBSRy5TVkcuZHJhd0tleSkge1xuICAgICAgICBSRy5TVkcuZHJhd0tleSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIVJHcmFwaC5TVkcuaXNOdWxsKHByb3Aua2V5KSkge1xuICAgICAgICBhbGVydCgnVGhlIGRyYXdLZXkoKSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCAtIGhhdmUgeW91IGZvcmdvdHRlbiB0byBpbmNsdWRlIHRoZSBrZXkgbGlicmFyeT8nKTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hdHRyaWJ1dGlvbih0aGlzKTtSRy5TVkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgICB9O3RoaXMuZHJhd0JhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmdyYXBoV2lkdGggPSB0aGlzLndpZHRoIC0gcHJvcC5ndXR0ZXJMZWZ0IC0gcHJvcC5ndXR0ZXJSaWdodDt0aGlzLmdyYXBoSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSBwcm9wLmd1dHRlclRvcCAtIHByb3AuZ3V0dGVyQm90dG9tO3ZhciBpbm5lcldpZHRoID0gdGhpcy5ncmFwaFdpZHRoIC8gdGhpcy5kYXRhLmxlbmd0aCAtIDIgKiBwcm9wLmhtYXJnaW4sXG4gICAgICAgICAgb3V0ZXJXaWR0aCA9IHRoaXMuZ3JhcGhXaWR0aCAvIHRoaXMuZGF0YS5sZW5ndGg7dmFyIHkgPSB0aGlzLmdldFlDb29yZCgwKSxcbiAgICAgICAgICB0b3RhbCA9IDA7Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuZGF0YVtpIC0gMV0sXG4gICAgICAgICAgICBuZXh0VmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdLFxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gdGhpcy5kYXRhW2ldLFxuICAgICAgICAgICAgcHJldlRvdGFsID0gdG90YWw7dG90YWwgKz0gcGFyc2VGbG9hdCh0aGlzLmRhdGFbaV0pIHx8IDA7dmFyIGhlaWdodCA9IG1hLmFicyh0aGlzLmRhdGFbaV0gLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbikgKiB0aGlzLmdyYXBoSGVpZ2h0KTtpZiAocHJldlZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZChwcmV2VG90YWwpIC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQocHJldlRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPT0gMCAmJiB0aGlzLmRhdGFbaV0gPiAwKSB7XG4gICAgICAgICAgICB5ID0geSAtIGhlaWdodDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVtpXSA+IDAgJiYgdGhpcy5kYXRhW2kgLSAxXSA+IDApIHtcbiAgICAgICAgICAgIHkgPSB5IC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhW2ldID4gMCAmJiB0aGlzLmRhdGFbaSAtIDFdIDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBwcmV2SGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhW2ldIDwgMCAmJiB0aGlzLmRhdGFbaSAtIDFdID4gMCkge30gZWxzZSBpZiAodGhpcy5kYXRhW2ldIDwgMCAmJiB0aGlzLmRhdGFbaSAtIDFdIDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBwcmV2SGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsbCA9IHRoaXMuZGF0YVtpXSA+IDAgPyBwcm9wLmNvbG9yc1swXSA6IHByb3AuY29sb3JzWzFdO2lmIChwcm9wLmNvbG9yc1NlcXVlbnRpYWwpIHtcbiAgICAgICAgICBmaWxsID0gcHJvcC5jb2xvcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHRoaXMuZGF0YS5sZW5ndGggLSAxICYmIHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0gPj0gMCkge1xuICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZCgwKSAtIGhlaWdodDtpZiAoIXByb3AuY29sb3JzU2VxdWVudGlhbCkge1xuICAgICAgICAgICAgZmlsbCA9IHByb3AuY29sb3JzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmRhdGEubGVuZ3RoIC0gMSAmJiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdIDwgMCkge1xuICAgICAgICAgIHkgPSB0aGlzLmdldFlDb29yZCgwKTtpZiAoIXByb3AuY29sb3JzU2VxdWVudGlhbCkge1xuICAgICAgICAgICAgZmlsbCA9IHByb3AuY29sb3JzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHByb3AuZ3V0dGVyTGVmdCArIG91dGVyV2lkdGggKiBpICsgcHJvcC5obWFyZ2luO2lmICh0aGlzLmRhdGFbaV0gPT09IG51bGwgfHwgdHlwZW9mIHRoaXMuZGF0YVtpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgYXhpc1kgPSB0aGlzLmdldFlDb29yZCgwKTtpZiAocHJldlZhbHVlIDwgMCkge1xuICAgICAgICAgICAgeSA9IHByZXZZICsgcHJldkhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHByZXZZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFlDb29yZCgwKSAtIHRoaXMuZ2V0WUNvb3JkKHRvdGFsKTtpZiAoIXByb3AuY29sb3JzU2VxdWVudGlhbCkge1xuICAgICAgICAgICAgZmlsbCA9IHByb3AuY29sb3JzWzNdIHx8IHByb3AuY29sb3JzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSArPSBoZWlnaHQ7aGVpZ2h0ICo9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjdCA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAncmVjdCcsIHBhcmVudDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IHg6IHgsIHk6IHksIHdpZHRoOiBpbm5lcldpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlLCBmaWxsOiBmaWxsLCAnc3Ryb2tlLXdpZHRoJzogcHJvcC5saW5ld2lkdGgsICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcycsICdkYXRhLWluZGV4JzogaSwgJ2RhdGEtb3JpZ2luYWwteCc6IHgsICdkYXRhLW9yaWdpbmFsLXknOiB5LCAnZGF0YS1vcmlnaW5hbC13aWR0aCc6IGlubmVyV2lkdGgsICdkYXRhLW9yaWdpbmFsLWhlaWdodCc6IGhlaWdodCwgJ2RhdGEtb3JpZ2luYWwtc3Ryb2tlJzogcHJvcC5zdHJva2VzdHlsZSwgJ2RhdGEtb3JpZ2luYWwtZmlsbCc6IGZpbGwsICdkYXRhLXZhbHVlJzogU3RyaW5nKHRoaXMuZGF0YVtpXSkgfSB9KTt0aGlzLmNvb3Jkc1tpXSA9IHsgb2JqZWN0OiByZWN0LCB4OiB4LCB5OiB5LCB3aWR0aDogaW5uZXJXaWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtpZiAoIVJHLlNWRy5pc051bGwocHJvcC50b29sdGlwcykgJiYgcHJvcC50b29sdGlwc1tpXSkge1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzOyhmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICByZWN0LmFkZEV2ZW50TGlzdGVuZXIocHJvcC50b29sdGlwc0V2ZW50LnJlcGxhY2UoL15vbi8sICcnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgb2JqLnJlbW92ZUhpZ2hsaWdodCgpO1JHLlNWRy50b29sdGlwKHsgb2JqZWN0OiBvYmosIGluZGV4OiBpZHgsIHRleHQ6IHByb3AudG9vbHRpcHNbaWR4XSwgZXZlbnQ6IGUgfSk7b2JqLmhpZ2hsaWdodChlLnRhcmdldCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7cmVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgfSkoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZYID0geCxcbiAgICAgICAgICAgIHByZXZZID0geSxcbiAgICAgICAgICAgIHByZXZXaWR0aCA9IGlubmVyV2lkdGgsXG4gICAgICAgICAgICBwcmV2SGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgICAgICAgcHJldlZhbHVlID0gdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5jb29yZHNbaSArIDFdICYmIHRoaXMuY29vcmRzW2kgKyAxXS5vYmplY3QpIHtcbiAgICAgICAgICB2YXIgeDEgPSBOdW1iZXIodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneCcpKSArIE51bWJlcih0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSxcbiAgICAgICAgICAgICAgeTEgPSBwYXJzZUludCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpICsgKHRoaXMuZGF0YVtpXSA+IDAgPyAwIDogcGFyc2VJbnQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKSxcbiAgICAgICAgICAgICAgeDIgPSB4MSArIDIgKiBwcm9wLmhtYXJnaW4sXG4gICAgICAgICAgICAgIHkyID0gcGFyc2VJbnQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneScpKSArICh0aGlzLmRhdGFbaV0gPiAwID8gMCA6IHBhcnNlSW50KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKSk7aWYgKHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB5MSA9IHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneScpKTt5MiA9IHBhcnNlRmxvYXQoeTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGluZSA9IFJHLlNWRy5jcmVhdGUoeyBzdmc6IHRoaXMuc3ZnLCB0eXBlOiAnbGluZScsIHBhcmVudDogdGhpcy5zdmcuYWxsLCBhdHRyOiB7IHgxOiB4MSwgeTE6IHkxICsgMC41LCB4MjogeDIsIHkyOiB5MiArIDAuNSwgc3Ryb2tlOiBwcm9wLnN0cm9rZXN0eWxlQ29ubmVjdG9yIHx8IHByb3Auc3Ryb2tlc3R5bGUsICdzdHJva2Utd2lkdGgnOiBwcm9wLmxpbmV3aWR0aCwgJ2RhdGEtaW5kZXgnOiBpLCAnZGF0YS1vcmlnaW5hbC14MSc6IHgxLCAnZGF0YS1vcmlnaW5hbC15MSc6IHkxICsgMC41LCAnZGF0YS1vcmlnaW5hbC14Mic6IHgyLCAnZGF0YS1vcmlnaW5hbC15Mic6IHkyICsgMC41IH0gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O3RoaXMuZ2V0WUNvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllcztpZiAodmFsdWUgPiB0aGlzLnNjYWxlLm1heCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB5LFxuICAgICAgICAgIHhheGlzcG9zID0gcHJvcC54YXhpc3BvcztpZiAodmFsdWUgPCB0aGlzLnNjYWxlLm1pbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSAodmFsdWUgLSB0aGlzLnNjYWxlLm1pbikgLyAodGhpcy5zY2FsZS5tYXggLSB0aGlzLnNjYWxlLm1pbik7eSAqPSB0aGlzLmhlaWdodCAtIHByb3AuZ3V0dGVyVG9wIC0gcHJvcC5ndXR0ZXJCb3R0b207eSA9IHRoaXMuaGVpZ2h0IC0gcHJvcC5ndXR0ZXJCb3R0b20gLSB5O3JldHVybiB5O1xuICAgIH07dGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgdmFyIHggPSByZWN0LmdldEF0dHJpYnV0ZSgneCcpLFxuICAgICAgICAgIHkgPSByZWN0LmdldEF0dHJpYnV0ZSgneScpLFxuICAgICAgICAgIHdpZHRoID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0ID0gcmVjdC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO3ZhciBoaWdobGlnaHQgPSBSRy5TVkcuY3JlYXRlKHsgc3ZnOiB0aGlzLnN2ZywgdHlwZTogJ3JlY3QnLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgYXR0cjogeyBzdHJva2U6IHByb3AuaGlnaGxpZ2h0U3Ryb2tlLCBmaWxsOiBwcm9wLmhpZ2hsaWdodEZpbGwsIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsICdzdHJva2Utd2lkdGgnOiBwcm9wLmhpZ2hsaWdodExpbmV3aWR0aCB9IH0pO1JHLlNWRy5SRUcuc2V0KCdoaWdobGlnaHQnLCBoaWdobGlnaHQpO1xuICAgIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5vcmlnaW5hbENvbG9ycykubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb2xvcnMgPSB7IGNvbG9yczogUkcuU1ZHLmFycmF5Q2xvbmUocHJvcC5jb2xvcnMpLCBiYWNrZ3JvdW5kR3JpZENvbG9yOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IpLCBoaWdobGlnaHRGaWxsOiBSRy5TVkcuYXJyYXlDbG9uZShwcm9wLmhpZ2hsaWdodEZpbGwpLCBiYWNrZ3JvdW5kQ29sb3I6IFJHLlNWRy5hcnJheUNsb25lKHByb3AuYmFja2dyb3VuZENvbG9yKSB9O1xuICAgICAgfVxuICAgICAgdmFyIGNvbG9ycyA9IHByb3AuY29sb3JzO2lmIChjb2xvcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb2xvcnNbaV0gPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IGNvbG9yc1tpXSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5iYWNrZ3JvdW5kR3JpZENvbG9yID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmJhY2tncm91bmRHcmlkQ29sb3IgfSk7cHJvcC5oaWdobGlnaHRGaWxsID0gUkcuU1ZHLnBhcnNlQ29sb3JMaW5lYXIoeyBvYmplY3Q6IHRoaXMsIGNvbG9yOiBwcm9wLmhpZ2hsaWdodEZpbGwgfSk7cHJvcC5iYWNrZ3JvdW5kQ29sb3IgPSBSRy5TVkcucGFyc2VDb2xvckxpbmVhcih7IG9iamVjdDogdGhpcywgY29sb3I6IHByb3AuYmFja2dyb3VuZENvbG9yIH0pO1xuICAgIH07dGhpcy5kcmF3TGFiZWxzQWJvdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvcC5sYWJlbHNBYm92ZSkge1xuICAgICAgICB2YXIgdG90YWwgPSAwO2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgbnVtID0gdGhpcy5kYXRhW2ldLFxuICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgbnVtO2lmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyB8fCBSRy5TVkcuaXNOdWxsKG51bSkpIHtcbiAgICAgICAgICAgIGlmIChSRy5TVkcuaXNOdWxsKG51bSkpIHtcbiAgICAgICAgICAgICAgbnVtID0gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RyID0gUkcuU1ZHLm51bWJlckZvcm1hdCh7IG9iamVjdDogdGhpcywgbnVtOiBudW0udG9GaXhlZChwcm9wLmxhYmVsc0Fib3ZlRGVjaW1hbHMpLCBwcmVwZW5kOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVVuaXRzUHJlID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVVbml0c1ByZSA6IG51bGwsIGFwcGVuZDogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVVbml0c1Bvc3QgPT09ICdzdHJpbmcnID8gcHJvcC5sYWJlbHNBYm92ZVVuaXRzUG9zdCA6IG51bGwsIHBvaW50OiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVBvaW50ID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVQb2ludCA6IG51bGwsIHRob3VzYW5kOiB0eXBlb2YgcHJvcC5sYWJlbHNBYm92ZVRob3VzYW5kID09PSAnc3RyaW5nJyA/IHByb3AubGFiZWxzQWJvdmVUaG91c2FuZCA6IG51bGwsIGZvcm1hdHRlcjogdHlwZW9mIHByb3AubGFiZWxzQWJvdmVGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicgPyBwcm9wLmxhYmVsc0Fib3ZlRm9ybWF0dGVyIDogbnVsbCB9KTtpZiAocHJvcC5sYWJlbHNBYm92ZVNwZWNpZmljICYmIHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYy5sZW5ndGggJiYgKHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbaV0gPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICBzdHIgPSBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbaV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubGFiZWxzQWJvdmVTcGVjaWZpYyAmJiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWMubGVuZ3RoICYmIHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbaV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wLmxhYmVsc0Fib3ZlU3BlY2lmaWNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSkgKyBwYXJzZUZsb2F0KHRoaXMuY29vcmRzW2ldLm9iamVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgLyAyKSArIHByb3AubGFiZWxzQWJvdmVPZmZzZXR4O2lmICh0aGlzLmRhdGFbaV0gPj0gMCkge1xuICAgICAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQodGhpcy5jb29yZHNbaV0ub2JqZWN0LmdldEF0dHJpYnV0ZSgneScpKSAtIDcgKyBwcm9wLmxhYmVsc0Fib3ZlT2Zmc2V0eTt2YXIgdmFsaWduID0gcHJvcC5sYWJlbHNBYm92ZVZhbGlnbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCd5JykpICsgcGFyc2VGbG9hdCh0aGlzLmNvb3Jkc1tpXS5vYmplY3QuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkgKyA3IC0gcHJvcC5sYWJlbHNBYm92ZU9mZnNldHk7dmFyIHZhbGlnbiA9IHByb3AubGFiZWxzQWJvdmVWYWxpZ24gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHLlNWRy50ZXh0KHsgb2JqZWN0OiB0aGlzLCBwYXJlbnQ6IHRoaXMuc3ZnLmFsbCwgdGV4dDogc3RyLCB4OiB4LCB5OiB5LCBoYWxpZ246IHByb3AubGFiZWxzQWJvdmVIYWxpZ24sIHZhbGlnbjogdmFsaWduLCBmb250OiBwcm9wLmxhYmVsc0Fib3ZlRm9udCB8fCBwcm9wLnRleHRGb250LCBzaXplOiBwcm9wLmxhYmVsc0Fib3ZlU2l6ZSB8fCBwcm9wLnRleHRTaXplLCBib2xkOiBwcm9wLmxhYmVsc0Fib3ZlQm9sZCB8fCBwcm9wLnRleHRCb2xkLCBpdGFsaWM6IHByb3AubGFiZWxzQWJvdmVJdGFsaWMgfHwgcHJvcC50ZXh0SXRhbGljLCBjb2xvcjogcHJvcC5sYWJlbHNBYm92ZUNvbG9yIHx8IHByb3AudGV4dENvbG9yLCBiYWNrZ3JvdW5kOiBwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZCB8fCBudWxsLCBwYWRkaW5nOiBwcm9wLmxhYmVsc0Fib3ZlQmFja2dyb3VuZFBhZGRpbmcgfHwgMCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpICE9PSAnb24nKSB7XG4gICAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgIH1cbiAgICAgIFJHLlNWRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO3JldHVybiB0aGlzO1xuICAgIH07dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGZ1bmModGhpcyk7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBSRy5TVkcuUkVHLmdldCgnaGlnaGxpZ2h0Jyk7aWYgKGhpZ2hsaWdodCAmJiBoaWdobGlnaHQucGFyZW50Tm9kZSkge1xuICAgICAgICBoaWdobGlnaHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWdobGlnaHQpO1xuICAgICAgfVxuICAgICAgUkcuU1ZHLlJFRy5zZXQoJ2hpZ2hsaWdodCcsIG51bGwpO1xuICAgIH07dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwLFxuICAgICAgICAgIGZyYW1lID0gMCxcbiAgICAgICAgICBvYmogPSB0aGlzLFxuICAgICAgICAgIGRhdGEgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSBudWxsLFxuICAgICAgICAgIHNlcSA9IDA7cmV0dXJuIHRoaXM7XG4gICAgfTt0aGlzLndhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O2ZvciAoaSBpbiBjb25mLm9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgY29uZi5vcHRpb25zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07cmV0dXJuIHRoaXM7XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGguc3ZnLndhdGVyZmFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///219\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Thermometer = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext('2d') : null;this.canvas.__object__ = this;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.type = 'thermometer';this.isRGraph = true;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.coords = [];this.graphArea = [];this.currentValue = null;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.linewidth': 1, 'chart.background.color': 'white', 'chart.strokestyle': 'black', 'chart.colors': ['Gradient(#c00:red:#f66:#fcc)'], 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.ticksize': 2, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.size': 12, 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.numticks': 10, 'chart.units.pre': '', 'chart.units.post': '', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.title': '', 'chart.title.side': '', 'chart.title.side.bold': true, 'chart.title.side.font': null, 'chart.shadow': true, 'chart.shadow.offsetx': 0, 'chart.shadow.offsety': 0, 'chart.shadow.blur': 15, 'chart.shadow.color': '#ddd', 'chart.resizable': false, 'chart.contextmenu': null, 'chart.adjustable': false, 'chart.value.label': true, 'chart.value.label.decimals': null, 'chart.value.label.thousand': ',', 'chart.value.label.point': '.', 'chart.labels.count': 5, 'chart.scale.visible': false, 'chart.scale.decimals': 0, 'chart.annotatable': false, 'chart.annotate.color': 'black' }, _defineProperty(_properties, 'chart.scale.decimals', 0), _defineProperty(_properties, 'chart.scale.point', '.'), _defineProperty(_properties, 'chart.scale.thousand', ','), _defineProperty(_properties, 'chart.tooltips', null), _defineProperty(_properties, 'chart.tooltips.highlight', true), _defineProperty(_properties, 'chart.tooltips.effect', 'fade'), _defineProperty(_properties, 'chart.tooltips.event', 'onclick'), _defineProperty(_properties, 'chart.highlight.stroke', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.highlight.fill', 'rgba(255,255,255,0.7)'), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _defineProperty(_properties, 'chart.bulb.bottom.radius.adjust', 0), _defineProperty(_properties, 'chart.bulb.bottom.radius', null), _properties);\n  if (!this.canvas) {\n    alert('[THERMOMETER] No canvas support');return;\n  }\n  this.$0 = {};if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.ylabels.count') {\n      name = 'chart.labels.count';\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name];\n  };this.draw = this.Draw = function () {\n    RG.fireCustomEvent(this, 'onbeforedraw');this.value = ma.min(this.max, this.value);this.value = ma.max(this.min, this.value);if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.coordsText = [];this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.scale2 = RG.getScale2(this, { max: this.max, min: this.min, strict: true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });this.x = this.gutterLeft;this.width = ca.width - this.gutterLeft - this.gutterRight;this.y = this.gutterTop + this.width / 2;this.halfWidth = this.width / 2;this.bulbTopCenterx = this.gutterLeft + this.width / 2;this.bulbTopCentery = this.gutterTop + this.width / 2;this.bulbTopRadius = this.width / 2;this.bulbBottomCenterx = this.gutterLeft + this.width / 2;this.bulbBottomRadius = typeof prop['chart.bulb.bottom.radius'] === 'number' ? prop['chart.bulb.bottom.radius'] : this.width * 0.75 + prop['chart.bulb.bottom.radius.adjust'];this.bulbBottomCentery = ca.height - this.gutterBottom - this.bulbBottomRadius;this.scaleTopY = this.bulbTopCentery;this.scaleBottomY = this.bulbBottomCentery - this.bulbBottomRadius;this.scaleHeight = this.scaleBottomY - this.scaleTopY;this.height = this.getYCoord(this.min) - this.getYCoord(this.value);this.coords[0] = [this.x, this.getYCoord(this.value), this.width, this.height];this.drawBackground();this.drawBar();this.drawTickMarks();this.drawLabels();if (prop['chart.title']) {\n      this.drawTitle();\n    }\n    if (prop['chart.title.side']) {\n      this.drawSideTitle();\n    }\n    if (prop['chart.resizable']) {\n      RG.allowResizing(this);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.showContext(this);\n    }\n    RG.installEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.fireCustomEvent(this, 'ondraw');return this;\n  };this.drawBackground = this.DrawBackground = function () {\n    if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    this.pathBackground();co.strokeStyle = prop['chart.strokestyle'];co.fillStyle = prop['chart.background.color'];co.lineWidth = 1 + prop['chart.linewidth'];co.stroke();co.fill();co.lineWidth = 1;\n  };this.drawBar = this.DrawBar = function () {\n    this.pathBar();pa2(co, 'f %', prop['chart.colors'][0]);\n  };this.pathBar = function () {\n    var barHeight = this.coords[0][3],\n        y = this.coords[0][1] + this.coords[0][3] - barHeight;\n    RG.noShadow(this);pa2(co, 'b r % % % % a % % % 0 6.28 false', this.coords[0][0], y, this.coords[0][2], this.bulbBottomCentery - y, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.pathBackground = function () {\n    pa2(this.context, 'b   r % % % %   a % % % 0 6.28 false   m % %   a % % % 0 6.28 false', this.x, this.scaleTopY, this.coords[0][2], this.bulbBottomCentery - this.scaleTopY, this.bulbTopCenterx, this.bulbTopCentery, this.bulbTopRadius, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomCenterx, this.bulbBottomCentery, this.bulbBottomRadius);\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    if (prop['chart.numticks']) {\n      var ticksize = prop['chart.ticksize'];co.strokeStyle = prop['chart.strokestyle'];co.lineWidth = prop['chart.linewidth'] / 2;co.beginPath();for (var i = 0; i <= prop['chart.numticks']; ++i) {\n        var y = this.scaleBottomY - this.scaleHeight / prop['chart.numticks'] * i;co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft + ticksize, ma.round(y));co.moveTo(ca.width - this.gutterRight, ma.round(y));co.lineTo(ca.width - this.gutterRight - ticksize, ma.round(y));\n      }\n      co.stroke();co.lineWidth = 1;\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (prop['chart.value.label']) {\n      co.fillStyle = prop['chart.text.color'];var text = prop['chart.scale.visible'] ? RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals'])) : RG.numberFormat(this, this.value.toFixed(typeof prop['chart.value.label.decimals'] == 'number' ? prop['chart.value.label.decimals'] : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']);RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'], x: this.coords[0][0] + this.coords[0][2] / 2, y: this.coords[0][1] + 7, text: text, valign: 'top', halign: 'center', bounding: true, boundingFill: 'white', tag: 'value.label' });\n    }\n    if (prop['chart.scale.visible']) {\n      this.drawScale();\n    }\n  };this.drawTitle = this.DrawTitle = function () {\n    co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: prop['chart.text.font'], size: prop['chart.text.size'] + 2, x: this.gutterLeft + this.width / 2, y: this.gutterTop - 3, text: String(prop['chart.title']), valign: 'bottom', halign: 'center', bold: true, tag: 'title' });\n  };this.drawSideTitle = this.DrawSideTitle = function () {\n    var font = prop['chart.title.side.font'] ? prop['chart.title.side.font'] : prop['chart.text.font'];var size = prop['chart.title.side.size'] ? prop['chart.title.side.size'] : prop['chart.text.size'] + 2;co.fillStyle = prop['chart.text.color'];RG.text2(this, { font: font, size: size + 2, x: this.gutterLeft - 3, y: this.scaleHeight / 2 + this.gutterTop + this.bulbTopRadius, text: String(prop['chart.title.side']), valign: 'bottom', halign: 'center', angle: 270, bold: prop['chart.title.side.bold'], tag: 'title.side', accessible: false });\n  };this.drawScale = this.DrawScale = function () {\n    co.fillStyle = prop['chart.text.color'];var font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        decimals = prop['chart.scale.decimals'],\n        numLabels = prop['chart.labels.count'],\n        step = (this.max - this.min) / numLabels;for (var i = 1; i <= numLabels; ++i) {\n      var x = ca.width - this.gutterRight + prop['chart.linewidth'] / 2,\n          y = ca.height - this.gutterBottom - 2 * this.bulbBottomRadius - this.scaleHeight / numLabels * i,\n          text = RG.numberFormat(this, String((this.min + i * step).toFixed(decimals)), units_pre, units_post);RG.text2(this, { font: font, size: size, x: x + 6, y: y, text: text, valign: 'center', tag: 'scale' });\n    }\n    RG.text2(this, { font: font, size: size, x: x + 6, y: this.bulbBottomCentery - this.bulbBottomRadius, text: RG.numberFormat(this, this.min.toFixed(decimals), units_pre, units_post), valign: 'center', tag: 'scale' });\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];for (var i = 0; i < this.coords.length; i++) {\n      var coords = this.coords[i],\n          left = coords[0],\n          top = coords[1],\n          width = coords[2],\n          height = coords[3];this.pathBar();if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : '';return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getValue = function (arg) {\n    if (arg.length === 2) {\n      var mouseX = arg[0],\n          mouseY = arg[1];\n    } else {\n      var mouseXY = RG.getMouseXY(arg),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];\n    }\n    var value = (this.scaleHeight - (mouseY - this.scaleTopY)) / this.scaleHeight;value *= this.max - this.min;value += this.min;value = ma.max(value, this.min);value = ma.min(value, this.max);return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (prop['chart.tooltips.highlight']) {\n      if (typeof prop['chart.highlight.style'] === 'function') {\n        prop['chart.highlight.style'](shape);return;\n      }\n      this.pathBar();pa2(co, 's % f %', prop['chart.highlight.stroke'], prop['chart.highlight.fill']);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    this.pathBackground();if (co.isPointInPath(mouseX, mouseY)) {\n      return this;\n    }\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e),\n          value = this.getValue(e);if (typeof value == 'number') {\n        RG.fireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.redrawCanvas(ca);\n      }\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var y = ma.abs(value - this.min) / ma.abs(this.max - this.min);\n    y = y * (this.scaleBottomY - this.scaleTopY);return this.scaleBottomY - y;\n  };this.overChartArea = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];this.pathBackground();return co.isPointInPath(mouseX, mouseY);\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.arrayClone(prop['chart.colors']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0; i < colors.length; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color) {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(prop['chart.gutter.left'], 0, ca.width - prop['chart.gutter.right'], 0);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1; j < parts.length; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var obj = this,\n        callback = arguments[1] || function () {},\n        opt = arguments[0] || {},\n        frames = opt.frames ? opt.frames : 30,\n        origValue = Number(obj.currentValue),\n        newValue = obj.value;newValue = ma.min(newValue, this.max);newValue = ma.max(newValue, this.min);var diff = newValue - origValue,\n        step = diff / frames,\n        frame = 0;function iterate() {\n      obj.value = step * frame + origValue;RG.clear(obj.canvas);RG.redrawCanvas(obj.canvas);if (frame < frames) {\n        frame++;RG.Effects.updateCanvas(iterate);\n      } else {\n        callback(obj);\n      }\n    }\n    iterate();return this;\n  };RG.register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC50aGVybW9tZXRlci5qcz9jMDkyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuUkdyYXBoID0gd2luZG93LlJHcmFwaCB8fCB7IGlzUkdyYXBoOiB0cnVlIH07UkdyYXBoLlRoZXJtb21ldGVyID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgdmFyIF9wcm9wZXJ0aWVzO1xuXG4gIGlmICgodHlwZW9mIGNvbmYgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmYpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbmYuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb25mID0geyBpZDogYXJndW1lbnRzWzBdLCBtaW46IGFyZ3VtZW50c1sxXSwgbWF4OiBhcmd1bWVudHNbMl0sIHZhbHVlOiBhcmd1bWVudHNbM10gfTtcbiAgfVxuICB0aGlzLmlkID0gY29uZi5pZDt0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO3RoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQgPyB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDt0aGlzLmNhbnZhcy5fX29iamVjdF9fID0gdGhpczt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLnR5cGUgPSAndGhlcm1vbWV0ZXInO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMubWluID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5taW4pO3RoaXMubWF4ID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5tYXgpO3RoaXMudmFsdWUgPSBSR3JhcGguc3RyaW5nc1RvTnVtYmVycyhjb25mLnZhbHVlKTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuZ3JhcGhBcmVhID0gW107dGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMucHJvcGVydGllcyA9IChfcHJvcGVydGllcyA9IHsgJ2NoYXJ0LmxpbmV3aWR0aCc6IDEsICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzogJ3doaXRlJywgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJ2JsYWNrJywgJ2NoYXJ0LmNvbG9ycyc6IFsnR3JhZGllbnQoI2MwMDpyZWQ6I2Y2NjojZmNjKSddLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQudGlja3NpemUnOiAyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5vdmVyZmxvdyc6ICd2aXNpYmxlJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZS5wb2ludGVyZXZlbnRzJzogdHJ1ZSwgJ2NoYXJ0Lm51bXRpY2tzJzogMTAsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0Lnpvb20uZmFjdG9yJzogMS41LCAnY2hhcnQuem9vbS5mYWRlLmluJzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uZmFkZS5vdXQnOiB0cnVlLCAnY2hhcnQuem9vbS5oZGlyJzogJ3JpZ2h0JywgJ2NoYXJ0Lnpvb20udmRpcic6ICdkb3duJywgJ2NoYXJ0Lnpvb20uZnJhbWVzJzogMjUsICdjaGFydC56b29tLmRlbGF5JzogMTYuNjY2LCAnY2hhcnQuem9vbS5zaGFkb3cnOiB0cnVlLCAnY2hhcnQuem9vbS5iYWNrZ3JvdW5kJzogdHJ1ZSwgJ2NoYXJ0LnRpdGxlJzogJycsICdjaGFydC50aXRsZS5zaWRlJzogJycsICdjaGFydC50aXRsZS5zaWRlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuc2lkZS5mb250JzogbnVsbCwgJ2NoYXJ0LnNoYWRvdyc6IHRydWUsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDAsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDAsICdjaGFydC5zaGFkb3cuYmx1cic6IDE1LCAnY2hhcnQuc2hhZG93LmNvbG9yJzogJyNkZGQnLCAnY2hhcnQucmVzaXphYmxlJzogZmFsc2UsICdjaGFydC5jb250ZXh0bWVudSc6IG51bGwsICdjaGFydC5hZGp1c3RhYmxlJzogZmFsc2UsICdjaGFydC52YWx1ZS5sYWJlbCc6IHRydWUsICdjaGFydC52YWx1ZS5sYWJlbC5kZWNpbWFscyc6IG51bGwsICdjaGFydC52YWx1ZS5sYWJlbC50aG91c2FuZCc6ICcsJywgJ2NoYXJ0LnZhbHVlLmxhYmVsLnBvaW50JzogJy4nLCAnY2hhcnQubGFiZWxzLmNvdW50JzogNSwgJ2NoYXJ0LnNjYWxlLnZpc2libGUnOiBmYWxzZSwgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycgfSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuc2NhbGUuZGVjaW1hbHMnLCAwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuc2NhbGUucG9pbnQnLCAnLicpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5zY2FsZS50aG91c2FuZCcsICcsJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcy5lZmZlY3QnLCAnZmFkZScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b29sdGlwcy5ldmVudCcsICdvbmNsaWNrJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnLCAncmdiYSgwLDAsMCwwKScpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5oaWdobGlnaHQuZmlsbCcsICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuY2xlYXJ0bycsICdyZ2JhKDAsMCwwLDApJyksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmJ1bGIuYm90dG9tLnJhZGl1cy5hZGp1c3QnLCAwKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYnVsYi5ib3R0b20ucmFkaXVzJywgbnVsbCksIF9wcm9wZXJ0aWVzKTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbVEhFUk1PTUVURVJdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHRoaXMuJDAgPSB7fTtpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogYXJndW1lbnRzWzFdO2lmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBuYW1lKTtyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PSAnY2hhcnQueWxhYmVscy5jb3VudCcpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQubGFiZWxzLmNvdW50JztcbiAgICB9XG4gICAgcHJvcFtuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7cmV0dXJuIHRoaXM7XG4gIH07dGhpcy5nZXQgPSB0aGlzLkdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIDYpICE9ICdjaGFydC4nKSB7XG4gICAgICBuYW1lID0gJ2NoYXJ0LicgKyBuYW1lO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFtuYW1lXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmJlZm9yZWRyYXcnKTt0aGlzLnZhbHVlID0gbWEubWluKHRoaXMubWF4LCB0aGlzLnZhbHVlKTt0aGlzLnZhbHVlID0gbWEubWF4KHRoaXMubWluLCB0aGlzLnZhbHVlKTtpZiAoIXRoaXMuY29sb3JzUGFyc2VkKSB7XG4gICAgICB0aGlzLnBhcnNlQ29sb3JzKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyBtYXg6IHRoaXMubWF4LCBtaW46IHRoaXMubWluLCBzdHJpY3Q6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7dGhpcy54ID0gdGhpcy5ndXR0ZXJMZWZ0O3RoaXMud2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dGhpcy55ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLndpZHRoIC8gMjt0aGlzLmhhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyO3RoaXMuYnVsYlRvcENlbnRlcnggPSB0aGlzLmd1dHRlckxlZnQgKyB0aGlzLndpZHRoIC8gMjt0aGlzLmJ1bGJUb3BDZW50ZXJ5ID0gdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLndpZHRoIC8gMjt0aGlzLmJ1bGJUb3BSYWRpdXMgPSB0aGlzLndpZHRoIC8gMjt0aGlzLmJ1bGJCb3R0b21DZW50ZXJ4ID0gdGhpcy5ndXR0ZXJMZWZ0ICsgdGhpcy53aWR0aCAvIDI7dGhpcy5idWxiQm90dG9tUmFkaXVzID0gdHlwZW9mIHByb3BbJ2NoYXJ0LmJ1bGIuYm90dG9tLnJhZGl1cyddID09PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LmJ1bGIuYm90dG9tLnJhZGl1cyddIDogdGhpcy53aWR0aCAqIDAuNzUgKyBwcm9wWydjaGFydC5idWxiLmJvdHRvbS5yYWRpdXMuYWRqdXN0J107dGhpcy5idWxiQm90dG9tQ2VudGVyeSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gdGhpcy5idWxiQm90dG9tUmFkaXVzO3RoaXMuc2NhbGVUb3BZID0gdGhpcy5idWxiVG9wQ2VudGVyeTt0aGlzLnNjYWxlQm90dG9tWSA9IHRoaXMuYnVsYkJvdHRvbUNlbnRlcnkgLSB0aGlzLmJ1bGJCb3R0b21SYWRpdXM7dGhpcy5zY2FsZUhlaWdodCA9IHRoaXMuc2NhbGVCb3R0b21ZIC0gdGhpcy5zY2FsZVRvcFk7dGhpcy5oZWlnaHQgPSB0aGlzLmdldFlDb29yZCh0aGlzLm1pbikgLSB0aGlzLmdldFlDb29yZCh0aGlzLnZhbHVlKTt0aGlzLmNvb3Jkc1swXSA9IFt0aGlzLngsIHRoaXMuZ2V0WUNvb3JkKHRoaXMudmFsdWUpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07dGhpcy5kcmF3QmFja2dyb3VuZCgpO3RoaXMuZHJhd0JhcigpO3RoaXMuZHJhd1RpY2tNYXJrcygpO3RoaXMuZHJhd0xhYmVscygpO2lmIChwcm9wWydjaGFydC50aXRsZSddKSB7XG4gICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQudGl0bGUuc2lkZSddKSB7XG4gICAgICB0aGlzLmRyYXdTaWRlVGl0bGUoKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5hbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuY29udGV4dG1lbnUnXSkge1xuICAgICAgUkcuc2hvd0NvbnRleHQodGhpcyk7XG4gICAgfVxuICAgIFJHLmluc3RhbGxFdmVudExpc3RlbmVycyh0aGlzKTtpZiAodGhpcy5maXJzdERyYXcpIHtcbiAgICAgIFJHLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25maXJzdGRyYXcnKTt0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO3RoaXMuZmlyc3REcmF3RnVuYygpO1xuICAgIH1cbiAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZHJhdycpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZHJhd0JhY2tncm91bmQgPSB0aGlzLkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgUkcuc2V0U2hhZG93KHRoaXMsIHByb3BbJ2NoYXJ0LnNoYWRvdy5jb2xvciddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eCddLCBwcm9wWydjaGFydC5zaGFkb3cub2Zmc2V0eSddLCBwcm9wWydjaGFydC5zaGFkb3cuYmx1ciddKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoQmFja2dyb3VuZCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28ubGluZVdpZHRoID0gMSArIHByb3BbJ2NoYXJ0LmxpbmV3aWR0aCddO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTtjby5saW5lV2lkdGggPSAxO1xuICB9O3RoaXMuZHJhd0JhciA9IHRoaXMuRHJhd0JhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhdGhCYXIoKTtwYTIoY28sICdmICUnLCBwcm9wWydjaGFydC5jb2xvcnMnXVswXSk7XG4gIH07dGhpcy5wYXRoQmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYXJIZWlnaHQgPSB0aGlzLmNvb3Jkc1swXVszXSxcbiAgICAgICAgeSA9IHRoaXMuY29vcmRzWzBdWzFdICsgdGhpcy5jb29yZHNbMF1bM10gLSBiYXJIZWlnaHQ7XG4gICAgUkcubm9TaGFkb3codGhpcyk7cGEyKGNvLCAnYiByICUgJSAlICUgYSAlICUgJSAwIDYuMjggZmFsc2UnLCB0aGlzLmNvb3Jkc1swXVswXSwgeSwgdGhpcy5jb29yZHNbMF1bMl0sIHRoaXMuYnVsYkJvdHRvbUNlbnRlcnkgLSB5LCB0aGlzLmJ1bGJCb3R0b21DZW50ZXJ4LCB0aGlzLmJ1bGJCb3R0b21DZW50ZXJ5LCB0aGlzLmJ1bGJCb3R0b21SYWRpdXMpO1xuICB9O3RoaXMucGF0aEJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGEyKHRoaXMuY29udGV4dCwgJ2IgICByICUgJSAlICUgICBhICUgJSAlIDAgNi4yOCBmYWxzZSAgIG0gJSAlICAgYSAlICUgJSAwIDYuMjggZmFsc2UnLCB0aGlzLngsIHRoaXMuc2NhbGVUb3BZLCB0aGlzLmNvb3Jkc1swXVsyXSwgdGhpcy5idWxiQm90dG9tQ2VudGVyeSAtIHRoaXMuc2NhbGVUb3BZLCB0aGlzLmJ1bGJUb3BDZW50ZXJ4LCB0aGlzLmJ1bGJUb3BDZW50ZXJ5LCB0aGlzLmJ1bGJUb3BSYWRpdXMsIHRoaXMuYnVsYkJvdHRvbUNlbnRlcngsIHRoaXMuYnVsYkJvdHRvbUNlbnRlcnksIHRoaXMuYnVsYkJvdHRvbUNlbnRlcngsIHRoaXMuYnVsYkJvdHRvbUNlbnRlcnksIHRoaXMuYnVsYkJvdHRvbVJhZGl1cyk7XG4gIH07dGhpcy5kcmF3VGlja01hcmtzID0gdGhpcy5EcmF3VGlja01hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wWydjaGFydC5udW10aWNrcyddKSB7XG4gICAgICB2YXIgdGlja3NpemUgPSBwcm9wWydjaGFydC50aWNrc2l6ZSddO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXTtjby5saW5lV2lkdGggPSBwcm9wWydjaGFydC5saW5ld2lkdGgnXSAvIDI7Y28uYmVnaW5QYXRoKCk7Zm9yICh2YXIgaSA9IDA7IGkgPD0gcHJvcFsnY2hhcnQubnVtdGlja3MnXTsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5zY2FsZUJvdHRvbVkgLSB0aGlzLnNjYWxlSGVpZ2h0IC8gcHJvcFsnY2hhcnQubnVtdGlja3MnXSAqIGk7Y28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQoeSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQgKyB0aWNrc2l6ZSwgbWEucm91bmQoeSkpO2NvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIG1hLnJvdW5kKHkpKTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0IC0gdGlja3NpemUsIG1hLnJvdW5kKHkpKTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO2NvLmxpbmVXaWR0aCA9IDE7XG4gICAgfVxuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQudmFsdWUubGFiZWwnXSkge1xuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciB0ZXh0ID0gcHJvcFsnY2hhcnQuc2NhbGUudmlzaWJsZSddID8gUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMudmFsdWUudG9GaXhlZCh0eXBlb2YgcHJvcFsnY2hhcnQudmFsdWUubGFiZWwuZGVjaW1hbHMnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LnZhbHVlLmxhYmVsLmRlY2ltYWxzJ10gOiBwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSkgOiBSRy5udW1iZXJGb3JtYXQodGhpcywgdGhpcy52YWx1ZS50b0ZpeGVkKHR5cGVvZiBwcm9wWydjaGFydC52YWx1ZS5sYWJlbC5kZWNpbWFscyddID09ICdudW1iZXInID8gcHJvcFsnY2hhcnQudmFsdWUubGFiZWwuZGVjaW1hbHMnXSA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pLCBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgcHJvcFsnY2hhcnQudW5pdHMucG9zdCddKTtSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBzaXplOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSwgeDogdGhpcy5jb29yZHNbMF1bMF0gKyB0aGlzLmNvb3Jkc1swXVsyXSAvIDIsIHk6IHRoaXMuY29vcmRzWzBdWzFdICsgNywgdGV4dDogdGV4dCwgdmFsaWduOiAndG9wJywgaGFsaWduOiAnY2VudGVyJywgYm91bmRpbmc6IHRydWUsIGJvdW5kaW5nRmlsbDogJ3doaXRlJywgdGFnOiAndmFsdWUubGFiZWwnIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuc2NhbGUudmlzaWJsZSddKSB7XG4gICAgICB0aGlzLmRyYXdTY2FsZSgpO1xuICAgIH1cbiAgfTt0aGlzLmRyYXdUaXRsZSA9IHRoaXMuRHJhd1RpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXTtSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHByb3BbJ2NoYXJ0LnRleHQuZm9udCddLCBzaXplOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSArIDIsIHg6IHRoaXMuZ3V0dGVyTGVmdCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLmd1dHRlclRvcCAtIDMsIHRleHQ6IFN0cmluZyhwcm9wWydjaGFydC50aXRsZSddKSwgdmFsaWduOiAnYm90dG9tJywgaGFsaWduOiAnY2VudGVyJywgYm9sZDogdHJ1ZSwgdGFnOiAndGl0bGUnIH0pO1xuICB9O3RoaXMuZHJhd1NpZGVUaXRsZSA9IHRoaXMuRHJhd1NpZGVUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9udCA9IHByb3BbJ2NoYXJ0LnRpdGxlLnNpZGUuZm9udCddID8gcHJvcFsnY2hhcnQudGl0bGUuc2lkZS5mb250J10gOiBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnNpZGUuc2l6ZSddID8gcHJvcFsnY2hhcnQudGl0bGUuc2lkZS5zaXplJ10gOiBwcm9wWydjaGFydC50ZXh0LnNpemUnXSArIDI7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO1JHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSArIDIsIHg6IHRoaXMuZ3V0dGVyTGVmdCAtIDMsIHk6IHRoaXMuc2NhbGVIZWlnaHQgLyAyICsgdGhpcy5ndXR0ZXJUb3AgKyB0aGlzLmJ1bGJUb3BSYWRpdXMsIHRleHQ6IFN0cmluZyhwcm9wWydjaGFydC50aXRsZS5zaWRlJ10pLCB2YWxpZ246ICdib3R0b20nLCBoYWxpZ246ICdjZW50ZXInLCBhbmdsZTogMjcwLCBib2xkOiBwcm9wWydjaGFydC50aXRsZS5zaWRlLmJvbGQnXSwgdGFnOiAndGl0bGUuc2lkZScsIGFjY2Vzc2libGU6IGZhbHNlIH0pO1xuICB9O3RoaXMuZHJhd1NjYWxlID0gdGhpcy5EcmF3U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J10sXG4gICAgICAgIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXSxcbiAgICAgICAgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sXG4gICAgICAgIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J10sXG4gICAgICAgIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSxcbiAgICAgICAgbnVtTGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sXG4gICAgICAgIHN0ZXAgPSAodGhpcy5tYXggLSB0aGlzLm1pbikgLyBudW1MYWJlbHM7Zm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtTGFiZWxzOyArK2kpIHtcbiAgICAgIHZhciB4ID0gY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgcHJvcFsnY2hhcnQubGluZXdpZHRoJ10gLyAyLFxuICAgICAgICAgIHkgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSAtIDIgKiB0aGlzLmJ1bGJCb3R0b21SYWRpdXMgLSB0aGlzLnNjYWxlSGVpZ2h0IC8gbnVtTGFiZWxzICogaSxcbiAgICAgICAgICB0ZXh0ID0gUkcubnVtYmVyRm9ybWF0KHRoaXMsIFN0cmluZygodGhpcy5taW4gKyBpICogc3RlcCkudG9GaXhlZChkZWNpbWFscykpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpO1JHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogeCArIDYsIHk6IHksIHRleHQ6IHRleHQsIHZhbGlnbjogJ2NlbnRlcicsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICB9XG4gICAgUkcudGV4dDIodGhpcywgeyBmb250OiBmb250LCBzaXplOiBzaXplLCB4OiB4ICsgNiwgeTogdGhpcy5idWxiQm90dG9tQ2VudGVyeSAtIHRoaXMuYnVsYkJvdHRvbVJhZGl1cywgdGV4dDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMubWluLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCB2YWxpZ246ICdjZW50ZXInLCB0YWc6ICdzY2FsZScgfSk7XG4gIH07dGhpcy5nZXRTaGFwZSA9IHRoaXMuZ2V0QmFyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRzW2ldLFxuICAgICAgICAgIGxlZnQgPSBjb29yZHNbMF0sXG4gICAgICAgICAgdG9wID0gY29vcmRzWzFdLFxuICAgICAgICAgIHdpZHRoID0gY29vcmRzWzJdLFxuICAgICAgICAgIGhlaWdodCA9IGNvb3Jkc1szXTt0aGlzLnBhdGhCYXIoKTtpZiAoY28uaXNQb2ludEluUGF0aChtb3VzZVgsIG1vdXNlWSkpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0ID8gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCBpKSA6ICcnO3JldHVybiB7IDA6IHRoaXMsIG9iamVjdDogdGhpcywgMTogbGVmdCwgeDogbGVmdCwgMjogdG9wLCB5OiB0b3AsIDM6IHdpZHRoLCB3aWR0aDogd2lkdGgsIDQ6IGhlaWdodCwgaGVpZ2h0OiBoZWlnaHQsIDU6IGksIGluZGV4OiBpLCB0b29sdGlwOiB0b29sdGlwIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGFyZy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBtb3VzZVggPSBhcmdbMF0sXG4gICAgICAgICAgbW91c2VZID0gYXJnWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoYXJnKSxcbiAgICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9ICh0aGlzLnNjYWxlSGVpZ2h0IC0gKG1vdXNlWSAtIHRoaXMuc2NhbGVUb3BZKSkgLyB0aGlzLnNjYWxlSGVpZ2h0O3ZhbHVlICo9IHRoaXMubWF4IC0gdGhpcy5taW47dmFsdWUgKz0gdGhpcy5taW47dmFsdWUgPSBtYS5tYXgodmFsdWUsIHRoaXMubWluKTt2YWx1ZSA9IG1hLm1pbih2YWx1ZSwgdGhpcy5tYXgpO3JldHVybiB2YWx1ZTtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnRvb2x0aXBzLmhpZ2hsaWdodCddKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtyZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGhCYXIoKTtwYTIoY28sICdzICUgZiAlJywgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddLCBwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWFlbMF0sXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWFlbMV07XG4gICAgdGhpcy5wYXRoQmFja2dyb3VuZCgpO2lmIChjby5pc1BvaW50SW5QYXRoKG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuYWRqdXN0aW5nX21vdXNlbW92ZSA9IHRoaXMuQWRqdXN0aW5nX21vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LmFkanVzdGFibGUnXSAmJiBSRy5SZWdpc3RyeS5nZXQoJ2NoYXJ0LmFkanVzdGluZycpICYmIFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykudWlkID09IHRoaXMudWlkKSB7XG4gICAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGUpO2lmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgUkcuZmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmFkanVzdCcpO3RoaXMudmFsdWUgPSBOdW1iZXIodmFsdWUudG9GaXhlZChwcm9wWydjaGFydC5zY2FsZS5kZWNpbWFscyddKSk7UkcucmVkcmF3Q2FudmFzKGNhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRZQ29vcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPiB0aGlzLm1heCB8fCB2YWx1ZSA8IHRoaXMubWluKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHkgPSBtYS5hYnModmFsdWUgLSB0aGlzLm1pbikgLyBtYS5hYnModGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgeSA9IHkgKiAodGhpcy5zY2FsZUJvdHRvbVkgLSB0aGlzLnNjYWxlVG9wWSk7cmV0dXJuIHRoaXMuc2NhbGVCb3R0b21ZIC0geTtcbiAgfTt0aGlzLm92ZXJDaGFydEFyZWEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKSxcbiAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgbW91c2VZID0gbW91c2VYWVsxXTt0aGlzLnBhdGhCYWNrZ3JvdW5kKCk7cmV0dXJuIGNvLmlzUG9pbnRJblBhdGgobW91c2VYLCBtb3VzZVkpO1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlDbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5jb2xvcnMnXTtmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29sb3JzW2ldID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQoY29sb3JzW2ldKTtcbiAgICB9XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5tYXRjaCgvXmdyYWRpZW50XFwoKC4qKVxcKSQvaSkpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFJlZ0V4cC4kMS5zcGxpdCgnOicpO3ZhciBncmFkID0gY28uY3JlYXRlTGluZWFyR3JhZGllbnQocHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXSwgMCwgY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXSwgMCk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGogKiBkaWZmLCBSRy50cmltKHBhcnRzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICB9O3RoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgZnVuYykge1xuICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSAhPT0gJ29uJykge1xuICAgICAgdHlwZSA9ICdvbicgKyB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXNbdHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbdHlwZV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5hZGRDdXN0b21FdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTt0aGlzLmZpcnN0RHJhd0Z1bmMgPSBmdW5jdGlvbiAoKSB7fTt0aGlzLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMsXG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGZyYW1lcyA9IG9wdC5mcmFtZXMgPyBvcHQuZnJhbWVzIDogMzAsXG4gICAgICAgIG9yaWdWYWx1ZSA9IE51bWJlcihvYmouY3VycmVudFZhbHVlKSxcbiAgICAgICAgbmV3VmFsdWUgPSBvYmoudmFsdWU7bmV3VmFsdWUgPSBtYS5taW4obmV3VmFsdWUsIHRoaXMubWF4KTtuZXdWYWx1ZSA9IG1hLm1heChuZXdWYWx1ZSwgdGhpcy5taW4pO3ZhciBkaWZmID0gbmV3VmFsdWUgLSBvcmlnVmFsdWUsXG4gICAgICAgIHN0ZXAgPSBkaWZmIC8gZnJhbWVzLFxuICAgICAgICBmcmFtZSA9IDA7ZnVuY3Rpb24gaXRlcmF0ZSgpIHtcbiAgICAgIG9iai52YWx1ZSA9IHN0ZXAgKiBmcmFtZSArIG9yaWdWYWx1ZTtSRy5jbGVhcihvYmouY2FudmFzKTtSRy5yZWRyYXdDYW52YXMob2JqLmNhbnZhcyk7aWYgKGZyYW1lIDwgZnJhbWVzKSB7XG4gICAgICAgIGZyYW1lKys7UkcuRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRlKCk7cmV0dXJuIHRoaXM7XG4gIH07UkcucmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnRoZXJtb21ldGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///220\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.VProgress = function (conf) {\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: arguments[0], min: arguments[1], max: arguments[2], value: arguments[3] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext('2d');this.canvas.__object__ = this;this.min = RGraph.stringsToNumbers(conf.min);this.max = RGraph.stringsToNumbers(conf.max);this.value = RGraph.stringsToNumbers(conf.value);this.type = 'vprogress';this.coords = [];this.isRGraph = true;this.currentValue = null;this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = { 'chart.colors': ['Gradient(white:#0c0)', 'Gradient(white:red)', 'Gradient(white:green)', 'yellow', 'pink', 'cyan', 'black', 'white', 'gray'], 'chart.strokestyle.inner': '#999', 'chart.strokestyle.outer': '#999', 'chart.tickmarks': true, 'chart.tickmarks.zerostart': true, 'chart.tickmarks.color': '#999', 'chart.tickmarks.inner': false, 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.numticks': 10, 'chart.numticks.inner': 50, 'chart.background.color': 'Gradient(#ccc:#eee:#efefef)', 'chart.shadow': false, 'chart.shadow.color': 'rgba(0,0,0,0.5)', 'chart.shadow.blur': 3, 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.title': '', 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.size': null, 'chart.title.color': 'black', 'chart.title.side': null, 'chart.title.side.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.title.side.size': 12, 'chart.title.side.color': 'black', 'chart.title.side.bold': true, 'chart.text.size': 12, 'chart.text.color': 'black', 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.highlight': true, 'chart.tooltips.event': 'onclick', 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.zoom.action': 'zoom', 'chart.arrows': false, 'chart.margin': 0, 'chart.resizable': false, 'chart.resize.handle.adjust': [0, 0], 'chart.resize.handle.background': null, 'chart.label.inner': false, 'chart.labels.count': 10, 'chart.labels.position': 'right', 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.adjustable': false, 'chart.scale.decimals': 0, 'chart.scale.thousand': ',', 'chart.scale.point': '.', 'chart.key': null, 'chart.key.background': 'white', 'chart.key.position': 'graph', 'chart.key.halign': 'right', 'chart.key.shadow': false, 'chart.key.shadow.color': '#666', 'chart.key.shadow.blur': 3, 'chart.key.shadow.offsetx': 2, 'chart.key.shadow.offsety': 2, 'chart.key.position.gutter.boxed': false, 'chart.key.position.x': null, 'chart.key.position.y': null, 'chart.key.color.shape': 'square', 'chart.key.rounded': true, 'chart.key.linewidth': 1, 'chart.key.colors': null, 'chart.key.interactive': false, 'chart.key.interactive.highlight.chart.stroke': '#000', 'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)', 'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)', 'chart.key.text.color': 'black', 'chart.events.click': null, 'chart.events.mousemove': null, 'chart.border.inner': true, 'chart.clearto': 'rgba(0,0,0,0)' };\n  if (!this.canvas) {\n    alert('[PROGRESS] No canvas support');return;\n  }\n  var linear_data = RGraph.arrayLinearize(this.value);for (var i = 0; i < linear_data.length; ++i) {\n    this['$' + i] = {};\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    if (name == 'chart.strokestyle') {\n      prop['chart.strokestyle.inner'] = value;prop['chart.strokestyle.outer'] = value;return;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RG.FireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    this.currentValue = this.value;this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.width = ca.width - this.gutterLeft - this.gutterRight;this.height = ca.height - this.gutterTop - this.gutterBottom;this.coords = [];this.coordsText = [];this.Drawbar();this.DrawTickMarks();this.DrawLabels();this.DrawTitles();if (prop['chart.bevel']) {\n      this.DrawBevel();\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    RG.InstallEventListeners(this);if (prop['chart.key'] && prop['chart.key'].length) {\n      RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    this.AllowAdjusting();if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawbar = this.Drawbar = function () {\n    this.scale2 = RG.getScale2(this, { 'max': this.max, 'min': this.min, 'strict': true, 'scale.thousand': prop['chart.scale.thousand'], 'scale.point': prop['chart.scale.point'], 'scale.decimals': prop['chart.scale.decimals'], 'ylabels.count': prop['chart.labels.count'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'] });if (prop['chart.shadow']) {\n      RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n    }\n    co.fillStyle = prop['chart.background.color'];co.strokeStyle = prop['chart.strokestyle.outer'];co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);RG.noShadow(this);co.strokeStyle = prop['chart.strokestyle.outer'];co.fillStyle = prop['chart.colors'][0];var margin = prop['chart.margin'];var barHeight = (ca.height - this.gutterTop - this.gutterBottom) * ((RG.arraySum(this.value) - this.min) / (this.max - this.min));if (typeof this.value === 'number') {\n      co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.inner'];if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, stroke: prop['chart.strokestyle.inner'] });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + (this.height - barHeight), width: this.width - margin - margin, height: barHeight, fill: prop['chart.colors'][0] });\n    } else if (_typeof(this.value) == 'object') {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];var startPoint = ca.height - this.gutterBottom;for (var i = 0, len = this.value.length; i < len; ++i) {\n        var segmentHeight = (this.value[i] - this.min) / (this.max - this.min) * (ca.height - this.gutterBottom - this.gutterTop);co.fillStyle = prop['chart.colors'][i];co.beginPath();if (prop['chart.border.inner']) {\n          this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, stroke: co.strokeStyle });\n        }\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: startPoint - segmentHeight, width: this.width - margin - margin, height: segmentHeight, fill: co.fillStyle });this.coords.push([this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight]);startPoint -= segmentHeight;\n      }\n      co.fill();\n    }\n    if (prop['chart.tickmarks.inner']) {\n      var spacing = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numticks.inner'];co.lineWidth = 1;co.strokeStyle = prop['chart.strokestyle.outer'];co.beginPath();for (var y = this.gutterTop; y < ca.height - this.gutterBottom; y += spacing) {\n        co.moveTo(this.gutterLeft, Math.round(y));co.lineTo(this.gutterLeft + 3, Math.round(y));co.moveTo(ca.width - this.gutterRight, Math.round(y));co.lineTo(ca.width - this.gutterRight - 3, Math.round(y));\n      }\n      co.stroke();\n    }\n    co.beginPath();co.strokeStyle = prop['chart.strokestyle.inner'];if (typeof this.value == 'number') {\n      if (prop['chart.border.inner']) {\n        this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });\n      }\n      this.drawCurvedBar({ x: this.gutterLeft + margin, y: this.gutterTop + this.height - barHeight, width: this.width - margin - margin, height: barHeight });this.coords.push([this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight]);\n    }\n    if (prop['chart.arrows']) {\n      var x = this.gutterLeft - 4;var y = ca.height - this.gutterBottom - barHeight;co.lineWidth = 1;co.fillStyle = 'black';co.strokeStyle = 'black';co.beginPath();co.moveTo(x, y);co.lineTo(x - 4, y - 2);co.lineTo(x - 4, y + 2);co.closePath();co.stroke();co.fill();x += this.width + 8;co.beginPath();co.moveTo(x, y);co.lineTo(x + 4, y - 2);co.lineTo(x + 4, y + 2);co.closePath();co.stroke();co.fill();pa2(co, 'b');\n    }\n    if (prop['chart.label.inner']) {\n      co.fillStyle = 'black';RG.text2(this, { 'font': prop['chart.text.font'], 'size': prop['chart.text.size'], 'x': (ca.width - this.gutterLeft - this.gutterRight) / 2 + this.gutterLeft, 'y': this.coords[this.coords.length - 1][1] - 5, 'text': RGraph.number_format(this, (typeof this.value == 'number' ? this.value : RG.array_sum(this.value)).toFixed(prop['chart.scale.decimals'])), 'valign': 'bottom', 'halign': 'center', 'bounding': true, 'boundingFill': 'white', 'tag': 'label.inner' });\n    }\n  };this.drawTickMarks = this.DrawTickMarks = function () {\n    co.strokeStyle = prop['chart.tickmarks.color'];if (prop['chart.tickmarks']) {\n      co.beginPath();for (var i = 0; prop['chart.tickmarks.zerostart'] ? i <= prop['chart.numticks'] : i < prop['chart.numticks']; i++) {\n        var startX = prop['chart.labels.position'] == 'left' ? this.gutterLeft : ca.width - prop['chart.gutter.right'];var endX = prop['chart.labels.position'] == 'left' ? startX - 4 : startX + 4;var yPos = this.height * (i / prop['chart.numticks']) + this.gutterTop;\n        co.moveTo(startX, ma.round(yPos));co.lineTo(endX, ma.round(yPos));\n      }\n      co.stroke();\n    }\n  };this.drawLabels = this.DrawLabels = function () {\n    if (!RG.is_null(prop['chart.labels.specific'])) {\n      return this.DrawSpecificLabels();\n    }\n    co.fillStyle = prop['chart.text.color'];var position = prop['chart.labels.position'].toLowerCase();var xAlignment = position == 'left' ? 'right' : 'left';var yAlignment = 'center';var count = prop['chart.labels.count'];var units_pre = prop['chart.units.pre'];var units_post = prop['chart.units.post'];var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var decimals = prop['chart.scale.decimals'];var offsetx = prop['chart.labels.offsetx'];var offsety = prop['chart.labels.offsety'];if (prop['chart.tickmarks']) {\n      for (var i = 0; i < count; ++i) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 7 + offsetx : ca.width - this.gutterRight + 7 + offsetx, y: (ca.height - this.gutterTop - this.gutterBottom) / count * i + this.gutterTop + offsety, text: this.scale2.labels[this.scale2.labels.length - (i + 1)], valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (prop['chart.tickmarks.zerostart'] && this.min == 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, 'text': RG.numberFormat(this, this.min.toFixed(this.min === 0 ? 0 : decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n      if (this.min != 0) {\n        RG.text2(this, { font: text_font, size: text_size, x: position == 'left' ? this.gutterLeft - 5 + offsetx : ca.width - this.gutterRight + 5 + offsetx, y: ca.height - this.gutterBottom + offsety, text: RG.number_format(this, this.min.toFixed(decimals), units_pre, units_post), valign: yAlignment, halign: xAlignment, tag: 'scale' });\n      }\n    }\n  };this.drawTitles = this.DrawTitles = function () {\n    var text_size = prop['chart.text.size'];var text_font = prop['chart.text.font'];var title_size = prop['chart.title.size'] ? prop['chart.title.size'] : text_size + 2;if (prop['chart.title'].length > 0) {\n      co.fillStyle = prop['chart.title.color'];RG.text2(this, { 'font': prop['chart.title.font'] ? prop['chart.title.font'] : text_font, 'size': title_size, 'x': this.gutterLeft + (ca.width - this.gutterLeft - this.gutterRight) / 2, 'y': this.gutterTop - 5, 'text': prop['chart.title'], 'valign': 'bottom', 'halign': 'center', 'bold': prop['chart.title.bold'], 'tag': 'title' });\n    }\n    if (typeof prop['chart.title.side'] == 'string') {\n      co.fillStyle = prop['chart.title.side.color'];RG.Text2(this, { 'font': prop['chart.title.side.font'], 'size': prop['chart.title.side.size'], 'x': prop['chart.labels.position'] == 'right' ? this.gutterLeft - 10 : ca.width - this.gutterRight + 10, 'y': this.gutterTop + this.height / 2, 'text': prop['chart.title.side'], 'valign': 'bottom', 'halign': 'center', 'angle': prop['chart.labels.position'] == 'right' ? 270 : 90, 'bold': prop['chart.title.side.bold'], 'tag': 'title.side' });\n    }\n  };this.getShape = this.getBar = function (e) {\n    var mouseXY = RG.getMouseXY(e),\n        mouseX = mouseXY[0],\n        mouseY = mouseXY[1];\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var x = this.coords[i][0],\n          y = this.coords[i][1],\n          w = this.coords[i][2],\n          h = this.coords[i][3],\n          idx = i;co.beginPath();this.drawCurvedBar({ x: x, y: y, width: w, height: h });if (co.isPointInPath(mouseX, mouseY)) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, 'object': this, 1: x, 'x': x, 2: y, 'y': y, 3: w, 'width': w, 4: h, 'height': h, 5: i, 'index': i, 'tooltip': tooltip };\n      }\n    }\n  };this.getValue = function (e) {\n    var mouseCoords = RG.getMouseXY(e);var mouseX = mouseCoords[0];var mouseY = mouseCoords[1];var value = (this.height - (mouseY - this.gutterTop)) / this.height;value *= this.max - this.min;value += this.min;if (value > this.max) value = this.max;if (value < this.min) value = this.min;return value;\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      var last = shape.index === this.coords.length - 1;this.drawCurvedBar({ x: shape.x, y: shape.y, width: shape.width, height: shape.height, stroke: prop['chart.highlight.stroke'], fill: prop['chart.highlight.fill'] });\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] >= this.gutterTop && mouseXY[1] <= ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.allowAdjusting = this.AllowAdjusting = function () {\n    return;\n  };this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {\n    if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\n      var mouseXY = RG.getMouseXY(e);var value = this.getValue(e);if (typeof value === 'number') {\n        RG.FireCustomEvent(this, 'onadjust');this.value = Number(value.toFixed(prop['chart.scale.decimals']));RG.RedrawCanvas(this.canvas);\n      }\n    }\n  };this.drawSpecificLabels = this.DrawSpecificLabels = function () {\n    var labels = prop['chart.labels.specific'];if (labels) {\n      var font = prop['chart.text.font'];var size = prop['chart.text.size'];var halign = prop['chart.labels.position'] == 'right' ? 'left' : 'right';var step = this.height / (labels.length - 1);co.beginPath();co.fillStyle = prop['chart.text.color'];for (var i = 0; i < labels.length; ++i) {\n        RG.Text2(this, { 'font': font, 'size': size, 'x': prop['chart.labels.position'] == 'right' ? ca.width - this.gutterRight + 7 : this.gutterLeft - 7, 'y': this.height + this.gutterTop - step * i, 'text': labels[i], 'valign': 'center', 'halign': halign, 'tag': 'labels.specific' });\n      }\n      co.fill();\n    }\n  };this.getYCoord = function (value) {\n    if (value > this.max || value < this.min) {\n      return null;\n    }\n    var barHeight = ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'];var coord = (value - this.min) / (this.max - this.min) * barHeight;coord = ca.height - coord - prop['chart.gutter.bottom'];return coord;\n  };this.overChartArea = function (e) {\n    var mouseXY = RGraph.getMouseXY(e);var mouseX = mouseXY[0];var mouseY = mouseXY[1];if (mouseX >= this.gutterLeft && mouseX <= ca.width - this.gutterRight && mouseY >= this.gutterTop && mouseY <= ca.height - this.gutterBottom) {\n      return true;\n    }\n    return false;\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.tickmarks.color'] = RG.array_clone(prop['chart.tickmarks.color']);this.original_colors['chart.strokestyle.inner'] = RG.array_clone(prop['chart.strokestyle.inner']);this.original_colors['chart.strokestyle.outer'] = RG.array_clone(prop['chart.strokestyle.outer']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.color'] = RG.array_clone(prop['chart.highlight.color']);\n    }\n    var colors = prop['chart.colors'];for (var i = 0, len = colors.length; i < len; ++i) {\n      colors[i] = this.parseSingleColorForGradient(colors[i]);\n    }\n    prop['chart.tickmarks.color'] = this.parseSingleColorForGradient(prop['chart.tickmarks.color']);prop['chart.strokestyle.inner'] = this.parseSingleColorForGradient(prop['chart.strokestyle.inner']);prop['chart.strokestyle.outer'] = this.parseSingleColorForGradient(prop['chart.strokestyle.outer']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n      return grad ? grad : color;\n    }\n    return grad ? grad : color;\n  };this.drawBevel = this.DrawBevel = function () {\n    for (var i = 0, height = 0; i < this.coords.length; ++i) {\n      height += this.coords[i][3];\n    }\n    co.save();co.beginPath();co.rect(this.coords[0][0], this.coords[this.coords.length - 1][1] - 1, this.coords[0][2], height);co.clip();co.save();co.beginPath();this.drawCurvedBar({ x: this.coords[0][0], y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2], height: height });co.clip();co.beginPath();co.shadowColor = 'black';co.shadowOffsetX = 0;co.shadowOffsetY = 0;co.shadowBlur = 15;co.lineWidth = 2;this.drawCurvedBar({ x: this.coords[0][0] - 1, y: this.coords[this.coords.length - 1][1] - 1, width: this.coords[0][2] + 2, height: height + 2 + 100 });co.stroke();co.restore();co.restore();\n  };this.interactiveKeyHighlight = function (index) {\n    var coords = this.coords[index];co.beginPath();co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];co.lineWidth = 2;co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];co.rect(coords[0], coords[1], coords[2], coords[3]);co.fill();co.stroke();co.lineWidth = 1;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.drawCurvedBar = function (opt) {\n    pa2(co, 'b r % % % %', opt.x, opt.y, opt.width, opt.height);if (opt.stroke) {\n      co.strokeStyle = opt.stroke;co.stroke();\n    }\n    if (opt.fill) {\n      co.fillStyle = opt.fill;co.fill();\n    }\n  };\n  this.firstDrawFunc = function () {};this.exec = function (func) {\n    func(this);return this;\n  };this.grow = function () {\n    var obj = this;var canvas = obj.canvas;var context = obj.context;var initial_value = obj.currentValue;var opt = arguments[0] || {};var numFrames = opt.frames || 30;var frame = 0;\n    var callback = arguments[1] || function () {};if (_typeof(obj.value) === 'object') {\n      if (RGraph.is_null(obj.currentValue)) {\n        obj.currentValue = [];for (var i = 0; i < obj.value.length; ++i) {\n          obj.currentValue[i] = 0;\n        }\n      }\n      var diff = [];var increment = [];for (var i = 0; i < obj.value.length; ++i) {\n        diff[i] = obj.value[i] - Number(obj.currentValue[i]);increment[i] = diff[i] / numFrames;\n      }\n      if (initial_value == null) {\n        initial_value = [];for (var i = 0; i < obj.value.length; ++i) {\n          initial_value[i] = 0;\n        }\n      }\n    } else {\n      var diff = obj.value - Number(obj.currentValue);var increment = diff / numFrames;\n    }\n    function iterator() {\n      frame++;if (frame <= numFrames) {\n        if (_typeof(obj.value) == 'object') {\n          obj.value = [];for (var i = 0; i < initial_value.length; ++i) {\n            obj.value[i] = initial_value[i] + increment[i] * frame;\n          }\n        } else {\n          obj.value = initial_value + increment * frame;\n        }\n        RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback();\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC52cHJvZ3Jlc3MuanM/Y2JmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5WUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY29uZikge1xuICBpZiAoKHR5cGVvZiBjb25mID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25mKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29uZiA9IHsgaWQ6IGFyZ3VtZW50c1swXSwgbWluOiBhcmd1bWVudHNbMV0sIG1heDogYXJndW1lbnRzWzJdLCB2YWx1ZTogYXJndW1lbnRzWzNdIH07XG4gIH1cbiAgdGhpcy5pZCA9IGNvbmYuaWQ7dGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTt0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO3RoaXMuY2FudmFzLl9fb2JqZWN0X18gPSB0aGlzO3RoaXMubWluID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5taW4pO3RoaXMubWF4ID0gUkdyYXBoLnN0cmluZ3NUb051bWJlcnMoY29uZi5tYXgpO3RoaXMudmFsdWUgPSBSR3JhcGguc3RyaW5nc1RvTnVtYmVycyhjb25mLnZhbHVlKTt0aGlzLnR5cGUgPSAndnByb2dyZXNzJzt0aGlzLmNvb3JkcyA9IFtdO3RoaXMuaXNSR3JhcGggPSB0cnVlO3RoaXMuY3VycmVudFZhbHVlID0gbnVsbDt0aGlzLnVpZCA9IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNhbnZhcy51aWQgPSB0aGlzLmNhbnZhcy51aWQgPyB0aGlzLmNhbnZhcy51aWQgOiBSR3JhcGguQ3JlYXRlVUlEKCk7dGhpcy5jb2xvcnNQYXJzZWQgPSBmYWxzZTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLm9yaWdpbmFsX2NvbG9ycyA9IFtdO3RoaXMuZmlyc3REcmF3ID0gdHJ1ZTt0aGlzLnByb3BlcnRpZXMgPSB7ICdjaGFydC5jb2xvcnMnOiBbJ0dyYWRpZW50KHdoaXRlOiMwYzApJywgJ0dyYWRpZW50KHdoaXRlOnJlZCknLCAnR3JhZGllbnQod2hpdGU6Z3JlZW4pJywgJ3llbGxvdycsICdwaW5rJywgJ2N5YW4nLCAnYmxhY2snLCAnd2hpdGUnLCAnZ3JheSddLCAnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInOiAnIzk5OScsICdjaGFydC5zdHJva2VzdHlsZS5vdXRlcic6ICcjOTk5JywgJ2NoYXJ0LnRpY2ttYXJrcyc6IHRydWUsICdjaGFydC50aWNrbWFya3MuemVyb3N0YXJ0JzogdHJ1ZSwgJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvcic6ICcjOTk5JywgJ2NoYXJ0LnRpY2ttYXJrcy5pbm5lcic6IGZhbHNlLCAnY2hhcnQuZ3V0dGVyLmxlZnQnOiAyNSwgJ2NoYXJ0Lmd1dHRlci5yaWdodCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnRvcCc6IDI1LCAnY2hhcnQuZ3V0dGVyLmJvdHRvbSc6IDI1LCAnY2hhcnQubnVtdGlja3MnOiAxMCwgJ2NoYXJ0Lm51bXRpY2tzLmlubmVyJzogNTAsICdjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJzogJ0dyYWRpZW50KCNjY2M6I2VlZTojZWZlZmVmKScsICdjaGFydC5zaGFkb3cnOiBmYWxzZSwgJ2NoYXJ0LnNoYWRvdy5jb2xvcic6ICdyZ2JhKDAsMCwwLDAuNSknLCAnY2hhcnQuc2hhZG93LmJsdXInOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHgnOiAzLCAnY2hhcnQuc2hhZG93Lm9mZnNldHknOiAzLCAnY2hhcnQudGl0bGUnOiAnJywgJ2NoYXJ0LnRpdGxlLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUuZm9udCc6IG51bGwsICdjaGFydC50aXRsZS5zaXplJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmNvbG9yJzogJ2JsYWNrJywgJ2NoYXJ0LnRpdGxlLnNpZGUnOiBudWxsLCAnY2hhcnQudGl0bGUuc2lkZS5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50aXRsZS5zaWRlLnNpemUnOiAxMiwgJ2NoYXJ0LnRpdGxlLnNpZGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGl0bGUuc2lkZS5ib2xkJzogdHJ1ZSwgJ2NoYXJ0LnRleHQuc2l6ZSc6IDEyLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LmZvbnQnOiAnU2Vnb2UgVUksIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJywgJ2NoYXJ0LnRleHQuYWNjZXNzaWJsZSc6IHRydWUsICdjaGFydC50ZXh0LmFjY2Vzc2libGUub3ZlcmZsb3cnOiAndmlzaWJsZScsICdjaGFydC50ZXh0LmFjY2Vzc2libGUucG9pbnRlcmV2ZW50cyc6IHRydWUsICdjaGFydC5jb250ZXh0bWVudSc6IG51bGwsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnRvb2x0aXBzJzogbnVsbCwgJ2NoYXJ0LnRvb2x0aXBzLmVmZmVjdCc6ICdmYWRlJywgJ2NoYXJ0LnRvb2x0aXBzLmNzcy5jbGFzcyc6ICdSR3JhcGhfdG9vbHRpcCcsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC5oaWdobGlnaHQuc3Ryb2tlJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmFubm90YXRhYmxlJzogZmFsc2UsICdjaGFydC5hbm5vdGF0ZS5jb2xvcic6ICdibGFjaycsICdjaGFydC56b29tLmZhY3Rvcic6IDEuNSwgJ2NoYXJ0Lnpvb20uZmFkZS5pbic6IHRydWUsICdjaGFydC56b29tLmZhZGUub3V0JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uaGRpcic6ICdyaWdodCcsICdjaGFydC56b29tLnZkaXInOiAnZG93bicsICdjaGFydC56b29tLmZyYW1lcyc6IDI1LCAnY2hhcnQuem9vbS5kZWxheSc6IDE2LjY2NiwgJ2NoYXJ0Lnpvb20uc2hhZG93JzogdHJ1ZSwgJ2NoYXJ0Lnpvb20uYmFja2dyb3VuZCc6IHRydWUsICdjaGFydC56b29tLmFjdGlvbic6ICd6b29tJywgJ2NoYXJ0LmFycm93cyc6IGZhbHNlLCAnY2hhcnQubWFyZ2luJzogMCwgJ2NoYXJ0LnJlc2l6YWJsZSc6IGZhbHNlLCAnY2hhcnQucmVzaXplLmhhbmRsZS5hZGp1c3QnOiBbMCwgMF0sICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQubGFiZWwuaW5uZXInOiBmYWxzZSwgJ2NoYXJ0LmxhYmVscy5jb3VudCc6IDEwLCAnY2hhcnQubGFiZWxzLnBvc2l0aW9uJzogJ3JpZ2h0JywgJ2NoYXJ0LmxhYmVscy5vZmZzZXR4JzogMCwgJ2NoYXJ0LmxhYmVscy5vZmZzZXR5JzogMCwgJ2NoYXJ0LmFkanVzdGFibGUnOiBmYWxzZSwgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJzogJywnLCAnY2hhcnQuc2NhbGUucG9pbnQnOiAnLicsICdjaGFydC5rZXknOiBudWxsLCAnY2hhcnQua2V5LmJhY2tncm91bmQnOiAnd2hpdGUnLCAnY2hhcnQua2V5LnBvc2l0aW9uJzogJ2dyYXBoJywgJ2NoYXJ0LmtleS5oYWxpZ24nOiAncmlnaHQnLCAnY2hhcnQua2V5LnNoYWRvdyc6IGZhbHNlLCAnY2hhcnQua2V5LnNoYWRvdy5jb2xvcic6ICcjNjY2JywgJ2NoYXJ0LmtleS5zaGFkb3cuYmx1cic6IDMsICdjaGFydC5rZXkuc2hhZG93Lm9mZnNldHgnOiAyLCAnY2hhcnQua2V5LnNoYWRvdy5vZmZzZXR5JzogMiwgJ2NoYXJ0LmtleS5wb3NpdGlvbi5ndXR0ZXIuYm94ZWQnOiBmYWxzZSwgJ2NoYXJ0LmtleS5wb3NpdGlvbi54JzogbnVsbCwgJ2NoYXJ0LmtleS5wb3NpdGlvbi55JzogbnVsbCwgJ2NoYXJ0LmtleS5jb2xvci5zaGFwZSc6ICdzcXVhcmUnLCAnY2hhcnQua2V5LnJvdW5kZWQnOiB0cnVlLCAnY2hhcnQua2V5LmxpbmV3aWR0aCc6IDEsICdjaGFydC5rZXkuY29sb3JzJzogbnVsbCwgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZSc6IGZhbHNlLCAnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnOiAnIzAwMCcsICdjaGFydC5rZXkuaW50ZXJhY3RpdmUuaGlnaGxpZ2h0LmNoYXJ0LmZpbGwnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJywgJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQubGFiZWwnOiAncmdiYSgyNTUsMCwwLDAuMiknLCAnY2hhcnQua2V5LnRleHQuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuZXZlbnRzLmNsaWNrJzogbnVsbCwgJ2NoYXJ0LmV2ZW50cy5tb3VzZW1vdmUnOiBudWxsLCAnY2hhcnQuYm9yZGVyLmlubmVyJzogdHJ1ZSwgJ2NoYXJ0LmNsZWFydG8nOiAncmdiYSgwLDAsMCwwKScgfTtcbiAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgIGFsZXJ0KCdbUFJPR1JFU1NdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIHZhciBsaW5lYXJfZGF0YSA9IFJHcmFwaC5hcnJheUxpbmVhcml6ZSh0aGlzLnZhbHVlKTtmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVhcl9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpc1snJCcgKyBpXSA9IHt9O1xuICB9XG4gIGlmICghdGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fKSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7dGhpcy5jYW52YXMuX19yZ3JhcGhfYWFfdHJhbnNsYXRlZF9fID0gdHJ1ZTtcbiAgfVxuICB2YXIgUkcgPSBSR3JhcGgsXG4gICAgICBjYSA9IHRoaXMuY2FudmFzLFxuICAgICAgY28gPSBjYS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgcHJvcCA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHBhMiA9IFJHLnBhdGgyLFxuICAgICAgd2luID0gd2luZG93LFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICBtYSA9IE1hdGg7XG4gIGlmIChSRy5FZmZlY3RzICYmIHR5cGVvZiBSRy5FZmZlY3RzLmRlY29yYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUkcuRWZmZWN0cy5kZWNvcmF0ZSh0aGlzKTtcbiAgfVxuICB0aGlzLnNldCA9IHRoaXMuU2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBhcmd1bWVudHNbMV07aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIG5hbWUpO3JldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIGlmIChuYW1lID09ICdjaGFydC5zdHJva2VzdHlsZScpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ10gPSB2YWx1ZTtwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddID0gdmFsdWU7cmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobmFtZS5tYXRjaCgvKFtBLVpdKS8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8oW0EtWl0pLywgJy4nICsgUmVnRXhwLiQxLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmdldCA9IHRoaXMuR2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNikgIT0gJ2NoYXJ0LicpIHtcbiAgICAgIG5hbWUgPSAnY2hhcnQuJyArIG5hbWU7XG4gICAgfVxuICAgIHdoaWxlIChuYW1lLm1hdGNoKC8oW0EtWl0pLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvLCAnLicgKyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH07dGhpcy5kcmF3ID0gdGhpcy5EcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlO3RoaXMuZ3V0dGVyTGVmdCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5sZWZ0J107dGhpcy5ndXR0ZXJSaWdodCA9IHByb3BbJ2NoYXJ0Lmd1dHRlci5yaWdodCddO3RoaXMuZ3V0dGVyVG9wID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddO3RoaXMuZ3V0dGVyQm90dG9tID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3RoaXMud2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dGhpcy5oZWlnaHQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tO3RoaXMuY29vcmRzID0gW107dGhpcy5jb29yZHNUZXh0ID0gW107dGhpcy5EcmF3YmFyKCk7dGhpcy5EcmF3VGlja01hcmtzKCk7dGhpcy5EcmF3TGFiZWxzKCk7dGhpcy5EcmF3VGl0bGVzKCk7aWYgKHByb3BbJ2NoYXJ0LmJldmVsJ10pIHtcbiAgICAgIHRoaXMuRHJhd0JldmVsKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgUkcuSW5zdGFsbEV2ZW50TGlzdGVuZXJzKHRoaXMpO2lmIChwcm9wWydjaGFydC5rZXknXSAmJiBwcm9wWydjaGFydC5rZXknXS5sZW5ndGgpIHtcbiAgICAgIFJHLkRyYXdLZXkodGhpcywgcHJvcFsnY2hhcnQua2V5J10sIHByb3BbJ2NoYXJ0LmNvbG9ycyddKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLkFsbG93QWRqdXN0aW5nKCk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdiYXIgPSB0aGlzLkRyYXdiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY2FsZTIgPSBSRy5nZXRTY2FsZTIodGhpcywgeyAnbWF4JzogdGhpcy5tYXgsICdtaW4nOiB0aGlzLm1pbiwgJ3N0cmljdCc6IHRydWUsICdzY2FsZS50aG91c2FuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnRob3VzYW5kJ10sICdzY2FsZS5wb2ludCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnBvaW50J10sICdzY2FsZS5kZWNpbWFscyc6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10sICd5bGFiZWxzLmNvdW50JzogcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J10sICdzY2FsZS5yb3VuZCc6IHByb3BbJ2NoYXJ0LnNjYWxlLnJvdW5kJ10sICd1bml0cy5wcmUnOiBwcm9wWydjaGFydC51bml0cy5wcmUnXSwgJ3VuaXRzLnBvc3QnOiBwcm9wWydjaGFydC51bml0cy5wb3N0J10gfSk7aWYgKHByb3BbJ2NoYXJ0LnNoYWRvdyddKSB7XG4gICAgICBSRy5zZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO1xuICAgIH1cbiAgICBjby5maWxsU3R5bGUgPSBwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmNvbG9yJ107Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddO2NvLnN0cm9rZVJlY3QodGhpcy5ndXR0ZXJMZWZ0LCB0aGlzLmd1dHRlclRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO2NvLmZpbGxSZWN0KHRoaXMuZ3V0dGVyTGVmdCwgdGhpcy5ndXR0ZXJUb3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtSRy5ub1NoYWRvdyh0aGlzKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ107Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMF07dmFyIG1hcmdpbiA9IHByb3BbJ2NoYXJ0Lm1hcmdpbiddO3ZhciBiYXJIZWlnaHQgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgKiAoKFJHLmFycmF5U3VtKHRoaXMudmFsdWUpIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBjby5saW5lV2lkdGggPSAxO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXTtpZiAocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pIHtcbiAgICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5ndXR0ZXJMZWZ0ICsgbWFyZ2luLCB5OiB0aGlzLmd1dHRlclRvcCArICh0aGlzLmhlaWdodCAtIGJhckhlaWdodCksIHdpZHRoOiB0aGlzLndpZHRoIC0gbWFyZ2luIC0gbWFyZ2luLCBoZWlnaHQ6IGJhckhlaWdodCwgc3Ryb2tlOiBwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5ndXR0ZXJMZWZ0ICsgbWFyZ2luLCB5OiB0aGlzLmd1dHRlclRvcCArICh0aGlzLmhlaWdodCAtIGJhckhlaWdodCksIHdpZHRoOiB0aGlzLndpZHRoIC0gbWFyZ2luIC0gbWFyZ2luLCBoZWlnaHQ6IGJhckhlaWdodCwgZmlsbDogcHJvcFsnY2hhcnQuY29sb3JzJ11bMF0gfSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMudmFsdWUpID09ICdvYmplY3QnKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ107dmFyIHN0YXJ0UG9pbnQgPSBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy52YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudEhlaWdodCA9ICh0aGlzLnZhbHVlW2ldIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pICogKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gdGhpcy5ndXR0ZXJUb3ApO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmNvbG9ycyddW2ldO2NvLmJlZ2luUGF0aCgpO2lmIChwcm9wWydjaGFydC5ib3JkZXIuaW5uZXInXSkge1xuICAgICAgICAgIHRoaXMuZHJhd0N1cnZlZEJhcih7IHg6IHRoaXMuZ3V0dGVyTGVmdCArIG1hcmdpbiwgeTogc3RhcnRQb2ludCAtIHNlZ21lbnRIZWlnaHQsIHdpZHRoOiB0aGlzLndpZHRoIC0gbWFyZ2luIC0gbWFyZ2luLCBoZWlnaHQ6IHNlZ21lbnRIZWlnaHQsIHN0cm9rZTogY28uc3Ryb2tlU3R5bGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5ndXR0ZXJMZWZ0ICsgbWFyZ2luLCB5OiBzdGFydFBvaW50IC0gc2VnbWVudEhlaWdodCwgd2lkdGg6IHRoaXMud2lkdGggLSBtYXJnaW4gLSBtYXJnaW4sIGhlaWdodDogc2VnbWVudEhlaWdodCwgZmlsbDogY28uZmlsbFN0eWxlIH0pO3RoaXMuY29vcmRzLnB1c2goW3RoaXMuZ3V0dGVyTGVmdCArIG1hcmdpbiwgc3RhcnRQb2ludCAtIHNlZ21lbnRIZWlnaHQsIHRoaXMud2lkdGggLSBtYXJnaW4gLSBtYXJnaW4sIHNlZ21lbnRIZWlnaHRdKTtzdGFydFBvaW50IC09IHNlZ21lbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICBjby5maWxsKCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC50aWNrbWFya3MuaW5uZXInXSkge1xuICAgICAgdmFyIHNwYWNpbmcgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyBwcm9wWydjaGFydC5udW10aWNrcy5pbm5lciddO2NvLmxpbmVXaWR0aCA9IDE7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddO2NvLmJlZ2luUGF0aCgpO2ZvciAodmFyIHkgPSB0aGlzLmd1dHRlclRvcDsgeSA8IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tOyB5ICs9IHNwYWNpbmcpIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgTWF0aC5yb3VuZCh5KSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCArIDMsIE1hdGgucm91bmQoeSkpO2NvLm1vdmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQsIE1hdGgucm91bmQoeSkpO2NvLmxpbmVUbyhjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgLSAzLCBNYXRoLnJvdW5kKHkpKTtcbiAgICAgIH1cbiAgICAgIGNvLnN0cm9rZSgpO1xuICAgIH1cbiAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ107aWYgKHR5cGVvZiB0aGlzLnZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICBpZiAocHJvcFsnY2hhcnQuYm9yZGVyLmlubmVyJ10pIHtcbiAgICAgICAgdGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5ndXR0ZXJMZWZ0ICsgbWFyZ2luLCB5OiB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGVpZ2h0IC0gYmFySGVpZ2h0LCB3aWR0aDogdGhpcy53aWR0aCAtIG1hcmdpbiAtIG1hcmdpbiwgaGVpZ2h0OiBiYXJIZWlnaHQgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdDdXJ2ZWRCYXIoeyB4OiB0aGlzLmd1dHRlckxlZnQgKyBtYXJnaW4sIHk6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oZWlnaHQgLSBiYXJIZWlnaHQsIHdpZHRoOiB0aGlzLndpZHRoIC0gbWFyZ2luIC0gbWFyZ2luLCBoZWlnaHQ6IGJhckhlaWdodCB9KTt0aGlzLmNvb3Jkcy5wdXNoKFt0aGlzLmd1dHRlckxlZnQgKyBtYXJnaW4sIHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5oZWlnaHQgLSBiYXJIZWlnaHQsIHRoaXMud2lkdGggLSBtYXJnaW4gLSBtYXJnaW4sIGJhckhlaWdodF0pO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQuYXJyb3dzJ10pIHtcbiAgICAgIHZhciB4ID0gdGhpcy5ndXR0ZXJMZWZ0IC0gNDt2YXIgeSA9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tIC0gYmFySGVpZ2h0O2NvLmxpbmVXaWR0aCA9IDE7Y28uZmlsbFN0eWxlID0gJ2JsYWNrJztjby5zdHJva2VTdHlsZSA9ICdibGFjayc7Y28uYmVnaW5QYXRoKCk7Y28ubW92ZVRvKHgsIHkpO2NvLmxpbmVUbyh4IC0gNCwgeSAtIDIpO2NvLmxpbmVUbyh4IC0gNCwgeSArIDIpO2NvLmNsb3NlUGF0aCgpO2NvLnN0cm9rZSgpO2NvLmZpbGwoKTt4ICs9IHRoaXMud2lkdGggKyA4O2NvLmJlZ2luUGF0aCgpO2NvLm1vdmVUbyh4LCB5KTtjby5saW5lVG8oeCArIDQsIHkgLSAyKTtjby5saW5lVG8oeCArIDQsIHkgKyAyKTtjby5jbG9zZVBhdGgoKTtjby5zdHJva2UoKTtjby5maWxsKCk7cGEyKGNvLCAnYicpO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubGFiZWwuaW5uZXInXSkge1xuICAgICAgY28uZmlsbFN0eWxlID0gJ2JsYWNrJztSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudGV4dC5mb250J10sICdzaXplJzogcHJvcFsnY2hhcnQudGV4dC5zaXplJ10sICd4JzogKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyICsgdGhpcy5ndXR0ZXJMZWZ0LCAneSc6IHRoaXMuY29vcmRzW3RoaXMuY29vcmRzLmxlbmd0aCAtIDFdWzFdIC0gNSwgJ3RleHQnOiBSR3JhcGgubnVtYmVyX2Zvcm1hdCh0aGlzLCAodHlwZW9mIHRoaXMudmFsdWUgPT0gJ251bWJlcicgPyB0aGlzLnZhbHVlIDogUkcuYXJyYXlfc3VtKHRoaXMudmFsdWUpKS50b0ZpeGVkKHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKSwgJ3ZhbGlnbic6ICdib3R0b20nLCAnaGFsaWduJzogJ2NlbnRlcicsICdib3VuZGluZyc6IHRydWUsICdib3VuZGluZ0ZpbGwnOiAnd2hpdGUnLCAndGFnJzogJ2xhYmVsLmlubmVyJyB9KTtcbiAgICB9XG4gIH07dGhpcy5kcmF3VGlja01hcmtzID0gdGhpcy5EcmF3VGlja01hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQudGlja21hcmtzLmNvbG9yJ107aWYgKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcyddKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtmb3IgKHZhciBpID0gMDsgcHJvcFsnY2hhcnQudGlja21hcmtzLnplcm9zdGFydCddID8gaSA8PSBwcm9wWydjaGFydC5udW10aWNrcyddIDogaSA8IHByb3BbJ2NoYXJ0Lm51bXRpY2tzJ107IGkrKykge1xuICAgICAgICB2YXIgc3RhcnRYID0gcHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0IDogY2Eud2lkdGggLSBwcm9wWydjaGFydC5ndXR0ZXIucmlnaHQnXTt2YXIgZW5kWCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddID09ICdsZWZ0JyA/IHN0YXJ0WCAtIDQgOiBzdGFydFggKyA0O3ZhciB5UG9zID0gdGhpcy5oZWlnaHQgKiAoaSAvIHByb3BbJ2NoYXJ0Lm51bXRpY2tzJ10pICsgdGhpcy5ndXR0ZXJUb3A7XG4gICAgICAgIGNvLm1vdmVUbyhzdGFydFgsIG1hLnJvdW5kKHlQb3MpKTtjby5saW5lVG8oZW5kWCwgbWEucm91bmQoeVBvcykpO1xuICAgICAgfVxuICAgICAgY28uc3Ryb2tlKCk7XG4gICAgfVxuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVJHLmlzX251bGwocHJvcFsnY2hhcnQubGFiZWxzLnNwZWNpZmljJ10pKSB7XG4gICAgICByZXR1cm4gdGhpcy5EcmF3U3BlY2lmaWNMYWJlbHMoKTtcbiAgICB9XG4gICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO3ZhciBwb3NpdGlvbiA9IHByb3BbJ2NoYXJ0LmxhYmVscy5wb3NpdGlvbiddLnRvTG93ZXJDYXNlKCk7dmFyIHhBbGlnbm1lbnQgPSBwb3NpdGlvbiA9PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO3ZhciB5QWxpZ25tZW50ID0gJ2NlbnRlcic7dmFyIGNvdW50ID0gcHJvcFsnY2hhcnQubGFiZWxzLmNvdW50J107dmFyIHVuaXRzX3ByZSA9IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddO3ZhciB1bml0c19wb3N0ID0gcHJvcFsnY2hhcnQudW5pdHMucG9zdCddO3ZhciB0ZXh0X3NpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgdGV4dF9mb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTt2YXIgb2Zmc2V0eCA9IHByb3BbJ2NoYXJ0LmxhYmVscy5vZmZzZXR4J107dmFyIG9mZnNldHkgPSBwcm9wWydjaGFydC5sYWJlbHMub2Zmc2V0eSddO2lmIChwcm9wWydjaGFydC50aWNrbWFya3MnXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogdGV4dF9mb250LCBzaXplOiB0ZXh0X3NpemUsIHg6IHBvc2l0aW9uID09ICdsZWZ0JyA/IHRoaXMuZ3V0dGVyTGVmdCAtIDcgKyBvZmZzZXR4IDogY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0ICsgNyArIG9mZnNldHgsIHk6IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlclRvcCAtIHRoaXMuZ3V0dGVyQm90dG9tKSAvIGNvdW50ICogaSArIHRoaXMuZ3V0dGVyVG9wICsgb2Zmc2V0eSwgdGV4dDogdGhpcy5zY2FsZTIubGFiZWxzW3RoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGggLSAoaSArIDEpXSwgdmFsaWduOiB5QWxpZ25tZW50LCBoYWxpZ246IHhBbGlnbm1lbnQsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wWydjaGFydC50aWNrbWFya3MuemVyb3N0YXJ0J10gJiYgdGhpcy5taW4gPT0gMCkge1xuICAgICAgICBSRy50ZXh0Mih0aGlzLCB7IGZvbnQ6IHRleHRfZm9udCwgc2l6ZTogdGV4dF9zaXplLCB4OiBwb3NpdGlvbiA9PSAnbGVmdCcgPyB0aGlzLmd1dHRlckxlZnQgLSA1ICsgb2Zmc2V0eCA6IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDUgKyBvZmZzZXR4LCB5OiBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSArIG9mZnNldHksICd0ZXh0JzogUkcubnVtYmVyRm9ybWF0KHRoaXMsIHRoaXMubWluLnRvRml4ZWQodGhpcy5taW4gPT09IDAgPyAwIDogZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCB2YWxpZ246IHlBbGlnbm1lbnQsIGhhbGlnbjogeEFsaWdubWVudCwgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWluICE9IDApIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyBmb250OiB0ZXh0X2ZvbnQsIHNpemU6IHRleHRfc2l6ZSwgeDogcG9zaXRpb24gPT0gJ2xlZnQnID8gdGhpcy5ndXR0ZXJMZWZ0IC0gNSArIG9mZnNldHggOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyA1ICsgb2Zmc2V0eCwgeTogY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20gKyBvZmZzZXR5LCB0ZXh0OiBSRy5udW1iZXJfZm9ybWF0KHRoaXMsIHRoaXMubWluLnRvRml4ZWQoZGVjaW1hbHMpLCB1bml0c19wcmUsIHVuaXRzX3Bvc3QpLCB2YWxpZ246IHlBbGlnbm1lbnQsIGhhbGlnbjogeEFsaWdubWVudCwgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTt0aGlzLmRyYXdUaXRsZXMgPSB0aGlzLkRyYXdUaXRsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRleHRfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddO3ZhciB0ZXh0X2ZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXTt2YXIgdGl0bGVfc2l6ZSA9IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA/IHByb3BbJ2NoYXJ0LnRpdGxlLnNpemUnXSA6IHRleHRfc2l6ZSArIDI7aWYgKHByb3BbJ2NoYXJ0LnRpdGxlJ10ubGVuZ3RoID4gMCkge1xuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGl0bGUuY29sb3InXTtSRy50ZXh0Mih0aGlzLCB7ICdmb250JzogcHJvcFsnY2hhcnQudGl0bGUuZm9udCddID8gcHJvcFsnY2hhcnQudGl0bGUuZm9udCddIDogdGV4dF9mb250LCAnc2l6ZSc6IHRpdGxlX3NpemUsICd4JzogdGhpcy5ndXR0ZXJMZWZ0ICsgKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCkgLyAyLCAneSc6IHRoaXMuZ3V0dGVyVG9wIC0gNSwgJ3RleHQnOiBwcm9wWydjaGFydC50aXRsZSddLCAndmFsaWduJzogJ2JvdHRvbScsICdoYWxpZ24nOiAnY2VudGVyJywgJ2JvbGQnOiBwcm9wWydjaGFydC50aXRsZS5ib2xkJ10sICd0YWcnOiAndGl0bGUnIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BbJ2NoYXJ0LnRpdGxlLnNpZGUnXSA9PSAnc3RyaW5nJykge1xuICAgICAgY28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGl0bGUuc2lkZS5jb2xvciddO1JHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBwcm9wWydjaGFydC50aXRsZS5zaWRlLmZvbnQnXSwgJ3NpemUnOiBwcm9wWydjaGFydC50aXRsZS5zaWRlLnNpemUnXSwgJ3gnOiBwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSA9PSAncmlnaHQnID8gdGhpcy5ndXR0ZXJMZWZ0IC0gMTAgOiBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyAxMCwgJ3knOiB0aGlzLmd1dHRlclRvcCArIHRoaXMuaGVpZ2h0IC8gMiwgJ3RleHQnOiBwcm9wWydjaGFydC50aXRsZS5zaWRlJ10sICd2YWxpZ24nOiAnYm90dG9tJywgJ2hhbGlnbic6ICdjZW50ZXInLCAnYW5nbGUnOiBwcm9wWydjaGFydC5sYWJlbHMucG9zaXRpb24nXSA9PSAncmlnaHQnID8gMjcwIDogOTAsICdib2xkJzogcHJvcFsnY2hhcnQudGl0bGUuc2lkZS5ib2xkJ10sICd0YWcnOiAndGl0bGUuc2lkZScgfSk7XG4gICAgfVxuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldEJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpLFxuICAgICAgICBtb3VzZVggPSBtb3VzZVhZWzBdLFxuICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHggPSB0aGlzLmNvb3Jkc1tpXVswXSxcbiAgICAgICAgICB5ID0gdGhpcy5jb29yZHNbaV1bMV0sXG4gICAgICAgICAgdyA9IHRoaXMuY29vcmRzW2ldWzJdLFxuICAgICAgICAgIGggPSB0aGlzLmNvb3Jkc1tpXVszXSxcbiAgICAgICAgICBpZHggPSBpO2NvLmJlZ2luUGF0aCgpO3RoaXMuZHJhd0N1cnZlZEJhcih7IHg6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSk7aWYgKGNvLmlzUG9pbnRJblBhdGgobW91c2VYLCBtb3VzZVkpKSB7XG4gICAgICAgIHZhciB0b29sdGlwID0gUkcucGFyc2VUb29sdGlwVGV4dChwcm9wWydjaGFydC50b29sdGlwcyddLCBpKTtyZXR1cm4geyAwOiB0aGlzLCAnb2JqZWN0JzogdGhpcywgMTogeCwgJ3gnOiB4LCAyOiB5LCAneSc6IHksIDM6IHcsICd3aWR0aCc6IHcsIDQ6IGgsICdoZWlnaHQnOiBoLCA1OiBpLCAnaW5kZXgnOiBpLCAndG9vbHRpcCc6IHRvb2x0aXAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07dGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlQ29vcmRzID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgbW91c2VYID0gbW91c2VDb29yZHNbMF07dmFyIG1vdXNlWSA9IG1vdXNlQ29vcmRzWzFdO3ZhciB2YWx1ZSA9ICh0aGlzLmhlaWdodCAtIChtb3VzZVkgLSB0aGlzLmd1dHRlclRvcCkpIC8gdGhpcy5oZWlnaHQ7dmFsdWUgKj0gdGhpcy5tYXggLSB0aGlzLm1pbjt2YWx1ZSArPSB0aGlzLm1pbjtpZiAodmFsdWUgPiB0aGlzLm1heCkgdmFsdWUgPSB0aGlzLm1heDtpZiAodmFsdWUgPCB0aGlzLm1pbikgdmFsdWUgPSB0aGlzLm1pbjtyZXR1cm4gdmFsdWU7XG4gIH07dGhpcy5oaWdobGlnaHQgPSB0aGlzLkhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHlsZSddKHNoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxhc3QgPSBzaGFwZS5pbmRleCA9PT0gdGhpcy5jb29yZHMubGVuZ3RoIC0gMTt0aGlzLmRyYXdDdXJ2ZWRCYXIoeyB4OiBzaGFwZS54LCB5OiBzaGFwZS55LCB3aWR0aDogc2hhcGUud2lkdGgsIGhlaWdodDogc2hhcGUuaGVpZ2h0LCBzdHJva2U6IHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSwgZmlsbDogcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSB9KTtcbiAgICB9XG4gIH07dGhpcy5nZXRPYmplY3RCeVhZID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSk7aWYgKG1vdXNlWFlbMF0gPiB0aGlzLmd1dHRlckxlZnQgJiYgbW91c2VYWVswXSA8IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAmJiBtb3VzZVhZWzFdID49IHRoaXMuZ3V0dGVyVG9wICYmIG1vdXNlWFlbMV0gPD0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTt0aGlzLmFsbG93QWRqdXN0aW5nID0gdGhpcy5BbGxvd0FkanVzdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07dGhpcy5hZGp1c3RpbmdfbW91c2Vtb3ZlID0gdGhpcy5BZGp1c3RpbmdfbW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQuYWRqdXN0YWJsZSddICYmIFJHLlJlZ2lzdHJ5LkdldCgnY2hhcnQuYWRqdXN0aW5nJykgJiYgUkcuUmVnaXN0cnkuR2V0KCdjaGFydC5hZGp1c3RpbmcnKS51aWQgPT0gdGhpcy51aWQpIHtcbiAgICAgIHZhciBtb3VzZVhZID0gUkcuZ2V0TW91c2VYWShlKTt2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGUpO2lmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIFJHLkZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25hZGp1c3QnKTt0aGlzLnZhbHVlID0gTnVtYmVyKHZhbHVlLnRvRml4ZWQocHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXSkpO1JHLlJlZHJhd0NhbnZhcyh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICB9O3RoaXMuZHJhd1NwZWNpZmljTGFiZWxzID0gdGhpcy5EcmF3U3BlY2lmaWNMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVscyA9IHByb3BbJ2NoYXJ0LmxhYmVscy5zcGVjaWZpYyddO2lmIChsYWJlbHMpIHtcbiAgICAgIHZhciBmb250ID0gcHJvcFsnY2hhcnQudGV4dC5mb250J107dmFyIHNpemUgPSBwcm9wWydjaGFydC50ZXh0LnNpemUnXTt2YXIgaGFsaWduID0gcHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7dmFyIHN0ZXAgPSB0aGlzLmhlaWdodCAvIChsYWJlbHMubGVuZ3RoIC0gMSk7Y28uYmVnaW5QYXRoKCk7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQudGV4dC5jb2xvciddO2ZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIFJHLlRleHQyKHRoaXMsIHsgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICd4JzogcHJvcFsnY2hhcnQubGFiZWxzLnBvc2l0aW9uJ10gPT0gJ3JpZ2h0JyA/IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCArIDcgOiB0aGlzLmd1dHRlckxlZnQgLSA3LCAneSc6IHRoaXMuaGVpZ2h0ICsgdGhpcy5ndXR0ZXJUb3AgLSBzdGVwICogaSwgJ3RleHQnOiBsYWJlbHNbaV0sICd2YWxpZ24nOiAnY2VudGVyJywgJ2hhbGlnbic6IGhhbGlnbiwgJ3RhZyc6ICdsYWJlbHMuc3BlY2lmaWMnIH0pO1xuICAgICAgfVxuICAgICAgY28uZmlsbCgpO1xuICAgIH1cbiAgfTt0aGlzLmdldFlDb29yZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA+IHRoaXMubWF4IHx8IHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYmFySGVpZ2h0ID0gY2EuaGVpZ2h0IC0gcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3ZhciBjb29yZCA9ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSAqIGJhckhlaWdodDtjb29yZCA9IGNhLmhlaWdodCAtIGNvb3JkIC0gcHJvcFsnY2hhcnQuZ3V0dGVyLmJvdHRvbSddO3JldHVybiBjb29yZDtcbiAgfTt0aGlzLm92ZXJDaGFydEFyZWEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVhZID0gUkdyYXBoLmdldE1vdXNlWFkoZSk7dmFyIG1vdXNlWCA9IG1vdXNlWFlbMF07dmFyIG1vdXNlWSA9IG1vdXNlWFlbMV07aWYgKG1vdXNlWCA+PSB0aGlzLmd1dHRlckxlZnQgJiYgbW91c2VYIDw9IGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCAmJiBtb3VzZVkgPj0gdGhpcy5ndXR0ZXJUb3AgJiYgbW91c2VZIDw9IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O3RoaXMucGFyc2VDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxfY29sb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNvbG9ycyddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuY29sb3JzJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC50aWNrbWFya3MuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvciddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLmlubmVyJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZS5vdXRlciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuaGlnaGxpZ2h0LmNvbG9yJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuY29sb3InXSk7XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5jb2xvcnMnXTtmb3IgKHZhciBpID0gMCwgbGVuID0gY29sb3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO1xuICAgIH1cbiAgICBwcm9wWydjaGFydC50aWNrbWFya3MuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnRpY2ttYXJrcy5jb2xvciddKTtwcm9wWydjaGFydC5zdHJva2VzdHlsZS5pbm5lciddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUuaW5uZXInXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUub3V0ZXInXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlLm91dGVyJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTtwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5oaWdobGlnaHQuc3Ryb2tlJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGNvbG9yLm1hdGNoKC9eZ3JhZGllbnRcXCgoLiopXFwpJC9pKSkge1xuICAgICAgdmFyIHBhcnRzID0gUmVnRXhwLiQxLnNwbGl0KCc6Jyk7dmFyIGdyYWQgPSBjby5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIDAsIHByb3BbJ2NoYXJ0Lmd1dHRlci50b3AnXSk7dmFyIGRpZmYgPSAxIC8gKHBhcnRzLmxlbmd0aCAtIDEpO2dyYWQuYWRkQ29sb3JTdG9wKDAsIFJHLnRyaW0ocGFydHNbMF0pKTtmb3IgKHZhciBqID0gMSwgbGVuID0gcGFydHMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoaiAqIGRpZmYsIFJHLnRyaW0ocGFydHNbal0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFkID8gZ3JhZCA6IGNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLmRyYXdCZXZlbCA9IHRoaXMuRHJhd0JldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBoZWlnaHQgPSAwOyBpIDwgdGhpcy5jb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGhlaWdodCArPSB0aGlzLmNvb3Jkc1tpXVszXTtcbiAgICB9XG4gICAgY28uc2F2ZSgpO2NvLmJlZ2luUGF0aCgpO2NvLnJlY3QodGhpcy5jb29yZHNbMF1bMF0sIHRoaXMuY29vcmRzW3RoaXMuY29vcmRzLmxlbmd0aCAtIDFdWzFdIC0gMSwgdGhpcy5jb29yZHNbMF1bMl0sIGhlaWdodCk7Y28uY2xpcCgpO2NvLnNhdmUoKTtjby5iZWdpblBhdGgoKTt0aGlzLmRyYXdDdXJ2ZWRCYXIoeyB4OiB0aGlzLmNvb3Jkc1swXVswXSwgeTogdGhpcy5jb29yZHNbdGhpcy5jb29yZHMubGVuZ3RoIC0gMV1bMV0gLSAxLCB3aWR0aDogdGhpcy5jb29yZHNbMF1bMl0sIGhlaWdodDogaGVpZ2h0IH0pO2NvLmNsaXAoKTtjby5iZWdpblBhdGgoKTtjby5zaGFkb3dDb2xvciA9ICdibGFjayc7Y28uc2hhZG93T2Zmc2V0WCA9IDA7Y28uc2hhZG93T2Zmc2V0WSA9IDA7Y28uc2hhZG93Qmx1ciA9IDE1O2NvLmxpbmVXaWR0aCA9IDI7dGhpcy5kcmF3Q3VydmVkQmFyKHsgeDogdGhpcy5jb29yZHNbMF1bMF0gLSAxLCB5OiB0aGlzLmNvb3Jkc1t0aGlzLmNvb3Jkcy5sZW5ndGggLSAxXVsxXSAtIDEsIHdpZHRoOiB0aGlzLmNvb3Jkc1swXVsyXSArIDIsIGhlaWdodDogaGVpZ2h0ICsgMiArIDEwMCB9KTtjby5zdHJva2UoKTtjby5yZXN0b3JlKCk7Y28ucmVzdG9yZSgpO1xuICB9O3RoaXMuaW50ZXJhY3RpdmVLZXlIaWdobGlnaHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZHNbaW5kZXhdO2NvLmJlZ2luUGF0aCgpO2NvLnN0cm9rZVN0eWxlID0gcHJvcFsnY2hhcnQua2V5LmludGVyYWN0aXZlLmhpZ2hsaWdodC5jaGFydC5zdHJva2UnXTtjby5saW5lV2lkdGggPSAyO2NvLmZpbGxTdHlsZSA9IHByb3BbJ2NoYXJ0LmtleS5pbnRlcmFjdGl2ZS5oaWdobGlnaHQuY2hhcnQuZmlsbCddO2NvLnJlY3QoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtjby5maWxsKCk7Y28uc3Ryb2tlKCk7Y28ubGluZVdpZHRoID0gMTtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5kcmF3Q3VydmVkQmFyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHBhMihjbywgJ2IgciAlICUgJSAlJywgb3B0LngsIG9wdC55LCBvcHQud2lkdGgsIG9wdC5oZWlnaHQpO2lmIChvcHQuc3Ryb2tlKSB7XG4gICAgICBjby5zdHJva2VTdHlsZSA9IG9wdC5zdHJva2U7Y28uc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChvcHQuZmlsbCkge1xuICAgICAgY28uZmlsbFN0eWxlID0gb3B0LmZpbGw7Y28uZmlsbCgpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5leGVjID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKHRoaXMpO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ3JvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdGhpczt2YXIgY2FudmFzID0gb2JqLmNhbnZhczt2YXIgY29udGV4dCA9IG9iai5jb250ZXh0O3ZhciBpbml0aWFsX3ZhbHVlID0gb2JqLmN1cnJlbnRWYWx1ZTt2YXIgb3B0ID0gYXJndW1lbnRzWzBdIHx8IHt9O3ZhciBudW1GcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBmcmFtZSA9IDA7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O2lmIChfdHlwZW9mKG9iai52YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoUkdyYXBoLmlzX251bGwob2JqLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgb2JqLmN1cnJlbnRWYWx1ZSA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgb2JqLmN1cnJlbnRWYWx1ZVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkaWZmID0gW107dmFyIGluY3JlbWVudCA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRpZmZbaV0gPSBvYmoudmFsdWVbaV0gLSBOdW1iZXIob2JqLmN1cnJlbnRWYWx1ZVtpXSk7aW5jcmVtZW50W2ldID0gZGlmZltpXSAvIG51bUZyYW1lcztcbiAgICAgIH1cbiAgICAgIGlmIChpbml0aWFsX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbF92YWx1ZSA9IFtdO2ZvciAodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaW5pdGlhbF92YWx1ZVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpZmYgPSBvYmoudmFsdWUgLSBOdW1iZXIob2JqLmN1cnJlbnRWYWx1ZSk7dmFyIGluY3JlbWVudCA9IGRpZmYgLyBudW1GcmFtZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZnJhbWUrKztpZiAoZnJhbWUgPD0gbnVtRnJhbWVzKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9iai52YWx1ZSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBvYmoudmFsdWUgPSBbXTtmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxfdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG9iai52YWx1ZVtpXSA9IGluaXRpYWxfdmFsdWVbaV0gKyBpbmNyZW1lbnRbaV0gKiBmcmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLnZhbHVlID0gaW5pdGlhbF92YWx1ZSArIGluY3JlbWVudCAqIGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIFJHcmFwaC5jbGVhcihvYmouY2FudmFzKTtSR3JhcGgucmVkcmF3Q2FudmFzKG9iai5jYW52YXMpO1JHcmFwaC5FZmZlY3RzLnVwZGF0ZUNhbnZhcyhpdGVyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRvcigpO3JldHVybiB0aGlzO1xuICB9O1JHLmF0dChjYSk7UkcuUmVnaXN0ZXIodGhpcyk7aWYgKHBhcnNlQ29uZk9iamVjdEZvck9wdGlvbnMpIHtcbiAgICBSRy5wYXJzZU9iamVjdFN0eWxlQ29uZmlnKHRoaXMsIGNvbmYub3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9vdGhlcl9jb21wb25lbnRzL3JncmFwaC9saWJyYXJpZXMvUkdyYXBoLnZwcm9ncmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///221\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nRGraph = window.RGraph || { isRGraph: true };RGraph.Waterfall = function (conf) {\n  var _properties;\n\n  if ((typeof conf === 'undefined' ? 'undefined' : _typeof(conf)) === 'object' && _typeof(conf.data) === 'object' && typeof conf.id === 'string') {\n    var parseConfObjectForOptions = true;\n  } else {\n    var conf = { id: conf, data: arguments[1] };\n  }\n  this.id = conf.id;this.canvas = document.getElementById(this.id);this.context = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;this.canvas.__object__ = this;this.type = 'waterfall';this.max = 0;this.data = conf.data;this.isRGraph = true;this.coords = [];this.uid = RGraph.CreateUID();this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();this.colorsParsed = false;this.coordsText = [];this.original_colors = [];this.firstDraw = true;this.properties = (_properties = { 'chart.background.barcolor1': 'rgba(0,0,0,0)', 'chart.background.barcolor2': 'rgba(0,0,0,0)', 'chart.background.grid': true, 'chart.background.grid.color': '#ddd', 'chart.background.grid.width': 1, 'chart.background.grid.hsize': 20, 'chart.background.grid.vsize': 20, 'chart.background.grid.vlines': true, 'chart.background.grid.hlines': true, 'chart.background.grid.border': true, 'chart.background.grid.autofit': true, 'chart.background.grid.autofit.align': true, 'chart.background.grid.autofit.numhlines': 5, 'chart.background.grid.autofit.numvlines': 20, 'chart.background.image': null, 'chart.background.hbars': null, 'chart.linewidth': 1, 'chart.axis.linewidth': 1, 'chart.xaxispos': 'bottom', 'chart.numxticks': null, 'chart.numyticks': 10, 'chart.hmargin': 5, 'chart.strokestyle': '#666', 'chart.axis.color': 'black', 'chart.gutter.left': 25, 'chart.gutter.right': 25, 'chart.gutter.top': 25, 'chart.gutter.bottom': 25, 'chart.labels': [], 'chart.labels.bold': false, 'chart.labels.offsetx': 0, 'chart.labels.offsety': 0, 'chart.ylabels.offsetx': 0, 'chart.ylabels.offsety': 0, 'chart.ylabels': true, 'chart.text.color': 'black', 'chart.text.size': 12, 'chart.text.angle': 0, 'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif', 'chart.text.accessible': true, 'chart.text.accessible.overflow': 'visible', 'chart.text.accessible.pointerevents': true, 'chart.ymax': null, 'chart.title': '', 'chart.title.color': 'black', 'chart.title.background': null, 'chart.title.hpos': null, 'chart.title.vpos': null, 'chart.title.bold': true, 'chart.title.font': null, 'chart.title.xaxis': '', 'chart.title.yaxis': '', 'chart.title.yaxis.bold': true, 'chart.title.yaxis.size': null, 'chart.title.yaxis.font': null, 'chart.title.yaxis.color': null, 'chart.title.xaxis.pos': null, 'chart.title.yaxis.pos': null, 'chart.title.yaxis.align': 'left', 'chart.title.xaxis.bold': true, 'chart.title.xaxis.size': null, 'chart.title.xaxis.font': null, 'chart.title.xaxis.color': null, 'chart.title.yaxis.x': null, 'chart.title.yaxis.y': null, 'chart.title.xaxis.x': null, 'chart.title.xaxis.y': null, 'chart.title.x': null, 'chart.title.y': null, 'chart.title.halign': null, 'chart.title.valign': null, 'chart.colors': ['green', 'red', 'blue'], 'chart.shadow': false, 'chart.shadow.color': '#666', 'chart.shadow.offsetx': 3, 'chart.shadow.offsety': 3, 'chart.shadow.blur': 3, 'chart.tooltips': null, 'chart.tooltips.effect': 'fade', 'chart.tooltips.css.class': 'RGraph_tooltip', 'chart.tooltips.event': 'onclick', 'chart.tooltips.highlight': true, 'chart.tooltips.override': null, 'chart.highlight.stroke': 'rgba(0,0,0,0)', 'chart.highlight.fill': 'rgba(255,255,255,0.7)', 'chart.contextmenu': null, 'chart.units.pre': '', 'chart.units.post': '', 'chart.scale.decimals': 0, 'chart.scale.point': '.', 'chart.scale.thousand': ',', 'chart.scale.zerostart': true, 'chart.crosshairs': false, 'chart.crosshairs.color': '#333', 'chart.crosshairs.hline': true, 'chart.crosshairs.vline': true, 'chart.annotatable': false, 'chart.annotate.color': 'black', 'chart.zoom.factor': 1.5, 'chart.zoom.fade.in': true, 'chart.zoom.fade.out': true, 'chart.zoom.hdir': 'right', 'chart.zoom.vdir': 'down', 'chart.zoom.frames': 25, 'chart.zoom.delay': 16.666, 'chart.zoom.shadow': true, 'chart.zoom.background': true, 'chart.resizable': false, 'chart.resize.handle.background': null, 'chart.noaxes': false, 'chart.noxaxis': false, 'chart.noyaxis': false }, _defineProperty(_properties, 'chart.axis.color', 'black'), _defineProperty(_properties, 'chart.total', true), _defineProperty(_properties, 'chart.multiplier.x', 1), _defineProperty(_properties, 'chart.multiplier.w', 1), _defineProperty(_properties, 'chart.events.click', null), _defineProperty(_properties, 'chart.events.mousemove', null), _defineProperty(_properties, 'chart.ylabels.count', 5), _defineProperty(_properties, 'chart.ymin', 0), _defineProperty(_properties, 'chart.clearto', 'rgba(0,0,0,0)'), _properties);\n  if (!this.canvas) {\n    alert('[WATERFALL] No canvas support');return;\n  }\n  for (var i = 0, len = this.data.length; i <= len; ++i) {\n    this['$' + i] = {};\n    if (typeof this.data[i] === 'string') {\n      this.data[i] = parseFloat(this.data[i]);\n    }\n  }\n  if (!this.canvas.__rgraph_aa_translated__) {\n    this.context.translate(0.5, 0.5);this.canvas.__rgraph_aa_translated__ = true;\n  }\n  var RG = RGraph,\n      ca = this.canvas,\n      co = ca.getContext('2d'),\n      prop = this.properties,\n      pa2 = RG.path2,\n      win = window,\n      doc = document,\n      ma = Math;\n  if (RG.Effects && typeof RG.Effects.decorate === 'function') {\n    RG.Effects.decorate(this);\n  }\n  this.set = this.Set = function (name, value) {\n    var value = typeof arguments[1] === 'undefined' ? null : arguments[1];if (arguments.length === 1 && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      RG.parseObjectStyleConfig(this, name);return this;\n    }\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    if (name == 'chart.total' && prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length;\n    }\n    prop[name.toLowerCase()] = value;return this;\n  };this.get = this.Get = function (name) {\n    if (name.substr(0, 6) != 'chart.') {\n      name = 'chart.' + name;\n    }\n    while (name.match(/([A-Z])/)) {\n      name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());\n    }\n    return prop[name.toLowerCase()];\n  };this.draw = this.Draw = function () {\n    RGraph.fireCustomEvent(this, 'onbeforedraw');if (!this.colorsParsed) {\n      this.parseColors();this.colorsParsed = true;\n    }\n    RGraph.DrawBackgroundImage(this);this.gutterLeft = prop['chart.gutter.left'];this.gutterRight = prop['chart.gutter.right'];this.gutterTop = prop['chart.gutter.top'];this.gutterBottom = prop['chart.gutter.bottom'];this.coords = [];this.coordsText = [];this.centery = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;this.max = 0;this.grapharea = ca.height - this.gutterTop - this.gutterBottom;this.graphwidth = ca.width - this.gutterLeft - this.gutterRight;this.halfTextHeight = prop['chart.text.size'] / 2;this.max = this.getMax(this.data);var decimals = prop['chart.scale.decimals'];this.scale2 = RG.getScale2(this, { max: typeof prop['chart.ymax'] == 'number' ? prop['chart.ymax'] : this.max, min: prop['chart.ymin'], strict: typeof prop['chart.ymax'] === 'number' ? true : false, 'scale.decimals': Number(decimals), 'scale.point': prop['chart.scale.point'], 'scale.thousand': prop['chart.scale.thousand'], 'scale.round': prop['chart.scale.round'], 'units.pre': prop['chart.units.pre'], 'units.post': prop['chart.units.post'], 'ylabels.count': prop['chart.ylabels.count'] });this.max = this.scale2.max;this.min = this.scale2.min;RG.drawBars(this);\n    RG.Background.draw(this);this.DrawAxes();this.Drawbars();this.DrawLabels();if (prop['chart.xaxispos'] === 'bottom' && prop['chart.noaxes'] === false && prop['chart.noxaxis'] === false && prop['chart.ymin'] === 0) {\n      co.strokeStyle = prop['chart.axis.color'];co.strokeRect(prop['chart.gutter.left'], ca.height - prop['chart.gutter.bottom'], ca.width - this.gutterLeft - this.gutterRight, 0);\n    }\n    if (prop['chart.contextmenu']) {\n      RG.ShowContext(this);\n    }\n    if (prop['chart.resizable']) {\n      RG.AllowResizing(this);\n    }\n    RG.InstallEventListeners(this);if (this.firstDraw) {\n      RG.fireCustomEvent(this, 'onfirstdraw');this.firstDraw = false;this.firstDrawFunc();\n    }\n    RG.FireCustomEvent(this, 'ondraw');return this;\n  };this.drawAxes = this.DrawAxes = function () {\n    if (prop['chart.noaxes']) {\n      return;\n    }\n    co.beginPath();co.strokeStyle = prop['chart.axis.color'];co.lineWidth = prop['chart.axis.linewidth'] + 0.001;if (prop['chart.noyaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.gutterTop);co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);\n    }\n    if (prop['chart.noxaxis'] == false) {\n      if (prop['chart.xaxispos'] == 'center') {\n        co.moveTo(this.gutterLeft, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));co.lineTo(ca.width - this.gutterRight, ma.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop));\n      } else {\n        var y = ma.floor(this.getYCoord(0));co.moveTo(this.gutterLeft, y);co.lineTo(ca.width - this.gutterRight, y);\n      }\n    }\n    var numYTicks = prop['chart.numyticks'];if (prop['chart.noyaxis'] === false && prop['chart.numyticks'] > 0) {\n      var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;for (y = this.gutterTop; y < ca.height - this.gutterBottom; y += yTickGap) {\n        if (prop['chart.xaxispos'] == 'bottom' || y != (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop) {\n          co.moveTo(this.gutterLeft, ma.round(y));co.lineTo(this.gutterLeft - 3, ma.round(y));\n        }\n      }\n      if (prop['chart.noxaxis'] || prop['chart.xaxispos'] == 'center' || prop['chart.ymin'] !== 0) {\n        co.moveTo(this.gutterLeft - 3, Math.round(ca.height - this.gutterBottom));co.lineTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));\n      }\n    }\n    if (prop['chart.numxticks'] == null) {\n      prop['chart.numxticks'] = this.data.length + (prop['chart.total'] ? 1 : 0);\n    }\n    if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\n      xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];if (prop['chart.xaxispos'] == 'center') {\n        yStart = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop - 3;yEnd = (ca.height - this.gutterBottom - this.gutterTop) / 2 + this.gutterTop + 3;\n      } else {\n        yStart = this.getYCoord(0) - (this.scale2.min < 0 ? 3 : 0);yEnd = this.getYCoord(0) + 3;\n      }\n      for (x = this.gutterLeft + xTickGap; x <= ca.width - this.gutterRight + 1; x += xTickGap) {\n        co.moveTo(ma.round(x), yStart);co.lineTo(ma.round(x), yEnd);\n      }\n      if (prop['chart.noyaxis']) {\n        co.moveTo(ma.round(this.gutterLeft), yStart);co.lineTo(ma.round(this.gutterLeft), yEnd);\n      }\n    }\n    if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false) {\n      co.moveTo(ma.round(this.gutterLeft), this.getYCoord(0));co.lineTo(ma.round(this.gutterLeft), this.getYCoord(0));\n    }\n    co.stroke();\n  };this.drawLabels = this.DrawLabels = function () {\n    var context = co,\n        numYLabels = 5,\n        interval = this.grapharea / numYLabels,\n        font = prop['chart.text.font'],\n        size = prop['chart.text.size'],\n        color = prop['chart.text.color'],\n        units_pre = prop['chart.units.pre'],\n        units_post = prop['chart.units.post'],\n        offsetx = prop['chart.ylabels.offsetx'],\n        offsety = prop['chart.ylabels.offsety'];co.beginPath();co.fillStyle = color;if (prop['chart.ylabels']) {\n      if (prop['chart.xaxispos'] == 'center') {\n        var halfInterval = interval / 2;var halfWay = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;for (var i = 0, len = this.scale2.labels.length; i < len; ++i) {\n          RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: this.gutterTop + this.grapharea / 2 / len * i + offsety, text: this.scale2.labels[len - i - 1], valign: 'center', halign: 'right', tag: 'scale' });RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: halfWay + this.grapharea / 2 / len * (i + 1) + offsety, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart']) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: halfWay, text: '0', font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      } else {\n        for (var i = 0, len = this.scale2.values.length; i < len; ++i) {\n          var y = this.getYCoord(this.scale2.values[i]) + offsety;RG.text2(this, { font: font, size: size, x: this.gutterLeft - 5 + offsetx, y: y, text: this.scale2.labels[i], valign: 'center', halign: 'right', tag: 'scale' });\n        }\n        if (prop['chart.scale.zerostart'] || prop['chart.ymin'] !== 0) {\n          RG.text2(co, { x: this.gutterLeft - 5 + offsetx, y: this.getYCoord(prop['chart.ymin'] || 0), text: RG.numberFormat(this, String(Number(prop['chart.ymin'] || 0).toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals'])), prop['chart.units.pre'], prop['chart.units.post']), font: font, size: size, valign: 'center', halign: 'right', tag: 'scale' });\n        }\n      }\n    }\n    if (prop['chart.labels'].length > 0) {\n      interval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.labels'].length;var halign = 'center';var angle = prop['chart.text.angle'];if (angle) {\n        halign = 'right';angle *= -1;\n      }\n      var labels = prop['chart.labels'],\n          labelsColor = prop['chart.labels.color'],\n          bold = prop['chart.labels.bold'],\n          offsetx = prop['chart.labels.offsetx'],\n          offsety = prop['chart.labels.offsety'];\n      for (var i = 0, len = labels.length; i < len; i += 1) {\n        RG.text2(this, { 'color': labelsColor, 'font': font, 'size': size, 'bold': bold, 'x': this.gutterLeft + i * interval + interval / 2 + offsetx, 'y': ca.height - this.gutterBottom + 5 + this.halfTextHeight + offsety, 'text': labels[i], 'valign': 'center', 'halign': halign, 'angle': angle, 'tag': 'labels' });\n      }\n    }\n    co.stroke();co.fill();\n  };this.drawbars = this.Drawbars = function () {\n    var context = co,\n        canvas = ca,\n        hmargin = prop['chart.hmargin'],\n        runningTotal = 0;co.lineWidth = prop['chart.linewidth'] + 0.001;for (var i = 0, len = this.data.length; i < len; ++i) {\n      co.beginPath();co.strokeStyle = prop['chart.strokestyle'];var x = ma.round(this.gutterLeft + hmargin + this.graphwidth / (this.data.length + (prop['chart.total'] ? 1 : 0)) * i * prop['chart.multiplier.x']);var h = this.getYCoord(0) - this.getYCoord(ma.abs(this.data[i]));if (i === 0) {\n        y = this.getYCoord(0) - h;\n      } else {\n        y = this.getYCoord(runningTotal) - h;\n      }\n      y = ma.round(y);var w = (ca.width - this.gutterLeft - this.gutterRight) / (this.data.length + (prop['chart.total'] ? 1 : 0)) - 2 * prop['chart.hmargin'];w = w * prop['chart.multiplier.w'];if (this.data[i] < 0) {\n        y += h;\n      }\n      co.fillStyle = this.data[i] >= 0 ? prop['chart.colors'][0] : prop['chart.colors'][1];if (prop['chart.shadow']) {\n        RG.setShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\n      } else {\n        RG.noShadow(this);\n      }\n      co.rect(x, ma.floor(y), w, ma.floor(h));this.coords.push([x, y, w, h]);runningTotal += this.data[i];co.stroke();co.fill();\n    }\n    this.total = runningTotal;if (prop['chart.total']) {\n      h = this.getYCoord(0) - this.getYCoord(ma.abs(runningTotal));if (prop['chart.xaxispos'] == 'center') {\n        y = runningTotal > 0 ? this.getYCoord(0) - h : this.getYCoord(0);\n      } else {\n        if (runningTotal > 0) {\n          y = this.getYCoord(0) - h;\n        } else {\n          y = this.getYCoord(0);\n        }\n      }\n      x = x + prop['chart.hmargin'] * 2 + w;co.fillStyle = prop['chart.colors'][2];pa2(co, 'b r % % % % s % f %', x, y, w, h, co.strokeStyle, co.fillStyle);var previousCoords = [x, y, w, ma.abs(h)];this.coords.push(previousCoords);\n    }\n    RG.noShadow(this);co.lineWidth = 1;co.strokeStyle = '#666';co.beginPath();for (var i = 1, len = this.coords.length; i < len; i += 1) {\n      var prev = this.coords[i - 1],\n          curr = this.coords[i],\n          prevData = this.data[i - 1];\n      var y = prevData > 0 ? prev[1] : prev[1] + prev[3];co.moveTo(prev[0] + prev[2], y);co.lineTo(curr[0], prevData > 0 ? prev[1] : prev[1] + prev[3]);\n    }\n    co.stroke();\n  };this.getShape = this.getBar = function (e) {\n    for (var i = 0, len = this.coords.length; i < len; i++) {\n      var mouseXY = RG.getMouseXY(e),\n          mouseX = mouseXY[0],\n          mouseY = mouseXY[1];var left = this.coords[i][0],\n          top = this.coords[i][1],\n          width = this.coords[i][2],\n          height = this.coords[i][3];if (mouseX >= left && mouseX <= left + width && mouseY >= top && mouseY <= top + height) {\n        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);return { 0: this, object: this, 1: left, x: left, 2: top, y: top, 3: width, width: width, 4: height, height: height, 5: i, index: i, tooltip: tooltip };\n      }\n    }\n    return null;\n  };this.getMax = function (data) {\n    var runningTotal = 0,\n        max = 0;for (var i = 0, len = data.length; i < len; i += 1) {\n      runningTotal += data[i];max = ma.max(ma.abs(runningTotal), max);\n    }\n    return ma.abs(max);\n  };this.allowTooltips = this.AllowTooltips = function () {\n    RG.PreLoadTooltipImages(this);RG.InstallWindowMousedownTooltipListener(this);RG.InstallCanvasMousemoveTooltipListener(this);RG.InstallCanvasMouseupTooltipListener(this);\n  };this.highlight = this.Highlight = function (shape) {\n    if (typeof prop['chart.highlight.style'] === 'function') {\n      prop['chart.highlight.style'](shape);\n    } else {\n      RG.Highlight.Rect(this, shape);\n    }\n  };this.getObjectByXY = function (e) {\n    var mouseXY = RG.getMouseXY(e);if (mouseXY[0] > this.gutterLeft && mouseXY[0] < ca.width - this.gutterRight && mouseXY[1] > this.gutterTop && mouseXY[1] < ca.height - this.gutterBottom) {\n      return this;\n    }\n  };this.getYCoord = function (value) {\n    if (prop['chart.xaxispos'] == 'center') {\n      if (value < -1 * this.max) {\n        return null;\n      }\n      var coord = value / this.max * (this.grapharea / 2);return this.gutterTop + this.grapharea / 2 - coord;\n    } else {\n      var coord = (value - this.scale2.min) / (this.max - this.scale2.min) * this.grapharea;coord = coord + this.gutterBottom;return ca.height - coord;\n    }\n  };this.parseColors = function () {\n    if (this.original_colors.length === 0) {\n      this.original_colors['chart.colors'] = RG.array_clone(prop['chart.colors']);this.original_colors['chart.key.colors'] = RG.array_clone(prop['chart.key.colors']);this.original_colors['chart.crosshairs.color'] = RG.array_clone(prop['chart.crosshairs.color']);this.original_colors['chart.highlight.stroke'] = RG.array_clone(prop['chart.highlight.stroke']);this.original_colors['chart.highlight.fill'] = RG.array_clone(prop['chart.highlight.fill']);this.original_colors['chart.background.barcolor1'] = RG.array_clone(prop['chart.background.barcolor1']);this.original_colors['chart.background.barcolor2'] = RG.array_clone(prop['chart.background.barcolor2']);this.original_colors['chart.background.grid.color'] = RG.array_clone(prop['chart.background.grid.color']);this.original_colors['chart.strokestyle'] = RG.array_clone(prop['chart.strokestyle']);this.original_colors['chart.axis.color'] = RG.array_clone(prop['chart.axis.color']);\n    }\n    var colors = prop['chart.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    var colors = prop['chart.key.colors'];if (colors) {\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        colors[i] = this.parseSingleColorForGradient(colors[i]);\n      }\n    }\n    prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);prop['chart.strokestyle'] = this.parseSingleColorForGradient(prop['chart.strokestyle']);prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);\n  };this.reset = function () {};this.parseSingleColorForGradient = function (color) {\n    if (!color || typeof color != 'string') {\n      return color;\n    }\n    if (typeof color === 'string' && color.match(/^gradient\\((.*)\\)$/i)) {\n      var parts = RegExp.$1.split(':');var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);var diff = 1 / (parts.length - 1);grad.addColorStop(0, RG.trim(parts[0]));for (var j = 1, len = parts.length; j < len; ++j) {\n        grad.addColorStop(j * diff, RG.trim(parts[j]));\n      }\n    }\n    return grad ? grad : color;\n  };this.on = function (type, func) {\n    if (type.substr(0, 2) !== 'on') {\n      type = 'on' + type;\n    }\n    if (typeof this[type] !== 'function') {\n      this[type] = func;\n    } else {\n      RG.addCustomEventListener(this, type, func);\n    }\n    return this;\n  };this.firstDrawFunc = function () {};this.grow = function () {\n    var opt = arguments[0] || {};var callback = arguments[1] || function () {};var frames = opt.frames || 30;var numFrame = 0;var obj = this;var data = RG.array_clone(obj.data);for (var i = 0, len = obj.data.length; i < len; ++i) {\n      obj.data[i] /= frames;\n    }\n    if (obj.Get('chart.ymax') == null) {\n      var max = obj.getMax(data);var scale2 = RG.getScale2(obj, { 'max': max });obj.Set('chart.ymax', scale2.max);\n    }\n    function iterator() {\n      for (var i = 0; i < obj.data.length; ++i) {\n        obj.data[i] = data[i] * RG.Effects.getEasingMultiplier(frames, numFrame);\n      }\n      RGraph.clear(obj.canvas);RGraph.redrawCanvas(obj.canvas);if (++numFrame < frames) {\n        RGraph.Effects.updateCanvas(iterator);\n      } else {\n        callback(obj);\n      }\n    }\n    iterator();return this;\n  };RG.att(ca);RG.Register(this);if (parseConfObjectForOptions) {\n    RG.parseObjectStyleConfig(this, conf.options);\n  }\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3RoZXJfY29tcG9uZW50cy9yZ3JhcGgvbGlicmFyaWVzL1JHcmFwaC53YXRlcmZhbGwuanM/OTJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblJHcmFwaCA9IHdpbmRvdy5SR3JhcGggfHwgeyBpc1JHcmFwaDogdHJ1ZSB9O1JHcmFwaC5XYXRlcmZhbGwgPSBmdW5jdGlvbiAoY29uZikge1xuICB2YXIgX3Byb3BlcnRpZXM7XG5cbiAgaWYgKCh0eXBlb2YgY29uZiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZikpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGNvbmYuZGF0YSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25mLmlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29uZiA9IHsgaWQ6IGNvbmYsIGRhdGE6IGFyZ3VtZW50c1sxXSB9O1xuICB9XG4gIHRoaXMuaWQgPSBjb25mLmlkO3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCA/IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSA6IG51bGw7dGhpcy5jYW52YXMuX19vYmplY3RfXyA9IHRoaXM7dGhpcy50eXBlID0gJ3dhdGVyZmFsbCc7dGhpcy5tYXggPSAwO3RoaXMuZGF0YSA9IGNvbmYuZGF0YTt0aGlzLmlzUkdyYXBoID0gdHJ1ZTt0aGlzLmNvb3JkcyA9IFtdO3RoaXMudWlkID0gUkdyYXBoLkNyZWF0ZVVJRCgpO3RoaXMuY2FudmFzLnVpZCA9IHRoaXMuY2FudmFzLnVpZCA/IHRoaXMuY2FudmFzLnVpZCA6IFJHcmFwaC5DcmVhdGVVSUQoKTt0aGlzLmNvbG9yc1BhcnNlZCA9IGZhbHNlO3RoaXMuY29vcmRzVGV4dCA9IFtdO3RoaXMub3JpZ2luYWxfY29sb3JzID0gW107dGhpcy5maXJzdERyYXcgPSB0cnVlO3RoaXMucHJvcGVydGllcyA9IChfcHJvcGVydGllcyA9IHsgJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJzogJ3JnYmEoMCwwLDAsMCknLCAnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInOiAncmdiYSgwLDAsMCwwKScsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJzogJyNkZGQnLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLndpZHRoJzogMSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5oc2l6ZSc6IDIwLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLnZzaXplJzogMjAsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQudmxpbmVzJzogdHJ1ZSwgJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5obGluZXMnOiB0cnVlLCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmJvcmRlcic6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdCc6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5hbGlnbic6IHRydWUsICdjaGFydC5iYWNrZ3JvdW5kLmdyaWQuYXV0b2ZpdC5udW1obGluZXMnOiA1LCAnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmF1dG9maXQubnVtdmxpbmVzJzogMjAsICdjaGFydC5iYWNrZ3JvdW5kLmltYWdlJzogbnVsbCwgJ2NoYXJ0LmJhY2tncm91bmQuaGJhcnMnOiBudWxsLCAnY2hhcnQubGluZXdpZHRoJzogMSwgJ2NoYXJ0LmF4aXMubGluZXdpZHRoJzogMSwgJ2NoYXJ0LnhheGlzcG9zJzogJ2JvdHRvbScsICdjaGFydC5udW14dGlja3MnOiBudWxsLCAnY2hhcnQubnVteXRpY2tzJzogMTAsICdjaGFydC5obWFyZ2luJzogNSwgJ2NoYXJ0LnN0cm9rZXN0eWxlJzogJyM2NjYnLCAnY2hhcnQuYXhpcy5jb2xvcic6ICdibGFjaycsICdjaGFydC5ndXR0ZXIubGVmdCc6IDI1LCAnY2hhcnQuZ3V0dGVyLnJpZ2h0JzogMjUsICdjaGFydC5ndXR0ZXIudG9wJzogMjUsICdjaGFydC5ndXR0ZXIuYm90dG9tJzogMjUsICdjaGFydC5sYWJlbHMnOiBbXSwgJ2NoYXJ0LmxhYmVscy5ib2xkJzogZmFsc2UsICdjaGFydC5sYWJlbHMub2Zmc2V0eCc6IDAsICdjaGFydC5sYWJlbHMub2Zmc2V0eSc6IDAsICdjaGFydC55bGFiZWxzLm9mZnNldHgnOiAwLCAnY2hhcnQueWxhYmVscy5vZmZzZXR5JzogMCwgJ2NoYXJ0LnlsYWJlbHMnOiB0cnVlLCAnY2hhcnQudGV4dC5jb2xvcic6ICdibGFjaycsICdjaGFydC50ZXh0LnNpemUnOiAxMiwgJ2NoYXJ0LnRleHQuYW5nbGUnOiAwLCAnY2hhcnQudGV4dC5mb250JzogJ1NlZ29lIFVJLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsICdjaGFydC50ZXh0LmFjY2Vzc2libGUnOiB0cnVlLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLm92ZXJmbG93JzogJ3Zpc2libGUnLCAnY2hhcnQudGV4dC5hY2Nlc3NpYmxlLnBvaW50ZXJldmVudHMnOiB0cnVlLCAnY2hhcnQueW1heCc6IG51bGwsICdjaGFydC50aXRsZSc6ICcnLCAnY2hhcnQudGl0bGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQudGl0bGUuYmFja2dyb3VuZCc6IG51bGwsICdjaGFydC50aXRsZS5ocG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnZwb3MnOiBudWxsLCAnY2hhcnQudGl0bGUuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzJzogJycsICdjaGFydC50aXRsZS55YXhpcyc6ICcnLCAnY2hhcnQudGl0bGUueWF4aXMuYm9sZCc6IHRydWUsICdjaGFydC50aXRsZS55YXhpcy5zaXplJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLmZvbnQnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMuY29sb3InOiBudWxsLCAnY2hhcnQudGl0bGUueGF4aXMucG9zJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLnBvcyc6IG51bGwsICdjaGFydC50aXRsZS55YXhpcy5hbGlnbic6ICdsZWZ0JywgJ2NoYXJ0LnRpdGxlLnhheGlzLmJvbGQnOiB0cnVlLCAnY2hhcnQudGl0bGUueGF4aXMuc2l6ZSc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy5mb250JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLmNvbG9yJzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnlheGlzLngnOiBudWxsLCAnY2hhcnQudGl0bGUueWF4aXMueSc6IG51bGwsICdjaGFydC50aXRsZS54YXhpcy54JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLnhheGlzLnknOiBudWxsLCAnY2hhcnQudGl0bGUueCc6IG51bGwsICdjaGFydC50aXRsZS55JzogbnVsbCwgJ2NoYXJ0LnRpdGxlLmhhbGlnbic6IG51bGwsICdjaGFydC50aXRsZS52YWxpZ24nOiBudWxsLCAnY2hhcnQuY29sb3JzJzogWydncmVlbicsICdyZWQnLCAnYmx1ZSddLCAnY2hhcnQuc2hhZG93JzogZmFsc2UsICdjaGFydC5zaGFkb3cuY29sb3InOiAnIzY2NicsICdjaGFydC5zaGFkb3cub2Zmc2V0eCc6IDMsICdjaGFydC5zaGFkb3cub2Zmc2V0eSc6IDMsICdjaGFydC5zaGFkb3cuYmx1cic6IDMsICdjaGFydC50b29sdGlwcyc6IG51bGwsICdjaGFydC50b29sdGlwcy5lZmZlY3QnOiAnZmFkZScsICdjaGFydC50b29sdGlwcy5jc3MuY2xhc3MnOiAnUkdyYXBoX3Rvb2x0aXAnLCAnY2hhcnQudG9vbHRpcHMuZXZlbnQnOiAnb25jbGljaycsICdjaGFydC50b29sdGlwcy5oaWdobGlnaHQnOiB0cnVlLCAnY2hhcnQudG9vbHRpcHMub3ZlcnJpZGUnOiBudWxsLCAnY2hhcnQuaGlnaGxpZ2h0LnN0cm9rZSc6ICdyZ2JhKDAsMCwwLDApJywgJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC43KScsICdjaGFydC5jb250ZXh0bWVudSc6IG51bGwsICdjaGFydC51bml0cy5wcmUnOiAnJywgJ2NoYXJ0LnVuaXRzLnBvc3QnOiAnJywgJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJzogMCwgJ2NoYXJ0LnNjYWxlLnBvaW50JzogJy4nLCAnY2hhcnQuc2NhbGUudGhvdXNhbmQnOiAnLCcsICdjaGFydC5zY2FsZS56ZXJvc3RhcnQnOiB0cnVlLCAnY2hhcnQuY3Jvc3NoYWlycyc6IGZhbHNlLCAnY2hhcnQuY3Jvc3NoYWlycy5jb2xvcic6ICcjMzMzJywgJ2NoYXJ0LmNyb3NzaGFpcnMuaGxpbmUnOiB0cnVlLCAnY2hhcnQuY3Jvc3NoYWlycy52bGluZSc6IHRydWUsICdjaGFydC5hbm5vdGF0YWJsZSc6IGZhbHNlLCAnY2hhcnQuYW5ub3RhdGUuY29sb3InOiAnYmxhY2snLCAnY2hhcnQuem9vbS5mYWN0b3InOiAxLjUsICdjaGFydC56b29tLmZhZGUuaW4nOiB0cnVlLCAnY2hhcnQuem9vbS5mYWRlLm91dCc6IHRydWUsICdjaGFydC56b29tLmhkaXInOiAncmlnaHQnLCAnY2hhcnQuem9vbS52ZGlyJzogJ2Rvd24nLCAnY2hhcnQuem9vbS5mcmFtZXMnOiAyNSwgJ2NoYXJ0Lnpvb20uZGVsYXknOiAxNi42NjYsICdjaGFydC56b29tLnNoYWRvdyc6IHRydWUsICdjaGFydC56b29tLmJhY2tncm91bmQnOiB0cnVlLCAnY2hhcnQucmVzaXphYmxlJzogZmFsc2UsICdjaGFydC5yZXNpemUuaGFuZGxlLmJhY2tncm91bmQnOiBudWxsLCAnY2hhcnQubm9heGVzJzogZmFsc2UsICdjaGFydC5ub3hheGlzJzogZmFsc2UsICdjaGFydC5ub3lheGlzJzogZmFsc2UgfSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQuYXhpcy5jb2xvcicsICdibGFjaycpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC50b3RhbCcsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5tdWx0aXBsaWVyLngnLCAxKSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQubXVsdGlwbGllci53JywgMSksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LmV2ZW50cy5jbGljaycsIG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5ldmVudHMubW91c2Vtb3ZlJywgbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfcHJvcGVydGllcywgJ2NoYXJ0LnlsYWJlbHMuY291bnQnLCA1KSwgX2RlZmluZVByb3BlcnR5KF9wcm9wZXJ0aWVzLCAnY2hhcnQueW1pbicsIDApLCBfZGVmaW5lUHJvcGVydHkoX3Byb3BlcnRpZXMsICdjaGFydC5jbGVhcnRvJywgJ3JnYmEoMCwwLDAsMCknKSwgX3Byb3BlcnRpZXMpO1xuICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgYWxlcnQoJ1tXQVRFUkZBTExdIE5vIGNhbnZhcyBzdXBwb3J0Jyk7cmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoOyBpIDw9IGxlbjsgKytpKSB7XG4gICAgdGhpc1snJCcgKyBpXSA9IHt9O1xuICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5kYXRhW2ldID0gcGFyc2VGbG9hdCh0aGlzLmRhdGFbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAoIXRoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXykge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO3RoaXMuY2FudmFzLl9fcmdyYXBoX2FhX3RyYW5zbGF0ZWRfXyA9IHRydWU7XG4gIH1cbiAgdmFyIFJHID0gUkdyYXBoLFxuICAgICAgY2EgPSB0aGlzLmNhbnZhcyxcbiAgICAgIGNvID0gY2EuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIHByb3AgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICBwYTIgPSBSRy5wYXRoMixcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIGRvYyA9IGRvY3VtZW50LFxuICAgICAgbWEgPSBNYXRoO1xuICBpZiAoUkcuRWZmZWN0cyAmJiB0eXBlb2YgUkcuRWZmZWN0cy5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJHLkVmZmVjdHMuZGVjb3JhdGUodGhpcyk7XG4gIH1cbiAgdGhpcy5zZXQgPSB0aGlzLlNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIFJHLnBhcnNlT2JqZWN0U3R5bGVDb25maWcodGhpcywgbmFtZSk7cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gJ2NoYXJ0LnRvdGFsJyAmJiBwcm9wWydjaGFydC5udW14dGlja3MnXSA9PSBudWxsKSB7XG4gICAgICBwcm9wWydjaGFydC5udW14dGlja3MnXSA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO3JldHVybiB0aGlzO1xuICB9O3RoaXMuZ2V0ID0gdGhpcy5HZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLnN1YnN0cigwLCA2KSAhPSAnY2hhcnQuJykge1xuICAgICAgbmFtZSA9ICdjaGFydC4nICsgbmFtZTtcbiAgICB9XG4gICAgd2hpbGUgKG5hbWUubWF0Y2goLyhbQS1aXSkvKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvKFtBLVpdKS8sICcuJyArIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfTt0aGlzLmRyYXcgPSB0aGlzLkRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgUkdyYXBoLmZpcmVDdXN0b21FdmVudCh0aGlzLCAnb25iZWZvcmVkcmF3Jyk7aWYgKCF0aGlzLmNvbG9yc1BhcnNlZCkge1xuICAgICAgdGhpcy5wYXJzZUNvbG9ycygpO3RoaXMuY29sb3JzUGFyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgUkdyYXBoLkRyYXdCYWNrZ3JvdW5kSW1hZ2UodGhpcyk7dGhpcy5ndXR0ZXJMZWZ0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLmxlZnQnXTt0aGlzLmd1dHRlclJpZ2h0ID0gcHJvcFsnY2hhcnQuZ3V0dGVyLnJpZ2h0J107dGhpcy5ndXR0ZXJUb3AgPSBwcm9wWydjaGFydC5ndXR0ZXIudG9wJ107dGhpcy5ndXR0ZXJCb3R0b20gPSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ107dGhpcy5jb29yZHMgPSBbXTt0aGlzLmNvb3Jkc1RleHQgPSBbXTt0aGlzLmNlbnRlcnkgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3A7dGhpcy5tYXggPSAwO3RoaXMuZ3JhcGhhcmVhID0gY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbTt0aGlzLmdyYXBod2lkdGggPSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQ7dGhpcy5oYWxmVGV4dEhlaWdodCA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddIC8gMjt0aGlzLm1heCA9IHRoaXMuZ2V0TWF4KHRoaXMuZGF0YSk7dmFyIGRlY2ltYWxzID0gcHJvcFsnY2hhcnQuc2NhbGUuZGVjaW1hbHMnXTt0aGlzLnNjYWxlMiA9IFJHLmdldFNjYWxlMih0aGlzLCB7IG1heDogdHlwZW9mIHByb3BbJ2NoYXJ0LnltYXgnXSA9PSAnbnVtYmVyJyA/IHByb3BbJ2NoYXJ0LnltYXgnXSA6IHRoaXMubWF4LCBtaW46IHByb3BbJ2NoYXJ0LnltaW4nXSwgc3RyaWN0OiB0eXBlb2YgcHJvcFsnY2hhcnQueW1heCddID09PSAnbnVtYmVyJyA/IHRydWUgOiBmYWxzZSwgJ3NjYWxlLmRlY2ltYWxzJzogTnVtYmVyKGRlY2ltYWxzKSwgJ3NjYWxlLnBvaW50JzogcHJvcFsnY2hhcnQuc2NhbGUucG9pbnQnXSwgJ3NjYWxlLnRob3VzYW5kJzogcHJvcFsnY2hhcnQuc2NhbGUudGhvdXNhbmQnXSwgJ3NjYWxlLnJvdW5kJzogcHJvcFsnY2hhcnQuc2NhbGUucm91bmQnXSwgJ3VuaXRzLnByZSc6IHByb3BbJ2NoYXJ0LnVuaXRzLnByZSddLCAndW5pdHMucG9zdCc6IHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSwgJ3lsYWJlbHMuY291bnQnOiBwcm9wWydjaGFydC55bGFiZWxzLmNvdW50J10gfSk7dGhpcy5tYXggPSB0aGlzLnNjYWxlMi5tYXg7dGhpcy5taW4gPSB0aGlzLnNjYWxlMi5taW47UkcuZHJhd0JhcnModGhpcyk7XG4gICAgUkcuQmFja2dyb3VuZC5kcmF3KHRoaXMpO3RoaXMuRHJhd0F4ZXMoKTt0aGlzLkRyYXdiYXJzKCk7dGhpcy5EcmF3TGFiZWxzKCk7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT09ICdib3R0b20nICYmIHByb3BbJ2NoYXJ0Lm5vYXhlcyddID09PSBmYWxzZSAmJiBwcm9wWydjaGFydC5ub3hheGlzJ10gPT09IGZhbHNlICYmIHByb3BbJ2NoYXJ0LnltaW4nXSA9PT0gMCkge1xuICAgICAgY28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5heGlzLmNvbG9yJ107Y28uc3Ryb2tlUmVjdChwcm9wWydjaGFydC5ndXR0ZXIubGVmdCddLCBjYS5oZWlnaHQgLSBwcm9wWydjaGFydC5ndXR0ZXIuYm90dG9tJ10sIGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJMZWZ0IC0gdGhpcy5ndXR0ZXJSaWdodCwgMCk7XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5jb250ZXh0bWVudSddKSB7XG4gICAgICBSRy5TaG93Q29udGV4dCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnJlc2l6YWJsZSddKSB7XG4gICAgICBSRy5BbGxvd1Jlc2l6aW5nKHRoaXMpO1xuICAgIH1cbiAgICBSRy5JbnN0YWxsRXZlbnRMaXN0ZW5lcnModGhpcyk7aWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICBSRy5maXJlQ3VzdG9tRXZlbnQodGhpcywgJ29uZmlyc3RkcmF3Jyk7dGhpcy5maXJzdERyYXcgPSBmYWxzZTt0aGlzLmZpcnN0RHJhd0Z1bmMoKTtcbiAgICB9XG4gICAgUkcuRmlyZUN1c3RvbUV2ZW50KHRoaXMsICdvbmRyYXcnKTtyZXR1cm4gdGhpcztcbiAgfTt0aGlzLmRyYXdBeGVzID0gdGhpcy5EcmF3QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvcFsnY2hhcnQubm9heGVzJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY28uYmVnaW5QYXRoKCk7Y28uc3Ryb2tlU3R5bGUgPSBwcm9wWydjaGFydC5heGlzLmNvbG9yJ107Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQuYXhpcy5saW5ld2lkdGgnXSArIDAuMDAxO2lmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT0gZmFsc2UpIHtcbiAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLCB0aGlzLmd1dHRlclRvcCk7Y28ubGluZVRvKG1hLnJvdW5kKHRoaXMuZ3V0dGVyTGVmdCksIGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tKTtcbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSA9PSBmYWxzZSkge1xuICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY28ubW92ZVRvKHRoaXMuZ3V0dGVyTGVmdCwgbWEucm91bmQoKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiArIHRoaXMuZ3V0dGVyVG9wKSk7Y28ubGluZVRvKGNhLndpZHRoIC0gdGhpcy5ndXR0ZXJSaWdodCwgbWEucm91bmQoKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gMiArIHRoaXMuZ3V0dGVyVG9wKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeSA9IG1hLmZsb29yKHRoaXMuZ2V0WUNvb3JkKDApKTtjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCB5KTtjby5saW5lVG8oY2Eud2lkdGggLSB0aGlzLmd1dHRlclJpZ2h0LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG51bVlUaWNrcyA9IHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddO2lmIChwcm9wWydjaGFydC5ub3lheGlzJ10gPT09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm51bXl0aWNrcyddID4gMCkge1xuICAgICAgdmFyIHlUaWNrR2FwID0gKGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyVG9wIC0gdGhpcy5ndXR0ZXJCb3R0b20pIC8gbnVtWVRpY2tzO2ZvciAoeSA9IHRoaXMuZ3V0dGVyVG9wOyB5IDwgY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b207IHkgKz0geVRpY2tHYXApIHtcbiAgICAgICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2JvdHRvbScgfHwgeSAhPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3ApIHtcbiAgICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0LCBtYS5yb3VuZCh5KSk7Y28ubGluZVRvKHRoaXMuZ3V0dGVyTGVmdCAtIDMsIG1hLnJvdW5kKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0Lm5veGF4aXMnXSB8fCBwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInIHx8IHByb3BbJ2NoYXJ0LnltaW4nXSAhPT0gMCkge1xuICAgICAgICBjby5tb3ZlVG8odGhpcy5ndXR0ZXJMZWZ0IC0gMywgTWF0aC5yb3VuZChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkpO2NvLmxpbmVUbyh0aGlzLmd1dHRlckxlZnQsIE1hdGgucm91bmQoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJCb3R0b20pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID09IG51bGwpIHtcbiAgICAgIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID0gdGhpcy5kYXRhLmxlbmd0aCArIChwcm9wWydjaGFydC50b3RhbCddID8gMSA6IDApO1xuICAgIH1cbiAgICBpZiAocHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlICYmIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddID4gMCkge1xuICAgICAgeFRpY2tHYXAgPSAoY2Eud2lkdGggLSB0aGlzLmd1dHRlckxlZnQgLSB0aGlzLmd1dHRlclJpZ2h0KSAvIHByb3BbJ2NoYXJ0Lm51bXh0aWNrcyddO2lmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgIHlTdGFydCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSAtIHRoaXMuZ3V0dGVyVG9wKSAvIDIgKyB0aGlzLmd1dHRlclRvcCAtIDM7eUVuZCA9IChjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSAtIHRoaXMuZ3V0dGVyVG9wKSAvIDIgKyB0aGlzLmd1dHRlclRvcCArIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5U3RhcnQgPSB0aGlzLmdldFlDb29yZCgwKSAtICh0aGlzLnNjYWxlMi5taW4gPCAwID8gMyA6IDApO3lFbmQgPSB0aGlzLmdldFlDb29yZCgwKSArIDM7XG4gICAgICB9XG4gICAgICBmb3IgKHggPSB0aGlzLmd1dHRlckxlZnQgKyB4VGlja0dhcDsgeCA8PSBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgKyAxOyB4ICs9IHhUaWNrR2FwKSB7XG4gICAgICAgIGNvLm1vdmVUbyhtYS5yb3VuZCh4KSwgeVN0YXJ0KTtjby5saW5lVG8obWEucm91bmQoeCksIHlFbmQpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BbJ2NoYXJ0Lm5veWF4aXMnXSkge1xuICAgICAgICBjby5tb3ZlVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSwgeVN0YXJ0KTtjby5saW5lVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSwgeUVuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5ub3lheGlzJ10gJiYgcHJvcFsnY2hhcnQubm94YXhpcyddID09IGZhbHNlKSB7XG4gICAgICBjby5tb3ZlVG8obWEucm91bmQodGhpcy5ndXR0ZXJMZWZ0KSwgdGhpcy5nZXRZQ29vcmQoMCkpO2NvLmxpbmVUbyhtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQpLCB0aGlzLmdldFlDb29yZCgwKSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1xuICB9O3RoaXMuZHJhd0xhYmVscyA9IHRoaXMuRHJhd0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dCA9IGNvLFxuICAgICAgICBudW1ZTGFiZWxzID0gNSxcbiAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLmdyYXBoYXJlYSAvIG51bVlMYWJlbHMsXG4gICAgICAgIGZvbnQgPSBwcm9wWydjaGFydC50ZXh0LmZvbnQnXSxcbiAgICAgICAgc2l6ZSA9IHByb3BbJ2NoYXJ0LnRleHQuc2l6ZSddLFxuICAgICAgICBjb2xvciA9IHByb3BbJ2NoYXJ0LnRleHQuY29sb3InXSxcbiAgICAgICAgdW5pdHNfcHJlID0gcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sXG4gICAgICAgIHVuaXRzX3Bvc3QgPSBwcm9wWydjaGFydC51bml0cy5wb3N0J10sXG4gICAgICAgIG9mZnNldHggPSBwcm9wWydjaGFydC55bGFiZWxzLm9mZnNldHgnXSxcbiAgICAgICAgb2Zmc2V0eSA9IHByb3BbJ2NoYXJ0LnlsYWJlbHMub2Zmc2V0eSddO2NvLmJlZ2luUGF0aCgpO2NvLmZpbGxTdHlsZSA9IGNvbG9yO2lmIChwcm9wWydjaGFydC55bGFiZWxzJ10pIHtcbiAgICAgIGlmIChwcm9wWydjaGFydC54YXhpc3BvcyddID09ICdjZW50ZXInKSB7XG4gICAgICAgIHZhciBoYWxmSW50ZXJ2YWwgPSBpbnRlcnZhbCAvIDI7dmFyIGhhbGZXYXkgPSAoY2EuaGVpZ2h0IC0gdGhpcy5ndXR0ZXJUb3AgLSB0aGlzLmd1dHRlckJvdHRvbSkgLyAyICsgdGhpcy5ndXR0ZXJUb3A7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2NhbGUyLmxhYmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIFJHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogdGhpcy5ndXR0ZXJMZWZ0IC0gNSArIG9mZnNldHgsIHk6IHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyIC8gbGVuICogaSArIG9mZnNldHksIHRleHQ6IHRoaXMuc2NhbGUyLmxhYmVsc1tsZW4gLSBpIC0gMV0sIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogJ3JpZ2h0JywgdGFnOiAnc2NhbGUnIH0pO1JHLnRleHQyKHRoaXMsIHsgZm9udDogZm9udCwgc2l6ZTogc2l6ZSwgeDogdGhpcy5ndXR0ZXJMZWZ0IC0gNSArIG9mZnNldHgsIHk6IGhhbGZXYXkgKyB0aGlzLmdyYXBoYXJlYSAvIDIgLyBsZW4gKiAoaSArIDEpICsgb2Zmc2V0eSwgdGV4dDogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCB2YWxpZ246ICdjZW50ZXInLCBoYWxpZ246ICdyaWdodCcsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10pIHtcbiAgICAgICAgICBSRy50ZXh0MihjbywgeyB4OiB0aGlzLmd1dHRlckxlZnQgLSA1ICsgb2Zmc2V0eCwgeTogaGFsZldheSwgdGV4dDogJzAnLCBmb250OiBmb250LCBzaXplOiBzaXplLCB2YWxpZ246ICdjZW50ZXInLCBoYWxpZ246ICdyaWdodCcsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2NhbGUyLnZhbHVlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5nZXRZQ29vcmQodGhpcy5zY2FsZTIudmFsdWVzW2ldKSArIG9mZnNldHk7UkcudGV4dDIodGhpcywgeyBmb250OiBmb250LCBzaXplOiBzaXplLCB4OiB0aGlzLmd1dHRlckxlZnQgLSA1ICsgb2Zmc2V0eCwgeTogeSwgdGV4dDogdGhpcy5zY2FsZTIubGFiZWxzW2ldLCB2YWxpZ246ICdjZW50ZXInLCBoYWxpZ246ICdyaWdodCcsIHRhZzogJ3NjYWxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFsnY2hhcnQuc2NhbGUuemVyb3N0YXJ0J10gfHwgcHJvcFsnY2hhcnQueW1pbiddICE9PSAwKSB7XG4gICAgICAgICAgUkcudGV4dDIoY28sIHsgeDogdGhpcy5ndXR0ZXJMZWZ0IC0gNSArIG9mZnNldHgsIHk6IHRoaXMuZ2V0WUNvb3JkKHByb3BbJ2NoYXJ0LnltaW4nXSB8fCAwKSwgdGV4dDogUkcubnVtYmVyRm9ybWF0KHRoaXMsIFN0cmluZyhOdW1iZXIocHJvcFsnY2hhcnQueW1pbiddIHx8IDApLnRvRml4ZWQocHJvcFsnY2hhcnQueW1pbiddID09PSAwID8gMCA6IHByb3BbJ2NoYXJ0LnNjYWxlLmRlY2ltYWxzJ10pKSwgcHJvcFsnY2hhcnQudW5pdHMucHJlJ10sIHByb3BbJ2NoYXJ0LnVuaXRzLnBvc3QnXSksIGZvbnQ6IGZvbnQsIHNpemU6IHNpemUsIHZhbGlnbjogJ2NlbnRlcicsIGhhbGlnbjogJ3JpZ2h0JywgdGFnOiAnc2NhbGUnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wWydjaGFydC5sYWJlbHMnXS5sZW5ndGggPiAwKSB7XG4gICAgICBpbnRlcnZhbCA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gcHJvcFsnY2hhcnQubGFiZWxzJ10ubGVuZ3RoO3ZhciBoYWxpZ24gPSAnY2VudGVyJzt2YXIgYW5nbGUgPSBwcm9wWydjaGFydC50ZXh0LmFuZ2xlJ107aWYgKGFuZ2xlKSB7XG4gICAgICAgIGhhbGlnbiA9ICdyaWdodCc7YW5nbGUgKj0gLTE7XG4gICAgICB9XG4gICAgICB2YXIgbGFiZWxzID0gcHJvcFsnY2hhcnQubGFiZWxzJ10sXG4gICAgICAgICAgbGFiZWxzQ29sb3IgPSBwcm9wWydjaGFydC5sYWJlbHMuY29sb3InXSxcbiAgICAgICAgICBib2xkID0gcHJvcFsnY2hhcnQubGFiZWxzLmJvbGQnXSxcbiAgICAgICAgICBvZmZzZXR4ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHgnXSxcbiAgICAgICAgICBvZmZzZXR5ID0gcHJvcFsnY2hhcnQubGFiZWxzLm9mZnNldHknXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgUkcudGV4dDIodGhpcywgeyAnY29sb3InOiBsYWJlbHNDb2xvciwgJ2ZvbnQnOiBmb250LCAnc2l6ZSc6IHNpemUsICdib2xkJzogYm9sZCwgJ3gnOiB0aGlzLmd1dHRlckxlZnQgKyBpICogaW50ZXJ2YWwgKyBpbnRlcnZhbCAvIDIgKyBvZmZzZXR4LCAneSc6IGNhLmhlaWdodCAtIHRoaXMuZ3V0dGVyQm90dG9tICsgNSArIHRoaXMuaGFsZlRleHRIZWlnaHQgKyBvZmZzZXR5LCAndGV4dCc6IGxhYmVsc1tpXSwgJ3ZhbGlnbic6ICdjZW50ZXInLCAnaGFsaWduJzogaGFsaWduLCAnYW5nbGUnOiBhbmdsZSwgJ3RhZyc6ICdsYWJlbHMnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjby5zdHJva2UoKTtjby5maWxsKCk7XG4gIH07dGhpcy5kcmF3YmFycyA9IHRoaXMuRHJhd2JhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBjbyxcbiAgICAgICAgY2FudmFzID0gY2EsXG4gICAgICAgIGhtYXJnaW4gPSBwcm9wWydjaGFydC5obWFyZ2luJ10sXG4gICAgICAgIHJ1bm5pbmdUb3RhbCA9IDA7Y28ubGluZVdpZHRoID0gcHJvcFsnY2hhcnQubGluZXdpZHRoJ10gKyAwLjAwMTtmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjby5iZWdpblBhdGgoKTtjby5zdHJva2VTdHlsZSA9IHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ107dmFyIHggPSBtYS5yb3VuZCh0aGlzLmd1dHRlckxlZnQgKyBobWFyZ2luICsgdGhpcy5ncmFwaHdpZHRoIC8gKHRoaXMuZGF0YS5sZW5ndGggKyAocHJvcFsnY2hhcnQudG90YWwnXSA/IDEgOiAwKSkgKiBpICogcHJvcFsnY2hhcnQubXVsdGlwbGllci54J10pO3ZhciBoID0gdGhpcy5nZXRZQ29vcmQoMCkgLSB0aGlzLmdldFlDb29yZChtYS5hYnModGhpcy5kYXRhW2ldKSk7aWYgKGkgPT09IDApIHtcbiAgICAgICAgeSA9IHRoaXMuZ2V0WUNvb3JkKDApIC0gaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSB0aGlzLmdldFlDb29yZChydW5uaW5nVG90YWwpIC0gaDtcbiAgICAgIH1cbiAgICAgIHkgPSBtYS5yb3VuZCh5KTt2YXIgdyA9IChjYS53aWR0aCAtIHRoaXMuZ3V0dGVyTGVmdCAtIHRoaXMuZ3V0dGVyUmlnaHQpIC8gKHRoaXMuZGF0YS5sZW5ndGggKyAocHJvcFsnY2hhcnQudG90YWwnXSA/IDEgOiAwKSkgLSAyICogcHJvcFsnY2hhcnQuaG1hcmdpbiddO3cgPSB3ICogcHJvcFsnY2hhcnQubXVsdGlwbGllci53J107aWYgKHRoaXMuZGF0YVtpXSA8IDApIHtcbiAgICAgICAgeSArPSBoO1xuICAgICAgfVxuICAgICAgY28uZmlsbFN0eWxlID0gdGhpcy5kYXRhW2ldID49IDAgPyBwcm9wWydjaGFydC5jb2xvcnMnXVswXSA6IHByb3BbJ2NoYXJ0LmNvbG9ycyddWzFdO2lmIChwcm9wWydjaGFydC5zaGFkb3cnXSkge1xuICAgICAgICBSRy5zZXRTaGFkb3codGhpcywgcHJvcFsnY2hhcnQuc2hhZG93LmNvbG9yJ10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR4J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5vZmZzZXR5J10sIHByb3BbJ2NoYXJ0LnNoYWRvdy5ibHVyJ10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUkcubm9TaGFkb3codGhpcyk7XG4gICAgICB9XG4gICAgICBjby5yZWN0KHgsIG1hLmZsb29yKHkpLCB3LCBtYS5mbG9vcihoKSk7dGhpcy5jb29yZHMucHVzaChbeCwgeSwgdywgaF0pO3J1bm5pbmdUb3RhbCArPSB0aGlzLmRhdGFbaV07Y28uc3Ryb2tlKCk7Y28uZmlsbCgpO1xuICAgIH1cbiAgICB0aGlzLnRvdGFsID0gcnVubmluZ1RvdGFsO2lmIChwcm9wWydjaGFydC50b3RhbCddKSB7XG4gICAgICBoID0gdGhpcy5nZXRZQ29vcmQoMCkgLSB0aGlzLmdldFlDb29yZChtYS5hYnMocnVubmluZ1RvdGFsKSk7aWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9IHJ1bm5pbmdUb3RhbCA+IDAgPyB0aGlzLmdldFlDb29yZCgwKSAtIGggOiB0aGlzLmdldFlDb29yZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChydW5uaW5nVG90YWwgPiAwKSB7XG4gICAgICAgICAgeSA9IHRoaXMuZ2V0WUNvb3JkKDApIC0gaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5ID0gdGhpcy5nZXRZQ29vcmQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHggPSB4ICsgcHJvcFsnY2hhcnQuaG1hcmdpbiddICogMiArIHc7Y28uZmlsbFN0eWxlID0gcHJvcFsnY2hhcnQuY29sb3JzJ11bMl07cGEyKGNvLCAnYiByICUgJSAlICUgcyAlIGYgJScsIHgsIHksIHcsIGgsIGNvLnN0cm9rZVN0eWxlLCBjby5maWxsU3R5bGUpO3ZhciBwcmV2aW91c0Nvb3JkcyA9IFt4LCB5LCB3LCBtYS5hYnMoaCldO3RoaXMuY29vcmRzLnB1c2gocHJldmlvdXNDb29yZHMpO1xuICAgIH1cbiAgICBSRy5ub1NoYWRvdyh0aGlzKTtjby5saW5lV2lkdGggPSAxO2NvLnN0cm9rZVN0eWxlID0gJyM2NjYnO2NvLmJlZ2luUGF0aCgpO2ZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLmNvb3Jkc1tpIC0gMV0sXG4gICAgICAgICAgY3VyciA9IHRoaXMuY29vcmRzW2ldLFxuICAgICAgICAgIHByZXZEYXRhID0gdGhpcy5kYXRhW2kgLSAxXTtcbiAgICAgIHZhciB5ID0gcHJldkRhdGEgPiAwID8gcHJldlsxXSA6IHByZXZbMV0gKyBwcmV2WzNdO2NvLm1vdmVUbyhwcmV2WzBdICsgcHJldlsyXSwgeSk7Y28ubGluZVRvKGN1cnJbMF0sIHByZXZEYXRhID4gMCA/IHByZXZbMV0gOiBwcmV2WzFdICsgcHJldlszXSk7XG4gICAgfVxuICAgIGNvLnN0cm9rZSgpO1xuICB9O3RoaXMuZ2V0U2hhcGUgPSB0aGlzLmdldEJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbW91c2VYWSA9IFJHLmdldE1vdXNlWFkoZSksXG4gICAgICAgICAgbW91c2VYID0gbW91c2VYWVswXSxcbiAgICAgICAgICBtb3VzZVkgPSBtb3VzZVhZWzFdO3ZhciBsZWZ0ID0gdGhpcy5jb29yZHNbaV1bMF0sXG4gICAgICAgICAgdG9wID0gdGhpcy5jb29yZHNbaV1bMV0sXG4gICAgICAgICAgd2lkdGggPSB0aGlzLmNvb3Jkc1tpXVsyXSxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmNvb3Jkc1tpXVszXTtpZiAobW91c2VYID49IGxlZnQgJiYgbW91c2VYIDw9IGxlZnQgKyB3aWR0aCAmJiBtb3VzZVkgPj0gdG9wICYmIG1vdXNlWSA8PSB0b3AgKyBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBSRy5wYXJzZVRvb2x0aXBUZXh0KHByb3BbJ2NoYXJ0LnRvb2x0aXBzJ10sIGkpO3JldHVybiB7IDA6IHRoaXMsIG9iamVjdDogdGhpcywgMTogbGVmdCwgeDogbGVmdCwgMjogdG9wLCB5OiB0b3AsIDM6IHdpZHRoLCB3aWR0aDogd2lkdGgsIDQ6IGhlaWdodCwgaGVpZ2h0OiBoZWlnaHQsIDU6IGksIGluZGV4OiBpLCB0b29sdGlwOiB0b29sdGlwIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O3RoaXMuZ2V0TWF4ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcnVubmluZ1RvdGFsID0gMCxcbiAgICAgICAgbWF4ID0gMDtmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcnVubmluZ1RvdGFsICs9IGRhdGFbaV07bWF4ID0gbWEubWF4KG1hLmFicyhydW5uaW5nVG90YWwpLCBtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gbWEuYWJzKG1heCk7XG4gIH07dGhpcy5hbGxvd1Rvb2x0aXBzID0gdGhpcy5BbGxvd1Rvb2x0aXBzID0gZnVuY3Rpb24gKCkge1xuICAgIFJHLlByZUxvYWRUb29sdGlwSW1hZ2VzKHRoaXMpO1JHLkluc3RhbGxXaW5kb3dNb3VzZWRvd25Ub29sdGlwTGlzdGVuZXIodGhpcyk7UkcuSW5zdGFsbENhbnZhc01vdXNlbW92ZVRvb2x0aXBMaXN0ZW5lcih0aGlzKTtSRy5JbnN0YWxsQ2FudmFzTW91c2V1cFRvb2x0aXBMaXN0ZW5lcih0aGlzKTtcbiAgfTt0aGlzLmhpZ2hsaWdodCA9IHRoaXMuSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wWydjaGFydC5oaWdobGlnaHQuc3R5bGUnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFsnY2hhcnQuaGlnaGxpZ2h0LnN0eWxlJ10oc2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSRy5IaWdobGlnaHQuUmVjdCh0aGlzLCBzaGFwZSk7XG4gICAgfVxuICB9O3RoaXMuZ2V0T2JqZWN0QnlYWSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlWFkgPSBSRy5nZXRNb3VzZVhZKGUpO2lmIChtb3VzZVhZWzBdID4gdGhpcy5ndXR0ZXJMZWZ0ICYmIG1vdXNlWFlbMF0gPCBjYS53aWR0aCAtIHRoaXMuZ3V0dGVyUmlnaHQgJiYgbW91c2VYWVsxXSA+IHRoaXMuZ3V0dGVyVG9wICYmIG1vdXNlWFlbMV0gPCBjYS5oZWlnaHQgLSB0aGlzLmd1dHRlckJvdHRvbSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O3RoaXMuZ2V0WUNvb3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHByb3BbJ2NoYXJ0LnhheGlzcG9zJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA8IC0xICogdGhpcy5tYXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY29vcmQgPSB2YWx1ZSAvIHRoaXMubWF4ICogKHRoaXMuZ3JhcGhhcmVhIC8gMik7cmV0dXJuIHRoaXMuZ3V0dGVyVG9wICsgdGhpcy5ncmFwaGFyZWEgLyAyIC0gY29vcmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb29yZCA9ICh2YWx1ZSAtIHRoaXMuc2NhbGUyLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLnNjYWxlMi5taW4pICogdGhpcy5ncmFwaGFyZWE7Y29vcmQgPSBjb29yZCArIHRoaXMuZ3V0dGVyQm90dG9tO3JldHVybiBjYS5oZWlnaHQgLSBjb29yZDtcbiAgICB9XG4gIH07dGhpcy5wYXJzZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbF9jb2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuY29sb3JzJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmtleS5jb2xvcnMnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmtleS5jb2xvcnMnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmNyb3NzaGFpcnMuY29sb3InXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10gPSBSRy5hcnJheV9jbG9uZShwcm9wWydjaGFydC5oaWdobGlnaHQuZmlsbCddKTt0aGlzLm9yaWdpbmFsX2NvbG9yc1snY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjEnXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmJhY2tncm91bmQuZ3JpZC5jb2xvciddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10pO3RoaXMub3JpZ2luYWxfY29sb3JzWydjaGFydC5zdHJva2VzdHlsZSddID0gUkcuYXJyYXlfY2xvbmUocHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSk7dGhpcy5vcmlnaW5hbF9jb2xvcnNbJ2NoYXJ0LmF4aXMuY29sb3InXSA9IFJHLmFycmF5X2Nsb25lKHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5jb2xvcnMnXTtpZiAoY29sb3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29sb3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbG9yc1tpXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KGNvbG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb2xvcnMgPSBwcm9wWydjaGFydC5rZXkuY29sb3JzJ107aWYgKGNvbG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb2xvcnNbaV0gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChjb2xvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5jcm9zc2hhaXJzLmNvbG9yJ10pO3Byb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5zdHJva2UnXSk7cHJvcFsnY2hhcnQuaGlnaGxpZ2h0LmZpbGwnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmhpZ2hsaWdodC5maWxsJ10pO3Byb3BbJ2NoYXJ0LmJhY2tncm91bmQuYmFyY29sb3IxJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMSddKTtwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmJhcmNvbG9yMiddID0gdGhpcy5wYXJzZVNpbmdsZUNvbG9yRm9yR3JhZGllbnQocHJvcFsnY2hhcnQuYmFja2dyb3VuZC5iYXJjb2xvcjInXSk7cHJvcFsnY2hhcnQuYmFja2dyb3VuZC5ncmlkLmNvbG9yJ10gPSB0aGlzLnBhcnNlU2luZ2xlQ29sb3JGb3JHcmFkaWVudChwcm9wWydjaGFydC5iYWNrZ3JvdW5kLmdyaWQuY29sb3InXSk7cHJvcFsnY2hhcnQuc3Ryb2tlc3R5bGUnXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LnN0cm9rZXN0eWxlJ10pO3Byb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSA9IHRoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50KHByb3BbJ2NoYXJ0LmF4aXMuY29sb3InXSk7XG4gIH07dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHt9O3RoaXMucGFyc2VTaW5nbGVDb2xvckZvckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvciB8fCB0eXBlb2YgY29sb3IgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubWF0Y2goL15ncmFkaWVudFxcKCguKilcXCkkL2kpKSB7XG4gICAgICB2YXIgcGFydHMgPSBSZWdFeHAuJDEuc3BsaXQoJzonKTt2YXIgZ3JhZCA9IGNvLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIGNhLmhlaWdodCAtIHByb3BbJ2NoYXJ0Lmd1dHRlci5ib3R0b20nXSwgMCwgcHJvcFsnY2hhcnQuZ3V0dGVyLnRvcCddKTt2YXIgZGlmZiA9IDEgLyAocGFydHMubGVuZ3RoIC0gMSk7Z3JhZC5hZGRDb2xvclN0b3AoMCwgUkcudHJpbShwYXJ0c1swXSkpO2ZvciAodmFyIGogPSAxLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChqICogZGlmZiwgUkcudHJpbShwYXJ0c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZCA/IGdyYWQgOiBjb2xvcjtcbiAgfTt0aGlzLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICBpZiAodHlwZS5zdWJzdHIoMCwgMikgIT09ICdvbicpIHtcbiAgICAgIHR5cGUgPSAnb24nICsgdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzW3R5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW3R5cGVdID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgUkcuYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07dGhpcy5maXJzdERyYXdGdW5jID0gZnVuY3Rpb24gKCkge307dGhpcy5ncm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHQgPSBhcmd1bWVudHNbMF0gfHwge307dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdIHx8IGZ1bmN0aW9uICgpIHt9O3ZhciBmcmFtZXMgPSBvcHQuZnJhbWVzIHx8IDMwO3ZhciBudW1GcmFtZSA9IDA7dmFyIG9iaiA9IHRoaXM7dmFyIGRhdGEgPSBSRy5hcnJheV9jbG9uZShvYmouZGF0YSk7Zm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBvYmouZGF0YVtpXSAvPSBmcmFtZXM7XG4gICAgfVxuICAgIGlmIChvYmouR2V0KCdjaGFydC55bWF4JykgPT0gbnVsbCkge1xuICAgICAgdmFyIG1heCA9IG9iai5nZXRNYXgoZGF0YSk7dmFyIHNjYWxlMiA9IFJHLmdldFNjYWxlMihvYmosIHsgJ21heCc6IG1heCB9KTtvYmouU2V0KCdjaGFydC55bWF4Jywgc2NhbGUyLm1heCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBvYmouZGF0YVtpXSA9IGRhdGFbaV0gKiBSRy5FZmZlY3RzLmdldEVhc2luZ011bHRpcGxpZXIoZnJhbWVzLCBudW1GcmFtZSk7XG4gICAgICB9XG4gICAgICBSR3JhcGguY2xlYXIob2JqLmNhbnZhcyk7UkdyYXBoLnJlZHJhd0NhbnZhcyhvYmouY2FudmFzKTtpZiAoKytudW1GcmFtZSA8IGZyYW1lcykge1xuICAgICAgICBSR3JhcGguRWZmZWN0cy51cGRhdGVDYW52YXMoaXRlcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0b3IoKTtyZXR1cm4gdGhpcztcbiAgfTtSRy5hdHQoY2EpO1JHLlJlZ2lzdGVyKHRoaXMpO2lmIChwYXJzZUNvbmZPYmplY3RGb3JPcHRpb25zKSB7XG4gICAgUkcucGFyc2VPYmplY3RTdHlsZUNvbmZpZyh0aGlzLCBjb25mLm9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL290aGVyX2NvbXBvbmVudHMvcmdyYXBoL2xpYnJhcmllcy9SR3JhcGgud2F0ZXJmYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///222\n")}]),[161]);